{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"#ifdef USE_IBL_LIGHTING\\n\\\nvec3 computeIBL(vec3 position, vec3 normal, vec3 lightDirection, vec3 lightColorHdr, czm_modelMaterial material)\\n\\\n{\\n\\\n    #if defined(DIFFUSE_IBL) || defined(SPECULAR_IBL)\\n\\\n        // Environment maps were provided, use them for IBL\\n\\\n        vec3 viewDirection = -normalize(position);\\n\\\n        vec3 iblColor = textureIBL(viewDirection, normal, material);\\n\\\n        return iblColor;\\n\\\n    #endif\\n\\\n    \\n\\\n    return vec3(0.0);\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#ifdef USE_CLEARCOAT\\n\\\nvec3 addClearcoatReflection(vec3 baseLayerColor, vec3 position, vec3 lightDirection, vec3 lightColorHdr, czm_modelMaterial material)\\n\\\n{\\n\\\n    vec3 viewDirection = -normalize(position);\\n\\\n    vec3 halfwayDirection = normalize(viewDirection + lightDirection);\\n\\\n    vec3 normal = material.clearcoatNormal;\\n\\\n    float NdotL = clamp(dot(normal, lightDirection), 0.001, 1.0);\\n\\\n\\n\\\n    // clearcoatF0 = vec3(pow((ior - 1.0) / (ior + 1.0), 2.0)), but without KHR_materials_ior, ior is a constant 1.5.\\n\\\n    vec3 f0 = vec3(0.04);\\n\\\n    vec3 f90 = vec3(1.0);\\n\\\n    // Note: clearcoat Fresnel computed with dot(n, v) instead of dot(v, h).\\n\\\n    // This is to make it energy conserving with a simple layering function.\\n\\\n    float NdotV = clamp(dot(normal, viewDirection), 0.0, 1.0);\\n\\\n    vec3 F = fresnelSchlick2(f0, f90, NdotV);\\n\\\n\\n\\\n    // compute specular reflection from direct lighting\\n\\\n    float roughness = material.clearcoatRoughness;\\n\\\n    float alphaRoughness = roughness * roughness;\\n\\\n    float directStrength = computeDirectSpecularStrength(normal, lightDirection, viewDirection, halfwayDirection, alphaRoughness);\\n\\\n    vec3 directReflection = F * directStrength * NdotL;\\n\\\n    vec3 color = lightColorHdr * directReflection;\\n\\\n\\n\\\n    #ifdef SPECULAR_IBL\\n\\\n        // Find the direction in which to sample the environment map\\n\\\n        vec3 reflectMC = normalize(model_iblReferenceFrameMatrix * reflect(-viewDirection, normal));\\n\\\n        vec3 iblColor = computeSpecularIBL(reflectMC, NdotV, f0, roughness);\\n\\\n        color += iblColor * material.occlusion;\\n\\\n    #endif\\n\\\n\\n\\\n    float clearcoatFactor = material.clearcoatFactor;\\n\\\n    vec3 clearcoatColor = color * clearcoatFactor;\\n\\\n\\n\\\n    // Dim base layer based on transmission loss through clearcoat\\n\\\n    return baseLayerColor * (1.0 - clearcoatFactor * F) + clearcoatColor;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#if defined(LIGHTING_PBR) && defined(HAS_NORMALS)\\n\\\nvec3 computePbrLighting(in czm_modelMaterial material, in vec3 position)\\n\\\n{\\n\\\n    #ifdef USE_CUSTOM_LIGHT_COLOR\\n\\\n        vec3 lightColorHdr = model_lightColorHdr;\\n\\\n    #else\\n\\\n        vec3 lightColorHdr = czm_lightColorHdr;\\n\\\n    #endif\\n\\\n\\n\\\n    vec3 viewDirection = -normalize(position);\\n\\\n    vec3 normal = material.normalEC;\\n\\\n    vec3 lightDirection = normalize(czm_lightDirectionEC);\\n\\\n\\n\\\n    vec3 directLighting = czm_pbrLighting(viewDirection, normal, lightDirection, material);\\n\\\n    vec3 directColor = lightColorHdr * directLighting;\\n\\\n\\n\\\n    // Accumulate colors from base layer\\n\\\n    vec3 color = directColor + material.emissive;\\n\\\n    #ifdef USE_IBL_LIGHTING\\n\\\n        color += computeIBL(position, normal, lightDirection, lightColorHdr, material);\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef USE_CLEARCOAT\\n\\\n        color = addClearcoatReflection(color, position, lightDirection, lightColorHdr, material);\\n\\\n    #endif\\n\\\n\\n\\\n    return color;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n/**\\n\\\n * Compute the material color under the current lighting conditions.\\n\\\n * All other material properties are passed through so further stages\\n\\\n * have access to them.\\n\\\n *\\n\\\n * @param {czm_modelMaterial} material The material properties from {@MaterialStageFS}\\n\\\n * @param {ProcessedAttributes} attributes\\n\\\n */\\n\\\nvoid lightingStage(inout czm_modelMaterial material, ProcessedAttributes attributes)\\n\\\n{\\n\\\n    #ifdef LIGHTING_PBR\\n\\\n        #ifdef HAS_NORMALS\\n\\\n            vec3 color = computePbrLighting(material, attributes.positionEC);\\n\\\n        #else\\n\\\n            vec3 color = material.diffuse * material.occlusion + material.emissive;\\n\\\n        #endif\\n\\\n        // In HDR mode, the frame buffer is in linear color space. The\\n\\\n        // post-processing stages (see PostProcessStageCollection) will handle\\n\\\n        // tonemapping. However, if HDR is not enabled, we must tonemap else large\\n\\\n        // values may be clamped to 1.0\\n\\\n        #ifndef HDR\\n\\\n            color = czm_pbrNeutralTonemapping(color);\\n\\\n        #endif\\n\\\n    #else // unlit\\n\\\n        vec3 color = material.diffuse;\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_POINT_CLOUD_COLOR_STYLE\\n\\\n        // The colors resulting from point cloud styles are adjusted differently.\\n\\\n        color = czm_gammaCorrect(color);\\n\\\n    #elif !defined(HDR)\\n\\\n        // If HDR is not enabled, the frame buffer stores sRGB colors rather than\\n\\\n        // linear colors so the linear value must be converted.\\n\\\n        color = czm_linearToSrgb(color);\\n\\\n    #endif\\n\\\n\\n\\\n    material.diffuse = color;\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Shaders/Model/LightingStageFS.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"#ifdef USE_IBL_LIGHTING\\n\\\nvec3 computeIBL(vec3 position, vec3 normal, vec3 lightDirection, vec3 lightColorHdr, czm_modelMaterial material)\\n\\\n{\\n\\\n    #if defined(DIFFUSE_IBL) || defined(SPECULAR_IBL)\\n\\\n        // Environment maps were provided, use them for IBL\\n\\\n        vec3 viewDirection = -normalize(position);\\n\\\n        vec3 iblColor = textureIBL(viewDirection, normal, material);\\n\\\n        return iblColor;\\n\\\n    #endif\\n\\\n    \\n\\\n    return vec3(0.0);\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#ifdef USE_CLEARCOAT\\n\\\nvec3 addClearcoatReflection(vec3 baseLayerColor, vec3 position, vec3 lightDirection, vec3 lightColorHdr, czm_modelMaterial material)\\n\\\n{\\n\\\n    vec3 viewDirection = -normalize(position);\\n\\\n    vec3 halfwayDirection = normalize(viewDirection + lightDirection);\\n\\\n    vec3 normal = material.clearcoatNormal;\\n\\\n    float NdotL = clamp(dot(normal, lightDirection), 0.001, 1.0);\\n\\\n\\n\\\n    // clearcoatF0 = vec3(pow((ior - 1.0) / (ior + 1.0), 2.0)), but without KHR_materials_ior, ior is a constant 1.5.\\n\\\n    vec3 f0 = vec3(0.04);\\n\\\n    vec3 f90 = vec3(1.0);\\n\\\n    // Note: clearcoat Fresnel computed with dot(n, v) instead of dot(v, h).\\n\\\n    // This is to make it energy conserving with a simple layering function.\\n\\\n    float NdotV = clamp(dot(normal, viewDirection), 0.0, 1.0);\\n\\\n    vec3 F = fresnelSchlick2(f0, f90, NdotV);\\n\\\n\\n\\\n    // compute specular reflection from direct lighting\\n\\\n    float roughness = material.clearcoatRoughness;\\n\\\n    float alphaRoughness = roughness * roughness;\\n\\\n    float directStrength = computeDirectSpecularStrength(normal, lightDirection, viewDirection, halfwayDirection, alphaRoughness);\\n\\\n    vec3 directReflection = F * directStrength * NdotL;\\n\\\n    vec3 color = lightColorHdr * directReflection;\\n\\\n\\n\\\n    #ifdef SPECULAR_IBL\\n\\\n        // Find the direction in which to sample the environment map\\n\\\n        vec3 reflectMC = normalize(model_iblReferenceFrameMatrix * reflect(-viewDirection, normal));\\n\\\n        vec3 iblColor = computeSpecularIBL(reflectMC, NdotV, f0, roughness);\\n\\\n        color += iblColor * material.occlusion;\\n\\\n    #endif\\n\\\n\\n\\\n    float clearcoatFactor = material.clearcoatFactor;\\n\\\n    vec3 clearcoatColor = color * clearcoatFactor;\\n\\\n\\n\\\n    // Dim base layer based on transmission loss through clearcoat\\n\\\n    return baseLayerColor * (1.0 - clearcoatFactor * F) + clearcoatColor;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#if defined(LIGHTING_PBR) && defined(HAS_NORMALS)\\n\\\nvec3 computePbrLighting(in czm_modelMaterial material, in vec3 position)\\n\\\n{\\n\\\n    #ifdef USE_CUSTOM_LIGHT_COLOR\\n\\\n        vec3 lightColorHdr = model_lightColorHdr;\\n\\\n    #else\\n\\\n        vec3 lightColorHdr = czm_lightColorHdr;\\n\\\n    #endif\\n\\\n\\n\\\n    vec3 viewDirection = -normalize(position);\\n\\\n    vec3 normal = material.normalEC;\\n\\\n    vec3 lightDirection = normalize(czm_lightDirectionEC);\\n\\\n\\n\\\n    vec3 directLighting = czm_pbrLighting(viewDirection, normal, lightDirection, material);\\n\\\n    vec3 directColor = lightColorHdr * directLighting;\\n\\\n\\n\\\n    // Accumulate colors from base layer\\n\\\n    vec3 color = directColor + material.emissive;\\n\\\n    #ifdef USE_IBL_LIGHTING\\n\\\n        color += computeIBL(position, normal, lightDirection, lightColorHdr, material);\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef USE_CLEARCOAT\\n\\\n        color = addClearcoatReflection(color, position, lightDirection, lightColorHdr, material);\\n\\\n    #endif\\n\\\n\\n\\\n    return color;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n/**\\n\\\n * Compute the material color under the current lighting conditions.\\n\\\n * All other material properties are passed through so further stages\\n\\\n * have access to them.\\n\\\n *\\n\\\n * @param {czm_modelMaterial} material The material properties from {@MaterialStageFS}\\n\\\n * @param {ProcessedAttributes} attributes\\n\\\n */\\n\\\nvoid lightingStage(inout czm_modelMaterial material, ProcessedAttributes attributes)\\n\\\n{\\n\\\n    #ifdef LIGHTING_PBR\\n\\\n        #ifdef HAS_NORMALS\\n\\\n            vec3 color = computePbrLighting(material, attributes.positionEC);\\n\\\n        #else\\n\\\n            vec3 color = material.diffuse * material.occlusion + material.emissive;\\n\\\n        #endif\\n\\\n        // In HDR mode, the frame buffer is in linear color space. The\\n\\\n        // post-processing stages (see PostProcessStageCollection) will handle\\n\\\n        // tonemapping. However, if HDR is not enabled, we must tonemap else large\\n\\\n        // values may be clamped to 1.0\\n\\\n        #ifndef HDR\\n\\\n            color = czm_pbrNeutralTonemapping(color);\\n\\\n        #endif\\n\\\n    #else // unlit\\n\\\n        vec3 color = material.diffuse;\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_POINT_CLOUD_COLOR_STYLE\\n\\\n        // The colors resulting from point cloud styles are adjusted differently.\\n\\\n        color = czm_gammaCorrect(color);\\n\\\n    #elif !defined(HDR)\\n\\\n        // If HDR is not enabled, the frame buffer stores sRGB colors rather than\\n\\\n        // linear colors so the linear value must be converted.\\n\\\n        color = czm_linearToSrgb(color);\\n\\\n    #endif\\n\\\n\\n\\\n    material.diffuse = color;\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}