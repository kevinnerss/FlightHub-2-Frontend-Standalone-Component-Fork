{"ast":null,"code":"import defined from \"../../Core/defined.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\n/**\n * The dequantization stage generates shader code to dequantize attributes\n * in the vertex shader\n *\n * @namespace DequantizationPipelineStage\n *\n * @private\n */\nconst DequantizationPipelineStage = {\n  name: \"DequantizationPipelineStage\",\n  // Helps with debugging\n\n  FUNCTION_ID_DEQUANTIZATION_STAGE_VS: \"dequantizationStage\",\n  FUNCTION_SIGNATURE_DEQUANTIZATION_STAGE_VS: \"void dequantizationStage(inout ProcessedAttributes attributes)\"\n};\n\n/**\n * Process a primitive with quantized attributes. This stage modifies the\n * following parts of the render resources:\n * <ul>\n *  <li>generates dequantization function and adds it to the shader</li>\n *  <li>adds any uniforms needed for dequantization to the shader and uniform map</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nDequantizationPipelineStage.process = function (renderResources, primitive, frameState) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const model = renderResources.model;\n  const hasClassification = defined(model.classificationType);\n  shaderBuilder.addDefine(\"USE_DEQUANTIZATION\", undefined, ShaderDestination.VERTEX);\n  shaderBuilder.addFunction(DequantizationPipelineStage.FUNCTION_ID_DEQUANTIZATION_STAGE_VS, DequantizationPipelineStage.FUNCTION_SIGNATURE_DEQUANTIZATION_STAGE_VS, ShaderDestination.VERTEX);\n  const attributes = primitive.attributes;\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    const quantization = attribute.quantization;\n    if (!defined(quantization)) {\n      // Non-quantized attributes were already handled in GeometryPipelineStage\n      continue;\n    }\n\n    // Only the position and texcoord attributes are used for classification models.\n    const isPositionAttribute = attribute.semantic === VertexAttributeSemantic.POSITION;\n    const isTexcoordAttribute = attribute.semantic === VertexAttributeSemantic.TEXCOORD;\n    if (hasClassification && !isPositionAttribute && !isTexcoordAttribute) {\n      continue;\n    }\n    const attributeInfo = ModelUtility.getAttributeInfo(attribute);\n    updateDequantizationFunction(shaderBuilder, attributeInfo);\n    addDequantizationUniforms(renderResources, attributeInfo);\n  }\n};\nfunction addDequantizationUniforms(renderResources, attributeInfo) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const uniformMap = renderResources.uniformMap;\n  const variableName = attributeInfo.variableName;\n  const quantization = attributeInfo.attribute.quantization;\n  if (quantization.octEncoded) {\n    const normalizationRange = `model_normalizationRange_${variableName}`;\n    shaderBuilder.addUniform(\"float\", normalizationRange, ShaderDestination.VERTEX);\n    uniformMap[normalizationRange] = function () {\n      return quantization.normalizationRange;\n    };\n  } else {\n    const offset = `model_quantizedVolumeOffset_${variableName}`;\n    const stepSize = `model_quantizedVolumeStepSize_${variableName}`;\n    const glslType = attributeInfo.glslType;\n    shaderBuilder.addUniform(glslType, offset, ShaderDestination.VERTEX);\n    shaderBuilder.addUniform(glslType, stepSize, ShaderDestination.VERTEX);\n    let quantizedVolumeOffset = quantization.quantizedVolumeOffset;\n    let quantizedVolumeStepSize = quantization.quantizedVolumeStepSize;\n\n    // COLOR_n is promoted to a vec4 in the shader, so the alpha value\n    // defaults to 1. For correctness, the quantization uniforms must be\n    // promoted to vec4s. The alpha values are chosen so the alpha\n    // dequantization is the identity, i.e. 0.0 + 1.0 * color.a\n    if (/^color_\\d+$/.test(variableName)) {\n      quantizedVolumeOffset = promoteToVec4(quantizedVolumeOffset, 0);\n      quantizedVolumeStepSize = promoteToVec4(quantizedVolumeStepSize, 1);\n    }\n    uniformMap[offset] = function () {\n      return quantizedVolumeOffset;\n    };\n    uniformMap[stepSize] = function () {\n      return quantizedVolumeStepSize;\n    };\n  }\n}\nfunction promoteToVec4(value, defaultAlpha) {\n  if (value instanceof Cartesian4) {\n    return value;\n  }\n  return new Cartesian4(value.x, value.y, value.z, defaultAlpha);\n}\nfunction updateDequantizationFunction(shaderBuilder, attributeInfo) {\n  const variableName = attributeInfo.variableName;\n  const quantization = attributeInfo.attribute.quantization;\n  let line;\n  if (quantization.octEncoded) {\n    line = generateOctDecodeLine(variableName, quantization);\n  } else {\n    line = generateDequantizeLine(variableName);\n  }\n  shaderBuilder.addFunctionLines(DequantizationPipelineStage.FUNCTION_ID_DEQUANTIZATION_STAGE_VS, [line]);\n}\nfunction generateOctDecodeLine(variableName, quantization) {\n  const structField = `attributes.${variableName}`;\n  const quantizedAttribute = `a_quantized_${variableName}`;\n  const normalizationRange = `model_normalizationRange_${variableName}`;\n\n  // Draco stores things as .zxy instead of xyz, so be explicit about the\n  // swizzle to avoid confusion\n  const swizzle = quantization.octEncodedZXY ? \".zxy\" : \".xyz\";\n\n  // This generates lines such as:\n  // attributes.normal = czm_octDecode(a_quantized_normal, model_normalizationRange_normal).zxy;\n  return `${structField} = czm_octDecode(${quantizedAttribute}, ${normalizationRange})${swizzle};`;\n}\nfunction generateDequantizeLine(variableName) {\n  const structField = `attributes.${variableName}`;\n  const quantizedAttribute = `a_quantized_${variableName}`;\n  const offset = `model_quantizedVolumeOffset_${variableName}`;\n  const stepSize = `model_quantizedVolumeStepSize_${variableName}`;\n\n  // This generates lines such as:\n  // attributes.texCoord_0 = model_quantizedVolumeOffset_texCoord_0 + a_quantized_texCoord_0 * model_quantizedVolumeStepSize;\n  return `${structField} = ${offset} + ${quantizedAttribute} * ${stepSize};`;\n}\nexport default DequantizationPipelineStage;","map":{"version":3,"names":["defined","Cartesian4","ShaderDestination","ModelUtility","VertexAttributeSemantic","DequantizationPipelineStage","name","FUNCTION_ID_DEQUANTIZATION_STAGE_VS","FUNCTION_SIGNATURE_DEQUANTIZATION_STAGE_VS","process","renderResources","primitive","frameState","shaderBuilder","model","hasClassification","classificationType","addDefine","undefined","VERTEX","addFunction","attributes","i","length","attribute","quantization","isPositionAttribute","semantic","POSITION","isTexcoordAttribute","TEXCOORD","attributeInfo","getAttributeInfo","updateDequantizationFunction","addDequantizationUniforms","uniformMap","variableName","octEncoded","normalizationRange","addUniform","offset","stepSize","glslType","quantizedVolumeOffset","quantizedVolumeStepSize","test","promoteToVec4","value","defaultAlpha","x","y","z","line","generateOctDecodeLine","generateDequantizeLine","addFunctionLines","structField","quantizedAttribute","swizzle","octEncodedZXY"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Model/DequantizationPipelineStage.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\n/**\n * The dequantization stage generates shader code to dequantize attributes\n * in the vertex shader\n *\n * @namespace DequantizationPipelineStage\n *\n * @private\n */\nconst DequantizationPipelineStage = {\n  name: \"DequantizationPipelineStage\", // Helps with debugging\n\n  FUNCTION_ID_DEQUANTIZATION_STAGE_VS: \"dequantizationStage\",\n  FUNCTION_SIGNATURE_DEQUANTIZATION_STAGE_VS:\n    \"void dequantizationStage(inout ProcessedAttributes attributes)\",\n};\n\n/**\n * Process a primitive with quantized attributes. This stage modifies the\n * following parts of the render resources:\n * <ul>\n *  <li>generates dequantization function and adds it to the shader</li>\n *  <li>adds any uniforms needed for dequantization to the shader and uniform map</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nDequantizationPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const model = renderResources.model;\n  const hasClassification = defined(model.classificationType);\n\n  shaderBuilder.addDefine(\n    \"USE_DEQUANTIZATION\",\n    undefined,\n    ShaderDestination.VERTEX,\n  );\n\n  shaderBuilder.addFunction(\n    DequantizationPipelineStage.FUNCTION_ID_DEQUANTIZATION_STAGE_VS,\n    DequantizationPipelineStage.FUNCTION_SIGNATURE_DEQUANTIZATION_STAGE_VS,\n    ShaderDestination.VERTEX,\n  );\n\n  const attributes = primitive.attributes;\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    const quantization = attribute.quantization;\n    if (!defined(quantization)) {\n      // Non-quantized attributes were already handled in GeometryPipelineStage\n      continue;\n    }\n\n    // Only the position and texcoord attributes are used for classification models.\n    const isPositionAttribute =\n      attribute.semantic === VertexAttributeSemantic.POSITION;\n    const isTexcoordAttribute =\n      attribute.semantic === VertexAttributeSemantic.TEXCOORD;\n    if (hasClassification && !isPositionAttribute && !isTexcoordAttribute) {\n      continue;\n    }\n\n    const attributeInfo = ModelUtility.getAttributeInfo(attribute);\n    updateDequantizationFunction(shaderBuilder, attributeInfo);\n    addDequantizationUniforms(renderResources, attributeInfo);\n  }\n};\n\nfunction addDequantizationUniforms(renderResources, attributeInfo) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const uniformMap = renderResources.uniformMap;\n  const variableName = attributeInfo.variableName;\n  const quantization = attributeInfo.attribute.quantization;\n\n  if (quantization.octEncoded) {\n    const normalizationRange = `model_normalizationRange_${variableName}`;\n    shaderBuilder.addUniform(\n      \"float\",\n      normalizationRange,\n      ShaderDestination.VERTEX,\n    );\n    uniformMap[normalizationRange] = function () {\n      return quantization.normalizationRange;\n    };\n  } else {\n    const offset = `model_quantizedVolumeOffset_${variableName}`;\n    const stepSize = `model_quantizedVolumeStepSize_${variableName}`;\n    const glslType = attributeInfo.glslType;\n    shaderBuilder.addUniform(glslType, offset, ShaderDestination.VERTEX);\n    shaderBuilder.addUniform(glslType, stepSize, ShaderDestination.VERTEX);\n\n    let quantizedVolumeOffset = quantization.quantizedVolumeOffset;\n    let quantizedVolumeStepSize = quantization.quantizedVolumeStepSize;\n\n    // COLOR_n is promoted to a vec4 in the shader, so the alpha value\n    // defaults to 1. For correctness, the quantization uniforms must be\n    // promoted to vec4s. The alpha values are chosen so the alpha\n    // dequantization is the identity, i.e. 0.0 + 1.0 * color.a\n    if (/^color_\\d+$/.test(variableName)) {\n      quantizedVolumeOffset = promoteToVec4(quantizedVolumeOffset, 0);\n      quantizedVolumeStepSize = promoteToVec4(quantizedVolumeStepSize, 1);\n    }\n\n    uniformMap[offset] = function () {\n      return quantizedVolumeOffset;\n    };\n\n    uniformMap[stepSize] = function () {\n      return quantizedVolumeStepSize;\n    };\n  }\n}\n\nfunction promoteToVec4(value, defaultAlpha) {\n  if (value instanceof Cartesian4) {\n    return value;\n  }\n\n  return new Cartesian4(value.x, value.y, value.z, defaultAlpha);\n}\n\nfunction updateDequantizationFunction(shaderBuilder, attributeInfo) {\n  const variableName = attributeInfo.variableName;\n  const quantization = attributeInfo.attribute.quantization;\n\n  let line;\n  if (quantization.octEncoded) {\n    line = generateOctDecodeLine(variableName, quantization);\n  } else {\n    line = generateDequantizeLine(variableName);\n  }\n\n  shaderBuilder.addFunctionLines(\n    DequantizationPipelineStage.FUNCTION_ID_DEQUANTIZATION_STAGE_VS,\n    [line],\n  );\n}\n\nfunction generateOctDecodeLine(variableName, quantization) {\n  const structField = `attributes.${variableName}`;\n\n  const quantizedAttribute = `a_quantized_${variableName}`;\n  const normalizationRange = `model_normalizationRange_${variableName}`;\n\n  // Draco stores things as .zxy instead of xyz, so be explicit about the\n  // swizzle to avoid confusion\n  const swizzle = quantization.octEncodedZXY ? \".zxy\" : \".xyz\";\n\n  // This generates lines such as:\n  // attributes.normal = czm_octDecode(a_quantized_normal, model_normalizationRange_normal).zxy;\n  return `${structField} = czm_octDecode(${quantizedAttribute}, ${normalizationRange})${swizzle};`;\n}\n\nfunction generateDequantizeLine(variableName) {\n  const structField = `attributes.${variableName}`;\n  const quantizedAttribute = `a_quantized_${variableName}`;\n  const offset = `model_quantizedVolumeOffset_${variableName}`;\n  const stepSize = `model_quantizedVolumeStepSize_${variableName}`;\n\n  // This generates lines such as:\n  // attributes.texCoord_0 = model_quantizedVolumeOffset_texCoord_0 + a_quantized_texCoord_0 * model_quantizedVolumeStepSize;\n  return `${structField} = ${offset} + ${quantizedAttribute} * ${stepSize};`;\n}\n\nexport default DequantizationPipelineStage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}