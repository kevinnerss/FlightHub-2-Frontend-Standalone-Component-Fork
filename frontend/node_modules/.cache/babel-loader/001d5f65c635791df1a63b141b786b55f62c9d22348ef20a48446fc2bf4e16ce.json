{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Check from \"../../Core/Check.js\";\nimport defined from \"../../Core/defined.js\";\nimport destroyObject from \"../../Core/destroyObject.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport ImageryConfiguration from \"./ImageryConfiguration.js\";\nimport ModelPrimitiveImagery from \"./ModelPrimitiveImagery.js\";\n\n/**\n * A class managing the draping of imagery on a <code>Model</code>.\n *\n * An instance of this class is created in the Model constructor. It will\n * create the data structures that carry the information that is required\n * for mapping imagery textures on model primitives.\n *\n * It offers two functions for managing the lifecycle of this draping process:\n *\n * The <code>update</code> function is called from the <code>Model.update</code>\n * function in each frame. It will create one <code>ModelPrimitiveImagery</code>\n * instance for each primitive that appears in the model, and call the\n * <code>update</code> function of these instances, respectively.\n *\n * The <code>ready</code> getter will be used to determine whether the\n * draping computations are done, and the update process of the <code>Model</code>\n * can continue, eventually causing the <code>model.ready</code> flag to\n * become <code>true</code>. The model imagery counts as \"ready\" when all\n * the imagery layers of the model are <code>ready</code>, and all the\n * <code>ModelPrimitiveImagery</code> instances are <code>ready</code>.\n *\n * @private\n */\nclass ModelImagery {\n  /**\n   * Creates a new instance\n   *\n   * @param {Model} model The model\n   * @throws {DeveloperError} If the model is not defined\n   */\n  constructor(model) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"model\", model);\n    //>>includeEnd('debug');\n\n    /**\n     * The model that this instance was created for.\n     *\n     * @type {Model}\n     * @readonly\n     * @private\n     */\n    this._model = model;\n\n    /**\n     * One <code<ModelPrimitiveImagery</code> for each primitive\n     * that appears in the model.\n     *\n     * Initially, this is <code>undefined</code>. When the <code>update</code>\n     * function is called and all imagery layers that are associated with the\n     * model are <code>ready</code>, this is initialized with one instance\n     * of a <code>ModelPrimitiveImagery</code> per runtime primitive (i.e. one for\n     * each <code>model.sceneGraph._runtimeNodes[n]._runtimePrimitives[p]</code>)\n     *\n     * @type {ModelPrimitiveImagery[]|undefined}\n     * @private\n     */\n    this._modelPrimitiveImageries = undefined;\n\n    /**\n     * One <code>ImageryConfiguration</code> object for each <code>ImageryLayer</code>\n     * that is associated with the model.\n     *\n     * This is used for determining whether the configuration (relevant property\n     * values) of an imagery layer has been changed since the previous\n     * <code>update</code> call, which should cause the draw commands of the\n     * model to be reset.\n     *\n     * @type {ImageryConfiguration[]}\n     * @private\n     */\n    this._imageryConfigurations = [];\n  }\n\n  /**\n   * The update function that is called from <code>Model.update</code> in\n   * each frame.\n   *\n   * This checks whether the imagery layer objects that are associated\n   * with the model are all <code>ready</code>. If they are not yet\n   * ready, then nothing is done.\n   *\n   * Otherwise, this just calls the <code>update</code> function of\n   * the <code>_modelPrimitiveImageries</code> (creating them if they had\n   * not been created yet).\n   *\n   * @param {FrameState} frameState The frame state\n   */\n  update(frameState) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"frameState\", frameState);\n    //>>includeEnd('debug');\n\n    if (!this._hasImagery) {\n      return;\n    }\n    if (!this._allImageryLayersReady) {\n      return;\n    }\n    if (!defined(this._modelPrimitiveImageries)) {\n      this._modelPrimitiveImageries = this._createModelPrimitiveImageries();\n    }\n    this._updateModelPrimitiveImageries(frameState);\n    this._checkForModifiedImageryConfigurations();\n  }\n\n  /**\n   * Creates the <code>ModelPrimitiveImagery</code> array that contains\n   * one <code>ModelPrimitiveImagery</code> for each primitive that is\n   * contained in the model.\n   *\n   * @returns {ModelPrimitiveImagery[]} The model primitive imageries\n   * @private\n   */\n  _createModelPrimitiveImageries() {\n    const model = this._model;\n    const runtimeNodesAndPrimitives = this._collectRuntimeNodesAndPrimitives();\n    const modelPrimitiveImageries = [];\n    const length = runtimeNodesAndPrimitives.length;\n    for (let i = 0; i < length; i++) {\n      const runtimeNodeAndPrimitive = runtimeNodesAndPrimitives[i];\n      const runtimeNode = runtimeNodeAndPrimitive.runtimeNode;\n      const runtimePrimitive = runtimeNodeAndPrimitive.runtimePrimitive;\n      const modelPrimitiveImagery = new ModelPrimitiveImagery(model, runtimeNode, runtimePrimitive);\n      runtimePrimitive.primitive.modelPrimitiveImagery = modelPrimitiveImagery;\n      modelPrimitiveImageries.push(modelPrimitiveImagery);\n    }\n    return modelPrimitiveImageries;\n  }\n\n  /**\n   * Computes all runtime nodes and primitives of the model.\n   *\n   * This is just the array that contains a\n   * <code>{ runtimeNode, runtimePrimitive }</code>\n   * for each\n   * <code>model.sceneGraph._runtimeNodes[n]._runtimePrimitives[p]</code>.\n   *\n   * @returns {object[]} The runtime nodes and primitives\n   * @private\n   */\n  _collectRuntimeNodesAndPrimitives() {\n    const model = this._model;\n    const sceneGraph = model.sceneGraph;\n    const runtimeNodes = sceneGraph._runtimeNodes;\n    const runtimeNodesAndPrimitives = [];\n    for (let i = 0; i < runtimeNodes.length; i++) {\n      const runtimeNode = runtimeNodes[i];\n      if (!defined(runtimeNode)) {\n        continue;\n      }\n      for (let j = 0; j < runtimeNode.runtimePrimitives.length; j++) {\n        const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n        runtimeNodesAndPrimitives.push({\n          runtimeNode: runtimeNode,\n          runtimePrimitive: runtimePrimitive\n        });\n      }\n    }\n    return runtimeNodesAndPrimitives;\n  }\n\n  /**\n   * Just calls <code>update</code> on each <code>ModelPrimitiveImagery</code>\n   * as part of the <code>update</code> of this class.\n   *\n   * @private\n   */\n  _updateModelPrimitiveImageries(frameState) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"frameState\", frameState);\n    //>>includeEnd('debug');\n\n    if (!defined(this._modelPrimitiveImageries)) {\n      throw new DeveloperError(\"The modelPrimitiveImageries have not been created\");\n    }\n    const modelPrimitiveImageries = this._modelPrimitiveImageries;\n    const length = modelPrimitiveImageries.length;\n    for (let i = 0; i < length; i++) {\n      const modelPrimitiveImagery = modelPrimitiveImageries[i];\n      modelPrimitiveImagery.update(frameState);\n    }\n  }\n\n  /**\n   * Destroy and delete all <code>ModelPrimitiveImagery</code> instances\n   * if they already have been created.\n   */\n  _deleteModelPrimitiveImageries() {\n    const modelPrimitiveImageries = this._modelPrimitiveImageries;\n    if (!defined(modelPrimitiveImageries)) {\n      return;\n    }\n    const length = modelPrimitiveImageries.length;\n    for (let i = 0; i < length; i++) {\n      const modelPrimitiveImagery = modelPrimitiveImageries[i];\n      modelPrimitiveImagery.destroy();\n    }\n    delete this._modelPrimitiveImageries;\n  }\n\n  /**\n   * Returns whether this instance is \"ready\".\n   *\n   * This means that all imagery layers that are associated with the model\n   * are <code>ready</code>, and all <code>ModelPrimitiveImagery</code>\n   * instances are <code>ready</code>.\n   *\n   * When this is <code>true</code>, then the mapping computations are\n   * complete and the structures containing the mapping information have\n   * been initialized. Otherwise, subsequent calls to <code>update</code>\n   * will perform the necessary computation until this getter eventually\n   * returns <code>true</code>.\n   *\n   * @returns {boolean} Whether this instance is \"ready\"\n   */\n  get ready() {\n    if (!this._hasImagery) {\n      return true;\n    }\n    if (!this._allImageryLayersReady) {\n      return false;\n    }\n    if (!this._allModelPrimitiveImageriesReady) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the model has imagery layers associated with it.\n   *\n   * @private\n   */\n  get _hasImagery() {\n    const model = this._model;\n    const imageryLayers = model.imageryLayers;\n    return defined(imageryLayers) && imageryLayers.length > 0;\n  }\n\n  /**\n   * Returns whether all imagery layers that are associated with the\n   * model are <code>ready</code>.\n   *\n   * If the model does not have imagery, then this always returns\n   * <code>true</code>. Otherwise, it returns whether each imagery\n   * layer is <code>ready</code>.\n   *\n   * @private\n   */\n  get _allImageryLayersReady() {\n    if (!this._hasImagery) {\n      return true;\n    }\n    const imageryLayers = this._model.imageryLayers;\n    const length = imageryLayers.length;\n    for (let i = 0; i < length; i++) {\n      const imageryLayer = imageryLayers.get(i);\n      if (!imageryLayer.ready) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether all <code>ModelPrimitiveImagery</code> instances\n   * are are <code>ready</code>.\n   *\n   * @private\n   */\n  get _allModelPrimitiveImageriesReady() {\n    const modelPrimitiveImageries = this._modelPrimitiveImageries;\n    if (!defined(modelPrimitiveImageries)) {\n      return false;\n    }\n    const length = modelPrimitiveImageries.length;\n    for (let i = 0; i < length; i++) {\n      const modelPrimitiveImagery = modelPrimitiveImageries[i];\n      if (!modelPrimitiveImagery.ready) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Check whether any of the settings of any imagery layer (like alpha\n   * or hue) has been changed since the last call to the <code>update</code>\n   * function.\n   *\n   * If this is the case, the draw commands of the model will be reset.\n   */\n  _checkForModifiedImageryConfigurations() {\n    if (this._imageryConfigurationsModified()) {\n      this._updateImageryConfigurations();\n      const model = this._model;\n      model.resetDrawCommands();\n    }\n  }\n\n  /**\n   * Returns whether any setting of an imagery layer (like alpha or hue) has\n   * been changed since the last time the <code>ImageryConfiguration</code>\n   * objects have been updated.\n   *\n   * @returns {boolean} Whether there was a modification\n   */\n  _imageryConfigurationsModified() {\n    const model = this._model;\n    const imageryLayers = model.imageryLayers;\n    const imageryConfigurations = this._imageryConfigurations;\n    if (imageryLayers.length !== imageryConfigurations.length) {\n      return true;\n    }\n    for (let i = 0; i < imageryLayers.length; i++) {\n      const imageryLayer = imageryLayers.get(i);\n      const imageryConfiguration = imageryConfigurations[i];\n      if (imageryLayer.show !== imageryConfiguration.show) {\n        return true;\n      }\n      if (imageryLayer.alpha !== imageryConfiguration.alpha) {\n        return true;\n      }\n      if (imageryLayer.brightness !== imageryConfiguration.brightness) {\n        return true;\n      }\n      if (imageryLayer.contrast !== imageryConfiguration.contrast) {\n        return true;\n      }\n      if (imageryLayer.hue !== imageryConfiguration.hue) {\n        return true;\n      }\n      if (imageryLayer.saturation !== imageryConfiguration.saturation) {\n        return true;\n      }\n      if (imageryLayer.gamma !== imageryConfiguration.gamma) {\n        return true;\n      }\n      if (imageryLayer.colorToAlpha !== imageryConfiguration.colorToAlpha) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Create one <code>ImageryConfiguration</code> object for each imagery\n   * layer that appears in the model, and store them as the\n   * <code>_imageryConfigurations</code>.\n   */\n  _updateImageryConfigurations() {\n    const model = this._model;\n    const imageryLayers = model.imageryLayers;\n    const imageryConfigurations = this._imageryConfigurations;\n    imageryConfigurations.length = imageryLayers.length;\n    for (let i = 0; i < imageryLayers.length; i++) {\n      const imageryLayer = imageryLayers.get(i);\n      imageryConfigurations[i] = new ImageryConfiguration(imageryLayer);\n    }\n  }\n\n  /**\n   * Returns whether this object was destroyed.\n   *\n   * If this object was destroyed, calling any function other than\n   * <code>isDestroyed</code> will result in a {@link DeveloperError}.\n   *\n   * @returns {boolean} Whether this object was destroyed\n   */\n  isDestroyed() {\n    return false;\n  }\n\n  /**\n   * Destroys this object and all its resources.\n   */\n  destroy() {\n    if (this.isDestroyed()) {\n      return;\n    }\n    this._deleteModelPrimitiveImageries();\n    return destroyObject(this);\n  }\n}\nexport default ModelImagery;","map":{"version":3,"names":["Check","defined","destroyObject","DeveloperError","ImageryConfiguration","ModelPrimitiveImagery","ModelImagery","constructor","model","_model","_modelPrimitiveImageries","undefined","_imageryConfigurations","update","frameState","_hasImagery","_allImageryLayersReady","_createModelPrimitiveImageries","_updateModelPrimitiveImageries","_checkForModifiedImageryConfigurations","runtimeNodesAndPrimitives","_collectRuntimeNodesAndPrimitives","modelPrimitiveImageries","length","i","runtimeNodeAndPrimitive","runtimeNode","runtimePrimitive","modelPrimitiveImagery","primitive","push","sceneGraph","runtimeNodes","_runtimeNodes","j","runtimePrimitives","_deleteModelPrimitiveImageries","destroy","ready","_allModelPrimitiveImageriesReady","imageryLayers","imageryLayer","get","_imageryConfigurationsModified","_updateImageryConfigurations","resetDrawCommands","imageryConfigurations","imageryConfiguration","show","alpha","brightness","contrast","hue","saturation","gamma","colorToAlpha","isDestroyed"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Model/ModelImagery.js"],"sourcesContent":["import Check from \"../../Core/Check.js\";\nimport defined from \"../../Core/defined.js\";\nimport destroyObject from \"../../Core/destroyObject.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\n\nimport ImageryConfiguration from \"./ImageryConfiguration.js\";\nimport ModelPrimitiveImagery from \"./ModelPrimitiveImagery.js\";\n\n/**\n * A class managing the draping of imagery on a <code>Model</code>.\n *\n * An instance of this class is created in the Model constructor. It will\n * create the data structures that carry the information that is required\n * for mapping imagery textures on model primitives.\n *\n * It offers two functions for managing the lifecycle of this draping process:\n *\n * The <code>update</code> function is called from the <code>Model.update</code>\n * function in each frame. It will create one <code>ModelPrimitiveImagery</code>\n * instance for each primitive that appears in the model, and call the\n * <code>update</code> function of these instances, respectively.\n *\n * The <code>ready</code> getter will be used to determine whether the\n * draping computations are done, and the update process of the <code>Model</code>\n * can continue, eventually causing the <code>model.ready</code> flag to\n * become <code>true</code>. The model imagery counts as \"ready\" when all\n * the imagery layers of the model are <code>ready</code>, and all the\n * <code>ModelPrimitiveImagery</code> instances are <code>ready</code>.\n *\n * @private\n */\nclass ModelImagery {\n  /**\n   * Creates a new instance\n   *\n   * @param {Model} model The model\n   * @throws {DeveloperError} If the model is not defined\n   */\n  constructor(model) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"model\", model);\n    //>>includeEnd('debug');\n\n    /**\n     * The model that this instance was created for.\n     *\n     * @type {Model}\n     * @readonly\n     * @private\n     */\n    this._model = model;\n\n    /**\n     * One <code<ModelPrimitiveImagery</code> for each primitive\n     * that appears in the model.\n     *\n     * Initially, this is <code>undefined</code>. When the <code>update</code>\n     * function is called and all imagery layers that are associated with the\n     * model are <code>ready</code>, this is initialized with one instance\n     * of a <code>ModelPrimitiveImagery</code> per runtime primitive (i.e. one for\n     * each <code>model.sceneGraph._runtimeNodes[n]._runtimePrimitives[p]</code>)\n     *\n     * @type {ModelPrimitiveImagery[]|undefined}\n     * @private\n     */\n    this._modelPrimitiveImageries = undefined;\n\n    /**\n     * One <code>ImageryConfiguration</code> object for each <code>ImageryLayer</code>\n     * that is associated with the model.\n     *\n     * This is used for determining whether the configuration (relevant property\n     * values) of an imagery layer has been changed since the previous\n     * <code>update</code> call, which should cause the draw commands of the\n     * model to be reset.\n     *\n     * @type {ImageryConfiguration[]}\n     * @private\n     */\n    this._imageryConfigurations = [];\n  }\n\n  /**\n   * The update function that is called from <code>Model.update</code> in\n   * each frame.\n   *\n   * This checks whether the imagery layer objects that are associated\n   * with the model are all <code>ready</code>. If they are not yet\n   * ready, then nothing is done.\n   *\n   * Otherwise, this just calls the <code>update</code> function of\n   * the <code>_modelPrimitiveImageries</code> (creating them if they had\n   * not been created yet).\n   *\n   * @param {FrameState} frameState The frame state\n   */\n  update(frameState) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"frameState\", frameState);\n    //>>includeEnd('debug');\n\n    if (!this._hasImagery) {\n      return;\n    }\n\n    if (!this._allImageryLayersReady) {\n      return;\n    }\n\n    if (!defined(this._modelPrimitiveImageries)) {\n      this._modelPrimitiveImageries = this._createModelPrimitiveImageries();\n    }\n    this._updateModelPrimitiveImageries(frameState);\n\n    this._checkForModifiedImageryConfigurations();\n  }\n\n  /**\n   * Creates the <code>ModelPrimitiveImagery</code> array that contains\n   * one <code>ModelPrimitiveImagery</code> for each primitive that is\n   * contained in the model.\n   *\n   * @returns {ModelPrimitiveImagery[]} The model primitive imageries\n   * @private\n   */\n  _createModelPrimitiveImageries() {\n    const model = this._model;\n    const runtimeNodesAndPrimitives = this._collectRuntimeNodesAndPrimitives();\n    const modelPrimitiveImageries = [];\n    const length = runtimeNodesAndPrimitives.length;\n    for (let i = 0; i < length; i++) {\n      const runtimeNodeAndPrimitive = runtimeNodesAndPrimitives[i];\n      const runtimeNode = runtimeNodeAndPrimitive.runtimeNode;\n      const runtimePrimitive = runtimeNodeAndPrimitive.runtimePrimitive;\n      const modelPrimitiveImagery = new ModelPrimitiveImagery(\n        model,\n        runtimeNode,\n        runtimePrimitive,\n      );\n      runtimePrimitive.primitive.modelPrimitiveImagery = modelPrimitiveImagery;\n      modelPrimitiveImageries.push(modelPrimitiveImagery);\n    }\n    return modelPrimitiveImageries;\n  }\n\n  /**\n   * Computes all runtime nodes and primitives of the model.\n   *\n   * This is just the array that contains a\n   * <code>{ runtimeNode, runtimePrimitive }</code>\n   * for each\n   * <code>model.sceneGraph._runtimeNodes[n]._runtimePrimitives[p]</code>.\n   *\n   * @returns {object[]} The runtime nodes and primitives\n   * @private\n   */\n  _collectRuntimeNodesAndPrimitives() {\n    const model = this._model;\n    const sceneGraph = model.sceneGraph;\n    const runtimeNodes = sceneGraph._runtimeNodes;\n    const runtimeNodesAndPrimitives = [];\n    for (let i = 0; i < runtimeNodes.length; i++) {\n      const runtimeNode = runtimeNodes[i];\n      if (!defined(runtimeNode)) {\n        continue;\n      }\n      for (let j = 0; j < runtimeNode.runtimePrimitives.length; j++) {\n        const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n        runtimeNodesAndPrimitives.push({\n          runtimeNode: runtimeNode,\n          runtimePrimitive: runtimePrimitive,\n        });\n      }\n    }\n    return runtimeNodesAndPrimitives;\n  }\n\n  /**\n   * Just calls <code>update</code> on each <code>ModelPrimitiveImagery</code>\n   * as part of the <code>update</code> of this class.\n   *\n   * @private\n   */\n  _updateModelPrimitiveImageries(frameState) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"frameState\", frameState);\n    //>>includeEnd('debug');\n\n    if (!defined(this._modelPrimitiveImageries)) {\n      throw new DeveloperError(\n        \"The modelPrimitiveImageries have not been created\",\n      );\n    }\n\n    const modelPrimitiveImageries = this._modelPrimitiveImageries;\n    const length = modelPrimitiveImageries.length;\n    for (let i = 0; i < length; i++) {\n      const modelPrimitiveImagery = modelPrimitiveImageries[i];\n      modelPrimitiveImagery.update(frameState);\n    }\n  }\n\n  /**\n   * Destroy and delete all <code>ModelPrimitiveImagery</code> instances\n   * if they already have been created.\n   */\n  _deleteModelPrimitiveImageries() {\n    const modelPrimitiveImageries = this._modelPrimitiveImageries;\n    if (!defined(modelPrimitiveImageries)) {\n      return;\n    }\n    const length = modelPrimitiveImageries.length;\n    for (let i = 0; i < length; i++) {\n      const modelPrimitiveImagery = modelPrimitiveImageries[i];\n      modelPrimitiveImagery.destroy();\n    }\n    delete this._modelPrimitiveImageries;\n  }\n\n  /**\n   * Returns whether this instance is \"ready\".\n   *\n   * This means that all imagery layers that are associated with the model\n   * are <code>ready</code>, and all <code>ModelPrimitiveImagery</code>\n   * instances are <code>ready</code>.\n   *\n   * When this is <code>true</code>, then the mapping computations are\n   * complete and the structures containing the mapping information have\n   * been initialized. Otherwise, subsequent calls to <code>update</code>\n   * will perform the necessary computation until this getter eventually\n   * returns <code>true</code>.\n   *\n   * @returns {boolean} Whether this instance is \"ready\"\n   */\n  get ready() {\n    if (!this._hasImagery) {\n      return true;\n    }\n    if (!this._allImageryLayersReady) {\n      return false;\n    }\n    if (!this._allModelPrimitiveImageriesReady) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the model has imagery layers associated with it.\n   *\n   * @private\n   */\n  get _hasImagery() {\n    const model = this._model;\n    const imageryLayers = model.imageryLayers;\n    return defined(imageryLayers) && imageryLayers.length > 0;\n  }\n\n  /**\n   * Returns whether all imagery layers that are associated with the\n   * model are <code>ready</code>.\n   *\n   * If the model does not have imagery, then this always returns\n   * <code>true</code>. Otherwise, it returns whether each imagery\n   * layer is <code>ready</code>.\n   *\n   * @private\n   */\n  get _allImageryLayersReady() {\n    if (!this._hasImagery) {\n      return true;\n    }\n    const imageryLayers = this._model.imageryLayers;\n    const length = imageryLayers.length;\n    for (let i = 0; i < length; i++) {\n      const imageryLayer = imageryLayers.get(i);\n      if (!imageryLayer.ready) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether all <code>ModelPrimitiveImagery</code> instances\n   * are are <code>ready</code>.\n   *\n   * @private\n   */\n  get _allModelPrimitiveImageriesReady() {\n    const modelPrimitiveImageries = this._modelPrimitiveImageries;\n    if (!defined(modelPrimitiveImageries)) {\n      return false;\n    }\n    const length = modelPrimitiveImageries.length;\n    for (let i = 0; i < length; i++) {\n      const modelPrimitiveImagery = modelPrimitiveImageries[i];\n      if (!modelPrimitiveImagery.ready) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Check whether any of the settings of any imagery layer (like alpha\n   * or hue) has been changed since the last call to the <code>update</code>\n   * function.\n   *\n   * If this is the case, the draw commands of the model will be reset.\n   */\n  _checkForModifiedImageryConfigurations() {\n    if (this._imageryConfigurationsModified()) {\n      this._updateImageryConfigurations();\n      const model = this._model;\n      model.resetDrawCommands();\n    }\n  }\n\n  /**\n   * Returns whether any setting of an imagery layer (like alpha or hue) has\n   * been changed since the last time the <code>ImageryConfiguration</code>\n   * objects have been updated.\n   *\n   * @returns {boolean} Whether there was a modification\n   */\n  _imageryConfigurationsModified() {\n    const model = this._model;\n    const imageryLayers = model.imageryLayers;\n    const imageryConfigurations = this._imageryConfigurations;\n    if (imageryLayers.length !== imageryConfigurations.length) {\n      return true;\n    }\n    for (let i = 0; i < imageryLayers.length; i++) {\n      const imageryLayer = imageryLayers.get(i);\n      const imageryConfiguration = imageryConfigurations[i];\n\n      if (imageryLayer.show !== imageryConfiguration.show) {\n        return true;\n      }\n      if (imageryLayer.alpha !== imageryConfiguration.alpha) {\n        return true;\n      }\n      if (imageryLayer.brightness !== imageryConfiguration.brightness) {\n        return true;\n      }\n      if (imageryLayer.contrast !== imageryConfiguration.contrast) {\n        return true;\n      }\n      if (imageryLayer.hue !== imageryConfiguration.hue) {\n        return true;\n      }\n      if (imageryLayer.saturation !== imageryConfiguration.saturation) {\n        return true;\n      }\n      if (imageryLayer.gamma !== imageryConfiguration.gamma) {\n        return true;\n      }\n      if (imageryLayer.colorToAlpha !== imageryConfiguration.colorToAlpha) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Create one <code>ImageryConfiguration</code> object for each imagery\n   * layer that appears in the model, and store them as the\n   * <code>_imageryConfigurations</code>.\n   */\n  _updateImageryConfigurations() {\n    const model = this._model;\n    const imageryLayers = model.imageryLayers;\n    const imageryConfigurations = this._imageryConfigurations;\n    imageryConfigurations.length = imageryLayers.length;\n    for (let i = 0; i < imageryLayers.length; i++) {\n      const imageryLayer = imageryLayers.get(i);\n      imageryConfigurations[i] = new ImageryConfiguration(imageryLayer);\n    }\n  }\n\n  /**\n   * Returns whether this object was destroyed.\n   *\n   * If this object was destroyed, calling any function other than\n   * <code>isDestroyed</code> will result in a {@link DeveloperError}.\n   *\n   * @returns {boolean} Whether this object was destroyed\n   */\n  isDestroyed() {\n    return false;\n  }\n\n  /**\n   * Destroys this object and all its resources.\n   */\n  destroy() {\n    if (this.isDestroyed()) {\n      return;\n    }\n    this._deleteModelPrimitiveImageries();\n    return destroyObject(this);\n  }\n}\n\nexport default ModelImagery;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}