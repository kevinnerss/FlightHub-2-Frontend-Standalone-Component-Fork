{"ast":null,"code":"/* eslint-disable new-cap */\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport FeatureDetection from \"./FeatureDetection.js\";\nimport RuntimeError from \"./RuntimeError.js\";\n\n/**\n * S2\n * --\n *\n * This implementation is based on the S2 C++ reference implementation: https://github.com/google/s2geometry\n *\n *\n * Overview:\n * ---------\n * The S2 library decomposes the unit sphere into a hierarchy of cells. A cell is a quadrilateral bounded by 4 geodesics.\n * The 6 root cells are obtained by projecting the six faces of a cube on a unit sphere. Each root cell follows a quadtree\n * subdivision scheme, i.e. each cell subdivides into 4 smaller cells that cover the same area as the parent cell. The S2 cell\n * hierarchy extends from level 0 (root cells) to level 30 (leaf cells). The root cells are rotated to enable a continuous Hilbert\n * curve to map all 6 faces of the cube.\n *\n *\n * Cell ID:\n * --------\n * Each cell in S2 can be uniquely identified using a 64-bit unsigned integer, its cell ID. The first 3 bits of the cell ID are the face bits, i.e.\n * they indicate which of the 6 faces of the cube a cell lies on. After the face bits are the position bits, i.e. they indicate the position\n * of the cell along the Hilbert curve. After the positions bits is the sentinel bit, which is always set to 1, and it indicates the level of the\n * cell. Again, the level can be between 0 and 30 in S2.\n *\n *   Note: In the illustration below, the face bits are marked with 'f', the position bits are marked with 'p', the zero bits are marked with '-'.\n *\n *   Cell ID (base 10): 3170534137668829184\n *   Cell ID (base 2) : 0010110000000000000000000000000000000000000000000000000000000000\n *\n *   001 0110000000000000000000000000000000000000000000000000000000000\n *   fff pps----------------------------------------------------------\n *\n * For the cell above, we can see that it lies on face 1 (01), with a Hilbert index of 1 (1).\n *\n *\n * Cell Subdivision:\n * ------------------\n * Cells in S2 subdivide recursively using quadtree subdivision. For each cell, you can get a child of index [0-3]. To compute the child at index i,\n * insert the base 2 representation of i to the right of the parent's position bits. Ensure that the sentinel bit is also shifted two places to the right.\n *\n *   Parent Cell ID (base 10) : 3170534137668829184\n *   Parent Cell ID (base 2)  : 0010110000000000000000000000000000000000000000000000000000000000\n *\n *   001 0110000000000000000000000000000000000000000000000000000000000\n *   fff pps----------------------------------------------------------\n *\n *   To get the 3rd child of the cell above, we insert the binary representation of 3 to the right of the parent's position bits:\n *\n *   Note: In the illustration below, the bits to be added are highlighted with '^'.\n *\n *   001 0111100000000000000000000000000000000000000000000000000000000\n *   fff pppps--------------------------------------------------------\n *         ^^\n *\n *   Child(3) Cell ID (base 10) : 3386706919782612992\n *   Child(3) Cell ID (base 2)  : 0010111100000000000000000000000000000000000000000000000000000000\n *\n * Cell Token:\n * -----------\n * To provide a more concise representation of the S2 cell ID, we can use their hexadecimal representation.\n *\n *   Cell ID (base 10): 3170534137668829184\n *   Cell ID (base 2) : 0010110000000000000000000000000000000000000000000000000000000000\n *\n *   We remove all trailing zero bits, until we reach the nybble (4 bits) that contains the sentinel bit.\n *\n *   Note: In the illustration below, the bits to be removed are highlighted with 'X'.\n *\n *   0010110000000000000000000000000000000000000000000000000000000000\n *   fffpps--XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n *\n *   We convert the remaining bits to their hexadecimal representation.\n *\n *   Base 2: 0010 1100\n *   Base 16: \"2\"  \"c\"\n *\n *   Cell Token: \"2c\"\n *\n * To compute the cell ID from the token, we simply add enough zeros to the right to make the ID span 64 bits.\n *\n * Coordinate Transforms:\n * ----------------------\n *\n * To go from a cell in S2 to a point on the ellipsoid, the following order of transforms is applied:\n *\n *   1. (Cell ID): S2 cell ID\n *   2. (Face, I, J): Leaf cell coordinates, where i and j are in range [0, 2^30 - 1]\n *   3. (Face, S, T): Cell space coordinates, where s and t are in range [0, 1].\n *   4. (Face, Si, Ti): Discrete cell space coordinates, where si and ti are in range [0, 2^31]\n *   5. (Face, U, V): Cube space coordinates, where u and v are in range [-1, 1]. We apply the non-linear quadratic transform here.\n *   6. (X, Y, Z): Direction vector, where vector may not be unit length. Can be normalized to obtain point on unit sphere\n *   7. (Latitude, Longitude): Direction vector, where latitude is in range [-90, 90] and longitude is in range [-180, 180]\n *\n * @ignore\n */\n\n// The maximum level supported within an S2 cell ID. Each level is represented by two bits in the final cell ID\nconst S2_MAX_LEVEL = 30;\n\n// The maximum index of a valid leaf cell plus one.  The range of valid leaf cell indices is [0..S2_LIMIT_IJ-1].\nconst S2_LIMIT_IJ = 1 << S2_MAX_LEVEL;\n\n// The maximum value of an si- or ti-coordinate.  The range of valid (si,ti) values is [0..S2_MAX_SITI].  Use `>>>` to convert to unsigned.\nconst S2_MAX_SITI = 1 << S2_MAX_LEVEL + 1 >>> 0;\n\n// The number of bits in a S2 cell ID used for specifying the position along the Hilbert curve\nconst S2_POSITION_BITS = 2 * S2_MAX_LEVEL + 1;\n\n// The number of bits per I and J in the lookup tables\nconst S2_LOOKUP_BITS = 4;\n\n// Lookup table for mapping 10 bits of IJ + orientation to 10 bits of Hilbert curve position + orientation.\nconst S2_LOOKUP_POSITIONS = [];\n\n// Lookup table for mapping 10 bits of IJ + orientation to 10 bits of Hilbert curve position + orientation.\nconst S2_LOOKUP_IJ = [];\n\n// Lookup table of two bits of IJ from two bits of curve position, based also on the current curve orientation from the swap and invert bits\nconst S2_POSITION_TO_IJ = [[0, 1, 3, 2],\n// 0: Normal order, no swap or invert\n[0, 2, 3, 1],\n// 1: Swap bit set, swap I and J bits\n[3, 2, 0, 1],\n// 2: Invert bit set, invert bits\n[3, 1, 0, 2] // 3: Swap and invert bits set\n];\n\n// Mask that specifies the swap orientation bit for the Hilbert curve\nconst S2_SWAP_MASK = 1;\n\n// Mask that specifies the invert orientation bit for the Hilbert curve\nconst S2_INVERT_MASK = 2;\n\n// Lookup for the orientation update mask of one of the four sub-cells within a higher level cell.\n// This mask is XOR'ed with the current orientation to get the sub-cell orientation.\nconst S2_POSITION_TO_ORIENTATION_MASK = [S2_SWAP_MASK, 0, 0, S2_SWAP_MASK | S2_INVERT_MASK];\n\n/**\n * Represents a cell in the S2 geometry library.\n *\n * @alias S2Cell\n * @constructor\n *\n * @param {bigint} [cellId] The 64-bit S2CellId.\n * @private\n */\nfunction S2Cell(cellId) {\n  if (!FeatureDetection.supportsBigInt()) {\n    throw new RuntimeError(\"S2 required BigInt support\");\n  }\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cellId)) {\n    throw new DeveloperError(\"cell ID is required.\");\n  }\n  if (!S2Cell.isValidId(cellId)) {\n    throw new DeveloperError(\"cell ID is invalid.\");\n  }\n  //>>includeEnd('debug');\n\n  this._cellId = cellId;\n  this._level = S2Cell.getLevel(cellId);\n}\n\n/**\n * Creates a new S2Cell from a token. A token is a hexadecimal representation of the 64-bit S2CellId.\n *\n * @param {string} token The token for the S2 Cell.\n * @returns {S2Cell} Returns a new S2Cell.\n * @private\n */\nS2Cell.fromToken = function (token) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"token\", token);\n  if (!S2Cell.isValidToken(token)) {\n    throw new DeveloperError(\"token is invalid.\");\n  }\n  //>>includeEnd('debug');\n\n  return new S2Cell(S2Cell.getIdFromToken(token));\n};\n\n/**\n * Validates an S2 cell ID.\n *\n * @param {bigint} [cellId] The S2CellId.\n * @returns {boolean} Returns true if the cell ID is valid, returns false otherwise.\n * @private\n */\nS2Cell.isValidId = function (cellId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bigint(\"cellId\", cellId);\n  //>>includeEnd('debug');\n\n  // Check if sentinel bit is missing.\n  if (cellId <= 0) {\n    return false;\n  }\n\n  // Check if face bits indicate a valid value, in range [0-5].\n  // eslint-disable-next-line\n  if (cellId >> BigInt(S2_POSITION_BITS) > 5) {\n    return false;\n  }\n\n  // Check trailing 1 bit is in one of the even bit positions allowed for the 30 levels, using a bitmask.\n  // eslint-disable-next-line no-undef\n  const lowestSetBit = cellId & ~cellId + BigInt(1);\n  // eslint-disable-next-line\n  if (!(lowestSetBit & BigInt(\"0x1555555555555555\"))) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * Validates an S2 cell token.\n *\n * @param {string} [token] The hexadecimal representation of an S2CellId.\n * @returns {boolean} Returns true if the token is valid, returns false otherwise.\n * @private\n */\nS2Cell.isValidToken = function (token) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"token\", token);\n  //>>includeEnd('debug');\n\n  if (!/^[0-9a-fA-F]{1,16}$/.test(token)) {\n    return false;\n  }\n  return S2Cell.isValidId(S2Cell.getIdFromToken(token));\n};\n\n/**\n * Converts an S2 cell token to a 64-bit S2 cell ID.\n *\n * @param {string} [token] The hexadecimal representation of an S2CellId. Expected to be a valid S2 token.\n * @returns {bigint} Returns the S2 cell ID.\n * @private\n */\nS2Cell.getIdFromToken = function (token) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"token\", token);\n  //>>includeEnd('debug');\n\n  return BigInt(\"0x\" + token + \"0\".repeat(16 - token.length)); // eslint-disable-line\n};\n\n/**\n * Converts a 64-bit S2 cell ID to an S2 cell token.\n *\n * @param {bigint} [cellId] The S2 cell ID.\n * @returns {string} Returns hexadecimal representation of an S2CellId.\n * @private\n */\nS2Cell.getTokenFromId = function (cellId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bigint(\"cellId\", cellId);\n  //>>includeEnd('debug');\n\n  const trailingZeroHexChars = Math.floor(countTrailingZeroBits(cellId) / 4);\n  const hexString = cellId.toString(16).replace(/0*$/, \"\");\n  const zeroString = Array(17 - trailingZeroHexChars - hexString.length).join(\"0\");\n  return zeroString + hexString;\n};\n\n/**\n * Gets the level of the cell from the cell ID.\n *\n * @param {bigint} [cellId] The S2 cell ID.\n * @returns {number} Returns the level of the cell.\n * @private\n */\nS2Cell.getLevel = function (cellId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bigint(\"cellId\", cellId);\n  if (!S2Cell.isValidId(cellId)) {\n    throw new DeveloperError();\n  }\n  //>>includeEnd('debug');\n\n  let lsbPosition = 0;\n  // eslint-disable-next-line\n  while (cellId !== BigInt(0)) {\n    // eslint-disable-next-line\n    if (cellId & BigInt(1)) {\n      break;\n    }\n    lsbPosition++;\n    cellId = cellId >> BigInt(1); // eslint-disable-line\n  }\n\n  // We use (>> 1) because there are 2 bits per level.\n  return S2_MAX_LEVEL - (lsbPosition >> 1);\n};\n\n/**\n * Gets the child cell of the cell at the given index.\n *\n * @param {number} index An integer index of the child.\n * @returns {S2Cell} The child of the S2Cell.\n * @private\n */\nS2Cell.prototype.getChild = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  if (index < 0 || index > 3) {\n    throw new DeveloperError(\"child index must be in the range [0-3].\");\n  }\n  if (this._level === 30) {\n    throw new DeveloperError(\"cannot get child of leaf cell.\");\n  }\n  //>>includeEnd('debug');\n\n  // Shift sentinel bit 2 positions to the right.\n  // eslint-disable-next-line no-undef\n  const newLsb = lsb(this._cellId) >> BigInt(2);\n  // Insert child index before the sentinel bit.\n  // eslint-disable-next-line no-undef\n  const childCellId = this._cellId + BigInt(2 * index + 1 - 4) * newLsb;\n  return new S2Cell(childCellId);\n};\n\n/**\n * Gets the parent cell of an S2Cell.\n *\n * @returns {S2Cell} Returns the parent of the S2Cell.\n * @private\n */\nS2Cell.prototype.getParent = function () {\n  //>>includeStart('debug', pragmas.debug);\n  if (this._level === 0) {\n    throw new DeveloperError(\"cannot get parent of root cell.\");\n  }\n  //>>includeEnd('debug');\n  // Shift the sentinel bit 2 positions to the left.\n  // eslint-disable-next-line no-undef\n  const newLsb = lsb(this._cellId) << BigInt(2);\n  // Erase the left over bits to the right of the sentinel bit.\n  // eslint-disable-next-line no-undef\n  return new S2Cell(this._cellId & ~newLsb + BigInt(1) | newLsb);\n};\n\n/**\n * Gets the parent cell at the given level.\n *\n * @returns {S2Cell} Returns the parent of the S2Cell.\n * @private\n */\nS2Cell.prototype.getParentAtLevel = function (level) {\n  //>>includeStart('debug', pragmas.debug);\n  if (this._level === 0 || level < 0 || this._level < level) {\n    throw new DeveloperError(\"cannot get parent at invalid level.\");\n  }\n  //>>includeEnd('debug');\n  const newLsb = lsbForLevel(level);\n  return new S2Cell(this._cellId & -newLsb | newLsb);\n};\n\n/**\n * Get center of the S2 cell.\n *\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid.\n * @returns {Cartesian3} The position of center of the S2 cell.\n * @private\n */\nS2Cell.prototype.getCenter = function (ellipsoid) {\n  ellipsoid = ellipsoid ?? Ellipsoid.WGS84;\n  let center = getS2Center(this._cellId, this._level);\n  // Normalize XYZ.\n  center = Cartesian3.normalize(center, center);\n  const cartographic = new Cartographic.fromCartesian(center, Ellipsoid.UNIT_SPHERE);\n  // Interpret as geodetic coordinates on the ellipsoid.\n  return Cartographic.toCartesian(cartographic, ellipsoid, new Cartesian3());\n};\n\n/**\n * Get vertex of the S2 cell. Vertices are indexed in CCW order.\n *\n * @param {number} index An integer index of the vertex. Must be in the range [0-3].\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid.\n * @returns {Cartesian3} The position of the vertex of the S2 cell.\n * @private\n */\nS2Cell.prototype.getVertex = function (index, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  if (index < 0 || index > 3) {\n    throw new DeveloperError(\"vertex index must be in the range [0-3].\");\n  }\n  //>>includeEnd('debug');\n\n  ellipsoid = ellipsoid ?? Ellipsoid.WGS84;\n  let vertex = getS2Vertex(this._cellId, this._level, index);\n  // Normalize XYZ.\n  vertex = Cartesian3.normalize(vertex, vertex);\n  const cartographic = new Cartographic.fromCartesian(vertex, Ellipsoid.UNIT_SPHERE);\n  // Interpret as geodetic coordinates on the ellipsoid.\n  return Cartographic.toCartesian(cartographic, ellipsoid, new Cartesian3());\n};\n\n/**\n * Creates an S2Cell from its face, position along the Hilbert curve for a given level.\n *\n * @param {number} face The root face of S2 this cell is on. Must be in the range [0-5].\n * @param {bigint} position The position along the Hilbert curve. Must be in the range [0-4**level).\n * @param {number} level The level of the S2 curve. Must be in the range [0-30].\n * @returns {S2Cell} A new S2Cell from the given parameters.\n * @private\n */\nS2Cell.fromFacePositionLevel = function (face, position, level) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bigint(\"position\", position);\n  if (face < 0 || face > 5) {\n    throw new DeveloperError(\"Invalid S2 Face (must be within 0-5)\");\n  }\n  if (level < 0 || level > S2_MAX_LEVEL) {\n    throw new DeveloperError(\"Invalid level (must be within 0-30)\");\n  }\n  if (position < 0 || position >= Math.pow(4, level)) {\n    throw new DeveloperError(\"Invalid Hilbert position for level\");\n  }\n  //>>includeEnd('debug');\n\n  const faceBitString = (face < 4 ? \"0\" : \"\") + (face < 2 ? \"0\" : \"\") + face.toString(2);\n  const positionBitString = position.toString(2);\n  const positionPrefixPadding = Array(2 * level - positionBitString.length + 1).join(\"0\");\n  const positionSuffixPadding = Array(S2_POSITION_BITS - 2 * level).join(\"0\");\n\n  // eslint-disable-next-line no-undef\n  const cellId = BigInt(`0b${faceBitString}${positionPrefixPadding}${positionBitString}1${\n  // Adding the sentinel bit that always follows the position bits.\n  positionSuffixPadding}`);\n  return new S2Cell(cellId);\n};\n\n/**\n * @private\n */\nfunction getS2Center(cellId, level) {\n  const faceSiTi = convertCellIdToFaceSiTi(cellId, level);\n  return convertFaceSiTitoXYZ(faceSiTi[0], faceSiTi[1], faceSiTi[2]);\n}\n/**\n * @private\n */\nfunction getS2Vertex(cellId, level, index) {\n  const faceIJ = convertCellIdToFaceIJ(cellId, level);\n  const uv = convertIJLeveltoBoundUV([faceIJ[1], faceIJ[2]], level);\n  // Handles CCW ordering of the vertices.\n  const y = index >> 1 & 1;\n  return convertFaceUVtoXYZ(faceIJ[0], uv[0][y ^ index & 1], uv[1][y]);\n}\n\n// S2 Coordinate Conversions\n\n/**\n * @private\n */\nfunction convertCellIdToFaceSiTi(cellId, level) {\n  const faceIJ = convertCellIdToFaceIJ(cellId);\n  const face = faceIJ[0];\n  const i = faceIJ[1];\n  const j = faceIJ[2];\n\n  // We're resolving the center when we do the coordinate transform here. For the leaf cells, we're adding half the cell size\n  // (remember that this space has 31 levels - which allows us to pick center and edges of the leaf cells). For non leaf cells,\n  // we get one of either two cells diagonal to the cell center. The correction is used to make sure we pick the leaf cell edges\n  // that represent the parent cell center.\n  const isLeaf = level === 30;\n  const shouldCorrect = !isLeaf && (BigInt(i) ^ cellId >> BigInt(2)) & BigInt(1); // eslint-disable-line\n  const correction = isLeaf ? 1 : shouldCorrect ? 2 : 0;\n  const si = (i << 1) + correction;\n  const ti = (j << 1) + correction;\n  return [face, si, ti];\n}\n\n/**\n * @private\n */\nfunction convertCellIdToFaceIJ(cellId) {\n  if (S2_LOOKUP_POSITIONS.length === 0) {\n    generateLookupTable();\n  }\n\n  // eslint-disable-next-line no-undef\n  const face = Number(cellId >> BigInt(S2_POSITION_BITS));\n  let bits = face & S2_SWAP_MASK;\n  const lookupMask = (1 << S2_LOOKUP_BITS) - 1;\n  let i = 0;\n  let j = 0;\n  for (let k = 7; k >= 0; k--) {\n    const numberOfBits = k === 7 ? S2_MAX_LEVEL - 7 * S2_LOOKUP_BITS : S2_LOOKUP_BITS;\n    const extractMask = (1 << 2 * numberOfBits) - 1;\n    bits += Number(cellId >> BigInt(k * 2 * S2_LOOKUP_BITS + 1) & BigInt(extractMask) // eslint-disable-line\n    ) << 2;\n    bits = S2_LOOKUP_IJ[bits];\n    const offset = k * S2_LOOKUP_BITS;\n    i += bits >> S2_LOOKUP_BITS + 2 << offset;\n    j += (bits >> 2 & lookupMask) << offset;\n    bits &= S2_SWAP_MASK | S2_INVERT_MASK;\n  }\n  return [face, i, j];\n}\n\n/**\n * @private\n */\nfunction convertFaceSiTitoXYZ(face, si, ti) {\n  const s = convertSiTitoST(si);\n  const t = convertSiTitoST(ti);\n  const u = convertSTtoUV(s);\n  const v = convertSTtoUV(t);\n  return convertFaceUVtoXYZ(face, u, v);\n}\n\n/**\n * @private\n */\nfunction convertFaceUVtoXYZ(face, u, v) {\n  switch (face) {\n    case 0:\n      return new Cartesian3(1, u, v);\n    case 1:\n      return new Cartesian3(-u, 1, v);\n    case 2:\n      return new Cartesian3(-u, -v, 1);\n    case 3:\n      return new Cartesian3(-1, -v, -u);\n    case 4:\n      return new Cartesian3(v, -1, -u);\n    default:\n      return new Cartesian3(v, u, -1);\n  }\n}\n\n/**\n * S2 provides 3 methods for the non-linear transform: linear, quadratic and tangential.\n * This implementation uses the quadratic method because it provides a good balance of\n * accuracy and speed.\n *\n * For a more detailed comparison of these transform methods, see\n * {@link https://github.com/google/s2geometry/blob/0c4c460bdfe696da303641771f9def900b3e440f/src/s2/s2metrics.cc}\n * @private\n */\nfunction convertSTtoUV(s) {\n  if (s >= 0.5) {\n    return 1 / 3 * (4 * s * s - 1);\n  }\n  return 1 / 3 * (1 - 4 * (1 - s) * (1 - s));\n}\n\n/**\n * @private\n */\nfunction convertSiTitoST(si) {\n  return 1.0 / S2_MAX_SITI * si;\n}\n\n/**\n * @private\n */\nfunction convertIJLeveltoBoundUV(ij, level) {\n  const result = [[], []];\n  const cellSize = getSizeIJ(level);\n  for (let d = 0; d < 2; ++d) {\n    const ijLow = ij[d] & -cellSize;\n    const ijHigh = ijLow + cellSize;\n    result[d][0] = convertSTtoUV(convertIJtoSTMinimum(ijLow));\n    result[d][1] = convertSTtoUV(convertIJtoSTMinimum(ijHigh));\n  }\n  return result;\n}\n\n/**\n * @private\n */\nfunction getSizeIJ(level) {\n  return 1 << S2_MAX_LEVEL - level >>> 0;\n}\n\n/**\n * @private\n */\nfunction convertIJtoSTMinimum(i) {\n  return 1.0 / S2_LIMIT_IJ * i;\n}\n\n// Utility Functions\n\n/**\n * This function generates 4 variations of a Hilbert curve of level 4, based on the S2_POSITION_TO_IJ table, for fast lookups of (i, j)\n * to position along Hilbert curve. The reference C++ implementation uses an iterative approach, however, this function is implemented\n * recursively.\n *\n * See {@link https://github.com/google/s2geometry/blob/c59d0ca01ae3976db7f8abdc83fcc871a3a95186/src/s2/s2cell_id.cc#L75-L109}\n * @private\n */\nfunction generateLookupCell(level, i, j, originalOrientation, position, orientation) {\n  if (level === S2_LOOKUP_BITS) {\n    const ij = (i << S2_LOOKUP_BITS) + j;\n    S2_LOOKUP_POSITIONS[(ij << 2) + originalOrientation] = (position << 2) + orientation;\n    S2_LOOKUP_IJ[(position << 2) + originalOrientation] = (ij << 2) + orientation;\n  } else {\n    level++;\n    i <<= 1;\n    j <<= 1;\n    position <<= 2;\n    const r = S2_POSITION_TO_IJ[orientation];\n    generateLookupCell(level, i + (r[0] >> 1), j + (r[0] & 1), originalOrientation, position, orientation ^ S2_POSITION_TO_ORIENTATION_MASK[0]);\n    generateLookupCell(level, i + (r[1] >> 1), j + (r[1] & 1), originalOrientation, position + 1, orientation ^ S2_POSITION_TO_ORIENTATION_MASK[1]);\n    generateLookupCell(level, i + (r[2] >> 1), j + (r[2] & 1), originalOrientation, position + 2, orientation ^ S2_POSITION_TO_ORIENTATION_MASK[2]);\n    generateLookupCell(level, i + (r[3] >> 1), j + (r[3] & 1), originalOrientation, position + 3, orientation ^ S2_POSITION_TO_ORIENTATION_MASK[3]);\n  }\n}\n\n/**\n * @private\n */\nfunction generateLookupTable() {\n  generateLookupCell(0, 0, 0, 0, 0, 0);\n  generateLookupCell(0, 0, 0, S2_SWAP_MASK, 0, S2_SWAP_MASK);\n  generateLookupCell(0, 0, 0, S2_INVERT_MASK, 0, S2_INVERT_MASK);\n  generateLookupCell(0, 0, 0, S2_SWAP_MASK | S2_INVERT_MASK, 0, S2_SWAP_MASK | S2_INVERT_MASK);\n}\n\n/**\n * Return the lowest-numbered bit that is on for this cell id\n * @private\n */\nfunction lsb(cellId) {\n  return cellId & ~cellId + BigInt(1); // eslint-disable-line\n}\n\n/**\n * Return the lowest-numbered bit that is on for cells at the given level.\n * @private\n */\nfunction lsbForLevel(level) {\n  return BigInt(1) << BigInt(2 * (S2_MAX_LEVEL - level)); // eslint-disable-line\n}\n\n// Lookup table for getting trailing zero bits.\n// https://graphics.stanford.edu/~seander/bithacks.html\nconst Mod67BitPosition = [64, 0, 1, 39, 2, 15, 40, 23, 3, 12, 16, 59, 41, 19, 24, 54, 4, 64, 13, 10, 17, 62, 60, 28, 42, 30, 20, 51, 25, 44, 55, 47, 5, 32, 65, 38, 14, 22, 11, 58, 18, 53, 63, 9, 61, 27, 29, 50, 43, 46, 31, 37, 21, 57, 52, 8, 26, 49, 45, 36, 56, 7, 48, 35, 6, 34, 33, 0];\n\n/**\n * Return the number of trailing zeros in number.\n * @private\n */\nfunction countTrailingZeroBits(x) {\n  return Mod67BitPosition[(-x & x) % BigInt(67)]; // eslint-disable-line\n}\nexport default S2Cell;","map":{"version":3,"names":["Cartesian3","Cartographic","Check","defined","DeveloperError","Ellipsoid","FeatureDetection","RuntimeError","S2_MAX_LEVEL","S2_LIMIT_IJ","S2_MAX_SITI","S2_POSITION_BITS","S2_LOOKUP_BITS","S2_LOOKUP_POSITIONS","S2_LOOKUP_IJ","S2_POSITION_TO_IJ","S2_SWAP_MASK","S2_INVERT_MASK","S2_POSITION_TO_ORIENTATION_MASK","S2Cell","cellId","supportsBigInt","isValidId","_cellId","_level","getLevel","fromToken","token","typeOf","string","isValidToken","getIdFromToken","bigint","BigInt","lowestSetBit","test","repeat","length","getTokenFromId","trailingZeroHexChars","Math","floor","countTrailingZeroBits","hexString","toString","replace","zeroString","Array","join","lsbPosition","prototype","getChild","index","number","newLsb","lsb","childCellId","getParent","getParentAtLevel","level","lsbForLevel","getCenter","ellipsoid","WGS84","center","getS2Center","normalize","cartographic","fromCartesian","UNIT_SPHERE","toCartesian","getVertex","vertex","getS2Vertex","fromFacePositionLevel","face","position","pow","faceBitString","positionBitString","positionPrefixPadding","positionSuffixPadding","faceSiTi","convertCellIdToFaceSiTi","convertFaceSiTitoXYZ","faceIJ","convertCellIdToFaceIJ","uv","convertIJLeveltoBoundUV","y","convertFaceUVtoXYZ","i","j","isLeaf","shouldCorrect","correction","si","ti","generateLookupTable","Number","bits","lookupMask","k","numberOfBits","extractMask","offset","s","convertSiTitoST","t","u","convertSTtoUV","v","ij","result","cellSize","getSizeIJ","d","ijLow","ijHigh","convertIJtoSTMinimum","generateLookupCell","originalOrientation","orientation","r","Mod67BitPosition","x"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/S2Cell.js"],"sourcesContent":["/* eslint-disable new-cap */\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport FeatureDetection from \"./FeatureDetection.js\";\nimport RuntimeError from \"./RuntimeError.js\";\n\n/**\n * S2\n * --\n *\n * This implementation is based on the S2 C++ reference implementation: https://github.com/google/s2geometry\n *\n *\n * Overview:\n * ---------\n * The S2 library decomposes the unit sphere into a hierarchy of cells. A cell is a quadrilateral bounded by 4 geodesics.\n * The 6 root cells are obtained by projecting the six faces of a cube on a unit sphere. Each root cell follows a quadtree\n * subdivision scheme, i.e. each cell subdivides into 4 smaller cells that cover the same area as the parent cell. The S2 cell\n * hierarchy extends from level 0 (root cells) to level 30 (leaf cells). The root cells are rotated to enable a continuous Hilbert\n * curve to map all 6 faces of the cube.\n *\n *\n * Cell ID:\n * --------\n * Each cell in S2 can be uniquely identified using a 64-bit unsigned integer, its cell ID. The first 3 bits of the cell ID are the face bits, i.e.\n * they indicate which of the 6 faces of the cube a cell lies on. After the face bits are the position bits, i.e. they indicate the position\n * of the cell along the Hilbert curve. After the positions bits is the sentinel bit, which is always set to 1, and it indicates the level of the\n * cell. Again, the level can be between 0 and 30 in S2.\n *\n *   Note: In the illustration below, the face bits are marked with 'f', the position bits are marked with 'p', the zero bits are marked with '-'.\n *\n *   Cell ID (base 10): 3170534137668829184\n *   Cell ID (base 2) : 0010110000000000000000000000000000000000000000000000000000000000\n *\n *   001 0110000000000000000000000000000000000000000000000000000000000\n *   fff pps----------------------------------------------------------\n *\n * For the cell above, we can see that it lies on face 1 (01), with a Hilbert index of 1 (1).\n *\n *\n * Cell Subdivision:\n * ------------------\n * Cells in S2 subdivide recursively using quadtree subdivision. For each cell, you can get a child of index [0-3]. To compute the child at index i,\n * insert the base 2 representation of i to the right of the parent's position bits. Ensure that the sentinel bit is also shifted two places to the right.\n *\n *   Parent Cell ID (base 10) : 3170534137668829184\n *   Parent Cell ID (base 2)  : 0010110000000000000000000000000000000000000000000000000000000000\n *\n *   001 0110000000000000000000000000000000000000000000000000000000000\n *   fff pps----------------------------------------------------------\n *\n *   To get the 3rd child of the cell above, we insert the binary representation of 3 to the right of the parent's position bits:\n *\n *   Note: In the illustration below, the bits to be added are highlighted with '^'.\n *\n *   001 0111100000000000000000000000000000000000000000000000000000000\n *   fff pppps--------------------------------------------------------\n *         ^^\n *\n *   Child(3) Cell ID (base 10) : 3386706919782612992\n *   Child(3) Cell ID (base 2)  : 0010111100000000000000000000000000000000000000000000000000000000\n *\n * Cell Token:\n * -----------\n * To provide a more concise representation of the S2 cell ID, we can use their hexadecimal representation.\n *\n *   Cell ID (base 10): 3170534137668829184\n *   Cell ID (base 2) : 0010110000000000000000000000000000000000000000000000000000000000\n *\n *   We remove all trailing zero bits, until we reach the nybble (4 bits) that contains the sentinel bit.\n *\n *   Note: In the illustration below, the bits to be removed are highlighted with 'X'.\n *\n *   0010110000000000000000000000000000000000000000000000000000000000\n *   fffpps--XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n *\n *   We convert the remaining bits to their hexadecimal representation.\n *\n *   Base 2: 0010 1100\n *   Base 16: \"2\"  \"c\"\n *\n *   Cell Token: \"2c\"\n *\n * To compute the cell ID from the token, we simply add enough zeros to the right to make the ID span 64 bits.\n *\n * Coordinate Transforms:\n * ----------------------\n *\n * To go from a cell in S2 to a point on the ellipsoid, the following order of transforms is applied:\n *\n *   1. (Cell ID): S2 cell ID\n *   2. (Face, I, J): Leaf cell coordinates, where i and j are in range [0, 2^30 - 1]\n *   3. (Face, S, T): Cell space coordinates, where s and t are in range [0, 1].\n *   4. (Face, Si, Ti): Discrete cell space coordinates, where si and ti are in range [0, 2^31]\n *   5. (Face, U, V): Cube space coordinates, where u and v are in range [-1, 1]. We apply the non-linear quadratic transform here.\n *   6. (X, Y, Z): Direction vector, where vector may not be unit length. Can be normalized to obtain point on unit sphere\n *   7. (Latitude, Longitude): Direction vector, where latitude is in range [-90, 90] and longitude is in range [-180, 180]\n *\n * @ignore\n */\n\n// The maximum level supported within an S2 cell ID. Each level is represented by two bits in the final cell ID\nconst S2_MAX_LEVEL = 30;\n\n// The maximum index of a valid leaf cell plus one.  The range of valid leaf cell indices is [0..S2_LIMIT_IJ-1].\nconst S2_LIMIT_IJ = 1 << S2_MAX_LEVEL;\n\n// The maximum value of an si- or ti-coordinate.  The range of valid (si,ti) values is [0..S2_MAX_SITI].  Use `>>>` to convert to unsigned.\nconst S2_MAX_SITI = (1 << (S2_MAX_LEVEL + 1)) >>> 0;\n\n// The number of bits in a S2 cell ID used for specifying the position along the Hilbert curve\nconst S2_POSITION_BITS = 2 * S2_MAX_LEVEL + 1;\n\n// The number of bits per I and J in the lookup tables\nconst S2_LOOKUP_BITS = 4;\n\n// Lookup table for mapping 10 bits of IJ + orientation to 10 bits of Hilbert curve position + orientation.\nconst S2_LOOKUP_POSITIONS = [];\n\n// Lookup table for mapping 10 bits of IJ + orientation to 10 bits of Hilbert curve position + orientation.\nconst S2_LOOKUP_IJ = [];\n\n// Lookup table of two bits of IJ from two bits of curve position, based also on the current curve orientation from the swap and invert bits\nconst S2_POSITION_TO_IJ = [\n  [0, 1, 3, 2], // 0: Normal order, no swap or invert\n  [0, 2, 3, 1], // 1: Swap bit set, swap I and J bits\n  [3, 2, 0, 1], // 2: Invert bit set, invert bits\n  [3, 1, 0, 2], // 3: Swap and invert bits set\n];\n\n// Mask that specifies the swap orientation bit for the Hilbert curve\nconst S2_SWAP_MASK = 1;\n\n// Mask that specifies the invert orientation bit for the Hilbert curve\nconst S2_INVERT_MASK = 2;\n\n// Lookup for the orientation update mask of one of the four sub-cells within a higher level cell.\n// This mask is XOR'ed with the current orientation to get the sub-cell orientation.\nconst S2_POSITION_TO_ORIENTATION_MASK = [\n  S2_SWAP_MASK,\n  0,\n  0,\n  S2_SWAP_MASK | S2_INVERT_MASK,\n];\n\n/**\n * Represents a cell in the S2 geometry library.\n *\n * @alias S2Cell\n * @constructor\n *\n * @param {bigint} [cellId] The 64-bit S2CellId.\n * @private\n */\nfunction S2Cell(cellId) {\n  if (!FeatureDetection.supportsBigInt()) {\n    throw new RuntimeError(\"S2 required BigInt support\");\n  }\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cellId)) {\n    throw new DeveloperError(\"cell ID is required.\");\n  }\n  if (!S2Cell.isValidId(cellId)) {\n    throw new DeveloperError(\"cell ID is invalid.\");\n  }\n  //>>includeEnd('debug');\n\n  this._cellId = cellId;\n  this._level = S2Cell.getLevel(cellId);\n}\n\n/**\n * Creates a new S2Cell from a token. A token is a hexadecimal representation of the 64-bit S2CellId.\n *\n * @param {string} token The token for the S2 Cell.\n * @returns {S2Cell} Returns a new S2Cell.\n * @private\n */\nS2Cell.fromToken = function (token) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"token\", token);\n  if (!S2Cell.isValidToken(token)) {\n    throw new DeveloperError(\"token is invalid.\");\n  }\n  //>>includeEnd('debug');\n\n  return new S2Cell(S2Cell.getIdFromToken(token));\n};\n\n/**\n * Validates an S2 cell ID.\n *\n * @param {bigint} [cellId] The S2CellId.\n * @returns {boolean} Returns true if the cell ID is valid, returns false otherwise.\n * @private\n */\nS2Cell.isValidId = function (cellId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bigint(\"cellId\", cellId);\n  //>>includeEnd('debug');\n\n  // Check if sentinel bit is missing.\n  if (cellId <= 0) {\n    return false;\n  }\n\n  // Check if face bits indicate a valid value, in range [0-5].\n  // eslint-disable-next-line\n  if (cellId >> BigInt(S2_POSITION_BITS) > 5) {\n    return false;\n  }\n\n  // Check trailing 1 bit is in one of the even bit positions allowed for the 30 levels, using a bitmask.\n  // eslint-disable-next-line no-undef\n  const lowestSetBit = cellId & (~cellId + BigInt(1));\n  // eslint-disable-next-line\n  if (!(lowestSetBit & BigInt(\"0x1555555555555555\"))) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Validates an S2 cell token.\n *\n * @param {string} [token] The hexadecimal representation of an S2CellId.\n * @returns {boolean} Returns true if the token is valid, returns false otherwise.\n * @private\n */\nS2Cell.isValidToken = function (token) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"token\", token);\n  //>>includeEnd('debug');\n\n  if (!/^[0-9a-fA-F]{1,16}$/.test(token)) {\n    return false;\n  }\n\n  return S2Cell.isValidId(S2Cell.getIdFromToken(token));\n};\n\n/**\n * Converts an S2 cell token to a 64-bit S2 cell ID.\n *\n * @param {string} [token] The hexadecimal representation of an S2CellId. Expected to be a valid S2 token.\n * @returns {bigint} Returns the S2 cell ID.\n * @private\n */\nS2Cell.getIdFromToken = function (token) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"token\", token);\n  //>>includeEnd('debug');\n\n  return BigInt(\"0x\" + token + \"0\".repeat(16 - token.length)); // eslint-disable-line\n};\n\n/**\n * Converts a 64-bit S2 cell ID to an S2 cell token.\n *\n * @param {bigint} [cellId] The S2 cell ID.\n * @returns {string} Returns hexadecimal representation of an S2CellId.\n * @private\n */\nS2Cell.getTokenFromId = function (cellId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bigint(\"cellId\", cellId);\n  //>>includeEnd('debug');\n\n  const trailingZeroHexChars = Math.floor(countTrailingZeroBits(cellId) / 4);\n  const hexString = cellId.toString(16).replace(/0*$/, \"\");\n\n  const zeroString = Array(17 - trailingZeroHexChars - hexString.length).join(\n    \"0\",\n  );\n  return zeroString + hexString;\n};\n\n/**\n * Gets the level of the cell from the cell ID.\n *\n * @param {bigint} [cellId] The S2 cell ID.\n * @returns {number} Returns the level of the cell.\n * @private\n */\nS2Cell.getLevel = function (cellId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bigint(\"cellId\", cellId);\n  if (!S2Cell.isValidId(cellId)) {\n    throw new DeveloperError();\n  }\n  //>>includeEnd('debug');\n\n  let lsbPosition = 0;\n  // eslint-disable-next-line\n  while (cellId !== BigInt(0)) {\n    // eslint-disable-next-line\n    if (cellId & BigInt(1)) {\n      break;\n    }\n    lsbPosition++;\n    cellId = cellId >> BigInt(1); // eslint-disable-line\n  }\n\n  // We use (>> 1) because there are 2 bits per level.\n  return S2_MAX_LEVEL - (lsbPosition >> 1);\n};\n\n/**\n * Gets the child cell of the cell at the given index.\n *\n * @param {number} index An integer index of the child.\n * @returns {S2Cell} The child of the S2Cell.\n * @private\n */\nS2Cell.prototype.getChild = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  if (index < 0 || index > 3) {\n    throw new DeveloperError(\"child index must be in the range [0-3].\");\n  }\n  if (this._level === 30) {\n    throw new DeveloperError(\"cannot get child of leaf cell.\");\n  }\n  //>>includeEnd('debug');\n\n  // Shift sentinel bit 2 positions to the right.\n  // eslint-disable-next-line no-undef\n  const newLsb = lsb(this._cellId) >> BigInt(2);\n  // Insert child index before the sentinel bit.\n  // eslint-disable-next-line no-undef\n  const childCellId = this._cellId + BigInt(2 * index + 1 - 4) * newLsb;\n  return new S2Cell(childCellId);\n};\n\n/**\n * Gets the parent cell of an S2Cell.\n *\n * @returns {S2Cell} Returns the parent of the S2Cell.\n * @private\n */\nS2Cell.prototype.getParent = function () {\n  //>>includeStart('debug', pragmas.debug);\n  if (this._level === 0) {\n    throw new DeveloperError(\"cannot get parent of root cell.\");\n  }\n  //>>includeEnd('debug');\n  // Shift the sentinel bit 2 positions to the left.\n  // eslint-disable-next-line no-undef\n  const newLsb = lsb(this._cellId) << BigInt(2);\n  // Erase the left over bits to the right of the sentinel bit.\n  // eslint-disable-next-line no-undef\n  return new S2Cell((this._cellId & (~newLsb + BigInt(1))) | newLsb);\n};\n\n/**\n * Gets the parent cell at the given level.\n *\n * @returns {S2Cell} Returns the parent of the S2Cell.\n * @private\n */\nS2Cell.prototype.getParentAtLevel = function (level) {\n  //>>includeStart('debug', pragmas.debug);\n  if (this._level === 0 || level < 0 || this._level < level) {\n    throw new DeveloperError(\"cannot get parent at invalid level.\");\n  }\n  //>>includeEnd('debug');\n  const newLsb = lsbForLevel(level);\n  return new S2Cell((this._cellId & -newLsb) | newLsb);\n};\n\n/**\n * Get center of the S2 cell.\n *\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid.\n * @returns {Cartesian3} The position of center of the S2 cell.\n * @private\n */\nS2Cell.prototype.getCenter = function (ellipsoid) {\n  ellipsoid = ellipsoid ?? Ellipsoid.WGS84;\n\n  let center = getS2Center(this._cellId, this._level);\n  // Normalize XYZ.\n  center = Cartesian3.normalize(center, center);\n  const cartographic = new Cartographic.fromCartesian(\n    center,\n    Ellipsoid.UNIT_SPHERE,\n  );\n  // Interpret as geodetic coordinates on the ellipsoid.\n  return Cartographic.toCartesian(cartographic, ellipsoid, new Cartesian3());\n};\n\n/**\n * Get vertex of the S2 cell. Vertices are indexed in CCW order.\n *\n * @param {number} index An integer index of the vertex. Must be in the range [0-3].\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid.\n * @returns {Cartesian3} The position of the vertex of the S2 cell.\n * @private\n */\nS2Cell.prototype.getVertex = function (index, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  if (index < 0 || index > 3) {\n    throw new DeveloperError(\"vertex index must be in the range [0-3].\");\n  }\n  //>>includeEnd('debug');\n\n  ellipsoid = ellipsoid ?? Ellipsoid.WGS84;\n\n  let vertex = getS2Vertex(this._cellId, this._level, index);\n  // Normalize XYZ.\n  vertex = Cartesian3.normalize(vertex, vertex);\n  const cartographic = new Cartographic.fromCartesian(\n    vertex,\n    Ellipsoid.UNIT_SPHERE,\n  );\n  // Interpret as geodetic coordinates on the ellipsoid.\n  return Cartographic.toCartesian(cartographic, ellipsoid, new Cartesian3());\n};\n\n/**\n * Creates an S2Cell from its face, position along the Hilbert curve for a given level.\n *\n * @param {number} face The root face of S2 this cell is on. Must be in the range [0-5].\n * @param {bigint} position The position along the Hilbert curve. Must be in the range [0-4**level).\n * @param {number} level The level of the S2 curve. Must be in the range [0-30].\n * @returns {S2Cell} A new S2Cell from the given parameters.\n * @private\n */\nS2Cell.fromFacePositionLevel = function (face, position, level) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bigint(\"position\", position);\n  if (face < 0 || face > 5) {\n    throw new DeveloperError(\"Invalid S2 Face (must be within 0-5)\");\n  }\n\n  if (level < 0 || level > S2_MAX_LEVEL) {\n    throw new DeveloperError(\"Invalid level (must be within 0-30)\");\n  }\n  if (position < 0 || position >= Math.pow(4, level)) {\n    throw new DeveloperError(\"Invalid Hilbert position for level\");\n  }\n  //>>includeEnd('debug');\n\n  const faceBitString =\n    (face < 4 ? \"0\" : \"\") + (face < 2 ? \"0\" : \"\") + face.toString(2);\n  const positionBitString = position.toString(2);\n  const positionPrefixPadding = Array(\n    2 * level - positionBitString.length + 1,\n  ).join(\"0\");\n  const positionSuffixPadding = Array(S2_POSITION_BITS - 2 * level).join(\"0\");\n\n  // eslint-disable-next-line no-undef\n  const cellId = BigInt(\n    `0b${faceBitString}${positionPrefixPadding}${positionBitString}1${\n      // Adding the sentinel bit that always follows the position bits.\n      positionSuffixPadding\n    }`,\n  );\n  return new S2Cell(cellId);\n};\n\n/**\n * @private\n */\nfunction getS2Center(cellId, level) {\n  const faceSiTi = convertCellIdToFaceSiTi(cellId, level);\n  return convertFaceSiTitoXYZ(faceSiTi[0], faceSiTi[1], faceSiTi[2]);\n}\n/**\n * @private\n */\nfunction getS2Vertex(cellId, level, index) {\n  const faceIJ = convertCellIdToFaceIJ(cellId, level);\n  const uv = convertIJLeveltoBoundUV([faceIJ[1], faceIJ[2]], level);\n  // Handles CCW ordering of the vertices.\n  const y = (index >> 1) & 1;\n  return convertFaceUVtoXYZ(faceIJ[0], uv[0][y ^ (index & 1)], uv[1][y]);\n}\n\n// S2 Coordinate Conversions\n\n/**\n * @private\n */\nfunction convertCellIdToFaceSiTi(cellId, level) {\n  const faceIJ = convertCellIdToFaceIJ(cellId);\n  const face = faceIJ[0];\n  const i = faceIJ[1];\n  const j = faceIJ[2];\n\n  // We're resolving the center when we do the coordinate transform here. For the leaf cells, we're adding half the cell size\n  // (remember that this space has 31 levels - which allows us to pick center and edges of the leaf cells). For non leaf cells,\n  // we get one of either two cells diagonal to the cell center. The correction is used to make sure we pick the leaf cell edges\n  // that represent the parent cell center.\n  const isLeaf = level === 30;\n  const shouldCorrect =\n    !isLeaf && (BigInt(i) ^ (cellId >> BigInt(2))) & BigInt(1); // eslint-disable-line\n  const correction = isLeaf ? 1 : shouldCorrect ? 2 : 0;\n  const si = (i << 1) + correction;\n  const ti = (j << 1) + correction;\n  return [face, si, ti];\n}\n\n/**\n * @private\n */\nfunction convertCellIdToFaceIJ(cellId) {\n  if (S2_LOOKUP_POSITIONS.length === 0) {\n    generateLookupTable();\n  }\n\n  // eslint-disable-next-line no-undef\n  const face = Number(cellId >> BigInt(S2_POSITION_BITS));\n  let bits = face & S2_SWAP_MASK;\n  const lookupMask = (1 << S2_LOOKUP_BITS) - 1;\n\n  let i = 0;\n  let j = 0;\n\n  for (let k = 7; k >= 0; k--) {\n    const numberOfBits =\n      k === 7 ? S2_MAX_LEVEL - 7 * S2_LOOKUP_BITS : S2_LOOKUP_BITS;\n    const extractMask = (1 << (2 * numberOfBits)) - 1;\n    bits +=\n      Number(\n        (cellId >> BigInt(k * 2 * S2_LOOKUP_BITS + 1)) & BigInt(extractMask), // eslint-disable-line\n      ) << 2;\n\n    bits = S2_LOOKUP_IJ[bits];\n\n    const offset = k * S2_LOOKUP_BITS;\n    i += (bits >> (S2_LOOKUP_BITS + 2)) << offset;\n    j += ((bits >> 2) & lookupMask) << offset;\n\n    bits &= S2_SWAP_MASK | S2_INVERT_MASK;\n  }\n\n  return [face, i, j];\n}\n\n/**\n * @private\n */\nfunction convertFaceSiTitoXYZ(face, si, ti) {\n  const s = convertSiTitoST(si);\n  const t = convertSiTitoST(ti);\n\n  const u = convertSTtoUV(s);\n  const v = convertSTtoUV(t);\n  return convertFaceUVtoXYZ(face, u, v);\n}\n\n/**\n * @private\n */\nfunction convertFaceUVtoXYZ(face, u, v) {\n  switch (face) {\n    case 0:\n      return new Cartesian3(1, u, v);\n    case 1:\n      return new Cartesian3(-u, 1, v);\n    case 2:\n      return new Cartesian3(-u, -v, 1);\n    case 3:\n      return new Cartesian3(-1, -v, -u);\n    case 4:\n      return new Cartesian3(v, -1, -u);\n    default:\n      return new Cartesian3(v, u, -1);\n  }\n}\n\n/**\n * S2 provides 3 methods for the non-linear transform: linear, quadratic and tangential.\n * This implementation uses the quadratic method because it provides a good balance of\n * accuracy and speed.\n *\n * For a more detailed comparison of these transform methods, see\n * {@link https://github.com/google/s2geometry/blob/0c4c460bdfe696da303641771f9def900b3e440f/src/s2/s2metrics.cc}\n * @private\n */\nfunction convertSTtoUV(s) {\n  if (s >= 0.5) {\n    return (1 / 3) * (4 * s * s - 1);\n  }\n  return (1 / 3) * (1 - 4 * (1 - s) * (1 - s));\n}\n\n/**\n * @private\n */\nfunction convertSiTitoST(si) {\n  return (1.0 / S2_MAX_SITI) * si;\n}\n\n/**\n * @private\n */\nfunction convertIJLeveltoBoundUV(ij, level) {\n  const result = [[], []];\n  const cellSize = getSizeIJ(level);\n  for (let d = 0; d < 2; ++d) {\n    const ijLow = ij[d] & -cellSize;\n    const ijHigh = ijLow + cellSize;\n    result[d][0] = convertSTtoUV(convertIJtoSTMinimum(ijLow));\n    result[d][1] = convertSTtoUV(convertIJtoSTMinimum(ijHigh));\n  }\n  return result;\n}\n\n/**\n * @private\n */\nfunction getSizeIJ(level) {\n  return (1 << (S2_MAX_LEVEL - level)) >>> 0;\n}\n\n/**\n * @private\n */\nfunction convertIJtoSTMinimum(i) {\n  return (1.0 / S2_LIMIT_IJ) * i;\n}\n\n// Utility Functions\n\n/**\n * This function generates 4 variations of a Hilbert curve of level 4, based on the S2_POSITION_TO_IJ table, for fast lookups of (i, j)\n * to position along Hilbert curve. The reference C++ implementation uses an iterative approach, however, this function is implemented\n * recursively.\n *\n * See {@link https://github.com/google/s2geometry/blob/c59d0ca01ae3976db7f8abdc83fcc871a3a95186/src/s2/s2cell_id.cc#L75-L109}\n * @private\n */\nfunction generateLookupCell(\n  level,\n  i,\n  j,\n  originalOrientation,\n  position,\n  orientation,\n) {\n  if (level === S2_LOOKUP_BITS) {\n    const ij = (i << S2_LOOKUP_BITS) + j;\n    S2_LOOKUP_POSITIONS[(ij << 2) + originalOrientation] =\n      (position << 2) + orientation;\n    S2_LOOKUP_IJ[(position << 2) + originalOrientation] =\n      (ij << 2) + orientation;\n  } else {\n    level++;\n    i <<= 1;\n    j <<= 1;\n    position <<= 2;\n    const r = S2_POSITION_TO_IJ[orientation];\n    generateLookupCell(\n      level,\n      i + (r[0] >> 1),\n      j + (r[0] & 1),\n      originalOrientation,\n      position,\n      orientation ^ S2_POSITION_TO_ORIENTATION_MASK[0],\n    );\n    generateLookupCell(\n      level,\n      i + (r[1] >> 1),\n      j + (r[1] & 1),\n      originalOrientation,\n      position + 1,\n      orientation ^ S2_POSITION_TO_ORIENTATION_MASK[1],\n    );\n    generateLookupCell(\n      level,\n      i + (r[2] >> 1),\n      j + (r[2] & 1),\n      originalOrientation,\n      position + 2,\n      orientation ^ S2_POSITION_TO_ORIENTATION_MASK[2],\n    );\n    generateLookupCell(\n      level,\n      i + (r[3] >> 1),\n      j + (r[3] & 1),\n      originalOrientation,\n      position + 3,\n      orientation ^ S2_POSITION_TO_ORIENTATION_MASK[3],\n    );\n  }\n}\n\n/**\n * @private\n */\nfunction generateLookupTable() {\n  generateLookupCell(0, 0, 0, 0, 0, 0);\n  generateLookupCell(0, 0, 0, S2_SWAP_MASK, 0, S2_SWAP_MASK);\n  generateLookupCell(0, 0, 0, S2_INVERT_MASK, 0, S2_INVERT_MASK);\n  generateLookupCell(\n    0,\n    0,\n    0,\n    S2_SWAP_MASK | S2_INVERT_MASK,\n    0,\n    S2_SWAP_MASK | S2_INVERT_MASK,\n  );\n}\n\n/**\n * Return the lowest-numbered bit that is on for this cell id\n * @private\n */\nfunction lsb(cellId) {\n  return cellId & (~cellId + BigInt(1)); // eslint-disable-line\n}\n\n/**\n * Return the lowest-numbered bit that is on for cells at the given level.\n * @private\n */\nfunction lsbForLevel(level) {\n  return BigInt(1) << BigInt(2 * (S2_MAX_LEVEL - level)); // eslint-disable-line\n}\n\n// Lookup table for getting trailing zero bits.\n// https://graphics.stanford.edu/~seander/bithacks.html\nconst Mod67BitPosition = [\n  64, 0, 1, 39, 2, 15, 40, 23, 3, 12, 16, 59, 41, 19, 24, 54, 4, 64, 13, 10, 17,\n  62, 60, 28, 42, 30, 20, 51, 25, 44, 55, 47, 5, 32, 65, 38, 14, 22, 11, 58, 18,\n  53, 63, 9, 61, 27, 29, 50, 43, 46, 31, 37, 21, 57, 52, 8, 26, 49, 45, 36, 56,\n  7, 48, 35, 6, 34, 33, 0,\n];\n\n/**\n * Return the number of trailing zeros in number.\n * @private\n */\nfunction countTrailingZeroBits(x) {\n  return Mod67BitPosition[(-x & x) % BigInt(67)]; // eslint-disable-line\n}\n\nexport default S2Cell;\n"],"mappings":"AAAA;AACA,OAAOA,UAAU,MAAM,iBAAiB;AACxC,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,KAAK,MAAM,YAAY;AAC9B,OAAOC,OAAO,MAAM,cAAc;AAClC,OAAOC,cAAc,MAAM,qBAAqB;AAChD,OAAOC,SAAS,MAAM,gBAAgB;AACtC,OAAOC,gBAAgB,MAAM,uBAAuB;AACpD,OAAOC,YAAY,MAAM,mBAAmB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAMC,YAAY,GAAG,EAAE;;AAEvB;AACA,MAAMC,WAAW,GAAG,CAAC,IAAID,YAAY;;AAErC;AACA,MAAME,WAAW,GAAI,CAAC,IAAKF,YAAY,GAAG,CAAE,KAAM,CAAC;;AAEnD;AACA,MAAMG,gBAAgB,GAAG,CAAC,GAAGH,YAAY,GAAG,CAAC;;AAE7C;AACA,MAAMI,cAAc,GAAG,CAAC;;AAExB;AACA,MAAMC,mBAAmB,GAAG,EAAE;;AAE9B;AACA,MAAMC,YAAY,GAAG,EAAE;;AAEvB;AACA,MAAMC,iBAAiB,GAAG,CACxB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AAAE;AACd,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AAAE;AACd,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AAAE;A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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}