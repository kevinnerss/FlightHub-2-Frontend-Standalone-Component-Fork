{"ast":null,"code":"import combine from \"../../Core/combine.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport SkinningStageVS from \"../../Shaders/Model/SkinningStageVS.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\n/**\n * The skinning pipeline stage processes the joint matrices of a skinned primitive.\n *\n * @namespace SkinningPipelineStage\n *\n * @private\n */\n\nconst SkinningPipelineStage = {\n  name: \"SkinningPipelineStage\",\n  // Helps with debugging\n\n  FUNCTION_ID_GET_SKINNING_MATRIX: \"getSkinningMatrix\",\n  FUNCTION_SIGNATURE_GET_SKINNING_MATRIX: \"mat4 getSkinningMatrix()\"\n};\n\n/**\n * This pipeline stage processes the joint matrices of a skinned primitive, adding\n * the relevant functions and uniforms to the shaders. The joint and weight attributes\n * themselves are processed in the geometry pipeline stage.\n *\n * Processes a primitive. This stage modifies the following parts of the render resources:\n * <ul>\n *  <li> adds the uniform declaration for the joint matrices in the vertex shader</li>\n *  <li> adds the function to compute the skinning matrix in the vertex shader</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @private\n */\nSkinningPipelineStage.process = function (renderResources, primitive) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addDefine(\"HAS_SKINNING\", undefined, ShaderDestination.VERTEX);\n  addGetSkinningMatrixFunction(shaderBuilder, primitive);\n  const runtimeNode = renderResources.runtimeNode;\n  const jointMatrices = runtimeNode.computedJointMatrices;\n  shaderBuilder.addUniform(\"mat4\", `u_jointMatrices[${jointMatrices.length}]`, ShaderDestination.VERTEX);\n  shaderBuilder.addVertexLines(SkinningStageVS);\n  const uniformMap = {\n    u_jointMatrices: function () {\n      return runtimeNode.computedJointMatrices;\n    }\n  };\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n};\nfunction getMaximumAttributeSetIndex(primitive) {\n  let setIndex = -1;\n  const attributes = primitive.attributes;\n  const length = attributes.length;\n  for (let i = 0; i < length; i++) {\n    const attribute = attributes[i];\n    const isJointsOrWeights = attribute.semantic === VertexAttributeSemantic.JOINTS || attribute.semantic === VertexAttributeSemantic.WEIGHTS;\n    if (!isJointsOrWeights) {\n      continue;\n    }\n    setIndex = Math.max(setIndex, attribute.setIndex);\n  }\n  return setIndex;\n}\nfunction addGetSkinningMatrixFunction(shaderBuilder, primitive) {\n  shaderBuilder.addFunction(SkinningPipelineStage.FUNCTION_ID_GET_SKINNING_MATRIX, SkinningPipelineStage.FUNCTION_SIGNATURE_GET_SKINNING_MATRIX, ShaderDestination.VERTEX);\n  const initialLine = \"mat4 skinnedMatrix = mat4(0);\";\n  shaderBuilder.addFunctionLines(SkinningPipelineStage.FUNCTION_ID_GET_SKINNING_MATRIX, [initialLine]);\n  let setIndex;\n  let componentIndex;\n  const componentStrings = [\"x\", \"y\", \"z\", \"w\"];\n  const maximumSetIndex = getMaximumAttributeSetIndex(primitive);\n  for (setIndex = 0; setIndex <= maximumSetIndex; setIndex++) {\n    for (componentIndex = 0; componentIndex <= 3; componentIndex++) {\n      const component = componentStrings[componentIndex];\n      // Example: skinnedMatrix += a_weights_0.x * u_jointMatrices[int(a_joints_0.x)];\n      const line = `skinnedMatrix += a_weights_${setIndex}.${component} * u_jointMatrices[int(a_joints_${setIndex}.${component})];`;\n      shaderBuilder.addFunctionLines(SkinningPipelineStage.FUNCTION_ID_GET_SKINNING_MATRIX, [line]);\n    }\n  }\n  const returnLine = \"return skinnedMatrix;\";\n  shaderBuilder.addFunctionLines(SkinningPipelineStage.FUNCTION_ID_GET_SKINNING_MATRIX, [returnLine]);\n}\nexport default SkinningPipelineStage;","map":{"version":3,"names":["combine","ShaderDestination","SkinningStageVS","VertexAttributeSemantic","SkinningPipelineStage","name","FUNCTION_ID_GET_SKINNING_MATRIX","FUNCTION_SIGNATURE_GET_SKINNING_MATRIX","process","renderResources","primitive","shaderBuilder","addDefine","undefined","VERTEX","addGetSkinningMatrixFunction","runtimeNode","jointMatrices","computedJointMatrices","addUniform","length","addVertexLines","uniformMap","u_jointMatrices","getMaximumAttributeSetIndex","setIndex","attributes","i","attribute","isJointsOrWeights","semantic","JOINTS","WEIGHTS","Math","max","addFunction","initialLine","addFunctionLines","componentIndex","componentStrings","maximumSetIndex","component","line","returnLine"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Model/SkinningPipelineStage.js"],"sourcesContent":["import combine from \"../../Core/combine.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport SkinningStageVS from \"../../Shaders/Model/SkinningStageVS.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\n/**\n * The skinning pipeline stage processes the joint matrices of a skinned primitive.\n *\n * @namespace SkinningPipelineStage\n *\n * @private\n */\n\nconst SkinningPipelineStage = {\n  name: \"SkinningPipelineStage\", // Helps with debugging\n\n  FUNCTION_ID_GET_SKINNING_MATRIX: \"getSkinningMatrix\",\n  FUNCTION_SIGNATURE_GET_SKINNING_MATRIX: \"mat4 getSkinningMatrix()\",\n};\n\n/**\n * This pipeline stage processes the joint matrices of a skinned primitive, adding\n * the relevant functions and uniforms to the shaders. The joint and weight attributes\n * themselves are processed in the geometry pipeline stage.\n *\n * Processes a primitive. This stage modifies the following parts of the render resources:\n * <ul>\n *  <li> adds the uniform declaration for the joint matrices in the vertex shader</li>\n *  <li> adds the function to compute the skinning matrix in the vertex shader</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @private\n */\nSkinningPipelineStage.process = function (renderResources, primitive) {\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  shaderBuilder.addDefine(\"HAS_SKINNING\", undefined, ShaderDestination.VERTEX);\n  addGetSkinningMatrixFunction(shaderBuilder, primitive);\n\n  const runtimeNode = renderResources.runtimeNode;\n  const jointMatrices = runtimeNode.computedJointMatrices;\n\n  shaderBuilder.addUniform(\n    \"mat4\",\n    `u_jointMatrices[${jointMatrices.length}]`,\n    ShaderDestination.VERTEX,\n  );\n\n  shaderBuilder.addVertexLines(SkinningStageVS);\n\n  const uniformMap = {\n    u_jointMatrices: function () {\n      return runtimeNode.computedJointMatrices;\n    },\n  };\n\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n};\n\nfunction getMaximumAttributeSetIndex(primitive) {\n  let setIndex = -1;\n  const attributes = primitive.attributes;\n  const length = attributes.length;\n  for (let i = 0; i < length; i++) {\n    const attribute = attributes[i];\n    const isJointsOrWeights =\n      attribute.semantic === VertexAttributeSemantic.JOINTS ||\n      attribute.semantic === VertexAttributeSemantic.WEIGHTS;\n\n    if (!isJointsOrWeights) {\n      continue;\n    }\n\n    setIndex = Math.max(setIndex, attribute.setIndex);\n  }\n\n  return setIndex;\n}\n\nfunction addGetSkinningMatrixFunction(shaderBuilder, primitive) {\n  shaderBuilder.addFunction(\n    SkinningPipelineStage.FUNCTION_ID_GET_SKINNING_MATRIX,\n    SkinningPipelineStage.FUNCTION_SIGNATURE_GET_SKINNING_MATRIX,\n    ShaderDestination.VERTEX,\n  );\n\n  const initialLine = \"mat4 skinnedMatrix = mat4(0);\";\n  shaderBuilder.addFunctionLines(\n    SkinningPipelineStage.FUNCTION_ID_GET_SKINNING_MATRIX,\n    [initialLine],\n  );\n\n  let setIndex;\n  let componentIndex;\n  const componentStrings = [\"x\", \"y\", \"z\", \"w\"];\n  const maximumSetIndex = getMaximumAttributeSetIndex(primitive);\n  for (setIndex = 0; setIndex <= maximumSetIndex; setIndex++) {\n    for (componentIndex = 0; componentIndex <= 3; componentIndex++) {\n      const component = componentStrings[componentIndex];\n      // Example: skinnedMatrix += a_weights_0.x * u_jointMatrices[int(a_joints_0.x)];\n      const line = `skinnedMatrix += a_weights_${setIndex}.${component} * u_jointMatrices[int(a_joints_${setIndex}.${component})];`;\n      shaderBuilder.addFunctionLines(\n        SkinningPipelineStage.FUNCTION_ID_GET_SKINNING_MATRIX,\n        [line],\n      );\n    }\n  }\n\n  const returnLine = \"return skinnedMatrix;\";\n  shaderBuilder.addFunctionLines(\n    SkinningPipelineStage.FUNCTION_ID_GET_SKINNING_MATRIX,\n    [returnLine],\n  );\n}\n\nexport default SkinningPipelineStage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}