{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Color from \"../Core/Color.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport writeTextToCanvas from \"../Core/writeTextToCanvas.js\";\nimport bitmapSDF from \"bitmap-sdf\";\nimport BillboardCollection from \"./BillboardCollection.js\";\nimport BillboardTexture from \"./BillboardTexture.js\";\nimport BlendOption from \"./BlendOption.js\";\nimport { isHeightReferenceClamp } from \"./HeightReference.js\";\nimport HorizontalOrigin from \"./HorizontalOrigin.js\";\nimport Label from \"./Label.js\";\nimport LabelStyle from \"./LabelStyle.js\";\nimport SDFSettings from \"./SDFSettings.js\";\nimport TextureAtlas from \"../Renderer/TextureAtlas.js\";\nimport VerticalOrigin from \"./VerticalOrigin.js\";\nimport GraphemeSplitter from \"grapheme-splitter\";\n\n/**\n * A glyph represents a single character in label.\n * @private\n */\nfunction Glyph() {\n  /**\n   * Object containing dimensions of the character as rendered to a canvas.\n   * @see {writeTextToCanvas}\n   * @type {object}\n   * @private\n   */\n  this.dimensions = undefined;\n\n  /**\n   * Reference to loaded image data for a single character, drawn in a particular style, shared and referenced across all labels.\n   * @type {BillboardTexture}\n   * @private\n   */\n  this.billboardTexture = undefined;\n\n  /**\n   * The individual billboard used to render the glyph. This may be <code>undefined</code> if the associated character is whitespace.\n   * @type {Billboard|undefined}\n   * @private\n   */\n  this.billboard = undefined;\n}\n\n// Traditionally, leading is %20 of the font size.\nconst defaultLineSpacingPercent = 1.2;\nconst whitePixelCanvasId = \"ID_WHITE_PIXEL\";\nconst whitePixelSize = new Cartesian2(4, 4);\nconst whitePixelBoundingRegion = new BoundingRectangle(1, 1, 1, 1);\n\n/**\n * Create the background image and start loading it into a texture\n * @private\n * @param {BillboardCollection} billboardCollection\n * @param {LabelCollection} labelCollection\n * @returns {Billboard}\n */\nfunction getWhitePixelBillboard(billboardCollection, labelCollection) {\n  const billboardTexture = labelCollection._backgroundBillboardTexture;\n  if (!billboardTexture.hasImage) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = whitePixelSize.x;\n    canvas.height = whitePixelSize.y;\n    const context2D = canvas.getContext(\"2d\");\n    context2D.fillStyle = \"#fff\";\n    context2D.fillRect(0, 0, canvas.width, canvas.height);\n    billboardTexture.loadImage(whitePixelCanvasId, canvas);\n    billboardTexture.addImageSubRegion(whitePixelCanvasId, whitePixelBoundingRegion);\n  }\n  const billboard = billboardCollection.add({\n    collection: labelCollection\n  });\n  billboard.setImageTexture(billboardTexture);\n  return billboard;\n}\n\n// reusable object for calling writeTextToCanvas\nconst writeTextToCanvasParameters = {};\nfunction createGlyphCanvas(character, font, fillColor, outlineColor, outlineWidth, style) {\n  writeTextToCanvasParameters.font = font;\n  writeTextToCanvasParameters.fillColor = fillColor;\n  writeTextToCanvasParameters.strokeColor = outlineColor;\n  writeTextToCanvasParameters.strokeWidth = outlineWidth;\n  // Setting the padding to something bigger is necessary to get enough space for the outlining.\n  writeTextToCanvasParameters.padding = SDFSettings.PADDING;\n  writeTextToCanvasParameters.fill = style === LabelStyle.FILL || style === LabelStyle.FILL_AND_OUTLINE;\n  writeTextToCanvasParameters.stroke = style === LabelStyle.OUTLINE || style === LabelStyle.FILL_AND_OUTLINE;\n  writeTextToCanvasParameters.backgroundColor = Color.BLACK;\n  return writeTextToCanvas(character, writeTextToCanvasParameters);\n}\nfunction unbindGlyphBillboard(labelCollection, glyph) {\n  const billboard = glyph.billboard;\n  if (defined(billboard)) {\n    billboard.show = false;\n    if (defined(billboard._removeCallbackFunc)) {\n      billboard._removeCallbackFunc();\n      billboard._removeCallbackFunc = undefined;\n    }\n    labelCollection._spareBillboards.push(billboard);\n    glyph.billboard = undefined;\n  }\n}\nconst splitter = new GraphemeSplitter();\nconst whitespaceRegex = /\\s/;\nfunction rebindAllGlyphs(labelCollection, label) {\n  const text = label._renderedText;\n  const graphemes = splitter.splitGraphemes(text);\n  const textLength = graphemes.length;\n  const glyphs = label._glyphs;\n  const glyphsLength = glyphs.length;\n\n  // Compute a font size scale relative to the sdf font generated size.\n  label._relativeSize = label._fontSize / SDFSettings.FONT_SIZE;\n\n  // if we have more glyphs than needed, unbind the extras.\n  if (textLength < glyphsLength) {\n    for (let glyphIndex = textLength; glyphIndex < glyphsLength; ++glyphIndex) {\n      unbindGlyphBillboard(labelCollection, glyphs[glyphIndex]);\n    }\n  }\n\n  // presize glyphs to match the new text length\n  glyphs.length = textLength;\n  const showBackground = label.show && label._showBackground && text.split(\"\\n\").join(\"\").length > 0;\n  let backgroundBillboard = label._backgroundBillboard;\n  const backgroundBillboardCollection = labelCollection._backgroundBillboardCollection;\n  if (!showBackground) {\n    if (defined(backgroundBillboard)) {\n      backgroundBillboardCollection.remove(backgroundBillboard);\n      label._backgroundBillboard = backgroundBillboard = undefined;\n    }\n  } else {\n    if (!defined(backgroundBillboard)) {\n      backgroundBillboard = getWhitePixelBillboard(backgroundBillboardCollection, labelCollection);\n      label._backgroundBillboard = backgroundBillboard;\n    }\n    backgroundBillboard.color = label._backgroundColor;\n    backgroundBillboard.show = label._show;\n    backgroundBillboard.position = label._position;\n    backgroundBillboard.eyeOffset = label._eyeOffset;\n    backgroundBillboard.pixelOffset = label._pixelOffset;\n    backgroundBillboard.horizontalOrigin = HorizontalOrigin.LEFT;\n    backgroundBillboard.verticalOrigin = label._verticalOrigin;\n    backgroundBillboard.heightReference = label._heightReference;\n    backgroundBillboard.scale = label.totalScale;\n    backgroundBillboard.pickPrimitive = label;\n    backgroundBillboard.id = label._id;\n    backgroundBillboard.translucencyByDistance = label._translucencyByDistance;\n    backgroundBillboard.pixelOffsetScaleByDistance = label._pixelOffsetScaleByDistance;\n    backgroundBillboard.scaleByDistance = label._scaleByDistance;\n    backgroundBillboard.distanceDisplayCondition = label._distanceDisplayCondition;\n    backgroundBillboard.disableDepthTestDistance = label._disableDepthTestDistance;\n    backgroundBillboard.clusterShow = label.clusterShow;\n  }\n  const glyphBillboardCollection = labelCollection._glyphBillboardCollection;\n  const glyphTextureCache = glyphBillboardCollection.billboardTextureCache;\n  const textDimensionsCache = labelCollection._textDimensionsCache;\n\n  // walk the text looking for new characters (creating new glyphs for each)\n  // or changed characters (rebinding existing glyphs)\n  for (let textIndex = 0; textIndex < textLength; ++textIndex) {\n    const character = graphemes[textIndex];\n    const verticalOrigin = label._verticalOrigin;\n    const id = JSON.stringify([character, label._fontFamily, label._fontStyle, label._fontWeight, +verticalOrigin]);\n    let dimensions = textDimensionsCache[id];\n    let glyphBillboardTexture = glyphTextureCache.get(id);\n    if (!defined(glyphBillboardTexture) || !defined(dimensions)) {\n      glyphBillboardTexture = new BillboardTexture(glyphBillboardCollection);\n      glyphTextureCache.set(id, glyphBillboardTexture);\n      const glyphFont = `${label._fontStyle} ${label._fontWeight} ${SDFSettings.FONT_SIZE}px ${label._fontFamily}`;\n      const canvas = createGlyphCanvas(character, glyphFont, Color.WHITE, Color.WHITE, 0.0, LabelStyle.FILL);\n      dimensions = canvas.dimensions;\n      textDimensionsCache[id] = dimensions;\n      if (canvas.width > 0 && canvas.height > 0 && !whitespaceRegex.test(character)) {\n        const sdfValues = bitmapSDF(canvas, {\n          cutoff: SDFSettings.CUTOFF,\n          radius: SDFSettings.RADIUS\n        });\n\n        // Context is originally created in writeTextToCanvas()\n        const ctx = canvas.getContext(\"2d\");\n        const canvasWidth = canvas.width;\n        const canvasHeight = canvas.height;\n        const imgData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\n        for (let i = 0; i < canvasWidth; i++) {\n          for (let j = 0; j < canvasHeight; j++) {\n            const baseIndex = j * canvasWidth + i;\n            const alpha = sdfValues[baseIndex] * 255;\n            const imageIndex = baseIndex * 4;\n            imgData.data[imageIndex + 0] = alpha;\n            imgData.data[imageIndex + 1] = alpha;\n            imgData.data[imageIndex + 2] = alpha;\n            imgData.data[imageIndex + 3] = alpha;\n          }\n        }\n        ctx.putImageData(imgData, 0, 0);\n        glyphBillboardTexture.loadImage(id, canvas);\n      }\n    }\n    let glyph = glyphs[textIndex];\n    if (!defined(glyph)) {\n      glyph = new Glyph();\n      glyph.dimensions = dimensions;\n      glyph.billboardTexture = glyphBillboardTexture;\n      glyphs[textIndex] = glyph;\n    }\n    if (glyph.billboardTexture.id !== id) {\n      // This glyph has been mapped to a new texture. If we had one before, release\n      // our reference to that texture and dimensions, but reuse the billboard.\n      glyph.billboardTexture = glyphBillboardTexture;\n      glyph.dimensions = dimensions;\n    }\n    if (!glyphBillboardTexture.hasImage) {\n      // No texture, and therefore no billboard, for this glyph.\n      // so, completely unbind glyph to free up the billboard for others\n      unbindGlyphBillboard(labelCollection, glyph);\n      continue;\n    }\n\n    // If we have a texture, configure the existing billboard, or obtain one\n    let billboard = glyph.billboard;\n    const spareBillboards = labelCollection._spareBillboards;\n    if (!defined(billboard)) {\n      if (spareBillboards.length > 0) {\n        billboard = spareBillboards.pop();\n      } else {\n        billboard = glyphBillboardCollection.add({\n          collection: labelCollection\n        });\n        billboard._labelDimensions = new Cartesian2();\n        billboard._labelTranslate = new Cartesian2();\n        billboard._positionFromParent = true;\n      }\n      glyph.billboard = billboard;\n    }\n    billboard.setImageTexture(glyphBillboardTexture);\n    billboard.show = label._show;\n    billboard.position = label._position;\n    billboard.eyeOffset = label._eyeOffset;\n    billboard.pixelOffset = label._pixelOffset;\n    billboard.horizontalOrigin = HorizontalOrigin.LEFT;\n    billboard.verticalOrigin = label._verticalOrigin;\n    billboard.heightReference = label._heightReference;\n    billboard.scale = label.totalScale;\n    billboard.pickPrimitive = label;\n    billboard.id = label._id;\n    billboard.translucencyByDistance = label._translucencyByDistance;\n    billboard.pixelOffsetScaleByDistance = label._pixelOffsetScaleByDistance;\n    billboard.scaleByDistance = label._scaleByDistance;\n    billboard.distanceDisplayCondition = label._distanceDisplayCondition;\n    billboard.disableDepthTestDistance = label._disableDepthTestDistance;\n    billboard._batchIndex = label._batchIndex;\n    billboard.outlineColor = label.outlineColor;\n    if (label.style === LabelStyle.FILL_AND_OUTLINE) {\n      billboard.color = label._fillColor;\n      billboard.outlineWidth = label.outlineWidth;\n    } else if (label.style === LabelStyle.FILL) {\n      billboard.color = label._fillColor;\n      billboard.outlineWidth = 0.0;\n    } else if (label.style === LabelStyle.OUTLINE) {\n      billboard.color = Color.TRANSPARENT;\n      billboard.outlineWidth = label.outlineWidth;\n    }\n  }\n\n  // changing glyphs will cause the position of the\n  // glyphs to change, since different characters have different widths\n  label._repositionAllGlyphs = true;\n}\nfunction calculateWidthOffset(lineWidth, horizontalOrigin, backgroundPadding) {\n  if (horizontalOrigin === HorizontalOrigin.CENTER) {\n    return -lineWidth / 2;\n  } else if (horizontalOrigin === HorizontalOrigin.RIGHT) {\n    return -(lineWidth + backgroundPadding.x);\n  }\n  return backgroundPadding.x;\n}\n\n// reusable Cartesian2 instances\nconst glyphPixelOffset = new Cartesian2();\nconst scratchBackgroundPadding = new Cartesian2();\nfunction repositionAllGlyphs(label) {\n  const glyphs = label._glyphs;\n  const text = label._renderedText;\n  let lastLineWidth = 0;\n  let maxLineWidth = 0;\n  const lineWidths = [];\n  let maxGlyphDescent = Number.NEGATIVE_INFINITY;\n  let maxGlyphY = 0;\n  let numberOfLines = 1;\n  const glyphLength = glyphs.length;\n  const backgroundBillboard = label._backgroundBillboard;\n  const backgroundPadding = Cartesian2.clone(defined(backgroundBillboard) ? label._backgroundPadding : Cartesian2.ZERO, scratchBackgroundPadding);\n\n  // We need to scale the background padding, which is specified in pixels by the inverse of the relative size so it is scaled properly.\n  backgroundPadding.x /= label._relativeSize;\n  backgroundPadding.y /= label._relativeSize;\n  for (let glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {\n    if (text.charAt(glyphIndex) === \"\\n\") {\n      lineWidths.push(lastLineWidth);\n      ++numberOfLines;\n      lastLineWidth = 0;\n      continue;\n    }\n    const glyph = glyphs[glyphIndex];\n    const dimensions = glyph.dimensions;\n    if (defined(dimensions)) {\n      maxGlyphY = Math.max(maxGlyphY, dimensions.height - dimensions.descent);\n      maxGlyphDescent = Math.max(maxGlyphDescent, dimensions.descent);\n\n      // Computing the line width must also account for the kerning that occurs between letters.\n      lastLineWidth += dimensions.width - dimensions.minx;\n      if (glyphIndex < glyphLength - 1) {\n        lastLineWidth += glyphs[glyphIndex + 1].dimensions.minx;\n      }\n      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n    }\n  }\n  lineWidths.push(lastLineWidth);\n  const maxLineHeight = maxGlyphY + maxGlyphDescent;\n  const scale = label.totalScale;\n  const horizontalOrigin = label._horizontalOrigin;\n  const verticalOrigin = label._verticalOrigin;\n  let lineIndex = 0;\n  let lineWidth = lineWidths[lineIndex];\n  let widthOffset = calculateWidthOffset(lineWidth, horizontalOrigin, backgroundPadding);\n  const lineSpacing = (defined(label._lineHeight) ? label._lineHeight : defaultLineSpacingPercent * label._fontSize) / label._relativeSize;\n  const otherLinesHeight = lineSpacing * (numberOfLines - 1);\n  let totalLineWidth = maxLineWidth;\n  let totalLineHeight = maxLineHeight + otherLinesHeight;\n  if (defined(backgroundBillboard)) {\n    totalLineWidth += backgroundPadding.x * 2;\n    totalLineHeight += backgroundPadding.y * 2;\n    backgroundBillboard._labelHorizontalOrigin = horizontalOrigin;\n  }\n  glyphPixelOffset.x = widthOffset * scale;\n  glyphPixelOffset.y = 0;\n  let firstCharOfLine = true;\n  let lineOffsetY = 0;\n  for (let glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {\n    if (text.charAt(glyphIndex) === \"\\n\") {\n      ++lineIndex;\n      lineOffsetY += lineSpacing;\n      lineWidth = lineWidths[lineIndex];\n      widthOffset = calculateWidthOffset(lineWidth, horizontalOrigin, backgroundPadding);\n      glyphPixelOffset.x = widthOffset * scale;\n      firstCharOfLine = true;\n      continue;\n    }\n    const glyph = glyphs[glyphIndex];\n    const dimensions = glyph.dimensions;\n    if (defined(dimensions)) {\n      if (verticalOrigin === VerticalOrigin.TOP) {\n        glyphPixelOffset.y = dimensions.height - maxGlyphY - backgroundPadding.y;\n        glyphPixelOffset.y += SDFSettings.PADDING;\n      } else if (verticalOrigin === VerticalOrigin.CENTER) {\n        glyphPixelOffset.y = (otherLinesHeight + dimensions.height - maxGlyphY) / 2;\n      } else if (verticalOrigin === VerticalOrigin.BASELINE) {\n        glyphPixelOffset.y = otherLinesHeight;\n        glyphPixelOffset.y -= SDFSettings.PADDING;\n      } else {\n        // VerticalOrigin.BOTTOM\n        glyphPixelOffset.y = otherLinesHeight + maxGlyphDescent + backgroundPadding.y;\n        glyphPixelOffset.y -= SDFSettings.PADDING;\n      }\n      glyphPixelOffset.y = (glyphPixelOffset.y - dimensions.descent - lineOffsetY) * scale;\n\n      // Handle any offsets for the first character of the line since the bounds might not be right on the bottom left pixel.\n      if (firstCharOfLine) {\n        glyphPixelOffset.x -= SDFSettings.PADDING * scale;\n        firstCharOfLine = false;\n      }\n      if (defined(glyph.billboard)) {\n        glyph.billboard._setTranslate(glyphPixelOffset);\n        glyph.billboard._labelDimensions.x = totalLineWidth;\n        glyph.billboard._labelDimensions.y = totalLineHeight;\n        glyph.billboard._labelHorizontalOrigin = horizontalOrigin;\n      }\n\n      //Compute the next x offset taking into account the kerning performed\n      //on both the current letter as well as the next letter to be drawn\n      //as well as any applied scale.\n      if (glyphIndex < glyphLength - 1) {\n        const nextGlyph = glyphs[glyphIndex + 1];\n        glyphPixelOffset.x += (dimensions.width - dimensions.minx + nextGlyph.dimensions.minx) * scale;\n      }\n    }\n  }\n  if (defined(backgroundBillboard) && text.split(\"\\n\").join(\"\").length > 0) {\n    if (horizontalOrigin === HorizontalOrigin.CENTER) {\n      widthOffset = -maxLineWidth / 2 - backgroundPadding.x;\n    } else if (horizontalOrigin === HorizontalOrigin.RIGHT) {\n      widthOffset = -(maxLineWidth + backgroundPadding.x * 2);\n    } else {\n      widthOffset = 0;\n    }\n    glyphPixelOffset.x = widthOffset * scale;\n    if (verticalOrigin === VerticalOrigin.TOP) {\n      glyphPixelOffset.y = maxLineHeight - maxGlyphY - maxGlyphDescent;\n    } else if (verticalOrigin === VerticalOrigin.CENTER) {\n      glyphPixelOffset.y = (maxLineHeight - maxGlyphY) / 2 - maxGlyphDescent;\n    } else if (verticalOrigin === VerticalOrigin.BASELINE) {\n      glyphPixelOffset.y = -backgroundPadding.y - maxGlyphDescent;\n    } else {\n      // VerticalOrigin.BOTTOM\n      glyphPixelOffset.y = 0;\n    }\n    glyphPixelOffset.y = glyphPixelOffset.y * scale;\n    backgroundBillboard.width = totalLineWidth;\n    backgroundBillboard.height = totalLineHeight;\n    backgroundBillboard._setTranslate(glyphPixelOffset);\n    backgroundBillboard._labelTranslate = Cartesian2.clone(glyphPixelOffset, backgroundBillboard._labelTranslate);\n  }\n  if (isHeightReferenceClamp(label.heightReference)) {\n    for (let glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {\n      const glyph = glyphs[glyphIndex];\n      const billboard = glyph.billboard;\n      if (defined(billboard)) {\n        billboard._labelTranslate = Cartesian2.clone(glyphPixelOffset, billboard._labelTranslate);\n      }\n    }\n  }\n}\nfunction destroyLabel(labelCollection, label) {\n  const glyphs = label._glyphs;\n  for (let i = 0, len = glyphs.length; i < len; ++i) {\n    unbindGlyphBillboard(labelCollection, glyphs[i]);\n  }\n  if (defined(label._backgroundBillboard)) {\n    labelCollection._backgroundBillboardCollection.remove(label._backgroundBillboard);\n    label._backgroundBillboard = undefined;\n  }\n  label._labelCollection = undefined;\n  if (defined(label._removeCallbackFunc)) {\n    label._removeCallbackFunc();\n  }\n  destroyObject(label);\n}\n\n/**\n * A renderable collection of labels.  Labels are viewport-aligned text positioned in the 3D scene.\n * Each label can have a different font, color, scale, etc.\n * <br /><br />\n * <div align='center'>\n * <img src='Images/Label.png' width='400' height='300' /><br />\n * Example labels\n * </div>\n * <br /><br />\n * Labels are added and removed from the collection using {@link LabelCollection#add}\n * and {@link LabelCollection#remove}.\n *\n * @alias LabelCollection\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each label from model to world coordinates.\n * @param {boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {Scene} [options.scene] Must be passed in for labels that use the height reference property or will be depth tested against the globe.\n * @param {BlendOption} [options.blendOption=BlendOption.OPAQUE_AND_TRANSLUCENT] The label blending option. The default\n * is used for rendering both opaque and translucent labels. However, if either all of the labels are completely opaque or all are completely translucent,\n * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.\n * @param {boolean} [options.show=true] Determines if the labels in the collection will be shown.\n *\n * @performance For best performance, prefer a few collections, each with many labels, to\n * many collections with only a few labels each.  Avoid having collections where some\n * labels change every frame and others do not; instead, create one or more collections\n * for static labels, and one or more collections for dynamic labels.\n *\n * @see LabelCollection#add\n * @see LabelCollection#remove\n * @see Label\n * @see BillboardCollection\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Labels.html|Cesium Sandcastle Labels Demo}\n *\n * @example\n * // Create a label collection with two labels\n * const labels = scene.primitives.add(new Cesium.LabelCollection());\n * labels.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   text : 'A label'\n * });\n * labels.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   text : 'Another label'\n * });\n */\nfunction LabelCollection(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  this._scene = options.scene;\n  this._batchTable = options.batchTable;\n  const backgroundBillboardCollection = new BillboardCollection({\n    scene: this._scene,\n    textureAtlas: new TextureAtlas({\n      initialSize: whitePixelSize\n    })\n  });\n  this._backgroundBillboardCollection = backgroundBillboardCollection;\n  this._backgroundBillboardTexture = new BillboardTexture(backgroundBillboardCollection);\n  this._glyphBillboardCollection = new BillboardCollection({\n    scene: this._scene,\n    batchTable: this._batchTable\n  });\n  this._glyphBillboardCollection._sdf = true;\n  this._spareBillboards = [];\n  this._textDimensionsCache = {};\n  this._labels = [];\n  this._labelsToUpdate = [];\n  this._totalGlyphCount = 0;\n  this._highlightColor = Color.clone(Color.WHITE); // Only used by Vector3DTilePoints\n\n  /**\n   * Determines if labels in this collection will be shown.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.show = options.show ?? true;\n\n  /**\n   * The 4x4 transformation matrix that transforms each label in this collection from model to world coordinates.\n   * When this is the identity matrix, the labels are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type Matrix4\n   * @default {@link Matrix4.IDENTITY}\n   *\n   * @example\n   * const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * labels.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0),\n   *   text     : 'Center'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0),\n   *   text     : 'East'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0),\n   *   text     : 'North'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0),\n   *   text     : 'Up'\n   * });\n   */\n  this.modelMatrix = Matrix4.clone(options.modelMatrix ?? Matrix4.IDENTITY);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = options.debugShowBoundingVolume ?? false;\n\n  /**\n   * The label blending option. The default is used for rendering both opaque and translucent labels.\n   * However, if either all of the labels are completely opaque or all are completely translucent,\n   * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve\n   * performance by up to 2x.\n   * @type {BlendOption}\n   * @default BlendOption.OPAQUE_AND_TRANSLUCENT\n   */\n  this.blendOption = options.blendOption ?? BlendOption.OPAQUE_AND_TRANSLUCENT;\n}\nObject.defineProperties(LabelCollection.prototype, {\n  /**\n   * Returns the number of labels in this collection.  This is commonly used with\n   * {@link LabelCollection#get} to iterate over all the labels\n   * in the collection.\n   * @memberof LabelCollection.prototype\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._labels.length;\n    }\n  },\n  /**\n   * Returns the size in bytes of the WebGL texture resources.\n   * @private\n   * @memberof LabelCollection.prototype\n   * @type {number}\n   * @readonly\n   */\n  sizeInBytes: {\n    get: function () {\n      return this._glyphBillboardCollection.sizeInBytes + this._backgroundBillboardCollection.sizeInBytes;\n    }\n  },\n  /**\n   * True when all labels currently in the collection are ready for rendering.\n   * @private\n   * @memberof LabelCollection.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      const backgroundBillboard = this._backgroundBillboardCollection.get(0);\n      if (defined(backgroundBillboard) && !backgroundBillboard.ready) {\n        return false;\n      }\n      return this._glyphBillboardCollection.ready;\n    }\n  }\n});\n\n/**\n * Creates and adds a label with the specified initial properties to the collection.\n * The added label is returned so it can be modified or removed from the collection later.\n *\n * @param {Label.ConstructorOptions} [options] A template describing the label's properties as shown in Example 1.\n * @returns {Label} The label that was added to the collection.\n *\n * @performance Calling <code>add</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten; this operations is <code>O(n)</code> and also incurs\n * CPU to GPU overhead.  For best performance, add as many billboards as possible before\n * calling <code>update</code>.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * // Example 1:  Add a label, specifying all the default values.\n * const l = labels.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   text : '',\n *   font : '30px sans-serif',\n *   fillColor : Cesium.Color.WHITE,\n *   outlineColor : Cesium.Color.BLACK,\n *   outlineWidth : 1.0,\n *   showBackground : false,\n *   backgroundColor : new Cesium.Color(0.165, 0.165, 0.165, 0.8),\n *   backgroundPadding : new Cesium.Cartesian2(7, 5),\n *   style : Cesium.LabelStyle.FILL,\n *   pixelOffset : Cesium.Cartesian2.ZERO,\n *   eyeOffset : Cesium.Cartesian3.ZERO,\n *   horizontalOrigin : Cesium.HorizontalOrigin.LEFT,\n *   verticalOrigin : Cesium.VerticalOrigin.BASELINE,\n *   scale : 1.0,\n *   translucencyByDistance : undefined,\n *   pixelOffsetScaleByDistance : undefined,\n *   heightReference : HeightReference.NONE,\n *   distanceDisplayCondition : undefined\n * });\n *\n * @example\n * // Example 2:  Specify only the label's cartographic position,\n * // text, and font.\n * const l = labels.add({\n *   position : Cesium.Cartesian3.fromRadians(longitude, latitude, height),\n *   text : 'Hello World',\n *   font : '24px Helvetica',\n * });\n *\n *\n * @see LabelCollection#remove\n * @see LabelCollection#removeAll\n */\nLabelCollection.prototype.add = function (options) {\n  const label = new Label(options, this);\n  this._labels.push(label);\n  this._labelsToUpdate.push(label);\n  return label;\n};\n\n/**\n * Removes a label from the collection.  Once removed, a label is no longer usable.\n *\n * @param {Label} label The label to remove.\n * @returns {boolean} <code>true</code> if the label was removed; <code>false</code> if the label was not found in the collection.\n *\n * @performance Calling <code>remove</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, remove as many labels as possible before calling <code>update</code>.\n * If you intend to temporarily hide a label, it is usually more efficient to call\n * {@link Label#show} instead of removing and re-adding the label.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * const l = labels.add(...);\n * labels.remove(l);  // Returns true\n *\n * @see LabelCollection#add\n * @see LabelCollection#removeAll\n * @see Label#show\n */\nLabelCollection.prototype.remove = function (label) {\n  if (defined(label) && label._labelCollection === this) {\n    const index = this._labels.indexOf(label);\n    if (index !== -1) {\n      this._labels.splice(index, 1);\n      destroyLabel(this, label);\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Removes all labels from the collection.\n *\n * @performance <code>O(n)</code>.  It is more efficient to remove all the labels\n * from a collection and then add new ones than to create a new collection entirely.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * labels.add(...);\n * labels.add(...);\n * labels.removeAll();\n *\n * @see LabelCollection#add\n * @see LabelCollection#remove\n */\nLabelCollection.prototype.removeAll = function () {\n  const labels = this._labels;\n  for (let i = 0, len = labels.length; i < len; ++i) {\n    destroyLabel(this, labels[i]);\n  }\n  labels.length = 0;\n};\n\n/**\n * Check whether this collection contains a given label.\n *\n * @param {Label} label The label to check for.\n * @returns {boolean} true if this collection contains the label, false otherwise.\n *\n * @see LabelCollection#get\n *\n */\nLabelCollection.prototype.contains = function (label) {\n  return defined(label) && label._labelCollection === this;\n};\n\n/**\n * Returns the label in the collection at the specified index.  Indices are zero-based\n * and increase as labels are added.  Removing a label shifts all labels after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link LabelCollection#length} to iterate over all the labels\n * in the collection.\n *\n * @param {number} index The zero-based index of the billboard.\n *\n * @returns {Label} The label at the specified index.\n *\n * @performance Expected constant time.  If labels were removed from the collection and\n * {@link Scene#render} was not called, an implicit <code>O(n)</code>\n * operation is performed.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Toggle the show property of every label in the collection\n * const len = labels.length;\n * for (let i = 0; i < len; ++i) {\n *   const l = billboards.get(i);\n *   l.show = !l.show;\n * }\n *\n * @see LabelCollection#length\n */\nLabelCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return this._labels[index];\n};\n\n/**\n * @private\n */\nLabelCollection.prototype.update = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n  const glyphBillboardCollection = this._glyphBillboardCollection;\n  const backgroundBillboardCollection = this._backgroundBillboardCollection;\n  glyphBillboardCollection.modelMatrix = this.modelMatrix;\n  glyphBillboardCollection.debugShowBoundingVolume = this.debugShowBoundingVolume;\n  backgroundBillboardCollection.modelMatrix = this.modelMatrix;\n  backgroundBillboardCollection.debugShowBoundingVolume = this.debugShowBoundingVolume;\n  const len = this._labelsToUpdate.length;\n  for (let i = 0; i < len; ++i) {\n    const label = this._labelsToUpdate[i];\n    if (label.isDestroyed()) {\n      continue;\n    }\n    const preUpdateGlyphCount = label._glyphs.length;\n    if (label._rebindAllGlyphs) {\n      rebindAllGlyphs(this, label);\n      label._rebindAllGlyphs = false;\n    }\n    if (label._repositionAllGlyphs) {\n      repositionAllGlyphs(label);\n      label._repositionAllGlyphs = false;\n    }\n    const glyphCountDifference = label._glyphs.length - preUpdateGlyphCount;\n    this._totalGlyphCount += glyphCountDifference;\n  }\n  const blendOption = backgroundBillboardCollection.length > 0 ? BlendOption.TRANSLUCENT : this.blendOption;\n  glyphBillboardCollection.blendOption = blendOption;\n  backgroundBillboardCollection.blendOption = blendOption;\n  glyphBillboardCollection._highlightColor = this._highlightColor;\n  backgroundBillboardCollection._highlightColor = this._highlightColor;\n  this._labelsToUpdate.length = 0;\n  backgroundBillboardCollection.update(frameState);\n  glyphBillboardCollection.update(frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n *\n * @see LabelCollection#destroy\n */\nLabelCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * labels = labels && labels.destroy();\n *\n * @see LabelCollection#isDestroyed\n */\nLabelCollection.prototype.destroy = function () {\n  this.removeAll();\n  this._glyphBillboardCollection = this._glyphBillboardCollection.destroy();\n  this._backgroundBillboardCollection = this._backgroundBillboardCollection.destroy();\n  return destroyObject(this);\n};\nexport default LabelCollection;","map":{"version":3,"names":["BoundingRectangle","Cartesian2","Color","Frozen","defined","destroyObject","DeveloperError","Matrix4","writeTextToCanvas","bitmapSDF","BillboardCollection","BillboardTexture","BlendOption","isHeightReferenceClamp","HorizontalOrigin","Label","LabelStyle","SDFSettings","TextureAtlas","VerticalOrigin","GraphemeSplitter","Glyph","dimensions","undefined","billboardTexture","billboard","defaultLineSpacingPercent","whitePixelCanvasId","whitePixelSize","whitePixelBoundingRegion","getWhitePixelBillboard","billboardCollection","labelCollection","_backgroundBillboardTexture","hasImage","canvas","document","createElement","width","x","height","y","context2D","getContext","fillStyle","fillRect","loadImage","addImageSubRegion","add","collection","setImageTexture","writeTextToCanvasParameters","createGlyphCanvas","character","font","fillColor","outlineColor","outlineWidth","style","strokeColor","strokeWidth","padding","PADDING","fill","FILL","FILL_AND_OUTLINE","stroke","OUTLINE","backgroundColor","BLACK","unbindGlyphBillboard","glyph","show","_removeCallbackFunc","_spareBillboards","push","splitter","whitespaceRegex","rebindAllGlyphs","label","text","_renderedText","graphemes","splitGraphemes","textLength","length","glyphs","_glyphs","glyphsLength","_relativeSize","_fontSize","FONT_SIZE","glyphIndex","showBackground","_showBackground","split","join","backgroundBillboard","_backgroundBillboard","backgroundBillboardCollection","_backgroundBillboardCollection","remove","color","_backgroundColor","_show","position","_position","eyeOffset","_eyeOffset","pixelOffset","_pixelOffset","horizontalOrigin","LEFT","verticalOrigin","_verticalOrigin","heightReference","_heightReference","scale","totalScale","pickPrimitive","id","_id","translucencyByDistance","_translucencyByDistance","pixelOffsetScaleByDistance","_pixelOffsetScaleByDistance","scaleByDistance","_scaleByDistance","distanceDisplayCondition","_distanceDisplayCondition","disableDepthTestDistance","_disableDepthTestDistance","clusterShow","glyphBillboardCollection","_glyphBillboardCollection","glyphTextureCache","billboardTextureCache","textDimensionsCache","_textDimensionsCache","textIndex","JSON","stringify","_fontFamily","_fontStyle","_fontWeight","glyphBillboardTexture","get","set","glyphFont","WHITE","test","sdfValues","cutoff","CUTOFF","radius","RADIUS","ctx","canvasWidth","canvasHeight","imgData","getImageData","i","j","baseIndex","alpha","imageIndex","data","putImageData","spareBillboards","pop","_labelDimensions","_labelTranslate","_positionFromParent","_batchIndex","_fillColor","TRANSPARENT","_repositionAllGlyphs","calculateWidthOffset","lineWidth","backgroundPadding","CENTER","RIGHT","glyphPixelOffset","scratchBackgroundPadding","repositionAllGlyphs","lastLineWidth","maxLineWidth","lineWidths","maxGlyphDescent","Number","NEGATIVE_INFINITY","maxGlyphY","numberOfLines","glyphLength","clone","_backgroundPadding","ZERO","charAt","Math","max","descent","minx","maxLineHeight","_horizontalOrigin","lineIndex","widthOffset","lineSpacing","_lineHeight","otherLinesHeight","totalLineWidth","totalLineHeight","_labelHorizontalOrigin","firstCharOfLine","lineOffsetY","TOP","BASELINE","_setTranslate","nextGlyph","destroyLabel","len","_labelCollection","LabelCollection","options","EMPTY_OBJECT","_scene","scene","_batchTable","batchTable","textureAtlas","initialSize","_sdf","_labels","_labelsToUpdate","_totalGlyphCount","_highlightColor","modelMatrix","IDENTITY","debugShowBoundingVolume","blendOption","OPAQUE_AND_TRANSLUCENT","Object","defineProperties","prototype","sizeInBytes","ready","index","indexOf","splice","removeAll","labels","contains","update","frameState","isDestroyed","preUpdateGlyphCount","_rebindAllGlyphs","glyphCountDifference","TRANSLUCENT","destroy"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/LabelCollection.js"],"sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Color from \"../Core/Color.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport writeTextToCanvas from \"../Core/writeTextToCanvas.js\";\nimport bitmapSDF from \"bitmap-sdf\";\nimport BillboardCollection from \"./BillboardCollection.js\";\nimport BillboardTexture from \"./BillboardTexture.js\";\nimport BlendOption from \"./BlendOption.js\";\nimport { isHeightReferenceClamp } from \"./HeightReference.js\";\nimport HorizontalOrigin from \"./HorizontalOrigin.js\";\nimport Label from \"./Label.js\";\nimport LabelStyle from \"./LabelStyle.js\";\nimport SDFSettings from \"./SDFSettings.js\";\nimport TextureAtlas from \"../Renderer/TextureAtlas.js\";\nimport VerticalOrigin from \"./VerticalOrigin.js\";\nimport GraphemeSplitter from \"grapheme-splitter\";\n\n/**\n * A glyph represents a single character in label.\n * @private\n */\nfunction Glyph() {\n  /**\n   * Object containing dimensions of the character as rendered to a canvas.\n   * @see {writeTextToCanvas}\n   * @type {object}\n   * @private\n   */\n  this.dimensions = undefined;\n\n  /**\n   * Reference to loaded image data for a single character, drawn in a particular style, shared and referenced across all labels.\n   * @type {BillboardTexture}\n   * @private\n   */\n  this.billboardTexture = undefined;\n\n  /**\n   * The individual billboard used to render the glyph. This may be <code>undefined</code> if the associated character is whitespace.\n   * @type {Billboard|undefined}\n   * @private\n   */\n  this.billboard = undefined;\n}\n\n// Traditionally, leading is %20 of the font size.\nconst defaultLineSpacingPercent = 1.2;\nconst whitePixelCanvasId = \"ID_WHITE_PIXEL\";\nconst whitePixelSize = new Cartesian2(4, 4);\nconst whitePixelBoundingRegion = new BoundingRectangle(1, 1, 1, 1);\n\n/**\n * Create the background image and start loading it into a texture\n * @private\n * @param {BillboardCollection} billboardCollection\n * @param {LabelCollection} labelCollection\n * @returns {Billboard}\n */\nfunction getWhitePixelBillboard(billboardCollection, labelCollection) {\n  const billboardTexture = labelCollection._backgroundBillboardTexture;\n  if (!billboardTexture.hasImage) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = whitePixelSize.x;\n    canvas.height = whitePixelSize.y;\n\n    const context2D = canvas.getContext(\"2d\");\n    context2D.fillStyle = \"#fff\";\n    context2D.fillRect(0, 0, canvas.width, canvas.height);\n\n    billboardTexture.loadImage(whitePixelCanvasId, canvas);\n    billboardTexture.addImageSubRegion(\n      whitePixelCanvasId,\n      whitePixelBoundingRegion,\n    );\n  }\n\n  const billboard = billboardCollection.add({\n    collection: labelCollection,\n  });\n\n  billboard.setImageTexture(billboardTexture);\n\n  return billboard;\n}\n\n// reusable object for calling writeTextToCanvas\nconst writeTextToCanvasParameters = {};\nfunction createGlyphCanvas(\n  character,\n  font,\n  fillColor,\n  outlineColor,\n  outlineWidth,\n  style,\n) {\n  writeTextToCanvasParameters.font = font;\n  writeTextToCanvasParameters.fillColor = fillColor;\n  writeTextToCanvasParameters.strokeColor = outlineColor;\n  writeTextToCanvasParameters.strokeWidth = outlineWidth;\n  // Setting the padding to something bigger is necessary to get enough space for the outlining.\n  writeTextToCanvasParameters.padding = SDFSettings.PADDING;\n\n  writeTextToCanvasParameters.fill =\n    style === LabelStyle.FILL || style === LabelStyle.FILL_AND_OUTLINE;\n  writeTextToCanvasParameters.stroke =\n    style === LabelStyle.OUTLINE || style === LabelStyle.FILL_AND_OUTLINE;\n  writeTextToCanvasParameters.backgroundColor = Color.BLACK;\n\n  return writeTextToCanvas(character, writeTextToCanvasParameters);\n}\n\nfunction unbindGlyphBillboard(labelCollection, glyph) {\n  const billboard = glyph.billboard;\n  if (defined(billboard)) {\n    billboard.show = false;\n    if (defined(billboard._removeCallbackFunc)) {\n      billboard._removeCallbackFunc();\n      billboard._removeCallbackFunc = undefined;\n    }\n    labelCollection._spareBillboards.push(billboard);\n    glyph.billboard = undefined;\n  }\n}\n\nconst splitter = new GraphemeSplitter();\nconst whitespaceRegex = /\\s/;\n\nfunction rebindAllGlyphs(labelCollection, label) {\n  const text = label._renderedText;\n  const graphemes = splitter.splitGraphemes(text);\n  const textLength = graphemes.length;\n  const glyphs = label._glyphs;\n  const glyphsLength = glyphs.length;\n\n  // Compute a font size scale relative to the sdf font generated size.\n  label._relativeSize = label._fontSize / SDFSettings.FONT_SIZE;\n\n  // if we have more glyphs than needed, unbind the extras.\n  if (textLength < glyphsLength) {\n    for (let glyphIndex = textLength; glyphIndex < glyphsLength; ++glyphIndex) {\n      unbindGlyphBillboard(labelCollection, glyphs[glyphIndex]);\n    }\n  }\n\n  // presize glyphs to match the new text length\n  glyphs.length = textLength;\n\n  const showBackground =\n    label.show && label._showBackground && text.split(\"\\n\").join(\"\").length > 0;\n  let backgroundBillboard = label._backgroundBillboard;\n  const backgroundBillboardCollection =\n    labelCollection._backgroundBillboardCollection;\n  if (!showBackground) {\n    if (defined(backgroundBillboard)) {\n      backgroundBillboardCollection.remove(backgroundBillboard);\n      label._backgroundBillboard = backgroundBillboard = undefined;\n    }\n  } else {\n    if (!defined(backgroundBillboard)) {\n      backgroundBillboard = getWhitePixelBillboard(\n        backgroundBillboardCollection,\n        labelCollection,\n      );\n      label._backgroundBillboard = backgroundBillboard;\n    }\n\n    backgroundBillboard.color = label._backgroundColor;\n    backgroundBillboard.show = label._show;\n    backgroundBillboard.position = label._position;\n    backgroundBillboard.eyeOffset = label._eyeOffset;\n    backgroundBillboard.pixelOffset = label._pixelOffset;\n    backgroundBillboard.horizontalOrigin = HorizontalOrigin.LEFT;\n    backgroundBillboard.verticalOrigin = label._verticalOrigin;\n    backgroundBillboard.heightReference = label._heightReference;\n    backgroundBillboard.scale = label.totalScale;\n    backgroundBillboard.pickPrimitive = label;\n    backgroundBillboard.id = label._id;\n    backgroundBillboard.translucencyByDistance = label._translucencyByDistance;\n    backgroundBillboard.pixelOffsetScaleByDistance =\n      label._pixelOffsetScaleByDistance;\n    backgroundBillboard.scaleByDistance = label._scaleByDistance;\n    backgroundBillboard.distanceDisplayCondition =\n      label._distanceDisplayCondition;\n    backgroundBillboard.disableDepthTestDistance =\n      label._disableDepthTestDistance;\n    backgroundBillboard.clusterShow = label.clusterShow;\n  }\n\n  const glyphBillboardCollection = labelCollection._glyphBillboardCollection;\n  const glyphTextureCache = glyphBillboardCollection.billboardTextureCache;\n  const textDimensionsCache = labelCollection._textDimensionsCache;\n\n  // walk the text looking for new characters (creating new glyphs for each)\n  // or changed characters (rebinding existing glyphs)\n  for (let textIndex = 0; textIndex < textLength; ++textIndex) {\n    const character = graphemes[textIndex];\n    const verticalOrigin = label._verticalOrigin;\n\n    const id = JSON.stringify([\n      character,\n      label._fontFamily,\n      label._fontStyle,\n      label._fontWeight,\n      +verticalOrigin,\n    ]);\n\n    let dimensions = textDimensionsCache[id];\n    let glyphBillboardTexture = glyphTextureCache.get(id);\n    if (!defined(glyphBillboardTexture) || !defined(dimensions)) {\n      glyphBillboardTexture = new BillboardTexture(glyphBillboardCollection);\n      glyphTextureCache.set(id, glyphBillboardTexture);\n\n      const glyphFont = `${label._fontStyle} ${label._fontWeight} ${SDFSettings.FONT_SIZE}px ${label._fontFamily}`;\n\n      const canvas = createGlyphCanvas(\n        character,\n        glyphFont,\n        Color.WHITE,\n        Color.WHITE,\n        0.0,\n        LabelStyle.FILL,\n      );\n\n      dimensions = canvas.dimensions;\n      textDimensionsCache[id] = dimensions;\n\n      if (\n        canvas.width > 0 &&\n        canvas.height > 0 &&\n        !whitespaceRegex.test(character)\n      ) {\n        const sdfValues = bitmapSDF(canvas, {\n          cutoff: SDFSettings.CUTOFF,\n          radius: SDFSettings.RADIUS,\n        });\n\n        // Context is originally created in writeTextToCanvas()\n        const ctx = canvas.getContext(\"2d\");\n        const canvasWidth = canvas.width;\n        const canvasHeight = canvas.height;\n        const imgData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\n        for (let i = 0; i < canvasWidth; i++) {\n          for (let j = 0; j < canvasHeight; j++) {\n            const baseIndex = j * canvasWidth + i;\n            const alpha = sdfValues[baseIndex] * 255;\n            const imageIndex = baseIndex * 4;\n            imgData.data[imageIndex + 0] = alpha;\n            imgData.data[imageIndex + 1] = alpha;\n            imgData.data[imageIndex + 2] = alpha;\n            imgData.data[imageIndex + 3] = alpha;\n          }\n        }\n        ctx.putImageData(imgData, 0, 0);\n        glyphBillboardTexture.loadImage(id, canvas);\n      }\n    }\n\n    let glyph = glyphs[textIndex];\n    if (!defined(glyph)) {\n      glyph = new Glyph();\n      glyph.dimensions = dimensions;\n      glyph.billboardTexture = glyphBillboardTexture;\n      glyphs[textIndex] = glyph;\n    }\n\n    if (glyph.billboardTexture.id !== id) {\n      // This glyph has been mapped to a new texture. If we had one before, release\n      // our reference to that texture and dimensions, but reuse the billboard.\n      glyph.billboardTexture = glyphBillboardTexture;\n      glyph.dimensions = dimensions;\n    }\n\n    if (!glyphBillboardTexture.hasImage) {\n      // No texture, and therefore no billboard, for this glyph.\n      // so, completely unbind glyph to free up the billboard for others\n      unbindGlyphBillboard(labelCollection, glyph);\n      continue;\n    }\n\n    // If we have a texture, configure the existing billboard, or obtain one\n    let billboard = glyph.billboard;\n    const spareBillboards = labelCollection._spareBillboards;\n    if (!defined(billboard)) {\n      if (spareBillboards.length > 0) {\n        billboard = spareBillboards.pop();\n      } else {\n        billboard = glyphBillboardCollection.add({\n          collection: labelCollection,\n        });\n        billboard._labelDimensions = new Cartesian2();\n        billboard._labelTranslate = new Cartesian2();\n        billboard._positionFromParent = true;\n      }\n      glyph.billboard = billboard;\n    }\n\n    billboard.setImageTexture(glyphBillboardTexture);\n\n    billboard.show = label._show;\n    billboard.position = label._position;\n    billboard.eyeOffset = label._eyeOffset;\n    billboard.pixelOffset = label._pixelOffset;\n    billboard.horizontalOrigin = HorizontalOrigin.LEFT;\n    billboard.verticalOrigin = label._verticalOrigin;\n    billboard.heightReference = label._heightReference;\n    billboard.scale = label.totalScale;\n    billboard.pickPrimitive = label;\n    billboard.id = label._id;\n    billboard.translucencyByDistance = label._translucencyByDistance;\n    billboard.pixelOffsetScaleByDistance = label._pixelOffsetScaleByDistance;\n    billboard.scaleByDistance = label._scaleByDistance;\n    billboard.distanceDisplayCondition = label._distanceDisplayCondition;\n    billboard.disableDepthTestDistance = label._disableDepthTestDistance;\n    billboard._batchIndex = label._batchIndex;\n    billboard.outlineColor = label.outlineColor;\n    if (label.style === LabelStyle.FILL_AND_OUTLINE) {\n      billboard.color = label._fillColor;\n      billboard.outlineWidth = label.outlineWidth;\n    } else if (label.style === LabelStyle.FILL) {\n      billboard.color = label._fillColor;\n      billboard.outlineWidth = 0.0;\n    } else if (label.style === LabelStyle.OUTLINE) {\n      billboard.color = Color.TRANSPARENT;\n      billboard.outlineWidth = label.outlineWidth;\n    }\n  }\n\n  // changing glyphs will cause the position of the\n  // glyphs to change, since different characters have different widths\n  label._repositionAllGlyphs = true;\n}\n\nfunction calculateWidthOffset(lineWidth, horizontalOrigin, backgroundPadding) {\n  if (horizontalOrigin === HorizontalOrigin.CENTER) {\n    return -lineWidth / 2;\n  } else if (horizontalOrigin === HorizontalOrigin.RIGHT) {\n    return -(lineWidth + backgroundPadding.x);\n  }\n  return backgroundPadding.x;\n}\n\n// reusable Cartesian2 instances\nconst glyphPixelOffset = new Cartesian2();\nconst scratchBackgroundPadding = new Cartesian2();\n\nfunction repositionAllGlyphs(label) {\n  const glyphs = label._glyphs;\n  const text = label._renderedText;\n  let lastLineWidth = 0;\n  let maxLineWidth = 0;\n  const lineWidths = [];\n  let maxGlyphDescent = Number.NEGATIVE_INFINITY;\n  let maxGlyphY = 0;\n  let numberOfLines = 1;\n  const glyphLength = glyphs.length;\n\n  const backgroundBillboard = label._backgroundBillboard;\n  const backgroundPadding = Cartesian2.clone(\n    defined(backgroundBillboard) ? label._backgroundPadding : Cartesian2.ZERO,\n    scratchBackgroundPadding,\n  );\n\n  // We need to scale the background padding, which is specified in pixels by the inverse of the relative size so it is scaled properly.\n  backgroundPadding.x /= label._relativeSize;\n  backgroundPadding.y /= label._relativeSize;\n\n  for (let glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {\n    if (text.charAt(glyphIndex) === \"\\n\") {\n      lineWidths.push(lastLineWidth);\n      ++numberOfLines;\n      lastLineWidth = 0;\n      continue;\n    }\n\n    const glyph = glyphs[glyphIndex];\n    const dimensions = glyph.dimensions;\n    if (defined(dimensions)) {\n      maxGlyphY = Math.max(maxGlyphY, dimensions.height - dimensions.descent);\n      maxGlyphDescent = Math.max(maxGlyphDescent, dimensions.descent);\n\n      // Computing the line width must also account for the kerning that occurs between letters.\n      lastLineWidth += dimensions.width - dimensions.minx;\n      if (glyphIndex < glyphLength - 1) {\n        lastLineWidth += glyphs[glyphIndex + 1].dimensions.minx;\n      }\n      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n    }\n  }\n  lineWidths.push(lastLineWidth);\n  const maxLineHeight = maxGlyphY + maxGlyphDescent;\n\n  const scale = label.totalScale;\n  const horizontalOrigin = label._horizontalOrigin;\n  const verticalOrigin = label._verticalOrigin;\n  let lineIndex = 0;\n  let lineWidth = lineWidths[lineIndex];\n  let widthOffset = calculateWidthOffset(\n    lineWidth,\n    horizontalOrigin,\n    backgroundPadding,\n  );\n  const lineSpacing =\n    (defined(label._lineHeight)\n      ? label._lineHeight\n      : defaultLineSpacingPercent * label._fontSize) / label._relativeSize;\n  const otherLinesHeight = lineSpacing * (numberOfLines - 1);\n  let totalLineWidth = maxLineWidth;\n  let totalLineHeight = maxLineHeight + otherLinesHeight;\n\n  if (defined(backgroundBillboard)) {\n    totalLineWidth += backgroundPadding.x * 2;\n    totalLineHeight += backgroundPadding.y * 2;\n    backgroundBillboard._labelHorizontalOrigin = horizontalOrigin;\n  }\n\n  glyphPixelOffset.x = widthOffset * scale;\n  glyphPixelOffset.y = 0;\n\n  let firstCharOfLine = true;\n\n  let lineOffsetY = 0;\n  for (let glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {\n    if (text.charAt(glyphIndex) === \"\\n\") {\n      ++lineIndex;\n      lineOffsetY += lineSpacing;\n      lineWidth = lineWidths[lineIndex];\n      widthOffset = calculateWidthOffset(\n        lineWidth,\n        horizontalOrigin,\n        backgroundPadding,\n      );\n      glyphPixelOffset.x = widthOffset * scale;\n      firstCharOfLine = true;\n      continue;\n    }\n\n    const glyph = glyphs[glyphIndex];\n    const dimensions = glyph.dimensions;\n    if (defined(dimensions)) {\n      if (verticalOrigin === VerticalOrigin.TOP) {\n        glyphPixelOffset.y =\n          dimensions.height - maxGlyphY - backgroundPadding.y;\n        glyphPixelOffset.y += SDFSettings.PADDING;\n      } else if (verticalOrigin === VerticalOrigin.CENTER) {\n        glyphPixelOffset.y =\n          (otherLinesHeight + dimensions.height - maxGlyphY) / 2;\n      } else if (verticalOrigin === VerticalOrigin.BASELINE) {\n        glyphPixelOffset.y = otherLinesHeight;\n        glyphPixelOffset.y -= SDFSettings.PADDING;\n      } else {\n        // VerticalOrigin.BOTTOM\n        glyphPixelOffset.y =\n          otherLinesHeight + maxGlyphDescent + backgroundPadding.y;\n        glyphPixelOffset.y -= SDFSettings.PADDING;\n      }\n      glyphPixelOffset.y =\n        (glyphPixelOffset.y - dimensions.descent - lineOffsetY) * scale;\n\n      // Handle any offsets for the first character of the line since the bounds might not be right on the bottom left pixel.\n      if (firstCharOfLine) {\n        glyphPixelOffset.x -= SDFSettings.PADDING * scale;\n        firstCharOfLine = false;\n      }\n\n      if (defined(glyph.billboard)) {\n        glyph.billboard._setTranslate(glyphPixelOffset);\n        glyph.billboard._labelDimensions.x = totalLineWidth;\n        glyph.billboard._labelDimensions.y = totalLineHeight;\n        glyph.billboard._labelHorizontalOrigin = horizontalOrigin;\n      }\n\n      //Compute the next x offset taking into account the kerning performed\n      //on both the current letter as well as the next letter to be drawn\n      //as well as any applied scale.\n      if (glyphIndex < glyphLength - 1) {\n        const nextGlyph = glyphs[glyphIndex + 1];\n        glyphPixelOffset.x +=\n          (dimensions.width - dimensions.minx + nextGlyph.dimensions.minx) *\n          scale;\n      }\n    }\n  }\n\n  if (defined(backgroundBillboard) && text.split(\"\\n\").join(\"\").length > 0) {\n    if (horizontalOrigin === HorizontalOrigin.CENTER) {\n      widthOffset = -maxLineWidth / 2 - backgroundPadding.x;\n    } else if (horizontalOrigin === HorizontalOrigin.RIGHT) {\n      widthOffset = -(maxLineWidth + backgroundPadding.x * 2);\n    } else {\n      widthOffset = 0;\n    }\n    glyphPixelOffset.x = widthOffset * scale;\n\n    if (verticalOrigin === VerticalOrigin.TOP) {\n      glyphPixelOffset.y = maxLineHeight - maxGlyphY - maxGlyphDescent;\n    } else if (verticalOrigin === VerticalOrigin.CENTER) {\n      glyphPixelOffset.y = (maxLineHeight - maxGlyphY) / 2 - maxGlyphDescent;\n    } else if (verticalOrigin === VerticalOrigin.BASELINE) {\n      glyphPixelOffset.y = -backgroundPadding.y - maxGlyphDescent;\n    } else {\n      // VerticalOrigin.BOTTOM\n      glyphPixelOffset.y = 0;\n    }\n    glyphPixelOffset.y = glyphPixelOffset.y * scale;\n\n    backgroundBillboard.width = totalLineWidth;\n    backgroundBillboard.height = totalLineHeight;\n    backgroundBillboard._setTranslate(glyphPixelOffset);\n    backgroundBillboard._labelTranslate = Cartesian2.clone(\n      glyphPixelOffset,\n      backgroundBillboard._labelTranslate,\n    );\n  }\n\n  if (isHeightReferenceClamp(label.heightReference)) {\n    for (let glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {\n      const glyph = glyphs[glyphIndex];\n      const billboard = glyph.billboard;\n      if (defined(billboard)) {\n        billboard._labelTranslate = Cartesian2.clone(\n          glyphPixelOffset,\n          billboard._labelTranslate,\n        );\n      }\n    }\n  }\n}\n\nfunction destroyLabel(labelCollection, label) {\n  const glyphs = label._glyphs;\n  for (let i = 0, len = glyphs.length; i < len; ++i) {\n    unbindGlyphBillboard(labelCollection, glyphs[i]);\n  }\n  if (defined(label._backgroundBillboard)) {\n    labelCollection._backgroundBillboardCollection.remove(\n      label._backgroundBillboard,\n    );\n    label._backgroundBillboard = undefined;\n  }\n  label._labelCollection = undefined;\n\n  if (defined(label._removeCallbackFunc)) {\n    label._removeCallbackFunc();\n  }\n\n  destroyObject(label);\n}\n\n/**\n * A renderable collection of labels.  Labels are viewport-aligned text positioned in the 3D scene.\n * Each label can have a different font, color, scale, etc.\n * <br /><br />\n * <div align='center'>\n * <img src='Images/Label.png' width='400' height='300' /><br />\n * Example labels\n * </div>\n * <br /><br />\n * Labels are added and removed from the collection using {@link LabelCollection#add}\n * and {@link LabelCollection#remove}.\n *\n * @alias LabelCollection\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each label from model to world coordinates.\n * @param {boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {Scene} [options.scene] Must be passed in for labels that use the height reference property or will be depth tested against the globe.\n * @param {BlendOption} [options.blendOption=BlendOption.OPAQUE_AND_TRANSLUCENT] The label blending option. The default\n * is used for rendering both opaque and translucent labels. However, if either all of the labels are completely opaque or all are completely translucent,\n * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.\n * @param {boolean} [options.show=true] Determines if the labels in the collection will be shown.\n *\n * @performance For best performance, prefer a few collections, each with many labels, to\n * many collections with only a few labels each.  Avoid having collections where some\n * labels change every frame and others do not; instead, create one or more collections\n * for static labels, and one or more collections for dynamic labels.\n *\n * @see LabelCollection#add\n * @see LabelCollection#remove\n * @see Label\n * @see BillboardCollection\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Labels.html|Cesium Sandcastle Labels Demo}\n *\n * @example\n * // Create a label collection with two labels\n * const labels = scene.primitives.add(new Cesium.LabelCollection());\n * labels.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   text : 'A label'\n * });\n * labels.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   text : 'Another label'\n * });\n */\nfunction LabelCollection(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  this._scene = options.scene;\n  this._batchTable = options.batchTable;\n\n  const backgroundBillboardCollection = new BillboardCollection({\n    scene: this._scene,\n    textureAtlas: new TextureAtlas({\n      initialSize: whitePixelSize,\n    }),\n  });\n  this._backgroundBillboardCollection = backgroundBillboardCollection;\n  this._backgroundBillboardTexture = new BillboardTexture(\n    backgroundBillboardCollection,\n  );\n\n  this._glyphBillboardCollection = new BillboardCollection({\n    scene: this._scene,\n    batchTable: this._batchTable,\n  });\n  this._glyphBillboardCollection._sdf = true;\n\n  this._spareBillboards = [];\n  this._textDimensionsCache = {};\n  this._labels = [];\n  this._labelsToUpdate = [];\n  this._totalGlyphCount = 0;\n\n  this._highlightColor = Color.clone(Color.WHITE); // Only used by Vector3DTilePoints\n\n  /**\n   * Determines if labels in this collection will be shown.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.show = options.show ?? true;\n\n  /**\n   * The 4x4 transformation matrix that transforms each label in this collection from model to world coordinates.\n   * When this is the identity matrix, the labels are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type Matrix4\n   * @default {@link Matrix4.IDENTITY}\n   *\n   * @example\n   * const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * labels.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0),\n   *   text     : 'Center'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0),\n   *   text     : 'East'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0),\n   *   text     : 'North'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0),\n   *   text     : 'Up'\n   * });\n   */\n  this.modelMatrix = Matrix4.clone(options.modelMatrix ?? Matrix4.IDENTITY);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = options.debugShowBoundingVolume ?? false;\n\n  /**\n   * The label blending option. The default is used for rendering both opaque and translucent labels.\n   * However, if either all of the labels are completely opaque or all are completely translucent,\n   * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve\n   * performance by up to 2x.\n   * @type {BlendOption}\n   * @default BlendOption.OPAQUE_AND_TRANSLUCENT\n   */\n  this.blendOption = options.blendOption ?? BlendOption.OPAQUE_AND_TRANSLUCENT;\n}\n\nObject.defineProperties(LabelCollection.prototype, {\n  /**\n   * Returns the number of labels in this collection.  This is commonly used with\n   * {@link LabelCollection#get} to iterate over all the labels\n   * in the collection.\n   * @memberof LabelCollection.prototype\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._labels.length;\n    },\n  },\n\n  /**\n   * Returns the size in bytes of the WebGL texture resources.\n   * @private\n   * @memberof LabelCollection.prototype\n   * @type {number}\n   * @readonly\n   */\n  sizeInBytes: {\n    get: function () {\n      return (\n        this._glyphBillboardCollection.sizeInBytes +\n        this._backgroundBillboardCollection.sizeInBytes\n      );\n    },\n  },\n\n  /**\n   * True when all labels currently in the collection are ready for rendering.\n   * @private\n   * @memberof LabelCollection.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      const backgroundBillboard = this._backgroundBillboardCollection.get(0);\n      if (defined(backgroundBillboard) && !backgroundBillboard.ready) {\n        return false;\n      }\n\n      return this._glyphBillboardCollection.ready;\n    },\n  },\n});\n\n/**\n * Creates and adds a label with the specified initial properties to the collection.\n * The added label is returned so it can be modified or removed from the collection later.\n *\n * @param {Label.ConstructorOptions} [options] A template describing the label's properties as shown in Example 1.\n * @returns {Label} The label that was added to the collection.\n *\n * @performance Calling <code>add</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten; this operations is <code>O(n)</code> and also incurs\n * CPU to GPU overhead.  For best performance, add as many billboards as possible before\n * calling <code>update</code>.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * // Example 1:  Add a label, specifying all the default values.\n * const l = labels.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   text : '',\n *   font : '30px sans-serif',\n *   fillColor : Cesium.Color.WHITE,\n *   outlineColor : Cesium.Color.BLACK,\n *   outlineWidth : 1.0,\n *   showBackground : false,\n *   backgroundColor : new Cesium.Color(0.165, 0.165, 0.165, 0.8),\n *   backgroundPadding : new Cesium.Cartesian2(7, 5),\n *   style : Cesium.LabelStyle.FILL,\n *   pixelOffset : Cesium.Cartesian2.ZERO,\n *   eyeOffset : Cesium.Cartesian3.ZERO,\n *   horizontalOrigin : Cesium.HorizontalOrigin.LEFT,\n *   verticalOrigin : Cesium.VerticalOrigin.BASELINE,\n *   scale : 1.0,\n *   translucencyByDistance : undefined,\n *   pixelOffsetScaleByDistance : undefined,\n *   heightReference : HeightReference.NONE,\n *   distanceDisplayCondition : undefined\n * });\n *\n * @example\n * // Example 2:  Specify only the label's cartographic position,\n * // text, and font.\n * const l = labels.add({\n *   position : Cesium.Cartesian3.fromRadians(longitude, latitude, height),\n *   text : 'Hello World',\n *   font : '24px Helvetica',\n * });\n *\n *\n * @see LabelCollection#remove\n * @see LabelCollection#removeAll\n */\nLabelCollection.prototype.add = function (options) {\n  const label = new Label(options, this);\n\n  this._labels.push(label);\n  this._labelsToUpdate.push(label);\n\n  return label;\n};\n\n/**\n * Removes a label from the collection.  Once removed, a label is no longer usable.\n *\n * @param {Label} label The label to remove.\n * @returns {boolean} <code>true</code> if the label was removed; <code>false</code> if the label was not found in the collection.\n *\n * @performance Calling <code>remove</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, remove as many labels as possible before calling <code>update</code>.\n * If you intend to temporarily hide a label, it is usually more efficient to call\n * {@link Label#show} instead of removing and re-adding the label.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * const l = labels.add(...);\n * labels.remove(l);  // Returns true\n *\n * @see LabelCollection#add\n * @see LabelCollection#removeAll\n * @see Label#show\n */\nLabelCollection.prototype.remove = function (label) {\n  if (defined(label) && label._labelCollection === this) {\n    const index = this._labels.indexOf(label);\n    if (index !== -1) {\n      this._labels.splice(index, 1);\n      destroyLabel(this, label);\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Removes all labels from the collection.\n *\n * @performance <code>O(n)</code>.  It is more efficient to remove all the labels\n * from a collection and then add new ones than to create a new collection entirely.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * labels.add(...);\n * labels.add(...);\n * labels.removeAll();\n *\n * @see LabelCollection#add\n * @see LabelCollection#remove\n */\nLabelCollection.prototype.removeAll = function () {\n  const labels = this._labels;\n\n  for (let i = 0, len = labels.length; i < len; ++i) {\n    destroyLabel(this, labels[i]);\n  }\n\n  labels.length = 0;\n};\n\n/**\n * Check whether this collection contains a given label.\n *\n * @param {Label} label The label to check for.\n * @returns {boolean} true if this collection contains the label, false otherwise.\n *\n * @see LabelCollection#get\n *\n */\nLabelCollection.prototype.contains = function (label) {\n  return defined(label) && label._labelCollection === this;\n};\n\n/**\n * Returns the label in the collection at the specified index.  Indices are zero-based\n * and increase as labels are added.  Removing a label shifts all labels after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link LabelCollection#length} to iterate over all the labels\n * in the collection.\n *\n * @param {number} index The zero-based index of the billboard.\n *\n * @returns {Label} The label at the specified index.\n *\n * @performance Expected constant time.  If labels were removed from the collection and\n * {@link Scene#render} was not called, an implicit <code>O(n)</code>\n * operation is performed.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Toggle the show property of every label in the collection\n * const len = labels.length;\n * for (let i = 0; i < len; ++i) {\n *   const l = billboards.get(i);\n *   l.show = !l.show;\n * }\n *\n * @see LabelCollection#length\n */\nLabelCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return this._labels[index];\n};\n\n/**\n * @private\n */\nLabelCollection.prototype.update = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  const glyphBillboardCollection = this._glyphBillboardCollection;\n  const backgroundBillboardCollection = this._backgroundBillboardCollection;\n\n  glyphBillboardCollection.modelMatrix = this.modelMatrix;\n  glyphBillboardCollection.debugShowBoundingVolume =\n    this.debugShowBoundingVolume;\n  backgroundBillboardCollection.modelMatrix = this.modelMatrix;\n  backgroundBillboardCollection.debugShowBoundingVolume =\n    this.debugShowBoundingVolume;\n\n  const len = this._labelsToUpdate.length;\n  for (let i = 0; i < len; ++i) {\n    const label = this._labelsToUpdate[i];\n    if (label.isDestroyed()) {\n      continue;\n    }\n\n    const preUpdateGlyphCount = label._glyphs.length;\n\n    if (label._rebindAllGlyphs) {\n      rebindAllGlyphs(this, label);\n      label._rebindAllGlyphs = false;\n    }\n\n    if (label._repositionAllGlyphs) {\n      repositionAllGlyphs(label);\n      label._repositionAllGlyphs = false;\n    }\n\n    const glyphCountDifference = label._glyphs.length - preUpdateGlyphCount;\n    this._totalGlyphCount += glyphCountDifference;\n  }\n\n  const blendOption =\n    backgroundBillboardCollection.length > 0\n      ? BlendOption.TRANSLUCENT\n      : this.blendOption;\n  glyphBillboardCollection.blendOption = blendOption;\n  backgroundBillboardCollection.blendOption = blendOption;\n\n  glyphBillboardCollection._highlightColor = this._highlightColor;\n  backgroundBillboardCollection._highlightColor = this._highlightColor;\n\n  this._labelsToUpdate.length = 0;\n  backgroundBillboardCollection.update(frameState);\n  glyphBillboardCollection.update(frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n *\n * @see LabelCollection#destroy\n */\nLabelCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * labels = labels && labels.destroy();\n *\n * @see LabelCollection#isDestroyed\n */\nLabelCollection.prototype.destroy = function () {\n  this.removeAll();\n  this._glyphBillboardCollection = this._glyphBillboardCollection.destroy();\n  this._backgroundBillboardCollection =\n    this._backgroundBillboardCollection.destroy();\n\n  return destroyObject(this);\n};\nexport default LabelCollection;\n"],"mappings":"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AI,CAACC,uBAAuB,GAAGf,OAAO,CAACe,uBAAuB,IAAI,KAAK;;EAEvE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,WAAW,GAAGhB,OAAO,CAACgB,WAAW,IAAIlO,WAAW,CAACmO,sBAAsB;AAC9E;AAEAC,MAAM,CAACC,gBAAgB,CAACpB,eAAe,CAACqB,SAAS,EAAE;EACjD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE7J,MAAM,EAAE;IACN6D,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACqF,OAAO,CAAClJ,MAAM;IAC5B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACE8J,WAAW,EAAE;IACXjG,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OACE,IAAI,CAACZ,yBAAyB,CAAC6G,WAAW,GAC1C,IAAI,CAAC/I,8BAA8B,CAAC+I,WAAW;IAEnD;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,KAAK,EAAE;IACLlG,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,MAAMjD,mBAAmB,GAAG,IAAI,CAACG,8BAA8B,CAAC8C,GAAG,CAAC,CAAC,CAAC;MACtE,IAAI9I,OAAO,CAAC6F,mBAAmB,CAAC,IAAI,CAACA,mBAAmB,CAACmJ,KAAK,EAAE;QAC9D,OAAO,KAAK;MACd;MAEA,OAAO,IAAI,CAAC9G,yBAAyB,CAAC8G,KAAK;IAC7C;EACF;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAvB,eAAe,CAACqB,SAAS,CAAClM,GAAG,GAAG,UAAU8K,OAAO,EAAE;EACjD,MAAM/I,KAAK,GAAG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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}