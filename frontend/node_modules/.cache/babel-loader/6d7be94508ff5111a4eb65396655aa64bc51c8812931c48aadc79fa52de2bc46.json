{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport AssociativeArray from \"../Core/AssociativeArray.js\";\nimport defined from \"../Core/defined.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport RectangleCollisionChecker from \"../Core/RectangleCollisionChecker.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport GroundPrimitive from \"../Scene/GroundPrimitive.js\";\nimport ShadowVolumeAppearance from \"../Scene/ShadowVolumeAppearance.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport MaterialProperty from \"./MaterialProperty.js\";\nimport Property from \"./Property.js\";\nconst distanceDisplayConditionScratch = new DistanceDisplayCondition();\nconst defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n\n// Encapsulates a Primitive and all the entities that it represents.\nfunction Batch(primitives, classificationType, appearanceType, materialProperty, usingSphericalTextureCoordinates, zIndex) {\n  this.primitives = primitives; // scene level primitive collection (each Batch manages its own Primitive from this collection)\n  this.classificationType = classificationType;\n  this.appearanceType = appearanceType;\n  this.materialProperty = materialProperty;\n  this.updaters = new AssociativeArray(); // GeometryUpdaters that manage the visual representation of the primitive.\n  this.createPrimitive = true;\n  this.primitive = undefined; // a GroundPrimitive encapsulating all the entities\n  this.oldPrimitive = undefined; // a GroundPrimitive that is being replaced by the current primitive, but will still be shown until the current primitive is ready.\n  this.geometry = new AssociativeArray();\n  this.material = undefined;\n  this.updatersWithAttributes = new AssociativeArray();\n  this.attributes = new AssociativeArray();\n  this.subscriptions = new AssociativeArray();\n  this.showsUpdated = new AssociativeArray();\n  this.usingSphericalTextureCoordinates = usingSphericalTextureCoordinates;\n  this.zIndex = zIndex;\n  this.rectangleCollisionCheck = new RectangleCollisionChecker();\n}\nBatch.prototype.overlapping = function (rectangle) {\n  return this.rectangleCollisionCheck.collides(rectangle);\n};\n\n// Check if the given updater's material is compatible with this batch\nBatch.prototype.isMaterial = function (updater) {\n  const material = this.materialProperty;\n  const updaterMaterial = updater.fillMaterialProperty;\n  if (updaterMaterial === material || updaterMaterial instanceof ColorMaterialProperty && material instanceof ColorMaterialProperty) {\n    return true;\n  }\n  return defined(material) && material.equals(updaterMaterial);\n};\n\n/**\n * Adds an updater to the Batch, and signals for a new Primitive to be created on the next update.\n * @param {JulianDate} time\n * @param {GeometryUpdater} updater\n * @param {GeometryInstance} geometryInstance\n * @private\n */\nBatch.prototype.add = function (time, updater, geometryInstance) {\n  const id = updater.id;\n  this.updaters.set(id, updater);\n  this.geometry.set(id, geometryInstance);\n  this.rectangleCollisionCheck.insert(id, geometryInstance.geometry.rectangle);\n  // Updaters with dynamic attributes must be tracked separately, may exit the batch\n  if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)) {\n    this.updatersWithAttributes.set(id, updater);\n  } else {\n    const that = this;\n    // Listen for show changes. These will be synchronized in updateShows.\n    this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function (entity, propertyName, newValue, oldValue) {\n      if (propertyName === \"isShowing\") {\n        that.showsUpdated.set(updater.id, updater);\n      }\n    }));\n  }\n  this.createPrimitive = true;\n};\n\n/**\n * Remove an updater from the Batch, and potentially signals for a new Primitive to be created\n * on the next update.\n * @param {GeometryUpdater} updater\n * @returns true if the updater was removed, false if it was not found.\n * @private\n */\nBatch.prototype.remove = function (updater) {\n  const id = updater.id;\n  const geometryInstance = this.geometry.get(id);\n  this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n  if (this.updaters.remove(id)) {\n    this.rectangleCollisionCheck.remove(id, geometryInstance.geometry.rectangle);\n    this.updatersWithAttributes.remove(id);\n    const unsubscribe = this.subscriptions.get(id);\n    if (defined(unsubscribe)) {\n      unsubscribe();\n      this.subscriptions.remove(id);\n    }\n    return true;\n  }\n  return false;\n};\n\n/**\n * Update a Batch, creating a new primitive, if necessary, or swapping out an old primitive for a new one that's ready.\n * A new primitive is created whenever an updater is added to or removed from a Batch.\n * @param {JulianDate} time\n * @returns a boolean indicating whether the Batch was updated.\n * @private\n */\nBatch.prototype.update = function (time) {\n  let isUpdated = true;\n  let primitive = this.primitive;\n  const primitives = this.primitives;\n  const geometries = this.geometry.values;\n  let i;\n  if (this.createPrimitive) {\n    const geometriesLength = geometries.length;\n    if (geometriesLength > 0) {\n      if (defined(primitive)) {\n        // Keep a handle to the old primitive so it can be removed when the updated version is ready.\n        if (!defined(this.oldPrimitive)) {\n          this.oldPrimitive = primitive;\n        } else {\n          // For if the new primitive changes again before it is ready.\n          primitives.remove(primitive);\n        }\n      }\n      this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n      primitive = new GroundPrimitive({\n        show: false,\n        asynchronous: true,\n        geometryInstances: geometries.slice(),\n        appearance: new this.appearanceType({\n          material: this.material\n          // translucent and closed properties overridden\n        }),\n        classificationType: this.classificationType\n      });\n      primitives.add(primitive, this.zIndex);\n      isUpdated = false;\n    } else {\n      if (defined(primitive)) {\n        primitives.remove(primitive);\n        primitive = undefined;\n      }\n      const oldPrimitive = this.oldPrimitive;\n      if (defined(oldPrimitive)) {\n        primitives.remove(oldPrimitive);\n        this.oldPrimitive = undefined;\n      }\n    }\n    this.attributes.removeAll();\n    this.primitive = primitive;\n    this.createPrimitive = false;\n  } else if (defined(primitive) && primitive.ready) {\n    primitive.show = true;\n    if (defined(this.oldPrimitive)) {\n      primitives.remove(this.oldPrimitive);\n      this.oldPrimitive = undefined;\n    }\n    this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n    this.primitive.appearance.material = this.material;\n    const updatersWithAttributes = this.updatersWithAttributes.values;\n    const length = updatersWithAttributes.length;\n    for (i = 0; i < length; i++) {\n      const updater = updatersWithAttributes[i];\n      const entity = updater.entity;\n      const instance = this.geometry.get(updater.id);\n      let attributes = this.attributes.get(instance.id.id);\n      if (!defined(attributes)) {\n        attributes = primitive.getGeometryInstanceAttributes(instance.id);\n        this.attributes.set(instance.id.id, attributes);\n      }\n      const show = entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n      const currentShow = attributes.show[0] === 1;\n      if (show !== currentShow) {\n        attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n      }\n      const distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n      if (!Property.isConstant(distanceDisplayConditionProperty)) {\n        const distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n        if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n          attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n          attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n        }\n      }\n    }\n    this.updateShows(primitive);\n  } else if (defined(primitive) && !primitive.ready) {\n    isUpdated = false;\n  }\n  return isUpdated;\n};\nBatch.prototype.updateShows = function (primitive) {\n  const showsUpdated = this.showsUpdated.values;\n  const length = showsUpdated.length;\n  for (let i = 0; i < length; i++) {\n    const updater = showsUpdated[i];\n    const entity = updater.entity;\n    const instance = this.geometry.get(updater.id);\n    let attributes = this.attributes.get(instance.id.id);\n    if (!defined(attributes)) {\n      attributes = primitive.getGeometryInstanceAttributes(instance.id);\n      this.attributes.set(instance.id.id, attributes);\n    }\n    const show = entity.isShowing;\n    const currentShow = attributes.show[0] === 1;\n    if (show !== currentShow) {\n      attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n      instance.attributes.show.value[0] = attributes.show[0];\n    }\n  }\n  this.showsUpdated.removeAll();\n};\nBatch.prototype.contains = function (updater) {\n  return this.updaters.contains(updater.id);\n};\nBatch.prototype.getBoundingSphere = function (updater, result) {\n  const primitive = this.primitive;\n  if (!primitive.ready) {\n    return BoundingSphereState.PENDING;\n  }\n  const attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n  if (!defined(attributes) || !defined(attributes.boundingSphere) || defined(attributes.show) && attributes.show[0] === 0) {\n    return BoundingSphereState.FAILED;\n  }\n  attributes.boundingSphere.clone(result);\n  return BoundingSphereState.DONE;\n};\n\n/**\n * Removes a Batch's primitive (and oldPrimitive, if it exists).\n * @private\n */\nBatch.prototype.destroy = function () {\n  const primitive = this.primitive;\n  const primitives = this.primitives;\n  if (defined(primitive)) {\n    primitives.remove(primitive);\n  }\n  const oldPrimitive = this.oldPrimitive;\n  if (defined(oldPrimitive)) {\n    primitives.remove(oldPrimitive);\n  }\n};\n\n/**\n * A container of Batch objects of ground geometry primitives, where a Batch is grouped by material,\n * texture coordinate type, and spatial overlap.\n * @private\n */\nfunction StaticGroundGeometryPerMaterialBatch(primitives, classificationType, appearanceType) {\n  this._items = []; // array of Batch objects, each containing representing a primitive and a set of updaters that manage the visual representation of the primitive.\n  this._primitives = primitives; // scene level primitive collection\n  this._classificationType = classificationType;\n  this._appearanceType = appearanceType;\n}\n\n/**\n * Adds an geometry updater to a Batch. Tries to find a preexisting compatible Batch, or else creates a new Batch.\n * Used by Visualizer classes to add and update (remove->add) a primitive's Updater set.\n *\n * @param {JulianDate} time\n * @param {GeometryUpdater} updater A GeometryUpdater that manages the visual representation of a primitive.\n * @private\n */\nStaticGroundGeometryPerMaterialBatch.prototype.add = function (time, updater) {\n  const items = this._items;\n  const length = items.length;\n  const geometryInstance = updater.createFillGeometryInstance(time);\n  const usingSphericalTextureCoordinates = ShadowVolumeAppearance.shouldUseSphericalCoordinates(geometryInstance.geometry.rectangle);\n  const zIndex = Property.getValueOrDefault(updater.zIndex, 0);\n  // Check if the Entity represented by the updater can be placed in an existing batch. Requirements:\n  // * compatible material (same material or same color)\n  // * same type of texture coordinates (spherical vs. planar)\n  // * conservatively non-overlapping with any entities in the existing batch\n  for (let i = 0; i < length; ++i) {\n    const item = items[i];\n    if (item.isMaterial(updater) && item.usingSphericalTextureCoordinates === usingSphericalTextureCoordinates && item.zIndex === zIndex && !item.overlapping(geometryInstance.geometry.rectangle)) {\n      item.add(time, updater, geometryInstance);\n      return;\n    }\n  }\n  // If a compatible batch wasn't found, create a new batch.\n  const batch = new Batch(this._primitives, this._classificationType, this._appearanceType, updater.fillMaterialProperty, usingSphericalTextureCoordinates, zIndex);\n  batch.add(time, updater, geometryInstance);\n  items.push(batch);\n};\n\n/**\n * Removes an updater from a Batch. Defers potential deletion until the next update.\n * @param {GeometryUpdater} updater A GeometryUpdater that manages the visual representation of a primitive.\n * @private\n */\nStaticGroundGeometryPerMaterialBatch.prototype.remove = function (updater) {\n  const items = this._items;\n  const length = items.length;\n  for (let i = length - 1; i >= 0; i--) {\n    const item = items[i];\n    if (item.remove(updater)) {\n      // If the item is now empty, delete it (deferred until the next update,\n      // in case a new updater is added to the same item first).\n      break;\n    }\n  }\n};\n\n/**\n * Updates all the items (Batches) in the collection, and deletes any that are empty.\n * @param {JulianDate} time\n * @returns a boolean indicating whether any of the items (Batches) were updated.\n * @private\n */\nStaticGroundGeometryPerMaterialBatch.prototype.update = function (time) {\n  let i;\n  const items = this._items;\n  const length = items.length;\n  for (i = length - 1; i >= 0; i--) {\n    const item = items[i];\n    if (item.updaters.length === 0) {\n      items.splice(i, 1);\n      item.destroy();\n    }\n  }\n  let isUpdated = true;\n  for (i = 0; i < items.length; i++) {\n    isUpdated = items[i].update(time) && isUpdated;\n  }\n  return isUpdated;\n};\nStaticGroundGeometryPerMaterialBatch.prototype.getBoundingSphere = function (updater, result) {\n  const items = this._items;\n  const length = items.length;\n  for (let i = 0; i < length; i++) {\n    const item = items[i];\n    if (item.contains(updater)) {\n      return item.getBoundingSphere(updater, result);\n    }\n  }\n  return BoundingSphereState.FAILED;\n};\nStaticGroundGeometryPerMaterialBatch.prototype.removeAllPrimitives = function () {\n  const items = this._items;\n  const length = items.length;\n  for (let i = 0; i < length; i++) {\n    items[i].destroy();\n  }\n  this._items.length = 0;\n};\nexport default StaticGroundGeometryPerMaterialBatch;","map":{"version":3,"names":["AssociativeArray","defined","DistanceDisplayCondition","DistanceDisplayConditionGeometryInstanceAttribute","RectangleCollisionChecker","ShowGeometryInstanceAttribute","GroundPrimitive","ShadowVolumeAppearance","BoundingSphereState","ColorMaterialProperty","MaterialProperty","Property","distanceDisplayConditionScratch","defaultDistanceDisplayCondition","Batch","primitives","classificationType","appearanceType","materialProperty","usingSphericalTextureCoordinates","zIndex","updaters","createPrimitive","primitive","undefined","oldPrimitive","geometry","material","updatersWithAttributes","attributes","subscriptions","showsUpdated","rectangleCollisionCheck","prototype","overlapping","rectangle","collides","isMaterial","updater","updaterMaterial","fillMaterialProperty","equals","add","time","geometryInstance","id","set","insert","hasConstantFill","isConstant","distanceDisplayConditionProperty","that","entity","definitionChanged","addEventListener","propertyName","newValue","oldValue","remove","get","unsubscribe","update","isUpdated","geometries","values","i","geometriesLength","length","getValue","show","asynchronous","geometryInstances","slice","appearance","removeAll","ready","instance","getGeometryInstanceAttributes","isShowing","isFilled","currentShow","toValue","distanceDisplayCondition","getValueOrDefault","_lastDistanceDisplayCondition","clone","updateShows","value","contains","getBoundingSphere","result","PENDING","boundingSphere","FAILED","DONE","destroy","StaticGroundGeometryPerMaterialBatch","_items","_primitives","_classificationType","_appearanceType","items","createFillGeometryInstance","shouldUseSphericalCoordinates","item","batch","push","splice","removeAllPrimitives"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/DataSources/StaticGroundGeometryPerMaterialBatch.js"],"sourcesContent":["import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport defined from \"../Core/defined.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport RectangleCollisionChecker from \"../Core/RectangleCollisionChecker.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport GroundPrimitive from \"../Scene/GroundPrimitive.js\";\nimport ShadowVolumeAppearance from \"../Scene/ShadowVolumeAppearance.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport MaterialProperty from \"./MaterialProperty.js\";\nimport Property from \"./Property.js\";\n\nconst distanceDisplayConditionScratch = new DistanceDisplayCondition();\nconst defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n\n// Encapsulates a Primitive and all the entities that it represents.\nfunction Batch(\n  primitives,\n  classificationType,\n  appearanceType,\n  materialProperty,\n  usingSphericalTextureCoordinates,\n  zIndex,\n) {\n  this.primitives = primitives; // scene level primitive collection (each Batch manages its own Primitive from this collection)\n  this.classificationType = classificationType;\n  this.appearanceType = appearanceType;\n  this.materialProperty = materialProperty;\n  this.updaters = new AssociativeArray(); // GeometryUpdaters that manage the visual representation of the primitive.\n  this.createPrimitive = true;\n  this.primitive = undefined; // a GroundPrimitive encapsulating all the entities\n  this.oldPrimitive = undefined; // a GroundPrimitive that is being replaced by the current primitive, but will still be shown until the current primitive is ready.\n  this.geometry = new AssociativeArray();\n  this.material = undefined;\n  this.updatersWithAttributes = new AssociativeArray();\n  this.attributes = new AssociativeArray();\n  this.subscriptions = new AssociativeArray();\n  this.showsUpdated = new AssociativeArray();\n  this.usingSphericalTextureCoordinates = usingSphericalTextureCoordinates;\n  this.zIndex = zIndex;\n  this.rectangleCollisionCheck = new RectangleCollisionChecker();\n}\n\nBatch.prototype.overlapping = function (rectangle) {\n  return this.rectangleCollisionCheck.collides(rectangle);\n};\n\n// Check if the given updater's material is compatible with this batch\nBatch.prototype.isMaterial = function (updater) {\n  const material = this.materialProperty;\n  const updaterMaterial = updater.fillMaterialProperty;\n\n  if (\n    updaterMaterial === material ||\n    (updaterMaterial instanceof ColorMaterialProperty &&\n      material instanceof ColorMaterialProperty)\n  ) {\n    return true;\n  }\n  return defined(material) && material.equals(updaterMaterial);\n};\n\n/**\n * Adds an updater to the Batch, and signals for a new Primitive to be created on the next update.\n * @param {JulianDate} time\n * @param {GeometryUpdater} updater\n * @param {GeometryInstance} geometryInstance\n * @private\n */\nBatch.prototype.add = function (time, updater, geometryInstance) {\n  const id = updater.id;\n  this.updaters.set(id, updater);\n  this.geometry.set(id, geometryInstance);\n  this.rectangleCollisionCheck.insert(id, geometryInstance.geometry.rectangle);\n  // Updaters with dynamic attributes must be tracked separately, may exit the batch\n  if (\n    !updater.hasConstantFill ||\n    !updater.fillMaterialProperty.isConstant ||\n    !Property.isConstant(updater.distanceDisplayConditionProperty)\n  ) {\n    this.updatersWithAttributes.set(id, updater);\n  } else {\n    const that = this;\n    // Listen for show changes. These will be synchronized in updateShows.\n    this.subscriptions.set(\n      id,\n      updater.entity.definitionChanged.addEventListener(\n        function (entity, propertyName, newValue, oldValue) {\n          if (propertyName === \"isShowing\") {\n            that.showsUpdated.set(updater.id, updater);\n          }\n        },\n      ),\n    );\n  }\n  this.createPrimitive = true;\n};\n\n/**\n * Remove an updater from the Batch, and potentially signals for a new Primitive to be created\n * on the next update.\n * @param {GeometryUpdater} updater\n * @returns true if the updater was removed, false if it was not found.\n * @private\n */\nBatch.prototype.remove = function (updater) {\n  const id = updater.id;\n  const geometryInstance = this.geometry.get(id);\n  this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n  if (this.updaters.remove(id)) {\n    this.rectangleCollisionCheck.remove(\n      id,\n      geometryInstance.geometry.rectangle,\n    );\n    this.updatersWithAttributes.remove(id);\n    const unsubscribe = this.subscriptions.get(id);\n    if (defined(unsubscribe)) {\n      unsubscribe();\n      this.subscriptions.remove(id);\n    }\n    return true;\n  }\n  return false;\n};\n\n/**\n * Update a Batch, creating a new primitive, if necessary, or swapping out an old primitive for a new one that's ready.\n * A new primitive is created whenever an updater is added to or removed from a Batch.\n * @param {JulianDate} time\n * @returns a boolean indicating whether the Batch was updated.\n * @private\n */\nBatch.prototype.update = function (time) {\n  let isUpdated = true;\n  let primitive = this.primitive;\n  const primitives = this.primitives;\n  const geometries = this.geometry.values;\n  let i;\n\n  if (this.createPrimitive) {\n    const geometriesLength = geometries.length;\n    if (geometriesLength > 0) {\n      if (defined(primitive)) {\n        // Keep a handle to the old primitive so it can be removed when the updated version is ready.\n        if (!defined(this.oldPrimitive)) {\n          this.oldPrimitive = primitive;\n        } else {\n          // For if the new primitive changes again before it is ready.\n          primitives.remove(primitive);\n        }\n      }\n\n      this.material = MaterialProperty.getValue(\n        time,\n        this.materialProperty,\n        this.material,\n      );\n\n      primitive = new GroundPrimitive({\n        show: false,\n        asynchronous: true,\n        geometryInstances: geometries.slice(),\n        appearance: new this.appearanceType({\n          material: this.material,\n          // translucent and closed properties overridden\n        }),\n        classificationType: this.classificationType,\n      });\n\n      primitives.add(primitive, this.zIndex);\n      isUpdated = false;\n    } else {\n      if (defined(primitive)) {\n        primitives.remove(primitive);\n        primitive = undefined;\n      }\n      const oldPrimitive = this.oldPrimitive;\n      if (defined(oldPrimitive)) {\n        primitives.remove(oldPrimitive);\n        this.oldPrimitive = undefined;\n      }\n    }\n\n    this.attributes.removeAll();\n    this.primitive = primitive;\n    this.createPrimitive = false;\n  } else if (defined(primitive) && primitive.ready) {\n    primitive.show = true;\n    if (defined(this.oldPrimitive)) {\n      primitives.remove(this.oldPrimitive);\n      this.oldPrimitive = undefined;\n    }\n\n    this.material = MaterialProperty.getValue(\n      time,\n      this.materialProperty,\n      this.material,\n    );\n    this.primitive.appearance.material = this.material;\n\n    const updatersWithAttributes = this.updatersWithAttributes.values;\n    const length = updatersWithAttributes.length;\n    for (i = 0; i < length; i++) {\n      const updater = updatersWithAttributes[i];\n      const entity = updater.entity;\n      const instance = this.geometry.get(updater.id);\n\n      let attributes = this.attributes.get(instance.id.id);\n      if (!defined(attributes)) {\n        attributes = primitive.getGeometryInstanceAttributes(instance.id);\n        this.attributes.set(instance.id.id, attributes);\n      }\n\n      const show =\n        entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n      const currentShow = attributes.show[0] === 1;\n      if (show !== currentShow) {\n        attributes.show = ShowGeometryInstanceAttribute.toValue(\n          show,\n          attributes.show,\n        );\n      }\n\n      const distanceDisplayConditionProperty =\n        updater.distanceDisplayConditionProperty;\n      if (!Property.isConstant(distanceDisplayConditionProperty)) {\n        const distanceDisplayCondition = Property.getValueOrDefault(\n          distanceDisplayConditionProperty,\n          time,\n          defaultDistanceDisplayCondition,\n          distanceDisplayConditionScratch,\n        );\n        if (\n          !DistanceDisplayCondition.equals(\n            distanceDisplayCondition,\n            attributes._lastDistanceDisplayCondition,\n          )\n        ) {\n          attributes._lastDistanceDisplayCondition =\n            DistanceDisplayCondition.clone(\n              distanceDisplayCondition,\n              attributes._lastDistanceDisplayCondition,\n            );\n          attributes.distanceDisplayCondition =\n            DistanceDisplayConditionGeometryInstanceAttribute.toValue(\n              distanceDisplayCondition,\n              attributes.distanceDisplayCondition,\n            );\n        }\n      }\n    }\n\n    this.updateShows(primitive);\n  } else if (defined(primitive) && !primitive.ready) {\n    isUpdated = false;\n  }\n  return isUpdated;\n};\n\nBatch.prototype.updateShows = function (primitive) {\n  const showsUpdated = this.showsUpdated.values;\n  const length = showsUpdated.length;\n  for (let i = 0; i < length; i++) {\n    const updater = showsUpdated[i];\n    const entity = updater.entity;\n    const instance = this.geometry.get(updater.id);\n\n    let attributes = this.attributes.get(instance.id.id);\n    if (!defined(attributes)) {\n      attributes = primitive.getGeometryInstanceAttributes(instance.id);\n      this.attributes.set(instance.id.id, attributes);\n    }\n\n    const show = entity.isShowing;\n    const currentShow = attributes.show[0] === 1;\n    if (show !== currentShow) {\n      attributes.show = ShowGeometryInstanceAttribute.toValue(\n        show,\n        attributes.show,\n      );\n      instance.attributes.show.value[0] = attributes.show[0];\n    }\n  }\n  this.showsUpdated.removeAll();\n};\n\nBatch.prototype.contains = function (updater) {\n  return this.updaters.contains(updater.id);\n};\n\nBatch.prototype.getBoundingSphere = function (updater, result) {\n  const primitive = this.primitive;\n  if (!primitive.ready) {\n    return BoundingSphereState.PENDING;\n  }\n  const attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n  if (\n    !defined(attributes) ||\n    !defined(attributes.boundingSphere) ||\n    (defined(attributes.show) && attributes.show[0] === 0)\n  ) {\n    return BoundingSphereState.FAILED;\n  }\n  attributes.boundingSphere.clone(result);\n  return BoundingSphereState.DONE;\n};\n\n/**\n * Removes a Batch's primitive (and oldPrimitive, if it exists).\n * @private\n */\nBatch.prototype.destroy = function () {\n  const primitive = this.primitive;\n  const primitives = this.primitives;\n  if (defined(primitive)) {\n    primitives.remove(primitive);\n  }\n  const oldPrimitive = this.oldPrimitive;\n  if (defined(oldPrimitive)) {\n    primitives.remove(oldPrimitive);\n  }\n};\n\n/**\n * A container of Batch objects of ground geometry primitives, where a Batch is grouped by material,\n * texture coordinate type, and spatial overlap.\n * @private\n */\nfunction StaticGroundGeometryPerMaterialBatch(\n  primitives,\n  classificationType,\n  appearanceType,\n) {\n  this._items = []; // array of Batch objects, each containing representing a primitive and a set of updaters that manage the visual representation of the primitive.\n  this._primitives = primitives; // scene level primitive collection\n  this._classificationType = classificationType;\n  this._appearanceType = appearanceType;\n}\n\n/**\n * Adds an geometry updater to a Batch. Tries to find a preexisting compatible Batch, or else creates a new Batch.\n * Used by Visualizer classes to add and update (remove->add) a primitive's Updater set.\n *\n * @param {JulianDate} time\n * @param {GeometryUpdater} updater A GeometryUpdater that manages the visual representation of a primitive.\n * @private\n */\nStaticGroundGeometryPerMaterialBatch.prototype.add = function (time, updater) {\n  const items = this._items;\n  const length = items.length;\n  const geometryInstance = updater.createFillGeometryInstance(time);\n  const usingSphericalTextureCoordinates =\n    ShadowVolumeAppearance.shouldUseSphericalCoordinates(\n      geometryInstance.geometry.rectangle,\n    );\n  const zIndex = Property.getValueOrDefault(updater.zIndex, 0);\n  // Check if the Entity represented by the updater can be placed in an existing batch. Requirements:\n  // * compatible material (same material or same color)\n  // * same type of texture coordinates (spherical vs. planar)\n  // * conservatively non-overlapping with any entities in the existing batch\n  for (let i = 0; i < length; ++i) {\n    const item = items[i];\n    if (\n      item.isMaterial(updater) &&\n      item.usingSphericalTextureCoordinates ===\n        usingSphericalTextureCoordinates &&\n      item.zIndex === zIndex &&\n      !item.overlapping(geometryInstance.geometry.rectangle)\n    ) {\n      item.add(time, updater, geometryInstance);\n      return;\n    }\n  }\n  // If a compatible batch wasn't found, create a new batch.\n  const batch = new Batch(\n    this._primitives,\n    this._classificationType,\n    this._appearanceType,\n    updater.fillMaterialProperty,\n    usingSphericalTextureCoordinates,\n    zIndex,\n  );\n  batch.add(time, updater, geometryInstance);\n  items.push(batch);\n};\n\n/**\n * Removes an updater from a Batch. Defers potential deletion until the next update.\n * @param {GeometryUpdater} updater A GeometryUpdater that manages the visual representation of a primitive.\n * @private\n */\nStaticGroundGeometryPerMaterialBatch.prototype.remove = function (updater) {\n  const items = this._items;\n  const length = items.length;\n  for (let i = length - 1; i >= 0; i--) {\n    const item = items[i];\n    if (item.remove(updater)) {\n      // If the item is now empty, delete it (deferred until the next update,\n      // in case a new updater is added to the same item first).\n      break;\n    }\n  }\n};\n\n/**\n * Updates all the items (Batches) in the collection, and deletes any that are empty.\n * @param {JulianDate} time\n * @returns a boolean indicating whether any of the items (Batches) were updated.\n * @private\n */\nStaticGroundGeometryPerMaterialBatch.prototype.update = function (time) {\n  let i;\n  const items = this._items;\n  const length = items.length;\n\n  for (i = length - 1; i >= 0; i--) {\n    const item = items[i];\n    if (item.updaters.length === 0) {\n      items.splice(i, 1);\n      item.destroy();\n    }\n  }\n\n  let isUpdated = true;\n  for (i = 0; i < items.length; i++) {\n    isUpdated = items[i].update(time) && isUpdated;\n  }\n  return isUpdated;\n};\n\nStaticGroundGeometryPerMaterialBatch.prototype.getBoundingSphere = function (\n  updater,\n  result,\n) {\n  const items = this._items;\n  const length = items.length;\n  for (let i = 0; i < length; i++) {\n    const item = items[i];\n    if (item.contains(updater)) {\n      return item.getBoundingSphere(updater, result);\n    }\n  }\n  return BoundingSphereState.FAILED;\n};\n\nStaticGroundGeometryPerMaterialBatch.prototype.removeAllPrimitives =\n  function () {\n    const items = this._items;\n    const length = items.length;\n    for (let i = 0; i < length; i++) {\n      items[i].destroy();\n    }\n    this._items.length = 0;\n  };\nexport default StaticGroundGeometryPerMaterialBatch;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}