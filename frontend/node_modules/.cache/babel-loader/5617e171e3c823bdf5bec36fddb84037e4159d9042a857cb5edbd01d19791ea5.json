{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"uniform vec4 u_initialColor;\\n\\\n\\n\\\n#if TEXTURE_UNITS > 0\\n\\\nuniform sampler2D u_dayTextures[TEXTURE_UNITS];\\n\\\nuniform vec4 u_dayTextureTranslationAndScale[TEXTURE_UNITS];\\n\\\nuniform bool u_dayTextureUseWebMercatorT[TEXTURE_UNITS];\\n\\\n\\n\\\n#ifdef APPLY_ALPHA\\n\\\nuniform float u_dayTextureAlpha[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_DAY_NIGHT_ALPHA\\n\\\nuniform float u_dayTextureNightAlpha[TEXTURE_UNITS];\\n\\\nuniform float u_dayTextureDayAlpha[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_SPLIT\\n\\\nuniform float u_dayTextureSplit[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_BRIGHTNESS\\n\\\nuniform float u_dayTextureBrightness[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_CONTRAST\\n\\\nuniform float u_dayTextureContrast[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_HUE\\n\\\nuniform float u_dayTextureHue[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_SATURATION\\n\\\nuniform float u_dayTextureSaturation[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_GAMMA\\n\\\nuniform float u_dayTextureOneOverGamma[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_IMAGERY_CUTOUT\\n\\\nuniform vec4 u_dayTextureCutoutRectangles[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_COLOR_TO_ALPHA\\n\\\nuniform vec4 u_colorsToAlpha[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\nuniform vec4 u_dayTextureTexCoordsRectangle[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#if defined(HAS_WATER_MASK) && (defined(SHOW_REFLECTIVE_OCEAN) || defined(APPLY_MATERIAL))\\n\\\nuniform sampler2D u_waterMask;\\n\\\nuniform vec4 u_waterMaskTranslationAndScale;\\n\\\nuniform float u_zoomedOutOceanSpecularIntensity;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef SHOW_OCEAN_WAVES\\n\\\nuniform sampler2D u_oceanNormalMap;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(ENABLE_DAYNIGHT_SHADING) || defined(GROUND_ATMOSPHERE)\\n\\\nuniform vec2 u_lightingFadeDistance;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef TILE_LIMIT_RECTANGLE\\n\\\nuniform vec4 u_cartographicLimitRectangle;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef GROUND_ATMOSPHERE\\n\\\nuniform vec2 u_nightFadeDistance;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_CLIPPING_PLANES\\n\\\nuniform highp sampler2D u_clippingPlanes;\\n\\\nuniform mat4 u_clippingPlanesMatrix;\\n\\\nuniform vec4 u_clippingPlanesEdgeStyle;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_CLIPPING_POLYGONS\\n\\\nuniform highp sampler2D u_clippingDistance;\\n\\\nin vec2 v_clippingPosition;\\n\\\nflat in int v_regionIndex;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(GROUND_ATMOSPHERE) || defined(FOG) && defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING))\\n\\\nuniform float u_minimumBrightness;\\n\\\n#endif\\n\\\n\\n\\\n// Based on colorCorrect\\n\\\n// The colorCorrect flag can only be true when tileProvider.hue/saturation/brightnessShift \\n\\\n// are nonzero AND when (applyFog || showGroundAtmosphere) in the tile provider\\n\\\n// - The tileProvider.hue/saturation/brightnessShift are just passed through\\n\\\n//   from the Globe hue/saturation/brightness, like atmosphereBrightnessShift\\n\\\n// - The applyFog depends on enableFog, and some tile distance from the viewer\\n\\\n// - The showGroundAtmosphere is a flag that is passed through from the Globe,\\n\\\n//   and is true by default when the ellipsoid is WGS84\\n\\\n#ifdef COLOR_CORRECT\\n\\\nuniform vec3 u_hsbShift; // Hue, saturation, brightness\\n\\\n#endif\\n\\\n\\n\\\n// Based on highlightFillTile\\n\\\n// This is set for terrain tiles when they are \\\"fill\\\" tiles, and\\n\\\n// the terrainProvider.fillHighlightColor was set to a value with\\n\\\n// nonzero alpha\\n\\\n#ifdef HIGHLIGHT_FILL_TILE\\n\\\nuniform vec4 u_fillHighlightColor;\\n\\\n#endif\\n\\\n\\n\\\n// Based on translucent\\n\\\n// This is set depending on the GlobeTranslucencyState\\n\\\n#ifdef TRANSLUCENT\\n\\\nuniform vec4 u_frontFaceAlphaByDistance;\\n\\\nuniform vec4 u_backFaceAlphaByDistance;\\n\\\nuniform vec4 u_translucencyRectangle;\\n\\\n#endif\\n\\\n\\n\\\n// Based on showUndergroundColor\\n\\\n// This is set when GlobeSurfaceTileProvider.isUndergroundVisible \\n\\\n// returns true, AND the tileProvider.undergroundColor had a value with \\n\\\n// nonzero alpha, and the tileProvider.undergroundColorAlphaByDistance\\n\\\n// was in the right range\\n\\\n#ifdef UNDERGROUND_COLOR\\n\\\nuniform vec4 u_undergroundColor;\\n\\\nuniform vec4 u_undergroundColorAlphaByDistance;\\n\\\n#endif\\n\\\n\\n\\\n// Based on enableLighting && hasVertexNormals\\n\\\n// The enableLighting flag is passed in directly from the Globe.\\n\\\n// The hasVertexNormals flag is from the tileProvider\\n\\\n#ifdef ENABLE_VERTEX_LIGHTING\\n\\\nuniform float u_lambertDiffuseMultiplier;\\n\\\nuniform float u_vertexShadowDarkness;\\n\\\n#endif\\n\\\n\\n\\\nin vec3 v_positionMC;\\n\\\nin vec3 v_positionEC;\\n\\\nin vec3 v_textureCoordinates;\\n\\\nin vec3 v_normalMC;\\n\\\nin vec3 v_normalEC;\\n\\\n\\n\\\n#ifdef APPLY_MATERIAL\\n\\\nin float v_height;\\n\\\nin float v_slope;\\n\\\nin float v_aspect;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(FOG) || defined(GROUND_ATMOSPHERE) || defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)\\n\\\nin float v_distance;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(GROUND_ATMOSPHERE) || defined(FOG)\\n\\\nin vec3 v_atmosphereRayleighColor;\\n\\\nin vec3 v_atmosphereMieColor;\\n\\\nin float v_atmosphereOpacity;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)\\n\\\nfloat interpolateByDistance(vec4 nearFarScalar, float distance)\\n\\\n{\\n\\\n    float startDistance = nearFarScalar.x;\\n\\\n    float startValue = nearFarScalar.y;\\n\\\n    float endDistance = nearFarScalar.z;\\n\\\n    float endValue = nearFarScalar.w;\\n\\\n    float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0);\\n\\\n    return mix(startValue, endValue, t);\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#if defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT) || defined(APPLY_MATERIAL)\\n\\\nvec4 alphaBlend(vec4 sourceColor, vec4 destinationColor)\\n\\\n{\\n\\\n    return sourceColor * vec4(sourceColor.aaa, 1.0) + destinationColor * (1.0 - sourceColor.a);\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#ifdef TRANSLUCENT\\n\\\nbool inTranslucencyRectangle()\\n\\\n{\\n\\\n    return\\n\\\n        v_textureCoordinates.x > u_translucencyRectangle.x &&\\n\\\n        v_textureCoordinates.x < u_translucencyRectangle.z &&\\n\\\n        v_textureCoordinates.y > u_translucencyRectangle.y &&\\n\\\n        v_textureCoordinates.y < u_translucencyRectangle.w;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\nvec4 sampleAndBlend(\\n\\\n    vec4 previousColor,\\n\\\n    sampler2D textureToSample,\\n\\\n    vec2 tileTextureCoordinates,\\n\\\n    vec4 textureCoordinateRectangle,\\n\\\n    vec4 textureCoordinateTranslationAndScale,\\n\\\n    float textureAlpha,\\n\\\n    float textureNightAlpha,\\n\\\n    float textureDayAlpha,\\n\\\n    float textureBrightness,\\n\\\n    float textureContrast,\\n\\\n    float textureHue,\\n\\\n    float textureSaturation,\\n\\\n    float textureOneOverGamma,\\n\\\n    float split,\\n\\\n    vec4 colorToAlpha,\\n\\\n    float nightBlend)\\n\\\n{\\n\\\n    // This crazy step stuff sets the alpha to 0.0 if this following condition is true:\\n\\\n    //    tileTextureCoordinates.s < textureCoordinateRectangle.s ||\\n\\\n    //    tileTextureCoordinates.s > textureCoordinateRectangle.p ||\\n\\\n    //    tileTextureCoordinates.t < textureCoordinateRectangle.t ||\\n\\\n    //    tileTextureCoordinates.t > textureCoordinateRectangle.q\\n\\\n    // In other words, the alpha is zero if the fragment is outside the rectangle\\n\\\n    // covered by this texture.  Would an actual 'if' yield better performance?\\n\\\n    vec2 alphaMultiplier = step(textureCoordinateRectangle.st, tileTextureCoordinates);\\n\\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\n\\\n\\n\\\n    alphaMultiplier = step(vec2(0.0), textureCoordinateRectangle.pq - tileTextureCoordinates);\\n\\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\n\\\n\\n\\\n#if defined(APPLY_DAY_NIGHT_ALPHA) && defined(ENABLE_DAYNIGHT_SHADING)\\n\\\n    textureAlpha *= mix(textureDayAlpha, textureNightAlpha, nightBlend);\\n\\\n#endif\\n\\\n\\n\\\n    vec2 translation = textureCoordinateTranslationAndScale.xy;\\n\\\n    vec2 scale = textureCoordinateTranslationAndScale.zw;\\n\\\n    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\\n\\\n    vec4 value = texture(textureToSample, textureCoordinates);\\n\\\n    vec3 color = value.rgb;\\n\\\n    float alpha = value.a;\\n\\\n\\n\\\n#ifdef APPLY_COLOR_TO_ALPHA\\n\\\n    vec3 colorDiff = abs(color.rgb - colorToAlpha.rgb);\\n\\\n    colorDiff.r = czm_maximumComponent(colorDiff);\\n\\\n    alpha = czm_branchFreeTernary(colorDiff.r < colorToAlpha.a, 0.0, alpha);\\n\\\n#endif\\n\\\n\\n\\\n#if !defined(APPLY_GAMMA)\\n\\\n    vec4 tempColor = czm_gammaCorrect(vec4(color, alpha));\\n\\\n    color = tempColor.rgb;\\n\\\n    alpha = tempColor.a;\\n\\\n#else\\n\\\n    color = pow(color, vec3(textureOneOverGamma));\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_SPLIT\\n\\\n    float splitPosition = czm_splitPosition;\\n\\\n    // Split to the left\\n\\\n    if (split < 0.0 && gl_FragCoord.x > splitPosition) {\\n\\\n       alpha = 0.0;\\n\\\n    }\\n\\\n    // Split to the right\\n\\\n    else if (split > 0.0 && gl_FragCoord.x < splitPosition) {\\n\\\n       alpha = 0.0;\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_BRIGHTNESS\\n\\\n    color = mix(vec3(0.0), color, textureBrightness);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_CONTRAST\\n\\\n    color = mix(vec3(0.5), color, textureContrast);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_HUE\\n\\\n    color = czm_hue(color, textureHue);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_SATURATION\\n\\\n    color = czm_saturation(color, textureSaturation);\\n\\\n#endif\\n\\\n\\n\\\n    float sourceAlpha = alpha * textureAlpha;\\n\\\n    float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\\n\\\n    outAlpha += sign(outAlpha) - 1.0;\\n\\\n\\n\\\n    vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\\n\\\n\\n\\\n    // When rendering imagery for a tile in multiple passes,\\n\\\n    // some GPU/WebGL implementation combinations will not blend fragments in\\n\\\n    // additional passes correctly if their computation includes an unmasked\\n\\\n    // divide-by-zero operation,\\n\\\n    // even if it's not in the output or if the output has alpha zero.\\n\\\n    //\\n\\\n    // For example, without sanitization for outAlpha,\\n\\\n    // this renders without artifacts:\\n\\\n    //   if (outAlpha == 0.0) { outColor = vec3(0.0); }\\n\\\n    //\\n\\\n    // but using czm_branchFreeTernary will cause portions of the tile that are\\n\\\n    // alpha-zero in the additional pass to render as black instead of blending\\n\\\n    // with the previous pass:\\n\\\n    //   outColor = czm_branchFreeTernary(outAlpha == 0.0, vec3(0.0), outColor);\\n\\\n    //\\n\\\n    // So instead, sanitize against divide-by-zero,\\n\\\n    // store this state on the sign of outAlpha, and correct on return.\\n\\\n\\n\\\n    return vec4(outColor, max(outAlpha, 0.0));\\n\\\n}\\n\\\n\\n\\\nvec4 computeDayColor(vec4 initialColor, vec3 textureCoordinates, float nightBlend);\\n\\\nvec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec4 imageryColor, float specularMapValue, float fade);\\n\\\n\\n\\\nconst float fExposure = 2.0;\\n\\\n\\n\\\nvec3 computeEllipsoidPosition()\\n\\\n{\\n\\\n    float mpp = czm_metersPerPixel(vec4(0.0, 0.0, -czm_currentFrustum.x, 1.0), 1.0);\\n\\\n    vec2 xy = gl_FragCoord.xy / czm_viewport.zw * 2.0 - vec2(1.0);\\n\\\n    xy *= czm_viewport.zw * mpp * 0.5;\\n\\\n\\n\\\n    vec3 direction;\\n\\\n    if (czm_orthographicIn3D == 1.0)\\n\\\n    {\\n\\\n        direction = vec3(0.0, 0.0, -1.0);\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        direction = normalize(vec3(xy, -czm_currentFrustum.x));\\n\\\n    }\\n\\\n\\n\\\n    czm_ray ray = czm_ray(vec3(0.0), direction);\\n\\\n\\n\\\n    vec3 ellipsoid_center = czm_view[3].xyz;\\n\\\n\\n\\\n    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid_center, czm_ellipsoidInverseRadii);\\n\\\n\\n\\\n    vec3 ellipsoidPosition = czm_pointAlongRay(ray, intersection.start);\\n\\\n    return (czm_inverseView * vec4(ellipsoidPosition, 1.0)).xyz;\\n\\\n}\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n#ifdef TILE_LIMIT_RECTANGLE\\n\\\n    if (v_textureCoordinates.x < u_cartographicLimitRectangle.x || u_cartographicLimitRectangle.z < v_textureCoordinates.x ||\\n\\\n        v_textureCoordinates.y < u_cartographicLimitRectangle.y || u_cartographicLimitRectangle.w < v_textureCoordinates.y)\\n\\\n        {\\n\\\n            discard;\\n\\\n        }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_CLIPPING_PLANES\\n\\\n    float clipDistance = clip(gl_FragCoord, u_clippingPlanes, u_clippingPlanesMatrix);\\n\\\n#endif\\n\\\n\\n\\\n#if defined(SHOW_REFLECTIVE_OCEAN) || defined(ENABLE_DAYNIGHT_SHADING) || defined(HDR)\\n\\\n    vec3 normalMC = czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0));   // normalized surface normal in model coordinates\\n\\\n    vec3 normalEC = czm_normal3D * normalMC;                                         // normalized surface normal in eye coordinates\\n\\\n#endif\\n\\\n\\n\\\n#if defined(APPLY_DAY_NIGHT_ALPHA) && defined(ENABLE_DAYNIGHT_SHADING)\\n\\\n    float nightBlend = 1.0 - clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * 5.0, 0.0, 1.0);\\n\\\n#else\\n\\\n    float nightBlend = 0.0;\\n\\\n#endif\\n\\\n\\n\\\n    // The clamp below works around an apparent bug in Chrome Canary v23.0.1241.0\\n\\\n    // where the fragment shader sees textures coordinates < 0.0 and > 1.0 for the\\n\\\n    // fragments on the edges of tiles even though the vertex shader is outputting\\n\\\n    // coordinates strictly in the 0-1 range.\\n\\\n    vec4 color = computeDayColor(u_initialColor, clamp(v_textureCoordinates, 0.0, 1.0), nightBlend);\\n\\\n\\n\\\n#ifdef SHOW_TILE_BOUNDARIES\\n\\\n    if (v_textureCoordinates.x < (1.0/256.0) || v_textureCoordinates.x > (255.0/256.0) ||\\n\\\n        v_textureCoordinates.y < (1.0/256.0) || v_textureCoordinates.y > (255.0/256.0))\\n\\\n    {\\n\\\n        color = vec4(1.0, 0.0, 0.0, 1.0);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#if defined(ENABLE_DAYNIGHT_SHADING) || defined(GROUND_ATMOSPHERE)\\n\\\n    float cameraDist;\\n\\\n    if (czm_sceneMode == czm_sceneMode2D)\\n\\\n    {\\n\\\n        cameraDist = max(czm_frustumPlanes.x - czm_frustumPlanes.y, czm_frustumPlanes.w - czm_frustumPlanes.z) * 0.5;\\n\\\n    }\\n\\\n    else if (czm_sceneMode == czm_sceneModeColumbusView)\\n\\\n    {\\n\\\n        cameraDist = -czm_view[3].z;\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        cameraDist = length(czm_view[3]);\\n\\\n    }\\n\\\n    float fadeOutDist = u_lightingFadeDistance.x;\\n\\\n    float fadeInDist = u_lightingFadeDistance.y;\\n\\\n    if (czm_sceneMode != czm_sceneMode3D) {\\n\\\n        vec3 radii = czm_ellipsoidRadii;\\n\\\n        float maxRadii = max(radii.x, max(radii.y, radii.z));\\n\\\n        fadeOutDist -= maxRadii;\\n\\\n        fadeInDist -= maxRadii;\\n\\\n    }\\n\\\n    float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\\n\\\n#else\\n\\\n    float fade = 0.0;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(HAS_WATER_MASK) && (defined(SHOW_REFLECTIVE_OCEAN) || defined(APPLY_MATERIAL))\\n\\\n    vec2 waterMaskTranslation = u_waterMaskTranslationAndScale.xy;\\n\\\n    vec2 waterMaskScale = u_waterMaskTranslationAndScale.zw;\\n\\\n    vec2 waterMaskTextureCoordinates = v_textureCoordinates.xy * waterMaskScale + waterMaskTranslation;\\n\\\n    waterMaskTextureCoordinates.y = 1.0 - waterMaskTextureCoordinates.y;\\n\\\n\\n\\\n    float mask = texture(u_waterMask, waterMaskTextureCoordinates).r;\\n\\\n\\n\\\n    #ifdef SHOW_REFLECTIVE_OCEAN\\n\\\n    if (mask > 0.0)\\n\\\n    {\\n\\\n        mat3 enuToEye = czm_eastNorthUpToEyeCoordinates(v_positionMC, normalEC);\\n\\\n\\n\\\n        vec2 ellipsoidTextureCoordinates = czm_ellipsoidTextureCoordinates(normalMC);\\n\\\n        vec2 ellipsoidFlippedTextureCoordinates = czm_ellipsoidTextureCoordinates(normalMC.zyx);\\n\\\n\\n\\\n        vec2 textureCoordinates = mix(ellipsoidTextureCoordinates, ellipsoidFlippedTextureCoordinates, czm_morphTime * smoothstep(0.9, 0.95, normalMC.z));\\n\\\n\\n\\\n        color = computeWaterColor(v_positionEC, textureCoordinates, enuToEye, color, mask, fade);\\n\\\n    }\\n\\\n    #endif\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_MATERIAL\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.st = v_textureCoordinates.st;\\n\\\n    materialInput.normalEC = normalize(v_normalEC);\\n\\\n    materialInput.positionToEyeEC = -v_positionEC;\\n\\\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, normalize(v_normalEC));\\n\\\n    materialInput.slope = v_slope;\\n\\\n    materialInput.height = v_height;\\n\\\n    materialInput.aspect = v_aspect;\\n\\\n    #ifdef HAS_WATER_MASK\\n\\\n        materialInput.waterMask = mask;\\n\\\n    #endif\\n\\\n\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n    vec4 materialColor = vec4(material.diffuse, material.alpha);\\n\\\n    color = alphaBlend(materialColor, color);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_VERTEX_LIGHTING\\n\\\n    float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalize(v_normalEC)) * u_lambertDiffuseMultiplier + u_vertexShadowDarkness, 0.0, 1.0);\\n\\\n    vec4 finalColor = vec4(color.rgb * czm_lightColor * diffuseIntensity, color.a);\\n\\\n#elif defined(ENABLE_DAYNIGHT_SHADING)\\n\\\n    float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);\\n\\\n    diffuseIntensity = mix(1.0, diffuseIntensity, fade);\\n\\\n    vec4 finalColor = vec4(color.rgb * czm_lightColor * diffuseIntensity, color.a);\\n\\\n#else\\n\\\n    vec4 finalColor = color;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_CLIPPING_PLANES\\n\\\n    vec4 clippingPlanesEdgeColor = vec4(1.0);\\n\\\n    clippingPlanesEdgeColor.rgb = u_clippingPlanesEdgeStyle.rgb;\\n\\\n    float clippingPlanesEdgeWidth = u_clippingPlanesEdgeStyle.a;\\n\\\n\\n\\\n    if (clipDistance < clippingPlanesEdgeWidth)\\n\\\n    {\\n\\\n        finalColor = clippingPlanesEdgeColor;\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_CLIPPING_POLYGONS\\n\\\n    vec2 clippingPosition = v_clippingPosition;\\n\\\n    int regionIndex = v_regionIndex;\\n\\\n    clipPolygons(u_clippingDistance, CLIPPING_POLYGON_REGIONS_LENGTH, clippingPosition, regionIndex);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef HIGHLIGHT_FILL_TILE\\n\\\n    finalColor = vec4(mix(finalColor.rgb, u_fillHighlightColor.rgb, u_fillHighlightColor.a), finalColor.a);\\n\\\n#endif\\n\\\n\\n\\\n#if defined(DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN)\\n\\\n    vec3 atmosphereLightDirection = czm_sunDirectionWC;\\n\\\n#else\\n\\\n    vec3 atmosphereLightDirection = czm_lightDirectionWC;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(GROUND_ATMOSPHERE) || defined(FOG)\\n\\\n    if (!czm_backFacing())\\n\\\n    {\\n\\\n        bool dynamicLighting = false;\\n\\\n        #if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_DAYNIGHT_SHADING) || defined(ENABLE_VERTEX_LIGHTING))\\n\\\n            dynamicLighting = true;\\n\\\n        #endif\\n\\\n\\n\\\n        vec3 rayleighColor;\\n\\\n        vec3 mieColor;\\n\\\n        float opacity;\\n\\\n\\n\\\n        vec3 positionWC;\\n\\\n        vec3 lightDirection;\\n\\\n\\n\\\n        // When the camera is far away (camera distance > nightFadeOutDistance), the scattering is computed in the fragment shader.\\n\\\n        // Otherwise, the scattering is computed in the vertex shader.\\n\\\n        #ifdef PER_FRAGMENT_GROUND_ATMOSPHERE\\n\\\n            positionWC = computeEllipsoidPosition();\\n\\\n            lightDirection = czm_branchFreeTernary(dynamicLighting, atmosphereLightDirection, normalize(positionWC));\\n\\\n            computeAtmosphereScattering(\\n\\\n                positionWC,\\n\\\n                lightDirection,\\n\\\n                rayleighColor,\\n\\\n                mieColor,\\n\\\n                opacity\\n\\\n            );\\n\\\n        #else\\n\\\n            positionWC = v_positionMC;\\n\\\n            lightDirection = czm_branchFreeTernary(dynamicLighting, atmosphereLightDirection, normalize(positionWC));\\n\\\n            rayleighColor = v_atmosphereRayleighColor;\\n\\\n            mieColor = v_atmosphereMieColor;\\n\\\n            opacity = v_atmosphereOpacity;\\n\\\n        #endif\\n\\\n\\n\\\n        #ifdef COLOR_CORRECT\\n\\\n            const bool ignoreBlackPixels = true;\\n\\\n            rayleighColor = czm_applyHSBShift(rayleighColor, u_hsbShift, ignoreBlackPixels);\\n\\\n            mieColor = czm_applyHSBShift(mieColor, u_hsbShift, ignoreBlackPixels);\\n\\\n        #endif\\n\\\n\\n\\\n        vec4 groundAtmosphereColor = computeAtmosphereColor(positionWC, lightDirection, rayleighColor, mieColor, opacity);\\n\\\n\\n\\\n        // Fog is applied to tiles selected for fog, close to the Earth.\\n\\\n        #ifdef FOG\\n\\\n            vec3 fogColor = groundAtmosphereColor.rgb;\\n\\\n\\n\\\n            // If there is lighting, apply that to the fog.\\n\\\n            #if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING))\\n\\\n                float darken = clamp(dot(normalize(czm_viewerPositionWC), atmosphereLightDirection), u_minimumBrightness, 1.0);\\n\\\n                fogColor *= darken;\\n\\\n            #endif\\n\\\n\\n\\\n            #ifndef HDR\\n\\\n                fogColor.rgb = czm_pbrNeutralTonemapping(fogColor.rgb);\\n\\\n                fogColor.rgb = czm_inverseGamma(fogColor.rgb);\\n\\\n            #endif\\n\\\n\\n\\\n            finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor.rgb, czm_fogVisualDensityScalar), finalColor.a);\\n\\\n\\n\\\n        #else\\n\\\n            // Apply ground atmosphere. This happens when the camera is far away from the earth.\\n\\\n\\n\\\n            // The transmittance is based on optical depth i.e. the length of segment of the ray inside the atmosphere.\\n\\\n            // This value is larger near the \\\"circumference\\\", as it is further away from the camera. We use it to\\n\\\n            // brighten up that area of the ground atmosphere.\\n\\\n            const float transmittanceModifier = 0.5;\\n\\\n            float transmittance = transmittanceModifier + clamp(1.0 - groundAtmosphereColor.a, 0.0, 1.0);\\n\\\n\\n\\\n            vec3 finalAtmosphereColor = finalColor.rgb + groundAtmosphereColor.rgb * transmittance;\\n\\\n\\n\\\n            #if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING))\\n\\\n                float fadeInDist = u_nightFadeDistance.x;\\n\\\n                float fadeOutDist = u_nightFadeDistance.y;\\n\\\n\\n\\\n                float sunlitAtmosphereIntensity = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.05, 1.0);\\n\\\n                float darken = clamp(dot(normalize(positionWC), atmosphereLightDirection), 0.0, 1.0);\\n\\\n                vec3 darkenendGroundAtmosphereColor = mix(groundAtmosphereColor.rgb, finalAtmosphereColor.rgb, darken);\\n\\\n\\n\\\n                finalAtmosphereColor = mix(darkenendGroundAtmosphereColor, finalAtmosphereColor, sunlitAtmosphereIntensity);\\n\\\n            #endif\\n\\\n\\n\\\n            #ifndef HDR\\n\\\n                finalAtmosphereColor.rgb = vec3(1.0) - exp(-fExposure * finalAtmosphereColor.rgb);\\n\\\n            #else\\n\\\n                finalAtmosphereColor.rgb = czm_saturation(finalAtmosphereColor.rgb, 1.6);\\n\\\n            #endif\\n\\\n\\n\\\n            finalColor.rgb = mix(finalColor.rgb, finalAtmosphereColor.rgb, fade);\\n\\\n        #endif\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef UNDERGROUND_COLOR\\n\\\n    if (czm_backFacing())\\n\\\n    {\\n\\\n        float distanceFromEllipsoid = max(czm_eyeHeight, 0.0);\\n\\\n        float distance = max(v_distance - distanceFromEllipsoid, 0.0);\\n\\\n        float blendAmount = interpolateByDistance(u_undergroundColorAlphaByDistance, distance);\\n\\\n        vec4 undergroundColor = vec4(u_undergroundColor.rgb, u_undergroundColor.a * blendAmount);\\n\\\n        finalColor = alphaBlend(undergroundColor, finalColor);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef TRANSLUCENT\\n\\\n    if (inTranslucencyRectangle())\\n\\\n    {\\n\\\n      vec4 alphaByDistance = gl_FrontFacing ? u_frontFaceAlphaByDistance : u_backFaceAlphaByDistance;\\n\\\n      finalColor.a *= interpolateByDistance(alphaByDistance, v_distance);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n    out_FragColor =  finalColor;\\n\\\n}\\n\\\n\\n\\\n\\n\\\n#ifdef SHOW_REFLECTIVE_OCEAN\\n\\\n\\n\\\nfloat waveFade(float edge0, float edge1, float x)\\n\\\n{\\n\\\n    float y = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n\\\n    return pow(1.0 - y, 5.0);\\n\\\n}\\n\\\n\\n\\\nfloat linearFade(float edge0, float edge1, float x)\\n\\\n{\\n\\\n    return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n\\\n}\\n\\\n\\n\\\n// Based on water rendering by Jonas Wagner:\\n\\\n// http://29a.ch/2012/7/19/webgl-terrain-rendering-water-fog\\n\\\n\\n\\\n// low altitude wave settings\\n\\\nconst float oceanFrequencyLowAltitude = 825000.0;\\n\\\nconst float oceanAnimationSpeedLowAltitude = 0.004;\\n\\\nconst float oceanOneOverAmplitudeLowAltitude = 1.0 / 2.0;\\n\\\nconst float oceanSpecularIntensity = 0.5;\\n\\\n\\n\\\n// high altitude wave settings\\n\\\nconst float oceanFrequencyHighAltitude = 125000.0;\\n\\\nconst float oceanAnimationSpeedHighAltitude = 0.008;\\n\\\nconst float oceanOneOverAmplitudeHighAltitude = 1.0 / 2.0;\\n\\\n\\n\\\nvec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec4 imageryColor, float maskValue, float fade)\\n\\\n{\\n\\\n    vec3 positionToEyeEC = -positionEyeCoordinates;\\n\\\n    float positionToEyeECLength = length(positionToEyeEC);\\n\\\n\\n\\\n    // The double normalize below works around a bug in Firefox on Android devices.\\n\\\n    vec3 normalizedPositionToEyeEC = normalize(normalize(positionToEyeEC));\\n\\\n\\n\\\n    // Fade out the waves as the camera moves far from the surface.\\n\\\n    float waveIntensity = waveFade(70000.0, 1000000.0, positionToEyeECLength);\\n\\\n\\n\\\n#ifdef SHOW_OCEAN_WAVES\\n\\\n    // high altitude waves\\n\\\n    float time = czm_frameNumber * oceanAnimationSpeedHighAltitude;\\n\\\n    vec4 noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequencyHighAltitude, time, 0.0);\\n\\\n    vec3 normalTangentSpaceHighAltitude = vec3(noise.xy, noise.z * oceanOneOverAmplitudeHighAltitude);\\n\\\n\\n\\\n    // low altitude waves\\n\\\n    time = czm_frameNumber * oceanAnimationSpeedLowAltitude;\\n\\\n    noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequencyLowAltitude, time, 0.0);\\n\\\n    vec3 normalTangentSpaceLowAltitude = vec3(noise.xy, noise.z * oceanOneOverAmplitudeLowAltitude);\\n\\\n\\n\\\n    // blend the 2 wave layers based on distance to surface\\n\\\n    float highAltitudeFade = linearFade(0.0, 60000.0, positionToEyeECLength);\\n\\\n    float lowAltitudeFade = 1.0 - linearFade(20000.0, 60000.0, positionToEyeECLength);\\n\\\n    vec3 normalTangentSpace =\\n\\\n        (highAltitudeFade * normalTangentSpaceHighAltitude) +\\n\\\n        (lowAltitudeFade * normalTangentSpaceLowAltitude);\\n\\\n    normalTangentSpace = normalize(normalTangentSpace);\\n\\\n\\n\\\n    // fade out the normal perturbation as we move farther from the water surface\\n\\\n    normalTangentSpace.xy *= waveIntensity;\\n\\\n    normalTangentSpace = normalize(normalTangentSpace);\\n\\\n#else\\n\\\n    vec3 normalTangentSpace = vec3(0.0, 0.0, 1.0);\\n\\\n#endif\\n\\\n\\n\\\n    vec3 normalEC = enuToEye * normalTangentSpace;\\n\\\n\\n\\\n    const vec3 waveHighlightColor = vec3(0.3, 0.45, 0.6);\\n\\\n\\n\\\n    // Use diffuse light to highlight the waves\\n\\\n    float diffuseIntensity = czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * maskValue;\\n\\\n    vec3 diffuseHighlight = waveHighlightColor * diffuseIntensity * (1.0 - fade);\\n\\\n\\n\\\n#ifdef SHOW_OCEAN_WAVES\\n\\\n    // Where diffuse light is low or non-existent, use wave highlights based solely on\\n\\\n    // the wave bumpiness and no particular light direction.\\n\\\n    float tsPerturbationRatio = normalTangentSpace.z;\\n\\\n    vec3 nonDiffuseHighlight = mix(waveHighlightColor * 5.0 * (1.0 - tsPerturbationRatio), vec3(0.0), diffuseIntensity);\\n\\\n#else\\n\\\n    vec3 nonDiffuseHighlight = vec3(0.0);\\n\\\n#endif\\n\\\n\\n\\\n    // Add specular highlights in 3D, and in all modes when zoomed in.\\n\\\n    float specularIntensity = czm_getSpecular(czm_lightDirectionEC, normalizedPositionToEyeEC, normalEC, 10.0);\\n\\\n    float surfaceReflectance = mix(0.0, mix(u_zoomedOutOceanSpecularIntensity, oceanSpecularIntensity, waveIntensity), maskValue);\\n\\\n    float specular = specularIntensity * surfaceReflectance;\\n\\\n\\n\\\n#ifdef HDR\\n\\\n    specular *= 1.4;\\n\\\n\\n\\\n    float e = 0.2;\\n\\\n    float d = 3.3;\\n\\\n    float c = 1.7;\\n\\\n\\n\\\n    vec3 color = imageryColor.rgb + (c * (vec3(e) + imageryColor.rgb * d) * (diffuseHighlight + nonDiffuseHighlight + specular));\\n\\\n#else\\n\\\n    vec3 color = imageryColor.rgb + diffuseHighlight + nonDiffuseHighlight + specular;\\n\\\n#endif\\n\\\n\\n\\\n    return vec4(color, imageryColor.a);\\n\\\n}\\n\\\n\\n\\\n#endif // #ifdef SHOW_REFLECTIVE_OCEAN\\n\\\n\";","map":{"version":3,"names":[],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Shaders/GlobeFS.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"uniform vec4 u_initialColor;\\n\\\n\\n\\\n#if TEXTURE_UNITS > 0\\n\\\nuniform sampler2D u_dayTextures[TEXTURE_UNITS];\\n\\\nuniform vec4 u_dayTextureTranslationAndScale[TEXTURE_UNITS];\\n\\\nuniform bool u_dayTextureUseWebMercatorT[TEXTURE_UNITS];\\n\\\n\\n\\\n#ifdef APPLY_ALPHA\\n\\\nuniform float u_dayTextureAlpha[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_DAY_NIGHT_ALPHA\\n\\\nuniform float u_dayTextureNightAlpha[TEXTURE_UNITS];\\n\\\nuniform float u_dayTextureDayAlpha[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_SPLIT\\n\\\nuniform float u_dayTextureSplit[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_BRIGHTNESS\\n\\\nuniform float u_dayTextureBrightness[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_CONTRAST\\n\\\nuniform float u_dayTextureContrast[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_HUE\\n\\\nuniform float u_dayTextureHue[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_SATURATION\\n\\\nuniform float u_dayTextureSaturation[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_GAMMA\\n\\\nuniform float u_dayTextureOneOverGamma[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_IMAGERY_CUTOUT\\n\\\nuniform vec4 u_dayTextureCutoutRectangles[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_COLOR_TO_ALPHA\\n\\\nuniform vec4 u_colorsToAlpha[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\nuniform vec4 u_dayTextureTexCoordsRectangle[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#if defined(HAS_WATER_MASK) && (defined(SHOW_REFLECTIVE_OCEAN) || defined(APPLY_MATERIAL))\\n\\\nuniform sampler2D u_waterMask;\\n\\\nuniform vec4 u_waterMaskTranslationAndScale;\\n\\\nuniform float u_zoomedOutOceanSpecularIntensity;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef SHOW_OCEAN_WAVES\\n\\\nuniform sampler2D u_oceanNormalMap;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(ENABLE_DAYNIGHT_SHADING) || defined(GROUND_ATMOSPHERE)\\n\\\nuniform vec2 u_lightingFadeDistance;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef TILE_LIMIT_RECTANGLE\\n\\\nuniform vec4 u_cartographicLimitRectangle;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef GROUND_ATMOSPHERE\\n\\\nuniform vec2 u_nightFadeDistance;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_CLIPPING_PLANES\\n\\\nuniform highp sampler2D u_clippingPlanes;\\n\\\nuniform mat4 u_clippingPlanesMatrix;\\n\\\nuniform vec4 u_clippingPlanesEdgeStyle;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_CLIPPING_POLYGONS\\n\\\nuniform highp sampler2D u_clippingDistance;\\n\\\nin vec2 v_clippingPosition;\\n\\\nflat in int v_regionIndex;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(GROUND_ATMOSPHERE) || defined(FOG) && defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING))\\n\\\nuniform float u_minimumBrightness;\\n\\\n#endif\\n\\\n\\n\\\n// Based on colorCorrect\\n\\\n// The colorCorrect flag can only be true when tileProvider.hue/saturation/brightnessShift \\n\\\n// are nonzero AND when (applyFog || showGroundAtmosphere) in the tile provider\\n\\\n// - The tileProvider.hue/saturation/brightnessShift are just passed through\\n\\\n//   from the Globe hue/saturation/brightness, like atmosphereBrightnessShift\\n\\\n// - The applyFog depends on enableFog, and some tile distance from the viewer\\n\\\n// - The showGroundAtmosphere is a flag that is passed through from the Globe,\\n\\\n//   and is true by default when the ellipsoid is WGS84\\n\\\n#ifdef COLOR_CORRECT\\n\\\nuniform vec3 u_hsbShift; // Hue, saturation, brightness\\n\\\n#endif\\n\\\n\\n\\\n// Based on highlightFillTile\\n\\\n// This is set for terrain tiles when they are \\\"fill\\\" tiles, and\\n\\\n// the terrainProvider.fillHighlightColor was set to a value with\\n\\\n// nonzero alpha\\n\\\n#ifdef HIGHLIGHT_FILL_TILE\\n\\\nuniform vec4 u_fillHighlightColor;\\n\\\n#endif\\n\\\n\\n\\\n// Based on translucent\\n\\\n// This is set depending on the GlobeTranslucencyState\\n\\\n#ifdef TRANSLUCENT\\n\\\nuniform vec4 u_frontFaceAlphaByDistance;\\n\\\nuniform vec4 u_backFaceAlphaByDistance;\\n\\\nuniform vec4 u_translucencyRectangle;\\n\\\n#endif\\n\\\n\\n\\\n// Based on showUndergroundColor\\n\\\n// This is set when GlobeSurfaceTileProvider.isUndergroundVisible \\n\\\n// returns true, AND the tileProvider.undergroundColor had a value with \\n\\\n// nonzero alpha, and the tileProvider.undergroundColorAlphaByDistance\\n\\\n// was in the right range\\n\\\n#ifdef UNDERGROUND_COLOR\\n\\\nuniform vec4 u_undergroundColor;\\n\\\nuniform vec4 u_undergroundColorAlphaByDistance;\\n\\\n#endif\\n\\\n\\n\\\n// Based on enableLighting && hasVertexNormals\\n\\\n// The enableLighting flag is passed in directly from the Globe.\\n\\\n// The hasVertexNormals flag is from the tileProvider\\n\\\n#ifdef ENABLE_VERTEX_LIGHTING\\n\\\nuniform float u_lambertDiffuseMultiplier;\\n\\\nuniform float u_vertexShadowDarkness;\\n\\\n#endif\\n\\\n\\n\\\nin vec3 v_positionMC;\\n\\\nin vec3 v_positionEC;\\n\\\nin vec3 v_textureCoordinates;\\n\\\nin vec3 v_normalMC;\\n\\\nin vec3 v_normalEC;\\n\\\n\\n\\\n#ifdef APPLY_MATERIAL\\n\\\nin float v_height;\\n\\\nin float v_slope;\\n\\\nin float v_aspect;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(FOG) || defined(GROUND_ATMOSPHERE) || defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)\\n\\\nin float v_distance;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(GROUND_ATMOSPHERE) || defined(FOG)\\n\\\nin vec3 v_atmosphereRayleighColor;\\n\\\nin vec3 v_atmosphereMieColor;\\n\\\nin float v_atmosphereOpacity;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)\\n\\\nfloat interpolateByDistance(vec4 nearFarScalar, float distance)\\n\\\n{\\n\\\n    float startDistance = nearFarScalar.x;\\n\\\n    float startValue = nearFarScalar.y;\\n\\\n    float endDistance = nearFarScalar.z;\\n\\\n    float endValue = nearFarScalar.w;\\n\\\n    float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0);\\n\\\n    return mix(startValue, endValue, t);\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#if defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT) || defined(APPLY_MATERIAL)\\n\\\nvec4 alphaBlend(vec4 sourceColor, vec4 destinationColor)\\n\\\n{\\n\\\n    return sourceColor * vec4(sourceColor.aaa, 1.0) + destinationColor * (1.0 - sourceColor.a);\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#ifdef TRANSLUCENT\\n\\\nbool inTranslucencyRectangle()\\n\\\n{\\n\\\n    return\\n\\\n        v_textureCoordinates.x > u_translucencyRectangle.x &&\\n\\\n        v_textureCoordinates.x < u_translucencyRectangle.z &&\\n\\\n        v_textureCoordinates.y > u_translucencyRectangle.y &&\\n\\\n        v_textureCoordinates.y < u_translucencyRectangle.w;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\nvec4 sampleAndBlend(\\n\\\n    vec4 previousColor,\\n\\\n    sampler2D textureToSample,\\n\\\n    vec2 tileTextureCoordinates,\\n\\\n    vec4 textureCoordinateRectangle,\\n\\\n    vec4 textureCoordinateTranslationAndScale,\\n\\\n    float textureAlpha,\\n\\\n    float textureNightAlpha,\\n\\\n    float textureDayAlpha,\\n\\\n    float textureBrightness,\\n\\\n    float textureContrast,\\n\\\n    float textureHue,\\n\\\n    float textureSaturation,\\n\\\n    float textureOneOverGamma,\\n\\\n    float split,\\n\\\n    vec4 colorToAlpha,\\n\\\n    float nightBlend)\\n\\\n{\\n\\\n    // This crazy step stuff sets the alpha to 0.0 if this following condition is true:\\n\\\n    //    tileTextureCoordinates.s < textureCoordinateRectangle.s ||\\n\\\n    //    tileTextureCoordinates.s > textureCoordinateRectangle.p ||\\n\\\n    //    tileTextureCoordinates.t < textureCoordinateRectangle.t ||\\n\\\n    //    tileTextureCoordinates.t > textureCoordinateRectangle.q\\n\\\n    // In other words, the alpha is zero if the fragment is outside the rectangle\\n\\\n    // covered by this texture.  Would an actual 'if' yield better performance?\\n\\\n    vec2 alphaMultiplier = step(textureCoordinateRectangle.st, tileTextureCoordinates);\\n\\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\n\\\n\\n\\\n    alphaMultiplier = step(vec2(0.0), textureCoordinateRectangle.pq - tileTextureCoordinates);\\n\\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\n\\\n\\n\\\n#if defined(APPLY_DAY_NIGHT_ALPHA) && defined(ENABLE_DAYNIGHT_SHADING)\\n\\\n    textureAlpha *= mix(textureDayAlpha, textureNightAlpha, nightBlend);\\n\\\n#endif\\n\\\n\\n\\\n    vec2 translation = textureCoordinateTranslationAndScale.xy;\\n\\\n    vec2 scale = textureCoordinateTranslationAndScale.zw;\\n\\\n    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\\n\\\n    vec4 value = texture(textureToSample, textureCoordinates);\\n\\\n    vec3 color = value.rgb;\\n\\\n    float alpha = value.a;\\n\\\n\\n\\\n#ifdef APPLY_COLOR_TO_ALPHA\\n\\\n    vec3 colorDiff = abs(color.rgb - colorToAlpha.rgb);\\n\\\n    colorDiff.r = czm_maximumComponent(colorDiff);\\n\\\n    alpha = czm_branchFreeTernary(colorDiff.r < colorToAlpha.a, 0.0, alpha);\\n\\\n#endif\\n\\\n\\n\\\n#if !defined(APPLY_GAMMA)\\n\\\n    vec4 tempColor = czm_gammaCorrect(vec4(color, alpha));\\n\\\n    color = tempColor.rgb;\\n\\\n    alpha = tempColor.a;\\n\\\n#else\\n\\\n    color = pow(color, vec3(textureOneOverGamma));\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_SPLIT\\n\\\n    float splitPosition = czm_splitPosition;\\n\\\n    // Split to the left\\n\\\n    if (split < 0.0 && gl_FragCoord.x > splitPosition) {\\n\\\n       alpha = 0.0;\\n\\\n    }\\n\\\n    // Split to the right\\n\\\n    else if (split > 0.0 && gl_FragCoord.x < splitPosition) {\\n\\\n       alpha = 0.0;\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_BRIGHTNESS\\n\\\n    color = mix(vec3(0.0), color, textureBrightness);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_CONTRAST\\n\\\n    color = mix(vec3(0.5), color, textureContrast);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_HUE\\n\\\n    color = czm_hue(color, textureHue);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_SATURATION\\n\\\n    color = czm_saturation(color, textureSaturation);\\n\\\n#endif\\n\\\n\\n\\\n    float sourceAlpha = alpha * textureAlpha;\\n\\\n    float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\\n\\\n    outAlpha += sign(outAlpha) - 1.0;\\n\\\n\\n\\\n    vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\\n\\\n\\n\\\n    // When rendering imagery for a tile in multiple passes,\\n\\\n    // some GPU/WebGL implementation combinations will not blend fragments in\\n\\\n    // additional passes correctly if their computation includes an unmasked\\n\\\n    // divide-by-zero operation,\\n\\\n    // even if it's not in the output or if the output has alpha zero.\\n\\\n    //\\n\\\n    // For example, without sanitization for outAlpha,\\n\\\n    // this renders without artifacts:\\n\\\n    //   if (outAlpha == 0.0) { outColor = vec3(0.0); }\\n\\\n    //\\n\\\n    // but using czm_branchFreeTernary will cause portions of the tile that are\\n\\\n    // alpha-zero in the additional pass to render as black instead of blending\\n\\\n    // with the previous pass:\\n\\\n    //   outColor = czm_branchFreeTernary(outAlpha == 0.0, vec3(0.0), outColor);\\n\\\n    //\\n\\\n    // So instead, sanitize against divide-by-zero,\\n\\\n    // store this state on the sign of outAlpha, and correct on return.\\n\\\n\\n\\\n    return vec4(outColor, max(outAlpha, 0.0));\\n\\\n}\\n\\\n\\n\\\nvec4 computeDayColor(vec4 initialColor, vec3 textureCoordinates, float nightBlend);\\n\\\nvec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec4 imageryColor, float specularMapValue, float fade);\\n\\\n\\n\\\nconst float fExposure = 2.0;\\n\\\n\\n\\\nvec3 computeEllipsoidPosition()\\n\\\n{\\n\\\n    float mpp = czm_metersPerPixel(vec4(0.0, 0.0, -czm_currentFrustum.x, 1.0), 1.0);\\n\\\n    vec2 xy = gl_FragCoord.xy / czm_viewport.zw * 2.0 - vec2(1.0);\\n\\\n    xy *= czm_viewport.zw * mpp * 0.5;\\n\\\n\\n\\\n    vec3 direction;\\n\\\n    if (czm_orthographicIn3D == 1.0)\\n\\\n    {\\n\\\n        direction = vec3(0.0, 0.0, -1.0);\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        direction = normalize(vec3(xy, -czm_currentFrustum.x));\\n\\\n    }\\n\\\n\\n\\\n    czm_ray ray = czm_ray(vec3(0.0), direction);\\n\\\n\\n\\\n    vec3 ellipsoid_center = czm_view[3].xyz;\\n\\\n\\n\\\n    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid_center, czm_ellipsoidInverseRadii);\\n\\\n\\n\\\n    vec3 ellipsoidPosition = czm_pointAlongRay(ray, intersection.start);\\n\\\n    return (czm_inverseView * vec4(ellipsoidPosition, 1.0)).xyz;\\n\\\n}\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n#ifdef TILE_LIMIT_RECTANGLE\\n\\\n    if (v_textureCoordinates.x < u_cartographicLimitRectangle.x || u_cartographicLimitRectangle.z < v_textureCoordinates.x ||\\n\\\n        v_textureCoordinates.y < u_cartographicLimitRectangle.y || u_cartographicLimitRectangle.w < v_textureCoordinates.y)\\n\\\n        {\\n\\\n            discard;\\n\\\n        }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_CLIPPING_PLANES\\n\\\n    float clipDistance = clip(gl_FragCoord, u_clippingPlanes, u_clippingPlanesMatrix);\\n\\\n#endif\\n\\\n\\n\\\n#if defined(SHOW_REFLECTIVE_OCEAN) || defined(ENABLE_DAYNIGHT_SHADING) || defined(HDR)\\n\\\n    vec3 normalMC = czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0));   // normalized surface normal in model coordinates\\n\\\n    vec3 normalEC = czm_normal3D * normalMC;                                         // normalized surface normal in eye coordinates\\n\\\n#endif\\n\\\n\\n\\\n#if defined(APPLY_DAY_NIGHT_ALPHA) && defined(ENABLE_DAYNIGHT_SHADING)\\n\\\n    float nightBlend = 1.0 - clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * 5.0, 0.0, 1.0);\\n\\\n#else\\n\\\n    float nightBlend = 0.0;\\n\\\n#endif\\n\\\n\\n\\\n    // The clamp below works around an apparent bug in Chrome Canary v23.0.1241.0\\n\\\n    // where the fragment shader sees textures coordinates < 0.0 and > 1.0 for the\\n\\\n    // fragments on the edges of tiles even though the vertex shader is outputting\\n\\\n    // coordinates strictly in the 0-1 range.\\n\\\n    vec4 color = computeDayColor(u_initialColor, clamp(v_textureCoordinates, 0.0, 1.0), nightBlend);\\n\\\n\\n\\\n#ifdef SHOW_TILE_BOUNDARIES\\n\\\n    if (v_textureCoordinates.x < (1.0/256.0) || v_textureCoordinates.x > (255.0/256.0) ||\\n\\\n        v_textureCoordinates.y < (1.0/256.0) || v_textureCoordinates.y > (255.0/256.0))\\n\\\n    {\\n\\\n        color = vec4(1.0, 0.0, 0.0, 1.0);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#if defined(ENABLE_DAYNIGHT_SHADING) || defined(GROUND_ATMOSPHERE)\\n\\\n    float cameraDist;\\n\\\n    if (czm_sceneMode == czm_sceneMode2D)\\n\\\n    {\\n\\\n        cameraDist = max(czm_frustumPlanes.x - czm_frustumPlanes.y, czm_frustumPlanes.w - czm_frustumPlanes.z) * 0.5;\\n\\\n    }\\n\\\n    else if (czm_sceneMode == czm_sceneModeColumbusView)\\n\\\n    {\\n\\\n        cameraDist = -czm_view[3].z;\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        cameraDist = length(czm_view[3]);\\n\\\n    }\\n\\\n    float fadeOutDist = u_lightingFadeDistance.x;\\n\\\n    float fadeInDist = u_lightingFadeDistance.y;\\n\\\n    if (czm_sceneMode != czm_sceneMode3D) {\\n\\\n        vec3 radii = czm_ellipsoidRadii;\\n\\\n        float maxRadii = max(radii.x, max(radii.y, radii.z));\\n\\\n        fadeOutDist -= maxRadii;\\n\\\n        fadeInDist -= maxRadii;\\n\\\n    }\\n\\\n    float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\\n\\\n#else\\n\\\n    float fade = 0.0;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(HAS_WATER_MASK) && (defined(SHOW_REFLECTIVE_OCEAN) || defined(APPLY_MATERIAL))\\n\\\n    vec2 waterMaskTranslation = u_waterMaskTranslationAndScale.xy;\\n\\\n    vec2 waterMaskScale = u_waterMaskTranslationAndScale.zw;\\n\\\n    vec2 waterMaskTextureCoordinates = v_textureCoordinates.xy * waterMaskScale + waterMaskTranslation;\\n\\\n    waterMaskTextureCoordinates.y = 1.0 - waterMaskTextureCoordinates.y;\\n\\\n\\n\\\n    float mask = texture(u_waterMask, waterMaskTextureCoordinates).r;\\n\\\n\\n\\\n    #ifdef SHOW_REFLECTIVE_OCEAN\\n\\\n    if (mask > 0.0)\\n\\\n    {\\n\\\n        mat3 enuToEye = czm_eastNorthUpToEyeCoordinates(v_positionMC, normalEC);\\n\\\n\\n\\\n        vec2 ellipsoidTextureCoordinates = czm_ellipsoidTextureCoordinates(normalMC);\\n\\\n        vec2 ellipsoidFlippedTextureCoordinates = czm_ellipsoidTextureCoordinates(normalMC.zyx);\\n\\\n\\n\\\n        vec2 textureCoordinates = mix(ellipsoidTextureCoordinates, ellipsoidFlippedTextureCoordinates, czm_morphTime * smoothstep(0.9, 0.95, normalMC.z));\\n\\\n\\n\\\n        color = computeWaterColor(v_positionEC, textureCoordinates, enuToEye, color, mask, fade);\\n\\\n    }\\n\\\n    #endif\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_MATERIAL\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.st = v_textureCoordinates.st;\\n\\\n    materialInput.normalEC = normalize(v_normalEC);\\n\\\n    materialInput.positionToEyeEC = -v_positionEC;\\n\\\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, normalize(v_normalEC));\\n\\\n    materialInput.slope = v_slope;\\n\\\n    materialInput.height = v_height;\\n\\\n    materialInput.aspect = v_aspect;\\n\\\n    #ifdef HAS_WATER_MASK\\n\\\n        materialInput.waterMask = mask;\\n\\\n    #endif\\n\\\n\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n    vec4 materialColor = vec4(material.diffuse, material.alpha);\\n\\\n    color = alphaBlend(materialColor, color);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_VERTEX_LIGHTING\\n\\\n    float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalize(v_normalEC)) * u_lambertDiffuseMultiplier + u_vertexShadowDarkness, 0.0, 1.0);\\n\\\n    vec4 finalColor = vec4(color.rgb * czm_lightColor * diffuseIntensity, color.a);\\n\\\n#elif defined(ENABLE_DAYNIGHT_SHADING)\\n\\\n    float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);\\n\\\n    diffuseIntensity = mix(1.0, diffuseIntensity, fade);\\n\\\n    vec4 finalColor = vec4(color.rgb * czm_lightColor * diffuseIntensity, color.a);\\n\\\n#else\\n\\\n    vec4 finalColor = color;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_CLIPPING_PLANES\\n\\\n    vec4 clippingPlanesEdgeColor = vec4(1.0);\\n\\\n    clippingPlanesEdgeColor.rgb = u_clippingPlanesEdgeStyle.rgb;\\n\\\n    float clippingPlanesEdgeWidth = u_clippingPlanesEdgeStyle.a;\\n\\\n\\n\\\n    if (clipDistance < clippingPlanesEdgeWidth)\\n\\\n    {\\n\\\n        finalColor = clippingPlanesEdgeColor;\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_CLIPPING_POLYGONS\\n\\\n    vec2 clippingPosition = v_clippingPosition;\\n\\\n    int regionIndex = v_regionIndex;\\n\\\n    clipPolygons(u_clippingDistance, CLIPPING_POLYGON_REGIONS_LENGTH, clippingPosition, regionIndex);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef HIGHLIGHT_FILL_TILE\\n\\\n    finalColor = vec4(mix(finalColor.rgb, u_fillHighlightColor.rgb, u_fillHighlightColor.a), finalColor.a);\\n\\\n#endif\\n\\\n\\n\\\n#if defined(DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN)\\n\\\n    vec3 atmosphereLightDirection = czm_sunDirectionWC;\\n\\\n#else\\n\\\n    vec3 atmosphereLightDirection = czm_lightDirectionWC;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(GROUND_ATMOSPHERE) || defined(FOG)\\n\\\n    if (!czm_backFacing())\\n\\\n    {\\n\\\n        bool dynamicLighting = false;\\n\\\n        #if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_DAYNIGHT_SHADING) || defined(ENABLE_VERTEX_LIGHTING))\\n\\\n            dynamicLighting = true;\\n\\\n        #endif\\n\\\n\\n\\\n        vec3 rayleighColor;\\n\\\n        vec3 mieColor;\\n\\\n        float opacity;\\n\\\n\\n\\\n        vec3 positionWC;\\n\\\n        vec3 lightDirection;\\n\\\n\\n\\\n        // When the camera is far away (camera distance > nightFadeOutDistance), the scattering is computed in the fragment shader.\\n\\\n        // Otherwise, the scattering is computed in the vertex shader.\\n\\\n        #ifdef PER_FRAGMENT_GROUND_ATMOSPHERE\\n\\\n            positionWC = computeEllipsoidPosition();\\n\\\n            lightDirection = czm_branchFreeTernary(dynamicLighting, atmosphereLightDirection, normalize(positionWC));\\n\\\n            computeAtmosphereScattering(\\n\\\n                positionWC,\\n\\\n                lightDirection,\\n\\\n                rayleighColor,\\n\\\n                mieColor,\\n\\\n                opacity\\n\\\n            );\\n\\\n        #else\\n\\\n            positionWC = v_positionMC;\\n\\\n            lightDirection = czm_branchFreeTernary(dynamicLighting, atmosphereLightDirection, normalize(positionWC));\\n\\\n            rayleighColor = v_atmosphereRayleighColor;\\n\\\n            mieColor = v_atmosphereMieColor;\\n\\\n            opacity = v_atmosphereOpacity;\\n\\\n        #endif\\n\\\n\\n\\\n        #ifdef COLOR_CORRECT\\n\\\n            const bool ignoreBlackPixels = true;\\n\\\n            rayleighColor = czm_applyHSBShift(rayleighColor, u_hsbShift, ignoreBlackPixels);\\n\\\n            mieColor = czm_applyHSBShift(mieColor, u_hsbShift, ignoreBlackPixels);\\n\\\n        #endif\\n\\\n\\n\\\n        vec4 groundAtmosphereColor = computeAtmosphereColor(positionWC, lightDirection, rayleighColor, mieColor, opacity);\\n\\\n\\n\\\n        // Fog is applied to tiles selected for fog, close to the Earth.\\n\\\n        #ifdef FOG\\n\\\n            vec3 fogColor = groundAtmosphereColor.rgb;\\n\\\n\\n\\\n            // If there is lighting, apply that to the fog.\\n\\\n            #if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING))\\n\\\n                float darken = clamp(dot(normalize(czm_viewerPositionWC), atmosphereLightDirection), u_minimumBrightness, 1.0);\\n\\\n                fogColor *= darken;\\n\\\n            #endif\\n\\\n\\n\\\n            #ifndef HDR\\n\\\n                fogColor.rgb = czm_pbrNeutralTonemapping(fogColor.rgb);\\n\\\n                fogColor.rgb = czm_inverseGamma(fogColor.rgb);\\n\\\n            #endif\\n\\\n\\n\\\n            finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor.rgb, czm_fogVisualDensityScalar), finalColor.a);\\n\\\n\\n\\\n        #else\\n\\\n            // Apply ground atmosphere. This happens when the camera is far away from the earth.\\n\\\n\\n\\\n            // The transmittance is based on optical depth i.e. the length of segment of the ray inside the atmosphere.\\n\\\n            // This value is larger near the \\\"circumference\\\", as it is further away from the camera. We use it to\\n\\\n            // brighten up that area of the ground atmosphere.\\n\\\n            const float transmittanceModifier = 0.5;\\n\\\n            float transmittance = transmittanceModifier + clamp(1.0 - groundAtmosphereColor.a, 0.0, 1.0);\\n\\\n\\n\\\n            vec3 finalAtmosphereColor = finalColor.rgb + groundAtmosphereColor.rgb * transmittance;\\n\\\n\\n\\\n            #if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING))\\n\\\n                float fadeInDist = u_nightFadeDistance.x;\\n\\\n                float fadeOutDist = u_nightFadeDistance.y;\\n\\\n\\n\\\n                float sunlitAtmosphereIntensity = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.05, 1.0);\\n\\\n                float darken = clamp(dot(normalize(positionWC), atmosphereLightDirection), 0.0, 1.0);\\n\\\n                vec3 darkenendGroundAtmosphereColor = mix(groundAtmosphereColor.rgb, finalAtmosphereColor.rgb, darken);\\n\\\n\\n\\\n                finalAtmosphereColor = mix(darkenendGroundAtmosphereColor, finalAtmosphereColor, sunlitAtmosphereIntensity);\\n\\\n            #endif\\n\\\n\\n\\\n            #ifndef HDR\\n\\\n                finalAtmosphereColor.rgb = vec3(1.0) - exp(-fExposure * finalAtmosphereColor.rgb);\\n\\\n            #else\\n\\\n                finalAtmosphereColor.rgb = czm_saturation(finalAtmosphereColor.rgb, 1.6);\\n\\\n            #endif\\n\\\n\\n\\\n            finalColor.rgb = mix(finalColor.rgb, finalAtmosphereColor.rgb, fade);\\n\\\n        #endif\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef UNDERGROUND_COLOR\\n\\\n    if (czm_backFacing())\\n\\\n    {\\n\\\n        float distanceFromEllipsoid = max(czm_eyeHeight, 0.0);\\n\\\n        float distance = max(v_distance - distanceFromEllipsoid, 0.0);\\n\\\n        float blendAmount = interpolateByDistance(u_undergroundColorAlphaByDistance, distance);\\n\\\n        vec4 undergroundColor = vec4(u_undergroundColor.rgb, u_undergroundColor.a * blendAmount);\\n\\\n        finalColor = alphaBlend(undergroundColor, finalColor);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef TRANSLUCENT\\n\\\n    if (inTranslucencyRectangle())\\n\\\n    {\\n\\\n      vec4 alphaByDistance = gl_FrontFacing ? u_frontFaceAlphaByDistance : u_backFaceAlphaByDistance;\\n\\\n      finalColor.a *= interpolateByDistance(alphaByDistance, v_distance);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n    out_FragColor =  finalColor;\\n\\\n}\\n\\\n\\n\\\n\\n\\\n#ifdef SHOW_REFLECTIVE_OCEAN\\n\\\n\\n\\\nfloat waveFade(float edge0, float edge1, float x)\\n\\\n{\\n\\\n    float y = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n\\\n    return pow(1.0 - y, 5.0);\\n\\\n}\\n\\\n\\n\\\nfloat linearFade(float edge0, float edge1, float x)\\n\\\n{\\n\\\n    return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n\\\n}\\n\\\n\\n\\\n// Based on water rendering by Jonas Wagner:\\n\\\n// http://29a.ch/2012/7/19/webgl-terrain-rendering-water-fog\\n\\\n\\n\\\n// low altitude wave settings\\n\\\nconst float oceanFrequencyLowAltitude = 825000.0;\\n\\\nconst float oceanAnimationSpeedLowAltitude = 0.004;\\n\\\nconst float oceanOneOverAmplitudeLowAltitude = 1.0 / 2.0;\\n\\\nconst float oceanSpecularIntensity = 0.5;\\n\\\n\\n\\\n// high altitude wave settings\\n\\\nconst float oceanFrequencyHighAltitude = 125000.0;\\n\\\nconst float oceanAnimationSpeedHighAltitude = 0.008;\\n\\\nconst float oceanOneOverAmplitudeHighAltitude = 1.0 / 2.0;\\n\\\n\\n\\\nvec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec4 imageryColor, float maskValue, float fade)\\n\\\n{\\n\\\n    vec3 positionToEyeEC = -positionEyeCoordinates;\\n\\\n    float positionToEyeECLength = length(positionToEyeEC);\\n\\\n\\n\\\n    // The double normalize below works around a bug in Firefox on Android devices.\\n\\\n    vec3 normalizedPositionToEyeEC = normalize(normalize(positionToEyeEC));\\n\\\n\\n\\\n    // Fade out the waves as the camera moves far from the surface.\\n\\\n    float waveIntensity = waveFade(70000.0, 1000000.0, positionToEyeECLength);\\n\\\n\\n\\\n#ifdef SHOW_OCEAN_WAVES\\n\\\n    // high altitude waves\\n\\\n    float time = czm_frameNumber * oceanAnimationSpeedHighAltitude;\\n\\\n    vec4 noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequencyHighAltitude, time, 0.0);\\n\\\n    vec3 normalTangentSpaceHighAltitude = vec3(noise.xy, noise.z * oceanOneOverAmplitudeHighAltitude);\\n\\\n\\n\\\n    // low altitude waves\\n\\\n    time = czm_frameNumber * oceanAnimationSpeedLowAltitude;\\n\\\n    noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequencyLowAltitude, time, 0.0);\\n\\\n    vec3 normalTangentSpaceLowAltitude = vec3(noise.xy, noise.z * oceanOneOverAmplitudeLowAltitude);\\n\\\n\\n\\\n    // blend the 2 wave layers based on distance to surface\\n\\\n    float highAltitudeFade = linearFade(0.0, 60000.0, positionToEyeECLength);\\n\\\n    float lowAltitudeFade = 1.0 - linearFade(20000.0, 60000.0, positionToEyeECLength);\\n\\\n    vec3 normalTangentSpace =\\n\\\n        (highAltitudeFade * normalTangentSpaceHighAltitude) +\\n\\\n        (lowAltitudeFade * normalTangentSpaceLowAltitude);\\n\\\n    normalTangentSpace = normalize(normalTangentSpace);\\n\\\n\\n\\\n    // fade out the normal perturbation as we move farther from the water surface\\n\\\n    normalTangentSpace.xy *= waveIntensity;\\n\\\n    normalTangentSpace = normalize(normalTangentSpace);\\n\\\n#else\\n\\\n    vec3 normalTangentSpace = vec3(0.0, 0.0, 1.0);\\n\\\n#endif\\n\\\n\\n\\\n    vec3 normalEC = enuToEye * normalTangentSpace;\\n\\\n\\n\\\n    const vec3 waveHighlightColor = vec3(0.3, 0.45, 0.6);\\n\\\n\\n\\\n    // Use diffuse light to highlight the waves\\n\\\n    float diffuseIntensity = czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * maskValue;\\n\\\n    vec3 diffuseHighlight = waveHighlightColor * diffuseIntensity * (1.0 - fade);\\n\\\n\\n\\\n#ifdef SHOW_OCEAN_WAVES\\n\\\n    // Where diffuse light is low or non-existent, use wave highlights based solely on\\n\\\n    // the wave bumpiness and no particular light direction.\\n\\\n    float tsPerturbationRatio = normalTangentSpace.z;\\n\\\n    vec3 nonDiffuseHighlight = mix(waveHighlightColor * 5.0 * (1.0 - tsPerturbationRatio), vec3(0.0), diffuseIntensity);\\n\\\n#else\\n\\\n    vec3 nonDiffuseHighlight = vec3(0.0);\\n\\\n#endif\\n\\\n\\n\\\n    // Add specular highlights in 3D, and in all modes when zoomed in.\\n\\\n    float specularIntensity = czm_getSpecular(czm_lightDirectionEC, normalizedPositionToEyeEC, normalEC, 10.0);\\n\\\n    float surfaceReflectance = mix(0.0, mix(u_zoomedOutOceanSpecularIntensity, oceanSpecularIntensity, waveIntensity), maskValue);\\n\\\n    float specular = specularIntensity * surfaceReflectance;\\n\\\n\\n\\\n#ifdef HDR\\n\\\n    specular *= 1.4;\\n\\\n\\n\\\n    float e = 0.2;\\n\\\n    float d = 3.3;\\n\\\n    float c = 1.7;\\n\\\n\\n\\\n    vec3 color = imageryColor.rgb + (c * (vec3(e) + imageryColor.rgb * d) * (diffuseHighlight + nonDiffuseHighlight + specular));\\n\\\n#else\\n\\\n    vec3 color = imageryColor.rgb + diffuseHighlight + nonDiffuseHighlight + specular;\\n\\\n#endif\\n\\\n\\n\\\n    return vec4(color, imageryColor.a);\\n\\\n}\\n\\\n\\n\\\n#endif // #ifdef SHOW_REFLECTIVE_OCEAN\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}