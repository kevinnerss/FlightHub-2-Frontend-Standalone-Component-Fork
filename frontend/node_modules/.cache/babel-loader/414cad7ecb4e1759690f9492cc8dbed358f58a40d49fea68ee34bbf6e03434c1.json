{"ast":null,"code":"import defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport LightingStageFS from \"../../Shaders/Model/LightingStageFS.js\";\nimport LightingModel from \"./LightingModel.js\";\n\n/**\n * The lighting pipeline stage is responsible for taking a material and rendering\n * it with a lighting model such as physically based rendering (PBR) or unlit\n * shading\n *\n * @namespace LightingPipelineStage\n *\n * @private\n */\nconst LightingPipelineStage = {\n  name: \"LightingPipelineStage\" // Helps with debugging\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render\n * resources:\n * <ul>\n *   <li>modifies the shader to include the lighting stage</li>\n * </ul>\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n *\n * @private\n */\nLightingPipelineStage.process = function (renderResources, primitive) {\n  const {\n    model,\n    lightingOptions,\n    shaderBuilder\n  } = renderResources;\n  if (defined(model.lightColor)) {\n    shaderBuilder.addDefine(\"USE_CUSTOM_LIGHT_COLOR\", undefined, ShaderDestination.FRAGMENT);\n    shaderBuilder.addUniform(\"vec3\", \"model_lightColorHdr\", ShaderDestination.FRAGMENT);\n    const uniformMap = renderResources.uniformMap;\n    uniformMap.model_lightColorHdr = function () {\n      return model.lightColor;\n    };\n  }\n\n  // The lighting model is always set by the material. However, custom shaders\n  // can override this.\n  const {\n    lightingModel\n  } = lightingOptions;\n  if (lightingModel === LightingModel.PBR) {\n    shaderBuilder.addDefine(\"LIGHTING_PBR\", undefined, ShaderDestination.FRAGMENT);\n  } else {\n    shaderBuilder.addDefine(\"LIGHTING_UNLIT\", undefined, ShaderDestination.FRAGMENT);\n  }\n  shaderBuilder.addFragmentLines(LightingStageFS);\n};\nexport default LightingPipelineStage;","map":{"version":3,"names":["defined","ShaderDestination","LightingStageFS","LightingModel","LightingPipelineStage","name","process","renderResources","primitive","model","lightingOptions","shaderBuilder","lightColor","addDefine","undefined","FRAGMENT","addUniform","uniformMap","model_lightColorHdr","lightingModel","PBR","addFragmentLines"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Model/LightingPipelineStage.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport LightingStageFS from \"../../Shaders/Model/LightingStageFS.js\";\nimport LightingModel from \"./LightingModel.js\";\n\n/**\n * The lighting pipeline stage is responsible for taking a material and rendering\n * it with a lighting model such as physically based rendering (PBR) or unlit\n * shading\n *\n * @namespace LightingPipelineStage\n *\n * @private\n */\nconst LightingPipelineStage = {\n  name: \"LightingPipelineStage\", // Helps with debugging\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render\n * resources:\n * <ul>\n *   <li>modifies the shader to include the lighting stage</li>\n * </ul>\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n *\n * @private\n */\nLightingPipelineStage.process = function (renderResources, primitive) {\n  const { model, lightingOptions, shaderBuilder } = renderResources;\n\n  if (defined(model.lightColor)) {\n    shaderBuilder.addDefine(\n      \"USE_CUSTOM_LIGHT_COLOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n\n    shaderBuilder.addUniform(\n      \"vec3\",\n      \"model_lightColorHdr\",\n      ShaderDestination.FRAGMENT,\n    );\n\n    const uniformMap = renderResources.uniformMap;\n    uniformMap.model_lightColorHdr = function () {\n      return model.lightColor;\n    };\n  }\n\n  // The lighting model is always set by the material. However, custom shaders\n  // can override this.\n  const { lightingModel } = lightingOptions;\n\n  if (lightingModel === LightingModel.PBR) {\n    shaderBuilder.addDefine(\n      \"LIGHTING_PBR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  } else {\n    shaderBuilder.addDefine(\n      \"LIGHTING_UNLIT\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  shaderBuilder.addFragmentLines(LightingStageFS);\n};\n\nexport default LightingPipelineStage;\n"],"mappings":"AAAA,OAAOA,OAAO,MAAM,uBAAuB;AAC3C,OAAOC,iBAAiB,MAAM,qCAAqC;AACnE,OAAOC,eAAe,MAAM,wCAAwC;AACpE,OAAOC,aAAa,MAAM,oBAAoB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,qBAAqB,GAAG;EAC5BC,IAAI,EAAE,uBAAuB,CAAE;AACjC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAD,qBAAqB,CAACE,OAAO,GAAG,UAAUC,eAAe,EAAEC,SAAS,EAAE;EACpE,MAAM;IAAEC,KAAK;IAAEC,eAAe;IAAEC;EAAc,CAAC,GAAGJ,eAAe;EAEjE,IAAIP,OAAO,CAACS,KAAK,CAACG,UAAU,CAAC,EAAE;IAC7BD,aAAa,CAACE,SAAS,CACrB,wBAAwB,EACxBC,SAAS,EACTb,iBAAiB,CAACc,QACpB,CAAC;IAEDJ,aAAa,CAACK,UAAU,CACtB,MAAM,EACN,qBAAqB,EACrBf,iBAAiB,CAACc,QACpB,CAAC;IAED,MAAME,UAAU,GAAGV,eAAe,CAACU,UAAU;IAC7CA,UAAU,CAACC,mBAAmB,GAAG,YAAY;MAC3C,OAAOT,KAAK,CAACG,UAAU;IACzB,CAAC;EACH;;EAEA;EACA;EACA,MAAM;IAAEO;EAAc,CAAC,GAAGT,eAAe;EAEzC,IAAIS,aAAa,KAAKhB,aAAa,CAACiB,GAAG,EAAE;IACvCT,aAAa,CAACE,SAAS,CACrB,cAAc,EACdC,SAAS,EACTb,iBAAiB,CAACc,QACpB,CAAC;EACH,CAAC,MAAM;IACLJ,aAAa,CAACE,SAAS,CACrB,gBAAgB,EAChBC,SAAS,EACTb,iBAAiB,CAACc,QACpB,CAAC;EACH;EAEAJ,aAAa,CAACU,gBAAgB,CAACnB,eAAe,CAAC;AACjD,CAAC;AAED,eAAeE,qBAAqB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}