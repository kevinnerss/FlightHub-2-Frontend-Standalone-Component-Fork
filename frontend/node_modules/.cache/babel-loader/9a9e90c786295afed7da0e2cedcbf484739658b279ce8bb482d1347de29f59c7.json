{"ast":null,"code":"import Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 3D Cartesian point.\n * @alias Cartesian3\n * @constructor\n *\n * @param {number} [x=0.0] The X component.\n * @param {number} [y=0.0] The Y component.\n * @param {number} [z=0.0] The Z component.\n *\n * @see Cartesian2\n * @see Cartesian4\n * @see Packable\n */\nfunction Cartesian3(x, y, z) {\n  /**\n   * The X component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.x = x ?? 0.0;\n\n  /**\n   * The Y component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.y = y ?? 0.0;\n\n  /**\n   * The Z component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.z = z ?? 0.0;\n}\n\n/**\n * Converts the provided Spherical into Cartesian3 coordinates.\n *\n * @param {Spherical} spherical The Spherical to be converted to Cartesian3.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromSpherical = function (spherical, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"spherical\", spherical);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  const clock = spherical.clock;\n  const cone = spherical.cone;\n  const magnitude = spherical.magnitude ?? 1.0;\n  const radial = magnitude * Math.sin(cone);\n  result.x = radial * Math.cos(clock);\n  result.y = radial * Math.sin(clock);\n  result.z = magnitude * Math.cos(cone);\n  return result;\n};\n\n/**\n * Creates a Cartesian3 instance from x, y and z coordinates.\n *\n * @param {number} x The x coordinate.\n * @param {number} y The y coordinate.\n * @param {number} z The z coordinate.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromElements = function (x, y, z, result) {\n  if (!defined(result)) {\n    return new Cartesian3(x, y, z);\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian3 instance.\n *\n * @param {Cartesian3} cartesian The Cartesian to duplicate.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian3.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);\n  }\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  result.z = cartesian.z;\n  return result;\n};\n\n/**\n * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the\n * x, y, and z properties of the Cartesian4 and drops w.\n * @function\n *\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian3 instance from.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromCartesian4 = Cartesian3.clone;\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nCartesian3.packedLength = 3;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian3} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCartesian3.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex] = value.z;\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian3} [result] The object into which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.z = array[startingIndex];\n  return result;\n};\n\n/**\n * Flattens an array of Cartesian3s into an array of components.\n *\n * @param {Cartesian3[]} array The array of cartesians to pack.\n * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 3 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 3) elements.\n * @returns {number[]} The packed array.\n */\nCartesian3.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 3;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new DeveloperError(\"If result is a typed array, it must have exactly array.length * 3 elements\");\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n  for (let i = 0; i < length; ++i) {\n    Cartesian3.pack(array[i], result, i * 3);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into an array of Cartesian3s.\n *\n * @param {number[]} array The array of components to unpack.\n * @param {Cartesian3[]} [result] The array onto which to store the result.\n * @returns {Cartesian3[]} The unpacked array.\n */\nCartesian3.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 3);\n  if (array.length % 3 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 3.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n  for (let i = 0; i < length; i += 3) {\n    const index = i / 3;\n    result[index] = Cartesian3.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian3 from three consecutive elements in an array.\n * @function\n *\n * @param {number[]} array The array whose three consecutive elements correspond to the x, y, and z components, respectively.\n * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian3 with (1.0, 2.0, 3.0)\n * const v = [1.0, 2.0, 3.0];\n * const p = Cesium.Cartesian3.fromArray(v);\n *\n * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0];\n * const p2 = Cesium.Cartesian3.fromArray(v2, 2);\n */\nCartesian3.fromArray = Cartesian3.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The cartesian to use.\n * @returns {number} The value of the maximum component.\n */\nCartesian3.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y, cartesian.z);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The cartesian to use.\n * @returns {number} The value of the minimum component.\n */\nCartesian3.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y, cartesian.z);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian3} first A cartesian to compare.\n * @param {Cartesian3} second A cartesian to compare.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} A cartesian with the minimum components.\n */\nCartesian3.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n  result.z = Math.min(first.z, second.z);\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian3} first A cartesian to compare.\n * @param {Cartesian3} second A cartesian to compare.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} A cartesian with the maximum components.\n */\nCartesian3.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  result.z = Math.max(first.z, second.z);\n  return result;\n};\n\n/**\n * Constrain a value to lie between two values.\n *\n * @param {Cartesian3} cartesian The value to clamp.\n * @param {Cartesian3} min The minimum bound.\n * @param {Cartesian3} max The maximum bound.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} The clamped value such that min <= value <= max.\n */\nCartesian3.clamp = function (value, min, max, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.typeOf.object(\"min\", min);\n  Check.typeOf.object(\"max\", max);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = CesiumMath.clamp(value.x, min.x, max.x);\n  const y = CesiumMath.clamp(value.y, min.y, max.y);\n  const z = CesiumMath.clamp(value.z, min.z, max.z);\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian3} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {number} The squared magnitude.\n */\nCartesian3.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z;\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian3} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {number} The magnitude.\n */\nCartesian3.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));\n};\nconst distanceScratch = new Cartesian3();\n\n/**\n * Computes the distance between two points.\n *\n * @param {Cartesian3} left The first point to compute the distance from.\n * @param {Cartesian3} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * const d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(2.0, 0.0, 0.0));\n */\nCartesian3.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.subtract(left, right, distanceScratch);\n  return Cartesian3.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian3#distance}.\n *\n * @param {Cartesian3} left The first point to compute the distance from.\n * @param {Cartesian3} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * const d = Cesium.Cartesian3.distanceSquared(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(3.0, 0.0, 0.0));\n */\nCartesian3.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.subtract(left, right, distanceScratch);\n  return Cartesian3.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian to be normalized.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const magnitude = Cartesian3.magnitude(cartesian);\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n  result.z = cartesian.z / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z)) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @returns {number} The dot product.\n */\nCartesian3.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y + left.z * right.z;\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  result.z = left.z * right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  result.z = left.z / right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian3} cartesian The Cartesian to be scaled.\n * @param {number} scalar The scalar to multiply with.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  result.z = cartesian.z * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian3} cartesian The Cartesian to be divided.\n * @param {number} scalar The scalar to divide by.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  result.z = cartesian.z / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian to be negated.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  result.z = -cartesian.z;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  result.z = Math.abs(cartesian.z);\n  return result;\n};\nconst lerpScratch = new Cartesian3();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian3} start The value corresponding to t at 0.0.\n * @param {Cartesian3} end The value corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian3.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian3.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian3.add(lerpScratch, result, result);\n};\nconst angleBetweenScratch = new Cartesian3();\nconst angleBetweenScratch2 = new Cartesian3();\n/**\n * Returns the angle, in radians, between the provided Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @returns {number} The angle between the Cartesians.\n */\nCartesian3.angleBetween = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.normalize(left, angleBetweenScratch);\n  Cartesian3.normalize(right, angleBetweenScratch2);\n  const cosine = Cartesian3.dot(angleBetweenScratch, angleBetweenScratch2);\n  const sine = Cartesian3.magnitude(Cartesian3.cross(angleBetweenScratch, angleBetweenScratch2, angleBetweenScratch));\n  return Math.atan2(sine, cosine);\n};\nconst mostOrthogonalAxisScratch = new Cartesian3();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The most orthogonal axis.\n */\nCartesian3.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const f = Cartesian3.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian3.abs(f, f);\n  if (f.x <= f.y) {\n    if (f.x <= f.z) {\n      result = Cartesian3.clone(Cartesian3.UNIT_X, result);\n    } else {\n      result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\n    }\n  } else if (f.y <= f.z) {\n    result = Cartesian3.clone(Cartesian3.UNIT_Y, result);\n  } else {\n    result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\n  }\n  return result;\n};\n\n/**\n * Projects vector a onto vector b\n * @param {Cartesian3} a The vector that needs projecting\n * @param {Cartesian3} b The vector to project onto\n * @param {Cartesian3} result The result cartesian\n * @returns {Cartesian3} The modified result parameter\n */\nCartesian3.projectVector = function (a, b, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"a\", a);\n  Check.defined(\"b\", b);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scalar = Cartesian3.dot(a, b) / Cartesian3.dot(b, b);\n  return Cartesian3.multiplyByScalar(b, scalar, result);\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian3} [left] The first Cartesian.\n * @param {Cartesian3} [right] The second Cartesian.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian3.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && left.x === right.x && left.y === right.y && left.z === right.z;\n};\n\n/**\n * @private\n */\nCartesian3.equalsArray = function (cartesian, array, offset) {\n  return cartesian.x === array[offset] && cartesian.y === array[offset + 1] && cartesian.z === array[offset + 2];\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian3} [left] The first Cartesian.\n * @param {Cartesian3} [right] The second Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian3.equalsEpsilon = function (left, right, relativeEpsilon, absoluteEpsilon) {\n  return left === right || defined(left) && defined(right) && CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.z, right.z, relativeEpsilon, absoluteEpsilon);\n};\n\n/**\n * Computes the cross (outer) product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The cross product.\n */\nCartesian3.cross = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const leftX = left.x;\n  const leftY = left.y;\n  const leftZ = left.z;\n  const rightX = right.x;\n  const rightY = right.y;\n  const rightZ = right.z;\n  const x = leftY * rightZ - leftZ * rightY;\n  const y = leftZ * rightX - leftX * rightZ;\n  const z = leftX * rightY - leftY * rightX;\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the midpoint between the right and left Cartesian.\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The midpoint.\n */\nCartesian3.midpoint = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = (left.x + right.x) * 0.5;\n  result.y = (left.y + right.y) * 0.5;\n  result.z = (left.z + right.z) * 0.5;\n  return result;\n};\n\n/**\n * Returns a Cartesian3 position from longitude and latitude values given in degrees.\n *\n * @param {number} longitude The longitude, in degrees\n * @param {number} latitude The latitude, in degrees\n * @param {number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n *\n * @example\n * const position = Cesium.Cartesian3.fromDegrees(-115.0, 37.0);\n */\nCartesian3.fromDegrees = function (longitude, latitude, height, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n\n  longitude = CesiumMath.toRadians(longitude);\n  latitude = CesiumMath.toRadians(latitude);\n  return Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result);\n};\nlet scratchN = new Cartesian3();\nlet scratchK = new Cartesian3();\n\n// To prevent a circular dependency, this value is overridden by Ellipsoid when Ellipsoid.default is set\nCartesian3._ellipsoidRadiiSquared = new Cartesian3(6378137.0 * 6378137.0, 6378137.0 * 6378137.0, 6356752.3142451793 * 6356752.3142451793);\n\n/**\n * Returns a Cartesian3 position from longitude and latitude values given in radians.\n *\n * @param {number} longitude The longitude, in radians\n * @param {number} latitude The latitude, in radians\n * @param {number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n *\n * @example\n * const position = Cesium.Cartesian3.fromRadians(-2.007, 0.645);\n */\nCartesian3.fromRadians = function (longitude, latitude, height, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n\n  height = height ?? 0.0;\n  const radiiSquared = !defined(ellipsoid) ? Cartesian3._ellipsoidRadiiSquared : ellipsoid.radiiSquared;\n  const cosLatitude = Math.cos(latitude);\n  scratchN.x = cosLatitude * Math.cos(longitude);\n  scratchN.y = cosLatitude * Math.sin(longitude);\n  scratchN.z = Math.sin(latitude);\n  scratchN = Cartesian3.normalize(scratchN, scratchN);\n  Cartesian3.multiplyComponents(radiiSquared, scratchN, scratchK);\n  const gamma = Math.sqrt(Cartesian3.dot(scratchN, scratchK));\n  scratchK = Cartesian3.divideByScalar(scratchK, gamma, scratchK);\n  scratchN = Cartesian3.multiplyByScalar(scratchN, height, scratchN);\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  return Cartesian3.add(scratchK, scratchN, result);\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.\n *\n * @param {number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the coordinates lie.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);\n */\nCartesian3.fromDegreesArray = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\n    throw new DeveloperError(\"the number of coordinates must be a multiple of 2 and at least 2\");\n  }\n  //>>includeEnd('debug');\n\n  const length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n  for (let i = 0; i < length; i += 2) {\n    const longitude = coordinates[i];\n    const latitude = coordinates[i + 1];\n    const index = i / 2;\n    result[index] = Cartesian3.fromDegrees(longitude, latitude, 0, ellipsoid, result[index]);\n  }\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.\n *\n * @param {number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the coordinates lie.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);\n */\nCartesian3.fromRadiansArray = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\n    throw new DeveloperError(\"the number of coordinates must be a multiple of 2 and at least 2\");\n  }\n  //>>includeEnd('debug');\n\n  const length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n  for (let i = 0; i < length; i += 2) {\n    const longitude = coordinates[i];\n    const latitude = coordinates[i + 1];\n    const index = i / 2;\n    result[index] = Cartesian3.fromRadians(longitude, latitude, 0, ellipsoid, result[index]);\n  }\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.\n *\n * @param {number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);\n */\nCartesian3.fromDegreesArrayHeights = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\n    throw new DeveloperError(\"the number of coordinates must be a multiple of 3 and at least 3\");\n  }\n  //>>includeEnd('debug');\n\n  const length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n  for (let i = 0; i < length; i += 3) {\n    const longitude = coordinates[i];\n    const latitude = coordinates[i + 1];\n    const height = coordinates[i + 2];\n    const index = i / 3;\n    result[index] = Cartesian3.fromDegrees(longitude, latitude, height, ellipsoid, result[index]);\n  }\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.\n *\n * @param {number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);\n */\nCartesian3.fromRadiansArrayHeights = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\n    throw new DeveloperError(\"the number of coordinates must be a multiple of 3 and at least 3\");\n  }\n  //>>includeEnd('debug');\n\n  const length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n  for (let i = 0; i < length; i += 3) {\n    const longitude = coordinates[i];\n    const latitude = coordinates[i + 1];\n    const height = coordinates[i + 2];\n    const index = i / 3;\n    result[index] = Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result[index]);\n  }\n  return result;\n};\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.ZERO = Object.freeze(new Cartesian3(0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (1.0, 1.0, 1.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.ONE = Object.freeze(new Cartesian3(1.0, 1.0, 1.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_X = Object.freeze(new Cartesian3(1.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_Y = Object.freeze(new Cartesian3(0.0, 1.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_Z = Object.freeze(new Cartesian3(0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Cartesian3 instance.\n *\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.prototype.clone = function (result) {\n  return Cartesian3.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian3} [right] The right hand side Cartesian.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian3.prototype.equals = function (right) {\n  return Cartesian3.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian3} [right] The right hand side Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian3.prototype.equalsEpsilon = function (right, relativeEpsilon, absoluteEpsilon) {\n  return Cartesian3.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y, z)'.\n *\n * @returns {string} A string representing this Cartesian in the format '(x, y, z)'.\n */\nCartesian3.prototype.toString = function () {\n  return `(${this.x}, ${this.y}, ${this.z})`;\n};\nexport default Cartesian3;","map":{"version":3,"names":["Check","defined","DeveloperError","CesiumMath","Cartesian3","x","y","z","fromSpherical","spherical","result","typeOf","object","clock","cone","magnitude","radial","Math","sin","cos","fromElements","clone","cartesian","undefined","fromCartesian4","packedLength","pack","value","array","startingIndex","unpack","packArray","length","resultLength","Array","isArray","i","unpackArray","number","greaterThanOrEquals","index","fromArray","maximumComponent","max","minimumComponent","min","minimumByComponent","first","second","maximumByComponent","clamp","magnitudeSquared","sqrt","distanceScratch","distance","left","right","subtract","distanceSquared","normalize","isNaN","dot","multiplyComponents","divideComponents","add","multiplyByScalar","scalar","divideByScalar","negate","abs","lerpScratch","lerp","start","end","t","angleBetweenScratch","angleBetweenScratch2","angleBetween","cosine","sine","cross","atan2","mostOrthogonalAxisScratch","mostOrthogonalAxis","f","UNIT_X","UNIT_Z","UNIT_Y","projectVector","a","b","equals","equalsArray","offset","equalsEpsilon","relativeEpsilon","absoluteEpsilon","leftX","leftY","leftZ","rightX","rightY","rightZ","midpoint","fromDegrees","longitude","latitude","height","ellipsoid","toRadians","fromRadians","scratchN","scratchK","_ellipsoidRadiiSquared","radiiSquared","cosLatitude","gamma","fromDegreesArray","coordinates","fromRadiansArray","fromDegreesArrayHeights","fromRadiansArrayHeights","ZERO","Object","freeze","ONE","prototype","toString"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/Cartesian3.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 3D Cartesian point.\n * @alias Cartesian3\n * @constructor\n *\n * @param {number} [x=0.0] The X component.\n * @param {number} [y=0.0] The Y component.\n * @param {number} [z=0.0] The Z component.\n *\n * @see Cartesian2\n * @see Cartesian4\n * @see Packable\n */\nfunction Cartesian3(x, y, z) {\n  /**\n   * The X component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.x = x ?? 0.0;\n\n  /**\n   * The Y component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.y = y ?? 0.0;\n\n  /**\n   * The Z component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.z = z ?? 0.0;\n}\n\n/**\n * Converts the provided Spherical into Cartesian3 coordinates.\n *\n * @param {Spherical} spherical The Spherical to be converted to Cartesian3.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromSpherical = function (spherical, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"spherical\", spherical);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  const clock = spherical.clock;\n  const cone = spherical.cone;\n  const magnitude = spherical.magnitude ?? 1.0;\n  const radial = magnitude * Math.sin(cone);\n  result.x = radial * Math.cos(clock);\n  result.y = radial * Math.sin(clock);\n  result.z = magnitude * Math.cos(cone);\n  return result;\n};\n\n/**\n * Creates a Cartesian3 instance from x, y and z coordinates.\n *\n * @param {number} x The x coordinate.\n * @param {number} y The y coordinate.\n * @param {number} z The z coordinate.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromElements = function (x, y, z, result) {\n  if (!defined(result)) {\n    return new Cartesian3(x, y, z);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian3 instance.\n *\n * @param {Cartesian3} cartesian The Cartesian to duplicate.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian3.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  result.z = cartesian.z;\n  return result;\n};\n\n/**\n * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the\n * x, y, and z properties of the Cartesian4 and drops w.\n * @function\n *\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian3 instance from.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromCartesian4 = Cartesian3.clone;\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nCartesian3.packedLength = 3;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian3} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCartesian3.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex] = value.z;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian3} [result] The object into which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.z = array[startingIndex];\n  return result;\n};\n\n/**\n * Flattens an array of Cartesian3s into an array of components.\n *\n * @param {Cartesian3[]} array The array of cartesians to pack.\n * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 3 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 3) elements.\n * @returns {number[]} The packed array.\n */\nCartesian3.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 3;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 3 elements\",\n    );\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    Cartesian3.pack(array[i], result, i * 3);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into an array of Cartesian3s.\n *\n * @param {number[]} array The array of components to unpack.\n * @param {Cartesian3[]} [result] The array onto which to store the result.\n * @returns {Cartesian3[]} The unpacked array.\n */\nCartesian3.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 3);\n  if (array.length % 3 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 3.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (let i = 0; i < length; i += 3) {\n    const index = i / 3;\n    result[index] = Cartesian3.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian3 from three consecutive elements in an array.\n * @function\n *\n * @param {number[]} array The array whose three consecutive elements correspond to the x, y, and z components, respectively.\n * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian3 with (1.0, 2.0, 3.0)\n * const v = [1.0, 2.0, 3.0];\n * const p = Cesium.Cartesian3.fromArray(v);\n *\n * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0];\n * const p2 = Cesium.Cartesian3.fromArray(v2, 2);\n */\nCartesian3.fromArray = Cartesian3.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The cartesian to use.\n * @returns {number} The value of the maximum component.\n */\nCartesian3.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y, cartesian.z);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The cartesian to use.\n * @returns {number} The value of the minimum component.\n */\nCartesian3.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y, cartesian.z);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian3} first A cartesian to compare.\n * @param {Cartesian3} second A cartesian to compare.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} A cartesian with the minimum components.\n */\nCartesian3.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n  result.z = Math.min(first.z, second.z);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian3} first A cartesian to compare.\n * @param {Cartesian3} second A cartesian to compare.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} A cartesian with the maximum components.\n */\nCartesian3.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  result.z = Math.max(first.z, second.z);\n  return result;\n};\n\n/**\n * Constrain a value to lie between two values.\n *\n * @param {Cartesian3} cartesian The value to clamp.\n * @param {Cartesian3} min The minimum bound.\n * @param {Cartesian3} max The maximum bound.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} The clamped value such that min <= value <= max.\n */\nCartesian3.clamp = function (value, min, max, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.typeOf.object(\"min\", min);\n  Check.typeOf.object(\"max\", max);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = CesiumMath.clamp(value.x, min.x, max.x);\n  const y = CesiumMath.clamp(value.y, min.y, max.y);\n  const z = CesiumMath.clamp(value.z, min.z, max.z);\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian3} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {number} The squared magnitude.\n */\nCartesian3.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return (\n    cartesian.x * cartesian.x +\n    cartesian.y * cartesian.y +\n    cartesian.z * cartesian.z\n  );\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian3} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {number} The magnitude.\n */\nCartesian3.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));\n};\n\nconst distanceScratch = new Cartesian3();\n\n/**\n * Computes the distance between two points.\n *\n * @param {Cartesian3} left The first point to compute the distance from.\n * @param {Cartesian3} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * const d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(2.0, 0.0, 0.0));\n */\nCartesian3.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.subtract(left, right, distanceScratch);\n  return Cartesian3.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian3#distance}.\n *\n * @param {Cartesian3} left The first point to compute the distance from.\n * @param {Cartesian3} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * const d = Cesium.Cartesian3.distanceSquared(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(3.0, 0.0, 0.0));\n */\nCartesian3.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.subtract(left, right, distanceScratch);\n  return Cartesian3.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian to be normalized.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const magnitude = Cartesian3.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n  result.z = cartesian.z / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z)) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @returns {number} The dot product.\n */\nCartesian3.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y + left.z * right.z;\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  result.z = left.z * right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  result.z = left.z / right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian3} cartesian The Cartesian to be scaled.\n * @param {number} scalar The scalar to multiply with.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  result.z = cartesian.z * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian3} cartesian The Cartesian to be divided.\n * @param {number} scalar The scalar to divide by.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  result.z = cartesian.z / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian to be negated.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  result.z = -cartesian.z;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  result.z = Math.abs(cartesian.z);\n  return result;\n};\n\nconst lerpScratch = new Cartesian3();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian3} start The value corresponding to t at 0.0.\n * @param {Cartesian3} end The value corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian3.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian3.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian3.add(lerpScratch, result, result);\n};\n\nconst angleBetweenScratch = new Cartesian3();\nconst angleBetweenScratch2 = new Cartesian3();\n/**\n * Returns the angle, in radians, between the provided Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @returns {number} The angle between the Cartesians.\n */\nCartesian3.angleBetween = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian3.normalize(left, angleBetweenScratch);\n  Cartesian3.normalize(right, angleBetweenScratch2);\n  const cosine = Cartesian3.dot(angleBetweenScratch, angleBetweenScratch2);\n  const sine = Cartesian3.magnitude(\n    Cartesian3.cross(\n      angleBetweenScratch,\n      angleBetweenScratch2,\n      angleBetweenScratch,\n    ),\n  );\n  return Math.atan2(sine, cosine);\n};\n\nconst mostOrthogonalAxisScratch = new Cartesian3();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The most orthogonal axis.\n */\nCartesian3.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const f = Cartesian3.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian3.abs(f, f);\n\n  if (f.x <= f.y) {\n    if (f.x <= f.z) {\n      result = Cartesian3.clone(Cartesian3.UNIT_X, result);\n    } else {\n      result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\n    }\n  } else if (f.y <= f.z) {\n    result = Cartesian3.clone(Cartesian3.UNIT_Y, result);\n  } else {\n    result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\n  }\n\n  return result;\n};\n\n/**\n * Projects vector a onto vector b\n * @param {Cartesian3} a The vector that needs projecting\n * @param {Cartesian3} b The vector to project onto\n * @param {Cartesian3} result The result cartesian\n * @returns {Cartesian3} The modified result parameter\n */\nCartesian3.projectVector = function (a, b, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"a\", a);\n  Check.defined(\"b\", b);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scalar = Cartesian3.dot(a, b) / Cartesian3.dot(b, b);\n  return Cartesian3.multiplyByScalar(b, scalar, result);\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian3} [left] The first Cartesian.\n * @param {Cartesian3} [right] The second Cartesian.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian3.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.z === right.z)\n  );\n};\n\n/**\n * @private\n */\nCartesian3.equalsArray = function (cartesian, array, offset) {\n  return (\n    cartesian.x === array[offset] &&\n    cartesian.y === array[offset + 1] &&\n    cartesian.z === array[offset + 2]\n  );\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian3} [left] The first Cartesian.\n * @param {Cartesian3} [right] The second Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian3.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      CesiumMath.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.z,\n        right.z,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ))\n  );\n};\n\n/**\n * Computes the cross (outer) product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The cross product.\n */\nCartesian3.cross = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const leftX = left.x;\n  const leftY = left.y;\n  const leftZ = left.z;\n  const rightX = right.x;\n  const rightY = right.y;\n  const rightZ = right.z;\n\n  const x = leftY * rightZ - leftZ * rightY;\n  const y = leftZ * rightX - leftX * rightZ;\n  const z = leftX * rightY - leftY * rightX;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the midpoint between the right and left Cartesian.\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The midpoint.\n */\nCartesian3.midpoint = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = (left.x + right.x) * 0.5;\n  result.y = (left.y + right.y) * 0.5;\n  result.z = (left.z + right.z) * 0.5;\n\n  return result;\n};\n\n/**\n * Returns a Cartesian3 position from longitude and latitude values given in degrees.\n *\n * @param {number} longitude The longitude, in degrees\n * @param {number} latitude The latitude, in degrees\n * @param {number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n *\n * @example\n * const position = Cesium.Cartesian3.fromDegrees(-115.0, 37.0);\n */\nCartesian3.fromDegrees = function (\n  longitude,\n  latitude,\n  height,\n  ellipsoid,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n\n  longitude = CesiumMath.toRadians(longitude);\n  latitude = CesiumMath.toRadians(latitude);\n  return Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result);\n};\n\nlet scratchN = new Cartesian3();\nlet scratchK = new Cartesian3();\n\n// To prevent a circular dependency, this value is overridden by Ellipsoid when Ellipsoid.default is set\nCartesian3._ellipsoidRadiiSquared = new Cartesian3(\n  6378137.0 * 6378137.0,\n  6378137.0 * 6378137.0,\n  6356752.3142451793 * 6356752.3142451793,\n);\n\n/**\n * Returns a Cartesian3 position from longitude and latitude values given in radians.\n *\n * @param {number} longitude The longitude, in radians\n * @param {number} latitude The latitude, in radians\n * @param {number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n *\n * @example\n * const position = Cesium.Cartesian3.fromRadians(-2.007, 0.645);\n */\nCartesian3.fromRadians = function (\n  longitude,\n  latitude,\n  height,\n  ellipsoid,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"longitude\", longitude);\n  Check.typeOf.number(\"latitude\", latitude);\n  //>>includeEnd('debug');\n\n  height = height ?? 0.0;\n\n  const radiiSquared = !defined(ellipsoid)\n    ? Cartesian3._ellipsoidRadiiSquared\n    : ellipsoid.radiiSquared;\n\n  const cosLatitude = Math.cos(latitude);\n  scratchN.x = cosLatitude * Math.cos(longitude);\n  scratchN.y = cosLatitude * Math.sin(longitude);\n  scratchN.z = Math.sin(latitude);\n  scratchN = Cartesian3.normalize(scratchN, scratchN);\n\n  Cartesian3.multiplyComponents(radiiSquared, scratchN, scratchK);\n  const gamma = Math.sqrt(Cartesian3.dot(scratchN, scratchK));\n  scratchK = Cartesian3.divideByScalar(scratchK, gamma, scratchK);\n  scratchN = Cartesian3.multiplyByScalar(scratchN, height, scratchN);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  return Cartesian3.add(scratchK, scratchN, result);\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.\n *\n * @param {number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the coordinates lie.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);\n */\nCartesian3.fromDegreesArray = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 2 and at least 2\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (let i = 0; i < length; i += 2) {\n    const longitude = coordinates[i];\n    const latitude = coordinates[i + 1];\n    const index = i / 2;\n    result[index] = Cartesian3.fromDegrees(\n      longitude,\n      latitude,\n      0,\n      ellipsoid,\n      result[index],\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.\n *\n * @param {number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the coordinates lie.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);\n */\nCartesian3.fromRadiansArray = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 2 and at least 2\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (let i = 0; i < length; i += 2) {\n    const longitude = coordinates[i];\n    const latitude = coordinates[i + 1];\n    const index = i / 2;\n    result[index] = Cartesian3.fromRadians(\n      longitude,\n      latitude,\n      0,\n      ellipsoid,\n      result[index],\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.\n *\n * @param {number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);\n */\nCartesian3.fromDegreesArrayHeights = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 3 and at least 3\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (let i = 0; i < length; i += 3) {\n    const longitude = coordinates[i];\n    const latitude = coordinates[i + 1];\n    const height = coordinates[i + 2];\n    const index = i / 3;\n    result[index] = Cartesian3.fromDegrees(\n      longitude,\n      latitude,\n      height,\n      ellipsoid,\n      result[index],\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.\n *\n * @param {number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the position lies.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);\n */\nCartesian3.fromRadiansArrayHeights = function (coordinates, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"coordinates\", coordinates);\n  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\n    throw new DeveloperError(\n      \"the number of coordinates must be a multiple of 3 and at least 3\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const length = coordinates.length;\n  if (!defined(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (let i = 0; i < length; i += 3) {\n    const longitude = coordinates[i];\n    const latitude = coordinates[i + 1];\n    const height = coordinates[i + 2];\n    const index = i / 3;\n    result[index] = Cartesian3.fromRadians(\n      longitude,\n      latitude,\n      height,\n      ellipsoid,\n      result[index],\n    );\n  }\n\n  return result;\n};\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.ZERO = Object.freeze(new Cartesian3(0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (1.0, 1.0, 1.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.ONE = Object.freeze(new Cartesian3(1.0, 1.0, 1.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_X = Object.freeze(new Cartesian3(1.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_Y = Object.freeze(new Cartesian3(0.0, 1.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_Z = Object.freeze(new Cartesian3(0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Cartesian3 instance.\n *\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.prototype.clone = function (result) {\n  return Cartesian3.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian3} [right] The right hand side Cartesian.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian3.prototype.equals = function (right) {\n  return Cartesian3.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian3} [right] The right hand side Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian3.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  return Cartesian3.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon,\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y, z)'.\n *\n * @returns {string} A string representing this Cartesian in the format '(x, y, z)'.\n */\nCartesian3.prototype.toString = function () {\n  return `(${this.x}, ${this.y}, ${this.z})`;\n};\nexport default Cartesian3;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}