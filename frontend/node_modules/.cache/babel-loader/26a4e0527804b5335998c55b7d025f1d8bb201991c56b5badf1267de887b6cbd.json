{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingRectangle from \"./BoundingRectangle.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CornerType from \"./CornerType.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport oneTimeWarning from \"./oneTimeWarning.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PolylineVolumeGeometryLibrary from \"./PolylineVolumeGeometryLibrary.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nimport WindingOrder from \"./WindingOrder.js\";\nfunction computeAttributes(combinedPositions, shape, boundingRectangle, vertexFormat) {\n  const attributes = new GeometryAttributes();\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: combinedPositions\n    });\n  }\n  const shapeLength = shape.length;\n  const vertexCount = combinedPositions.length / 3;\n  const length = (vertexCount - shapeLength * 2) / (shapeLength * 2);\n  const firstEndIndices = PolygonPipeline.triangulate(shape);\n  const indicesCount = (length - 1) * shapeLength * 6 + firstEndIndices.length * 2;\n  const indices = IndexDatatype.createTypedArray(vertexCount, indicesCount);\n  let i, j;\n  let ll, ul, ur, lr;\n  const offset = shapeLength * 2;\n  let index = 0;\n  for (i = 0; i < length - 1; i++) {\n    for (j = 0; j < shapeLength - 1; j++) {\n      ll = j * 2 + i * shapeLength * 2;\n      lr = ll + offset;\n      ul = ll + 1;\n      ur = ul + offset;\n      indices[index++] = ul;\n      indices[index++] = ll;\n      indices[index++] = ur;\n      indices[index++] = ur;\n      indices[index++] = ll;\n      indices[index++] = lr;\n    }\n    ll = shapeLength * 2 - 2 + i * shapeLength * 2;\n    ul = ll + 1;\n    ur = ul + offset;\n    lr = ll + offset;\n    indices[index++] = ul;\n    indices[index++] = ll;\n    indices[index++] = ur;\n    indices[index++] = ur;\n    indices[index++] = ll;\n    indices[index++] = lr;\n  }\n  if (vertexFormat.st || vertexFormat.tangent || vertexFormat.bitangent) {\n    // st required for tangent/bitangent calculation\n    const st = new Float32Array(vertexCount * 2);\n    const lengthSt = 1 / (length - 1);\n    const heightSt = 1 / boundingRectangle.height;\n    const heightOffset = boundingRectangle.height / 2;\n    let s, t;\n    let stindex = 0;\n    for (i = 0; i < length; i++) {\n      s = i * lengthSt;\n      t = heightSt * (shape[0].y + heightOffset);\n      st[stindex++] = s;\n      st[stindex++] = t;\n      for (j = 1; j < shapeLength; j++) {\n        t = heightSt * (shape[j].y + heightOffset);\n        st[stindex++] = s;\n        st[stindex++] = t;\n        st[stindex++] = s;\n        st[stindex++] = t;\n      }\n      t = heightSt * (shape[0].y + heightOffset);\n      st[stindex++] = s;\n      st[stindex++] = t;\n    }\n    for (j = 0; j < shapeLength; j++) {\n      s = 0;\n      t = heightSt * (shape[j].y + heightOffset);\n      st[stindex++] = s;\n      st[stindex++] = t;\n    }\n    for (j = 0; j < shapeLength; j++) {\n      s = (length - 1) * lengthSt;\n      t = heightSt * (shape[j].y + heightOffset);\n      st[stindex++] = s;\n      st[stindex++] = t;\n    }\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: new Float32Array(st)\n    });\n  }\n  const endOffset = vertexCount - shapeLength * 2;\n  for (i = 0; i < firstEndIndices.length; i += 3) {\n    const v0 = firstEndIndices[i] + endOffset;\n    const v1 = firstEndIndices[i + 1] + endOffset;\n    const v2 = firstEndIndices[i + 2] + endOffset;\n    indices[index++] = v0;\n    indices[index++] = v1;\n    indices[index++] = v2;\n    indices[index++] = v2 + shapeLength;\n    indices[index++] = v1 + shapeLength;\n    indices[index++] = v0 + shapeLength;\n  }\n  let geometry = new Geometry({\n    attributes: attributes,\n    indices: indices,\n    boundingSphere: BoundingSphere.fromVertices(combinedPositions),\n    primitiveType: PrimitiveType.TRIANGLES\n  });\n  if (vertexFormat.normal) {\n    geometry = GeometryPipeline.computeNormal(geometry);\n  }\n  if (vertexFormat.tangent || vertexFormat.bitangent) {\n    try {\n      geometry = GeometryPipeline.computeTangentAndBitangent(geometry);\n    } catch (e) {\n      oneTimeWarning(\"polyline-volume-tangent-bitangent\", \"Unable to compute tangents and bitangents for polyline volume geometry\");\n      //TODO https://github.com/CesiumGS/cesium/issues/3609\n    }\n    if (!vertexFormat.tangent) {\n      geometry.attributes.tangent = undefined;\n    }\n    if (!vertexFormat.bitangent) {\n      geometry.attributes.bitangent = undefined;\n    }\n    if (!vertexFormat.st) {\n      geometry.attributes.st = undefined;\n    }\n  }\n  return geometry;\n}\n\n/**\n * A description of a polyline with a volume (a 2D shape extruded along a polyline).\n *\n * @alias PolylineVolumeGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.polylinePositions An array of {@link Cartesian3} positions that define the center of the polyline volume.\n * @param {Cartesian2[]} options.shapePositions An array of {@link Cartesian2} positions that define the shape to be extruded along the polyline\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n *\n * @see PolylineVolumeGeometry#createGeometry\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Polyline%20Volume.html|Cesium Sandcastle Polyline Volume Demo}\n *\n * @example\n * function computeCircle(radius) {\n *   const positions = [];\n *   for (let i = 0; i < 360; i++) {\n *     const radians = Cesium.Math.toRadians(i);\n *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));\n *   }\n *   return positions;\n * }\n *\n * const volume = new Cesium.PolylineVolumeGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0\n *   ]),\n *   shapePositions : computeCircle(100000.0)\n * });\n */\nfunction PolylineVolumeGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const positions = options.polylinePositions;\n  const shape = options.shapePositions;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.polylinePositions is required.\");\n  }\n  if (!defined(shape)) {\n    throw new DeveloperError(\"options.shapePositions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._positions = positions;\n  this._shape = shape;\n  this._ellipsoid = Ellipsoid.clone(options.ellipsoid ?? Ellipsoid.default);\n  this._cornerType = options.cornerType ?? CornerType.ROUNDED;\n  this._vertexFormat = VertexFormat.clone(options.vertexFormat ?? VertexFormat.DEFAULT);\n  this._granularity = options.granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n  this._workerName = \"createPolylineVolumeGeometry\";\n  let numComponents = 1 + positions.length * Cartesian3.packedLength;\n  numComponents += 1 + shape.length * Cartesian2.packedLength;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 2;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolylineVolumeGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nPolylineVolumeGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n  let i;\n  const positions = value._positions;\n  let length = positions.length;\n  array[startingIndex++] = length;\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n  const shape = value._shape;\n  length = shape.length;\n  array[startingIndex++] = length;\n  for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n    Cartesian2.pack(shape[i], array, startingIndex);\n  }\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex++] = value._cornerType;\n  array[startingIndex] = value._granularity;\n  return array;\n};\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  polylinePositions: undefined,\n  shapePositions: undefined,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  cornerType: undefined,\n  granularity: undefined\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolylineVolumeGeometry} [result] The object into which to store the result.\n * @returns {PolylineVolumeGeometry} The modified result parameter or a new PolylineVolumeGeometry instance if one was not provided.\n */\nPolylineVolumeGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n  let i;\n  let length = array[startingIndex++];\n  const positions = new Array(length);\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n  length = array[startingIndex++];\n  const shape = new Array(length);\n  for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n    shape[i] = Cartesian2.unpack(array, startingIndex);\n  }\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n  const vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n  startingIndex += VertexFormat.packedLength;\n  const cornerType = array[startingIndex++];\n  const granularity = array[startingIndex];\n  if (!defined(result)) {\n    scratchOptions.polylinePositions = positions;\n    scratchOptions.shapePositions = shape;\n    scratchOptions.cornerType = cornerType;\n    scratchOptions.granularity = granularity;\n    return new PolylineVolumeGeometry(scratchOptions);\n  }\n  result._positions = positions;\n  result._shape = shape;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._cornerType = cornerType;\n  result._granularity = granularity;\n  return result;\n};\nconst brScratch = new BoundingRectangle();\n\n/**\n * Computes the geometric representation of a polyline with a volume, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolylineVolumeGeometry} polylineVolumeGeometry A description of the polyline volume.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolylineVolumeGeometry.createGeometry = function (polylineVolumeGeometry) {\n  const positions = polylineVolumeGeometry._positions;\n  const cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n  let shape2D = polylineVolumeGeometry._shape;\n  shape2D = PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(shape2D);\n  if (cleanPositions.length < 2 || shape2D.length < 3) {\n    return undefined;\n  }\n  if (PolygonPipeline.computeWindingOrder2D(shape2D) === WindingOrder.CLOCKWISE) {\n    shape2D.reverse();\n  }\n  const boundingRectangle = BoundingRectangle.fromPoints(shape2D, brScratch);\n  const computedPositions = PolylineVolumeGeometryLibrary.computePositions(cleanPositions, shape2D, boundingRectangle, polylineVolumeGeometry, true);\n  return computeAttributes(computedPositions, shape2D, boundingRectangle, polylineVolumeGeometry._vertexFormat);\n};\nexport default PolylineVolumeGeometry;","map":{"version":3,"names":["arrayRemoveDuplicates","BoundingRectangle","BoundingSphere","Cartesian2","Cartesian3","ComponentDatatype","CornerType","Frozen","defined","DeveloperError","Ellipsoid","Geometry","GeometryAttribute","GeometryAttributes","GeometryPipeline","IndexDatatype","CesiumMath","oneTimeWarning","PolygonPipeline","PolylineVolumeGeometryLibrary","PrimitiveType","VertexFormat","WindingOrder","computeAttributes","combinedPositions","shape","boundingRectangle","vertexFormat","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","shapeLength","length","vertexCount","firstEndIndices","triangulate","indicesCount","indices","createTypedArray","i","j","ll","ul","ur","lr","offset","index","st","tangent","bitangent","Float32Array","lengthSt","heightSt","height","heightOffset","s","t","stindex","y","FLOAT","endOffset","v0","v1","v2","geometry","boundingSphere","fromVertices","primitiveType","TRIANGLES","normal","computeNormal","computeTangentAndBitangent","e","undefined","PolylineVolumeGeometry","options","EMPTY_OBJECT","positions","polylinePositions","shapePositions","_positions","_shape","_ellipsoid","clone","ellipsoid","default","_cornerType","cornerType","ROUNDED","_vertexFormat","DEFAULT","_granularity","granularity","RADIANS_PER_DEGREE","_workerName","numComponents","packedLength","pack","value","array","startingIndex","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","unpack","result","Array","brScratch","createGeometry","polylineVolumeGeometry","cleanPositions","equalsEpsilon","shape2D","removeDuplicatesFromShape","computeWindingOrder2D","CLOCKWISE","reverse","fromPoints","computedPositions","computePositions"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/PolylineVolumeGeometry.js"],"sourcesContent":["import arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingRectangle from \"./BoundingRectangle.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CornerType from \"./CornerType.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport oneTimeWarning from \"./oneTimeWarning.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PolylineVolumeGeometryLibrary from \"./PolylineVolumeGeometryLibrary.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n\nfunction computeAttributes(\n  combinedPositions,\n  shape,\n  boundingRectangle,\n  vertexFormat,\n) {\n  const attributes = new GeometryAttributes();\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: combinedPositions,\n    });\n  }\n  const shapeLength = shape.length;\n  const vertexCount = combinedPositions.length / 3;\n  const length = (vertexCount - shapeLength * 2) / (shapeLength * 2);\n  const firstEndIndices = PolygonPipeline.triangulate(shape);\n\n  const indicesCount =\n    (length - 1) * shapeLength * 6 + firstEndIndices.length * 2;\n  const indices = IndexDatatype.createTypedArray(vertexCount, indicesCount);\n  let i, j;\n  let ll, ul, ur, lr;\n  const offset = shapeLength * 2;\n  let index = 0;\n  for (i = 0; i < length - 1; i++) {\n    for (j = 0; j < shapeLength - 1; j++) {\n      ll = j * 2 + i * shapeLength * 2;\n      lr = ll + offset;\n      ul = ll + 1;\n      ur = ul + offset;\n\n      indices[index++] = ul;\n      indices[index++] = ll;\n      indices[index++] = ur;\n      indices[index++] = ur;\n      indices[index++] = ll;\n      indices[index++] = lr;\n    }\n    ll = shapeLength * 2 - 2 + i * shapeLength * 2;\n    ul = ll + 1;\n    ur = ul + offset;\n    lr = ll + offset;\n\n    indices[index++] = ul;\n    indices[index++] = ll;\n    indices[index++] = ur;\n    indices[index++] = ur;\n    indices[index++] = ll;\n    indices[index++] = lr;\n  }\n\n  if (vertexFormat.st || vertexFormat.tangent || vertexFormat.bitangent) {\n    // st required for tangent/bitangent calculation\n    const st = new Float32Array(vertexCount * 2);\n    const lengthSt = 1 / (length - 1);\n    const heightSt = 1 / boundingRectangle.height;\n    const heightOffset = boundingRectangle.height / 2;\n    let s, t;\n    let stindex = 0;\n    for (i = 0; i < length; i++) {\n      s = i * lengthSt;\n      t = heightSt * (shape[0].y + heightOffset);\n      st[stindex++] = s;\n      st[stindex++] = t;\n      for (j = 1; j < shapeLength; j++) {\n        t = heightSt * (shape[j].y + heightOffset);\n        st[stindex++] = s;\n        st[stindex++] = t;\n        st[stindex++] = s;\n        st[stindex++] = t;\n      }\n      t = heightSt * (shape[0].y + heightOffset);\n      st[stindex++] = s;\n      st[stindex++] = t;\n    }\n    for (j = 0; j < shapeLength; j++) {\n      s = 0;\n      t = heightSt * (shape[j].y + heightOffset);\n      st[stindex++] = s;\n      st[stindex++] = t;\n    }\n    for (j = 0; j < shapeLength; j++) {\n      s = (length - 1) * lengthSt;\n      t = heightSt * (shape[j].y + heightOffset);\n      st[stindex++] = s;\n      st[stindex++] = t;\n    }\n\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: new Float32Array(st),\n    });\n  }\n\n  const endOffset = vertexCount - shapeLength * 2;\n  for (i = 0; i < firstEndIndices.length; i += 3) {\n    const v0 = firstEndIndices[i] + endOffset;\n    const v1 = firstEndIndices[i + 1] + endOffset;\n    const v2 = firstEndIndices[i + 2] + endOffset;\n\n    indices[index++] = v0;\n    indices[index++] = v1;\n    indices[index++] = v2;\n    indices[index++] = v2 + shapeLength;\n    indices[index++] = v1 + shapeLength;\n    indices[index++] = v0 + shapeLength;\n  }\n\n  let geometry = new Geometry({\n    attributes: attributes,\n    indices: indices,\n    boundingSphere: BoundingSphere.fromVertices(combinedPositions),\n    primitiveType: PrimitiveType.TRIANGLES,\n  });\n\n  if (vertexFormat.normal) {\n    geometry = GeometryPipeline.computeNormal(geometry);\n  }\n\n  if (vertexFormat.tangent || vertexFormat.bitangent) {\n    try {\n      geometry = GeometryPipeline.computeTangentAndBitangent(geometry);\n    } catch (e) {\n      oneTimeWarning(\n        \"polyline-volume-tangent-bitangent\",\n        \"Unable to compute tangents and bitangents for polyline volume geometry\",\n      );\n      //TODO https://github.com/CesiumGS/cesium/issues/3609\n    }\n\n    if (!vertexFormat.tangent) {\n      geometry.attributes.tangent = undefined;\n    }\n    if (!vertexFormat.bitangent) {\n      geometry.attributes.bitangent = undefined;\n    }\n    if (!vertexFormat.st) {\n      geometry.attributes.st = undefined;\n    }\n  }\n\n  return geometry;\n}\n\n/**\n * A description of a polyline with a volume (a 2D shape extruded along a polyline).\n *\n * @alias PolylineVolumeGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.polylinePositions An array of {@link Cartesian3} positions that define the center of the polyline volume.\n * @param {Cartesian2[]} options.shapePositions An array of {@link Cartesian2} positions that define the shape to be extruded along the polyline\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n *\n * @see PolylineVolumeGeometry#createGeometry\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Polyline%20Volume.html|Cesium Sandcastle Polyline Volume Demo}\n *\n * @example\n * function computeCircle(radius) {\n *   const positions = [];\n *   for (let i = 0; i < 360; i++) {\n *     const radians = Cesium.Math.toRadians(i);\n *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));\n *   }\n *   return positions;\n * }\n *\n * const volume = new Cesium.PolylineVolumeGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0\n *   ]),\n *   shapePositions : computeCircle(100000.0)\n * });\n */\nfunction PolylineVolumeGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const positions = options.polylinePositions;\n  const shape = options.shapePositions;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.polylinePositions is required.\");\n  }\n  if (!defined(shape)) {\n    throw new DeveloperError(\"options.shapePositions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._positions = positions;\n  this._shape = shape;\n  this._ellipsoid = Ellipsoid.clone(options.ellipsoid ?? Ellipsoid.default);\n  this._cornerType = options.cornerType ?? CornerType.ROUNDED;\n  this._vertexFormat = VertexFormat.clone(\n    options.vertexFormat ?? VertexFormat.DEFAULT,\n  );\n  this._granularity = options.granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n  this._workerName = \"createPolylineVolumeGeometry\";\n\n  let numComponents = 1 + positions.length * Cartesian3.packedLength;\n  numComponents += 1 + shape.length * Cartesian2.packedLength;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength =\n    numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 2;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolylineVolumeGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nPolylineVolumeGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  let i;\n\n  const positions = value._positions;\n  let length = positions.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  const shape = value._shape;\n  length = shape.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n    Cartesian2.pack(shape[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._cornerType;\n  array[startingIndex] = value._granularity;\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  polylinePositions: undefined,\n  shapePositions: undefined,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  cornerType: undefined,\n  granularity: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolylineVolumeGeometry} [result] The object into which to store the result.\n * @returns {PolylineVolumeGeometry} The modified result parameter or a new PolylineVolumeGeometry instance if one was not provided.\n */\nPolylineVolumeGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  let i;\n\n  let length = array[startingIndex++];\n  const positions = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  length = array[startingIndex++];\n  const shape = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n    shape[i] = Cartesian2.unpack(array, startingIndex);\n  }\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat,\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const cornerType = array[startingIndex++];\n  const granularity = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.polylinePositions = positions;\n    scratchOptions.shapePositions = shape;\n    scratchOptions.cornerType = cornerType;\n    scratchOptions.granularity = granularity;\n    return new PolylineVolumeGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._shape = shape;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._cornerType = cornerType;\n  result._granularity = granularity;\n\n  return result;\n};\n\nconst brScratch = new BoundingRectangle();\n\n/**\n * Computes the geometric representation of a polyline with a volume, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolylineVolumeGeometry} polylineVolumeGeometry A description of the polyline volume.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolylineVolumeGeometry.createGeometry = function (polylineVolumeGeometry) {\n  const positions = polylineVolumeGeometry._positions;\n  const cleanPositions = arrayRemoveDuplicates(\n    positions,\n    Cartesian3.equalsEpsilon,\n  );\n  let shape2D = polylineVolumeGeometry._shape;\n  shape2D = PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(shape2D);\n\n  if (cleanPositions.length < 2 || shape2D.length < 3) {\n    return undefined;\n  }\n\n  if (\n    PolygonPipeline.computeWindingOrder2D(shape2D) === WindingOrder.CLOCKWISE\n  ) {\n    shape2D.reverse();\n  }\n  const boundingRectangle = BoundingRectangle.fromPoints(shape2D, brScratch);\n\n  const computedPositions = PolylineVolumeGeometryLibrary.computePositions(\n    cleanPositions,\n    shape2D,\n    boundingRectangle,\n    polylineVolumeGeometry,\n    true,\n  );\n  return computeAttributes(\n    computedPositions,\n    shape2D,\n    boundingRectangle,\n    polylineVolumeGeometry._vertexFormat,\n  );\n};\nexport default PolylineVolumeGeometry;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}