{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-hex.js\";\nimport \"core-js/modules/esnext.uint8-array.to-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.to-hex.js\";\nimport AttributeCompression from \"../Core/AttributeCompression.js\";\nimport binarySearch from \"../Core/binarySearch.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport HeightmapTerrainData from \"../Core/HeightmapTerrainData.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Queue from \"../Core/Queue.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport TerrainEncoding from \"../Core/TerrainEncoding.js\";\nimport TerrainMesh from \"../Core/TerrainMesh.js\";\nimport TileEdge from \"../Core/TileEdge.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport GlobeSurfaceTile from \"./GlobeSurfaceTile.js\";\nimport TileSelectionResult from \"./TileSelectionResult.js\";\nfunction TerrainFillMesh(tile) {\n  this.tile = tile;\n  this.frameLastUpdated = undefined;\n  this.westMeshes = []; // north to south (CCW)\n  this.westTiles = [];\n  this.southMeshes = []; // west to east (CCW)\n  this.southTiles = [];\n  this.eastMeshes = []; // south to north (CCW)\n  this.eastTiles = [];\n  this.northMeshes = []; // east to west (CCW)\n  this.northTiles = [];\n  this.southwestMesh = undefined;\n  this.southwestTile = undefined;\n  this.southeastMesh = undefined;\n  this.southeastTile = undefined;\n  this.northwestMesh = undefined;\n  this.northwestTile = undefined;\n  this.northeastMesh = undefined;\n  this.northeastTile = undefined;\n  this.changedThisFrame = true;\n  this.visitedFrame = undefined;\n  this.enqueuedFrame = undefined;\n  this.mesh = undefined;\n  this.vertexArray = undefined;\n  this.waterMaskTexture = undefined;\n  this.waterMaskTranslationAndScale = new Cartesian4();\n}\nTerrainFillMesh.prototype.update = function (tileProvider, frameState, vertexArraysToDestroy) {\n  if (this.changedThisFrame) {\n    createFillMesh(tileProvider, frameState, this.tile, vertexArraysToDestroy);\n    this.changedThisFrame = false;\n  }\n};\nTerrainFillMesh.prototype.destroy = function (vertexArraysToDestroy) {\n  this._destroyVertexArray(vertexArraysToDestroy);\n  if (defined(this.waterMaskTexture)) {\n    --this.waterMaskTexture.referenceCount;\n    if (this.waterMaskTexture.referenceCount === 0) {\n      this.waterMaskTexture.destroy();\n    }\n    this.waterMaskTexture = undefined;\n  }\n  return undefined;\n};\nTerrainFillMesh.prototype._destroyVertexArray = function (vertexArraysToDestroy) {\n  if (defined(this.vertexArray)) {\n    if (defined(vertexArraysToDestroy)) {\n      vertexArraysToDestroy.push(this.vertexArray);\n    } else {\n      GlobeSurfaceTile._freeVertexArray(this.vertexArray);\n    }\n    this.vertexArray = undefined;\n  }\n};\nconst traversalQueueScratch = new Queue();\nTerrainFillMesh.updateFillTiles = function (tileProvider, renderedTiles, frameState, vertexArraysToDestroy) {\n  // We want our fill tiles to look natural, which means they should align perfectly with\n  // adjacent loaded tiles, and their edges that are not adjacent to loaded tiles should have\n  // sensible heights (e.g. the average of the heights of loaded edges). Some fill tiles may\n  // be adjacent only to other fill tiles, and in that case heights should be assigned fanning\n  // outward from the loaded tiles so that there are no sudden changes in height.\n\n  // We do this with a breadth-first traversal of the rendered tiles, starting with the loaded\n  // ones. Graph nodes are tiles and graph edges connect to other rendered tiles that are spatially adjacent\n  // to those tiles. As we visit each node, we propagate tile edges to adjacent tiles. If there's no data\n  // for a tile edge,  we create an edge with an average height and then propagate it. If an edge is partially defined\n  // (e.g. an edge is adjacent to multiple more-detailed tiles and only some of them are loaded), we\n  // fill in the rest of the edge with the same height.\n  const quadtree = tileProvider._quadtree;\n  const levelZeroTiles = quadtree._levelZeroTiles;\n  const lastSelectionFrameNumber = quadtree._lastSelectionFrameNumber;\n  const traversalQueue = traversalQueueScratch;\n  traversalQueue.clear();\n\n  // Add the tiles with real geometry to the traversal queue.\n  for (let i = 0; i < renderedTiles.length; ++i) {\n    const renderedTile = renderedTiles[i];\n    if (defined(renderedTile.data.vertexArray)) {\n      traversalQueue.enqueue(renderedTiles[i]);\n    }\n  }\n  let tile = traversalQueue.dequeue();\n  while (tile !== undefined) {\n    const tileToWest = tile.findTileToWest(levelZeroTiles);\n    const tileToSouth = tile.findTileToSouth(levelZeroTiles);\n    const tileToEast = tile.findTileToEast(levelZeroTiles);\n    const tileToNorth = tile.findTileToNorth(levelZeroTiles);\n    visitRenderedTiles(tileProvider, frameState, tile, tileToWest, lastSelectionFrameNumber, TileEdge.EAST, false, traversalQueue, vertexArraysToDestroy);\n    visitRenderedTiles(tileProvider, frameState, tile, tileToSouth, lastSelectionFrameNumber, TileEdge.NORTH, false, traversalQueue, vertexArraysToDestroy);\n    visitRenderedTiles(tileProvider, frameState, tile, tileToEast, lastSelectionFrameNumber, TileEdge.WEST, false, traversalQueue, vertexArraysToDestroy);\n    visitRenderedTiles(tileProvider, frameState, tile, tileToNorth, lastSelectionFrameNumber, TileEdge.SOUTH, false, traversalQueue, vertexArraysToDestroy);\n    const tileToNorthwest = tileToWest.findTileToNorth(levelZeroTiles);\n    const tileToSouthwest = tileToWest.findTileToSouth(levelZeroTiles);\n    const tileToNortheast = tileToEast.findTileToNorth(levelZeroTiles);\n    const tileToSoutheast = tileToEast.findTileToSouth(levelZeroTiles);\n    visitRenderedTiles(tileProvider, frameState, tile, tileToNorthwest, lastSelectionFrameNumber, TileEdge.SOUTHEAST, false, traversalQueue, vertexArraysToDestroy);\n    visitRenderedTiles(tileProvider, frameState, tile, tileToNortheast, lastSelectionFrameNumber, TileEdge.SOUTHWEST, false, traversalQueue, vertexArraysToDestroy);\n    visitRenderedTiles(tileProvider, frameState, tile, tileToSouthwest, lastSelectionFrameNumber, TileEdge.NORTHEAST, false, traversalQueue, vertexArraysToDestroy);\n    visitRenderedTiles(tileProvider, frameState, tile, tileToSoutheast, lastSelectionFrameNumber, TileEdge.NORTHWEST, false, traversalQueue, vertexArraysToDestroy);\n    tile = traversalQueue.dequeue();\n  }\n};\nfunction visitRenderedTiles(tileProvider, frameState, sourceTile, startTile, currentFrameNumber, tileEdge, downOnly, traversalQueue, vertexArraysToDestroy) {\n  if (startTile === undefined) {\n    // There are no tiles North or South of the poles.\n    return;\n  }\n  let tile = startTile;\n  while (tile && (tile._lastSelectionResultFrame !== currentFrameNumber || TileSelectionResult.wasKicked(tile._lastSelectionResult) || TileSelectionResult.originalResult(tile._lastSelectionResult) === TileSelectionResult.CULLED)) {\n    // This tile wasn't visited or it was visited and then kicked, so walk up to find the closest ancestor that was rendered.\n    // We also walk up if the tile was culled, because if siblings were kicked an ancestor may have been rendered.\n    if (downOnly) {\n      return;\n    }\n    const parent = tile.parent;\n    if (tileEdge >= TileEdge.NORTHWEST && parent !== undefined) {\n      // When we're looking for a corner, verify that the parent tile is still relevant.\n      // That is, the parent and child must share the corner in question.\n      switch (tileEdge) {\n        case TileEdge.NORTHWEST:\n          tile = tile === parent.northwestChild ? parent : undefined;\n          break;\n        case TileEdge.NORTHEAST:\n          tile = tile === parent.northeastChild ? parent : undefined;\n          break;\n        case TileEdge.SOUTHWEST:\n          tile = tile === parent.southwestChild ? parent : undefined;\n          break;\n        case TileEdge.SOUTHEAST:\n          tile = tile === parent.southeastChild ? parent : undefined;\n          break;\n      }\n    } else {\n      tile = parent;\n    }\n  }\n  if (tile === undefined) {\n    return;\n  }\n  if (tile._lastSelectionResult === TileSelectionResult.RENDERED) {\n    if (defined(tile.data.vertexArray)) {\n      // No further processing necessary for renderable tiles.\n      return;\n    }\n    visitTile(tileProvider, frameState, sourceTile, tile, tileEdge, currentFrameNumber, traversalQueue, vertexArraysToDestroy);\n    return;\n  }\n  if (TileSelectionResult.originalResult(startTile._lastSelectionResult) === TileSelectionResult.CULLED) {\n    return;\n  }\n\n  // This tile was refined, so find rendered children, if any.\n  // Visit the tiles in counter-clockwise order.\n  switch (tileEdge) {\n    case TileEdge.WEST:\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.northwestChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.southwestChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      break;\n    case TileEdge.EAST:\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.southeastChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.northeastChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      break;\n    case TileEdge.SOUTH:\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.southwestChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.southeastChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      break;\n    case TileEdge.NORTH:\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.northeastChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.northwestChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      break;\n    case TileEdge.NORTHWEST:\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.northwestChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      break;\n    case TileEdge.NORTHEAST:\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.northeastChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      break;\n    case TileEdge.SOUTHWEST:\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.southwestChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      break;\n    case TileEdge.SOUTHEAST:\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.southeastChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      break;\n    default:\n      throw new DeveloperError(\"Invalid edge\");\n  }\n}\nfunction visitTile(tileProvider, frameState, sourceTile, destinationTile, tileEdge, frameNumber, traversalQueue, vertexArraysToDestroy) {\n  const destinationSurfaceTile = destinationTile.data;\n  if (destinationSurfaceTile.fill === undefined) {\n    destinationSurfaceTile.fill = new TerrainFillMesh(destinationTile);\n  } else if (destinationSurfaceTile.fill.visitedFrame === frameNumber) {\n    // Don't propagate edges to tiles that have already been visited this frame.\n    return;\n  }\n  if (destinationSurfaceTile.fill.enqueuedFrame !== frameNumber) {\n    // First time visiting this tile this frame, add it to the traversal queue.\n    destinationSurfaceTile.fill.enqueuedFrame = frameNumber;\n    destinationSurfaceTile.fill.changedThisFrame = false;\n    traversalQueue.enqueue(destinationTile);\n  }\n  propagateEdge(tileProvider, frameState, sourceTile, destinationTile, tileEdge, vertexArraysToDestroy);\n}\nfunction propagateEdge(tileProvider, frameState, sourceTile, destinationTile, tileEdge, vertexArraysToDestroy) {\n  const destinationFill = destinationTile.data.fill;\n  let sourceMesh;\n  const sourceFill = sourceTile.data.fill;\n  if (defined(sourceFill)) {\n    sourceFill.visitedFrame = frameState.frameNumber;\n\n    // Source is a fill, create/update it if necessary.\n    if (sourceFill.changedThisFrame) {\n      createFillMesh(tileProvider, frameState, sourceTile, vertexArraysToDestroy);\n      sourceFill.changedThisFrame = false;\n    }\n    sourceMesh = sourceTile.data.fill.mesh;\n  } else {\n    sourceMesh = sourceTile.data.mesh;\n  }\n  let edgeMeshes;\n  let edgeTiles;\n  switch (tileEdge) {\n    case TileEdge.WEST:\n      edgeMeshes = destinationFill.westMeshes;\n      edgeTiles = destinationFill.westTiles;\n      break;\n    case TileEdge.SOUTH:\n      edgeMeshes = destinationFill.southMeshes;\n      edgeTiles = destinationFill.southTiles;\n      break;\n    case TileEdge.EAST:\n      edgeMeshes = destinationFill.eastMeshes;\n      edgeTiles = destinationFill.eastTiles;\n      break;\n    case TileEdge.NORTH:\n      edgeMeshes = destinationFill.northMeshes;\n      edgeTiles = destinationFill.northTiles;\n      break;\n    // Corners are simpler.\n    case TileEdge.NORTHWEST:\n      destinationFill.changedThisFrame = destinationFill.changedThisFrame || destinationFill.northwestMesh !== sourceMesh;\n      destinationFill.northwestMesh = sourceMesh;\n      destinationFill.northwestTile = sourceTile;\n      return;\n    case TileEdge.NORTHEAST:\n      destinationFill.changedThisFrame = destinationFill.changedThisFrame || destinationFill.northeastMesh !== sourceMesh;\n      destinationFill.northeastMesh = sourceMesh;\n      destinationFill.northeastTile = sourceTile;\n      return;\n    case TileEdge.SOUTHWEST:\n      destinationFill.changedThisFrame = destinationFill.changedThisFrame || destinationFill.southwestMesh !== sourceMesh;\n      destinationFill.southwestMesh = sourceMesh;\n      destinationFill.southwestTile = sourceTile;\n      return;\n    case TileEdge.SOUTHEAST:\n      destinationFill.changedThisFrame = destinationFill.changedThisFrame || destinationFill.southeastMesh !== sourceMesh;\n      destinationFill.southeastMesh = sourceMesh;\n      destinationFill.southeastTile = sourceTile;\n      return;\n  }\n  if (sourceTile.level <= destinationTile.level) {\n    // Source edge completely spans the destination edge.\n    destinationFill.changedThisFrame = destinationFill.changedThisFrame || edgeMeshes[0] !== sourceMesh || edgeMeshes.length !== 1;\n    edgeMeshes[0] = sourceMesh;\n    edgeTiles[0] = sourceTile;\n    edgeMeshes.length = 1;\n    edgeTiles.length = 1;\n    return;\n  }\n\n  // Source edge is a subset of the destination edge.\n  // Figure out the range of meshes we're replacing.\n  let startIndex, endIndex, existingTile, existingRectangle;\n  const sourceRectangle = sourceTile.rectangle;\n  let epsilon;\n  const destinationRectangle = destinationTile.rectangle;\n  switch (tileEdge) {\n    case TileEdge.WEST:\n      epsilon = (destinationRectangle.north - destinationRectangle.south) * CesiumMath.EPSILON5;\n      for (startIndex = 0; startIndex < edgeTiles.length; ++startIndex) {\n        existingTile = edgeTiles[startIndex];\n        existingRectangle = existingTile.rectangle;\n        if (CesiumMath.greaterThan(sourceRectangle.north, existingRectangle.south, epsilon)) {\n          break;\n        }\n      }\n      for (endIndex = startIndex; endIndex < edgeTiles.length; ++endIndex) {\n        existingTile = edgeTiles[endIndex];\n        existingRectangle = existingTile.rectangle;\n        if (CesiumMath.greaterThanOrEquals(sourceRectangle.south, existingRectangle.north, epsilon)) {\n          break;\n        }\n      }\n      break;\n    case TileEdge.SOUTH:\n      epsilon = (destinationRectangle.east - destinationRectangle.west) * CesiumMath.EPSILON5;\n      for (startIndex = 0; startIndex < edgeTiles.length; ++startIndex) {\n        existingTile = edgeTiles[startIndex];\n        existingRectangle = existingTile.rectangle;\n        if (CesiumMath.lessThan(sourceRectangle.west, existingRectangle.east, epsilon)) {\n          break;\n        }\n      }\n      for (endIndex = startIndex; endIndex < edgeTiles.length; ++endIndex) {\n        existingTile = edgeTiles[endIndex];\n        existingRectangle = existingTile.rectangle;\n        if (CesiumMath.lessThanOrEquals(sourceRectangle.east, existingRectangle.west, epsilon)) {\n          break;\n        }\n      }\n      break;\n    case TileEdge.EAST:\n      epsilon = (destinationRectangle.north - destinationRectangle.south) * CesiumMath.EPSILON5;\n      for (startIndex = 0; startIndex < edgeTiles.length; ++startIndex) {\n        existingTile = edgeTiles[startIndex];\n        existingRectangle = existingTile.rectangle;\n        if (CesiumMath.lessThan(sourceRectangle.south, existingRectangle.north, epsilon)) {\n          break;\n        }\n      }\n      for (endIndex = startIndex; endIndex < edgeTiles.length; ++endIndex) {\n        existingTile = edgeTiles[endIndex];\n        existingRectangle = existingTile.rectangle;\n        if (CesiumMath.lessThanOrEquals(sourceRectangle.north, existingRectangle.south, epsilon)) {\n          break;\n        }\n      }\n      break;\n    case TileEdge.NORTH:\n      epsilon = (destinationRectangle.east - destinationRectangle.west) * CesiumMath.EPSILON5;\n      for (startIndex = 0; startIndex < edgeTiles.length; ++startIndex) {\n        existingTile = edgeTiles[startIndex];\n        existingRectangle = existingTile.rectangle;\n        if (CesiumMath.greaterThan(sourceRectangle.east, existingRectangle.west, epsilon)) {\n          break;\n        }\n      }\n      for (endIndex = startIndex; endIndex < edgeTiles.length; ++endIndex) {\n        existingTile = edgeTiles[endIndex];\n        existingRectangle = existingTile.rectangle;\n        if (CesiumMath.greaterThanOrEquals(sourceRectangle.west, existingRectangle.east, epsilon)) {\n          break;\n        }\n      }\n      break;\n  }\n  if (endIndex - startIndex === 1) {\n    destinationFill.changedThisFrame = destinationFill.changedThisFrame || edgeMeshes[startIndex] !== sourceMesh;\n    edgeMeshes[startIndex] = sourceMesh;\n    edgeTiles[startIndex] = sourceTile;\n  } else {\n    destinationFill.changedThisFrame = true;\n    edgeMeshes.splice(startIndex, endIndex - startIndex, sourceMesh);\n    edgeTiles.splice(startIndex, endIndex - startIndex, sourceTile);\n  }\n}\nconst cartographicScratch = new Cartographic();\nconst centerCartographicScratch = new Cartographic();\nconst cartesianScratch = new Cartesian3();\nconst normalScratch = new Cartesian3();\nconst octEncodedNormalScratch = new Cartesian2();\nconst uvScratch2 = new Cartesian2();\nconst uvScratch = new Cartesian2();\nfunction HeightAndNormal() {\n  this.height = 0.0;\n  this.encodedNormal = new Cartesian2();\n}\nfunction fillMissingCorner(fill, ellipsoid, u, v, corner, adjacentCorner1, adjacentCorner2, oppositeCorner, vertex) {\n  if (defined(corner)) {\n    return corner;\n  }\n  let height;\n  if (defined(adjacentCorner1) && defined(adjacentCorner2)) {\n    height = (adjacentCorner1.height + adjacentCorner2.height) * 0.5;\n  } else if (defined(adjacentCorner1)) {\n    height = adjacentCorner1.height;\n  } else if (defined(adjacentCorner2)) {\n    height = adjacentCorner2.height;\n  } else if (defined(oppositeCorner)) {\n    height = oppositeCorner.height;\n  } else {\n    const surfaceTile = fill.tile.data;\n    const tileBoundingRegion = surfaceTile.tileBoundingRegion;\n    let minimumHeight = 0.0;\n    let maximumHeight = 0.0;\n    if (defined(tileBoundingRegion)) {\n      minimumHeight = tileBoundingRegion.minimumHeight;\n      maximumHeight = tileBoundingRegion.maximumHeight;\n    }\n    height = (minimumHeight + maximumHeight) * 0.5;\n  }\n  getVertexWithHeightAtCorner(fill, ellipsoid, u, v, height, vertex);\n  return vertex;\n}\nconst heightRangeScratch = {\n  minimumHeight: 0.0,\n  maximumHeight: 0.0\n};\nconst scratchCenter = new Cartesian3();\nconst swVertexScratch = new HeightAndNormal();\nconst seVertexScratch = new HeightAndNormal();\nconst nwVertexScratch = new HeightAndNormal();\nconst neVertexScratch = new HeightAndNormal();\nconst heightmapBuffer = typeof Uint8Array !== \"undefined\" ? new Uint8Array(9 * 9) : undefined;\nconst scratchCreateMeshSyncOptions = {\n  tilingScheme: undefined,\n  x: 0,\n  y: 0,\n  level: 0,\n  exaggeration: 1.0,\n  exaggerationRelativeHeight: 0.0\n};\nfunction createFillMesh(tileProvider, frameState, tile, vertexArraysToDestroy) {\n  GlobeSurfaceTile.initialize(tile, tileProvider.terrainProvider, tileProvider._imageryLayers);\n  const surfaceTile = tile.data;\n  const fill = surfaceTile.fill;\n  const rectangle = tile.rectangle;\n  const exaggeration = frameState.verticalExaggeration;\n  const exaggerationRelativeHeight = frameState.verticalExaggerationRelativeHeight;\n  const hasExaggeration = exaggeration !== 1.0;\n  const ellipsoid = tile.tilingScheme.ellipsoid;\n  let nwCorner = getCorner(fill, ellipsoid, 0.0, 1.0, fill.northwestTile, fill.northwestMesh, fill.northTiles, fill.northMeshes, fill.westTiles, fill.westMeshes, nwVertexScratch);\n  let swCorner = getCorner(fill, ellipsoid, 0.0, 0.0, fill.southwestTile, fill.southwestMesh, fill.westTiles, fill.westMeshes, fill.southTiles, fill.southMeshes, swVertexScratch);\n  let seCorner = getCorner(fill, ellipsoid, 1.0, 0.0, fill.southeastTile, fill.southeastMesh, fill.southTiles, fill.southMeshes, fill.eastTiles, fill.eastMeshes, seVertexScratch);\n  let neCorner = getCorner(fill, ellipsoid, 1.0, 1.0, fill.northeastTile, fill.northeastMesh, fill.eastTiles, fill.eastMeshes, fill.northTiles, fill.northMeshes, neVertexScratch);\n  nwCorner = fillMissingCorner(fill, ellipsoid, 0.0, 1.0, nwCorner, swCorner, neCorner, seCorner, nwVertexScratch);\n  swCorner = fillMissingCorner(fill, ellipsoid, 0.0, 0.0, swCorner, nwCorner, seCorner, neCorner, swVertexScratch);\n  seCorner = fillMissingCorner(fill, ellipsoid, 1.0, 1.0, seCorner, swCorner, neCorner, nwCorner, seVertexScratch);\n  neCorner = fillMissingCorner(fill, ellipsoid, 1.0, 1.0, neCorner, seCorner, nwCorner, swCorner, neVertexScratch);\n  const southwestHeight = swCorner.height;\n  const southeastHeight = seCorner.height;\n  const northwestHeight = nwCorner.height;\n  const northeastHeight = neCorner.height;\n  let minimumHeight = Math.min(southwestHeight, southeastHeight, northwestHeight, northeastHeight);\n  let maximumHeight = Math.max(southwestHeight, southeastHeight, northwestHeight, northeastHeight);\n  const middleHeight = (minimumHeight + maximumHeight) * 0.5;\n  let i;\n  let len;\n\n  // For low-detail tiles, our usual fill tile approach will create tiles that\n  // look really blocky because they don't have enough vertices to account for the\n  // Earth's curvature. But the height range will also typically be well within\n  // the allowed geometric error for those levels. So fill such tiles with a\n  // constant-height heightmap.\n  const geometricError = tileProvider.getLevelMaximumGeometricError(tile.level);\n  const minCutThroughRadius = ellipsoid.maximumRadius - geometricError;\n  let maxTileWidth = Math.acos(minCutThroughRadius / ellipsoid.maximumRadius) * 4.0;\n\n  // When the tile width is greater than maxTileWidth as computed above, the error\n  // of a normal fill tile from globe curvature alone will exceed the allowed geometric\n  // error. Terrain won't change that much. However, we can allow more error than that.\n  // A little blockiness during load is acceptable. For the WGS84 ellipsoid and\n  // standard geometric error setup, the value here will have us use a heightmap\n  // at levels 1, 2, and 3.\n  maxTileWidth *= 1.5;\n  if (rectangle.width > maxTileWidth && maximumHeight - minimumHeight <= geometricError) {\n    const terrainData = new HeightmapTerrainData({\n      width: 9,\n      height: 9,\n      buffer: heightmapBuffer,\n      structure: {\n        // Use the maximum as the constant height so that this tile's skirt\n        // covers any cracks with adjacent tiles.\n        heightOffset: maximumHeight\n      }\n    });\n    const createMeshSyncOptions = scratchCreateMeshSyncOptions;\n    createMeshSyncOptions.tilingScheme = tile.tilingScheme;\n    createMeshSyncOptions.x = tile.x;\n    createMeshSyncOptions.y = tile.y;\n    createMeshSyncOptions.level = tile.level;\n    createMeshSyncOptions.exaggeration = exaggeration;\n    createMeshSyncOptions.exaggerationRelativeHeight = exaggerationRelativeHeight;\n    fill.mesh = terrainData._createMeshSync(createMeshSyncOptions);\n  } else {\n    const hasGeodeticSurfaceNormals = hasExaggeration;\n    const centerCartographic = Rectangle.center(rectangle, centerCartographicScratch);\n    centerCartographic.height = middleHeight;\n    const center = ellipsoid.cartographicToCartesian(centerCartographic, scratchCenter);\n    const encoding = new TerrainEncoding(center, undefined, undefined, undefined, undefined, true, true, hasGeodeticSurfaceNormals, exaggeration, exaggerationRelativeHeight);\n\n    // At _most_, we have vertices for the 4 corners, plus 1 center, plus every adjacent edge vertex.\n    // In reality there will be less most of the time, but close enough; better\n    // to overestimate than to re-allocate/copy/traverse the vertices twice.\n    // Also, we'll often be able to squeeze the index data into the extra space in the buffer.\n    let maxVertexCount = 5;\n    let meshes;\n    meshes = fill.westMeshes;\n    for (i = 0, len = meshes.length; i < len; ++i) {\n      maxVertexCount += meshes[i].eastIndicesNorthToSouth.length;\n    }\n    meshes = fill.southMeshes;\n    for (i = 0, len = meshes.length; i < len; ++i) {\n      maxVertexCount += meshes[i].northIndicesWestToEast.length;\n    }\n    meshes = fill.eastMeshes;\n    for (i = 0, len = meshes.length; i < len; ++i) {\n      maxVertexCount += meshes[i].westIndicesSouthToNorth.length;\n    }\n    meshes = fill.northMeshes;\n    for (i = 0, len = meshes.length; i < len; ++i) {\n      maxVertexCount += meshes[i].southIndicesEastToWest.length;\n    }\n    const heightRange = heightRangeScratch;\n    heightRange.minimumHeight = minimumHeight;\n    heightRange.maximumHeight = maximumHeight;\n    const stride = encoding.stride;\n    let typedArray = new Float32Array(maxVertexCount * stride);\n    let nextIndex = 0;\n    const northwestIndex = nextIndex;\n    nextIndex = addVertexWithComputedPosition(ellipsoid, rectangle, encoding, typedArray, nextIndex, 0.0, 1.0, nwCorner.height, nwCorner.encodedNormal, 1.0, heightRange);\n    nextIndex = addEdge(fill, ellipsoid, encoding, typedArray, nextIndex, fill.westTiles, fill.westMeshes, TileEdge.EAST, heightRange);\n    const southwestIndex = nextIndex;\n    nextIndex = addVertexWithComputedPosition(ellipsoid, rectangle, encoding, typedArray, nextIndex, 0.0, 0.0, swCorner.height, swCorner.encodedNormal, 0.0, heightRange);\n    nextIndex = addEdge(fill, ellipsoid, encoding, typedArray, nextIndex, fill.southTiles, fill.southMeshes, TileEdge.NORTH, heightRange);\n    const southeastIndex = nextIndex;\n    nextIndex = addVertexWithComputedPosition(ellipsoid, rectangle, encoding, typedArray, nextIndex, 1.0, 0.0, seCorner.height, seCorner.encodedNormal, 0.0, heightRange);\n    nextIndex = addEdge(fill, ellipsoid, encoding, typedArray, nextIndex, fill.eastTiles, fill.eastMeshes, TileEdge.WEST, heightRange);\n    const northeastIndex = nextIndex;\n    nextIndex = addVertexWithComputedPosition(ellipsoid, rectangle, encoding, typedArray, nextIndex, 1.0, 1.0, neCorner.height, neCorner.encodedNormal, 1.0, heightRange);\n    nextIndex = addEdge(fill, ellipsoid, encoding, typedArray, nextIndex, fill.northTiles, fill.northMeshes, TileEdge.SOUTH, heightRange);\n    minimumHeight = heightRange.minimumHeight;\n    maximumHeight = heightRange.maximumHeight;\n    const obb = OrientedBoundingBox.fromRectangle(rectangle, minimumHeight, maximumHeight, tile.tilingScheme.ellipsoid);\n\n    // Add a single vertex at the center of the tile.\n    const southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(rectangle.south);\n    const oneOverMercatorHeight = 1.0 / (WebMercatorProjection.geodeticLatitudeToMercatorAngle(rectangle.north) - southMercatorY);\n    const centerWebMercatorT = (WebMercatorProjection.geodeticLatitudeToMercatorAngle(centerCartographic.latitude) - southMercatorY) * oneOverMercatorHeight;\n    const geodeticSurfaceNormal = ellipsoid.geodeticSurfaceNormalCartographic(cartographicScratch, normalScratch);\n    const centerEncodedNormal = AttributeCompression.octEncode(geodeticSurfaceNormal, octEncodedNormalScratch);\n    const centerIndex = nextIndex;\n    encoding.encode(typedArray, nextIndex * stride, obb.center, Cartesian2.fromElements(0.5, 0.5, uvScratch), middleHeight, centerEncodedNormal, centerWebMercatorT, geodeticSurfaceNormal);\n    ++nextIndex;\n    const vertexCount = nextIndex;\n    const bytesPerIndex = vertexCount < 256 ? 1 : 2;\n    const indexCount = (vertexCount - 1) * 3; // one triangle per edge vertex\n    const indexDataBytes = indexCount * bytesPerIndex;\n    const availableBytesInBuffer = (typedArray.length - vertexCount * stride) * Float32Array.BYTES_PER_ELEMENT;\n    let indices;\n    if (availableBytesInBuffer >= indexDataBytes) {\n      // Store the index data in the same buffer as the vertex data.\n      const startIndex = vertexCount * stride * Float32Array.BYTES_PER_ELEMENT;\n      indices = vertexCount < 256 ? new Uint8Array(typedArray.buffer, startIndex, indexCount) : new Uint16Array(typedArray.buffer, startIndex, indexCount);\n    } else {\n      // Allocate a new buffer for the index data.\n      indices = vertexCount < 256 ? new Uint8Array(indexCount) : new Uint16Array(indexCount);\n    }\n    typedArray = new Float32Array(typedArray.buffer, 0, vertexCount * stride);\n    let indexOut = 0;\n    for (i = 0; i < vertexCount - 2; ++i) {\n      indices[indexOut++] = centerIndex;\n      indices[indexOut++] = i;\n      indices[indexOut++] = i + 1;\n    }\n    indices[indexOut++] = centerIndex;\n    indices[indexOut++] = i;\n    indices[indexOut++] = 0;\n    const westIndicesSouthToNorth = [];\n    for (i = southwestIndex; i >= northwestIndex; --i) {\n      westIndicesSouthToNorth.push(i);\n    }\n    const southIndicesEastToWest = [];\n    for (i = southeastIndex; i >= southwestIndex; --i) {\n      southIndicesEastToWest.push(i);\n    }\n    const eastIndicesNorthToSouth = [];\n    for (i = northeastIndex; i >= southeastIndex; --i) {\n      eastIndicesNorthToSouth.push(i);\n    }\n    const northIndicesWestToEast = [];\n    northIndicesWestToEast.push(0);\n    for (i = centerIndex - 1; i >= northeastIndex; --i) {\n      northIndicesWestToEast.push(i);\n    }\n    fill.mesh = new TerrainMesh(encoding.center, typedArray, indices, indexCount, vertexCount, minimumHeight, maximumHeight, BoundingSphere.fromOrientedBoundingBox(obb), computeOccludeePoint(tileProvider, obb.center, rectangle, minimumHeight, maximumHeight), encoding.stride, obb, encoding, westIndicesSouthToNorth, southIndicesEastToWest, eastIndicesNorthToSouth, northIndicesWestToEast);\n  }\n  const context = frameState.context;\n  fill._destroyVertexArray(vertexArraysToDestroy);\n  fill.vertexArray = GlobeSurfaceTile._createVertexArrayForMesh(context, fill.mesh);\n  surfaceTile.processImagery(tile, tileProvider.terrainProvider, frameState, true);\n  const oldTexture = fill.waterMaskTexture;\n  fill.waterMaskTexture = undefined;\n  if (tileProvider.terrainProvider.hasWaterMask) {\n    const waterSourceTile = surfaceTile._findAncestorTileWithTerrainData(tile);\n    if (defined(waterSourceTile) && defined(waterSourceTile.data.waterMaskTexture)) {\n      fill.waterMaskTexture = waterSourceTile.data.waterMaskTexture;\n      ++fill.waterMaskTexture.referenceCount;\n      surfaceTile._computeWaterMaskTranslationAndScale(tile, waterSourceTile, fill.waterMaskTranslationAndScale);\n    }\n  }\n  if (defined(oldTexture)) {\n    --oldTexture.referenceCount;\n    if (oldTexture.referenceCount === 0) {\n      oldTexture.destroy();\n    }\n  }\n}\nfunction addVertexWithComputedPosition(ellipsoid, rectangle, encoding, buffer, index, u, v, height, encodedNormal, webMercatorT, heightRange) {\n  const cartographic = cartographicScratch;\n  cartographic.longitude = CesiumMath.lerp(rectangle.west, rectangle.east, u);\n  cartographic.latitude = CesiumMath.lerp(rectangle.south, rectangle.north, v);\n  cartographic.height = height;\n  const position = ellipsoid.cartographicToCartesian(cartographic, cartesianScratch);\n  let geodeticSurfaceNormal;\n  if (encoding.hasGeodeticSurfaceNormals) {\n    geodeticSurfaceNormal = ellipsoid.geodeticSurfaceNormal(position, normalScratch);\n  }\n  const uv = uvScratch2;\n  uv.x = u;\n  uv.y = v;\n  encoding.encode(buffer, index * encoding.stride, position, uv, height, encodedNormal, webMercatorT, geodeticSurfaceNormal);\n  heightRange.minimumHeight = Math.min(heightRange.minimumHeight, height);\n  heightRange.maximumHeight = Math.max(heightRange.maximumHeight, height);\n  return index + 1;\n}\nconst sourceRectangleScratch = new Rectangle();\nfunction transformTextureCoordinates(sourceTile, targetTile, coordinates, result) {\n  let sourceRectangle = sourceTile.rectangle;\n  const targetRectangle = targetTile.rectangle;\n\n  // Handle transforming across the anti-meridian.\n  if (targetTile.x === 0 && coordinates.x === 1.0 && sourceTile.x === sourceTile.tilingScheme.getNumberOfXTilesAtLevel(sourceTile.level) - 1) {\n    sourceRectangle = Rectangle.clone(sourceTile.rectangle, sourceRectangleScratch);\n    sourceRectangle.west -= CesiumMath.TWO_PI;\n    sourceRectangle.east -= CesiumMath.TWO_PI;\n  } else if (sourceTile.x === 0 && coordinates.x === 0.0 && targetTile.x === targetTile.tilingScheme.getNumberOfXTilesAtLevel(targetTile.level) - 1) {\n    sourceRectangle = Rectangle.clone(sourceTile.rectangle, sourceRectangleScratch);\n    sourceRectangle.west += CesiumMath.TWO_PI;\n    sourceRectangle.east += CesiumMath.TWO_PI;\n  }\n  const sourceWidth = sourceRectangle.east - sourceRectangle.west;\n  const umin = (targetRectangle.west - sourceRectangle.west) / sourceWidth;\n  const umax = (targetRectangle.east - sourceRectangle.west) / sourceWidth;\n  const sourceHeight = sourceRectangle.north - sourceRectangle.south;\n  const vmin = (targetRectangle.south - sourceRectangle.south) / sourceHeight;\n  const vmax = (targetRectangle.north - sourceRectangle.south) / sourceHeight;\n  let u = (coordinates.x - umin) / (umax - umin);\n  let v = (coordinates.y - vmin) / (vmax - vmin);\n\n  // Ensure that coordinates very near the corners are at the corners.\n  if (Math.abs(u) < Math.EPSILON5) {\n    u = 0.0;\n  } else if (Math.abs(u - 1.0) < Math.EPSILON5) {\n    u = 1.0;\n  }\n  if (Math.abs(v) < Math.EPSILON5) {\n    v = 0.0;\n  } else if (Math.abs(v - 1.0) < Math.EPSILON5) {\n    v = 1.0;\n  }\n  result.x = u;\n  result.y = v;\n  return result;\n}\nconst encodedNormalScratch = new Cartesian2();\nfunction getVertexFromTileAtCorner(sourceMesh, sourceIndex, u, v, vertex) {\n  const sourceEncoding = sourceMesh.encoding;\n  const sourceVertices = sourceMesh.vertices;\n  vertex.height = sourceEncoding.decodeHeight(sourceVertices, sourceIndex);\n  if (sourceEncoding.hasVertexNormals) {\n    sourceEncoding.getOctEncodedNormal(sourceVertices, sourceIndex, vertex.encodedNormal);\n  } else {\n    const normal = vertex.encodedNormal;\n    normal.x = 0.0;\n    normal.y = 0.0;\n  }\n}\nconst encodedNormalScratch2 = new Cartesian2();\nconst cartesianScratch2 = new Cartesian3();\nfunction getInterpolatedVertexAtCorner(ellipsoid, sourceTile, targetTile, sourceMesh, previousIndex, nextIndex, u, v, interpolateU, vertex) {\n  const sourceEncoding = sourceMesh.encoding;\n  const sourceVertices = sourceMesh.vertices;\n  const previousUv = transformTextureCoordinates(sourceTile, targetTile, sourceEncoding.decodeTextureCoordinates(sourceVertices, previousIndex, uvScratch), uvScratch);\n  const nextUv = transformTextureCoordinates(sourceTile, targetTile, sourceEncoding.decodeTextureCoordinates(sourceVertices, nextIndex, uvScratch2), uvScratch2);\n  let ratio;\n  if (interpolateU) {\n    ratio = (u - previousUv.x) / (nextUv.x - previousUv.x);\n  } else {\n    ratio = (v - previousUv.y) / (nextUv.y - previousUv.y);\n  }\n  const height1 = sourceEncoding.decodeHeight(sourceVertices, previousIndex);\n  const height2 = sourceEncoding.decodeHeight(sourceVertices, nextIndex);\n  const targetRectangle = targetTile.rectangle;\n  cartographicScratch.longitude = CesiumMath.lerp(targetRectangle.west, targetRectangle.east, u);\n  cartographicScratch.latitude = CesiumMath.lerp(targetRectangle.south, targetRectangle.north, v);\n  vertex.height = cartographicScratch.height = CesiumMath.lerp(height1, height2, ratio);\n  let normal;\n  if (sourceEncoding.hasVertexNormals) {\n    const encodedNormal1 = sourceEncoding.getOctEncodedNormal(sourceVertices, previousIndex, encodedNormalScratch);\n    const encodedNormal2 = sourceEncoding.getOctEncodedNormal(sourceVertices, nextIndex, encodedNormalScratch2);\n    const normal1 = AttributeCompression.octDecode(encodedNormal1.x, encodedNormal1.y, cartesianScratch);\n    const normal2 = AttributeCompression.octDecode(encodedNormal2.x, encodedNormal2.y, cartesianScratch2);\n    normal = Cartesian3.lerp(normal1, normal2, ratio, cartesianScratch);\n    Cartesian3.normalize(normal, normal);\n    AttributeCompression.octEncode(normal, vertex.encodedNormal);\n  } else {\n    normal = ellipsoid.geodeticSurfaceNormalCartographic(cartographicScratch, cartesianScratch);\n    AttributeCompression.octEncode(normal, vertex.encodedNormal);\n  }\n}\nfunction getVertexWithHeightAtCorner(terrainFillMesh, ellipsoid, u, v, height, vertex) {\n  vertex.height = height;\n  const normal = ellipsoid.geodeticSurfaceNormalCartographic(cartographicScratch, cartesianScratch);\n  AttributeCompression.octEncode(normal, vertex.encodedNormal);\n}\nfunction getCorner(terrainFillMesh, ellipsoid, u, v, cornerTile, cornerMesh, previousEdgeTiles, previousEdgeMeshes, nextEdgeTiles, nextEdgeMeshes, vertex) {\n  const gotCorner = getCornerFromEdge(terrainFillMesh, ellipsoid, previousEdgeMeshes, previousEdgeTiles, false, u, v, vertex) || getCornerFromEdge(terrainFillMesh, ellipsoid, nextEdgeMeshes, nextEdgeTiles, true, u, v, vertex);\n  if (gotCorner) {\n    return vertex;\n  }\n  let vertexIndex;\n  if (meshIsUsable(cornerTile, cornerMesh)) {\n    // Corner mesh is valid, copy its corner vertex to this mesh.\n    if (u === 0.0) {\n      if (v === 0.0) {\n        // southwest destination, northeast source\n        vertexIndex = cornerMesh.eastIndicesNorthToSouth[0];\n      } else {\n        // northwest destination, southeast source\n        vertexIndex = cornerMesh.southIndicesEastToWest[0];\n      }\n    } else if (v === 0.0) {\n      // southeast destination, northwest source\n      vertexIndex = cornerMesh.northIndicesWestToEast[0];\n    } else {\n      // northeast destination, southwest source\n      vertexIndex = cornerMesh.westIndicesSouthToNorth[0];\n    }\n    getVertexFromTileAtCorner(cornerMesh, vertexIndex, u, v, vertex);\n    return vertex;\n  }\n\n  // There is no precise vertex available from the corner or from either adjacent edge.\n  // This is either because there are no tiles at all at the edges and corner, or\n  // because the tiles at the edge are higher-level-number and don't extend all the way\n  // to the corner.\n  // Try to grab a height from the adjacent edges.\n  let height;\n  if (u === 0.0) {\n    if (v === 0.0) {\n      // southwest\n      height = getClosestHeightToCorner(terrainFillMesh.westMeshes, terrainFillMesh.westTiles, TileEdge.EAST, terrainFillMesh.southMeshes, terrainFillMesh.southTiles, TileEdge.NORTH, u, v);\n    } else {\n      // northwest\n      height = getClosestHeightToCorner(terrainFillMesh.northMeshes, terrainFillMesh.northTiles, TileEdge.SOUTH, terrainFillMesh.westMeshes, terrainFillMesh.westTiles, TileEdge.EAST, u, v);\n    }\n  } else if (v === 0.0) {\n    // southeast\n    height = getClosestHeightToCorner(terrainFillMesh.southMeshes, terrainFillMesh.southTiles, TileEdge.NORTH, terrainFillMesh.eastMeshes, terrainFillMesh.eastTiles, TileEdge.WEST, u, v);\n  } else {\n    // northeast\n    height = getClosestHeightToCorner(terrainFillMesh.eastMeshes, terrainFillMesh.eastTiles, TileEdge.WEST, terrainFillMesh.northMeshes, terrainFillMesh.northTiles, TileEdge.SOUTH, u, v);\n  }\n  if (defined(height)) {\n    getVertexWithHeightAtCorner(terrainFillMesh, ellipsoid, u, v, height, vertex);\n    return vertex;\n  }\n\n  // No heights available that are closer than the adjacent corners.\n  return undefined;\n}\nfunction getClosestHeightToCorner(previousMeshes, previousTiles, previousEdge, nextMeshes, nextTiles, nextEdge, u, v) {\n  const height1 = getNearestHeightOnEdge(previousMeshes, previousTiles, false, previousEdge, u, v);\n  const height2 = getNearestHeightOnEdge(nextMeshes, nextTiles, true, nextEdge, u, v);\n  if (defined(height1) && defined(height2)) {\n    // It would be slightly better to do a weighted average of the two heights\n    // based on their distance from the corner, but it shouldn't matter much in practice.\n    return (height1 + height2) * 0.5;\n  } else if (defined(height1)) {\n    return height1;\n  }\n  return height2;\n}\nfunction addEdge(terrainFillMesh, ellipsoid, encoding, typedArray, nextIndex, edgeTiles, edgeMeshes, tileEdge, heightRange) {\n  for (let i = 0; i < edgeTiles.length; ++i) {\n    nextIndex = addEdgeMesh(terrainFillMesh, ellipsoid, encoding, typedArray, nextIndex, edgeTiles[i], edgeMeshes[i], tileEdge, heightRange);\n  }\n  return nextIndex;\n}\nfunction addEdgeMesh(terrainFillMesh, ellipsoid, encoding, typedArray, nextIndex, edgeTile, edgeMesh, tileEdge, heightRange) {\n  // Handle copying edges across the anti-meridian.\n  let sourceRectangle = edgeTile.rectangle;\n  if (tileEdge === TileEdge.EAST && terrainFillMesh.tile.x === 0) {\n    sourceRectangle = Rectangle.clone(edgeTile.rectangle, sourceRectangleScratch);\n    sourceRectangle.west -= CesiumMath.TWO_PI;\n    sourceRectangle.east -= CesiumMath.TWO_PI;\n  } else if (tileEdge === TileEdge.WEST && edgeTile.x === 0) {\n    sourceRectangle = Rectangle.clone(edgeTile.rectangle, sourceRectangleScratch);\n    sourceRectangle.west += CesiumMath.TWO_PI;\n    sourceRectangle.east += CesiumMath.TWO_PI;\n  }\n  const targetRectangle = terrainFillMesh.tile.rectangle;\n  let lastU;\n  let lastV;\n  if (nextIndex > 0) {\n    encoding.decodeTextureCoordinates(typedArray, nextIndex - 1, uvScratch);\n    lastU = uvScratch.x;\n    lastV = uvScratch.y;\n  }\n  let indices;\n  let compareU;\n  switch (tileEdge) {\n    case TileEdge.WEST:\n      indices = edgeMesh.westIndicesSouthToNorth;\n      compareU = false;\n      break;\n    case TileEdge.NORTH:\n      indices = edgeMesh.northIndicesWestToEast;\n      compareU = true;\n      break;\n    case TileEdge.EAST:\n      indices = edgeMesh.eastIndicesNorthToSouth;\n      compareU = false;\n      break;\n    case TileEdge.SOUTH:\n      indices = edgeMesh.southIndicesEastToWest;\n      compareU = true;\n      break;\n  }\n  const sourceTile = edgeTile;\n  const targetTile = terrainFillMesh.tile;\n  const sourceEncoding = edgeMesh.encoding;\n  const sourceVertices = edgeMesh.vertices;\n  const targetStride = encoding.stride;\n  let southMercatorY;\n  let oneOverMercatorHeight;\n  if (sourceEncoding.hasWebMercatorT) {\n    southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(targetRectangle.south);\n    oneOverMercatorHeight = 1.0 / (WebMercatorProjection.geodeticLatitudeToMercatorAngle(targetRectangle.north) - southMercatorY);\n  }\n  for (let i = 0; i < indices.length; ++i) {\n    const index = indices[i];\n    const uv = sourceEncoding.decodeTextureCoordinates(sourceVertices, index, uvScratch);\n    transformTextureCoordinates(sourceTile, targetTile, uv, uv);\n    const u = uv.x;\n    const v = uv.y;\n    const uOrV = compareU ? u : v;\n    if (uOrV < 0.0 || uOrV > 1.0) {\n      // Vertex is outside the target tile - skip it.\n      continue;\n    }\n    if (Math.abs(u - lastU) < CesiumMath.EPSILON5 && Math.abs(v - lastV) < CesiumMath.EPSILON5) {\n      // Vertex is very close to the previous one - skip it.\n      continue;\n    }\n    const nearlyEdgeU = Math.abs(u) < CesiumMath.EPSILON5 || Math.abs(u - 1.0) < CesiumMath.EPSILON5;\n    const nearlyEdgeV = Math.abs(v) < CesiumMath.EPSILON5 || Math.abs(v - 1.0) < CesiumMath.EPSILON5;\n    if (nearlyEdgeU && nearlyEdgeV) {\n      // Corner vertex - skip it.\n      continue;\n    }\n    const position = sourceEncoding.decodePosition(sourceVertices, index, cartesianScratch);\n    const height = sourceEncoding.decodeHeight(sourceVertices, index);\n    let normal;\n    if (sourceEncoding.hasVertexNormals) {\n      normal = sourceEncoding.getOctEncodedNormal(sourceVertices, index, octEncodedNormalScratch);\n    } else {\n      normal = octEncodedNormalScratch;\n      normal.x = 0.0;\n      normal.y = 0.0;\n    }\n    let webMercatorT = v;\n    if (sourceEncoding.hasWebMercatorT) {\n      const latitude = CesiumMath.lerp(targetRectangle.south, targetRectangle.north, v);\n      webMercatorT = (WebMercatorProjection.geodeticLatitudeToMercatorAngle(latitude) - southMercatorY) * oneOverMercatorHeight;\n    }\n    let geodeticSurfaceNormal;\n    if (encoding.hasGeodeticSurfaceNormals) {\n      geodeticSurfaceNormal = ellipsoid.geodeticSurfaceNormal(position, normalScratch);\n    }\n    encoding.encode(typedArray, nextIndex * targetStride, position, uv, height, normal, webMercatorT, geodeticSurfaceNormal);\n    heightRange.minimumHeight = Math.min(heightRange.minimumHeight, height);\n    heightRange.maximumHeight = Math.max(heightRange.maximumHeight, height);\n    ++nextIndex;\n  }\n  return nextIndex;\n}\nfunction getNearestHeightOnEdge(meshes, tiles, isNext, edge, u, v) {\n  let meshStart;\n  let meshEnd;\n  let meshStep;\n  if (isNext) {\n    meshStart = 0;\n    meshEnd = meshes.length;\n    meshStep = 1;\n  } else {\n    meshStart = meshes.length - 1;\n    meshEnd = -1;\n    meshStep = -1;\n  }\n  for (let meshIndex = meshStart; meshIndex !== meshEnd; meshIndex += meshStep) {\n    const mesh = meshes[meshIndex];\n    const tile = tiles[meshIndex];\n    if (!meshIsUsable(tile, mesh)) {\n      continue;\n    }\n    let indices;\n    switch (edge) {\n      case TileEdge.WEST:\n        indices = mesh.westIndicesSouthToNorth;\n        break;\n      case TileEdge.SOUTH:\n        indices = mesh.southIndicesEastToWest;\n        break;\n      case TileEdge.EAST:\n        indices = mesh.eastIndicesNorthToSouth;\n        break;\n      case TileEdge.NORTH:\n        indices = mesh.northIndicesWestToEast;\n        break;\n    }\n    const index = indices[isNext ? 0 : indices.length - 1];\n    if (defined(index)) {\n      return mesh.encoding.decodeHeight(mesh.vertices, index);\n    }\n  }\n  return undefined;\n}\nfunction meshIsUsable(tile, mesh) {\n  return defined(mesh) && (!defined(tile.data.fill) || !tile.data.fill.changedThisFrame);\n}\nfunction getCornerFromEdge(terrainFillMesh, ellipsoid, edgeMeshes, edgeTiles, isNext, u, v, vertex) {\n  let edgeVertices;\n  let compareU;\n  let increasing;\n  let vertexIndexIndex;\n  let vertexIndex;\n  const sourceTile = edgeTiles[isNext ? 0 : edgeMeshes.length - 1];\n  const sourceMesh = edgeMeshes[isNext ? 0 : edgeMeshes.length - 1];\n  if (meshIsUsable(sourceTile, sourceMesh)) {\n    // Previous mesh is valid, but we don't know yet if it covers this corner.\n    if (u === 0.0) {\n      if (v === 0.0) {\n        // southwest\n        edgeVertices = isNext ? sourceMesh.northIndicesWestToEast : sourceMesh.eastIndicesNorthToSouth;\n        compareU = isNext;\n        increasing = isNext;\n      } else {\n        // northwest\n        edgeVertices = isNext ? sourceMesh.eastIndicesNorthToSouth : sourceMesh.southIndicesEastToWest;\n        compareU = !isNext;\n        increasing = false;\n      }\n    } else if (v === 0.0) {\n      // southeast\n      edgeVertices = isNext ? sourceMesh.westIndicesSouthToNorth : sourceMesh.northIndicesWestToEast;\n      compareU = !isNext;\n      increasing = true;\n    } else {\n      // northeast\n      edgeVertices = isNext ? sourceMesh.southIndicesEastToWest : sourceMesh.westIndicesSouthToNorth;\n      compareU = isNext;\n      increasing = !isNext;\n    }\n    if (edgeVertices.length > 0) {\n      // The vertex we want will very often be the first/last vertex so check that first.\n      vertexIndexIndex = isNext ? 0 : edgeVertices.length - 1;\n      vertexIndex = edgeVertices[vertexIndexIndex];\n      sourceMesh.encoding.decodeTextureCoordinates(sourceMesh.vertices, vertexIndex, uvScratch);\n      const targetUv = transformTextureCoordinates(sourceTile, terrainFillMesh.tile, uvScratch, uvScratch);\n      if (targetUv.x === u && targetUv.y === v) {\n        // Vertex is good!\n        getVertexFromTileAtCorner(sourceMesh, vertexIndex, u, v, vertex);\n        return true;\n      }\n\n      // The last vertex is not the one we need, try binary searching for the right one.\n      vertexIndexIndex = binarySearch(edgeVertices, compareU ? u : v, function (vertexIndex, textureCoordinate) {\n        sourceMesh.encoding.decodeTextureCoordinates(sourceMesh.vertices, vertexIndex, uvScratch);\n        const targetUv = transformTextureCoordinates(sourceTile, terrainFillMesh.tile, uvScratch, uvScratch);\n        if (increasing) {\n          if (compareU) {\n            return targetUv.x - u;\n          }\n          return targetUv.y - v;\n        } else if (compareU) {\n          return u - targetUv.x;\n        }\n        return v - targetUv.y;\n      });\n      if (vertexIndexIndex < 0) {\n        vertexIndexIndex = ~vertexIndexIndex;\n        if (vertexIndexIndex > 0 && vertexIndexIndex < edgeVertices.length) {\n          // The corner falls between two vertices, so interpolate between them.\n          getInterpolatedVertexAtCorner(ellipsoid, sourceTile, terrainFillMesh.tile, sourceMesh, edgeVertices[vertexIndexIndex - 1], edgeVertices[vertexIndexIndex], u, v, compareU, vertex);\n          return true;\n        }\n      } else {\n        // Found a vertex that fits in the corner exactly.\n        getVertexFromTileAtCorner(sourceMesh, edgeVertices[vertexIndexIndex], u, v, vertex);\n        return true;\n      }\n    }\n  }\n  return false;\n}\nconst cornerPositionsScratch = [new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3()];\nfunction computeOccludeePoint(tileProvider, center, rectangle, minimumHeight, maximumHeight, result) {\n  const ellipsoidalOccluder = tileProvider.quadtree._occluders.ellipsoid;\n  const ellipsoid = ellipsoidalOccluder.ellipsoid;\n  const cornerPositions = cornerPositionsScratch;\n  Cartesian3.fromRadians(rectangle.west, rectangle.south, maximumHeight, ellipsoid, cornerPositions[0]);\n  Cartesian3.fromRadians(rectangle.east, rectangle.south, maximumHeight, ellipsoid, cornerPositions[1]);\n  Cartesian3.fromRadians(rectangle.west, rectangle.north, maximumHeight, ellipsoid, cornerPositions[2]);\n  Cartesian3.fromRadians(rectangle.east, rectangle.north, maximumHeight, ellipsoid, cornerPositions[3]);\n  return ellipsoidalOccluder.computeHorizonCullingPointPossiblyUnderEllipsoid(center, cornerPositions, minimumHeight, result);\n}\nexport default TerrainFillMesh;","map":{"version":3,"names":["AttributeCompression","binarySearch","BoundingSphere","Cartesian2","Cartesian3","Cartesian4","Cartographic","defined","DeveloperError","HeightmapTerrainData","CesiumMath","OrientedBoundingBox","Queue","Rectangle","TerrainEncoding","TerrainMesh","TileEdge","WebMercatorProjection","GlobeSurfaceTile","TileSelectionResult","TerrainFillMesh","tile","frameLastUpdated","undefined","westMeshes","westTiles","southMeshes","southTiles","eastMeshes","eastTiles","northMeshes","northTiles","southwestMesh","southwestTile","southeastMesh","southeastTile","northwestMesh","northwestTile","northeastMesh","northeastTile","changedThisFrame","visitedFrame","enqueuedFrame","mesh","vertexArray","waterMaskTexture","waterMaskTranslationAndScale","prototype","update","tileProvider","frameState","vertexArraysToDestroy","createFillMesh","destroy","_destroyVertexArray","referenceCount","push","_freeVertexArray","traversalQueueScratch","updateFillTiles","renderedTiles","quadtree","_quadtree","levelZeroTiles","_levelZeroTiles","lastSelectionFrameNumber","_lastSelectionFrameNumber","traversalQueue","clear","i","length","renderedTile","data","enqueue","dequeue","tileToWest","findTileToWest","tileToSouth","findTileToSouth","tileToEast","findTileToEast","tileToNorth","findTileToNorth","visitRenderedTiles","EAST","NORTH","WEST","SOUTH","tileToNorthwest","tileToSouthwest","tileToNortheast","tileToSoutheast","SOUTHEAST","SOUTHWEST","NORTHEAST","NORTHWEST","sourceTile","startTile","currentFrameNumber","tileEdge","downOnly","_lastSelectionResultFrame","wasKicked","_lastSelectionResult","originalResult","CULLED","parent","northwestChild","northeastChild","southwestChild","southeastChild","RENDERED","visitTile","destinationTile","frameNumber","destinationSurfaceTile","fill","propagateEdge","destinationFill","sourceMesh","sourceFill","edgeMeshes","edgeTiles","level","startIndex","endIndex","existingTile","existingRectangle","sourceRectangle","rectangle","epsilon","destinationRectangle","north","south","EPSILON5","greaterThan","greaterThanOrEquals","east","west","lessThan","lessThanOrEquals","splice","cartographicScratch","centerCartographicScratch","cartesianScratch","normalScratch","octEncodedNormalScratch","uvScratch2","uvScratch","HeightAndNormal","height","encodedNormal","fillMissingCorner","ellipsoid","u","v","corner","adjacentCorner1","adjacentCorner2","oppositeCorner","vertex","surfaceTile","tileBoundingRegion","minimumHeight","maximumHeight","getVertexWithHeightAtCorner","heightRangeScratch","scratchCenter","swVertexScratch","seVertexScratch","nwVertexScratch","neVertexScratch","heightmapBuffer","Uint8Array","scratchCreateMeshSyncOptions","tilingScheme","x","y","exaggeration","exaggerationRelativeHeight","initialize","terrainProvider","_imageryLayers","verticalExaggeration","verticalExaggerationRelativeHeight","hasExaggeration","nwCorner","getCorner","swCorner","seCorner","neCorner","southwestHeight","southeastHeight","northwestHeight","northeastHeight","Math","min","max","middleHeight","len","geometricError","getLevelMaximumGeometricError","minCutThroughRadius","maximumRadius","maxTileWidth","acos","width","terrainData","buffer","structure","heightOffset","createMeshSyncOptions","_createMeshSync","hasGeodeticSurfaceNormals","centerCartographic","center","cartographicToCartesian","encoding","maxVertexCount","meshes","eastIndicesNorthToSouth","northIndicesWestToEast","westIndicesSouthToNorth","southIndicesEastToWest","heightRange","stride","typedArray","Float32Array","nextIndex","northwestIndex","addVertexWithComputedPosition","addEdge","southwestIndex","southeastIndex","northeastIndex","obb","fromRectangle","southMercatorY","geodeticLatitudeToMercatorAngle","oneOverMercatorHeight","centerWebMercatorT","latitude","geodeticSurfaceNormal","geodeticSurfaceNormalCartographic","centerEncodedNormal","octEncode","centerIndex","encode","fromElements","vertexCount","bytesPerIndex","indexCount","indexDataBytes","availableBytesInBuffer","BYTES_PER_ELEMENT","indices","Uint16Array","indexOut","fromOrientedBoundingBox","computeOccludeePoint","context","_createVertexArrayForMesh","processImagery","oldTexture","hasWaterMask","waterSourceTile","_findAncestorTileWithTerrainData","_computeWaterMaskTranslationAndScale","index","webMercatorT","cartographic","longitude","lerp","position","uv","sourceRectangleScratch","transformTextureCoordinates","targetTile","coordinates","result","targetRectangle","getNumberOfXTilesAtLevel","clone","TWO_PI","sourceWidth","umin","umax","sourceHeight","vmin","vmax","abs","encodedNormalScratch","getVertexFromTileAtCorner","sourceIndex","sourceEncoding","sourceVertices","vertices","decodeHeight","hasVertexNormals","getOctEncodedNormal","normal","encodedNormalScratch2","cartesianScratch2","getInterpolatedVertexAtCorner","previousIndex","interpolateU","previousUv","decodeTextureCoordinates","nextUv","ratio","height1","height2","encodedNormal1","encodedNormal2","normal1","octDecode","normal2","normalize","terrainFillMesh","cornerTile","cornerMesh","previousEdgeTiles","previousEdgeMeshes","nextEdgeTiles","nextEdgeMeshes","gotCorner","getCornerFromEdge","vertexIndex","meshIsUsable","getClosestHeightToCorner","previousMeshes","previousTiles","previousEdge","nextMeshes","nextTiles","nextEdge","getNearestHeightOnEdge","addEdgeMesh","edgeTile","edgeMesh","lastU","lastV","compareU","targetStride","hasWebMercatorT","uOrV","nearlyEdgeU","nearlyEdgeV","decodePosition","tiles","isNext","edge","meshStart","meshEnd","meshStep","meshIndex","edgeVertices","increasing","vertexIndexIndex","targetUv","textureCoordinate","cornerPositionsScratch","ellipsoidalOccluder","_occluders","cornerPositions","fromRadians","computeHorizonCullingPointPossiblyUnderEllipsoid"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/TerrainFillMesh.js"],"sourcesContent":["import AttributeCompression from \"../Core/AttributeCompression.js\";\nimport binarySearch from \"../Core/binarySearch.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport HeightmapTerrainData from \"../Core/HeightmapTerrainData.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Queue from \"../Core/Queue.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport TerrainEncoding from \"../Core/TerrainEncoding.js\";\nimport TerrainMesh from \"../Core/TerrainMesh.js\";\nimport TileEdge from \"../Core/TileEdge.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport GlobeSurfaceTile from \"./GlobeSurfaceTile.js\";\nimport TileSelectionResult from \"./TileSelectionResult.js\";\n\nfunction TerrainFillMesh(tile) {\n  this.tile = tile;\n  this.frameLastUpdated = undefined;\n  this.westMeshes = []; // north to south (CCW)\n  this.westTiles = [];\n  this.southMeshes = []; // west to east (CCW)\n  this.southTiles = [];\n  this.eastMeshes = []; // south to north (CCW)\n  this.eastTiles = [];\n  this.northMeshes = []; // east to west (CCW)\n  this.northTiles = [];\n  this.southwestMesh = undefined;\n  this.southwestTile = undefined;\n  this.southeastMesh = undefined;\n  this.southeastTile = undefined;\n  this.northwestMesh = undefined;\n  this.northwestTile = undefined;\n  this.northeastMesh = undefined;\n  this.northeastTile = undefined;\n  this.changedThisFrame = true;\n  this.visitedFrame = undefined;\n  this.enqueuedFrame = undefined;\n  this.mesh = undefined;\n  this.vertexArray = undefined;\n  this.waterMaskTexture = undefined;\n  this.waterMaskTranslationAndScale = new Cartesian4();\n}\n\nTerrainFillMesh.prototype.update = function (\n  tileProvider,\n  frameState,\n  vertexArraysToDestroy,\n) {\n  if (this.changedThisFrame) {\n    createFillMesh(tileProvider, frameState, this.tile, vertexArraysToDestroy);\n    this.changedThisFrame = false;\n  }\n};\n\nTerrainFillMesh.prototype.destroy = function (vertexArraysToDestroy) {\n  this._destroyVertexArray(vertexArraysToDestroy);\n\n  if (defined(this.waterMaskTexture)) {\n    --this.waterMaskTexture.referenceCount;\n    if (this.waterMaskTexture.referenceCount === 0) {\n      this.waterMaskTexture.destroy();\n    }\n    this.waterMaskTexture = undefined;\n  }\n\n  return undefined;\n};\n\nTerrainFillMesh.prototype._destroyVertexArray = function (\n  vertexArraysToDestroy,\n) {\n  if (defined(this.vertexArray)) {\n    if (defined(vertexArraysToDestroy)) {\n      vertexArraysToDestroy.push(this.vertexArray);\n    } else {\n      GlobeSurfaceTile._freeVertexArray(this.vertexArray);\n    }\n    this.vertexArray = undefined;\n  }\n};\n\nconst traversalQueueScratch = new Queue();\n\nTerrainFillMesh.updateFillTiles = function (\n  tileProvider,\n  renderedTiles,\n  frameState,\n  vertexArraysToDestroy,\n) {\n  // We want our fill tiles to look natural, which means they should align perfectly with\n  // adjacent loaded tiles, and their edges that are not adjacent to loaded tiles should have\n  // sensible heights (e.g. the average of the heights of loaded edges). Some fill tiles may\n  // be adjacent only to other fill tiles, and in that case heights should be assigned fanning\n  // outward from the loaded tiles so that there are no sudden changes in height.\n\n  // We do this with a breadth-first traversal of the rendered tiles, starting with the loaded\n  // ones. Graph nodes are tiles and graph edges connect to other rendered tiles that are spatially adjacent\n  // to those tiles. As we visit each node, we propagate tile edges to adjacent tiles. If there's no data\n  // for a tile edge,  we create an edge with an average height and then propagate it. If an edge is partially defined\n  // (e.g. an edge is adjacent to multiple more-detailed tiles and only some of them are loaded), we\n  // fill in the rest of the edge with the same height.\n  const quadtree = tileProvider._quadtree;\n  const levelZeroTiles = quadtree._levelZeroTiles;\n  const lastSelectionFrameNumber = quadtree._lastSelectionFrameNumber;\n\n  const traversalQueue = traversalQueueScratch;\n  traversalQueue.clear();\n\n  // Add the tiles with real geometry to the traversal queue.\n  for (let i = 0; i < renderedTiles.length; ++i) {\n    const renderedTile = renderedTiles[i];\n    if (defined(renderedTile.data.vertexArray)) {\n      traversalQueue.enqueue(renderedTiles[i]);\n    }\n  }\n\n  let tile = traversalQueue.dequeue();\n\n  while (tile !== undefined) {\n    const tileToWest = tile.findTileToWest(levelZeroTiles);\n    const tileToSouth = tile.findTileToSouth(levelZeroTiles);\n    const tileToEast = tile.findTileToEast(levelZeroTiles);\n    const tileToNorth = tile.findTileToNorth(levelZeroTiles);\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToWest,\n      lastSelectionFrameNumber,\n      TileEdge.EAST,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy,\n    );\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToSouth,\n      lastSelectionFrameNumber,\n      TileEdge.NORTH,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy,\n    );\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToEast,\n      lastSelectionFrameNumber,\n      TileEdge.WEST,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy,\n    );\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToNorth,\n      lastSelectionFrameNumber,\n      TileEdge.SOUTH,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy,\n    );\n\n    const tileToNorthwest = tileToWest.findTileToNorth(levelZeroTiles);\n    const tileToSouthwest = tileToWest.findTileToSouth(levelZeroTiles);\n    const tileToNortheast = tileToEast.findTileToNorth(levelZeroTiles);\n    const tileToSoutheast = tileToEast.findTileToSouth(levelZeroTiles);\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToNorthwest,\n      lastSelectionFrameNumber,\n      TileEdge.SOUTHEAST,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy,\n    );\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToNortheast,\n      lastSelectionFrameNumber,\n      TileEdge.SOUTHWEST,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy,\n    );\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToSouthwest,\n      lastSelectionFrameNumber,\n      TileEdge.NORTHEAST,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy,\n    );\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToSoutheast,\n      lastSelectionFrameNumber,\n      TileEdge.NORTHWEST,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy,\n    );\n\n    tile = traversalQueue.dequeue();\n  }\n};\n\nfunction visitRenderedTiles(\n  tileProvider,\n  frameState,\n  sourceTile,\n  startTile,\n  currentFrameNumber,\n  tileEdge,\n  downOnly,\n  traversalQueue,\n  vertexArraysToDestroy,\n) {\n  if (startTile === undefined) {\n    // There are no tiles North or South of the poles.\n    return;\n  }\n\n  let tile = startTile;\n  while (\n    tile &&\n    (tile._lastSelectionResultFrame !== currentFrameNumber ||\n      TileSelectionResult.wasKicked(tile._lastSelectionResult) ||\n      TileSelectionResult.originalResult(tile._lastSelectionResult) ===\n        TileSelectionResult.CULLED)\n  ) {\n    // This tile wasn't visited or it was visited and then kicked, so walk up to find the closest ancestor that was rendered.\n    // We also walk up if the tile was culled, because if siblings were kicked an ancestor may have been rendered.\n    if (downOnly) {\n      return;\n    }\n\n    const parent = tile.parent;\n    if (tileEdge >= TileEdge.NORTHWEST && parent !== undefined) {\n      // When we're looking for a corner, verify that the parent tile is still relevant.\n      // That is, the parent and child must share the corner in question.\n      switch (tileEdge) {\n        case TileEdge.NORTHWEST:\n          tile = tile === parent.northwestChild ? parent : undefined;\n          break;\n        case TileEdge.NORTHEAST:\n          tile = tile === parent.northeastChild ? parent : undefined;\n          break;\n        case TileEdge.SOUTHWEST:\n          tile = tile === parent.southwestChild ? parent : undefined;\n          break;\n        case TileEdge.SOUTHEAST:\n          tile = tile === parent.southeastChild ? parent : undefined;\n          break;\n      }\n    } else {\n      tile = parent;\n    }\n  }\n\n  if (tile === undefined) {\n    return;\n  }\n\n  if (tile._lastSelectionResult === TileSelectionResult.RENDERED) {\n    if (defined(tile.data.vertexArray)) {\n      // No further processing necessary for renderable tiles.\n      return;\n    }\n    visitTile(\n      tileProvider,\n      frameState,\n      sourceTile,\n      tile,\n      tileEdge,\n      currentFrameNumber,\n      traversalQueue,\n      vertexArraysToDestroy,\n    );\n    return;\n  }\n\n  if (\n    TileSelectionResult.originalResult(startTile._lastSelectionResult) ===\n    TileSelectionResult.CULLED\n  ) {\n    return;\n  }\n\n  // This tile was refined, so find rendered children, if any.\n  // Visit the tiles in counter-clockwise order.\n  switch (tileEdge) {\n    case TileEdge.WEST:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.northwestChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy,\n      );\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.southwestChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy,\n      );\n      break;\n    case TileEdge.EAST:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.southeastChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy,\n      );\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.northeastChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy,\n      );\n      break;\n    case TileEdge.SOUTH:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.southwestChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy,\n      );\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.southeastChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy,\n      );\n      break;\n    case TileEdge.NORTH:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.northeastChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy,\n      );\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.northwestChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy,\n      );\n      break;\n    case TileEdge.NORTHWEST:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.northwestChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy,\n      );\n      break;\n    case TileEdge.NORTHEAST:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.northeastChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy,\n      );\n      break;\n    case TileEdge.SOUTHWEST:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.southwestChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy,\n      );\n      break;\n    case TileEdge.SOUTHEAST:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.southeastChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy,\n      );\n      break;\n    default:\n      throw new DeveloperError(\"Invalid edge\");\n  }\n}\n\nfunction visitTile(\n  tileProvider,\n  frameState,\n  sourceTile,\n  destinationTile,\n  tileEdge,\n  frameNumber,\n  traversalQueue,\n  vertexArraysToDestroy,\n) {\n  const destinationSurfaceTile = destinationTile.data;\n\n  if (destinationSurfaceTile.fill === undefined) {\n    destinationSurfaceTile.fill = new TerrainFillMesh(destinationTile);\n  } else if (destinationSurfaceTile.fill.visitedFrame === frameNumber) {\n    // Don't propagate edges to tiles that have already been visited this frame.\n    return;\n  }\n\n  if (destinationSurfaceTile.fill.enqueuedFrame !== frameNumber) {\n    // First time visiting this tile this frame, add it to the traversal queue.\n    destinationSurfaceTile.fill.enqueuedFrame = frameNumber;\n    destinationSurfaceTile.fill.changedThisFrame = false;\n    traversalQueue.enqueue(destinationTile);\n  }\n\n  propagateEdge(\n    tileProvider,\n    frameState,\n    sourceTile,\n    destinationTile,\n    tileEdge,\n    vertexArraysToDestroy,\n  );\n}\n\nfunction propagateEdge(\n  tileProvider,\n  frameState,\n  sourceTile,\n  destinationTile,\n  tileEdge,\n  vertexArraysToDestroy,\n) {\n  const destinationFill = destinationTile.data.fill;\n\n  let sourceMesh;\n  const sourceFill = sourceTile.data.fill;\n  if (defined(sourceFill)) {\n    sourceFill.visitedFrame = frameState.frameNumber;\n\n    // Source is a fill, create/update it if necessary.\n    if (sourceFill.changedThisFrame) {\n      createFillMesh(\n        tileProvider,\n        frameState,\n        sourceTile,\n        vertexArraysToDestroy,\n      );\n      sourceFill.changedThisFrame = false;\n    }\n    sourceMesh = sourceTile.data.fill.mesh;\n  } else {\n    sourceMesh = sourceTile.data.mesh;\n  }\n\n  let edgeMeshes;\n  let edgeTiles;\n\n  switch (tileEdge) {\n    case TileEdge.WEST:\n      edgeMeshes = destinationFill.westMeshes;\n      edgeTiles = destinationFill.westTiles;\n      break;\n    case TileEdge.SOUTH:\n      edgeMeshes = destinationFill.southMeshes;\n      edgeTiles = destinationFill.southTiles;\n      break;\n    case TileEdge.EAST:\n      edgeMeshes = destinationFill.eastMeshes;\n      edgeTiles = destinationFill.eastTiles;\n      break;\n    case TileEdge.NORTH:\n      edgeMeshes = destinationFill.northMeshes;\n      edgeTiles = destinationFill.northTiles;\n      break;\n    // Corners are simpler.\n    case TileEdge.NORTHWEST:\n      destinationFill.changedThisFrame =\n        destinationFill.changedThisFrame ||\n        destinationFill.northwestMesh !== sourceMesh;\n      destinationFill.northwestMesh = sourceMesh;\n      destinationFill.northwestTile = sourceTile;\n      return;\n    case TileEdge.NORTHEAST:\n      destinationFill.changedThisFrame =\n        destinationFill.changedThisFrame ||\n        destinationFill.northeastMesh !== sourceMesh;\n      destinationFill.northeastMesh = sourceMesh;\n      destinationFill.northeastTile = sourceTile;\n      return;\n    case TileEdge.SOUTHWEST:\n      destinationFill.changedThisFrame =\n        destinationFill.changedThisFrame ||\n        destinationFill.southwestMesh !== sourceMesh;\n      destinationFill.southwestMesh = sourceMesh;\n      destinationFill.southwestTile = sourceTile;\n      return;\n    case TileEdge.SOUTHEAST:\n      destinationFill.changedThisFrame =\n        destinationFill.changedThisFrame ||\n        destinationFill.southeastMesh !== sourceMesh;\n      destinationFill.southeastMesh = sourceMesh;\n      destinationFill.southeastTile = sourceTile;\n      return;\n  }\n\n  if (sourceTile.level <= destinationTile.level) {\n    // Source edge completely spans the destination edge.\n    destinationFill.changedThisFrame =\n      destinationFill.changedThisFrame ||\n      edgeMeshes[0] !== sourceMesh ||\n      edgeMeshes.length !== 1;\n    edgeMeshes[0] = sourceMesh;\n    edgeTiles[0] = sourceTile;\n    edgeMeshes.length = 1;\n    edgeTiles.length = 1;\n    return;\n  }\n\n  // Source edge is a subset of the destination edge.\n  // Figure out the range of meshes we're replacing.\n  let startIndex, endIndex, existingTile, existingRectangle;\n  const sourceRectangle = sourceTile.rectangle;\n\n  let epsilon;\n  const destinationRectangle = destinationTile.rectangle;\n\n  switch (tileEdge) {\n    case TileEdge.WEST:\n      epsilon =\n        (destinationRectangle.north - destinationRectangle.south) *\n        CesiumMath.EPSILON5;\n\n      for (startIndex = 0; startIndex < edgeTiles.length; ++startIndex) {\n        existingTile = edgeTiles[startIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.greaterThan(\n            sourceRectangle.north,\n            existingRectangle.south,\n            epsilon,\n          )\n        ) {\n          break;\n        }\n      }\n      for (endIndex = startIndex; endIndex < edgeTiles.length; ++endIndex) {\n        existingTile = edgeTiles[endIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.greaterThanOrEquals(\n            sourceRectangle.south,\n            existingRectangle.north,\n            epsilon,\n          )\n        ) {\n          break;\n        }\n      }\n      break;\n    case TileEdge.SOUTH:\n      epsilon =\n        (destinationRectangle.east - destinationRectangle.west) *\n        CesiumMath.EPSILON5;\n\n      for (startIndex = 0; startIndex < edgeTiles.length; ++startIndex) {\n        existingTile = edgeTiles[startIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.lessThan(\n            sourceRectangle.west,\n            existingRectangle.east,\n            epsilon,\n          )\n        ) {\n          break;\n        }\n      }\n      for (endIndex = startIndex; endIndex < edgeTiles.length; ++endIndex) {\n        existingTile = edgeTiles[endIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.lessThanOrEquals(\n            sourceRectangle.east,\n            existingRectangle.west,\n            epsilon,\n          )\n        ) {\n          break;\n        }\n      }\n      break;\n    case TileEdge.EAST:\n      epsilon =\n        (destinationRectangle.north - destinationRectangle.south) *\n        CesiumMath.EPSILON5;\n\n      for (startIndex = 0; startIndex < edgeTiles.length; ++startIndex) {\n        existingTile = edgeTiles[startIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.lessThan(\n            sourceRectangle.south,\n            existingRectangle.north,\n            epsilon,\n          )\n        ) {\n          break;\n        }\n      }\n      for (endIndex = startIndex; endIndex < edgeTiles.length; ++endIndex) {\n        existingTile = edgeTiles[endIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.lessThanOrEquals(\n            sourceRectangle.north,\n            existingRectangle.south,\n            epsilon,\n          )\n        ) {\n          break;\n        }\n      }\n      break;\n    case TileEdge.NORTH:\n      epsilon =\n        (destinationRectangle.east - destinationRectangle.west) *\n        CesiumMath.EPSILON5;\n\n      for (startIndex = 0; startIndex < edgeTiles.length; ++startIndex) {\n        existingTile = edgeTiles[startIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.greaterThan(\n            sourceRectangle.east,\n            existingRectangle.west,\n            epsilon,\n          )\n        ) {\n          break;\n        }\n      }\n      for (endIndex = startIndex; endIndex < edgeTiles.length; ++endIndex) {\n        existingTile = edgeTiles[endIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.greaterThanOrEquals(\n            sourceRectangle.west,\n            existingRectangle.east,\n            epsilon,\n          )\n        ) {\n          break;\n        }\n      }\n      break;\n  }\n\n  if (endIndex - startIndex === 1) {\n    destinationFill.changedThisFrame =\n      destinationFill.changedThisFrame || edgeMeshes[startIndex] !== sourceMesh;\n    edgeMeshes[startIndex] = sourceMesh;\n    edgeTiles[startIndex] = sourceTile;\n  } else {\n    destinationFill.changedThisFrame = true;\n    edgeMeshes.splice(startIndex, endIndex - startIndex, sourceMesh);\n    edgeTiles.splice(startIndex, endIndex - startIndex, sourceTile);\n  }\n}\n\nconst cartographicScratch = new Cartographic();\nconst centerCartographicScratch = new Cartographic();\nconst cartesianScratch = new Cartesian3();\nconst normalScratch = new Cartesian3();\nconst octEncodedNormalScratch = new Cartesian2();\nconst uvScratch2 = new Cartesian2();\nconst uvScratch = new Cartesian2();\n\nfunction HeightAndNormal() {\n  this.height = 0.0;\n  this.encodedNormal = new Cartesian2();\n}\n\nfunction fillMissingCorner(\n  fill,\n  ellipsoid,\n  u,\n  v,\n  corner,\n  adjacentCorner1,\n  adjacentCorner2,\n  oppositeCorner,\n  vertex,\n) {\n  if (defined(corner)) {\n    return corner;\n  }\n\n  let height;\n\n  if (defined(adjacentCorner1) && defined(adjacentCorner2)) {\n    height = (adjacentCorner1.height + adjacentCorner2.height) * 0.5;\n  } else if (defined(adjacentCorner1)) {\n    height = adjacentCorner1.height;\n  } else if (defined(adjacentCorner2)) {\n    height = adjacentCorner2.height;\n  } else if (defined(oppositeCorner)) {\n    height = oppositeCorner.height;\n  } else {\n    const surfaceTile = fill.tile.data;\n    const tileBoundingRegion = surfaceTile.tileBoundingRegion;\n    let minimumHeight = 0.0;\n    let maximumHeight = 0.0;\n    if (defined(tileBoundingRegion)) {\n      minimumHeight = tileBoundingRegion.minimumHeight;\n      maximumHeight = tileBoundingRegion.maximumHeight;\n    }\n    height = (minimumHeight + maximumHeight) * 0.5;\n  }\n\n  getVertexWithHeightAtCorner(fill, ellipsoid, u, v, height, vertex);\n  return vertex;\n}\n\nconst heightRangeScratch = {\n  minimumHeight: 0.0,\n  maximumHeight: 0.0,\n};\n\nconst scratchCenter = new Cartesian3();\nconst swVertexScratch = new HeightAndNormal();\nconst seVertexScratch = new HeightAndNormal();\nconst nwVertexScratch = new HeightAndNormal();\nconst neVertexScratch = new HeightAndNormal();\nconst heightmapBuffer =\n  typeof Uint8Array !== \"undefined\" ? new Uint8Array(9 * 9) : undefined;\n\nconst scratchCreateMeshSyncOptions = {\n  tilingScheme: undefined,\n  x: 0,\n  y: 0,\n  level: 0,\n  exaggeration: 1.0,\n  exaggerationRelativeHeight: 0.0,\n};\nfunction createFillMesh(tileProvider, frameState, tile, vertexArraysToDestroy) {\n  GlobeSurfaceTile.initialize(\n    tile,\n    tileProvider.terrainProvider,\n    tileProvider._imageryLayers,\n  );\n\n  const surfaceTile = tile.data;\n  const fill = surfaceTile.fill;\n  const rectangle = tile.rectangle;\n\n  const exaggeration = frameState.verticalExaggeration;\n  const exaggerationRelativeHeight =\n    frameState.verticalExaggerationRelativeHeight;\n  const hasExaggeration = exaggeration !== 1.0;\n\n  const ellipsoid = tile.tilingScheme.ellipsoid;\n\n  let nwCorner = getCorner(\n    fill,\n    ellipsoid,\n    0.0,\n    1.0,\n    fill.northwestTile,\n    fill.northwestMesh,\n    fill.northTiles,\n    fill.northMeshes,\n    fill.westTiles,\n    fill.westMeshes,\n    nwVertexScratch,\n  );\n  let swCorner = getCorner(\n    fill,\n    ellipsoid,\n    0.0,\n    0.0,\n    fill.southwestTile,\n    fill.southwestMesh,\n    fill.westTiles,\n    fill.westMeshes,\n    fill.southTiles,\n    fill.southMeshes,\n    swVertexScratch,\n  );\n  let seCorner = getCorner(\n    fill,\n    ellipsoid,\n    1.0,\n    0.0,\n    fill.southeastTile,\n    fill.southeastMesh,\n    fill.southTiles,\n    fill.southMeshes,\n    fill.eastTiles,\n    fill.eastMeshes,\n    seVertexScratch,\n  );\n  let neCorner = getCorner(\n    fill,\n    ellipsoid,\n    1.0,\n    1.0,\n    fill.northeastTile,\n    fill.northeastMesh,\n    fill.eastTiles,\n    fill.eastMeshes,\n    fill.northTiles,\n    fill.northMeshes,\n    neVertexScratch,\n  );\n\n  nwCorner = fillMissingCorner(\n    fill,\n    ellipsoid,\n    0.0,\n    1.0,\n    nwCorner,\n    swCorner,\n    neCorner,\n    seCorner,\n    nwVertexScratch,\n  );\n  swCorner = fillMissingCorner(\n    fill,\n    ellipsoid,\n    0.0,\n    0.0,\n    swCorner,\n    nwCorner,\n    seCorner,\n    neCorner,\n    swVertexScratch,\n  );\n  seCorner = fillMissingCorner(\n    fill,\n    ellipsoid,\n    1.0,\n    1.0,\n    seCorner,\n    swCorner,\n    neCorner,\n    nwCorner,\n    seVertexScratch,\n  );\n  neCorner = fillMissingCorner(\n    fill,\n    ellipsoid,\n    1.0,\n    1.0,\n    neCorner,\n    seCorner,\n    nwCorner,\n    swCorner,\n    neVertexScratch,\n  );\n\n  const southwestHeight = swCorner.height;\n  const southeastHeight = seCorner.height;\n  const northwestHeight = nwCorner.height;\n  const northeastHeight = neCorner.height;\n\n  let minimumHeight = Math.min(\n    southwestHeight,\n    southeastHeight,\n    northwestHeight,\n    northeastHeight,\n  );\n  let maximumHeight = Math.max(\n    southwestHeight,\n    southeastHeight,\n    northwestHeight,\n    northeastHeight,\n  );\n\n  const middleHeight = (minimumHeight + maximumHeight) * 0.5;\n\n  let i;\n  let len;\n\n  // For low-detail tiles, our usual fill tile approach will create tiles that\n  // look really blocky because they don't have enough vertices to account for the\n  // Earth's curvature. But the height range will also typically be well within\n  // the allowed geometric error for those levels. So fill such tiles with a\n  // constant-height heightmap.\n  const geometricError = tileProvider.getLevelMaximumGeometricError(tile.level);\n  const minCutThroughRadius = ellipsoid.maximumRadius - geometricError;\n  let maxTileWidth =\n    Math.acos(minCutThroughRadius / ellipsoid.maximumRadius) * 4.0;\n\n  // When the tile width is greater than maxTileWidth as computed above, the error\n  // of a normal fill tile from globe curvature alone will exceed the allowed geometric\n  // error. Terrain won't change that much. However, we can allow more error than that.\n  // A little blockiness during load is acceptable. For the WGS84 ellipsoid and\n  // standard geometric error setup, the value here will have us use a heightmap\n  // at levels 1, 2, and 3.\n  maxTileWidth *= 1.5;\n\n  if (\n    rectangle.width > maxTileWidth &&\n    maximumHeight - minimumHeight <= geometricError\n  ) {\n    const terrainData = new HeightmapTerrainData({\n      width: 9,\n      height: 9,\n      buffer: heightmapBuffer,\n      structure: {\n        // Use the maximum as the constant height so that this tile's skirt\n        // covers any cracks with adjacent tiles.\n        heightOffset: maximumHeight,\n      },\n    });\n\n    const createMeshSyncOptions = scratchCreateMeshSyncOptions;\n    createMeshSyncOptions.tilingScheme = tile.tilingScheme;\n    createMeshSyncOptions.x = tile.x;\n    createMeshSyncOptions.y = tile.y;\n    createMeshSyncOptions.level = tile.level;\n    createMeshSyncOptions.exaggeration = exaggeration;\n    createMeshSyncOptions.exaggerationRelativeHeight =\n      exaggerationRelativeHeight;\n\n    fill.mesh = terrainData._createMeshSync(createMeshSyncOptions);\n  } else {\n    const hasGeodeticSurfaceNormals = hasExaggeration;\n    const centerCartographic = Rectangle.center(\n      rectangle,\n      centerCartographicScratch,\n    );\n    centerCartographic.height = middleHeight;\n    const center = ellipsoid.cartographicToCartesian(\n      centerCartographic,\n      scratchCenter,\n    );\n    const encoding = new TerrainEncoding(\n      center,\n      undefined,\n      undefined,\n      undefined,\n      undefined,\n      true,\n      true,\n      hasGeodeticSurfaceNormals,\n      exaggeration,\n      exaggerationRelativeHeight,\n    );\n\n    // At _most_, we have vertices for the 4 corners, plus 1 center, plus every adjacent edge vertex.\n    // In reality there will be less most of the time, but close enough; better\n    // to overestimate than to re-allocate/copy/traverse the vertices twice.\n    // Also, we'll often be able to squeeze the index data into the extra space in the buffer.\n    let maxVertexCount = 5;\n    let meshes;\n\n    meshes = fill.westMeshes;\n    for (i = 0, len = meshes.length; i < len; ++i) {\n      maxVertexCount += meshes[i].eastIndicesNorthToSouth.length;\n    }\n\n    meshes = fill.southMeshes;\n    for (i = 0, len = meshes.length; i < len; ++i) {\n      maxVertexCount += meshes[i].northIndicesWestToEast.length;\n    }\n\n    meshes = fill.eastMeshes;\n    for (i = 0, len = meshes.length; i < len; ++i) {\n      maxVertexCount += meshes[i].westIndicesSouthToNorth.length;\n    }\n\n    meshes = fill.northMeshes;\n    for (i = 0, len = meshes.length; i < len; ++i) {\n      maxVertexCount += meshes[i].southIndicesEastToWest.length;\n    }\n\n    const heightRange = heightRangeScratch;\n    heightRange.minimumHeight = minimumHeight;\n    heightRange.maximumHeight = maximumHeight;\n\n    const stride = encoding.stride;\n    let typedArray = new Float32Array(maxVertexCount * stride);\n\n    let nextIndex = 0;\n    const northwestIndex = nextIndex;\n    nextIndex = addVertexWithComputedPosition(\n      ellipsoid,\n      rectangle,\n      encoding,\n      typedArray,\n      nextIndex,\n      0.0,\n      1.0,\n      nwCorner.height,\n      nwCorner.encodedNormal,\n      1.0,\n      heightRange,\n    );\n    nextIndex = addEdge(\n      fill,\n      ellipsoid,\n      encoding,\n      typedArray,\n      nextIndex,\n      fill.westTiles,\n      fill.westMeshes,\n      TileEdge.EAST,\n      heightRange,\n    );\n    const southwestIndex = nextIndex;\n    nextIndex = addVertexWithComputedPosition(\n      ellipsoid,\n      rectangle,\n      encoding,\n      typedArray,\n      nextIndex,\n      0.0,\n      0.0,\n      swCorner.height,\n      swCorner.encodedNormal,\n      0.0,\n      heightRange,\n    );\n    nextIndex = addEdge(\n      fill,\n      ellipsoid,\n      encoding,\n      typedArray,\n      nextIndex,\n      fill.southTiles,\n      fill.southMeshes,\n      TileEdge.NORTH,\n      heightRange,\n    );\n    const southeastIndex = nextIndex;\n    nextIndex = addVertexWithComputedPosition(\n      ellipsoid,\n      rectangle,\n      encoding,\n      typedArray,\n      nextIndex,\n      1.0,\n      0.0,\n      seCorner.height,\n      seCorner.encodedNormal,\n      0.0,\n      heightRange,\n    );\n    nextIndex = addEdge(\n      fill,\n      ellipsoid,\n      encoding,\n      typedArray,\n      nextIndex,\n      fill.eastTiles,\n      fill.eastMeshes,\n      TileEdge.WEST,\n      heightRange,\n    );\n    const northeastIndex = nextIndex;\n    nextIndex = addVertexWithComputedPosition(\n      ellipsoid,\n      rectangle,\n      encoding,\n      typedArray,\n      nextIndex,\n      1.0,\n      1.0,\n      neCorner.height,\n      neCorner.encodedNormal,\n      1.0,\n      heightRange,\n    );\n    nextIndex = addEdge(\n      fill,\n      ellipsoid,\n      encoding,\n      typedArray,\n      nextIndex,\n      fill.northTiles,\n      fill.northMeshes,\n      TileEdge.SOUTH,\n      heightRange,\n    );\n\n    minimumHeight = heightRange.minimumHeight;\n    maximumHeight = heightRange.maximumHeight;\n\n    const obb = OrientedBoundingBox.fromRectangle(\n      rectangle,\n      minimumHeight,\n      maximumHeight,\n      tile.tilingScheme.ellipsoid,\n    );\n\n    // Add a single vertex at the center of the tile.\n    const southMercatorY =\n      WebMercatorProjection.geodeticLatitudeToMercatorAngle(rectangle.south);\n    const oneOverMercatorHeight =\n      1.0 /\n      (WebMercatorProjection.geodeticLatitudeToMercatorAngle(rectangle.north) -\n        southMercatorY);\n    const centerWebMercatorT =\n      (WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n        centerCartographic.latitude,\n      ) -\n        southMercatorY) *\n      oneOverMercatorHeight;\n\n    const geodeticSurfaceNormal = ellipsoid.geodeticSurfaceNormalCartographic(\n      cartographicScratch,\n      normalScratch,\n    );\n    const centerEncodedNormal = AttributeCompression.octEncode(\n      geodeticSurfaceNormal,\n      octEncodedNormalScratch,\n    );\n\n    const centerIndex = nextIndex;\n    encoding.encode(\n      typedArray,\n      nextIndex * stride,\n      obb.center,\n      Cartesian2.fromElements(0.5, 0.5, uvScratch),\n      middleHeight,\n      centerEncodedNormal,\n      centerWebMercatorT,\n      geodeticSurfaceNormal,\n    );\n    ++nextIndex;\n\n    const vertexCount = nextIndex;\n\n    const bytesPerIndex = vertexCount < 256 ? 1 : 2;\n    const indexCount = (vertexCount - 1) * 3; // one triangle per edge vertex\n    const indexDataBytes = indexCount * bytesPerIndex;\n    const availableBytesInBuffer =\n      (typedArray.length - vertexCount * stride) *\n      Float32Array.BYTES_PER_ELEMENT;\n\n    let indices;\n    if (availableBytesInBuffer >= indexDataBytes) {\n      // Store the index data in the same buffer as the vertex data.\n      const startIndex = vertexCount * stride * Float32Array.BYTES_PER_ELEMENT;\n      indices =\n        vertexCount < 256\n          ? new Uint8Array(typedArray.buffer, startIndex, indexCount)\n          : new Uint16Array(typedArray.buffer, startIndex, indexCount);\n    } else {\n      // Allocate a new buffer for the index data.\n      indices =\n        vertexCount < 256\n          ? new Uint8Array(indexCount)\n          : new Uint16Array(indexCount);\n    }\n\n    typedArray = new Float32Array(typedArray.buffer, 0, vertexCount * stride);\n\n    let indexOut = 0;\n    for (i = 0; i < vertexCount - 2; ++i) {\n      indices[indexOut++] = centerIndex;\n      indices[indexOut++] = i;\n      indices[indexOut++] = i + 1;\n    }\n\n    indices[indexOut++] = centerIndex;\n    indices[indexOut++] = i;\n    indices[indexOut++] = 0;\n\n    const westIndicesSouthToNorth = [];\n    for (i = southwestIndex; i >= northwestIndex; --i) {\n      westIndicesSouthToNorth.push(i);\n    }\n\n    const southIndicesEastToWest = [];\n    for (i = southeastIndex; i >= southwestIndex; --i) {\n      southIndicesEastToWest.push(i);\n    }\n\n    const eastIndicesNorthToSouth = [];\n    for (i = northeastIndex; i >= southeastIndex; --i) {\n      eastIndicesNorthToSouth.push(i);\n    }\n\n    const northIndicesWestToEast = [];\n    northIndicesWestToEast.push(0);\n    for (i = centerIndex - 1; i >= northeastIndex; --i) {\n      northIndicesWestToEast.push(i);\n    }\n\n    fill.mesh = new TerrainMesh(\n      encoding.center,\n      typedArray,\n      indices,\n      indexCount,\n      vertexCount,\n      minimumHeight,\n      maximumHeight,\n      BoundingSphere.fromOrientedBoundingBox(obb),\n      computeOccludeePoint(\n        tileProvider,\n        obb.center,\n        rectangle,\n        minimumHeight,\n        maximumHeight,\n      ),\n      encoding.stride,\n      obb,\n      encoding,\n      westIndicesSouthToNorth,\n      southIndicesEastToWest,\n      eastIndicesNorthToSouth,\n      northIndicesWestToEast,\n    );\n  }\n\n  const context = frameState.context;\n\n  fill._destroyVertexArray(vertexArraysToDestroy);\n\n  fill.vertexArray = GlobeSurfaceTile._createVertexArrayForMesh(\n    context,\n    fill.mesh,\n  );\n  surfaceTile.processImagery(\n    tile,\n    tileProvider.terrainProvider,\n    frameState,\n    true,\n  );\n\n  const oldTexture = fill.waterMaskTexture;\n  fill.waterMaskTexture = undefined;\n\n  if (tileProvider.terrainProvider.hasWaterMask) {\n    const waterSourceTile = surfaceTile._findAncestorTileWithTerrainData(tile);\n    if (\n      defined(waterSourceTile) &&\n      defined(waterSourceTile.data.waterMaskTexture)\n    ) {\n      fill.waterMaskTexture = waterSourceTile.data.waterMaskTexture;\n      ++fill.waterMaskTexture.referenceCount;\n      surfaceTile._computeWaterMaskTranslationAndScale(\n        tile,\n        waterSourceTile,\n        fill.waterMaskTranslationAndScale,\n      );\n    }\n  }\n\n  if (defined(oldTexture)) {\n    --oldTexture.referenceCount;\n    if (oldTexture.referenceCount === 0) {\n      oldTexture.destroy();\n    }\n  }\n}\n\nfunction addVertexWithComputedPosition(\n  ellipsoid,\n  rectangle,\n  encoding,\n  buffer,\n  index,\n  u,\n  v,\n  height,\n  encodedNormal,\n  webMercatorT,\n  heightRange,\n) {\n  const cartographic = cartographicScratch;\n  cartographic.longitude = CesiumMath.lerp(rectangle.west, rectangle.east, u);\n  cartographic.latitude = CesiumMath.lerp(rectangle.south, rectangle.north, v);\n  cartographic.height = height;\n  const position = ellipsoid.cartographicToCartesian(\n    cartographic,\n    cartesianScratch,\n  );\n\n  let geodeticSurfaceNormal;\n  if (encoding.hasGeodeticSurfaceNormals) {\n    geodeticSurfaceNormal = ellipsoid.geodeticSurfaceNormal(\n      position,\n      normalScratch,\n    );\n  }\n\n  const uv = uvScratch2;\n  uv.x = u;\n  uv.y = v;\n\n  encoding.encode(\n    buffer,\n    index * encoding.stride,\n    position,\n    uv,\n    height,\n    encodedNormal,\n    webMercatorT,\n    geodeticSurfaceNormal,\n  );\n\n  heightRange.minimumHeight = Math.min(heightRange.minimumHeight, height);\n  heightRange.maximumHeight = Math.max(heightRange.maximumHeight, height);\n\n  return index + 1;\n}\n\nconst sourceRectangleScratch = new Rectangle();\n\nfunction transformTextureCoordinates(\n  sourceTile,\n  targetTile,\n  coordinates,\n  result,\n) {\n  let sourceRectangle = sourceTile.rectangle;\n  const targetRectangle = targetTile.rectangle;\n\n  // Handle transforming across the anti-meridian.\n  if (\n    targetTile.x === 0 &&\n    coordinates.x === 1.0 &&\n    sourceTile.x ===\n      sourceTile.tilingScheme.getNumberOfXTilesAtLevel(sourceTile.level) - 1\n  ) {\n    sourceRectangle = Rectangle.clone(\n      sourceTile.rectangle,\n      sourceRectangleScratch,\n    );\n    sourceRectangle.west -= CesiumMath.TWO_PI;\n    sourceRectangle.east -= CesiumMath.TWO_PI;\n  } else if (\n    sourceTile.x === 0 &&\n    coordinates.x === 0.0 &&\n    targetTile.x ===\n      targetTile.tilingScheme.getNumberOfXTilesAtLevel(targetTile.level) - 1\n  ) {\n    sourceRectangle = Rectangle.clone(\n      sourceTile.rectangle,\n      sourceRectangleScratch,\n    );\n    sourceRectangle.west += CesiumMath.TWO_PI;\n    sourceRectangle.east += CesiumMath.TWO_PI;\n  }\n\n  const sourceWidth = sourceRectangle.east - sourceRectangle.west;\n  const umin = (targetRectangle.west - sourceRectangle.west) / sourceWidth;\n  const umax = (targetRectangle.east - sourceRectangle.west) / sourceWidth;\n\n  const sourceHeight = sourceRectangle.north - sourceRectangle.south;\n  const vmin = (targetRectangle.south - sourceRectangle.south) / sourceHeight;\n  const vmax = (targetRectangle.north - sourceRectangle.south) / sourceHeight;\n\n  let u = (coordinates.x - umin) / (umax - umin);\n  let v = (coordinates.y - vmin) / (vmax - vmin);\n\n  // Ensure that coordinates very near the corners are at the corners.\n  if (Math.abs(u) < Math.EPSILON5) {\n    u = 0.0;\n  } else if (Math.abs(u - 1.0) < Math.EPSILON5) {\n    u = 1.0;\n  }\n\n  if (Math.abs(v) < Math.EPSILON5) {\n    v = 0.0;\n  } else if (Math.abs(v - 1.0) < Math.EPSILON5) {\n    v = 1.0;\n  }\n\n  result.x = u;\n  result.y = v;\n  return result;\n}\n\nconst encodedNormalScratch = new Cartesian2();\n\nfunction getVertexFromTileAtCorner(sourceMesh, sourceIndex, u, v, vertex) {\n  const sourceEncoding = sourceMesh.encoding;\n  const sourceVertices = sourceMesh.vertices;\n\n  vertex.height = sourceEncoding.decodeHeight(sourceVertices, sourceIndex);\n\n  if (sourceEncoding.hasVertexNormals) {\n    sourceEncoding.getOctEncodedNormal(\n      sourceVertices,\n      sourceIndex,\n      vertex.encodedNormal,\n    );\n  } else {\n    const normal = vertex.encodedNormal;\n    normal.x = 0.0;\n    normal.y = 0.0;\n  }\n}\n\nconst encodedNormalScratch2 = new Cartesian2();\nconst cartesianScratch2 = new Cartesian3();\n\nfunction getInterpolatedVertexAtCorner(\n  ellipsoid,\n  sourceTile,\n  targetTile,\n  sourceMesh,\n  previousIndex,\n  nextIndex,\n  u,\n  v,\n  interpolateU,\n  vertex,\n) {\n  const sourceEncoding = sourceMesh.encoding;\n  const sourceVertices = sourceMesh.vertices;\n\n  const previousUv = transformTextureCoordinates(\n    sourceTile,\n    targetTile,\n    sourceEncoding.decodeTextureCoordinates(\n      sourceVertices,\n      previousIndex,\n      uvScratch,\n    ),\n    uvScratch,\n  );\n  const nextUv = transformTextureCoordinates(\n    sourceTile,\n    targetTile,\n    sourceEncoding.decodeTextureCoordinates(\n      sourceVertices,\n      nextIndex,\n      uvScratch2,\n    ),\n    uvScratch2,\n  );\n\n  let ratio;\n  if (interpolateU) {\n    ratio = (u - previousUv.x) / (nextUv.x - previousUv.x);\n  } else {\n    ratio = (v - previousUv.y) / (nextUv.y - previousUv.y);\n  }\n\n  const height1 = sourceEncoding.decodeHeight(sourceVertices, previousIndex);\n  const height2 = sourceEncoding.decodeHeight(sourceVertices, nextIndex);\n\n  const targetRectangle = targetTile.rectangle;\n  cartographicScratch.longitude = CesiumMath.lerp(\n    targetRectangle.west,\n    targetRectangle.east,\n    u,\n  );\n  cartographicScratch.latitude = CesiumMath.lerp(\n    targetRectangle.south,\n    targetRectangle.north,\n    v,\n  );\n  vertex.height = cartographicScratch.height = CesiumMath.lerp(\n    height1,\n    height2,\n    ratio,\n  );\n\n  let normal;\n  if (sourceEncoding.hasVertexNormals) {\n    const encodedNormal1 = sourceEncoding.getOctEncodedNormal(\n      sourceVertices,\n      previousIndex,\n      encodedNormalScratch,\n    );\n    const encodedNormal2 = sourceEncoding.getOctEncodedNormal(\n      sourceVertices,\n      nextIndex,\n      encodedNormalScratch2,\n    );\n    const normal1 = AttributeCompression.octDecode(\n      encodedNormal1.x,\n      encodedNormal1.y,\n      cartesianScratch,\n    );\n    const normal2 = AttributeCompression.octDecode(\n      encodedNormal2.x,\n      encodedNormal2.y,\n      cartesianScratch2,\n    );\n    normal = Cartesian3.lerp(normal1, normal2, ratio, cartesianScratch);\n    Cartesian3.normalize(normal, normal);\n    AttributeCompression.octEncode(normal, vertex.encodedNormal);\n  } else {\n    normal = ellipsoid.geodeticSurfaceNormalCartographic(\n      cartographicScratch,\n      cartesianScratch,\n    );\n    AttributeCompression.octEncode(normal, vertex.encodedNormal);\n  }\n}\n\nfunction getVertexWithHeightAtCorner(\n  terrainFillMesh,\n  ellipsoid,\n  u,\n  v,\n  height,\n  vertex,\n) {\n  vertex.height = height;\n  const normal = ellipsoid.geodeticSurfaceNormalCartographic(\n    cartographicScratch,\n    cartesianScratch,\n  );\n  AttributeCompression.octEncode(normal, vertex.encodedNormal);\n}\n\nfunction getCorner(\n  terrainFillMesh,\n  ellipsoid,\n  u,\n  v,\n  cornerTile,\n  cornerMesh,\n  previousEdgeTiles,\n  previousEdgeMeshes,\n  nextEdgeTiles,\n  nextEdgeMeshes,\n  vertex,\n) {\n  const gotCorner =\n    getCornerFromEdge(\n      terrainFillMesh,\n      ellipsoid,\n      previousEdgeMeshes,\n      previousEdgeTiles,\n      false,\n      u,\n      v,\n      vertex,\n    ) ||\n    getCornerFromEdge(\n      terrainFillMesh,\n      ellipsoid,\n      nextEdgeMeshes,\n      nextEdgeTiles,\n      true,\n      u,\n      v,\n      vertex,\n    );\n  if (gotCorner) {\n    return vertex;\n  }\n\n  let vertexIndex;\n\n  if (meshIsUsable(cornerTile, cornerMesh)) {\n    // Corner mesh is valid, copy its corner vertex to this mesh.\n    if (u === 0.0) {\n      if (v === 0.0) {\n        // southwest destination, northeast source\n        vertexIndex = cornerMesh.eastIndicesNorthToSouth[0];\n      } else {\n        // northwest destination, southeast source\n        vertexIndex = cornerMesh.southIndicesEastToWest[0];\n      }\n    } else if (v === 0.0) {\n      // southeast destination, northwest source\n      vertexIndex = cornerMesh.northIndicesWestToEast[0];\n    } else {\n      // northeast destination, southwest source\n      vertexIndex = cornerMesh.westIndicesSouthToNorth[0];\n    }\n    getVertexFromTileAtCorner(cornerMesh, vertexIndex, u, v, vertex);\n    return vertex;\n  }\n\n  // There is no precise vertex available from the corner or from either adjacent edge.\n  // This is either because there are no tiles at all at the edges and corner, or\n  // because the tiles at the edge are higher-level-number and don't extend all the way\n  // to the corner.\n  // Try to grab a height from the adjacent edges.\n  let height;\n  if (u === 0.0) {\n    if (v === 0.0) {\n      // southwest\n      height = getClosestHeightToCorner(\n        terrainFillMesh.westMeshes,\n        terrainFillMesh.westTiles,\n        TileEdge.EAST,\n        terrainFillMesh.southMeshes,\n        terrainFillMesh.southTiles,\n        TileEdge.NORTH,\n        u,\n        v,\n      );\n    } else {\n      // northwest\n      height = getClosestHeightToCorner(\n        terrainFillMesh.northMeshes,\n        terrainFillMesh.northTiles,\n        TileEdge.SOUTH,\n        terrainFillMesh.westMeshes,\n        terrainFillMesh.westTiles,\n        TileEdge.EAST,\n        u,\n        v,\n      );\n    }\n  } else if (v === 0.0) {\n    // southeast\n    height = getClosestHeightToCorner(\n      terrainFillMesh.southMeshes,\n      terrainFillMesh.southTiles,\n      TileEdge.NORTH,\n      terrainFillMesh.eastMeshes,\n      terrainFillMesh.eastTiles,\n      TileEdge.WEST,\n      u,\n      v,\n    );\n  } else {\n    // northeast\n    height = getClosestHeightToCorner(\n      terrainFillMesh.eastMeshes,\n      terrainFillMesh.eastTiles,\n      TileEdge.WEST,\n      terrainFillMesh.northMeshes,\n      terrainFillMesh.northTiles,\n      TileEdge.SOUTH,\n      u,\n      v,\n    );\n  }\n\n  if (defined(height)) {\n    getVertexWithHeightAtCorner(\n      terrainFillMesh,\n      ellipsoid,\n      u,\n      v,\n      height,\n      vertex,\n    );\n    return vertex;\n  }\n\n  // No heights available that are closer than the adjacent corners.\n  return undefined;\n}\n\nfunction getClosestHeightToCorner(\n  previousMeshes,\n  previousTiles,\n  previousEdge,\n  nextMeshes,\n  nextTiles,\n  nextEdge,\n  u,\n  v,\n) {\n  const height1 = getNearestHeightOnEdge(\n    previousMeshes,\n    previousTiles,\n    false,\n    previousEdge,\n    u,\n    v,\n  );\n  const height2 = getNearestHeightOnEdge(\n    nextMeshes,\n    nextTiles,\n    true,\n    nextEdge,\n    u,\n    v,\n  );\n  if (defined(height1) && defined(height2)) {\n    // It would be slightly better to do a weighted average of the two heights\n    // based on their distance from the corner, but it shouldn't matter much in practice.\n    return (height1 + height2) * 0.5;\n  } else if (defined(height1)) {\n    return height1;\n  }\n  return height2;\n}\n\nfunction addEdge(\n  terrainFillMesh,\n  ellipsoid,\n  encoding,\n  typedArray,\n  nextIndex,\n  edgeTiles,\n  edgeMeshes,\n  tileEdge,\n  heightRange,\n) {\n  for (let i = 0; i < edgeTiles.length; ++i) {\n    nextIndex = addEdgeMesh(\n      terrainFillMesh,\n      ellipsoid,\n      encoding,\n      typedArray,\n      nextIndex,\n      edgeTiles[i],\n      edgeMeshes[i],\n      tileEdge,\n      heightRange,\n    );\n  }\n  return nextIndex;\n}\n\nfunction addEdgeMesh(\n  terrainFillMesh,\n  ellipsoid,\n  encoding,\n  typedArray,\n  nextIndex,\n  edgeTile,\n  edgeMesh,\n  tileEdge,\n  heightRange,\n) {\n  // Handle copying edges across the anti-meridian.\n  let sourceRectangle = edgeTile.rectangle;\n  if (tileEdge === TileEdge.EAST && terrainFillMesh.tile.x === 0) {\n    sourceRectangle = Rectangle.clone(\n      edgeTile.rectangle,\n      sourceRectangleScratch,\n    );\n    sourceRectangle.west -= CesiumMath.TWO_PI;\n    sourceRectangle.east -= CesiumMath.TWO_PI;\n  } else if (tileEdge === TileEdge.WEST && edgeTile.x === 0) {\n    sourceRectangle = Rectangle.clone(\n      edgeTile.rectangle,\n      sourceRectangleScratch,\n    );\n    sourceRectangle.west += CesiumMath.TWO_PI;\n    sourceRectangle.east += CesiumMath.TWO_PI;\n  }\n\n  const targetRectangle = terrainFillMesh.tile.rectangle;\n\n  let lastU;\n  let lastV;\n\n  if (nextIndex > 0) {\n    encoding.decodeTextureCoordinates(typedArray, nextIndex - 1, uvScratch);\n    lastU = uvScratch.x;\n    lastV = uvScratch.y;\n  }\n\n  let indices;\n  let compareU;\n\n  switch (tileEdge) {\n    case TileEdge.WEST:\n      indices = edgeMesh.westIndicesSouthToNorth;\n      compareU = false;\n      break;\n    case TileEdge.NORTH:\n      indices = edgeMesh.northIndicesWestToEast;\n      compareU = true;\n      break;\n    case TileEdge.EAST:\n      indices = edgeMesh.eastIndicesNorthToSouth;\n      compareU = false;\n      break;\n    case TileEdge.SOUTH:\n      indices = edgeMesh.southIndicesEastToWest;\n      compareU = true;\n      break;\n  }\n\n  const sourceTile = edgeTile;\n  const targetTile = terrainFillMesh.tile;\n  const sourceEncoding = edgeMesh.encoding;\n  const sourceVertices = edgeMesh.vertices;\n  const targetStride = encoding.stride;\n\n  let southMercatorY;\n  let oneOverMercatorHeight;\n  if (sourceEncoding.hasWebMercatorT) {\n    southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n      targetRectangle.south,\n    );\n    oneOverMercatorHeight =\n      1.0 /\n      (WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n        targetRectangle.north,\n      ) -\n        southMercatorY);\n  }\n\n  for (let i = 0; i < indices.length; ++i) {\n    const index = indices[i];\n\n    const uv = sourceEncoding.decodeTextureCoordinates(\n      sourceVertices,\n      index,\n      uvScratch,\n    );\n    transformTextureCoordinates(sourceTile, targetTile, uv, uv);\n    const u = uv.x;\n    const v = uv.y;\n    const uOrV = compareU ? u : v;\n\n    if (uOrV < 0.0 || uOrV > 1.0) {\n      // Vertex is outside the target tile - skip it.\n      continue;\n    }\n\n    if (\n      Math.abs(u - lastU) < CesiumMath.EPSILON5 &&\n      Math.abs(v - lastV) < CesiumMath.EPSILON5\n    ) {\n      // Vertex is very close to the previous one - skip it.\n      continue;\n    }\n\n    const nearlyEdgeU =\n      Math.abs(u) < CesiumMath.EPSILON5 ||\n      Math.abs(u - 1.0) < CesiumMath.EPSILON5;\n    const nearlyEdgeV =\n      Math.abs(v) < CesiumMath.EPSILON5 ||\n      Math.abs(v - 1.0) < CesiumMath.EPSILON5;\n\n    if (nearlyEdgeU && nearlyEdgeV) {\n      // Corner vertex - skip it.\n      continue;\n    }\n\n    const position = sourceEncoding.decodePosition(\n      sourceVertices,\n      index,\n      cartesianScratch,\n    );\n    const height = sourceEncoding.decodeHeight(sourceVertices, index);\n\n    let normal;\n    if (sourceEncoding.hasVertexNormals) {\n      normal = sourceEncoding.getOctEncodedNormal(\n        sourceVertices,\n        index,\n        octEncodedNormalScratch,\n      );\n    } else {\n      normal = octEncodedNormalScratch;\n      normal.x = 0.0;\n      normal.y = 0.0;\n    }\n\n    let webMercatorT = v;\n    if (sourceEncoding.hasWebMercatorT) {\n      const latitude = CesiumMath.lerp(\n        targetRectangle.south,\n        targetRectangle.north,\n        v,\n      );\n      webMercatorT =\n        (WebMercatorProjection.geodeticLatitudeToMercatorAngle(latitude) -\n          southMercatorY) *\n        oneOverMercatorHeight;\n    }\n\n    let geodeticSurfaceNormal;\n    if (encoding.hasGeodeticSurfaceNormals) {\n      geodeticSurfaceNormal = ellipsoid.geodeticSurfaceNormal(\n        position,\n        normalScratch,\n      );\n    }\n\n    encoding.encode(\n      typedArray,\n      nextIndex * targetStride,\n      position,\n      uv,\n      height,\n      normal,\n      webMercatorT,\n      geodeticSurfaceNormal,\n    );\n\n    heightRange.minimumHeight = Math.min(heightRange.minimumHeight, height);\n    heightRange.maximumHeight = Math.max(heightRange.maximumHeight, height);\n\n    ++nextIndex;\n  }\n\n  return nextIndex;\n}\n\nfunction getNearestHeightOnEdge(meshes, tiles, isNext, edge, u, v) {\n  let meshStart;\n  let meshEnd;\n  let meshStep;\n\n  if (isNext) {\n    meshStart = 0;\n    meshEnd = meshes.length;\n    meshStep = 1;\n  } else {\n    meshStart = meshes.length - 1;\n    meshEnd = -1;\n    meshStep = -1;\n  }\n\n  for (\n    let meshIndex = meshStart;\n    meshIndex !== meshEnd;\n    meshIndex += meshStep\n  ) {\n    const mesh = meshes[meshIndex];\n    const tile = tiles[meshIndex];\n    if (!meshIsUsable(tile, mesh)) {\n      continue;\n    }\n\n    let indices;\n    switch (edge) {\n      case TileEdge.WEST:\n        indices = mesh.westIndicesSouthToNorth;\n        break;\n      case TileEdge.SOUTH:\n        indices = mesh.southIndicesEastToWest;\n        break;\n      case TileEdge.EAST:\n        indices = mesh.eastIndicesNorthToSouth;\n        break;\n      case TileEdge.NORTH:\n        indices = mesh.northIndicesWestToEast;\n        break;\n    }\n\n    const index = indices[isNext ? 0 : indices.length - 1];\n    if (defined(index)) {\n      return mesh.encoding.decodeHeight(mesh.vertices, index);\n    }\n  }\n\n  return undefined;\n}\n\nfunction meshIsUsable(tile, mesh) {\n  return (\n    defined(mesh) &&\n    (!defined(tile.data.fill) || !tile.data.fill.changedThisFrame)\n  );\n}\n\nfunction getCornerFromEdge(\n  terrainFillMesh,\n  ellipsoid,\n  edgeMeshes,\n  edgeTiles,\n  isNext,\n  u,\n  v,\n  vertex,\n) {\n  let edgeVertices;\n  let compareU;\n  let increasing;\n  let vertexIndexIndex;\n  let vertexIndex;\n  const sourceTile = edgeTiles[isNext ? 0 : edgeMeshes.length - 1];\n  const sourceMesh = edgeMeshes[isNext ? 0 : edgeMeshes.length - 1];\n\n  if (meshIsUsable(sourceTile, sourceMesh)) {\n    // Previous mesh is valid, but we don't know yet if it covers this corner.\n    if (u === 0.0) {\n      if (v === 0.0) {\n        // southwest\n        edgeVertices = isNext\n          ? sourceMesh.northIndicesWestToEast\n          : sourceMesh.eastIndicesNorthToSouth;\n        compareU = isNext;\n        increasing = isNext;\n      } else {\n        // northwest\n        edgeVertices = isNext\n          ? sourceMesh.eastIndicesNorthToSouth\n          : sourceMesh.southIndicesEastToWest;\n        compareU = !isNext;\n        increasing = false;\n      }\n    } else if (v === 0.0) {\n      // southeast\n      edgeVertices = isNext\n        ? sourceMesh.westIndicesSouthToNorth\n        : sourceMesh.northIndicesWestToEast;\n      compareU = !isNext;\n      increasing = true;\n    } else {\n      // northeast\n      edgeVertices = isNext\n        ? sourceMesh.southIndicesEastToWest\n        : sourceMesh.westIndicesSouthToNorth;\n      compareU = isNext;\n      increasing = !isNext;\n    }\n\n    if (edgeVertices.length > 0) {\n      // The vertex we want will very often be the first/last vertex so check that first.\n      vertexIndexIndex = isNext ? 0 : edgeVertices.length - 1;\n      vertexIndex = edgeVertices[vertexIndexIndex];\n      sourceMesh.encoding.decodeTextureCoordinates(\n        sourceMesh.vertices,\n        vertexIndex,\n        uvScratch,\n      );\n      const targetUv = transformTextureCoordinates(\n        sourceTile,\n        terrainFillMesh.tile,\n        uvScratch,\n        uvScratch,\n      );\n      if (targetUv.x === u && targetUv.y === v) {\n        // Vertex is good!\n        getVertexFromTileAtCorner(sourceMesh, vertexIndex, u, v, vertex);\n        return true;\n      }\n\n      // The last vertex is not the one we need, try binary searching for the right one.\n      vertexIndexIndex = binarySearch(\n        edgeVertices,\n        compareU ? u : v,\n        function (vertexIndex, textureCoordinate) {\n          sourceMesh.encoding.decodeTextureCoordinates(\n            sourceMesh.vertices,\n            vertexIndex,\n            uvScratch,\n          );\n          const targetUv = transformTextureCoordinates(\n            sourceTile,\n            terrainFillMesh.tile,\n            uvScratch,\n            uvScratch,\n          );\n          if (increasing) {\n            if (compareU) {\n              return targetUv.x - u;\n            }\n            return targetUv.y - v;\n          } else if (compareU) {\n            return u - targetUv.x;\n          }\n          return v - targetUv.y;\n        },\n      );\n\n      if (vertexIndexIndex < 0) {\n        vertexIndexIndex = ~vertexIndexIndex;\n\n        if (vertexIndexIndex > 0 && vertexIndexIndex < edgeVertices.length) {\n          // The corner falls between two vertices, so interpolate between them.\n          getInterpolatedVertexAtCorner(\n            ellipsoid,\n            sourceTile,\n            terrainFillMesh.tile,\n            sourceMesh,\n            edgeVertices[vertexIndexIndex - 1],\n            edgeVertices[vertexIndexIndex],\n            u,\n            v,\n            compareU,\n            vertex,\n          );\n          return true;\n        }\n      } else {\n        // Found a vertex that fits in the corner exactly.\n        getVertexFromTileAtCorner(\n          sourceMesh,\n          edgeVertices[vertexIndexIndex],\n          u,\n          v,\n          vertex,\n        );\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nconst cornerPositionsScratch = [\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n];\n\nfunction computeOccludeePoint(\n  tileProvider,\n  center,\n  rectangle,\n  minimumHeight,\n  maximumHeight,\n  result,\n) {\n  const ellipsoidalOccluder = tileProvider.quadtree._occluders.ellipsoid;\n  const ellipsoid = ellipsoidalOccluder.ellipsoid;\n\n  const cornerPositions = cornerPositionsScratch;\n  Cartesian3.fromRadians(\n    rectangle.west,\n    rectangle.south,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[0],\n  );\n  Cartesian3.fromRadians(\n    rectangle.east,\n    rectangle.south,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[1],\n  );\n  Cartesian3.fromRadians(\n    rectangle.west,\n    rectangle.north,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[2],\n  );\n  Cartesian3.fromRadians(\n    rectangle.east,\n    rectangle.north,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[3],\n  );\n\n  return ellipsoidalOccluder.computeHorizonCullingPointPossiblyUnderEllipsoid(\n    center,\n    cornerPositions,\n    minimumHeight,\n    result,\n  );\n}\nexport default TerrainFillMesh;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}