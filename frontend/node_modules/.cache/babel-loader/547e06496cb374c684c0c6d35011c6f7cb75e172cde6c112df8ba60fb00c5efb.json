{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-hex.js\";\nimport \"core-js/modules/esnext.uint8-array.to-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.to-hex.js\";\nimport ArcType from \"./ArcType.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Color from \"./Color.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nfunction interpolateColors(p0, p1, color0, color1, minDistance, array, offset) {\n  const numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);\n  let i;\n  const r0 = color0.red;\n  const g0 = color0.green;\n  const b0 = color0.blue;\n  const a0 = color0.alpha;\n  const r1 = color1.red;\n  const g1 = color1.green;\n  const b1 = color1.blue;\n  const a1 = color1.alpha;\n  if (Color.equals(color0, color1)) {\n    for (i = 0; i < numPoints; i++) {\n      array[offset++] = Color.floatToByte(r0);\n      array[offset++] = Color.floatToByte(g0);\n      array[offset++] = Color.floatToByte(b0);\n      array[offset++] = Color.floatToByte(a0);\n    }\n    return offset;\n  }\n  const redPerVertex = (r1 - r0) / numPoints;\n  const greenPerVertex = (g1 - g0) / numPoints;\n  const bluePerVertex = (b1 - b0) / numPoints;\n  const alphaPerVertex = (a1 - a0) / numPoints;\n  let index = offset;\n  for (i = 0; i < numPoints; i++) {\n    array[index++] = Color.floatToByte(r0 + i * redPerVertex);\n    array[index++] = Color.floatToByte(g0 + i * greenPerVertex);\n    array[index++] = Color.floatToByte(b0 + i * bluePerVertex);\n    array[index++] = Color.floatToByte(a0 + i * alphaPerVertex);\n  }\n  return index;\n}\n\n/**\n * A description of a polyline modeled as a line strip; the first two positions define a line segment,\n * and each additional position defines a line segment from the previous position.\n *\n * @alias SimplePolylineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the positions in the polyline as a line strip.\n * @param {Color[]} [options.colors] An Array of {@link Color} defining the per vertex or per segment colors.\n * @param {boolean} [options.colorsPerVertex=false] A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n *\n * @exception {DeveloperError} At least two positions are required.\n * @exception {DeveloperError} colors has an invalid length.\n *\n * @see SimplePolylineGeometry#createGeometry\n *\n * @example\n * // A polyline with two connected line segments\n * const polyline = new Cesium.SimplePolylineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     0.0, 0.0,\n *     5.0, 0.0,\n *     5.0, 5.0\n *   ])\n * });\n * const geometry = Cesium.SimplePolylineGeometry.createGeometry(polyline);\n */\nfunction SimplePolylineGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const positions = options.positions;\n  const colors = options.colors;\n  const colorsPerVertex = options.colorsPerVertex ?? false;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions) || positions.length < 2) {\n    throw new DeveloperError(\"At least two positions are required.\");\n  }\n  if (defined(colors) && (colorsPerVertex && colors.length < positions.length || !colorsPerVertex && colors.length < positions.length - 1)) {\n    throw new DeveloperError(\"colors has an invalid length.\");\n  }\n  //>>includeEnd('debug');\n\n  this._positions = positions;\n  this._colors = colors;\n  this._colorsPerVertex = colorsPerVertex;\n  this._arcType = options.arcType ?? ArcType.GEODESIC;\n  this._granularity = options.granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n  this._ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n  this._workerName = \"createSimplePolylineGeometry\";\n  let numComponents = 1 + positions.length * Cartesian3.packedLength;\n  numComponents += defined(colors) ? 1 + colors.length * Color.packedLength : 1;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength = numComponents + Ellipsoid.packedLength + 3;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {SimplePolylineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nSimplePolylineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n  let i;\n  const positions = value._positions;\n  let length = positions.length;\n  array[startingIndex++] = length;\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n  const colors = value._colors;\n  length = defined(colors) ? colors.length : 0.0;\n  array[startingIndex++] = length;\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    Color.pack(colors[i], array, startingIndex);\n  }\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  array[startingIndex++] = value._colorsPerVertex ? 1.0 : 0.0;\n  array[startingIndex++] = value._arcType;\n  array[startingIndex] = value._granularity;\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {SimplePolylineGeometry} [result] The object into which to store the result.\n * @returns {SimplePolylineGeometry} The modified result parameter or a new SimplePolylineGeometry instance if one was not provided.\n */\nSimplePolylineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n  let i;\n  let length = array[startingIndex++];\n  const positions = new Array(length);\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n  length = array[startingIndex++];\n  const colors = length > 0 ? new Array(length) : undefined;\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    colors[i] = Color.unpack(array, startingIndex);\n  }\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  const colorsPerVertex = array[startingIndex++] === 1.0;\n  const arcType = array[startingIndex++];\n  const granularity = array[startingIndex];\n  if (!defined(result)) {\n    return new SimplePolylineGeometry({\n      positions: positions,\n      colors: colors,\n      ellipsoid: ellipsoid,\n      colorsPerVertex: colorsPerVertex,\n      arcType: arcType,\n      granularity: granularity\n    });\n  }\n  result._positions = positions;\n  result._colors = colors;\n  result._ellipsoid = ellipsoid;\n  result._colorsPerVertex = colorsPerVertex;\n  result._arcType = arcType;\n  result._granularity = granularity;\n  return result;\n};\nconst scratchArray1 = new Array(2);\nconst scratchArray2 = new Array(2);\nconst generateArcOptionsScratch = {\n  positions: scratchArray1,\n  height: scratchArray2,\n  ellipsoid: undefined,\n  minDistance: undefined,\n  granularity: undefined\n};\n\n/**\n * Computes the geometric representation of a simple polyline, including its vertices, indices, and a bounding sphere.\n *\n * @param {SimplePolylineGeometry} simplePolylineGeometry A description of the polyline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nSimplePolylineGeometry.createGeometry = function (simplePolylineGeometry) {\n  const positions = simplePolylineGeometry._positions;\n  const colors = simplePolylineGeometry._colors;\n  const colorsPerVertex = simplePolylineGeometry._colorsPerVertex;\n  const arcType = simplePolylineGeometry._arcType;\n  const granularity = simplePolylineGeometry._granularity;\n  const ellipsoid = simplePolylineGeometry._ellipsoid;\n  const minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n  const perSegmentColors = defined(colors) && !colorsPerVertex;\n  let i;\n  const length = positions.length;\n  let positionValues;\n  let numberOfPositions;\n  let colorValues;\n  let color;\n  let offset = 0;\n  if (arcType === ArcType.GEODESIC || arcType === ArcType.RHUMB) {\n    let subdivisionSize;\n    let numberOfPointsFunction;\n    let generateArcFunction;\n    if (arcType === ArcType.GEODESIC) {\n      subdivisionSize = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n      numberOfPointsFunction = PolylinePipeline.numberOfPoints;\n      generateArcFunction = PolylinePipeline.generateArc;\n    } else {\n      subdivisionSize = granularity;\n      numberOfPointsFunction = PolylinePipeline.numberOfPointsRhumbLine;\n      generateArcFunction = PolylinePipeline.generateRhumbArc;\n    }\n    const heights = PolylinePipeline.extractHeights(positions, ellipsoid);\n    const generateArcOptions = generateArcOptionsScratch;\n    if (arcType === ArcType.GEODESIC) {\n      generateArcOptions.minDistance = minDistance;\n    } else {\n      generateArcOptions.granularity = granularity;\n    }\n    generateArcOptions.ellipsoid = ellipsoid;\n    if (perSegmentColors) {\n      let positionCount = 0;\n      for (i = 0; i < length - 1; i++) {\n        positionCount += numberOfPointsFunction(positions[i], positions[i + 1], subdivisionSize) + 1;\n      }\n      positionValues = new Float64Array(positionCount * 3);\n      colorValues = new Uint8Array(positionCount * 4);\n      generateArcOptions.positions = scratchArray1;\n      generateArcOptions.height = scratchArray2;\n      let ci = 0;\n      for (i = 0; i < length - 1; ++i) {\n        scratchArray1[0] = positions[i];\n        scratchArray1[1] = positions[i + 1];\n        scratchArray2[0] = heights[i];\n        scratchArray2[1] = heights[i + 1];\n        const pos = generateArcFunction(generateArcOptions);\n        if (defined(colors)) {\n          const segLen = pos.length / 3;\n          color = colors[i];\n          for (let k = 0; k < segLen; ++k) {\n            colorValues[ci++] = Color.floatToByte(color.red);\n            colorValues[ci++] = Color.floatToByte(color.green);\n            colorValues[ci++] = Color.floatToByte(color.blue);\n            colorValues[ci++] = Color.floatToByte(color.alpha);\n          }\n        }\n        positionValues.set(pos, offset);\n        offset += pos.length;\n      }\n    } else {\n      generateArcOptions.positions = positions;\n      generateArcOptions.height = heights;\n      positionValues = new Float64Array(generateArcFunction(generateArcOptions));\n      if (defined(colors)) {\n        colorValues = new Uint8Array(positionValues.length / 3 * 4);\n        for (i = 0; i < length - 1; ++i) {\n          const p0 = positions[i];\n          const p1 = positions[i + 1];\n          const c0 = colors[i];\n          const c1 = colors[i + 1];\n          offset = interpolateColors(p0, p1, c0, c1, minDistance, colorValues, offset);\n        }\n        const lastColor = colors[length - 1];\n        colorValues[offset++] = Color.floatToByte(lastColor.red);\n        colorValues[offset++] = Color.floatToByte(lastColor.green);\n        colorValues[offset++] = Color.floatToByte(lastColor.blue);\n        colorValues[offset++] = Color.floatToByte(lastColor.alpha);\n      }\n    }\n  } else {\n    numberOfPositions = perSegmentColors ? length * 2 - 2 : length;\n    positionValues = new Float64Array(numberOfPositions * 3);\n    colorValues = defined(colors) ? new Uint8Array(numberOfPositions * 4) : undefined;\n    let positionIndex = 0;\n    let colorIndex = 0;\n    for (i = 0; i < length; ++i) {\n      const p = positions[i];\n      if (perSegmentColors && i > 0) {\n        Cartesian3.pack(p, positionValues, positionIndex);\n        positionIndex += 3;\n        color = colors[i - 1];\n        colorValues[colorIndex++] = Color.floatToByte(color.red);\n        colorValues[colorIndex++] = Color.floatToByte(color.green);\n        colorValues[colorIndex++] = Color.floatToByte(color.blue);\n        colorValues[colorIndex++] = Color.floatToByte(color.alpha);\n      }\n      if (perSegmentColors && i === length - 1) {\n        break;\n      }\n      Cartesian3.pack(p, positionValues, positionIndex);\n      positionIndex += 3;\n      if (defined(colors)) {\n        color = colors[i];\n        colorValues[colorIndex++] = Color.floatToByte(color.red);\n        colorValues[colorIndex++] = Color.floatToByte(color.green);\n        colorValues[colorIndex++] = Color.floatToByte(color.blue);\n        colorValues[colorIndex++] = Color.floatToByte(color.alpha);\n      }\n    }\n  }\n  const attributes = new GeometryAttributes();\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positionValues\n  });\n  if (defined(colors)) {\n    attributes.color = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 4,\n      values: colorValues,\n      normalize: true\n    });\n  }\n  numberOfPositions = positionValues.length / 3;\n  const numberOfIndices = (numberOfPositions - 1) * 2;\n  const indices = IndexDatatype.createTypedArray(numberOfPositions, numberOfIndices);\n  let index = 0;\n  for (i = 0; i < numberOfPositions - 1; ++i) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n  }\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: BoundingSphere.fromPoints(positions)\n  });\n};\nexport default SimplePolylineGeometry;","map":{"version":3,"names":["ArcType","BoundingSphere","Cartesian3","Color","ComponentDatatype","Frozen","defined","DeveloperError","Ellipsoid","Geometry","GeometryAttribute","GeometryAttributes","IndexDatatype","CesiumMath","PolylinePipeline","PrimitiveType","interpolateColors","p0","p1","color0","color1","minDistance","array","offset","numPoints","numberOfPoints","i","r0","red","g0","green","b0","blue","a0","alpha","r1","g1","b1","a1","equals","floatToByte","redPerVertex","greenPerVertex","bluePerVertex","alphaPerVertex","index","SimplePolylineGeometry","options","EMPTY_OBJECT","positions","colors","colorsPerVertex","length","_positions","_colors","_colorsPerVertex","_arcType","arcType","GEODESIC","_granularity","granularity","RADIANS_PER_DEGREE","_ellipsoid","ellipsoid","default","_workerName","numComponents","packedLength","pack","value","startingIndex","unpack","result","Array","undefined","scratchArray1","scratchArray2","generateArcOptionsScratch","height","createGeometry","simplePolylineGeometry","chordLength","maximumRadius","perSegmentColors","positionValues","numberOfPositions","colorValues","color","RHUMB","subdivisionSize","numberOfPointsFunction","generateArcFunction","generateArc","numberOfPointsRhumbLine","generateRhumbArc","heights","extractHeights","generateArcOptions","positionCount","Float64Array","Uint8Array","ci","pos","segLen","k","set","c0","c1","lastColor","positionIndex","colorIndex","p","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","UNSIGNED_BYTE","normalize","numberOfIndices","indices","createTypedArray","primitiveType","LINES","boundingSphere","fromPoints"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/SimplePolylineGeometry.js"],"sourcesContent":["import ArcType from \"./ArcType.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Color from \"./Color.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nfunction interpolateColors(p0, p1, color0, color1, minDistance, array, offset) {\n  const numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);\n  let i;\n\n  const r0 = color0.red;\n  const g0 = color0.green;\n  const b0 = color0.blue;\n  const a0 = color0.alpha;\n\n  const r1 = color1.red;\n  const g1 = color1.green;\n  const b1 = color1.blue;\n  const a1 = color1.alpha;\n\n  if (Color.equals(color0, color1)) {\n    for (i = 0; i < numPoints; i++) {\n      array[offset++] = Color.floatToByte(r0);\n      array[offset++] = Color.floatToByte(g0);\n      array[offset++] = Color.floatToByte(b0);\n      array[offset++] = Color.floatToByte(a0);\n    }\n    return offset;\n  }\n\n  const redPerVertex = (r1 - r0) / numPoints;\n  const greenPerVertex = (g1 - g0) / numPoints;\n  const bluePerVertex = (b1 - b0) / numPoints;\n  const alphaPerVertex = (a1 - a0) / numPoints;\n\n  let index = offset;\n  for (i = 0; i < numPoints; i++) {\n    array[index++] = Color.floatToByte(r0 + i * redPerVertex);\n    array[index++] = Color.floatToByte(g0 + i * greenPerVertex);\n    array[index++] = Color.floatToByte(b0 + i * bluePerVertex);\n    array[index++] = Color.floatToByte(a0 + i * alphaPerVertex);\n  }\n\n  return index;\n}\n\n/**\n * A description of a polyline modeled as a line strip; the first two positions define a line segment,\n * and each additional position defines a line segment from the previous position.\n *\n * @alias SimplePolylineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the positions in the polyline as a line strip.\n * @param {Color[]} [options.colors] An Array of {@link Color} defining the per vertex or per segment colors.\n * @param {boolean} [options.colorsPerVertex=false] A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to be used as a reference.\n *\n * @exception {DeveloperError} At least two positions are required.\n * @exception {DeveloperError} colors has an invalid length.\n *\n * @see SimplePolylineGeometry#createGeometry\n *\n * @example\n * // A polyline with two connected line segments\n * const polyline = new Cesium.SimplePolylineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     0.0, 0.0,\n *     5.0, 0.0,\n *     5.0, 5.0\n *   ])\n * });\n * const geometry = Cesium.SimplePolylineGeometry.createGeometry(polyline);\n */\nfunction SimplePolylineGeometry(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const positions = options.positions;\n  const colors = options.colors;\n  const colorsPerVertex = options.colorsPerVertex ?? false;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions) || positions.length < 2) {\n    throw new DeveloperError(\"At least two positions are required.\");\n  }\n  if (\n    defined(colors) &&\n    ((colorsPerVertex && colors.length < positions.length) ||\n      (!colorsPerVertex && colors.length < positions.length - 1))\n  ) {\n    throw new DeveloperError(\"colors has an invalid length.\");\n  }\n  //>>includeEnd('debug');\n\n  this._positions = positions;\n  this._colors = colors;\n  this._colorsPerVertex = colorsPerVertex;\n\n  this._arcType = options.arcType ?? ArcType.GEODESIC;\n  this._granularity = options.granularity ?? CesiumMath.RADIANS_PER_DEGREE;\n  this._ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n  this._workerName = \"createSimplePolylineGeometry\";\n\n  let numComponents = 1 + positions.length * Cartesian3.packedLength;\n  numComponents += defined(colors) ? 1 + colors.length * Color.packedLength : 1;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  this.packedLength = numComponents + Ellipsoid.packedLength + 3;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {SimplePolylineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nSimplePolylineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  let i;\n\n  const positions = value._positions;\n  let length = positions.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  const colors = value._colors;\n  length = defined(colors) ? colors.length : 0.0;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    Color.pack(colors[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._colorsPerVertex ? 1.0 : 0.0;\n  array[startingIndex++] = value._arcType;\n  array[startingIndex] = value._granularity;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {SimplePolylineGeometry} [result] The object into which to store the result.\n * @returns {SimplePolylineGeometry} The modified result parameter or a new SimplePolylineGeometry instance if one was not provided.\n */\nSimplePolylineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  let i;\n\n  let length = array[startingIndex++];\n  const positions = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  length = array[startingIndex++];\n  const colors = length > 0 ? new Array(length) : undefined;\n\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    colors[i] = Color.unpack(array, startingIndex);\n  }\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  const colorsPerVertex = array[startingIndex++] === 1.0;\n  const arcType = array[startingIndex++];\n  const granularity = array[startingIndex];\n\n  if (!defined(result)) {\n    return new SimplePolylineGeometry({\n      positions: positions,\n      colors: colors,\n      ellipsoid: ellipsoid,\n      colorsPerVertex: colorsPerVertex,\n      arcType: arcType,\n      granularity: granularity,\n    });\n  }\n\n  result._positions = positions;\n  result._colors = colors;\n  result._ellipsoid = ellipsoid;\n  result._colorsPerVertex = colorsPerVertex;\n  result._arcType = arcType;\n  result._granularity = granularity;\n\n  return result;\n};\n\nconst scratchArray1 = new Array(2);\nconst scratchArray2 = new Array(2);\nconst generateArcOptionsScratch = {\n  positions: scratchArray1,\n  height: scratchArray2,\n  ellipsoid: undefined,\n  minDistance: undefined,\n  granularity: undefined,\n};\n\n/**\n * Computes the geometric representation of a simple polyline, including its vertices, indices, and a bounding sphere.\n *\n * @param {SimplePolylineGeometry} simplePolylineGeometry A description of the polyline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nSimplePolylineGeometry.createGeometry = function (simplePolylineGeometry) {\n  const positions = simplePolylineGeometry._positions;\n  const colors = simplePolylineGeometry._colors;\n  const colorsPerVertex = simplePolylineGeometry._colorsPerVertex;\n  const arcType = simplePolylineGeometry._arcType;\n  const granularity = simplePolylineGeometry._granularity;\n  const ellipsoid = simplePolylineGeometry._ellipsoid;\n\n  const minDistance = CesiumMath.chordLength(\n    granularity,\n    ellipsoid.maximumRadius,\n  );\n  const perSegmentColors = defined(colors) && !colorsPerVertex;\n\n  let i;\n  const length = positions.length;\n\n  let positionValues;\n  let numberOfPositions;\n  let colorValues;\n  let color;\n  let offset = 0;\n\n  if (arcType === ArcType.GEODESIC || arcType === ArcType.RHUMB) {\n    let subdivisionSize;\n    let numberOfPointsFunction;\n    let generateArcFunction;\n    if (arcType === ArcType.GEODESIC) {\n      subdivisionSize = CesiumMath.chordLength(\n        granularity,\n        ellipsoid.maximumRadius,\n      );\n      numberOfPointsFunction = PolylinePipeline.numberOfPoints;\n      generateArcFunction = PolylinePipeline.generateArc;\n    } else {\n      subdivisionSize = granularity;\n      numberOfPointsFunction = PolylinePipeline.numberOfPointsRhumbLine;\n      generateArcFunction = PolylinePipeline.generateRhumbArc;\n    }\n\n    const heights = PolylinePipeline.extractHeights(positions, ellipsoid);\n\n    const generateArcOptions = generateArcOptionsScratch;\n    if (arcType === ArcType.GEODESIC) {\n      generateArcOptions.minDistance = minDistance;\n    } else {\n      generateArcOptions.granularity = granularity;\n    }\n    generateArcOptions.ellipsoid = ellipsoid;\n\n    if (perSegmentColors) {\n      let positionCount = 0;\n      for (i = 0; i < length - 1; i++) {\n        positionCount +=\n          numberOfPointsFunction(\n            positions[i],\n            positions[i + 1],\n            subdivisionSize,\n          ) + 1;\n      }\n\n      positionValues = new Float64Array(positionCount * 3);\n      colorValues = new Uint8Array(positionCount * 4);\n\n      generateArcOptions.positions = scratchArray1;\n      generateArcOptions.height = scratchArray2;\n\n      let ci = 0;\n      for (i = 0; i < length - 1; ++i) {\n        scratchArray1[0] = positions[i];\n        scratchArray1[1] = positions[i + 1];\n\n        scratchArray2[0] = heights[i];\n        scratchArray2[1] = heights[i + 1];\n\n        const pos = generateArcFunction(generateArcOptions);\n\n        if (defined(colors)) {\n          const segLen = pos.length / 3;\n          color = colors[i];\n          for (let k = 0; k < segLen; ++k) {\n            colorValues[ci++] = Color.floatToByte(color.red);\n            colorValues[ci++] = Color.floatToByte(color.green);\n            colorValues[ci++] = Color.floatToByte(color.blue);\n            colorValues[ci++] = Color.floatToByte(color.alpha);\n          }\n        }\n\n        positionValues.set(pos, offset);\n        offset += pos.length;\n      }\n    } else {\n      generateArcOptions.positions = positions;\n      generateArcOptions.height = heights;\n      positionValues = new Float64Array(\n        generateArcFunction(generateArcOptions),\n      );\n\n      if (defined(colors)) {\n        colorValues = new Uint8Array((positionValues.length / 3) * 4);\n\n        for (i = 0; i < length - 1; ++i) {\n          const p0 = positions[i];\n          const p1 = positions[i + 1];\n          const c0 = colors[i];\n          const c1 = colors[i + 1];\n          offset = interpolateColors(\n            p0,\n            p1,\n            c0,\n            c1,\n            minDistance,\n            colorValues,\n            offset,\n          );\n        }\n\n        const lastColor = colors[length - 1];\n        colorValues[offset++] = Color.floatToByte(lastColor.red);\n        colorValues[offset++] = Color.floatToByte(lastColor.green);\n        colorValues[offset++] = Color.floatToByte(lastColor.blue);\n        colorValues[offset++] = Color.floatToByte(lastColor.alpha);\n      }\n    }\n  } else {\n    numberOfPositions = perSegmentColors ? length * 2 - 2 : length;\n    positionValues = new Float64Array(numberOfPositions * 3);\n    colorValues = defined(colors)\n      ? new Uint8Array(numberOfPositions * 4)\n      : undefined;\n\n    let positionIndex = 0;\n    let colorIndex = 0;\n\n    for (i = 0; i < length; ++i) {\n      const p = positions[i];\n\n      if (perSegmentColors && i > 0) {\n        Cartesian3.pack(p, positionValues, positionIndex);\n        positionIndex += 3;\n\n        color = colors[i - 1];\n        colorValues[colorIndex++] = Color.floatToByte(color.red);\n        colorValues[colorIndex++] = Color.floatToByte(color.green);\n        colorValues[colorIndex++] = Color.floatToByte(color.blue);\n        colorValues[colorIndex++] = Color.floatToByte(color.alpha);\n      }\n\n      if (perSegmentColors && i === length - 1) {\n        break;\n      }\n\n      Cartesian3.pack(p, positionValues, positionIndex);\n      positionIndex += 3;\n\n      if (defined(colors)) {\n        color = colors[i];\n        colorValues[colorIndex++] = Color.floatToByte(color.red);\n        colorValues[colorIndex++] = Color.floatToByte(color.green);\n        colorValues[colorIndex++] = Color.floatToByte(color.blue);\n        colorValues[colorIndex++] = Color.floatToByte(color.alpha);\n      }\n    }\n  }\n\n  const attributes = new GeometryAttributes();\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positionValues,\n  });\n\n  if (defined(colors)) {\n    attributes.color = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 4,\n      values: colorValues,\n      normalize: true,\n    });\n  }\n\n  numberOfPositions = positionValues.length / 3;\n  const numberOfIndices = (numberOfPositions - 1) * 2;\n  const indices = IndexDatatype.createTypedArray(\n    numberOfPositions,\n    numberOfIndices,\n  );\n\n  let index = 0;\n  for (i = 0; i < numberOfPositions - 1; ++i) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: BoundingSphere.fromPoints(positions),\n  });\n};\nexport default SimplePolylineGeometry;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}