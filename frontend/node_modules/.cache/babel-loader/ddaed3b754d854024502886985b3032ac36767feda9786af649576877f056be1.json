{"ast":null,"code":"import Check from \"./Check.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrthographicOffCenterFrustum from \"./OrthographicOffCenterFrustum.js\";\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias OrthographicFrustum\n * @constructor\n *\n * @param {object} [options] An object with the following properties:\n * @param {number} [options.width] The width of the frustum in meters.\n * @param {number} [options.aspectRatio] The aspect ratio of the frustum's width to it's height.\n * @param {number} [options.near=1.0] The distance of the near plane.\n * @param {number} [options.far=500000000.0] The distance of the far plane.\n *\n * @example\n * const maxRadii = ellipsoid.maximumRadius;\n *\n * const frustum = new Cesium.OrthographicFrustum();\n * frustum.near = 0.01 * maxRadii;\n * frustum.far = 50.0 * maxRadii;\n */\nfunction OrthographicFrustum(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  this._offCenterFrustum = new OrthographicOffCenterFrustum();\n\n  /**\n   * The horizontal width of the frustum in meters.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.width = options.width;\n  this._width = undefined;\n\n  /**\n   * The aspect ratio of the frustum's width to it's height.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.aspectRatio = options.aspectRatio;\n  this._aspectRatio = undefined;\n\n  /**\n   * The distance of the near plane.\n   * @type {number}\n   * @default 1.0\n   */\n  this.near = options.near ?? 1.0;\n  this._near = this.near;\n\n  /**\n   * The distance of the far plane.\n   * @type {number}\n   * @default 500000000.0;\n   */\n  this.far = options.far ?? 500000000.0;\n  this._far = this.far;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nOrthographicFrustum.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {OrthographicFrustum} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nOrthographicFrustum.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n  array[startingIndex++] = value.width;\n  array[startingIndex++] = value.aspectRatio;\n  array[startingIndex++] = value.near;\n  array[startingIndex] = value.far;\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {OrthographicFrustum} [result] The object into which to store the result.\n * @returns {OrthographicFrustum} The modified result parameter or a new OrthographicFrustum instance if one was not provided.\n */\nOrthographicFrustum.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n  if (!defined(result)) {\n    result = new OrthographicFrustum();\n  }\n  result.width = array[startingIndex++];\n  result.aspectRatio = array[startingIndex++];\n  result.near = array[startingIndex++];\n  result.far = array[startingIndex];\n  return result;\n};\nfunction update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(frustum.width) || !defined(frustum.aspectRatio) || !defined(frustum.near) || !defined(frustum.far)) {\n    throw new DeveloperError(\"width, aspectRatio, near, or far parameters are not set.\");\n  }\n  //>>includeEnd('debug');\n\n  const f = frustum._offCenterFrustum;\n  if (frustum.width !== frustum._width || frustum.aspectRatio !== frustum._aspectRatio || frustum.near !== frustum._near || frustum.far !== frustum._far) {\n    //>>includeStart('debug', pragmas.debug);\n    if (frustum.aspectRatio < 0) {\n      throw new DeveloperError(\"aspectRatio must be positive.\");\n    }\n    if (frustum.near < 0 || frustum.near > frustum.far) {\n      throw new DeveloperError(\"near must be greater than zero and less than far.\");\n    }\n    //>>includeEnd('debug');\n\n    frustum._aspectRatio = frustum.aspectRatio;\n    frustum._width = frustum.width;\n    frustum._near = frustum.near;\n    frustum._far = frustum.far;\n    const ratio = 1.0 / frustum.aspectRatio;\n    f.right = frustum.width * 0.5;\n    f.left = -f.right;\n    f.top = ratio * f.right;\n    f.bottom = -f.top;\n    f.near = frustum.near;\n    f.far = frustum.far;\n  }\n}\nObject.defineProperties(OrthographicFrustum.prototype, {\n  /**\n   * Gets the orthographic projection matrix computed from the view frustum.\n   * @memberof OrthographicFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   */\n  projectionMatrix: {\n    get: function () {\n      update(this);\n      return this._offCenterFrustum.projectionMatrix;\n    }\n  },\n  /**\n   * Gets the orthographic projection matrix computed from the view frustum.\n   * @memberof OrthographicFrustum.prototype\n   * @type {OrthographicOffCenterFrustum}\n   * @readonly\n   * @private\n   */\n  offCenterFrustum: {\n    get: function () {\n      update(this);\n      return this._offCenterFrustum;\n    }\n  }\n});\n\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);\n */\nOrthographicFrustum.prototype.computeCullingVolume = function (position, direction, up) {\n  update(this);\n  return this._offCenterFrustum.computeCullingVolume(position, direction, up);\n};\n\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {number} drawingBufferWidth The width of the drawing buffer.\n * @param {number} drawingBufferHeight The height of the drawing buffer.\n * @param {number} distance The distance to the near plane in meters.\n * @param {number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new Cesium.Cartesian2());\n */\nOrthographicFrustum.prototype.getPixelDimensions = function (drawingBufferWidth, drawingBufferHeight, distance, pixelRatio, result) {\n  update(this);\n  return this._offCenterFrustum.getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, pixelRatio, result);\n};\n\n/**\n * Returns a duplicate of a OrthographicFrustum instance.\n *\n * @param {OrthographicFrustum} [result] The object onto which to store the result.\n * @returns {OrthographicFrustum} The modified result parameter or a new OrthographicFrustum instance if one was not provided.\n */\nOrthographicFrustum.prototype.clone = function (result) {\n  if (!defined(result)) {\n    result = new OrthographicFrustum();\n  }\n  result.aspectRatio = this.aspectRatio;\n  result.width = this.width;\n  result.near = this.near;\n  result.far = this.far;\n\n  // force update of clone to compute matrices\n  result._aspectRatio = undefined;\n  result._width = undefined;\n  result._near = undefined;\n  result._far = undefined;\n  this._offCenterFrustum.clone(result._offCenterFrustum);\n  return result;\n};\n\n/**\n * Compares the provided OrthographicFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrthographicFrustum} [other] The right hand side OrthographicFrustum.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nOrthographicFrustum.prototype.equals = function (other) {\n  if (!defined(other) || !(other instanceof OrthographicFrustum)) {\n    return false;\n  }\n  update(this);\n  update(other);\n  return this.width === other.width && this.aspectRatio === other.aspectRatio && this._offCenterFrustum.equals(other._offCenterFrustum);\n};\n\n/**\n * Compares the provided OrthographicFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {OrthographicFrustum} other The right hand side OrthographicFrustum.\n * @param {number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\nOrthographicFrustum.prototype.equalsEpsilon = function (other, relativeEpsilon, absoluteEpsilon) {\n  if (!defined(other) || !(other instanceof OrthographicFrustum)) {\n    return false;\n  }\n  update(this);\n  update(other);\n  return CesiumMath.equalsEpsilon(this.width, other.width, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(this.aspectRatio, other.aspectRatio, relativeEpsilon, absoluteEpsilon) && this._offCenterFrustum.equalsEpsilon(other._offCenterFrustum, relativeEpsilon, absoluteEpsilon);\n};\nexport default OrthographicFrustum;","map":{"version":3,"names":["Check","Frozen","defined","DeveloperError","CesiumMath","OrthographicOffCenterFrustum","OrthographicFrustum","options","EMPTY_OBJECT","_offCenterFrustum","width","_width","undefined","aspectRatio","_aspectRatio","near","_near","far","_far","packedLength","pack","value","array","startingIndex","typeOf","object","unpack","result","update","frustum","f","ratio","right","left","top","bottom","Object","defineProperties","prototype","projectionMatrix","get","offCenterFrustum","computeCullingVolume","position","direction","up","getPixelDimensions","drawingBufferWidth","drawingBufferHeight","distance","pixelRatio","clone","equals","other","equalsEpsilon","relativeEpsilon","absoluteEpsilon"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/OrthographicFrustum.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrthographicOffCenterFrustum from \"./OrthographicOffCenterFrustum.js\";\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias OrthographicFrustum\n * @constructor\n *\n * @param {object} [options] An object with the following properties:\n * @param {number} [options.width] The width of the frustum in meters.\n * @param {number} [options.aspectRatio] The aspect ratio of the frustum's width to it's height.\n * @param {number} [options.near=1.0] The distance of the near plane.\n * @param {number} [options.far=500000000.0] The distance of the far plane.\n *\n * @example\n * const maxRadii = ellipsoid.maximumRadius;\n *\n * const frustum = new Cesium.OrthographicFrustum();\n * frustum.near = 0.01 * maxRadii;\n * frustum.far = 50.0 * maxRadii;\n */\nfunction OrthographicFrustum(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  this._offCenterFrustum = new OrthographicOffCenterFrustum();\n\n  /**\n   * The horizontal width of the frustum in meters.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.width = options.width;\n  this._width = undefined;\n\n  /**\n   * The aspect ratio of the frustum's width to it's height.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.aspectRatio = options.aspectRatio;\n  this._aspectRatio = undefined;\n\n  /**\n   * The distance of the near plane.\n   * @type {number}\n   * @default 1.0\n   */\n  this.near = options.near ?? 1.0;\n  this._near = this.near;\n\n  /**\n   * The distance of the far plane.\n   * @type {number}\n   * @default 500000000.0;\n   */\n  this.far = options.far ?? 500000000.0;\n  this._far = this.far;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nOrthographicFrustum.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {OrthographicFrustum} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nOrthographicFrustum.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  array[startingIndex++] = value.width;\n  array[startingIndex++] = value.aspectRatio;\n  array[startingIndex++] = value.near;\n  array[startingIndex] = value.far;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {OrthographicFrustum} [result] The object into which to store the result.\n * @returns {OrthographicFrustum} The modified result parameter or a new OrthographicFrustum instance if one was not provided.\n */\nOrthographicFrustum.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  if (!defined(result)) {\n    result = new OrthographicFrustum();\n  }\n\n  result.width = array[startingIndex++];\n  result.aspectRatio = array[startingIndex++];\n  result.near = array[startingIndex++];\n  result.far = array[startingIndex];\n\n  return result;\n};\n\nfunction update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(frustum.width) ||\n    !defined(frustum.aspectRatio) ||\n    !defined(frustum.near) ||\n    !defined(frustum.far)\n  ) {\n    throw new DeveloperError(\n      \"width, aspectRatio, near, or far parameters are not set.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const f = frustum._offCenterFrustum;\n\n  if (\n    frustum.width !== frustum._width ||\n    frustum.aspectRatio !== frustum._aspectRatio ||\n    frustum.near !== frustum._near ||\n    frustum.far !== frustum._far\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (frustum.aspectRatio < 0) {\n      throw new DeveloperError(\"aspectRatio must be positive.\");\n    }\n    if (frustum.near < 0 || frustum.near > frustum.far) {\n      throw new DeveloperError(\n        \"near must be greater than zero and less than far.\",\n      );\n    }\n    //>>includeEnd('debug');\n\n    frustum._aspectRatio = frustum.aspectRatio;\n    frustum._width = frustum.width;\n    frustum._near = frustum.near;\n    frustum._far = frustum.far;\n\n    const ratio = 1.0 / frustum.aspectRatio;\n    f.right = frustum.width * 0.5;\n    f.left = -f.right;\n    f.top = ratio * f.right;\n    f.bottom = -f.top;\n    f.near = frustum.near;\n    f.far = frustum.far;\n  }\n}\n\nObject.defineProperties(OrthographicFrustum.prototype, {\n  /**\n   * Gets the orthographic projection matrix computed from the view frustum.\n   * @memberof OrthographicFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   */\n  projectionMatrix: {\n    get: function () {\n      update(this);\n      return this._offCenterFrustum.projectionMatrix;\n    },\n  },\n  /**\n   * Gets the orthographic projection matrix computed from the view frustum.\n   * @memberof OrthographicFrustum.prototype\n   * @type {OrthographicOffCenterFrustum}\n   * @readonly\n   * @private\n   */\n  offCenterFrustum: {\n    get: function () {\n      update(this);\n      return this._offCenterFrustum;\n    },\n  },\n});\n\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);\n */\nOrthographicFrustum.prototype.computeCullingVolume = function (\n  position,\n  direction,\n  up,\n) {\n  update(this);\n  return this._offCenterFrustum.computeCullingVolume(position, direction, up);\n};\n\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {number} drawingBufferWidth The width of the drawing buffer.\n * @param {number} drawingBufferHeight The height of the drawing buffer.\n * @param {number} distance The distance to the near plane in meters.\n * @param {number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new Cesium.Cartesian2());\n */\nOrthographicFrustum.prototype.getPixelDimensions = function (\n  drawingBufferWidth,\n  drawingBufferHeight,\n  distance,\n  pixelRatio,\n  result,\n) {\n  update(this);\n  return this._offCenterFrustum.getPixelDimensions(\n    drawingBufferWidth,\n    drawingBufferHeight,\n    distance,\n    pixelRatio,\n    result,\n  );\n};\n\n/**\n * Returns a duplicate of a OrthographicFrustum instance.\n *\n * @param {OrthographicFrustum} [result] The object onto which to store the result.\n * @returns {OrthographicFrustum} The modified result parameter or a new OrthographicFrustum instance if one was not provided.\n */\nOrthographicFrustum.prototype.clone = function (result) {\n  if (!defined(result)) {\n    result = new OrthographicFrustum();\n  }\n\n  result.aspectRatio = this.aspectRatio;\n  result.width = this.width;\n  result.near = this.near;\n  result.far = this.far;\n\n  // force update of clone to compute matrices\n  result._aspectRatio = undefined;\n  result._width = undefined;\n  result._near = undefined;\n  result._far = undefined;\n\n  this._offCenterFrustum.clone(result._offCenterFrustum);\n\n  return result;\n};\n\n/**\n * Compares the provided OrthographicFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrthographicFrustum} [other] The right hand side OrthographicFrustum.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nOrthographicFrustum.prototype.equals = function (other) {\n  if (!defined(other) || !(other instanceof OrthographicFrustum)) {\n    return false;\n  }\n\n  update(this);\n  update(other);\n\n  return (\n    this.width === other.width &&\n    this.aspectRatio === other.aspectRatio &&\n    this._offCenterFrustum.equals(other._offCenterFrustum)\n  );\n};\n\n/**\n * Compares the provided OrthographicFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {OrthographicFrustum} other The right hand side OrthographicFrustum.\n * @param {number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\nOrthographicFrustum.prototype.equalsEpsilon = function (\n  other,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  if (!defined(other) || !(other instanceof OrthographicFrustum)) {\n    return false;\n  }\n\n  update(this);\n  update(other);\n\n  return (\n    CesiumMath.equalsEpsilon(\n      this.width,\n      other.width,\n      relativeEpsilon,\n      absoluteEpsilon,\n    ) &&\n    CesiumMath.equalsEpsilon(\n      this.aspectRatio,\n      other.aspectRatio,\n      relativeEpsilon,\n      absoluteEpsilon,\n    ) &&\n    this._offCenterFrustum.equalsEpsilon(\n      other._offCenterFrustum,\n      relativeEpsilon,\n      absoluteEpsilon,\n    )\n  );\n};\nexport default OrthographicFrustum;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}