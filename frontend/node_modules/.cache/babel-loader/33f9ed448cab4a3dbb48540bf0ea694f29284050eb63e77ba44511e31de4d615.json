{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-hex.js\";\nimport \"core-js/modules/esnext.uint8-array.to-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.to-hex.js\";\nimport Check from \"../../Core/Check.js\";\nimport defined from \"../../Core/defined.js\";\nimport Cartesian2 from \"../../Core/Cartesian2.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport AttributeCompression from \"../../Core/AttributeCompression.js\";\nimport IndexDatatype from \"../../Core/IndexDatatype.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport AttributeType from \"../AttributeType.js\";\n\n/**\n * A class for reading the data from a <code>ModelComponents.Attribute</code>.\n *\n * NOTE: Much of the functionality here already exists, scattered in many places.\n * In most cases, the functionality is tailored for \"one case\" (like only handling\n * positions, or only normals, or not considering quantization, or not handling\n * interleaved buffers, ...). In many cases, the functionality is tailored for an\n * 'accessor' (and often, the functions also expect the 'gltf' to be given).\n * Most of what is done here (and in the existing functions) is pretty low-level\n * and generic, though: The functions could often be fed with some (count, type,\n * componentType), and there could be convenience functions that EITHER take these\n * values from an 'accessor' OR from an 'attribute'. The tl;dr: Large parts of\n * this could be \"nicer\", or \"more generic\", and \"better\" along all dimensions\n * of this term. Just give me time...\n *\n * NOTE: The fact that all this has to operate on TypedArray is unfortunate.\n * Most of the subsequent processing could operate on some abstraction of\n * that. The fact that that TypedArrays can be read/written as \"bulk\", and\n * then offer access that is \"as efficient as it can be\" could be a\n * justification, as part of the performance-genericity trade-off\n *\n * NOTE: All this does not properly handle MATn types. There should be SOME\n * abstraction for element- and component-wise access of the data. See\n * https://github.com/javagl/JglTF/blob/84ce6d019fec3b75b6af1649bbe834005b2c620f/jgltf-model/src/main/java/de/javagl/jgltf/model/AbstractAccessorData.java#L149\n *\n * @private\n */\nclass ModelReader {\n  /**\n   * Reads the data of the given atttribute into a typed array.\n   *\n   * This will read the data into a compact, flat array with the data\n   * type corresponding to the data type of the attribute.\n   *\n   * If the attribute is contained in an interleaved buffer, marked as\n   * 'normalized', quantized, or oct-encoded, then it will be deinterleaved,\n   * normalization will be applied, it will be dequantized and oct-decoded\n   * as necessary.\n   *\n   * The result will be THE actual attribute data.\n   *\n   * @param {ModelComponents.Attribute} attribute The attribute\n   * @returns {TypedArray} The attribute data\n   */\n  static readAttributeAsTypedArray(attribute) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"attribute\", attribute);\n    //>>includeEnd('debug');\n\n    // Obtain a compact (non-interleaved) typed array that contains\n    // the components.\n    const compactTypedArray = ModelReader.readAttributeAsRawCompactTypedArray(attribute);\n\n    // If the attribute is not normalized and the data is not quantized\n    // and not normalized, then this can be returned directly\n    const normalized = attribute.normalized;\n    const quantization = attribute.quantization;\n    if (!defined(quantization) && !normalized) {\n      return compactTypedArray;\n    }\n    const elementType = attribute.type;\n    const elementCount = attribute.count;\n\n    // If the attribute is normalized, normalize the data from\n    // the typed array\n    let normalizedTypedArray = compactTypedArray;\n    if (normalized) {\n      // Note that although this is called \"dequantize\", it does\n      // not really \"dequantize\" based on the quantization. It only\n      // performs the conversion from the (normalized) integer\n      // component types into floating point.\n      normalizedTypedArray = AttributeCompression.dequantize(compactTypedArray, attribute.componentDatatype, elementType, elementCount);\n    }\n    if (!defined(quantization)) {\n      return normalizedTypedArray;\n    }\n    // Now, this one actually DOES dequantize...\n    const dequantizedTypedArray = ModelReader.dequantize(normalizedTypedArray, elementCount, elementType, quantization);\n    return dequantizedTypedArray;\n  }\n\n  /**\n   * Read the data of the given attribute into a compact typed array.\n   *\n   * If the attribute is stored as interleaved data, then the result\n   * will be the deinterleaved data. If the data is quantized or\n   * normalized, then the resulting data will be the \"raw\" data,\n   * without applying normalization or dequantization.\n   *\n   * @param {ModelComponents.Attribute} attribute The attribute\n   * @returns {TypedArray} The raw attribute data\n   */\n  static readAttributeAsRawCompactTypedArray(attribute) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"attribute\", attribute);\n    //>>includeEnd('debug');\n\n    const elementType = attribute.type;\n    const elementCount = attribute.count;\n    const componentsPerElement = AttributeType.getNumberOfComponents(elementType);\n    const totalComponentCount = elementCount * componentsPerElement;\n\n    // If the data is quantized, use the quantized component type\n    let componentType = attribute.componentDatatype;\n    const quantization = attribute.quantization;\n    if (defined(quantization)) {\n      componentType = quantization.componentDatatype;\n    }\n    const buffer = attribute.buffer;\n\n    // If the byte stride is the default (i.e. the total element size),\n    // then just fetch the whole buffer data into a typed array of the\n    // desired target type, and return it\n    const byteOffset = attribute.byteOffset;\n    const byteStride = attribute.byteStride;\n    const bytesPerComponent = ComponentDatatype.getSizeInBytes(componentType);\n    const defaultByteStride = componentsPerElement * bytesPerComponent;\n    if (!defined(byteStride) || byteStride === defaultByteStride) {\n      const typedArray = ComponentDatatype.createTypedArray(componentType, totalComponentCount);\n      buffer.getBufferData(typedArray, byteOffset);\n      return typedArray;\n    }\n\n    // Fetch the whole buffer in its raw form, to pick out the\n    // interleaved values.\n    // Note: When ALL attributes have to be fetched from an\n    // interleaved buffer, then this getBufferData call will\n    // be performed multiple times. It would be preferable to\n    // have ONE \"TypedArray[] getThemFrom(buffer)\" call that\n    // returns all of the (interleaved) attributes at once,\n    // but this requires abstractions that we don't have.\n    const fullTypedArray = new Uint8Array(buffer.sizeInBytes);\n    buffer.getBufferData(fullTypedArray);\n\n    // Read the components of each element, and write them into\n    // a typed array in a compact form\n    const compactTypedArray = ComponentDatatype.createTypedArray(componentType, totalComponentCount);\n    const elementByteStride = byteStride ?? defaultByteStride;\n    const dataView = new DataView(fullTypedArray.buffer, fullTypedArray.byteOffset, fullTypedArray.byteLength);\n    const components = new Array(componentsPerElement);\n    const componentsReader = ModelReader.createComponentsReader(componentType);\n    for (let i = 0; i < elementCount; ++i) {\n      const elementByteOffset = byteOffset + i * elementByteStride;\n      componentsReader(dataView, elementByteOffset, componentsPerElement, components);\n      for (let j = 0; j < componentsPerElement; ++j) {\n        compactTypedArray[i * componentsPerElement + j] = components[j];\n      }\n    }\n    return compactTypedArray;\n  }\n\n  /**\n   * Dequantize the data from the given input array, based on the given\n   * quantization information, and return the result.\n   *\n   * This assumes that normalization has already been applied. This means that\n   * when the <code>quantization.normalized</code> flag is <code>true</code>,\n   * then the input is assumed to contain floating point values in the range\n   * [-1, 1].\n   *\n   * @param {TypedArray} quantizedTypedArray The quantized typed array\n   * @param {number} elementCount The number of elements\n   * @param {AttributeType} elementType The element type\n   * @param {ModelComponents.Quantization} quantization The quantization\n   * @returns {TypedArray} The result\n   * @throws DeveloperError When the element type is not SCALAR, VEC2,\n   * VEC3, or VEC4\n   */\n  static dequantize(quantizedTypedArray, elementCount, elementType, quantization) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"quantizedTypedArray\", quantizedTypedArray);\n    Check.typeOf.number.greaterThanOrEquals(\"elementCount\", elementCount, 0);\n    Check.defined(\"elementType\", elementType);\n    Check.defined(\"quantization\", quantization);\n    //>>includeEnd('debug');\n\n    if (quantization.octEncoded) {\n      const dequantizedTypedArray = ModelReader.octDecode(quantizedTypedArray, elementCount, quantization.normalizationRange, undefined);\n      if (quantization.octEncodedZXY) {\n        ModelReader.convertZxyToXyz(dequantizedTypedArray, dequantizedTypedArray);\n      }\n      return dequantizedTypedArray;\n    }\n\n    // These could be generalized, if the offset/stepSize were not\n    // CartesianX objects, but arrays...\n    const stepSize = quantization.quantizedVolumeStepSize;\n    const offset = quantization.quantizedVolumeOffset;\n    if (elementType === AttributeType.SCALAR) {\n      return ModelReader.dequantize1D(quantizedTypedArray, elementCount, stepSize, offset, undefined);\n    }\n    if (elementType === AttributeType.VEC2) {\n      return ModelReader.dequantize2D(quantizedTypedArray, elementCount, stepSize, offset, undefined);\n    }\n    if (elementType === AttributeType.VEC3) {\n      return ModelReader.dequantize3D(quantizedTypedArray, elementCount, stepSize, offset, undefined);\n    }\n    if (elementType === AttributeType.VEC4) {\n      return ModelReader.dequantize4D(quantizedTypedArray, elementCount, stepSize, offset, undefined);\n    }\n    throw new DeveloperError(`Element type for dequantization must be SCALAR, VEC2, VEC3, or VEC4, but is ${elementType}`);\n  }\n\n  /**\n   * Decode oct-encoded normals from the given input, and write the\n   * result into the given output, allocating and returning a new\n   * array if the result was undefined.\n   *\n   * This will apply the <code>AttributeCompression.octDecodeInRange</code>\n   * function to each three components of the input.\n   *\n   * @param {TypedArray} quantizedTypedArray The input\n   * @param {number} elementCount The number of elements\n   * @param {number} normalizationRange The normalization range\n   * @param {TypedArray} [dequantizedTypedArray] The result\n   * @returns {TypedArray} The result\n   */\n  static octDecode(quantizedTypedArray, elementCount, normalizationRange, dequantizedTypedArray) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"quantizedTypedArray\", quantizedTypedArray);\n    Check.typeOf.number.greaterThanOrEquals(\"elementCount\", elementCount, 0);\n    Check.typeOf.number.greaterThan(\"normalizationRange\", normalizationRange, 0);\n    //>>includeEnd('debug');\n\n    if (!defined(dequantizedTypedArray)) {\n      dequantizedTypedArray = new Float32Array(quantizedTypedArray.length);\n    }\n    const c = new Cartesian3();\n    for (let i = 0; i < elementCount; i++) {\n      Cartesian3.unpack(quantizedTypedArray, i * 3, c);\n      AttributeCompression.octDecodeInRange(c, normalizationRange, c);\n      Cartesian3.pack(dequantizedTypedArray, c, i * 3);\n    }\n    return dequantizedTypedArray;\n  }\n\n  /**\n   * Swizzle all three consecutive elements in the given input array\n   * from (z, x, y) to (x, y, z), and write the result into the\n   * given output array, creating a new array if the given output\n   * array was undefined.\n   *\n   * @param {TypedArray} input The input\n   * @param {number} elementCount The number of elements\n   * @param {TypedArray} [output] The result\n   * @returns {TypedArray} The result\n   */\n  static convertZxyToXyz(input, elementCount, output) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"input\", input);\n    Check.typeOf.number.greaterThanOrEquals(\"elementCount\", elementCount, 0);\n    //>>includeEnd('debug');\n\n    if (!defined(output)) {\n      output = new Float32Array(input.length);\n    }\n    let offset = 0;\n    for (let i = 0; i < elementCount; i++, offset += 3) {\n      const z = input[offset + 0];\n      const x = input[offset + 1];\n      const y = input[offset + 2];\n      output[offset + 0] = x;\n      output[offset + 1] = y;\n      output[offset + 2] = z;\n    }\n    return output;\n  }\n\n  /**\n   * Dequantize the given quantized array, based on the given quantization\n   * information, and write the result into the given output array, creating\n   * the output array if it was undefined.\n   *\n   * This will simply fill the output array with\n   * <code>output[i] = input[i] * stepSize + offset</code>\n   *\n   * @param {TypedArray} quantizedTypedArray The quantized array\n   * @param {number} elementCount The number of elements\n   * @param {number} stepSize The quantization step size\n   * @param {number} offset The quantization offset\n   * @param {TypedArray} [dequantizedTypedArray] The result\n   * @returns {TypedArray} The result\n   */\n  static dequantize1D(quantizedTypedArray, elementCount, stepSize, offset, dequantizedTypedArray) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"quantizedTypedArray\", quantizedTypedArray);\n    Check.typeOf.number.greaterThanOrEquals(\"elementCount\", elementCount, 0);\n    Check.defined(\"stepSize\", stepSize);\n    Check.defined(\"offset\", offset);\n    //>>includeEnd('debug');\n\n    if (!defined(dequantizedTypedArray)) {\n      dequantizedTypedArray = new Float32Array(quantizedTypedArray.length);\n    }\n    for (let i = 0; i < elementCount; i++) {\n      const q = quantizedTypedArray[i];\n      const d = q * stepSize + offset;\n      dequantizedTypedArray[i] = d;\n    }\n    return dequantizedTypedArray;\n  }\n\n  /**\n   * Dequantize the given quantized array, based on the given quantization\n   * information, and write the result into the given output array, creating\n   * the output array if it was undefined.\n   *\n   * This will simply fill the output array with\n   * <code>output[i] = input[i] * stepSize + offset</code>\n   * when interpreting the input and output as arrays of Cartesian2.\n   *\n   * @param {TypedArray} quantizedTypedArray The quantized array\n   * @param {number} elementCount The number of elements\n   * @param {Cartesian2} stepSize The quantization step size\n   * @param {Cartesian2} offset The quantization offset\n   * @param {TypedArray} [dequantizedTypedArray] The result\n   * @returns {TypedArray} The result\n   */\n  static dequantize2D(quantizedTypedArray, elementCount, stepSize, offset, dequantizedTypedArray) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"quantizedTypedArray\", quantizedTypedArray);\n    Check.typeOf.number.greaterThanOrEquals(\"elementCount\", elementCount, 0);\n    Check.defined(\"stepSize\", stepSize);\n    Check.defined(\"offset\", offset);\n    //>>includeEnd('debug');\n\n    if (!defined(dequantizedTypedArray)) {\n      dequantizedTypedArray = new Float32Array(quantizedTypedArray.length);\n    }\n    const c = new Cartesian2();\n    for (let i = 0; i < elementCount; i++) {\n      Cartesian2.unpack(quantizedTypedArray, i * 2, c);\n      Cartesian2.multiplyComponents(c, stepSize, c);\n      Cartesian2.add(c, offset, c);\n      Cartesian2.pack(c, dequantizedTypedArray, i * 2);\n    }\n    return dequantizedTypedArray;\n  }\n\n  /**\n   * Dequantize the given quantized array, based on the given quantization\n   * information, and write the result into the given output array, creating\n   * the output array if it was undefined.\n   *\n   * This will simply fill the output array with\n   * <code>output[i] = input[i] * stepSize + offset</code>\n   * when interpreting the input and output as arrays of Cartesian3.\n   *\n   * @param {TypedArray} quantizedTypedArray The quantized array\n   * @param {number} elementCount The number of elements\n   * @param {Cartesian3} stepSize The quantization step size\n   * @param {Cartesian3} offset The quantization offset\n   * @param {TypedArray} [dequantizedTypedArray] The result\n   * @returns {TypedArray} The result\n   */\n  static dequantize3D(quantizedTypedArray, elementCount, stepSize, offset, dequantizedTypedArray) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"quantizedTypedArray\", quantizedTypedArray);\n    Check.typeOf.number.greaterThanOrEquals(\"elementCount\", elementCount, 0);\n    Check.defined(\"stepSize\", stepSize);\n    Check.defined(\"offset\", offset);\n    //>>includeEnd('debug');\n\n    if (!defined(dequantizedTypedArray)) {\n      dequantizedTypedArray = new Float32Array(quantizedTypedArray.length);\n    }\n    const c = new Cartesian3();\n    for (let i = 0; i < elementCount; i++) {\n      Cartesian3.unpack(quantizedTypedArray, i * 3, c);\n      Cartesian3.multiplyComponents(c, stepSize, c);\n      Cartesian3.add(c, offset, c);\n      Cartesian3.pack(c, dequantizedTypedArray, i * 3);\n    }\n    return dequantizedTypedArray;\n  }\n\n  /**\n   * Dequantize the given quantized array, based on the given quantization\n   * information, and write the result into the given output array, creating\n   * the output array if it was undefined.\n   *\n   * This will simply fill the output array with\n   * <code>output[i] = input[i] * stepSize + offset</code>\n   * when interpreting the input and output as arrays of Cartesian4.\n   *\n   * @param {TypedArray} quantizedTypedArray The quantized array\n   * @param {number} elementCount The number of elements\n   * @param {Cartesian4} stepSize The quantization step size\n   * @param {Cartesian4} offset The quantization offset\n   * @param {TypedArray} [dequantizedTypedArray] The result\n   * @returns {TypedArray} The result\n   */\n  static dequantize4D(quantizedTypedArray, elementCount, stepSize, offset, dequantizedTypedArray) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"quantizedTypedArray\", quantizedTypedArray);\n    Check.typeOf.number.greaterThanOrEquals(\"elementCount\", elementCount, 0);\n    Check.defined(\"stepSize\", stepSize);\n    Check.defined(\"offset\", offset);\n    //>>includeEnd('debug');\n\n    if (!defined(dequantizedTypedArray)) {\n      dequantizedTypedArray = new Float32Array(quantizedTypedArray.length);\n    }\n    const c = new Cartesian4();\n    for (let i = 0; i < elementCount; i++) {\n      Cartesian4.unpack(quantizedTypedArray, i * 4, c);\n      Cartesian4.multiplyComponents(c, stepSize, c);\n      Cartesian4.add(c, offset, c);\n      Cartesian4.pack(c, dequantizedTypedArray, i * 4);\n    }\n    return dequantizedTypedArray;\n  }\n\n  /**\n   * Reads and returns a value with the given type\n   * at the given byte offset from the data view, in little-endian\n   * order\n   * @callback ComponentsReaderCallback\n   * @param {DataView} dataView Typed data view into a binary buffer\n   * @param {number} byteOffset The offset, in bytes, from the start of the view to read the data from\n   * @param {number} numberOfComponents The number of components to read\n   * @param {number[]} result The array in which to read the result\n   */\n\n  /**\n   * Creates a function that reads the specified number of components with\n   * the given type from the given data view, in little-endian\n   * order, and writes them into a given result array.\n   *\n   * @param {ComponentDatatype} componentType The component type\n   * @returns {ComponentsReaderCallback} The reader\n   */\n  static createComponentsReader(componentType) {\n    const componentReader = ModelReader.createComponentReader(componentType);\n    const sizeInBytes = ComponentDatatype.getSizeInBytes(componentType);\n    return function (dataView, byteOffset, numberOfComponents, result) {\n      let offset = byteOffset;\n      for (let i = 0; i < numberOfComponents; ++i) {\n        result[i] = componentReader(dataView, offset);\n        offset += sizeInBytes;\n      }\n    };\n  }\n\n  /**\n   * Reads and returns a value with the given type\n   * at the given byte offset from the data view, in little-endian\n   * order\n   * @callback ComponentReaderCallback\n   * @param {DataView} dataView Typed data view into a binary buffer\n   * @param {number} byteOffset The offset, in bytes, from the start of the view to read the data from\n   * @returns {number|BigInt} The value read from the dataView\n   */\n\n  /**\n   * Creates a function that reads and returns a value with the given type\n   * at the given byte offset from the data view, in little-endian\n   * order\n   * @param {ComponentDatatype} componentType The component type\n   * @returns {ComponentReaderCallback} The reader\n   */\n  static createComponentReader(componentType) {\n    switch (componentType) {\n      case ComponentDatatype.BYTE:\n        return function (dataView, byteOffset) {\n          return dataView.getInt8(byteOffset);\n        };\n      case ComponentDatatype.UNSIGNED_BYTE:\n        return function (dataView, byteOffset) {\n          return dataView.getUint8(byteOffset);\n        };\n      case ComponentDatatype.SHORT:\n        return function (dataView, byteOffset) {\n          return dataView.getInt16(byteOffset, true);\n        };\n      case ComponentDatatype.UNSIGNED_SHORT:\n        return function (dataView, byteOffset) {\n          return dataView.getUint16(byteOffset, true);\n        };\n      case ComponentDatatype.INT:\n        return function (dataView, byteOffset) {\n          return dataView.getInt32(byteOffset, true);\n        };\n      case ComponentDatatype.UNSIGNED_INT:\n        return function (dataView, byteOffset) {\n          return dataView.getUint32(byteOffset, true);\n        };\n      case ComponentDatatype.FLOAT:\n        return function (dataView, byteOffset) {\n          return dataView.getFloat32(byteOffset, true);\n        };\n      case ComponentDatatype.DOUBLE:\n        return function (dataView, byteOffset) {\n          return dataView.getFloat64(byteOffset, true);\n        };\n    }\n    throw new DeveloperError(`The componentType must be a valid ComponentDatatype, but is ${componentType}`);\n  }\n\n  /**\n   * Transform the elements of the given array with the given 4x4 matrix,\n   * interpreting each 3 consecutive elements as a 3D point, and write\n   * the result into the given result array, creating the result array\n   * if it was undefined.\n   *\n   * @param {TypedArray} input The input array\n   * @param {Matrix4} matrix The matrix\n   * @param {TypedArray} [result] The result\n   * @returns {TypedArray} The result\n   */\n  static transform3D(input, matrix, result) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"input\", input);\n    Check.defined(\"matrix\", matrix);\n    //>>includeEnd('debug');\n\n    if (!defined(result)) {\n      result = new Float32Array(input.length);\n    }\n    const c = new Cartesian3();\n    const elementCount = input.length / 3;\n    for (let i = 0; i < elementCount; i++) {\n      Cartesian3.unpack(input, i * 3, c);\n      Matrix4.multiplyByPoint(matrix, c, c);\n      Cartesian3.pack(c, result, i * 3);\n    }\n    return result;\n  }\n\n  /**\n   * Read the indices values from the given primitive indices, and\n   * return them as a typed array.\n   *\n   * If the given object already has a <code>typedArray/code> property, then it\n   * is assumed that this contains the proper indices, and they are returned.\n   *\n   * Otherwise, this reads the data from the <code>buffer</code> of the given\n   * primitive indices object, into a typed array with a type that matches the\n   * <code>indexDataType</code>, and returns it.\n   *\n   * Clients may not modify the returned typed array.\n   *\n   * @param {ModelComponents.Indices} primitiveIndices The primitive indices\n   * @returns {TypedArray} The indices values\n   * @throws {DeveloperError} If the <code>indexDataType</code> of the given\n   * object is neither <code>UNSIGNED_BYTE</code>, nor <code>UNSIGNED_SHORT</code>,\n   * nor <code>UNSIGNED_INT</code>\n   */\n  static readIndicesAsTypedArray(primitiveIndices) {\n    const existingIndices = primitiveIndices.typedArray;\n    if (defined(existingIndices)) {\n      return existingIndices;\n    }\n    const indicesBuffer = primitiveIndices.buffer;\n    const indicesCount = primitiveIndices.count;\n    const indexDatatype = primitiveIndices.indexDatatype;\n    const indices = ModelReader.createIndexTypedArray(indexDatatype, indicesCount);\n    indicesBuffer.getBufferData(indices);\n    return indices;\n  }\n\n  /**\n   * Read the indices values from the given primitive indices object, and return\n   * them as a typed array of triangle vertex indices.\n   *\n   * If the given primitive type is <code>TRIANGLES</code>, then the indices\n   * values will be read from the given object, and returned.\n   *\n   * If the primitive type is <code>TRIANGLE_STRIP</code> or <code>TRIANGLE_FAN</code>,\n   * then the original indices values, will be read, converted into triangle indices\n   * (i.e. their equivalent <code>TRIANGLES</code> representation), and the result\n   * will be returned.\n   *\n   * The type of the returned array will match the <code>indexDataType</code>\n   * of the given object.\n   *\n   * Clients may not modify the returned typed array.\n   *\n   * @param {ModelComponents.Indices} primitiveIndices The primitive indices\n   * @returns {TypedArray} The indices, converted to triangle indices if necessary\n   * @throws {DeveloperError} If the <code>indexDataType</code> of the given\n   * object is neither <code>UNSIGNED_BYTE</code>, nor <code>UNSIGNED_SHORT</code>,\n   * nor <code>UNSIGNED_INT</code>, or the given <code>primitiveType</code>\n   * is neither <code>TRIANGLES</code>, nor <code>TRIANGLE_STRIP</code>,\n   * nor <code>TRIANGLE_FAN</code>\n   */\n  static readIndicesAsTriangleIndicesTypedArray(primitiveIndices, primitiveType) {\n    const originalIndices = ModelReader.readIndicesAsTypedArray(primitiveIndices);\n    if (primitiveType === PrimitiveType.TRIANGLES) {\n      return originalIndices;\n    }\n    if (primitiveType === PrimitiveType.TRIANGLE_STRIP) {\n      const triangleIndices = ModelReader.convertTriangleStripToTriangleIndices(originalIndices);\n      return triangleIndices;\n    }\n    if (primitiveType === PrimitiveType.TRIANGLE_FAN) {\n      const triangleIndices = ModelReader.convertTriangleFanToTriangleIndices(originalIndices);\n      return triangleIndices;\n    }\n    throw new DeveloperError(`The primitiveType must be TRIANGLES (${PrimitiveType.TRIANGLES}, ` + `TRIANGLE_STRIP (${PrimitiveType.TRIANGLE_STRIP}, or ` + `TRIANGLE_FAN (${PrimitiveType.TRIANGLE_FAN}, but is ${primitiveType}`);\n  }\n\n  /**\n   * Converts the given indices from a <code>TRIANGLE_STRIP</code> representation\n   * into a <code>TRIANGLES</code> representation, and returns the result.\n   *\n   * The type of the result will be the same as the type of the input array.\n   *\n   * @param {TypedArray} indices The input indices\n   * @returns {TypedArray} The resulting triangle indices\n   */\n  static convertTriangleStripToTriangleIndices(indices) {\n    const triangleIndices = indices.constructor((indices.length - 2) * 3);\n    for (let i = 0; i < indices.length - 2; i++) {\n      if (i % 2 === 1) {\n        triangleIndices[i * 3 + 0] = indices[i + 0];\n        triangleIndices[i * 3 + 1] = indices[i + 2];\n        triangleIndices[i * 3 + 2] = indices[i + 1];\n      } else {\n        triangleIndices[i * 3 + 0] = indices[i + 0];\n        triangleIndices[i * 3 + 1] = indices[i + 1];\n        triangleIndices[i * 3 + 2] = indices[i + 2];\n      }\n    }\n    return triangleIndices;\n  }\n\n  /**\n   * Converts the given indices from a <code>TRIANGLE_FAN</code> representation\n   * into a <code>TRIANGLES</code> representation, and returns the result.\n   *\n   * The type of the result will be the same as the type of the input array.\n   *\n   * @param {TypedArray} indices The input indices\n   * @returns {TypedArray} The resulting triangle indices\n   */\n  static convertTriangleFanToTriangleIndices(indices) {\n    const triangleIndices = indices.constructor((indices.length - 2) * 3);\n    for (let i = 0; i < indices.length - 2; i++) {\n      triangleIndices[i * 3 + 0] = indices[i + 0];\n      triangleIndices[i * 3 + 1] = indices[i + 1];\n      triangleIndices[i * 3 + 2] = indices[i + 2];\n    }\n    return triangleIndices;\n  }\n\n  /**\n   * Create a typed array with a type that matches the given index data type,\n   * and the given size.\n   *\n   * @param {number} indexDatatype The <code>IndexDataType</code>\n   * @param {number} size The size of the array that will be created\n   * @returns {TypedArray} The typed array\n   * @throws {DeveloperError} If the <code>indexDataType</code> is neither\n   * <code>UNSIGNED_BYTE</code>, nor <code>UNSIGNED_SHORT</code>,\n   * nor <code>UNSIGNED_INT</code>, or the size is negative.\n   */\n  static createIndexTypedArray(indexDatatype, size) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.typeOf.number.greaterThanOrEquals(\"size\", size, 0);\n    //>>includeEnd('debug');\n\n    switch (indexDatatype) {\n      case IndexDatatype.UNSIGNED_BYTE:\n        return new Uint8Array(size);\n      case IndexDatatype.UNSIGNED_SHORT:\n        return new Uint16Array(size);\n      case IndexDatatype.UNSIGNED_INT:\n        return new Uint32Array(size);\n    }\n    throw new DeveloperError(`The indexDatatype must be UNSIGNED_BYTE (${IndexDatatype.UNSIGNED_BYTE}, ` + `UNSIGNED_SHORT (${IndexDatatype.UNSIGNED_SHORT}, or ` + `UNSIGNED_INT (${IndexDatatype.UNSIGNED_INT}, but is ${indexDatatype}`);\n  }\n}\nexport default ModelReader;","map":{"version":3,"names":["Check","defined","Cartesian2","Cartesian3","Cartesian4","DeveloperError","ComponentDatatype","AttributeCompression","IndexDatatype","PrimitiveType","Matrix4","AttributeType","ModelReader","readAttributeAsTypedArray","attribute","compactTypedArray","readAttributeAsRawCompactTypedArray","normalized","quantization","elementType","type","elementCount","count","normalizedTypedArray","dequantize","componentDatatype","dequantizedTypedArray","componentsPerElement","getNumberOfComponents","totalComponentCount","componentType","buffer","byteOffset","byteStride","bytesPerComponent","getSizeInBytes","defaultByteStride","typedArray","createTypedArray","getBufferData","fullTypedArray","Uint8Array","sizeInBytes","elementByteStride","dataView","DataView","byteLength","components","Array","componentsReader","createComponentsReader","i","elementByteOffset","j","quantizedTypedArray","typeOf","number","greaterThanOrEquals","octEncoded","octDecode","normalizationRange","undefined","octEncodedZXY","convertZxyToXyz","stepSize","quantizedVolumeStepSize","offset","quantizedVolumeOffset","SCALAR","dequantize1D","VEC2","dequantize2D","VEC3","dequantize3D","VEC4","dequantize4D","greaterThan","Float32Array","length","c","unpack","octDecodeInRange","pack","input","output","z","x","y","q","d","multiplyComponents","add","componentReader","createComponentReader","numberOfComponents","result","BYTE","getInt8","UNSIGNED_BYTE","getUint8","SHORT","getInt16","UNSIGNED_SHORT","getUint16","INT","getInt32","UNSIGNED_INT","getUint32","FLOAT","getFloat32","DOUBLE","getFloat64","transform3D","matrix","multiplyByPoint","readIndicesAsTypedArray","primitiveIndices","existingIndices","indicesBuffer","indicesCount","indexDatatype","indices","createIndexTypedArray","readIndicesAsTriangleIndicesTypedArray","primitiveType","originalIndices","TRIANGLES","TRIANGLE_STRIP","triangleIndices","convertTriangleStripToTriangleIndices","TRIANGLE_FAN","convertTriangleFanToTriangleIndices","constructor","size","Uint16Array","Uint32Array"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Model/ModelReader.js"],"sourcesContent":["import Check from \"../../Core/Check.js\";\nimport defined from \"../../Core/defined.js\";\nimport Cartesian2 from \"../../Core/Cartesian2.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport AttributeCompression from \"../../Core/AttributeCompression.js\";\nimport IndexDatatype from \"../../Core/IndexDatatype.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\n\nimport AttributeType from \"../AttributeType.js\";\n\n/**\n * A class for reading the data from a <code>ModelComponents.Attribute</code>.\n *\n * NOTE: Much of the functionality here already exists, scattered in many places.\n * In most cases, the functionality is tailored for \"one case\" (like only handling\n * positions, or only normals, or not considering quantization, or not handling\n * interleaved buffers, ...). In many cases, the functionality is tailored for an\n * 'accessor' (and often, the functions also expect the 'gltf' to be given).\n * Most of what is done here (and in the existing functions) is pretty low-level\n * and generic, though: The functions could often be fed with some (count, type,\n * componentType), and there could be convenience functions that EITHER take these\n * values from an 'accessor' OR from an 'attribute'. The tl;dr: Large parts of\n * this could be \"nicer\", or \"more generic\", and \"better\" along all dimensions\n * of this term. Just give me time...\n *\n * NOTE: The fact that all this has to operate on TypedArray is unfortunate.\n * Most of the subsequent processing could operate on some abstraction of\n * that. The fact that that TypedArrays can be read/written as \"bulk\", and\n * then offer access that is \"as efficient as it can be\" could be a\n * justification, as part of the performance-genericity trade-off\n *\n * NOTE: All this does not properly handle MATn types. There should be SOME\n * abstraction for element- and component-wise access of the data. See\n * https://github.com/javagl/JglTF/blob/84ce6d019fec3b75b6af1649bbe834005b2c620f/jgltf-model/src/main/java/de/javagl/jgltf/model/AbstractAccessorData.java#L149\n *\n * @private\n */\nclass ModelReader {\n  /**\n   * Reads the data of the given atttribute into a typed array.\n   *\n   * This will read the data into a compact, flat array with the data\n   * type corresponding to the data type of the attribute.\n   *\n   * If the attribute is contained in an interleaved buffer, marked as\n   * 'normalized', quantized, or oct-encoded, then it will be deinterleaved,\n   * normalization will be applied, it will be dequantized and oct-decoded\n   * as necessary.\n   *\n   * The result will be THE actual attribute data.\n   *\n   * @param {ModelComponents.Attribute} attribute The attribute\n   * @returns {TypedArray} The attribute data\n   */\n  static readAttributeAsTypedArray(attribute) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"attribute\", attribute);\n    //>>includeEnd('debug');\n\n    // Obtain a compact (non-interleaved) typed array that contains\n    // the components.\n    const compactTypedArray =\n      ModelReader.readAttributeAsRawCompactTypedArray(attribute);\n\n    // If the attribute is not normalized and the data is not quantized\n    // and not normalized, then this can be returned directly\n    const normalized = attribute.normalized;\n    const quantization = attribute.quantization;\n    if (!defined(quantization) && !normalized) {\n      return compactTypedArray;\n    }\n\n    const elementType = attribute.type;\n    const elementCount = attribute.count;\n\n    // If the attribute is normalized, normalize the data from\n    // the typed array\n    let normalizedTypedArray = compactTypedArray;\n    if (normalized) {\n      // Note that although this is called \"dequantize\", it does\n      // not really \"dequantize\" based on the quantization. It only\n      // performs the conversion from the (normalized) integer\n      // component types into floating point.\n      normalizedTypedArray = AttributeCompression.dequantize(\n        compactTypedArray,\n        attribute.componentDatatype,\n        elementType,\n        elementCount,\n      );\n    }\n\n    if (!defined(quantization)) {\n      return normalizedTypedArray;\n    }\n    // Now, this one actually DOES dequantize...\n    const dequantizedTypedArray = ModelReader.dequantize(\n      normalizedTypedArray,\n      elementCount,\n      elementType,\n      quantization,\n    );\n    return dequantizedTypedArray;\n  }\n\n  /**\n   * Read the data of the given attribute into a compact typed array.\n   *\n   * If the attribute is stored as interleaved data, then the result\n   * will be the deinterleaved data. If the data is quantized or\n   * normalized, then the resulting data will be the \"raw\" data,\n   * without applying normalization or dequantization.\n   *\n   * @param {ModelComponents.Attribute} attribute The attribute\n   * @returns {TypedArray} The raw attribute data\n   */\n  static readAttributeAsRawCompactTypedArray(attribute) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"attribute\", attribute);\n    //>>includeEnd('debug');\n\n    const elementType = attribute.type;\n    const elementCount = attribute.count;\n\n    const componentsPerElement =\n      AttributeType.getNumberOfComponents(elementType);\n    const totalComponentCount = elementCount * componentsPerElement;\n\n    // If the data is quantized, use the quantized component type\n    let componentType = attribute.componentDatatype;\n    const quantization = attribute.quantization;\n    if (defined(quantization)) {\n      componentType = quantization.componentDatatype;\n    }\n    const buffer = attribute.buffer;\n\n    // If the byte stride is the default (i.e. the total element size),\n    // then just fetch the whole buffer data into a typed array of the\n    // desired target type, and return it\n    const byteOffset = attribute.byteOffset;\n    const byteStride = attribute.byteStride;\n    const bytesPerComponent = ComponentDatatype.getSizeInBytes(componentType);\n    const defaultByteStride = componentsPerElement * bytesPerComponent;\n    if (!defined(byteStride) || byteStride === defaultByteStride) {\n      const typedArray = ComponentDatatype.createTypedArray(\n        componentType,\n        totalComponentCount,\n      );\n      buffer.getBufferData(typedArray, byteOffset);\n      return typedArray;\n    }\n\n    // Fetch the whole buffer in its raw form, to pick out the\n    // interleaved values.\n    // Note: When ALL attributes have to be fetched from an\n    // interleaved buffer, then this getBufferData call will\n    // be performed multiple times. It would be preferable to\n    // have ONE \"TypedArray[] getThemFrom(buffer)\" call that\n    // returns all of the (interleaved) attributes at once,\n    // but this requires abstractions that we don't have.\n    const fullTypedArray = new Uint8Array(buffer.sizeInBytes);\n    buffer.getBufferData(fullTypedArray);\n\n    // Read the components of each element, and write them into\n    // a typed array in a compact form\n    const compactTypedArray = ComponentDatatype.createTypedArray(\n      componentType,\n      totalComponentCount,\n    );\n    const elementByteStride = byteStride ?? defaultByteStride;\n    const dataView = new DataView(\n      fullTypedArray.buffer,\n      fullTypedArray.byteOffset,\n      fullTypedArray.byteLength,\n    );\n    const components = new Array(componentsPerElement);\n    const componentsReader = ModelReader.createComponentsReader(componentType);\n    for (let i = 0; i < elementCount; ++i) {\n      const elementByteOffset = byteOffset + i * elementByteStride;\n      componentsReader(\n        dataView,\n        elementByteOffset,\n        componentsPerElement,\n        components,\n      );\n      for (let j = 0; j < componentsPerElement; ++j) {\n        compactTypedArray[i * componentsPerElement + j] = components[j];\n      }\n    }\n    return compactTypedArray;\n  }\n\n  /**\n   * Dequantize the data from the given input array, based on the given\n   * quantization information, and return the result.\n   *\n   * This assumes that normalization has already been applied. This means that\n   * when the <code>quantization.normalized</code> flag is <code>true</code>,\n   * then the input is assumed to contain floating point values in the range\n   * [-1, 1].\n   *\n   * @param {TypedArray} quantizedTypedArray The quantized typed array\n   * @param {number} elementCount The number of elements\n   * @param {AttributeType} elementType The element type\n   * @param {ModelComponents.Quantization} quantization The quantization\n   * @returns {TypedArray} The result\n   * @throws DeveloperError When the element type is not SCALAR, VEC2,\n   * VEC3, or VEC4\n   */\n  static dequantize(\n    quantizedTypedArray,\n    elementCount,\n    elementType,\n    quantization,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"quantizedTypedArray\", quantizedTypedArray);\n    Check.typeOf.number.greaterThanOrEquals(\"elementCount\", elementCount, 0);\n    Check.defined(\"elementType\", elementType);\n    Check.defined(\"quantization\", quantization);\n    //>>includeEnd('debug');\n\n    if (quantization.octEncoded) {\n      const dequantizedTypedArray = ModelReader.octDecode(\n        quantizedTypedArray,\n        elementCount,\n        quantization.normalizationRange,\n        undefined,\n      );\n      if (quantization.octEncodedZXY) {\n        ModelReader.convertZxyToXyz(\n          dequantizedTypedArray,\n          dequantizedTypedArray,\n        );\n      }\n      return dequantizedTypedArray;\n    }\n\n    // These could be generalized, if the offset/stepSize were not\n    // CartesianX objects, but arrays...\n    const stepSize = quantization.quantizedVolumeStepSize;\n    const offset = quantization.quantizedVolumeOffset;\n    if (elementType === AttributeType.SCALAR) {\n      return ModelReader.dequantize1D(\n        quantizedTypedArray,\n        elementCount,\n        stepSize,\n        offset,\n        undefined,\n      );\n    }\n    if (elementType === AttributeType.VEC2) {\n      return ModelReader.dequantize2D(\n        quantizedTypedArray,\n        elementCount,\n        stepSize,\n        offset,\n        undefined,\n      );\n    }\n    if (elementType === AttributeType.VEC3) {\n      return ModelReader.dequantize3D(\n        quantizedTypedArray,\n        elementCount,\n        stepSize,\n        offset,\n        undefined,\n      );\n    }\n    if (elementType === AttributeType.VEC4) {\n      return ModelReader.dequantize4D(\n        quantizedTypedArray,\n        elementCount,\n        stepSize,\n        offset,\n        undefined,\n      );\n    }\n    throw new DeveloperError(\n      `Element type for dequantization must be SCALAR, VEC2, VEC3, or VEC4, but is ${elementType}`,\n    );\n  }\n\n  /**\n   * Decode oct-encoded normals from the given input, and write the\n   * result into the given output, allocating and returning a new\n   * array if the result was undefined.\n   *\n   * This will apply the <code>AttributeCompression.octDecodeInRange</code>\n   * function to each three components of the input.\n   *\n   * @param {TypedArray} quantizedTypedArray The input\n   * @param {number} elementCount The number of elements\n   * @param {number} normalizationRange The normalization range\n   * @param {TypedArray} [dequantizedTypedArray] The result\n   * @returns {TypedArray} The result\n   */\n  static octDecode(\n    quantizedTypedArray,\n    elementCount,\n    normalizationRange,\n    dequantizedTypedArray,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"quantizedTypedArray\", quantizedTypedArray);\n    Check.typeOf.number.greaterThanOrEquals(\"elementCount\", elementCount, 0);\n    Check.typeOf.number.greaterThan(\n      \"normalizationRange\",\n      normalizationRange,\n      0,\n    );\n    //>>includeEnd('debug');\n\n    if (!defined(dequantizedTypedArray)) {\n      dequantizedTypedArray = new Float32Array(quantizedTypedArray.length);\n    }\n    const c = new Cartesian3();\n    for (let i = 0; i < elementCount; i++) {\n      Cartesian3.unpack(quantizedTypedArray, i * 3, c);\n      AttributeCompression.octDecodeInRange(c, normalizationRange, c);\n      Cartesian3.pack(dequantizedTypedArray, c, i * 3);\n    }\n    return dequantizedTypedArray;\n  }\n\n  /**\n   * Swizzle all three consecutive elements in the given input array\n   * from (z, x, y) to (x, y, z), and write the result into the\n   * given output array, creating a new array if the given output\n   * array was undefined.\n   *\n   * @param {TypedArray} input The input\n   * @param {number} elementCount The number of elements\n   * @param {TypedArray} [output] The result\n   * @returns {TypedArray} The result\n   */\n  static convertZxyToXyz(input, elementCount, output) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"input\", input);\n    Check.typeOf.number.greaterThanOrEquals(\"elementCount\", elementCount, 0);\n    //>>includeEnd('debug');\n\n    if (!defined(output)) {\n      output = new Float32Array(input.length);\n    }\n    let offset = 0;\n    for (let i = 0; i < elementCount; i++, offset += 3) {\n      const z = input[offset + 0];\n      const x = input[offset + 1];\n      const y = input[offset + 2];\n      output[offset + 0] = x;\n      output[offset + 1] = y;\n      output[offset + 2] = z;\n    }\n    return output;\n  }\n\n  /**\n   * Dequantize the given quantized array, based on the given quantization\n   * information, and write the result into the given output array, creating\n   * the output array if it was undefined.\n   *\n   * This will simply fill the output array with\n   * <code>output[i] = input[i] * stepSize + offset</code>\n   *\n   * @param {TypedArray} quantizedTypedArray The quantized array\n   * @param {number} elementCount The number of elements\n   * @param {number} stepSize The quantization step size\n   * @param {number} offset The quantization offset\n   * @param {TypedArray} [dequantizedTypedArray] The result\n   * @returns {TypedArray} The result\n   */\n  static dequantize1D(\n    quantizedTypedArray,\n    elementCount,\n    stepSize,\n    offset,\n    dequantizedTypedArray,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"quantizedTypedArray\", quantizedTypedArray);\n    Check.typeOf.number.greaterThanOrEquals(\"elementCount\", elementCount, 0);\n    Check.defined(\"stepSize\", stepSize);\n    Check.defined(\"offset\", offset);\n    //>>includeEnd('debug');\n\n    if (!defined(dequantizedTypedArray)) {\n      dequantizedTypedArray = new Float32Array(quantizedTypedArray.length);\n    }\n    for (let i = 0; i < elementCount; i++) {\n      const q = quantizedTypedArray[i];\n      const d = q * stepSize + offset;\n      dequantizedTypedArray[i] = d;\n    }\n    return dequantizedTypedArray;\n  }\n\n  /**\n   * Dequantize the given quantized array, based on the given quantization\n   * information, and write the result into the given output array, creating\n   * the output array if it was undefined.\n   *\n   * This will simply fill the output array with\n   * <code>output[i] = input[i] * stepSize + offset</code>\n   * when interpreting the input and output as arrays of Cartesian2.\n   *\n   * @param {TypedArray} quantizedTypedArray The quantized array\n   * @param {number} elementCount The number of elements\n   * @param {Cartesian2} stepSize The quantization step size\n   * @param {Cartesian2} offset The quantization offset\n   * @param {TypedArray} [dequantizedTypedArray] The result\n   * @returns {TypedArray} The result\n   */\n  static dequantize2D(\n    quantizedTypedArray,\n    elementCount,\n    stepSize,\n    offset,\n    dequantizedTypedArray,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"quantizedTypedArray\", quantizedTypedArray);\n    Check.typeOf.number.greaterThanOrEquals(\"elementCount\", elementCount, 0);\n    Check.defined(\"stepSize\", stepSize);\n    Check.defined(\"offset\", offset);\n    //>>includeEnd('debug');\n\n    if (!defined(dequantizedTypedArray)) {\n      dequantizedTypedArray = new Float32Array(quantizedTypedArray.length);\n    }\n    const c = new Cartesian2();\n    for (let i = 0; i < elementCount; i++) {\n      Cartesian2.unpack(quantizedTypedArray, i * 2, c);\n      Cartesian2.multiplyComponents(c, stepSize, c);\n      Cartesian2.add(c, offset, c);\n      Cartesian2.pack(c, dequantizedTypedArray, i * 2);\n    }\n    return dequantizedTypedArray;\n  }\n\n  /**\n   * Dequantize the given quantized array, based on the given quantization\n   * information, and write the result into the given output array, creating\n   * the output array if it was undefined.\n   *\n   * This will simply fill the output array with\n   * <code>output[i] = input[i] * stepSize + offset</code>\n   * when interpreting the input and output as arrays of Cartesian3.\n   *\n   * @param {TypedArray} quantizedTypedArray The quantized array\n   * @param {number} elementCount The number of elements\n   * @param {Cartesian3} stepSize The quantization step size\n   * @param {Cartesian3} offset The quantization offset\n   * @param {TypedArray} [dequantizedTypedArray] The result\n   * @returns {TypedArray} The result\n   */\n  static dequantize3D(\n    quantizedTypedArray,\n    elementCount,\n    stepSize,\n    offset,\n    dequantizedTypedArray,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"quantizedTypedArray\", quantizedTypedArray);\n    Check.typeOf.number.greaterThanOrEquals(\"elementCount\", elementCount, 0);\n    Check.defined(\"stepSize\", stepSize);\n    Check.defined(\"offset\", offset);\n    //>>includeEnd('debug');\n\n    if (!defined(dequantizedTypedArray)) {\n      dequantizedTypedArray = new Float32Array(quantizedTypedArray.length);\n    }\n    const c = new Cartesian3();\n    for (let i = 0; i < elementCount; i++) {\n      Cartesian3.unpack(quantizedTypedArray, i * 3, c);\n      Cartesian3.multiplyComponents(c, stepSize, c);\n      Cartesian3.add(c, offset, c);\n      Cartesian3.pack(c, dequantizedTypedArray, i * 3);\n    }\n    return dequantizedTypedArray;\n  }\n\n  /**\n   * Dequantize the given quantized array, based on the given quantization\n   * information, and write the result into the given output array, creating\n   * the output array if it was undefined.\n   *\n   * This will simply fill the output array with\n   * <code>output[i] = input[i] * stepSize + offset</code>\n   * when interpreting the input and output as arrays of Cartesian4.\n   *\n   * @param {TypedArray} quantizedTypedArray The quantized array\n   * @param {number} elementCount The number of elements\n   * @param {Cartesian4} stepSize The quantization step size\n   * @param {Cartesian4} offset The quantization offset\n   * @param {TypedArray} [dequantizedTypedArray] The result\n   * @returns {TypedArray} The result\n   */\n  static dequantize4D(\n    quantizedTypedArray,\n    elementCount,\n    stepSize,\n    offset,\n    dequantizedTypedArray,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"quantizedTypedArray\", quantizedTypedArray);\n    Check.typeOf.number.greaterThanOrEquals(\"elementCount\", elementCount, 0);\n    Check.defined(\"stepSize\", stepSize);\n    Check.defined(\"offset\", offset);\n    //>>includeEnd('debug');\n\n    if (!defined(dequantizedTypedArray)) {\n      dequantizedTypedArray = new Float32Array(quantizedTypedArray.length);\n    }\n    const c = new Cartesian4();\n    for (let i = 0; i < elementCount; i++) {\n      Cartesian4.unpack(quantizedTypedArray, i * 4, c);\n      Cartesian4.multiplyComponents(c, stepSize, c);\n      Cartesian4.add(c, offset, c);\n      Cartesian4.pack(c, dequantizedTypedArray, i * 4);\n    }\n    return dequantizedTypedArray;\n  }\n\n  /**\n   * Reads and returns a value with the given type\n   * at the given byte offset from the data view, in little-endian\n   * order\n   * @callback ComponentsReaderCallback\n   * @param {DataView} dataView Typed data view into a binary buffer\n   * @param {number} byteOffset The offset, in bytes, from the start of the view to read the data from\n   * @param {number} numberOfComponents The number of components to read\n   * @param {number[]} result The array in which to read the result\n   */\n\n  /**\n   * Creates a function that reads the specified number of components with\n   * the given type from the given data view, in little-endian\n   * order, and writes them into a given result array.\n   *\n   * @param {ComponentDatatype} componentType The component type\n   * @returns {ComponentsReaderCallback} The reader\n   */\n  static createComponentsReader(componentType) {\n    const componentReader = ModelReader.createComponentReader(componentType);\n    const sizeInBytes = ComponentDatatype.getSizeInBytes(componentType);\n    return function (dataView, byteOffset, numberOfComponents, result) {\n      let offset = byteOffset;\n      for (let i = 0; i < numberOfComponents; ++i) {\n        result[i] = componentReader(dataView, offset);\n        offset += sizeInBytes;\n      }\n    };\n  }\n\n  /**\n   * Reads and returns a value with the given type\n   * at the given byte offset from the data view, in little-endian\n   * order\n   * @callback ComponentReaderCallback\n   * @param {DataView} dataView Typed data view into a binary buffer\n   * @param {number} byteOffset The offset, in bytes, from the start of the view to read the data from\n   * @returns {number|BigInt} The value read from the dataView\n   */\n\n  /**\n   * Creates a function that reads and returns a value with the given type\n   * at the given byte offset from the data view, in little-endian\n   * order\n   * @param {ComponentDatatype} componentType The component type\n   * @returns {ComponentReaderCallback} The reader\n   */\n  static createComponentReader(componentType) {\n    switch (componentType) {\n      case ComponentDatatype.BYTE:\n        return function (dataView, byteOffset) {\n          return dataView.getInt8(byteOffset);\n        };\n      case ComponentDatatype.UNSIGNED_BYTE:\n        return function (dataView, byteOffset) {\n          return dataView.getUint8(byteOffset);\n        };\n      case ComponentDatatype.SHORT:\n        return function (dataView, byteOffset) {\n          return dataView.getInt16(byteOffset, true);\n        };\n      case ComponentDatatype.UNSIGNED_SHORT:\n        return function (dataView, byteOffset) {\n          return dataView.getUint16(byteOffset, true);\n        };\n      case ComponentDatatype.INT:\n        return function (dataView, byteOffset) {\n          return dataView.getInt32(byteOffset, true);\n        };\n      case ComponentDatatype.UNSIGNED_INT:\n        return function (dataView, byteOffset) {\n          return dataView.getUint32(byteOffset, true);\n        };\n      case ComponentDatatype.FLOAT:\n        return function (dataView, byteOffset) {\n          return dataView.getFloat32(byteOffset, true);\n        };\n      case ComponentDatatype.DOUBLE:\n        return function (dataView, byteOffset) {\n          return dataView.getFloat64(byteOffset, true);\n        };\n    }\n    throw new DeveloperError(\n      `The componentType must be a valid ComponentDatatype, but is ${componentType}`,\n    );\n  }\n\n  /**\n   * Transform the elements of the given array with the given 4x4 matrix,\n   * interpreting each 3 consecutive elements as a 3D point, and write\n   * the result into the given result array, creating the result array\n   * if it was undefined.\n   *\n   * @param {TypedArray} input The input array\n   * @param {Matrix4} matrix The matrix\n   * @param {TypedArray} [result] The result\n   * @returns {TypedArray} The result\n   */\n  static transform3D(input, matrix, result) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"input\", input);\n    Check.defined(\"matrix\", matrix);\n    //>>includeEnd('debug');\n\n    if (!defined(result)) {\n      result = new Float32Array(input.length);\n    }\n    const c = new Cartesian3();\n    const elementCount = input.length / 3;\n    for (let i = 0; i < elementCount; i++) {\n      Cartesian3.unpack(input, i * 3, c);\n      Matrix4.multiplyByPoint(matrix, c, c);\n      Cartesian3.pack(c, result, i * 3);\n    }\n    return result;\n  }\n\n  /**\n   * Read the indices values from the given primitive indices, and\n   * return them as a typed array.\n   *\n   * If the given object already has a <code>typedArray/code> property, then it\n   * is assumed that this contains the proper indices, and they are returned.\n   *\n   * Otherwise, this reads the data from the <code>buffer</code> of the given\n   * primitive indices object, into a typed array with a type that matches the\n   * <code>indexDataType</code>, and returns it.\n   *\n   * Clients may not modify the returned typed array.\n   *\n   * @param {ModelComponents.Indices} primitiveIndices The primitive indices\n   * @returns {TypedArray} The indices values\n   * @throws {DeveloperError} If the <code>indexDataType</code> of the given\n   * object is neither <code>UNSIGNED_BYTE</code>, nor <code>UNSIGNED_SHORT</code>,\n   * nor <code>UNSIGNED_INT</code>\n   */\n  static readIndicesAsTypedArray(primitiveIndices) {\n    const existingIndices = primitiveIndices.typedArray;\n    if (defined(existingIndices)) {\n      return existingIndices;\n    }\n    const indicesBuffer = primitiveIndices.buffer;\n    const indicesCount = primitiveIndices.count;\n    const indexDatatype = primitiveIndices.indexDatatype;\n    const indices = ModelReader.createIndexTypedArray(\n      indexDatatype,\n      indicesCount,\n    );\n    indicesBuffer.getBufferData(indices);\n    return indices;\n  }\n\n  /**\n   * Read the indices values from the given primitive indices object, and return\n   * them as a typed array of triangle vertex indices.\n   *\n   * If the given primitive type is <code>TRIANGLES</code>, then the indices\n   * values will be read from the given object, and returned.\n   *\n   * If the primitive type is <code>TRIANGLE_STRIP</code> or <code>TRIANGLE_FAN</code>,\n   * then the original indices values, will be read, converted into triangle indices\n   * (i.e. their equivalent <code>TRIANGLES</code> representation), and the result\n   * will be returned.\n   *\n   * The type of the returned array will match the <code>indexDataType</code>\n   * of the given object.\n   *\n   * Clients may not modify the returned typed array.\n   *\n   * @param {ModelComponents.Indices} primitiveIndices The primitive indices\n   * @returns {TypedArray} The indices, converted to triangle indices if necessary\n   * @throws {DeveloperError} If the <code>indexDataType</code> of the given\n   * object is neither <code>UNSIGNED_BYTE</code>, nor <code>UNSIGNED_SHORT</code>,\n   * nor <code>UNSIGNED_INT</code>, or the given <code>primitiveType</code>\n   * is neither <code>TRIANGLES</code>, nor <code>TRIANGLE_STRIP</code>,\n   * nor <code>TRIANGLE_FAN</code>\n   */\n  static readIndicesAsTriangleIndicesTypedArray(\n    primitiveIndices,\n    primitiveType,\n  ) {\n    const originalIndices =\n      ModelReader.readIndicesAsTypedArray(primitiveIndices);\n    if (primitiveType === PrimitiveType.TRIANGLES) {\n      return originalIndices;\n    }\n    if (primitiveType === PrimitiveType.TRIANGLE_STRIP) {\n      const triangleIndices =\n        ModelReader.convertTriangleStripToTriangleIndices(originalIndices);\n      return triangleIndices;\n    }\n    if (primitiveType === PrimitiveType.TRIANGLE_FAN) {\n      const triangleIndices =\n        ModelReader.convertTriangleFanToTriangleIndices(originalIndices);\n      return triangleIndices;\n    }\n    throw new DeveloperError(\n      `The primitiveType must be TRIANGLES (${PrimitiveType.TRIANGLES}, ` +\n        `TRIANGLE_STRIP (${PrimitiveType.TRIANGLE_STRIP}, or ` +\n        `TRIANGLE_FAN (${PrimitiveType.TRIANGLE_FAN}, but is ${primitiveType}`,\n    );\n  }\n\n  /**\n   * Converts the given indices from a <code>TRIANGLE_STRIP</code> representation\n   * into a <code>TRIANGLES</code> representation, and returns the result.\n   *\n   * The type of the result will be the same as the type of the input array.\n   *\n   * @param {TypedArray} indices The input indices\n   * @returns {TypedArray} The resulting triangle indices\n   */\n  static convertTriangleStripToTriangleIndices(indices) {\n    const triangleIndices = indices.constructor((indices.length - 2) * 3);\n    for (let i = 0; i < indices.length - 2; i++) {\n      if (i % 2 === 1) {\n        triangleIndices[i * 3 + 0] = indices[i + 0];\n        triangleIndices[i * 3 + 1] = indices[i + 2];\n        triangleIndices[i * 3 + 2] = indices[i + 1];\n      } else {\n        triangleIndices[i * 3 + 0] = indices[i + 0];\n        triangleIndices[i * 3 + 1] = indices[i + 1];\n        triangleIndices[i * 3 + 2] = indices[i + 2];\n      }\n    }\n    return triangleIndices;\n  }\n\n  /**\n   * Converts the given indices from a <code>TRIANGLE_FAN</code> representation\n   * into a <code>TRIANGLES</code> representation, and returns the result.\n   *\n   * The type of the result will be the same as the type of the input array.\n   *\n   * @param {TypedArray} indices The input indices\n   * @returns {TypedArray} The resulting triangle indices\n   */\n  static convertTriangleFanToTriangleIndices(indices) {\n    const triangleIndices = indices.constructor((indices.length - 2) * 3);\n    for (let i = 0; i < indices.length - 2; i++) {\n      triangleIndices[i * 3 + 0] = indices[i + 0];\n      triangleIndices[i * 3 + 1] = indices[i + 1];\n      triangleIndices[i * 3 + 2] = indices[i + 2];\n    }\n    return triangleIndices;\n  }\n\n  /**\n   * Create a typed array with a type that matches the given index data type,\n   * and the given size.\n   *\n   * @param {number} indexDatatype The <code>IndexDataType</code>\n   * @param {number} size The size of the array that will be created\n   * @returns {TypedArray} The typed array\n   * @throws {DeveloperError} If the <code>indexDataType</code> is neither\n   * <code>UNSIGNED_BYTE</code>, nor <code>UNSIGNED_SHORT</code>,\n   * nor <code>UNSIGNED_INT</code>, or the size is negative.\n   */\n  static createIndexTypedArray(indexDatatype, size) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.typeOf.number.greaterThanOrEquals(\"size\", size, 0);\n    //>>includeEnd('debug');\n\n    switch (indexDatatype) {\n      case IndexDatatype.UNSIGNED_BYTE:\n        return new Uint8Array(size);\n      case IndexDatatype.UNSIGNED_SHORT:\n        return new Uint16Array(size);\n      case IndexDatatype.UNSIGNED_INT:\n        return new Uint32Array(size);\n    }\n    throw new DeveloperError(\n      `The indexDatatype must be UNSIGNED_BYTE (${IndexDatatype.UNSIGNED_BYTE}, ` +\n        `UNSIGNED_SHORT (${IndexDatatype.UNSIGNED_SHORT}, or ` +\n        `UNSIGNED_INT (${IndexDatatype.UNSIGNED_INT}, but is ${indexDatatype}`,\n    );\n  }\n}\n\nexport default ModelReader;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}