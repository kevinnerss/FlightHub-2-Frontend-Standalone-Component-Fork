{"ast":null,"code":"import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Ray from \"./Ray.js\";\n\n/**\n * Represents a point in stereographic coordinates, which can be obtained by projecting a cartesian coordinate from one pole onto a tangent plane at the other pole.\n * The stereographic projection faithfully represents the relative directions of all great circles passing through its center point.\n * To faithfully represents angles everywhere, this is a conformal projection, which means points are projected onto an arbrary sphere.\n * @param {Cartesian2} [position] The steroegraphic coordinates.\n * @param {EllipseGeometry} [tangentPlane] The tangent plane onto which the point was projected.\n */\nfunction Stereographic(position, tangentPlane) {\n  this.position = position;\n  if (!defined(this.position)) {\n    this.position = new Cartesian2();\n  }\n  this.tangentPlane = tangentPlane;\n  if (!defined(this.tangentPlane)) {\n    this.tangentPlane = Stereographic.NORTH_POLE_TANGENT_PLANE;\n  }\n}\nObject.defineProperties(Stereographic.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof Stereographic.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this.tangentPlane.ellipsoid;\n    }\n  },\n  /**\n   * Gets the x coordinate\n   * @memberof Stereographic.prototype\n   * @type {number}\n   */\n  x: {\n    get: function () {\n      return this.position.x;\n    }\n  },\n  /**\n   * Gets the y coordinate\n   * @memberof Stereographic.prototype\n   * @type {number}\n   */\n  y: {\n    get: function () {\n      return this.position.y;\n    }\n  },\n  /**\n   * Computes the conformal latitude, or the ellipsoidal latitude projected onto an arbitrary sphere.\n   * @memberof Stereographic.prototype\n   * @type {number}\n   */\n  conformalLatitude: {\n    get: function () {\n      const r = Cartesian2.magnitude(this.position);\n      const d = 2 * this.ellipsoid.maximumRadius;\n      const sign = this.tangentPlane.plane.normal.z;\n      return sign * (CesiumMath.PI_OVER_TWO - 2 * Math.atan2(r, d));\n    }\n  },\n  /**\n   * Computes the longitude\n   * @memberof Stereographic.prototype\n   * @type {number}\n   */\n  longitude: {\n    get: function () {\n      let longitude = CesiumMath.PI_OVER_TWO + Math.atan2(this.y, this.x);\n      if (longitude > Math.PI) {\n        longitude -= CesiumMath.TWO_PI;\n      }\n      return longitude;\n    }\n  }\n});\nconst scratchCartographic = new Cartographic();\nconst scratchCartesian = new Cartesian3();\n\n/**\n * Computes the latitude based on an ellipsoid.\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which to compute the longitude.\n * @returns {number} The latitude\n */\nStereographic.prototype.getLatitude = function (ellipsoid) {\n  if (!defined(ellipsoid)) {\n    ellipsoid = Ellipsoid.default;\n  }\n  scratchCartographic.latitude = this.conformalLatitude;\n  scratchCartographic.longitude = this.longitude;\n  scratchCartographic.height = 0.0;\n  const cartesian = this.ellipsoid.cartographicToCartesian(scratchCartographic, scratchCartesian);\n  ellipsoid.cartesianToCartographic(cartesian, scratchCartographic);\n  return scratchCartographic.latitude;\n};\nconst scratchProjectPointOntoPlaneRay = new Ray();\nconst scratchProjectPointOntoPlaneRayDirection = new Cartesian3();\nconst scratchProjectPointOntoPlaneCartesian3 = new Cartesian3();\n\n/**\n * Computes the projection of the provided 3D position onto the 2D polar plane, radially outward from the provided origin.\n *\n * @param {Cartesian3} cartesian The point to project.\n * @param {Stereographic} [result] The object onto which to store the result.\n * @returns {Sterographic} The modified result parameter or a new Sterographic instance if none was provided.\n */\nStereographic.fromCartesian = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  const sign = CesiumMath.signNotZero(cartesian.z);\n  let tangentPlane = Stereographic.NORTH_POLE_TANGENT_PLANE;\n  let origin = Stereographic.SOUTH_POLE;\n  if (sign < 0) {\n    tangentPlane = Stereographic.SOUTH_POLE_TANGENT_PLANE;\n    origin = Stereographic.NORTH_POLE;\n  }\n  const ray = scratchProjectPointOntoPlaneRay;\n  ray.origin = tangentPlane.ellipsoid.scaleToGeocentricSurface(cartesian, ray.origin);\n  ray.direction = Cartesian3.subtract(ray.origin, origin, scratchProjectPointOntoPlaneRayDirection);\n  Cartesian3.normalize(ray.direction, ray.direction);\n  const intersectionPoint = IntersectionTests.rayPlane(ray, tangentPlane.plane, scratchProjectPointOntoPlaneCartesian3);\n  const v = Cartesian3.subtract(intersectionPoint, origin, intersectionPoint);\n  const x = Cartesian3.dot(tangentPlane.xAxis, v);\n  const y = sign * Cartesian3.dot(tangentPlane.yAxis, v);\n  if (!defined(result)) {\n    return new Stereographic(new Cartesian2(x, y), tangentPlane);\n  }\n  result.position = new Cartesian2(x, y);\n  result.tangentPlane = tangentPlane;\n  return result;\n};\n\n/**\n * Computes the projection of the provided 3D positions onto the 2D polar plane, radially outward from the provided origin.\n *\n * @param {Cartesian3[]} cartesians The points to project.\n * @param {Stereographic[]} [result] The object onto which to store the result.\n * @returns {Sterographic[]} The modified result parameter or a new Sterographic instance if none was provided.\n */\nStereographic.fromCartesianArray = function (cartesians, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  const length = cartesians.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (let i = 0; i < length; i++) {\n    result[i] = Stereographic.fromCartesian(cartesians[i], result[i]);\n  }\n  return result;\n};\n\n/**\n * Duplicates a Stereographic instance.\n *\n * @param {Stereographic} stereographic The Stereographic to duplicate.\n * @param {Stereographic} [result] The object onto which to store the result.\n * @returns {Stereographic} The modified result parameter or a new Stereographic instance if one was not provided. (Returns undefined if stereographic is undefined)\n */\nStereographic.clone = function (stereographic, result) {\n  if (!defined(stereographic)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Stereographic(stereographic.position, stereographic.tangentPlane);\n  }\n  result.position = stereographic.position;\n  result.tangentPlane = stereographic.tangentPlane;\n  return result;\n};\n\n/**\n * An Ellipsoid instance initialized to radii of (0.5, 0.5, 0.5).\n *\n * @type {Stereographic}\n * @constant\n */\nStereographic.HALF_UNIT_SPHERE = Object.freeze(new Ellipsoid(0.5, 0.5, 0.5));\nStereographic.NORTH_POLE = Object.freeze(new Cartesian3(0.0, 0.0, 0.5));\nStereographic.SOUTH_POLE = Object.freeze(new Cartesian3(0.0, 0.0, -0.5));\nStereographic.NORTH_POLE_TANGENT_PLANE = Object.freeze(new EllipsoidTangentPlane(Stereographic.NORTH_POLE, Stereographic.HALF_UNIT_SPHERE));\nStereographic.SOUTH_POLE_TANGENT_PLANE = Object.freeze(new EllipsoidTangentPlane(Stereographic.SOUTH_POLE, Stereographic.HALF_UNIT_SPHERE));\nexport default Stereographic;","map":{"version":3,"names":["Cartesian2","Cartesian3","Cartographic","Check","defined","Ellipsoid","EllipsoidTangentPlane","IntersectionTests","CesiumMath","Ray","Stereographic","position","tangentPlane","NORTH_POLE_TANGENT_PLANE","Object","defineProperties","prototype","ellipsoid","get","x","y","conformalLatitude","r","magnitude","d","maximumRadius","sign","plane","normal","z","PI_OVER_TWO","Math","atan2","longitude","PI","TWO_PI","scratchCartographic","scratchCartesian","getLatitude","default","latitude","height","cartesian","cartographicToCartesian","cartesianToCartographic","scratchProjectPointOntoPlaneRay","scratchProjectPointOntoPlaneRayDirection","scratchProjectPointOntoPlaneCartesian3","fromCartesian","result","signNotZero","origin","SOUTH_POLE","SOUTH_POLE_TANGENT_PLANE","NORTH_POLE","ray","scaleToGeocentricSurface","direction","subtract","normalize","intersectionPoint","rayPlane","v","dot","xAxis","yAxis","fromCartesianArray","cartesians","length","Array","i","clone","stereographic","undefined","HALF_UNIT_SPHERE","freeze"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/Stereographic.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Ray from \"./Ray.js\";\n\n/**\n * Represents a point in stereographic coordinates, which can be obtained by projecting a cartesian coordinate from one pole onto a tangent plane at the other pole.\n * The stereographic projection faithfully represents the relative directions of all great circles passing through its center point.\n * To faithfully represents angles everywhere, this is a conformal projection, which means points are projected onto an arbrary sphere.\n * @param {Cartesian2} [position] The steroegraphic coordinates.\n * @param {EllipseGeometry} [tangentPlane] The tangent plane onto which the point was projected.\n */\nfunction Stereographic(position, tangentPlane) {\n  this.position = position;\n  if (!defined(this.position)) {\n    this.position = new Cartesian2();\n  }\n\n  this.tangentPlane = tangentPlane;\n  if (!defined(this.tangentPlane)) {\n    this.tangentPlane = Stereographic.NORTH_POLE_TANGENT_PLANE;\n  }\n}\n\nObject.defineProperties(Stereographic.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof Stereographic.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this.tangentPlane.ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the x coordinate\n   * @memberof Stereographic.prototype\n   * @type {number}\n   */\n  x: {\n    get: function () {\n      return this.position.x;\n    },\n  },\n\n  /**\n   * Gets the y coordinate\n   * @memberof Stereographic.prototype\n   * @type {number}\n   */\n  y: {\n    get: function () {\n      return this.position.y;\n    },\n  },\n\n  /**\n   * Computes the conformal latitude, or the ellipsoidal latitude projected onto an arbitrary sphere.\n   * @memberof Stereographic.prototype\n   * @type {number}\n   */\n  conformalLatitude: {\n    get: function () {\n      const r = Cartesian2.magnitude(this.position);\n      const d = 2 * this.ellipsoid.maximumRadius;\n      const sign = this.tangentPlane.plane.normal.z;\n      return sign * (CesiumMath.PI_OVER_TWO - 2 * Math.atan2(r, d));\n    },\n  },\n\n  /**\n   * Computes the longitude\n   * @memberof Stereographic.prototype\n   * @type {number}\n   */\n  longitude: {\n    get: function () {\n      let longitude = CesiumMath.PI_OVER_TWO + Math.atan2(this.y, this.x);\n      if (longitude > Math.PI) {\n        longitude -= CesiumMath.TWO_PI;\n      }\n\n      return longitude;\n    },\n  },\n});\n\nconst scratchCartographic = new Cartographic();\nconst scratchCartesian = new Cartesian3();\n\n/**\n * Computes the latitude based on an ellipsoid.\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which to compute the longitude.\n * @returns {number} The latitude\n */\nStereographic.prototype.getLatitude = function (ellipsoid) {\n  if (!defined(ellipsoid)) {\n    ellipsoid = Ellipsoid.default;\n  }\n\n  scratchCartographic.latitude = this.conformalLatitude;\n  scratchCartographic.longitude = this.longitude;\n  scratchCartographic.height = 0.0;\n  const cartesian = this.ellipsoid.cartographicToCartesian(\n    scratchCartographic,\n    scratchCartesian,\n  );\n  ellipsoid.cartesianToCartographic(cartesian, scratchCartographic);\n  return scratchCartographic.latitude;\n};\n\nconst scratchProjectPointOntoPlaneRay = new Ray();\nconst scratchProjectPointOntoPlaneRayDirection = new Cartesian3();\nconst scratchProjectPointOntoPlaneCartesian3 = new Cartesian3();\n\n/**\n * Computes the projection of the provided 3D position onto the 2D polar plane, radially outward from the provided origin.\n *\n * @param {Cartesian3} cartesian The point to project.\n * @param {Stereographic} [result] The object onto which to store the result.\n * @returns {Sterographic} The modified result parameter or a new Sterographic instance if none was provided.\n */\nStereographic.fromCartesian = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  const sign = CesiumMath.signNotZero(cartesian.z);\n  let tangentPlane = Stereographic.NORTH_POLE_TANGENT_PLANE;\n  let origin = Stereographic.SOUTH_POLE;\n  if (sign < 0) {\n    tangentPlane = Stereographic.SOUTH_POLE_TANGENT_PLANE;\n    origin = Stereographic.NORTH_POLE;\n  }\n\n  const ray = scratchProjectPointOntoPlaneRay;\n  ray.origin = tangentPlane.ellipsoid.scaleToGeocentricSurface(\n    cartesian,\n    ray.origin,\n  );\n  ray.direction = Cartesian3.subtract(\n    ray.origin,\n    origin,\n    scratchProjectPointOntoPlaneRayDirection,\n  );\n  Cartesian3.normalize(ray.direction, ray.direction);\n\n  const intersectionPoint = IntersectionTests.rayPlane(\n    ray,\n    tangentPlane.plane,\n    scratchProjectPointOntoPlaneCartesian3,\n  );\n  const v = Cartesian3.subtract(intersectionPoint, origin, intersectionPoint);\n  const x = Cartesian3.dot(tangentPlane.xAxis, v);\n  const y = sign * Cartesian3.dot(tangentPlane.yAxis, v);\n\n  if (!defined(result)) {\n    return new Stereographic(new Cartesian2(x, y), tangentPlane);\n  }\n\n  result.position = new Cartesian2(x, y);\n  result.tangentPlane = tangentPlane;\n  return result;\n};\n\n/**\n * Computes the projection of the provided 3D positions onto the 2D polar plane, radially outward from the provided origin.\n *\n * @param {Cartesian3[]} cartesians The points to project.\n * @param {Stereographic[]} [result] The object onto which to store the result.\n * @returns {Sterographic[]} The modified result parameter or a new Sterographic instance if none was provided.\n */\nStereographic.fromCartesianArray = function (cartesians, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  const length = cartesians.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (let i = 0; i < length; i++) {\n    result[i] = Stereographic.fromCartesian(cartesians[i], result[i]);\n  }\n  return result;\n};\n\n/**\n * Duplicates a Stereographic instance.\n *\n * @param {Stereographic} stereographic The Stereographic to duplicate.\n * @param {Stereographic} [result] The object onto which to store the result.\n * @returns {Stereographic} The modified result parameter or a new Stereographic instance if one was not provided. (Returns undefined if stereographic is undefined)\n */\nStereographic.clone = function (stereographic, result) {\n  if (!defined(stereographic)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Stereographic(\n      stereographic.position,\n      stereographic.tangentPlane,\n    );\n  }\n\n  result.position = stereographic.position;\n  result.tangentPlane = stereographic.tangentPlane;\n\n  return result;\n};\n\n/**\n * An Ellipsoid instance initialized to radii of (0.5, 0.5, 0.5).\n *\n * @type {Stereographic}\n * @constant\n */\nStereographic.HALF_UNIT_SPHERE = Object.freeze(new Ellipsoid(0.5, 0.5, 0.5));\n\nStereographic.NORTH_POLE = Object.freeze(new Cartesian3(0.0, 0.0, 0.5));\nStereographic.SOUTH_POLE = Object.freeze(new Cartesian3(0.0, 0.0, -0.5));\n\nStereographic.NORTH_POLE_TANGENT_PLANE = Object.freeze(\n  new EllipsoidTangentPlane(\n    Stereographic.NORTH_POLE,\n    Stereographic.HALF_UNIT_SPHERE,\n  ),\n);\nStereographic.SOUTH_POLE_TANGENT_PLANE = Object.freeze(\n  new EllipsoidTangentPlane(\n    Stereographic.SOUTH_POLE,\n    Stereographic.HALF_UNIT_SPHERE,\n  ),\n);\n\nexport default Stereographic;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}