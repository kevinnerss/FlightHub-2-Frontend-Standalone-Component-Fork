{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"// See IntersectionUtils.glsl for the definitions of Ray, NO_HIT, INF_HIT, Intersections,\\n\\\n// RayShapeIntersection, setSurfaceIntersection, setShapeIntersection\\n\\\n// See IntersectLongitude.glsl for the definitions of intersectHalfPlane,\\n\\\n// intersectFlippedWedge, intersectRegularWedge\\n\\\n\\n\\\n/* Ellipsoid defines (set in Scene/VoxelEllipsoidShape.js)\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_EQUAL_ZERO\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_UNDER_HALF\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_OVER_HALF\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_UNDER_HALF\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_EQUAL_HALF\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_OVER_HALF\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_UNDER_HALF\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_EQUAL_HALF\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_OVER_HALF\\n\\\n#define ELLIPSOID_INTERSECTION_INDEX_LONGITUDE\\n\\\n#define ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX\\n\\\n#define ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN\\n\\\n#define ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MAX\\n\\\n#define ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MIN\\n\\\n*/\\n\\\n\\n\\\n#if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE)\\n\\\n    uniform vec2 u_ellipsoidRenderLongitudeMinMax;\\n\\\n#endif\\n\\\nuniform float u_eccentricitySquared;\\n\\\nuniform vec2 u_ellipsoidRenderLatitudeSinMinMax;\\n\\\nuniform vec2 u_clipMinMaxHeight; // Values are negative: clipHeight - maxShapeHeight\\n\\\n\\n\\\nRayShapeIntersection intersectZPlane(in Ray ray, in float z) {\\n\\\n    float t = -ray.pos.z / ray.dir.z;\\n\\\n\\n\\\n    bool startsOutside = sign(ray.pos.z) == sign(z);\\n\\\n    bool entry = (t >= 0.0) != startsOutside;\\n\\\n\\n\\\n    vec4 intersect = vec4(0.0, 0.0, z, t);\\n\\\n    vec4 farSide = vec4(normalize(ray.dir), INF_HIT);\\n\\\n\\n\\\n    if (entry) {\\n\\\n        return RayShapeIntersection(intersect, farSide);\\n\\\n    } else {\\n\\\n        return RayShapeIntersection(-1.0 * farSide, intersect);\\n\\\n    }\\n\\\n}\\n\\\n\\n\\\nRayShapeIntersection intersectHeight(in Ray ray, in float height, in bool convex)\\n\\\n{\\n\\\n    // Scale the ray by the ellipsoid axes to make it a unit sphere\\n\\\n    // Note: approximating ellipsoid + height as an ellipsoid\\n\\\n    vec3 radiiCorrection = vec3(1.0) / (u_ellipsoidRadii + height);\\n\\\n    vec3 position = ray.pos * radiiCorrection;\\n\\\n    vec3 direction = ray.dir * radiiCorrection;\\n\\\n\\n\\\n    float a = dot(direction, direction); // ~ 1.0 (or maybe 4.0 if ray is scaled)\\n\\\n    float b = dot(direction, position); // roughly inside [-1.0, 1.0] when zoomed in\\n\\\n    float c = dot(position, position) - 1.0; // ~ 0.0 when zoomed in.\\n\\\n    float determinant = b * b - a * c; // ~ b * b when zoomed in\\n\\\n\\n\\\n    if (determinant < 0.0) {\\n\\\n        vec4 miss = vec4(normalize(direction), NO_HIT);\\n\\\n        return RayShapeIntersection(miss, miss);\\n\\\n    }\\n\\\n\\n\\\n    determinant = sqrt(determinant);\\n\\\n\\n\\\n    // Compute larger root using standard formula\\n\\\n    float signB = b < 0.0 ? -1.0 : 1.0;\\n\\\n    // The other root may suffer from subtractive cancellation in the standard formula.\\n\\\n    // Compute it from the first root instead.\\n\\\n    float t1 = (-b - signB * determinant) / a;\\n\\\n    float t2 = c / (a * t1);\\n\\\n    float tmin = min(t1, t2);\\n\\\n    float tmax = max(t1, t2);\\n\\\n\\n\\\n    float directionScale = convex ? 1.0 : -1.0;\\n\\\n    vec3 d1 = directionScale * (position + tmin * direction);\\n\\\n    vec3 d2 = directionScale * (position + tmax * direction);\\n\\\n\\n\\\n    // Return normals in eye coordinates. Use spherical approximation for the normal.\\n\\\n    vec3 normal1 = normalize(czm_normal * d1);\\n\\\n    vec3 normal2 = normalize(czm_normal * d2);\\n\\\n\\n\\\n    return RayShapeIntersection(vec4(normal1, tmin), vec4(normal2, tmax));\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Given a circular cone around the z-axis, with apex at the origin,\\n\\\n * find the parametric distance(s) along a ray where that ray intersects\\n\\\n * the cone.\\n\\\n * The cone opening angle is described by the squared cosine of\\n\\\n * its half-angle (the angle between the Z-axis and the surface)\\n\\\n */\\n\\\nvec2 intersectDoubleEndedCone(in Ray ray, in float cosSqrHalfAngle)\\n\\\n{\\n\\\n    vec3 o = ray.pos;\\n\\\n    vec3 d = ray.dir;\\n\\\n    float sinSqrHalfAngle = 1.0 - cosSqrHalfAngle;\\n\\\n\\n\\\n    float aSin = d.z * d.z * sinSqrHalfAngle;\\n\\\n    float aCos = -dot(d.xy, d.xy) * cosSqrHalfAngle;\\n\\\n    float a = aSin + aCos;\\n\\\n\\n\\\n    float bSin = d.z * o.z * sinSqrHalfAngle;\\n\\\n    float bCos = -dot(o.xy, d.xy) * cosSqrHalfAngle;\\n\\\n    float b = bSin + bCos;\\n\\\n\\n\\\n    float cSin = o.z * o.z * sinSqrHalfAngle;\\n\\\n    float cCos = -dot(o.xy, o.xy) * cosSqrHalfAngle;\\n\\\n    float c = cSin + cCos;\\n\\\n    // determinant = b * b - a * c. But bSin * bSin = aSin * cSin.\\n\\\n    // Avoid subtractive cancellation by expanding to eliminate these terms\\n\\\n    float determinant = 2.0 * bSin * bCos + bCos * bCos - aSin * cCos - aCos * cSin - aCos * cCos;\\n\\\n\\n\\\n    if (determinant < 0.0) {\\n\\\n        return vec2(NO_HIT);\\n\\\n    } else if (a == 0.0) {\\n\\\n        // Ray is parallel to cone surface\\n\\\n        return (b == 0.0)\\n\\\n            ? vec2(NO_HIT) // Ray is on cone surface\\n\\\n            : vec2(-0.5 * c / b, NO_HIT);\\n\\\n    }\\n\\\n\\n\\\n    determinant = sqrt(determinant);\\n\\\n\\n\\\n    // Compute larger root using standard formula\\n\\\n    float signB = b < 0.0 ? -1.0 : 1.0;\\n\\\n    float t1 = (-b - signB * determinant) / a;\\n\\\n    // The other root may suffer from subtractive cancellation in the standard formula.\\n\\\n    // Compute it from the first root instead.\\n\\\n    float t2 = c / (a * t1);\\n\\\n    float tmin = min(t1, t2);\\n\\\n    float tmax = max(t1, t2);\\n\\\n    return vec2(tmin, tmax);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Given a point on a conical surface, find the surface normal at that point.\\n\\\n */\\n\\\nvec3 getConeNormal(in vec3 p, in bool convex) {\\n\\\n    // Start with radial component pointing toward z-axis\\n\\\n    vec2 radial = -abs(p.z) * normalize(p.xy);\\n\\\n    // Z component points toward opening of cone\\n\\\n    float zSign = (p.z < 0.0) ? -1.0 : 1.0;\\n\\\n    float z = length(p.xy) * zSign;\\n\\\n    // Flip normal if shape is convex\\n\\\n    float flip = (convex) ? -1.0 : 1.0;\\n\\\n    return normalize(vec3(radial, z) * flip);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Compute the shift between the ellipsoid origin and the apex of a cone of latitude\\n\\\n */\\n\\\nfloat getLatitudeConeShift(in float sinLatitude) {\\n\\\n    // Find prime vertical radius of curvature: \\n\\\n    // the distance along the ellipsoid normal to the intersection with the z-axis\\n\\\n    float x2 = u_eccentricitySquared * sinLatitude * sinLatitude;\\n\\\n    float primeVerticalRadius = u_ellipsoidRadii.x * inversesqrt(1.0 - x2);\\n\\\n\\n\\\n    // Compute a shift from the origin to the intersection of the cone with the z-axis\\n\\\n    return primeVerticalRadius * u_eccentricitySquared * sinLatitude;\\n\\\n}\\n\\\n\\n\\\nvoid intersectFlippedCone(in Ray ray, in float cosHalfAngle, out RayShapeIntersection intersections[2]) {\\n\\\n    // Shift the ray to account for the latitude cone not being centered at the Earth center\\n\\\n    ray.pos.z += getLatitudeConeShift(cosHalfAngle);\\n\\\n\\n\\\n    float cosSqrHalfAngle = cosHalfAngle * cosHalfAngle;\\n\\\n    vec2 intersect = intersectDoubleEndedCone(ray, cosSqrHalfAngle);\\n\\\n\\n\\\n    vec4 miss = vec4(normalize(ray.dir), NO_HIT);\\n\\\n    vec4 farSide = vec4(normalize(ray.dir), INF_HIT);\\n\\\n\\n\\\n    // Initialize output with no intersections\\n\\\n    intersections[0].entry = -1.0 * farSide;\\n\\\n    intersections[0].exit = farSide;\\n\\\n    intersections[1].entry = miss;\\n\\\n    intersections[1].exit = miss;\\n\\\n\\n\\\n    if (intersect.x == NO_HIT) {\\n\\\n        return;\\n\\\n    }\\n\\\n\\n\\\n    // Find the points of intersection\\n\\\n    float tmin = intersect.x;\\n\\\n    float tmax = intersect.y;\\n\\\n    vec3 p0 = ray.pos + tmin * ray.dir;\\n\\\n    vec3 p1 = ray.pos + tmax * ray.dir;\\n\\\n\\n\\\n    vec4 intersect0 = vec4(getConeNormal(p0, true), tmin);\\n\\\n    vec4 intersect1 = vec4(getConeNormal(p1, true), tmax);\\n\\\n\\n\\\n    bool p0InShadowCone = sign(p0.z) != sign(cosHalfAngle);\\n\\\n    bool p1InShadowCone = sign(p1.z) != sign(cosHalfAngle);\\n\\\n\\n\\\n    if (p0InShadowCone && p1InShadowCone) {\\n\\\n        // no valid intersections\\n\\\n    } else if (p0InShadowCone) {\\n\\\n        intersections[0].exit = intersect1;\\n\\\n    } else if (p1InShadowCone) {\\n\\\n        intersections[0].entry = intersect0;\\n\\\n    } else {\\n\\\n        intersections[0].exit = intersect0;\\n\\\n        intersections[1].entry = intersect1;\\n\\\n        intersections[1].exit = farSide;\\n\\\n    }\\n\\\n}\\n\\\n\\n\\\nRayShapeIntersection intersectRegularCone(in Ray ray, in float cosHalfAngle, in bool convex) {\\n\\\n    // Shift the ray to account for the latitude cone not being centered at the Earth center\\n\\\n    ray.pos.z += getLatitudeConeShift(cosHalfAngle);\\n\\\n\\n\\\n    float cosSqrHalfAngle = cosHalfAngle * cosHalfAngle;\\n\\\n    vec2 intersect = intersectDoubleEndedCone(ray, cosSqrHalfAngle);\\n\\\n\\n\\\n    vec4 miss = vec4(normalize(ray.dir), NO_HIT);\\n\\\n    vec4 farSide = vec4(normalize(ray.dir), INF_HIT);\\n\\\n\\n\\\n    if (intersect.x == NO_HIT) {\\n\\\n        return RayShapeIntersection(miss, miss);\\n\\\n    }\\n\\\n\\n\\\n    // Find the points of intersection\\n\\\n    float tmin = intersect.x;\\n\\\n    float tmax = intersect.y;\\n\\\n    vec3 p0 = ray.pos + tmin * ray.dir;\\n\\\n    vec3 p1 = ray.pos + tmax * ray.dir;\\n\\\n\\n\\\n    vec4 intersect0 = vec4(getConeNormal(p0, convex), tmin);\\n\\\n    vec4 intersect1 = vec4(getConeNormal(p1, convex), tmax);\\n\\\n\\n\\\n    bool p0InShadowCone = sign(p0.z) != sign(cosHalfAngle);\\n\\\n    bool p1InShadowCone = sign(p1.z) != sign(cosHalfAngle);\\n\\\n\\n\\\n    if (p0InShadowCone && p1InShadowCone) {\\n\\\n        return RayShapeIntersection(miss, miss);\\n\\\n    } else if (p0InShadowCone) {\\n\\\n        return RayShapeIntersection(intersect1, farSide);\\n\\\n    } else if (p1InShadowCone) {\\n\\\n        return RayShapeIntersection(-1.0 * farSide, intersect0);\\n\\\n    } else {\\n\\\n        return RayShapeIntersection(intersect0, intersect1);\\n\\\n    }\\n\\\n}\\n\\\n\\n\\\nvoid intersectShape(in Ray ray, in Ray rayEC, inout Intersections ix) {    // Outer ellipsoid\\n\\\n    RayShapeIntersection outerIntersect = intersectHeight(ray, u_clipMinMaxHeight.y, true);\\n\\\n    setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MAX, outerIntersect);\\n\\\n\\n\\\n    // Exit early if the outer ellipsoid was missed.\\n\\\n    if (outerIntersect.entry.w == NO_HIT) {\\n\\\n        return;\\n\\\n    }\\n\\\n\\n\\\n    // Inner ellipsoid\\n\\\n    RayShapeIntersection innerIntersect = intersectHeight(ray, u_clipMinMaxHeight.x, false);\\n\\\n\\n\\\n    if (innerIntersect.entry.w == NO_HIT) {\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MIN, innerIntersect);\\n\\\n    } else {\\n\\\n        // When the ellipsoid is large and thin it's possible for floating point math\\n\\\n        // to cause the ray to intersect the inner ellipsoid before the outer ellipsoid. \\n\\\n        // To prevent this from happening, clamp innerIntersect to outerIntersect and\\n\\\n        // sandwich the inner ellipsoid intersection inside the outer ellipsoid intersection.\\n\\\n\\n\\\n        // Without this special case,\\n\\\n        // [outerMin, outerMax, innerMin, innerMax] will bubble sort to\\n\\\n        // [outerMin, innerMin, outerMax, innerMax] which will cause the back\\n\\\n        // side of the ellipsoid to be invisible because it will think the ray\\n\\\n        // is still inside the inner (negative) ellipsoid after exiting the\\n\\\n        // outer (positive) ellipsoid.\\n\\\n\\n\\\n        // With this special case,\\n\\\n        // [outerMin, innerMin, innerMax, outerMax] will bubble sort to\\n\\\n        // [outerMin, innerMin, innerMax, outerMax] which will work correctly.\\n\\\n\\n\\\n        // Note: If initializeIntersections() changes its sorting function\\n\\\n        // from bubble sort to something else, this code may need to change.\\n\\\n        innerIntersect.entry.w = max(innerIntersect.entry.w, outerIntersect.entry.w);\\n\\\n        innerIntersect.exit.w = min(innerIntersect.exit.w, outerIntersect.exit.w);\\n\\\n        setSurfaceIntersection(ix, 0, outerIntersect.entry, true, true);  // positive, enter\\n\\\n        setSurfaceIntersection(ix, 1, innerIntersect.entry, false, true); // negative, enter\\n\\\n        setSurfaceIntersection(ix, 2, innerIntersect.exit, false, false); // negative, exit\\n\\\n        setSurfaceIntersection(ix, 3, outerIntersect.exit, true, false);  // positive, exit\\n\\\n    }\\n\\\n\\n\\\n    // Bottom cone\\n\\\n    #if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_UNDER_HALF)\\n\\\n        RayShapeIntersection bottomConeIntersection = intersectRegularCone(ray, u_ellipsoidRenderLatitudeSinMinMax.x, false);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN, bottomConeIntersection);\\n\\\n    #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_EQUAL_HALF)\\n\\\n        RayShapeIntersection bottomConeIntersection = intersectZPlane(ray, -1.0);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN, bottomConeIntersection);\\n\\\n    #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_OVER_HALF)\\n\\\n        RayShapeIntersection bottomConeIntersections[2];\\n\\\n        intersectFlippedCone(ray, u_ellipsoidRenderLatitudeSinMinMax.x, bottomConeIntersections);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN + 0, bottomConeIntersections[0]);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN + 1, bottomConeIntersections[1]);\\n\\\n    #endif\\n\\\n\\n\\\n    // Top cone\\n\\\n    #if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_UNDER_HALF)\\n\\\n        RayShapeIntersection topConeIntersections[2];\\n\\\n        intersectFlippedCone(ray, u_ellipsoidRenderLatitudeSinMinMax.y, topConeIntersections);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX + 0, topConeIntersections[0]);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX + 1, topConeIntersections[1]);\\n\\\n    #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_EQUAL_HALF)\\n\\\n        RayShapeIntersection topConeIntersection = intersectZPlane(ray, 1.0);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX, topConeIntersection);\\n\\\n    #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_OVER_HALF)\\n\\\n        RayShapeIntersection topConeIntersection = intersectRegularCone(ray, u_ellipsoidRenderLatitudeSinMinMax.y, false);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX, topConeIntersection);\\n\\\n    #endif\\n\\\n\\n\\\n    // Wedge\\n\\\n    #if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_EQUAL_ZERO)\\n\\\n        RayShapeIntersection wedgeIntersects[2];\\n\\\n        intersectHalfPlane(ray, u_ellipsoidRenderLongitudeMinMax.x, wedgeIntersects);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LONGITUDE + 0, wedgeIntersects[0]);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LONGITUDE + 1, wedgeIntersects[1]);\\n\\\n    #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_UNDER_HALF)\\n\\\n        RayShapeIntersection wedgeIntersect = intersectRegularWedge(ray, u_ellipsoidRenderLongitudeMinMax);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LONGITUDE, wedgeIntersect);\\n\\\n    #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_OVER_HALF)\\n\\\n        RayShapeIntersection wedgeIntersects[2];\\n\\\n        intersectFlippedWedge(ray, u_ellipsoidRenderLongitudeMinMax, wedgeIntersects);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LONGITUDE + 0, wedgeIntersects[0]);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LONGITUDE + 1, wedgeIntersects[1]);\\n\\\n    #endif\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Shaders/Voxels/IntersectEllipsoid.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"// See IntersectionUtils.glsl for the definitions of Ray, NO_HIT, INF_HIT, Intersections,\\n\\\n// RayShapeIntersection, setSurfaceIntersection, setShapeIntersection\\n\\\n// See IntersectLongitude.glsl for the definitions of intersectHalfPlane,\\n\\\n// intersectFlippedWedge, intersectRegularWedge\\n\\\n\\n\\\n/* Ellipsoid defines (set in Scene/VoxelEllipsoidShape.js)\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_EQUAL_ZERO\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_UNDER_HALF\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_OVER_HALF\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_UNDER_HALF\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_EQUAL_HALF\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_OVER_HALF\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_UNDER_HALF\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_EQUAL_HALF\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_OVER_HALF\\n\\\n#define ELLIPSOID_INTERSECTION_INDEX_LONGITUDE\\n\\\n#define ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX\\n\\\n#define ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN\\n\\\n#define ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MAX\\n\\\n#define ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MIN\\n\\\n*/\\n\\\n\\n\\\n#if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE)\\n\\\n    uniform vec2 u_ellipsoidRenderLongitudeMinMax;\\n\\\n#endif\\n\\\nuniform float u_eccentricitySquared;\\n\\\nuniform vec2 u_ellipsoidRenderLatitudeSinMinMax;\\n\\\nuniform vec2 u_clipMinMaxHeight; // Values are negative: clipHeight - maxShapeHeight\\n\\\n\\n\\\nRayShapeIntersection intersectZPlane(in Ray ray, in float z) {\\n\\\n    float t = -ray.pos.z / ray.dir.z;\\n\\\n\\n\\\n    bool startsOutside = sign(ray.pos.z) == sign(z);\\n\\\n    bool entry = (t >= 0.0) != startsOutside;\\n\\\n\\n\\\n    vec4 intersect = vec4(0.0, 0.0, z, t);\\n\\\n    vec4 farSide = vec4(normalize(ray.dir), INF_HIT);\\n\\\n\\n\\\n    if (entry) {\\n\\\n        return RayShapeIntersection(intersect, farSide);\\n\\\n    } else {\\n\\\n        return RayShapeIntersection(-1.0 * farSide, intersect);\\n\\\n    }\\n\\\n}\\n\\\n\\n\\\nRayShapeIntersection intersectHeight(in Ray ray, in float height, in bool convex)\\n\\\n{\\n\\\n    // Scale the ray by the ellipsoid axes to make it a unit sphere\\n\\\n    // Note: approximating ellipsoid + height as an ellipsoid\\n\\\n    vec3 radiiCorrection = vec3(1.0) / (u_ellipsoidRadii + height);\\n\\\n    vec3 position = ray.pos * radiiCorrection;\\n\\\n    vec3 direction = ray.dir * radiiCorrection;\\n\\\n\\n\\\n    float a = dot(direction, direction); // ~ 1.0 (or maybe 4.0 if ray is scaled)\\n\\\n    float b = dot(direction, position); // roughly inside [-1.0, 1.0] when zoomed in\\n\\\n    float c = dot(position, position) - 1.0; // ~ 0.0 when zoomed in.\\n\\\n    float determinant = b * b - a * c; // ~ b * b when zoomed in\\n\\\n\\n\\\n    if (determinant < 0.0) {\\n\\\n        vec4 miss = vec4(normalize(direction), NO_HIT);\\n\\\n        return RayShapeIntersection(miss, miss);\\n\\\n    }\\n\\\n\\n\\\n    determinant = sqrt(determinant);\\n\\\n\\n\\\n    // Compute larger root using standard formula\\n\\\n    float signB = b < 0.0 ? -1.0 : 1.0;\\n\\\n    // The other root may suffer from subtractive cancellation in the standard formula.\\n\\\n    // Compute it from the first root instead.\\n\\\n    float t1 = (-b - signB * determinant) / a;\\n\\\n    float t2 = c / (a * t1);\\n\\\n    float tmin = min(t1, t2);\\n\\\n    float tmax = max(t1, t2);\\n\\\n\\n\\\n    float directionScale = convex ? 1.0 : -1.0;\\n\\\n    vec3 d1 = directionScale * (position + tmin * direction);\\n\\\n    vec3 d2 = directionScale * (position + tmax * direction);\\n\\\n\\n\\\n    // Return normals in eye coordinates. Use spherical approximation for the normal.\\n\\\n    vec3 normal1 = normalize(czm_normal * d1);\\n\\\n    vec3 normal2 = normalize(czm_normal * d2);\\n\\\n\\n\\\n    return RayShapeIntersection(vec4(normal1, tmin), vec4(normal2, tmax));\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Given a circular cone around the z-axis, with apex at the origin,\\n\\\n * find the parametric distance(s) along a ray where that ray intersects\\n\\\n * the cone.\\n\\\n * The cone opening angle is described by the squared cosine of\\n\\\n * its half-angle (the angle between the Z-axis and the surface)\\n\\\n */\\n\\\nvec2 intersectDoubleEndedCone(in Ray ray, in float cosSqrHalfAngle)\\n\\\n{\\n\\\n    vec3 o = ray.pos;\\n\\\n    vec3 d = ray.dir;\\n\\\n    float sinSqrHalfAngle = 1.0 - cosSqrHalfAngle;\\n\\\n\\n\\\n    float aSin = d.z * d.z * sinSqrHalfAngle;\\n\\\n    float aCos = -dot(d.xy, d.xy) * cosSqrHalfAngle;\\n\\\n    float a = aSin + aCos;\\n\\\n\\n\\\n    float bSin = d.z * o.z * sinSqrHalfAngle;\\n\\\n    float bCos = -dot(o.xy, d.xy) * cosSqrHalfAngle;\\n\\\n    float b = bSin + bCos;\\n\\\n\\n\\\n    float cSin = o.z * o.z * sinSqrHalfAngle;\\n\\\n    float cCos = -dot(o.xy, o.xy) * cosSqrHalfAngle;\\n\\\n    float c = cSin + cCos;\\n\\\n    // determinant = b * b - a * c. But bSin * bSin = aSin * cSin.\\n\\\n    // Avoid subtractive cancellation by expanding to eliminate these terms\\n\\\n    float determinant = 2.0 * bSin * bCos + bCos * bCos - aSin * cCos - aCos * cSin - aCos * cCos;\\n\\\n\\n\\\n    if (determinant < 0.0) {\\n\\\n        return vec2(NO_HIT);\\n\\\n    } else if (a == 0.0) {\\n\\\n        // Ray is parallel to cone surface\\n\\\n        return (b == 0.0)\\n\\\n            ? vec2(NO_HIT) // Ray is on cone surface\\n\\\n            : vec2(-0.5 * c / b, NO_HIT);\\n\\\n    }\\n\\\n\\n\\\n    determinant = sqrt(determinant);\\n\\\n\\n\\\n    // Compute larger root using standard formula\\n\\\n    float signB = b < 0.0 ? -1.0 : 1.0;\\n\\\n    float t1 = (-b - signB * determinant) / a;\\n\\\n    // The other root may suffer from subtractive cancellation in the standard formula.\\n\\\n    // Compute it from the first root instead.\\n\\\n    float t2 = c / (a * t1);\\n\\\n    float tmin = min(t1, t2);\\n\\\n    float tmax = max(t1, t2);\\n\\\n    return vec2(tmin, tmax);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Given a point on a conical surface, find the surface normal at that point.\\n\\\n */\\n\\\nvec3 getConeNormal(in vec3 p, in bool convex) {\\n\\\n    // Start with radial component pointing toward z-axis\\n\\\n    vec2 radial = -abs(p.z) * normalize(p.xy);\\n\\\n    // Z component points toward opening of cone\\n\\\n    float zSign = (p.z < 0.0) ? -1.0 : 1.0;\\n\\\n    float z = length(p.xy) * zSign;\\n\\\n    // Flip normal if shape is convex\\n\\\n    float flip = (convex) ? -1.0 : 1.0;\\n\\\n    return normalize(vec3(radial, z) * flip);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Compute the shift between the ellipsoid origin and the apex of a cone of latitude\\n\\\n */\\n\\\nfloat getLatitudeConeShift(in float sinLatitude) {\\n\\\n    // Find prime vertical radius of curvature: \\n\\\n    // the distance along the ellipsoid normal to the intersection with the z-axis\\n\\\n    float x2 = u_eccentricitySquared * sinLatitude * sinLatitude;\\n\\\n    float primeVerticalRadius = u_ellipsoidRadii.x * inversesqrt(1.0 - x2);\\n\\\n\\n\\\n    // Compute a shift from the origin to the intersection of the cone with the z-axis\\n\\\n    return primeVerticalRadius * u_eccentricitySquared * sinLatitude;\\n\\\n}\\n\\\n\\n\\\nvoid intersectFlippedCone(in Ray ray, in float cosHalfAngle, out RayShapeIntersection intersections[2]) {\\n\\\n    // Shift the ray to account for the latitude cone not being centered at the Earth center\\n\\\n    ray.pos.z += getLatitudeConeShift(cosHalfAngle);\\n\\\n\\n\\\n    float cosSqrHalfAngle = cosHalfAngle * cosHalfAngle;\\n\\\n    vec2 intersect = intersectDoubleEndedCone(ray, cosSqrHalfAngle);\\n\\\n\\n\\\n    vec4 miss = vec4(normalize(ray.dir), NO_HIT);\\n\\\n    vec4 farSide = vec4(normalize(ray.dir), INF_HIT);\\n\\\n\\n\\\n    // Initialize output with no intersections\\n\\\n    intersections[0].entry = -1.0 * farSide;\\n\\\n    intersections[0].exit = farSide;\\n\\\n    intersections[1].entry = miss;\\n\\\n    intersections[1].exit = miss;\\n\\\n\\n\\\n    if (intersect.x == NO_HIT) {\\n\\\n        return;\\n\\\n    }\\n\\\n\\n\\\n    // Find the points of intersection\\n\\\n    float tmin = intersect.x;\\n\\\n    float tmax = intersect.y;\\n\\\n    vec3 p0 = ray.pos + tmin * ray.dir;\\n\\\n    vec3 p1 = ray.pos + tmax * ray.dir;\\n\\\n\\n\\\n    vec4 intersect0 = vec4(getConeNormal(p0, true), tmin);\\n\\\n    vec4 intersect1 = vec4(getConeNormal(p1, true), tmax);\\n\\\n\\n\\\n    bool p0InShadowCone = sign(p0.z) != sign(cosHalfAngle);\\n\\\n    bool p1InShadowCone = sign(p1.z) != sign(cosHalfAngle);\\n\\\n\\n\\\n    if (p0InShadowCone && p1InShadowCone) {\\n\\\n        // no valid intersections\\n\\\n    } else if (p0InShadowCone) {\\n\\\n        intersections[0].exit = intersect1;\\n\\\n    } else if (p1InShadowCone) {\\n\\\n        intersections[0].entry = intersect0;\\n\\\n    } else {\\n\\\n        intersections[0].exit = intersect0;\\n\\\n        intersections[1].entry = intersect1;\\n\\\n        intersections[1].exit = farSide;\\n\\\n    }\\n\\\n}\\n\\\n\\n\\\nRayShapeIntersection intersectRegularCone(in Ray ray, in float cosHalfAngle, in bool convex) {\\n\\\n    // Shift the ray to account for the latitude cone not being centered at the Earth center\\n\\\n    ray.pos.z += getLatitudeConeShift(cosHalfAngle);\\n\\\n\\n\\\n    float cosSqrHalfAngle = cosHalfAngle * cosHalfAngle;\\n\\\n    vec2 intersect = intersectDoubleEndedCone(ray, cosSqrHalfAngle);\\n\\\n\\n\\\n    vec4 miss = vec4(normalize(ray.dir), NO_HIT);\\n\\\n    vec4 farSide = vec4(normalize(ray.dir), INF_HIT);\\n\\\n\\n\\\n    if (intersect.x == NO_HIT) {\\n\\\n        return RayShapeIntersection(miss, miss);\\n\\\n    }\\n\\\n\\n\\\n    // Find the points of intersection\\n\\\n    float tmin = intersect.x;\\n\\\n    float tmax = intersect.y;\\n\\\n    vec3 p0 = ray.pos + tmin * ray.dir;\\n\\\n    vec3 p1 = ray.pos + tmax * ray.dir;\\n\\\n\\n\\\n    vec4 intersect0 = vec4(getConeNormal(p0, convex), tmin);\\n\\\n    vec4 intersect1 = vec4(getConeNormal(p1, convex), tmax);\\n\\\n\\n\\\n    bool p0InShadowCone = sign(p0.z) != sign(cosHalfAngle);\\n\\\n    bool p1InShadowCone = sign(p1.z) != sign(cosHalfAngle);\\n\\\n\\n\\\n    if (p0InShadowCone && p1InShadowCone) {\\n\\\n        return RayShapeIntersection(miss, miss);\\n\\\n    } else if (p0InShadowCone) {\\n\\\n        return RayShapeIntersection(intersect1, farSide);\\n\\\n    } else if (p1InShadowCone) {\\n\\\n        return RayShapeIntersection(-1.0 * farSide, intersect0);\\n\\\n    } else {\\n\\\n        return RayShapeIntersection(intersect0, intersect1);\\n\\\n    }\\n\\\n}\\n\\\n\\n\\\nvoid intersectShape(in Ray ray, in Ray rayEC, inout Intersections ix) {    // Outer ellipsoid\\n\\\n    RayShapeIntersection outerIntersect = intersectHeight(ray, u_clipMinMaxHeight.y, true);\\n\\\n    setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MAX, outerIntersect);\\n\\\n\\n\\\n    // Exit early if the outer ellipsoid was missed.\\n\\\n    if (outerIntersect.entry.w == NO_HIT) {\\n\\\n        return;\\n\\\n    }\\n\\\n\\n\\\n    // Inner ellipsoid\\n\\\n    RayShapeIntersection innerIntersect = intersectHeight(ray, u_clipMinMaxHeight.x, false);\\n\\\n\\n\\\n    if (innerIntersect.entry.w == NO_HIT) {\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MIN, innerIntersect);\\n\\\n    } else {\\n\\\n        // When the ellipsoid is large and thin it's possible for floating point math\\n\\\n        // to cause the ray to intersect the inner ellipsoid before the outer ellipsoid. \\n\\\n        // To prevent this from happening, clamp innerIntersect to outerIntersect and\\n\\\n        // sandwich the inner ellipsoid intersection inside the outer ellipsoid intersection.\\n\\\n\\n\\\n        // Without this special case,\\n\\\n        // [outerMin, outerMax, innerMin, innerMax] will bubble sort to\\n\\\n        // [outerMin, innerMin, outerMax, innerMax] which will cause the back\\n\\\n        // side of the ellipsoid to be invisible because it will think the ray\\n\\\n        // is still inside the inner (negative) ellipsoid after exiting the\\n\\\n        // outer (positive) ellipsoid.\\n\\\n\\n\\\n        // With this special case,\\n\\\n        // [outerMin, innerMin, innerMax, outerMax] will bubble sort to\\n\\\n        // [outerMin, innerMin, innerMax, outerMax] which will work correctly.\\n\\\n\\n\\\n        // Note: If initializeIntersections() changes its sorting function\\n\\\n        // from bubble sort to something else, this code may need to change.\\n\\\n        innerIntersect.entry.w = max(innerIntersect.entry.w, outerIntersect.entry.w);\\n\\\n        innerIntersect.exit.w = min(innerIntersect.exit.w, outerIntersect.exit.w);\\n\\\n        setSurfaceIntersection(ix, 0, outerIntersect.entry, true, true);  // positive, enter\\n\\\n        setSurfaceIntersection(ix, 1, innerIntersect.entry, false, true); // negative, enter\\n\\\n        setSurfaceIntersection(ix, 2, innerIntersect.exit, false, false); // negative, exit\\n\\\n        setSurfaceIntersection(ix, 3, outerIntersect.exit, true, false);  // positive, exit\\n\\\n    }\\n\\\n\\n\\\n    // Bottom cone\\n\\\n    #if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_UNDER_HALF)\\n\\\n        RayShapeIntersection bottomConeIntersection = intersectRegularCone(ray, u_ellipsoidRenderLatitudeSinMinMax.x, false);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN, bottomConeIntersection);\\n\\\n    #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_EQUAL_HALF)\\n\\\n        RayShapeIntersection bottomConeIntersection = intersectZPlane(ray, -1.0);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN, bottomConeIntersection);\\n\\\n    #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_OVER_HALF)\\n\\\n        RayShapeIntersection bottomConeIntersections[2];\\n\\\n        intersectFlippedCone(ray, u_ellipsoidRenderLatitudeSinMinMax.x, bottomConeIntersections);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN + 0, bottomConeIntersections[0]);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN + 1, bottomConeIntersections[1]);\\n\\\n    #endif\\n\\\n\\n\\\n    // Top cone\\n\\\n    #if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_UNDER_HALF)\\n\\\n        RayShapeIntersection topConeIntersections[2];\\n\\\n        intersectFlippedCone(ray, u_ellipsoidRenderLatitudeSinMinMax.y, topConeIntersections);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX + 0, topConeIntersections[0]);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX + 1, topConeIntersections[1]);\\n\\\n    #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_EQUAL_HALF)\\n\\\n        RayShapeIntersection topConeIntersection = intersectZPlane(ray, 1.0);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX, topConeIntersection);\\n\\\n    #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_OVER_HALF)\\n\\\n        RayShapeIntersection topConeIntersection = intersectRegularCone(ray, u_ellipsoidRenderLatitudeSinMinMax.y, false);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX, topConeIntersection);\\n\\\n    #endif\\n\\\n\\n\\\n    // Wedge\\n\\\n    #if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_EQUAL_ZERO)\\n\\\n        RayShapeIntersection wedgeIntersects[2];\\n\\\n        intersectHalfPlane(ray, u_ellipsoidRenderLongitudeMinMax.x, wedgeIntersects);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LONGITUDE + 0, wedgeIntersects[0]);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LONGITUDE + 1, wedgeIntersects[1]);\\n\\\n    #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_UNDER_HALF)\\n\\\n        RayShapeIntersection wedgeIntersect = intersectRegularWedge(ray, u_ellipsoidRenderLongitudeMinMax);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LONGITUDE, wedgeIntersect);\\n\\\n    #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_OVER_HALF)\\n\\\n        RayShapeIntersection wedgeIntersects[2];\\n\\\n        intersectFlippedWedge(ray, u_ellipsoidRenderLongitudeMinMax, wedgeIntersects);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LONGITUDE + 0, wedgeIntersects[0]);\\n\\\n        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LONGITUDE + 1, wedgeIntersects[1]);\\n\\\n    #endif\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}