{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Check from \"../Core/Check.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport BufferLoader from \"./BufferLoader.js\";\nimport GltfBufferViewLoader from \"./GltfBufferViewLoader.js\";\nimport GltfDracoLoader from \"./GltfDracoLoader.js\";\nimport GltfImageLoader from \"./GltfImageLoader.js\";\nimport GltfIndexBufferLoader from \"./GltfIndexBufferLoader.js\";\nimport GltfJsonLoader from \"./GltfJsonLoader.js\";\nimport GltfTextureLoader from \"./GltfTextureLoader.js\";\nimport GltfVertexBufferLoader from \"./GltfVertexBufferLoader.js\";\nimport GltfSpzLoader from \"./GltfSpzLoader.js\";\nimport MetadataSchemaLoader from \"./MetadataSchemaLoader.js\";\nimport ResourceCacheKey from \"./ResourceCacheKey.js\";\nimport ResourceCacheStatistics from \"./ResourceCacheStatistics.js\";\n\n/**\n * Cache for resources shared across 3D Tiles and glTF.\n *\n * @namespace ResourceCache\n *\n * @private\n */\nfunction ResourceCache() {}\nResourceCache.cacheEntries = {};\n\n// Statistics about binary data stored in the resource cache\nResourceCache.statistics = new ResourceCacheStatistics();\n\n/**\n * A reference-counted cache entry.\n *\n * @param {ResourceLoader} resourceLoader The resource.\n *\n * @alias CacheEntry\n * @constructor\n *\n * @private\n */\nfunction CacheEntry(resourceLoader) {\n  this.referenceCount = 1;\n  this.resourceLoader = resourceLoader;\n\n  // For unit testing only\n  this._statisticsPromise = undefined;\n}\n\n/**\n * Gets a resource from the cache. If the resource exists its reference count is\n * incremented. Otherwise, if no resource loader exists, undefined is returned.\n *\n * @param {string} cacheKey The cache key of the resource.\n *\n * @returns {ResourceLoader|undefined} The resource.\n * @private\n */\nResourceCache.get = function (cacheKey) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"cacheKey\", cacheKey);\n  //>>includeEnd('debug');\n\n  const cacheEntry = ResourceCache.cacheEntries[cacheKey];\n  if (defined(cacheEntry)) {\n    ++cacheEntry.referenceCount;\n    return cacheEntry.resourceLoader;\n  }\n  return undefined;\n};\n\n/**\n * Adds it to the cache.\n *\n * @param {ResourceLoader} resourceLoader The resource.\n * @returns {ResourceLoader} The resource.\n *\n * @exception {DeveloperError} Resource with this cacheKey is already in the cache\n * @private\n */\nResourceCache.add = function (resourceLoader) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"resourceLoader\", resourceLoader);\n  //>>includeEnd('debug');\n\n  const cacheKey = resourceLoader.cacheKey;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"options.resourceLoader.cacheKey\", cacheKey);\n  if (defined(ResourceCache.cacheEntries[cacheKey])) {\n    throw new DeveloperError(`Resource with this cacheKey is already in the cache: ${cacheKey}`);\n  }\n  //>>includeEnd('debug');\n\n  ResourceCache.cacheEntries[cacheKey] = new CacheEntry(resourceLoader);\n  return resourceLoader;\n};\n\n/**\n * Unloads a resource from the cache. When the reference count hits zero the\n * resource is destroyed.\n *\n * @param {ResourceLoader} resourceLoader The resource.\n *\n * @exception {DeveloperError} Resource is not in the cache.\n * @exception {DeveloperError} Cannot unload resource that has no references.\n * @private\n */\nResourceCache.unload = function (resourceLoader) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"resourceLoader\", resourceLoader);\n  //>>includeEnd('debug');\n\n  const cacheKey = resourceLoader.cacheKey;\n  const cacheEntry = ResourceCache.cacheEntries[cacheKey];\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cacheEntry)) {\n    throw new DeveloperError(`Resource is not in the cache: ${cacheKey}`);\n  }\n  //>>includeEnd('debug');\n\n  --cacheEntry.referenceCount;\n  if (cacheEntry.referenceCount === 0) {\n    ResourceCache.statistics.removeLoader(resourceLoader);\n    resourceLoader.destroy();\n    delete ResourceCache.cacheEntries[cacheKey];\n  }\n};\n\n/**\n * Gets an existing schema loader from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} [options.schema] An object that explicitly defines a schema JSON. Mutually exclusive with options.resource.\n * @param {Resource} [options.resource] The {@link Resource} pointing to the schema JSON. Mutually exclusive with options.schema.\n *\n * @returns {MetadataSchemaLoader} The cached schema resource.\n *\n * @exception {DeveloperError} One of options.schema and options.resource must be defined.\n * @private\n */\nResourceCache.getSchemaLoader = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const {\n    schema,\n    resource\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(schema) === defined(resource)) {\n    throw new DeveloperError(\"One of options.schema and options.resource must be defined.\");\n  }\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getSchemaCacheKey({\n    schema: schema,\n    resource: resource\n  });\n  let schemaLoader = ResourceCache.get(cacheKey);\n  if (defined(schemaLoader)) {\n    return schemaLoader;\n  }\n  schemaLoader = new MetadataSchemaLoader({\n    schema: schema,\n    resource: resource,\n    cacheKey: cacheKey\n  });\n  return ResourceCache.add(schemaLoader);\n};\n\n/**\n * Gets an existing embedded buffer loader from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {Resource} options.parentResource The {@link Resource} containing the embedded buffer.\n * @param {number} options.bufferId A unique identifier of the embedded buffer within the parent resource.\n * @param {Uint8Array} [options.typedArray] The typed array containing the embedded buffer contents.\n *\n * @returns {BufferLoader} The cached buffer loader.\n * @private\n */\nResourceCache.getEmbeddedBufferLoader = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const {\n    parentResource,\n    bufferId,\n    typedArray\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.parentResource\", parentResource);\n  Check.typeOf.number(\"options.bufferId\", bufferId);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getEmbeddedBufferCacheKey({\n    parentResource: parentResource,\n    bufferId: bufferId\n  });\n  let bufferLoader = ResourceCache.get(cacheKey);\n  if (defined(bufferLoader)) {\n    return bufferLoader;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.typedArray\", typedArray);\n  //>>includeEnd('debug');\n\n  bufferLoader = new BufferLoader({\n    typedArray: typedArray,\n    cacheKey: cacheKey\n  });\n  return ResourceCache.add(bufferLoader);\n};\n\n/**\n * Gets an existing external buffer from loader the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {Resource} options.resource The {@link Resource} pointing to the external buffer.\n *\n * @returns {BufferLoader} The cached buffer loader.\n * @private\n */\nResourceCache.getExternalBufferLoader = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const {\n    resource\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.resource\", resource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getExternalBufferCacheKey({\n    resource: resource\n  });\n  let bufferLoader = ResourceCache.get(cacheKey);\n  if (defined(bufferLoader)) {\n    return bufferLoader;\n  }\n  bufferLoader = new BufferLoader({\n    resource: resource,\n    cacheKey: cacheKey\n  });\n  return ResourceCache.add(bufferLoader);\n};\n\n/**\n * Gets an existing glTF JSON loader from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {Uint8Array} [options.typedArray] The typed array containing the glTF contents.\n * @param {object} [options.gltfJson] The parsed glTF JSON contents.\n *\n * @returns {GltfJsonLoader} The cached glTF JSON loader.\n * @private\n */\nResourceCache.getGltfJsonLoader = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const {\n    gltfResource,\n    baseResource,\n    typedArray,\n    gltfJson\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getGltfCacheKey({\n    gltfResource: gltfResource\n  });\n  let gltfJsonLoader = ResourceCache.get(cacheKey);\n  if (defined(gltfJsonLoader)) {\n    return gltfJsonLoader;\n  }\n  gltfJsonLoader = new GltfJsonLoader({\n    resourceCache: ResourceCache,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    typedArray: typedArray,\n    gltfJson: gltfJson,\n    cacheKey: cacheKey\n  });\n  return ResourceCache.add(gltfJsonLoader);\n};\n\n/**\n * Gets an existing glTF buffer view from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {number} options.bufferViewId The bufferView ID.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n *\n * @returns {GltfBufferViewLoader} The cached buffer view loader.\n * @private\n */\nResourceCache.getBufferViewLoader = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const {\n    gltf,\n    bufferViewId,\n    gltfResource,\n    baseResource\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.bufferViewId\", bufferViewId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getBufferViewCacheKey({\n    gltf: gltf,\n    bufferViewId: bufferViewId,\n    gltfResource: gltfResource,\n    baseResource: baseResource\n  });\n  let bufferViewLoader = ResourceCache.get(cacheKey);\n  if (defined(bufferViewLoader)) {\n    return bufferViewLoader;\n  }\n  bufferViewLoader = new GltfBufferViewLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    bufferViewId: bufferViewId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    cacheKey: cacheKey\n  });\n  return ResourceCache.add(bufferViewLoader);\n};\n\n/**\n * Gets an existing Draco data from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {object} options.primitive The primitive containing the Draco extension.\n * @param {object} options.draco The Draco extension object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n *\n * @returns {GltfDracoLoader} The cached Draco loader.\n * @private\n */\nResourceCache.getDracoLoader = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const {\n    gltf,\n    primitive,\n    draco,\n    gltfResource,\n    baseResource\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.primitive\", primitive);\n  Check.typeOf.object(\"options.draco\", draco);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getDracoCacheKey({\n    gltf: gltf,\n    draco: draco,\n    gltfResource: gltfResource,\n    baseResource: baseResource\n  });\n  let dracoLoader = ResourceCache.get(cacheKey);\n  if (defined(dracoLoader)) {\n    return dracoLoader;\n  }\n  dracoLoader = new GltfDracoLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    primitive: primitive,\n    draco: draco,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    cacheKey: cacheKey\n  });\n  return ResourceCache.add(dracoLoader);\n};\n\n/**\n * Gets an existing SPZ loader from the cache, or creates a new loader if one does not already exist.\n * This loader is used to decode SPZ (Splat Point Cloud) data in glTF.\n * \n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {object} options.primitive The primitive containing the SPZ extension.\n * @param {object} options.spz The SPZ extension object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n *\n * @return {GltfSpzLoader} The cached SPZ loader.\n @private\n * */\nResourceCache.getSpzLoader = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const {\n    gltf,\n    primitive,\n    spz,\n    gltfResource,\n    baseResource\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.primitive\", primitive);\n  Check.typeOf.object(\"options.spz\", spz);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getSpzCacheKey({\n    gltf: gltf,\n    primitive: primitive,\n    gltfResource: gltfResource,\n    baseResource: baseResource\n  });\n  let spzLoader = ResourceCache.get(cacheKey);\n  if (defined(spzLoader)) {\n    return spzLoader;\n  }\n  spzLoader = new GltfSpzLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    primitive: primitive,\n    spz: spz,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    cacheKey: cacheKey\n  });\n  return ResourceCache.add(spzLoader);\n};\n\n/**\n * Gets an existing glTF vertex buffer from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {FrameState} options.frameState The frame state.\n * @param {number} [options.bufferViewId] The bufferView ID corresponding to the vertex buffer.\n * @param {object} [options.primitive] The primitive containing the Draco extension.\n * @param {object} [options.draco] The Draco extension object.\n * @param {string} [options.attributeSemantic] The attribute semantic, e.g. POSITION or NORMAL.\n * @param {number} [options.accessorId] The accessor ID.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {boolean} [options.dequantize=false] Determines whether or not the vertex buffer will be dequantized on the CPU.\n * @param {boolean} [options.loadBuffer=false] Load vertex buffer as a GPU vertex buffer.\n * @param {boolean} [options.loadTypedArray=false] Load vertex buffer as a typed array.\n * @exception {DeveloperError} One of options.bufferViewId and options.draco must be defined.\n * @exception {DeveloperError} When options.draco is defined options.attributeSemantic must also be defined.\n * @exception {DeveloperError} When options.draco is defined options.accessorId must also be defined.\n *\n * @returns {GltfVertexBufferLoader} The cached vertex buffer loader.\n * @private\n */\nResourceCache.getVertexBufferLoader = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const {\n    gltf,\n    gltfResource,\n    baseResource,\n    frameState,\n    bufferViewId,\n    primitive,\n    draco,\n    spz,\n    attributeSemantic,\n    accessorId,\n    asynchronous = true,\n    dequantize = false,\n    loadBuffer = false,\n    loadTypedArray = false\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  Check.typeOf.object(\"options.frameState\", frameState);\n  if (!loadBuffer && !loadTypedArray) {\n    throw new DeveloperError(\"At least one of loadBuffer and loadTypedArray must be true.\");\n  }\n  const hasBufferViewId = defined(bufferViewId);\n  const hasPrimitive = defined(primitive);\n  const hasDraco = hasDracoCompression(draco, attributeSemantic);\n  const hasAttributeSemantic = defined(attributeSemantic);\n  const hasAccessorId = defined(accessorId);\n  const hasSpz = defined(spz);\n  if (hasBufferViewId === (hasDraco !== hasSpz)) {\n    throw new DeveloperError(\"One of options.bufferViewId, options.draco, or options.spz must be defined.\");\n  }\n  if (hasDraco && !hasAttributeSemantic) {\n    throw new DeveloperError(\"When options.draco is defined options.attributeSemantic must also be defined.\");\n  }\n  if (hasDraco && !hasAccessorId) {\n    throw new DeveloperError(\"When options.draco is defined options.hasAccessorId must also be defined.\");\n  }\n  if (hasDraco && !hasPrimitive) {\n    throw new DeveloperError(\"When options.draco is defined options.primitive must also be defined.\");\n  }\n  if (hasDraco) {\n    Check.typeOf.object(\"options.draco\", draco);\n    Check.typeOf.string(\"options.attributeSemantic\", attributeSemantic);\n    Check.typeOf.number(\"options.accessorId\", accessorId);\n  }\n\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getVertexBufferCacheKey({\n    gltf: gltf,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    frameState: frameState,\n    bufferViewId: bufferViewId,\n    draco: draco,\n    spz: spz,\n    attributeSemantic: attributeSemantic,\n    dequantize: dequantize,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray\n  });\n  let vertexBufferLoader = ResourceCache.get(cacheKey);\n  if (defined(vertexBufferLoader)) {\n    return vertexBufferLoader;\n  }\n  vertexBufferLoader = new GltfVertexBufferLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    bufferViewId: bufferViewId,\n    primitive: primitive,\n    draco: draco,\n    spz: spz,\n    attributeSemantic: attributeSemantic,\n    accessorId: accessorId,\n    cacheKey: cacheKey,\n    asynchronous: asynchronous,\n    dequantize: dequantize,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray\n  });\n  return ResourceCache.add(vertexBufferLoader);\n};\nfunction hasDracoCompression(draco, semantic) {\n  return defined(draco) && defined(draco.attributes) && defined(draco.attributes[semantic]);\n}\n\n/**\n * Gets an existing glTF index buffer from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {number} options.accessorId The accessor ID corresponding to the index buffer.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {FrameState} options.frameState The frame state.\n * @param {object} [options.primitive] The primitive containing the Draco extension.\n * @param {object} [options.draco] The Draco extension object.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {boolean} [options.loadBuffer=false] Load index buffer as a GPU index buffer.\n * @param {boolean} [options.loadTypedArray=false] Load index buffer as a typed array.\n * @returns {GltfIndexBufferLoader} The cached index buffer loader.\n * @private\n */\nResourceCache.getIndexBufferLoader = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const {\n    gltf,\n    accessorId,\n    gltfResource,\n    baseResource,\n    frameState,\n    primitive,\n    draco,\n    asynchronous = true,\n    loadBuffer = false,\n    loadTypedArray = false\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.accessorId\", accessorId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  Check.typeOf.object(\"options.frameState\", frameState);\n  if (!loadBuffer && !loadTypedArray) {\n    throw new DeveloperError(\"At least one of loadBuffer and loadTypedArray must be true.\");\n  }\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getIndexBufferCacheKey({\n    gltf: gltf,\n    accessorId: accessorId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    frameState: frameState,\n    draco: draco,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray\n  });\n  let indexBufferLoader = ResourceCache.get(cacheKey);\n  if (defined(indexBufferLoader)) {\n    return indexBufferLoader;\n  }\n  indexBufferLoader = new GltfIndexBufferLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    accessorId: accessorId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    primitive: primitive,\n    draco: draco,\n    cacheKey: cacheKey,\n    asynchronous: asynchronous,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray\n  });\n  return ResourceCache.add(indexBufferLoader);\n};\n\n/**\n * Gets an existing glTF image from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {number} options.imageId The image ID.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n *\n * @returns {GltfImageLoader} The cached image loader.\n * @private\n */\nResourceCache.getImageLoader = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const {\n    gltf,\n    imageId,\n    gltfResource,\n    baseResource\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.imageId\", imageId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getImageCacheKey({\n    gltf: gltf,\n    imageId: imageId,\n    gltfResource: gltfResource,\n    baseResource: baseResource\n  });\n  let imageLoader = ResourceCache.get(cacheKey);\n  if (defined(imageLoader)) {\n    return imageLoader;\n  }\n  imageLoader = new GltfImageLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    imageId: imageId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    cacheKey: cacheKey\n  });\n  return ResourceCache.add(imageLoader);\n};\n\n/**\n * Gets an existing glTF texture from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {object} options.textureInfo The texture info object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {SupportedImageFormats} options.supportedImageFormats The supported image formats.\n * @param {FrameState} options.frameState The frame state.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n *\n * @returns {GltfTextureLoader} The cached texture loader.\n * @private\n */\nResourceCache.getTextureLoader = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const {\n    gltf,\n    textureInfo,\n    gltfResource,\n    baseResource,\n    supportedImageFormats,\n    frameState,\n    asynchronous = true\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.textureInfo\", textureInfo);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  Check.typeOf.object(\"options.supportedImageFormats\", supportedImageFormats);\n  Check.typeOf.object(\"options.frameState\", frameState);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getTextureCacheKey({\n    gltf: gltf,\n    textureInfo: textureInfo,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    supportedImageFormats: supportedImageFormats,\n    frameState: frameState\n  });\n  let textureLoader = ResourceCache.get(cacheKey);\n  if (defined(textureLoader)) {\n    return textureLoader;\n  }\n  textureLoader = new GltfTextureLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    textureInfo: textureInfo,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    supportedImageFormats: supportedImageFormats,\n    cacheKey: cacheKey,\n    asynchronous: asynchronous\n  });\n  return ResourceCache.add(textureLoader);\n};\n\n/**\n * Unload everything from the cache. This is used for unit testing.\n *\n * @private\n */\nResourceCache.clearForSpecs = function () {\n  // Unload in the order below. This prevents an unload function from unloading\n  // a resource that has already been unloaded.\n  const precedence = [GltfVertexBufferLoader, GltfIndexBufferLoader, GltfDracoLoader, GltfTextureLoader, GltfImageLoader, GltfBufferViewLoader, BufferLoader, MetadataSchemaLoader, GltfJsonLoader];\n  let cacheKey;\n  const cacheEntries = ResourceCache.cacheEntries;\n  const cacheEntriesSorted = [];\n  for (cacheKey in cacheEntries) {\n    if (cacheEntries.hasOwnProperty(cacheKey)) {\n      cacheEntriesSorted.push(cacheEntries[cacheKey]);\n    }\n  }\n  cacheEntriesSorted.sort(function (a, b) {\n    const indexA = precedence.indexOf(a.resourceLoader.constructor);\n    const indexB = precedence.indexOf(b.resourceLoader.constructor);\n    return indexA - indexB;\n  });\n  const cacheEntriesLength = cacheEntriesSorted.length;\n  for (let i = 0; i < cacheEntriesLength; ++i) {\n    const cacheEntry = cacheEntriesSorted[i];\n    cacheKey = cacheEntry.resourceLoader.cacheKey;\n    if (defined(cacheEntries[cacheKey])) {\n      cacheEntry.resourceLoader.destroy();\n      delete cacheEntries[cacheKey];\n    }\n  }\n  ResourceCache.statistics.clear();\n};\nexport default ResourceCache;","map":{"version":3,"names":["Check","Frozen","defined","DeveloperError","BufferLoader","GltfBufferViewLoader","GltfDracoLoader","GltfImageLoader","GltfIndexBufferLoader","GltfJsonLoader","GltfTextureLoader","GltfVertexBufferLoader","GltfSpzLoader","MetadataSchemaLoader","ResourceCacheKey","ResourceCacheStatistics","ResourceCache","cacheEntries","statistics","CacheEntry","resourceLoader","referenceCount","_statisticsPromise","undefined","get","cacheKey","typeOf","string","cacheEntry","add","object","unload","removeLoader","destroy","getSchemaLoader","options","EMPTY_OBJECT","schema","resource","getSchemaCacheKey","schemaLoader","getEmbeddedBufferLoader","parentResource","bufferId","typedArray","number","getEmbeddedBufferCacheKey","bufferLoader","getExternalBufferLoader","getExternalBufferCacheKey","getGltfJsonLoader","gltfResource","baseResource","gltfJson","getGltfCacheKey","gltfJsonLoader","resourceCache","getBufferViewLoader","gltf","bufferViewId","getBufferViewCacheKey","bufferViewLoader","getDracoLoader","primitive","draco","getDracoCacheKey","dracoLoader","getSpzLoader","spz","getSpzCacheKey","spzLoader","getVertexBufferLoader","frameState","attributeSemantic","accessorId","asynchronous","dequantize","loadBuffer","loadTypedArray","hasBufferViewId","hasPrimitive","hasDraco","hasDracoCompression","hasAttributeSemantic","hasAccessorId","hasSpz","getVertexBufferCacheKey","vertexBufferLoader","semantic","attributes","getIndexBufferLoader","getIndexBufferCacheKey","indexBufferLoader","getImageLoader","imageId","getImageCacheKey","imageLoader","getTextureLoader","textureInfo","supportedImageFormats","getTextureCacheKey","textureLoader","clearForSpecs","precedence","cacheEntriesSorted","hasOwnProperty","push","sort","a","b","indexA","indexOf","constructor","indexB","cacheEntriesLength","length","i","clear"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/ResourceCache.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport BufferLoader from \"./BufferLoader.js\";\nimport GltfBufferViewLoader from \"./GltfBufferViewLoader.js\";\nimport GltfDracoLoader from \"./GltfDracoLoader.js\";\nimport GltfImageLoader from \"./GltfImageLoader.js\";\nimport GltfIndexBufferLoader from \"./GltfIndexBufferLoader.js\";\nimport GltfJsonLoader from \"./GltfJsonLoader.js\";\nimport GltfTextureLoader from \"./GltfTextureLoader.js\";\nimport GltfVertexBufferLoader from \"./GltfVertexBufferLoader.js\";\nimport GltfSpzLoader from \"./GltfSpzLoader.js\";\nimport MetadataSchemaLoader from \"./MetadataSchemaLoader.js\";\nimport ResourceCacheKey from \"./ResourceCacheKey.js\";\nimport ResourceCacheStatistics from \"./ResourceCacheStatistics.js\";\n\n/**\n * Cache for resources shared across 3D Tiles and glTF.\n *\n * @namespace ResourceCache\n *\n * @private\n */\nfunction ResourceCache() {}\n\nResourceCache.cacheEntries = {};\n\n// Statistics about binary data stored in the resource cache\nResourceCache.statistics = new ResourceCacheStatistics();\n\n/**\n * A reference-counted cache entry.\n *\n * @param {ResourceLoader} resourceLoader The resource.\n *\n * @alias CacheEntry\n * @constructor\n *\n * @private\n */\nfunction CacheEntry(resourceLoader) {\n  this.referenceCount = 1;\n  this.resourceLoader = resourceLoader;\n\n  // For unit testing only\n  this._statisticsPromise = undefined;\n}\n\n/**\n * Gets a resource from the cache. If the resource exists its reference count is\n * incremented. Otherwise, if no resource loader exists, undefined is returned.\n *\n * @param {string} cacheKey The cache key of the resource.\n *\n * @returns {ResourceLoader|undefined} The resource.\n * @private\n */\nResourceCache.get = function (cacheKey) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"cacheKey\", cacheKey);\n  //>>includeEnd('debug');\n\n  const cacheEntry = ResourceCache.cacheEntries[cacheKey];\n  if (defined(cacheEntry)) {\n    ++cacheEntry.referenceCount;\n    return cacheEntry.resourceLoader;\n  }\n  return undefined;\n};\n\n/**\n * Adds it to the cache.\n *\n * @param {ResourceLoader} resourceLoader The resource.\n * @returns {ResourceLoader} The resource.\n *\n * @exception {DeveloperError} Resource with this cacheKey is already in the cache\n * @private\n */\nResourceCache.add = function (resourceLoader) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"resourceLoader\", resourceLoader);\n  //>>includeEnd('debug');\n\n  const cacheKey = resourceLoader.cacheKey;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"options.resourceLoader.cacheKey\", cacheKey);\n\n  if (defined(ResourceCache.cacheEntries[cacheKey])) {\n    throw new DeveloperError(\n      `Resource with this cacheKey is already in the cache: ${cacheKey}`,\n    );\n  }\n  //>>includeEnd('debug');\n\n  ResourceCache.cacheEntries[cacheKey] = new CacheEntry(resourceLoader);\n\n  return resourceLoader;\n};\n\n/**\n * Unloads a resource from the cache. When the reference count hits zero the\n * resource is destroyed.\n *\n * @param {ResourceLoader} resourceLoader The resource.\n *\n * @exception {DeveloperError} Resource is not in the cache.\n * @exception {DeveloperError} Cannot unload resource that has no references.\n * @private\n */\nResourceCache.unload = function (resourceLoader) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"resourceLoader\", resourceLoader);\n  //>>includeEnd('debug');\n\n  const cacheKey = resourceLoader.cacheKey;\n  const cacheEntry = ResourceCache.cacheEntries[cacheKey];\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cacheEntry)) {\n    throw new DeveloperError(`Resource is not in the cache: ${cacheKey}`);\n  }\n  //>>includeEnd('debug');\n\n  --cacheEntry.referenceCount;\n\n  if (cacheEntry.referenceCount === 0) {\n    ResourceCache.statistics.removeLoader(resourceLoader);\n    resourceLoader.destroy();\n    delete ResourceCache.cacheEntries[cacheKey];\n  }\n};\n\n/**\n * Gets an existing schema loader from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} [options.schema] An object that explicitly defines a schema JSON. Mutually exclusive with options.resource.\n * @param {Resource} [options.resource] The {@link Resource} pointing to the schema JSON. Mutually exclusive with options.schema.\n *\n * @returns {MetadataSchemaLoader} The cached schema resource.\n *\n * @exception {DeveloperError} One of options.schema and options.resource must be defined.\n * @private\n */\nResourceCache.getSchemaLoader = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const { schema, resource } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(schema) === defined(resource)) {\n    throw new DeveloperError(\n      \"One of options.schema and options.resource must be defined.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getSchemaCacheKey({\n    schema: schema,\n    resource: resource,\n  });\n\n  let schemaLoader = ResourceCache.get(cacheKey);\n  if (defined(schemaLoader)) {\n    return schemaLoader;\n  }\n\n  schemaLoader = new MetadataSchemaLoader({\n    schema: schema,\n    resource: resource,\n    cacheKey: cacheKey,\n  });\n\n  return ResourceCache.add(schemaLoader);\n};\n\n/**\n * Gets an existing embedded buffer loader from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {Resource} options.parentResource The {@link Resource} containing the embedded buffer.\n * @param {number} options.bufferId A unique identifier of the embedded buffer within the parent resource.\n * @param {Uint8Array} [options.typedArray] The typed array containing the embedded buffer contents.\n *\n * @returns {BufferLoader} The cached buffer loader.\n * @private\n */\nResourceCache.getEmbeddedBufferLoader = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const { parentResource, bufferId, typedArray } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.parentResource\", parentResource);\n  Check.typeOf.number(\"options.bufferId\", bufferId);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getEmbeddedBufferCacheKey({\n    parentResource: parentResource,\n    bufferId: bufferId,\n  });\n\n  let bufferLoader = ResourceCache.get(cacheKey);\n  if (defined(bufferLoader)) {\n    return bufferLoader;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.typedArray\", typedArray);\n  //>>includeEnd('debug');\n\n  bufferLoader = new BufferLoader({\n    typedArray: typedArray,\n    cacheKey: cacheKey,\n  });\n\n  return ResourceCache.add(bufferLoader);\n};\n\n/**\n * Gets an existing external buffer from loader the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {Resource} options.resource The {@link Resource} pointing to the external buffer.\n *\n * @returns {BufferLoader} The cached buffer loader.\n * @private\n */\nResourceCache.getExternalBufferLoader = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const { resource } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.resource\", resource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getExternalBufferCacheKey({\n    resource: resource,\n  });\n\n  let bufferLoader = ResourceCache.get(cacheKey);\n  if (defined(bufferLoader)) {\n    return bufferLoader;\n  }\n\n  bufferLoader = new BufferLoader({\n    resource: resource,\n    cacheKey: cacheKey,\n  });\n\n  return ResourceCache.add(bufferLoader);\n};\n\n/**\n * Gets an existing glTF JSON loader from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {Uint8Array} [options.typedArray] The typed array containing the glTF contents.\n * @param {object} [options.gltfJson] The parsed glTF JSON contents.\n *\n * @returns {GltfJsonLoader} The cached glTF JSON loader.\n * @private\n */\nResourceCache.getGltfJsonLoader = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const { gltfResource, baseResource, typedArray, gltfJson } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getGltfCacheKey({\n    gltfResource: gltfResource,\n  });\n\n  let gltfJsonLoader = ResourceCache.get(cacheKey);\n  if (defined(gltfJsonLoader)) {\n    return gltfJsonLoader;\n  }\n\n  gltfJsonLoader = new GltfJsonLoader({\n    resourceCache: ResourceCache,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    typedArray: typedArray,\n    gltfJson: gltfJson,\n    cacheKey: cacheKey,\n  });\n\n  return ResourceCache.add(gltfJsonLoader);\n};\n\n/**\n * Gets an existing glTF buffer view from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {number} options.bufferViewId The bufferView ID.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n *\n * @returns {GltfBufferViewLoader} The cached buffer view loader.\n * @private\n */\nResourceCache.getBufferViewLoader = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const { gltf, bufferViewId, gltfResource, baseResource } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.bufferViewId\", bufferViewId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getBufferViewCacheKey({\n    gltf: gltf,\n    bufferViewId: bufferViewId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n  });\n\n  let bufferViewLoader = ResourceCache.get(cacheKey);\n  if (defined(bufferViewLoader)) {\n    return bufferViewLoader;\n  }\n\n  bufferViewLoader = new GltfBufferViewLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    bufferViewId: bufferViewId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    cacheKey: cacheKey,\n  });\n\n  return ResourceCache.add(bufferViewLoader);\n};\n\n/**\n * Gets an existing Draco data from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {object} options.primitive The primitive containing the Draco extension.\n * @param {object} options.draco The Draco extension object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n *\n * @returns {GltfDracoLoader} The cached Draco loader.\n * @private\n */\nResourceCache.getDracoLoader = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const { gltf, primitive, draco, gltfResource, baseResource } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.primitive\", primitive);\n  Check.typeOf.object(\"options.draco\", draco);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getDracoCacheKey({\n    gltf: gltf,\n    draco: draco,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n  });\n\n  let dracoLoader = ResourceCache.get(cacheKey);\n  if (defined(dracoLoader)) {\n    return dracoLoader;\n  }\n\n  dracoLoader = new GltfDracoLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    primitive: primitive,\n    draco: draco,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    cacheKey: cacheKey,\n  });\n\n  return ResourceCache.add(dracoLoader);\n};\n\n/**\n * Gets an existing SPZ loader from the cache, or creates a new loader if one does not already exist.\n * This loader is used to decode SPZ (Splat Point Cloud) data in glTF.\n * \n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {object} options.primitive The primitive containing the SPZ extension.\n * @param {object} options.spz The SPZ extension object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n *\n * @return {GltfSpzLoader} The cached SPZ loader.\n @private\n * */\nResourceCache.getSpzLoader = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const { gltf, primitive, spz, gltfResource, baseResource } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.primitive\", primitive);\n  Check.typeOf.object(\"options.spz\", spz);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getSpzCacheKey({\n    gltf: gltf,\n    primitive: primitive,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n  });\n\n  let spzLoader = ResourceCache.get(cacheKey);\n  if (defined(spzLoader)) {\n    return spzLoader;\n  }\n\n  spzLoader = new GltfSpzLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    primitive: primitive,\n    spz: spz,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    cacheKey: cacheKey,\n  });\n\n  return ResourceCache.add(spzLoader);\n};\n\n/**\n * Gets an existing glTF vertex buffer from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {FrameState} options.frameState The frame state.\n * @param {number} [options.bufferViewId] The bufferView ID corresponding to the vertex buffer.\n * @param {object} [options.primitive] The primitive containing the Draco extension.\n * @param {object} [options.draco] The Draco extension object.\n * @param {string} [options.attributeSemantic] The attribute semantic, e.g. POSITION or NORMAL.\n * @param {number} [options.accessorId] The accessor ID.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {boolean} [options.dequantize=false] Determines whether or not the vertex buffer will be dequantized on the CPU.\n * @param {boolean} [options.loadBuffer=false] Load vertex buffer as a GPU vertex buffer.\n * @param {boolean} [options.loadTypedArray=false] Load vertex buffer as a typed array.\n * @exception {DeveloperError} One of options.bufferViewId and options.draco must be defined.\n * @exception {DeveloperError} When options.draco is defined options.attributeSemantic must also be defined.\n * @exception {DeveloperError} When options.draco is defined options.accessorId must also be defined.\n *\n * @returns {GltfVertexBufferLoader} The cached vertex buffer loader.\n * @private\n */\nResourceCache.getVertexBufferLoader = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const {\n    gltf,\n    gltfResource,\n    baseResource,\n    frameState,\n    bufferViewId,\n    primitive,\n    draco,\n    spz,\n    attributeSemantic,\n    accessorId,\n    asynchronous = true,\n    dequantize = false,\n    loadBuffer = false,\n    loadTypedArray = false,\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  Check.typeOf.object(\"options.frameState\", frameState);\n  if (!loadBuffer && !loadTypedArray) {\n    throw new DeveloperError(\n      \"At least one of loadBuffer and loadTypedArray must be true.\",\n    );\n  }\n\n  const hasBufferViewId = defined(bufferViewId);\n  const hasPrimitive = defined(primitive);\n  const hasDraco = hasDracoCompression(draco, attributeSemantic);\n  const hasAttributeSemantic = defined(attributeSemantic);\n  const hasAccessorId = defined(accessorId);\n  const hasSpz = defined(spz);\n\n  if (hasBufferViewId === (hasDraco !== hasSpz)) {\n    throw new DeveloperError(\n      \"One of options.bufferViewId, options.draco, or options.spz must be defined.\",\n    );\n  }\n\n  if (hasDraco && !hasAttributeSemantic) {\n    throw new DeveloperError(\n      \"When options.draco is defined options.attributeSemantic must also be defined.\",\n    );\n  }\n\n  if (hasDraco && !hasAccessorId) {\n    throw new DeveloperError(\n      \"When options.draco is defined options.hasAccessorId must also be defined.\",\n    );\n  }\n\n  if (hasDraco && !hasPrimitive) {\n    throw new DeveloperError(\n      \"When options.draco is defined options.primitive must also be defined.\",\n    );\n  }\n\n  if (hasDraco) {\n    Check.typeOf.object(\"options.draco\", draco);\n    Check.typeOf.string(\"options.attributeSemantic\", attributeSemantic);\n    Check.typeOf.number(\"options.accessorId\", accessorId);\n  }\n\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getVertexBufferCacheKey({\n    gltf: gltf,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    frameState: frameState,\n    bufferViewId: bufferViewId,\n    draco: draco,\n    spz: spz,\n    attributeSemantic: attributeSemantic,\n    dequantize: dequantize,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray,\n  });\n\n  let vertexBufferLoader = ResourceCache.get(cacheKey);\n  if (defined(vertexBufferLoader)) {\n    return vertexBufferLoader;\n  }\n\n  vertexBufferLoader = new GltfVertexBufferLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    bufferViewId: bufferViewId,\n    primitive: primitive,\n    draco: draco,\n    spz: spz,\n    attributeSemantic: attributeSemantic,\n    accessorId: accessorId,\n    cacheKey: cacheKey,\n    asynchronous: asynchronous,\n    dequantize: dequantize,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray,\n  });\n\n  return ResourceCache.add(vertexBufferLoader);\n};\n\nfunction hasDracoCompression(draco, semantic) {\n  return (\n    defined(draco) &&\n    defined(draco.attributes) &&\n    defined(draco.attributes[semantic])\n  );\n}\n\n/**\n * Gets an existing glTF index buffer from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {number} options.accessorId The accessor ID corresponding to the index buffer.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {FrameState} options.frameState The frame state.\n * @param {object} [options.primitive] The primitive containing the Draco extension.\n * @param {object} [options.draco] The Draco extension object.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {boolean} [options.loadBuffer=false] Load index buffer as a GPU index buffer.\n * @param {boolean} [options.loadTypedArray=false] Load index buffer as a typed array.\n * @returns {GltfIndexBufferLoader} The cached index buffer loader.\n * @private\n */\nResourceCache.getIndexBufferLoader = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const {\n    gltf,\n    accessorId,\n    gltfResource,\n    baseResource,\n    frameState,\n    primitive,\n    draco,\n    asynchronous = true,\n    loadBuffer = false,\n    loadTypedArray = false,\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.accessorId\", accessorId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  Check.typeOf.object(\"options.frameState\", frameState);\n  if (!loadBuffer && !loadTypedArray) {\n    throw new DeveloperError(\n      \"At least one of loadBuffer and loadTypedArray must be true.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getIndexBufferCacheKey({\n    gltf: gltf,\n    accessorId: accessorId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    frameState: frameState,\n    draco: draco,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray,\n  });\n\n  let indexBufferLoader = ResourceCache.get(cacheKey);\n  if (defined(indexBufferLoader)) {\n    return indexBufferLoader;\n  }\n\n  indexBufferLoader = new GltfIndexBufferLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    accessorId: accessorId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    primitive: primitive,\n    draco: draco,\n    cacheKey: cacheKey,\n    asynchronous: asynchronous,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray,\n  });\n\n  return ResourceCache.add(indexBufferLoader);\n};\n\n/**\n * Gets an existing glTF image from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {number} options.imageId The image ID.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n *\n * @returns {GltfImageLoader} The cached image loader.\n * @private\n */\nResourceCache.getImageLoader = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const { gltf, imageId, gltfResource, baseResource } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.imageId\", imageId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getImageCacheKey({\n    gltf: gltf,\n    imageId: imageId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n  });\n\n  let imageLoader = ResourceCache.get(cacheKey);\n  if (defined(imageLoader)) {\n    return imageLoader;\n  }\n\n  imageLoader = new GltfImageLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    imageId: imageId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    cacheKey: cacheKey,\n  });\n\n  return ResourceCache.add(imageLoader);\n};\n\n/**\n * Gets an existing glTF texture from the cache, or creates a new loader if one does not already exist.\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.gltf The glTF JSON.\n * @param {object} options.textureInfo The texture info object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {SupportedImageFormats} options.supportedImageFormats The supported image formats.\n * @param {FrameState} options.frameState The frame state.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n *\n * @returns {GltfTextureLoader} The cached texture loader.\n * @private\n */\nResourceCache.getTextureLoader = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const {\n    gltf,\n    textureInfo,\n    gltfResource,\n    baseResource,\n    supportedImageFormats,\n    frameState,\n    asynchronous = true,\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.textureInfo\", textureInfo);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  Check.typeOf.object(\"options.supportedImageFormats\", supportedImageFormats);\n  Check.typeOf.object(\"options.frameState\", frameState);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getTextureCacheKey({\n    gltf: gltf,\n    textureInfo: textureInfo,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    supportedImageFormats: supportedImageFormats,\n    frameState: frameState,\n  });\n\n  let textureLoader = ResourceCache.get(cacheKey);\n  if (defined(textureLoader)) {\n    return textureLoader;\n  }\n\n  textureLoader = new GltfTextureLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    textureInfo: textureInfo,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    supportedImageFormats: supportedImageFormats,\n    cacheKey: cacheKey,\n    asynchronous: asynchronous,\n  });\n\n  return ResourceCache.add(textureLoader);\n};\n\n/**\n * Unload everything from the cache. This is used for unit testing.\n *\n * @private\n */\nResourceCache.clearForSpecs = function () {\n  // Unload in the order below. This prevents an unload function from unloading\n  // a resource that has already been unloaded.\n  const precedence = [\n    GltfVertexBufferLoader,\n    GltfIndexBufferLoader,\n    GltfDracoLoader,\n    GltfTextureLoader,\n    GltfImageLoader,\n    GltfBufferViewLoader,\n    BufferLoader,\n    MetadataSchemaLoader,\n    GltfJsonLoader,\n  ];\n\n  let cacheKey;\n  const cacheEntries = ResourceCache.cacheEntries;\n\n  const cacheEntriesSorted = [];\n  for (cacheKey in cacheEntries) {\n    if (cacheEntries.hasOwnProperty(cacheKey)) {\n      cacheEntriesSorted.push(cacheEntries[cacheKey]);\n    }\n  }\n\n  cacheEntriesSorted.sort(function (a, b) {\n    const indexA = precedence.indexOf(a.resourceLoader.constructor);\n    const indexB = precedence.indexOf(b.resourceLoader.constructor);\n    return indexA - indexB;\n  });\n\n  const cacheEntriesLength = cacheEntriesSorted.length;\n  for (let i = 0; i < cacheEntriesLength; ++i) {\n    const cacheEntry = cacheEntriesSorted[i];\n    cacheKey = cacheEntry.resourceLoader.cacheKey;\n    if (defined(cacheEntries[cacheKey])) {\n      cacheEntry.resourceLoader.destroy();\n      delete cacheEntries[cacheKey];\n    }\n  }\n\n  ResourceCache.statistics.clear();\n};\n\nexport default ResourceCache;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}