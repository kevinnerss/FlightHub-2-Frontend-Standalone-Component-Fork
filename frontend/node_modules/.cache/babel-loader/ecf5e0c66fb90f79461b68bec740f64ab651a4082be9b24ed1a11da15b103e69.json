{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Transforms from \"../Core/Transforms.js\";\n\n/**\n * An ellipsoid {@link VoxelShape}.\n *\n * @alias VoxelEllipsoidShape\n * @constructor\n *\n * @see VoxelShape\n * @see VoxelBoxShape\n * @see VoxelCylinderShape\n * @see VoxelShapeType\n *\n * @private\n */\nfunction VoxelEllipsoidShape() {\n  this._orientedBoundingBox = new OrientedBoundingBox();\n  this._boundingSphere = new BoundingSphere();\n  this._boundTransform = new Matrix4();\n  this._shapeTransform = new Matrix4();\n\n  /**\n   * @type {Rectangle}\n   * @private\n   */\n  this._rectangle = new Rectangle();\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._minimumHeight = VoxelEllipsoidShape.DefaultMinBounds.z;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._maximumHeight = VoxelEllipsoidShape.DefaultMaxBounds.z;\n\n  /**\n   * @type {Ellipsoid}\n   * @private\n   */\n  this._ellipsoid = new Ellipsoid();\n\n  /**\n   * @type {Cartesian3}\n   * @private\n   */\n  this._translation = new Cartesian3();\n\n  /**\n   * @type {Matrix3}\n   * @private\n   */\n  this._rotation = new Matrix3();\n  this._shaderUniforms = {\n    cameraPositionCartographic: new Cartesian3(),\n    ellipsoidEcToEastNorthUp: new Matrix3(),\n    ellipsoidRadii: new Cartesian3(),\n    eccentricitySquared: 0.0,\n    evoluteScale: new Cartesian2(),\n    ellipsoidCurvatureAtLatitude: new Cartesian2(),\n    ellipsoidInverseRadiiSquared: new Cartesian3(),\n    ellipsoidRenderLongitudeMinMax: new Cartesian2(),\n    ellipsoidShapeUvLongitudeRangeOrigin: 0.0,\n    ellipsoidShapeUvLongitudeMinMaxMid: new Cartesian3(),\n    ellipsoidLocalToShapeUvLongitude: new Cartesian2(),\n    ellipsoidLocalToShapeUvLatitude: new Cartesian2(),\n    ellipsoidRenderLatitudeSinMinMax: new Cartesian2(),\n    ellipsoidInverseHeightDifference: 0.0,\n    clipMinMaxHeight: new Cartesian2()\n  };\n  this._shaderDefines = {\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_EQUAL_ZERO: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_UNDER_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_OVER_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY: undefined,\n    ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE: undefined,\n    ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_UNDER_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_EQUAL_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_OVER_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_UNDER_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_EQUAL_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_OVER_HALF: undefined,\n    ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE: undefined,\n    ELLIPSOID_INTERSECTION_INDEX_LONGITUDE: undefined,\n    ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX: undefined,\n    ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN: undefined,\n    ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MAX: undefined,\n    ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MIN: undefined\n  };\n  this._shaderMaximumIntersectionsLength = 0; // not known until update\n}\nObject.defineProperties(VoxelEllipsoidShape.prototype, {\n  /**\n   * An oriented bounding box containing the bounded shape.\n   *\n   * @memberof VoxelEllipsoidShape.prototype\n   * @type {OrientedBoundingBox}\n   * @readonly\n   * @private\n   */\n  orientedBoundingBox: {\n    get: function () {\n      return this._orientedBoundingBox;\n    }\n  },\n  /**\n   * A bounding sphere containing the bounded shape.\n   *\n   * @memberof VoxelEllipsoidShape.prototype\n   * @type {BoundingSphere}\n   * @readonly\n   * @private\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    }\n  },\n  /**\n   * A transformation matrix containing the bounded shape.\n   *\n   * @memberof VoxelEllipsoidShape.prototype\n   * @type {Matrix4}\n   * @readonly\n   * @private\n   */\n  boundTransform: {\n    get: function () {\n      return this._boundTransform;\n    }\n  },\n  /**\n   * A transformation matrix containing the shape, ignoring the bounds.\n   *\n   * @memberof VoxelEllipsoidShape.prototype\n   * @type {Matrix4}\n   * @readonly\n   * @private\n   */\n  shapeTransform: {\n    get: function () {\n      return this._shapeTransform;\n    }\n  },\n  /**\n   * @memberof VoxelEllipsoidShape.prototype\n   * @type {Object<string, any>}\n   * @readonly\n   * @private\n   */\n  shaderUniforms: {\n    get: function () {\n      return this._shaderUniforms;\n    }\n  },\n  /**\n   * @memberof VoxelEllipsoidShape.prototype\n   * @type {Object<string, any>}\n   * @readonly\n   * @private\n   */\n  shaderDefines: {\n    get: function () {\n      return this._shaderDefines;\n    }\n  },\n  /**\n   * The maximum number of intersections against the shape for any ray direction.\n   * @memberof VoxelEllipsoidShape.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  shaderMaximumIntersectionsLength: {\n    get: function () {\n      return this._shaderMaximumIntersectionsLength;\n    }\n  }\n});\nconst scratchActualMinBounds = new Cartesian3();\nconst scratchShapeMinBounds = new Cartesian3();\nconst scratchShapeMaxBounds = new Cartesian3();\nconst scratchClipMinBounds = new Cartesian3();\nconst scratchClipMaxBounds = new Cartesian3();\nconst scratchRenderMinBounds = new Cartesian3();\nconst scratchRenderMaxBounds = new Cartesian3();\nconst scratchScale = new Cartesian3();\nconst scratchShapeOuterExtent = new Cartesian3();\nconst scratchRenderOuterExtent = new Cartesian3();\nconst scratchRenderRectangle = new Rectangle();\n\n/**\n * Update the shape's state.\n * @private\n * @param {Matrix4} modelMatrix The model matrix.\n * @param {Cartesian3} minBounds The minimum bounds.\n * @param {Cartesian3} maxBounds The maximum bounds.\n * @param {Cartesian3} [clipMinBounds=VoxelEllipsoidShape.DefaultMinBounds] The minimum clip bounds.\n * @param {Cartesian3} [clipMaxBounds=VoxelEllipsoidShape.DefaultMaxBounds] The maximum clip bounds.\n * @returns {boolean} Whether the shape is visible.\n */\nVoxelEllipsoidShape.prototype.update = function (modelMatrix, minBounds, maxBounds, clipMinBounds, clipMaxBounds) {\n  const {\n    DefaultMinBounds,\n    DefaultMaxBounds\n  } = VoxelEllipsoidShape;\n  clipMinBounds = clipMinBounds ?? DefaultMinBounds;\n  clipMaxBounds = clipMaxBounds ?? DefaultMaxBounds;\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"modelMatrix\", modelMatrix);\n  Check.typeOf.object(\"minBounds\", minBounds);\n  Check.typeOf.object(\"maxBounds\", maxBounds);\n  //>>includeEnd('debug');\n\n  const epsilonZeroScale = CesiumMath.EPSILON10;\n  const epsilonLongitudeDiscontinuity = CesiumMath.EPSILON3; // 0.001 radians = 0.05729578 degrees\n  const epsilonLongitude = CesiumMath.EPSILON10;\n  const epsilonLatitude = CesiumMath.EPSILON10;\n  const epsilonLatitudeFlat = CesiumMath.EPSILON3; // 0.001 radians = 0.05729578 degrees\n\n  // Don't let the height go below the center of the ellipsoid.\n  const radii = Matrix4.getScale(modelMatrix, scratchScale);\n  const actualMinBounds = Cartesian3.clone(DefaultMinBounds, scratchActualMinBounds);\n  actualMinBounds.z = -Cartesian3.minimumComponent(radii);\n  const shapeMinBounds = Cartesian3.clamp(minBounds, actualMinBounds, DefaultMaxBounds, scratchShapeMinBounds);\n  const shapeMaxBounds = Cartesian3.clamp(maxBounds, actualMinBounds, DefaultMaxBounds, scratchShapeMaxBounds);\n  const clampedClipMinBounds = Cartesian3.clamp(clipMinBounds, actualMinBounds, DefaultMaxBounds, scratchClipMinBounds);\n  const clampedClipMaxBounds = Cartesian3.clamp(clipMaxBounds, actualMinBounds, DefaultMaxBounds, scratchClipMaxBounds);\n  const renderMinBounds = Cartesian3.maximumByComponent(shapeMinBounds, clampedClipMinBounds, scratchRenderMinBounds);\n  const renderMaxBounds = Cartesian3.minimumByComponent(shapeMaxBounds, clampedClipMaxBounds, scratchRenderMaxBounds);\n\n  // Compute the farthest a point can be from the center of the ellipsoid.\n  const shapeOuterExtent = Cartesian3.add(radii, Cartesian3.fromElements(shapeMaxBounds.z, shapeMaxBounds.z, shapeMaxBounds.z, scratchShapeOuterExtent), scratchShapeOuterExtent);\n  const renderOuterExtent = Cartesian3.add(radii, Cartesian3.fromElements(renderMaxBounds.z, renderMaxBounds.z, renderMaxBounds.z, scratchRenderOuterExtent), scratchRenderOuterExtent);\n\n  // Exit early if the shape is not visible.\n  // Note that minLongitude may be greater than maxLongitude when crossing the 180th meridian.\n  if (renderMinBounds.y > renderMaxBounds.y || renderMinBounds.y === DefaultMaxBounds.y || renderMaxBounds.y === DefaultMinBounds.y || renderMinBounds.z > renderMaxBounds.z || CesiumMath.equalsEpsilon(renderOuterExtent, Cartesian3.ZERO, undefined, epsilonZeroScale)) {\n    return false;\n  }\n  this._rectangle = Rectangle.fromRadians(shapeMinBounds.x, shapeMinBounds.y, shapeMaxBounds.x, shapeMaxBounds.y);\n  this._translation = Matrix4.getTranslation(modelMatrix, this._translation);\n  this._rotation = Matrix4.getRotation(modelMatrix, this._rotation);\n  this._ellipsoid = Ellipsoid.fromCartesian3(radii, this._ellipsoid);\n  this._minimumHeight = shapeMinBounds.z;\n  this._maximumHeight = shapeMaxBounds.z;\n  const renderRectangle = Rectangle.fromRadians(renderMinBounds.x, renderMinBounds.y, renderMaxBounds.x, renderMaxBounds.y, scratchRenderRectangle);\n  this._orientedBoundingBox = getEllipsoidChunkObb(renderRectangle, renderMinBounds.z, renderMaxBounds.z, this._ellipsoid, this._translation, this._rotation, this._orientedBoundingBox);\n  this._shapeTransform = Matrix4.fromRotationTranslation(this._rotation, this._translation, this._shapeTransform);\n  this._boundTransform = Matrix4.fromRotationTranslation(this._orientedBoundingBox.halfAxes, this._orientedBoundingBox.center, this._boundTransform);\n  this._boundingSphere = BoundingSphere.fromOrientedBoundingBox(this._orientedBoundingBox, this._boundingSphere);\n\n  // Longitude\n  const defaultLongitudeRange = DefaultMaxBounds.x - DefaultMinBounds.x;\n  const defaultLongitudeRangeHalf = 0.5 * defaultLongitudeRange;\n  const renderIsLongitudeReversed = renderMaxBounds.x < renderMinBounds.x;\n  const renderLongitudeRange = renderMaxBounds.x - renderMinBounds.x + renderIsLongitudeReversed * defaultLongitudeRange;\n  const renderIsLongitudeRangeZero = renderLongitudeRange <= epsilonLongitude;\n  const renderIsLongitudeRangeUnderHalf = renderLongitudeRange >= defaultLongitudeRangeHalf - epsilonLongitude && renderLongitudeRange < defaultLongitudeRange - epsilonLongitude;\n  const renderIsLongitudeRangeOverHalf = renderLongitudeRange > epsilonLongitude && renderLongitudeRange < defaultLongitudeRangeHalf - epsilonLongitude;\n  const renderHasLongitude = renderIsLongitudeRangeZero || renderIsLongitudeRangeUnderHalf || renderIsLongitudeRangeOverHalf;\n  const shapeIsLongitudeReversed = shapeMaxBounds.x < shapeMinBounds.x;\n  const shapeLongitudeRange = shapeMaxBounds.x - shapeMinBounds.x + shapeIsLongitudeReversed * defaultLongitudeRange;\n  const shapeIsLongitudeRangeUnderHalf = shapeLongitudeRange > defaultLongitudeRangeHalf + epsilonLongitude && shapeLongitudeRange < defaultLongitudeRange - epsilonLongitude;\n  const shapeIsLongitudeRangeHalf = shapeLongitudeRange >= defaultLongitudeRangeHalf - epsilonLongitude && shapeLongitudeRange <= defaultLongitudeRangeHalf + epsilonLongitude;\n  const shapeIsLongitudeRangeOverHalf = shapeLongitudeRange < defaultLongitudeRangeHalf - epsilonLongitude;\n  const shapeHasLongitude = shapeIsLongitudeRangeUnderHalf || shapeIsLongitudeRangeHalf || shapeIsLongitudeRangeOverHalf;\n\n  // Latitude\n  const renderIsLatitudeMaxUnderHalf = renderMaxBounds.y < -epsilonLatitudeFlat;\n  const renderIsLatitudeMaxHalf = renderMaxBounds.y >= -epsilonLatitudeFlat && renderMaxBounds.y <= +epsilonLatitudeFlat;\n  const renderIsLatitudeMaxOverHalf = renderMaxBounds.y > +epsilonLatitudeFlat && renderMaxBounds.y < DefaultMaxBounds.y - epsilonLatitude;\n  const renderHasLatitudeMax = renderIsLatitudeMaxUnderHalf || renderIsLatitudeMaxHalf || renderIsLatitudeMaxOverHalf;\n  const renderIsLatitudeMinUnderHalf = renderMinBounds.y > DefaultMinBounds.y + epsilonLatitude && renderMinBounds.y < -epsilonLatitudeFlat;\n  const renderIsLatitudeMinHalf = renderMinBounds.y >= -epsilonLatitudeFlat && renderMinBounds.y <= +epsilonLatitudeFlat;\n  const renderIsLatitudeMinOverHalf = renderMinBounds.y > +epsilonLatitudeFlat;\n  const renderHasLatitudeMin = renderIsLatitudeMinUnderHalf || renderIsLatitudeMinHalf || renderIsLatitudeMinOverHalf;\n  const renderHasLatitude = renderHasLatitudeMax || renderHasLatitudeMin;\n  const shapeLatitudeRange = shapeMaxBounds.y - shapeMinBounds.y;\n  const shapeIsLatitudeMaxUnderHalf = shapeMaxBounds.y < -epsilonLatitudeFlat;\n  const shapeIsLatitudeMaxHalf = shapeMaxBounds.y >= -epsilonLatitudeFlat && shapeMaxBounds.y <= +epsilonLatitudeFlat;\n  const shapeIsLatitudeMaxOverHalf = shapeMaxBounds.y > +epsilonLatitudeFlat && shapeMaxBounds.y < DefaultMaxBounds.y - epsilonLatitude;\n  const shapeHasLatitudeMax = shapeIsLatitudeMaxUnderHalf || shapeIsLatitudeMaxHalf || shapeIsLatitudeMaxOverHalf;\n  const shapeIsLatitudeMinUnderHalf = shapeMinBounds.y > DefaultMinBounds.y + epsilonLatitude && shapeMinBounds.y < -epsilonLatitudeFlat;\n  const shapeIsLatitudeMinHalf = shapeMinBounds.y >= -epsilonLatitudeFlat && shapeMinBounds.y <= +epsilonLatitudeFlat;\n  const shapeIsLatitudeMinOverHalf = shapeMinBounds.y > +epsilonLatitudeFlat;\n  const shapeHasLatitudeMin = shapeIsLatitudeMinUnderHalf || shapeIsLatitudeMinHalf || shapeIsLatitudeMinOverHalf;\n  const shapeHasLatitude = shapeHasLatitudeMax || shapeHasLatitudeMin;\n  const shaderUniforms = this._shaderUniforms;\n  const shaderDefines = this._shaderDefines;\n\n  // To keep things simple, clear the defines every time\n  for (const key in shaderDefines) {\n    if (shaderDefines.hasOwnProperty(key)) {\n      shaderDefines[key] = undefined;\n    }\n  }\n  shaderUniforms.ellipsoidRadii = Cartesian3.clone(shapeOuterExtent, shaderUniforms.ellipsoidRadii);\n  const {\n    x: radiiX,\n    z: radiiZ\n  } = shaderUniforms.ellipsoidRadii;\n  const axisRatio = radiiZ / radiiX;\n  shaderUniforms.eccentricitySquared = 1.0 - axisRatio * axisRatio;\n  shaderUniforms.evoluteScale = Cartesian2.fromElements((radiiX * radiiX - radiiZ * radiiZ) / radiiX, (radiiZ * radiiZ - radiiX * radiiX) / radiiZ, shaderUniforms.evoluteScale);\n\n  // Used to compute geodetic surface normal.\n  shaderUniforms.ellipsoidInverseRadiiSquared = Cartesian3.divideComponents(Cartesian3.ONE, Cartesian3.multiplyComponents(shaderUniforms.ellipsoidRadii, shaderUniforms.ellipsoidRadii, shaderUniforms.ellipsoidInverseRadiiSquared), shaderUniforms.ellipsoidInverseRadiiSquared);\n\n  // Keep track of how many intersections there are going to be.\n  let intersectionCount = 0;\n\n  // Intersects outer and inner ellipsoid for the max and min height.\n  shaderDefines[\"ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MAX\"] = intersectionCount;\n  intersectionCount += 1;\n  shaderDefines[\"ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MIN\"] = intersectionCount;\n  intersectionCount += 1;\n  shaderUniforms.clipMinMaxHeight = Cartesian2.fromElements(renderMinBounds.z - shapeMaxBounds.z, renderMaxBounds.z - shapeMaxBounds.z, shaderUniforms.clipMinMaxHeight);\n\n  // The percent of space that is between the inner and outer ellipsoid.\n  const thickness = shapeMaxBounds.z - shapeMinBounds.z;\n  shaderUniforms.ellipsoidInverseHeightDifference = 1.0 / thickness;\n  if (shapeMinBounds.z === shapeMaxBounds.z) {\n    shaderUniforms.ellipsoidInverseHeightDifference = 0.0;\n  }\n\n  // Intersects a wedge for the min and max longitude.\n  if (renderHasLongitude) {\n    shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE\"] = true;\n    shaderDefines[\"ELLIPSOID_INTERSECTION_INDEX_LONGITUDE\"] = intersectionCount;\n    if (renderIsLongitudeRangeUnderHalf) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_UNDER_HALF\"] = true;\n      intersectionCount += 1;\n    } else if (renderIsLongitudeRangeOverHalf) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_OVER_HALF\"] = true;\n      intersectionCount += 2;\n    } else if (renderIsLongitudeRangeZero) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_EQUAL_ZERO\"] = true;\n      intersectionCount += 2;\n    }\n    shaderUniforms.ellipsoidRenderLongitudeMinMax = Cartesian2.fromElements(renderMinBounds.x, renderMaxBounds.x, shaderUniforms.ellipsoidRenderLongitudeMinMax);\n  }\n  if (shapeHasLongitude) {\n    shaderDefines[\"ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE\"] = true;\n    const uvShapeMinLongitude = (shapeMinBounds.x - DefaultMinBounds.x) / defaultLongitudeRange;\n    const uvShapeMaxLongitude = (shapeMaxBounds.x - DefaultMinBounds.x) / defaultLongitudeRange;\n    const uvLongitudeRangeZero = 1.0 - shapeLongitudeRange / defaultLongitudeRange;\n    // Translate the origin of UV angles (in [0,1]) to the center of the unoccupied space\n    const uvLongitudeRangeOrigin = (uvShapeMaxLongitude + 0.5 * uvLongitudeRangeZero) % 1.0;\n    shaderUniforms.ellipsoidShapeUvLongitudeRangeOrigin = uvLongitudeRangeOrigin;\n    const shapeIsLongitudeReversed = shapeMaxBounds.x < shapeMinBounds.x;\n    if (shapeIsLongitudeReversed) {\n      shaderDefines[\"ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED\"] = true;\n    }\n    if (shapeLongitudeRange <= epsilonLongitude) {\n      shaderUniforms.ellipsoidLocalToShapeUvLongitude = Cartesian2.fromElements(0.0, 1.0, shaderUniforms.ellipsoidLocalToShapeUvLongitude);\n    } else {\n      const scale = defaultLongitudeRange / shapeLongitudeRange;\n      const shiftedMinLongitude = uvShapeMinLongitude - uvLongitudeRangeOrigin;\n      const offset = -scale * (shiftedMinLongitude - Math.floor(shiftedMinLongitude));\n      shaderUniforms.ellipsoidLocalToShapeUvLongitude = Cartesian2.fromElements(scale, offset, shaderUniforms.ellipsoidLocalToShapeUvLongitude);\n    }\n  }\n  if (renderHasLongitude) {\n    const renderIsMinLongitudeDiscontinuity = CesiumMath.equalsEpsilon(renderMinBounds.x, DefaultMinBounds.x, undefined, epsilonLongitudeDiscontinuity);\n    const renderIsMaxLongitudeDiscontinuity = CesiumMath.equalsEpsilon(renderMaxBounds.x, DefaultMaxBounds.x, undefined, epsilonLongitudeDiscontinuity);\n    if (renderIsMinLongitudeDiscontinuity) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY\"] = true;\n    }\n    if (renderIsMaxLongitudeDiscontinuity) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY\"] = true;\n    }\n    const uvShapeMinLongitude = (shapeMinBounds.x - DefaultMinBounds.x) / defaultLongitudeRange;\n    const uvShapeMaxLongitude = (shapeMaxBounds.x - DefaultMinBounds.x) / defaultLongitudeRange;\n    const uvRenderMaxLongitude = (renderMaxBounds.x - DefaultMinBounds.x) / defaultLongitudeRange;\n    const uvRenderLongitudeRangeZero = 1.0 - renderLongitudeRange / defaultLongitudeRange;\n    const uvRenderLongitudeRangeZeroMid = (uvRenderMaxLongitude + 0.5 * uvRenderLongitudeRangeZero) % 1.0;\n    shaderUniforms.ellipsoidShapeUvLongitudeMinMaxMid = Cartesian3.fromElements(uvShapeMinLongitude, uvShapeMaxLongitude, uvRenderLongitudeRangeZeroMid, shaderUniforms.ellipsoidShapeUvLongitudeMinMaxMid);\n  }\n  if (renderHasLatitude) {\n    // Intersects a cone for min latitude\n    if (renderHasLatitudeMin) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN\"] = true;\n      shaderDefines[\"ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN\"] = intersectionCount;\n      if (renderIsLatitudeMinUnderHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_UNDER_HALF\"] = true;\n        intersectionCount += 1;\n      } else if (renderIsLatitudeMinHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_EQUAL_HALF\"] = true;\n        intersectionCount += 1;\n      } else if (renderIsLatitudeMinOverHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_OVER_HALF\"] = true;\n        intersectionCount += 2;\n      }\n    }\n\n    // Intersects a cone for max latitude\n    if (renderHasLatitudeMax) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX\"] = true;\n      shaderDefines[\"ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX\"] = intersectionCount;\n      if (renderIsLatitudeMaxUnderHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_UNDER_HALF\"] = true;\n        intersectionCount += 2;\n      } else if (renderIsLatitudeMaxHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_EQUAL_HALF\"] = true;\n        intersectionCount += 1;\n      } else if (renderIsLatitudeMaxOverHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_OVER_HALF\"] = true;\n        intersectionCount += 1;\n      }\n    }\n    shaderUniforms.ellipsoidRenderLatitudeSinMinMax = Cartesian2.fromElements(Math.sin(renderMinBounds.y), Math.sin(renderMaxBounds.y), shaderUniforms.ellipsoidRenderLatitudeSinMinMax);\n  }\n  if (shapeHasLatitude) {\n    shaderDefines[\"ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE\"] = true;\n    if (shapeLatitudeRange < epsilonLatitude) {\n      shaderUniforms.ellipsoidLocalToShapeUvLatitude = Cartesian2.fromElements(0.0, 1.0, shaderUniforms.ellipsoidLocalToShapeUvLatitude);\n    } else {\n      const defaultLatitudeRange = DefaultMaxBounds.y - DefaultMinBounds.y;\n      const scale = defaultLatitudeRange / shapeLatitudeRange;\n      const offset = (DefaultMinBounds.y - shapeMinBounds.y) / shapeLatitudeRange;\n      shaderUniforms.ellipsoidLocalToShapeUvLatitude = Cartesian2.fromElements(scale, offset, shaderUniforms.ellipsoidLocalToShapeUvLatitude);\n    }\n  }\n  this._shaderMaximumIntersectionsLength = intersectionCount;\n  return true;\n};\nconst scratchCameraPositionCartographic = new Cartographic();\nconst surfacePositionScratch = new Cartesian3();\nconst enuTransformScratch = new Matrix4();\nconst enuRotationScratch = new Matrix3();\n/**\n * Update any view-dependent transforms.\n * @private\n * @param {FrameState} frameState The frame state.\n */\nVoxelEllipsoidShape.prototype.updateViewTransforms = function (frameState) {\n  const shaderUniforms = this._shaderUniforms;\n  const ellipsoid = this._ellipsoid;\n  // TODO: incorporate modelMatrix or shapeTransform here?\n  const cameraWC = frameState.camera.positionWC;\n  const cameraPositionCartographic = ellipsoid.cartesianToCartographic(cameraWC, scratchCameraPositionCartographic);\n  Cartesian3.fromElements(cameraPositionCartographic.longitude, cameraPositionCartographic.latitude, cameraPositionCartographic.height, shaderUniforms.cameraPositionCartographic);\n\n  // TODO: incorporate modelMatrix here?\n  const surfacePosition = Cartesian3.fromRadians(cameraPositionCartographic.longitude, cameraPositionCartographic.latitude, 0.0, ellipsoid, surfacePositionScratch);\n  shaderUniforms.ellipsoidCurvatureAtLatitude = ellipsoid.getLocalCurvature(surfacePosition, shaderUniforms.ellipsoidCurvatureAtLatitude);\n  const enuToWorld = Transforms.eastNorthUpToFixedFrame(surfacePosition, ellipsoid, enuTransformScratch);\n  const rotateEnuToWorld = Matrix4.getRotation(enuToWorld, enuRotationScratch);\n  const rotateWorldToView = frameState.context.uniformState.viewRotation;\n  const rotateEnuToView = Matrix3.multiply(rotateWorldToView, rotateEnuToWorld, enuRotationScratch);\n  // Inverse is the transpose since it's a pure rotation.\n  shaderUniforms.ellipsoidEcToEastNorthUp = Matrix3.transpose(rotateEnuToView, shaderUniforms.ellipsoidEcToEastNorthUp);\n};\nconst scratchRectangle = new Rectangle();\n\n/**\n * Computes an oriented bounding box for a specified tile.\n * @private\n * @param {number} tileLevel The tile's level.\n * @param {number} tileX The tile's x coordinate.\n * @param {number} tileY The tile's y coordinate.\n * @param {number} tileZ The tile's z coordinate.\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified tile\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelEllipsoidShape.prototype.computeOrientedBoundingBoxForTile = function (tileLevel, tileX, tileY, tileZ, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"tileLevel\", tileLevel);\n  Check.typeOf.number(\"tileX\", tileX);\n  Check.typeOf.number(\"tileY\", tileY);\n  Check.typeOf.number(\"tileZ\", tileZ);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const sizeAtLevel = 1.0 / Math.pow(2.0, tileLevel);\n  const minLongitudeLerp = tileX * sizeAtLevel;\n  const maxLongitudeLerp = (tileX + 1) * sizeAtLevel;\n  const minLatitudeLerp = tileY * sizeAtLevel;\n  const maxLatitudeLerp = (tileY + 1) * sizeAtLevel;\n  const minHeightLerp = tileZ * sizeAtLevel;\n  const maxHeightLerp = (tileZ + 1) * sizeAtLevel;\n  const rectangle = Rectangle.subsection(this._rectangle, minLongitudeLerp, minLatitudeLerp, maxLongitudeLerp, maxLatitudeLerp, scratchRectangle);\n  const minHeight = CesiumMath.lerp(this._minimumHeight, this._maximumHeight, minHeightLerp);\n  const maxHeight = CesiumMath.lerp(this._minimumHeight, this._maximumHeight, maxHeightLerp);\n  return getEllipsoidChunkObb(rectangle, minHeight, maxHeight, this._ellipsoid, this._translation, this._rotation, result);\n};\nconst scratchQuadrantPosition = new Cartesian2();\nconst scratchInverseRadii = new Cartesian2();\nconst scratchEllipseTrigs = new Cartesian2();\nconst scratchEllipseGuess = new Cartesian2();\nconst scratchEvolute = new Cartesian2();\nconst scratchQ = new Cartesian2();\n\n/**\n * Find the nearest point on an ellipse and its radius.\n * @param {Cartesian2} position\n * @param {Cartesian2} radii\n * @param {Cartesian2} evoluteScale\n * @param {Cartesian3} result The Cartesian3 to store the result in. .x and .y components contain the nearest point on the ellipse, .z contains the local radius of curvature.\n * @returns {Cartesian3} The nearest point on the ellipse and its radius.\n * @private\n */\nfunction nearestPointAndRadiusOnEllipse(position, radii, evoluteScale, result) {\n  // Map to the first quadrant\n  const p = Cartesian2.abs(position, scratchQuadrantPosition);\n  const inverseRadii = Cartesian2.fromElements(1.0 / radii.x, 1.0 / radii.y, scratchInverseRadii);\n  // We describe the ellipse parametrically: v = radii * vec2(cos(t), sin(t))\n  // but store the cos and sin of t in a vec2 for efficiency.\n  // Initial guess: t = pi/4\n  let tTrigs = Cartesian2.fromElements(Math.SQRT1_2, Math.SQRT1_2, scratchEllipseTrigs);\n  // TODO: too much duplication. Move v and evolute declarations inside loop?\n  // Initial guess of point on ellipsoid\n  let v = Cartesian2.multiplyComponents(radii, tTrigs, scratchEllipseGuess);\n  // Center of curvature of the ellipse at v\n  let evolute = Cartesian2.fromElements(evoluteScale.x * tTrigs.x * tTrigs.x * tTrigs.x, evoluteScale.y * tTrigs.y * tTrigs.y * tTrigs.y, scratchEvolute);\n  for (let i = 0; i < 3; ++i) {\n    // Find the (approximate) intersection of p - evolute with the ellipsoid.\n    const distance = Cartesian2.magnitude(Cartesian2.subtract(v, evolute, scratchQ));\n    const direction = Cartesian2.normalize(Cartesian2.subtract(p, evolute, scratchQ), scratchQ);\n    const q = Cartesian2.multiplyByScalar(direction, distance, scratchQ);\n    // Update the estimate of t\n    tTrigs = Cartesian2.multiplyComponents(Cartesian2.add(q, evolute, scratchEllipseTrigs), inverseRadii, scratchEllipseTrigs);\n    tTrigs = Cartesian2.normalize(Cartesian2.clamp(tTrigs, Cartesian2.ZERO, Cartesian2.ONE, scratchEllipseTrigs), scratchEllipseTrigs);\n    v = Cartesian2.multiplyComponents(radii, tTrigs, scratchEllipseGuess);\n    evolute = Cartesian2.fromElements(evoluteScale.x * tTrigs.x * tTrigs.x * tTrigs.x, evoluteScale.y * tTrigs.y * tTrigs.y * tTrigs.y, scratchEvolute);\n  }\n\n  // Map back to the original quadrant\n  return Cartesian3.fromElements(Math.sign(position.x) * v.x, Math.sign(position.y) * v.y, Cartesian2.magnitude(Cartesian2.subtract(v, evolute, scratchQ)), result);\n}\nconst scratchEllipseRadii = new Cartesian2();\nconst scratchEllipsePosition = new Cartesian2();\nconst scratchSurfacePointAndRadius = new Cartesian3();\nconst scratchNormal2d = new Cartesian2();\n/**\n * Convert a UV coordinate to the shape's UV space.\n * @private\n * @param {Cartesian3} positionLocal The local position to convert.\n * @param {Cartesian3} result The Cartesian3 to store the result in.\n * @returns {Cartesian3} The converted UV coordinate.\n */\nVoxelEllipsoidShape.prototype.convertLocalToShapeUvSpace = function (positionLocal, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"positionLocal\", positionLocal);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  let longitude = Math.atan2(positionLocal.y, positionLocal.x);\n  const {\n    ellipsoidRadii,\n    evoluteScale,\n    ellipsoidInverseRadiiSquared,\n    ellipsoidInverseHeightDifference,\n    ellipsoidShapeUvLongitudeRangeOrigin,\n    ellipsoidLocalToShapeUvLongitude,\n    ellipsoidLocalToShapeUvLatitude\n  } = this._shaderUniforms;\n  const distanceFromZAxis = Math.hypot(positionLocal.x, positionLocal.y);\n  const posEllipse = Cartesian2.fromElements(distanceFromZAxis, positionLocal.z, scratchEllipsePosition);\n  const surfacePointAndRadius = nearestPointAndRadiusOnEllipse(posEllipse, Cartesian2.fromElements(ellipsoidRadii.x, ellipsoidRadii.z, scratchEllipseRadii), evoluteScale, scratchSurfacePointAndRadius);\n  const normal2d = Cartesian2.normalize(Cartesian2.fromElements(surfacePointAndRadius.x * ellipsoidInverseRadiiSquared.x, surfacePointAndRadius.y * ellipsoidInverseRadiiSquared.z, scratchNormal2d), scratchNormal2d);\n  let latitude = Math.atan2(normal2d.y, normal2d.x);\n  const heightSign = Cartesian2.magnitude(posEllipse) < Cartesian2.magnitude(surfacePointAndRadius) ? -1.0 : 1.0;\n  const heightVector = Cartesian2.subtract(posEllipse, surfacePointAndRadius, scratchEllipsePosition);\n  let height = heightSign * Cartesian2.magnitude(heightVector);\n  const {\n    ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE,\n    ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE\n  } = this._shaderDefines;\n  longitude = (longitude + Math.PI) / (2.0 * Math.PI);\n  if (defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE)) {\n    longitude -= ellipsoidShapeUvLongitudeRangeOrigin;\n    longitude = longitude - Math.floor(longitude);\n    // Scale and shift so [0, 1] covers the occupied space.\n    longitude = longitude * ellipsoidLocalToShapeUvLongitude.x + ellipsoidLocalToShapeUvLongitude.y;\n  }\n  latitude = (latitude + Math.PI / 2.0) / Math.PI;\n  if (defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE)) {\n    // Scale and shift so [0, 1] covers the occupied space.\n    latitude = latitude * ellipsoidLocalToShapeUvLatitude.x + ellipsoidLocalToShapeUvLatitude.y;\n  }\n  height = 1.0 + height * ellipsoidInverseHeightDifference;\n  return Cartesian3.fromElements(longitude, latitude, height, result);\n};\nconst sampleSizeScratch = new Cartesian3();\nconst scratchTileMinBounds = new Cartesian3();\nconst scratchTileMaxBounds = new Cartesian3();\n\n/**\n * Computes an oriented bounding box for a specified sample within a specified tile.\n * @private\n * @param {SpatialNode} spatialNode The spatial node containing the sample\n * @param {Cartesian3} tileDimensions The size of the tile in number of samples, before padding\n * @param {Cartesian3} tileUv The sample coordinate within the tile\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified sample\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelEllipsoidShape.prototype.computeOrientedBoundingBoxForSample = function (spatialNode, tileDimensions, tileUv, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"spatialNode\", spatialNode);\n  Check.typeOf.object(\"tileDimensions\", tileDimensions);\n  Check.typeOf.object(\"tileUv\", tileUv);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const tileSizeAtLevel = 1.0 / Math.pow(2.0, spatialNode.level);\n  const sampleSize = Cartesian3.divideComponents(Cartesian3.ONE, tileDimensions, sampleSizeScratch);\n  const sampleSizeAtLevel = Cartesian3.multiplyByScalar(sampleSize, tileSizeAtLevel, sampleSizeScratch);\n  const minLerp = Cartesian3.multiplyByScalar(Cartesian3.fromElements(spatialNode.x + tileUv.x, spatialNode.y + tileUv.y, spatialNode.z + tileUv.z, scratchTileMinBounds), tileSizeAtLevel, scratchTileMinBounds);\n  const maxLerp = Cartesian3.add(minLerp, sampleSizeAtLevel, scratchTileMaxBounds);\n  const rectangle = Rectangle.subsection(this._rectangle, minLerp.x, minLerp.y, maxLerp.x, maxLerp.y, scratchRectangle);\n  const minHeight = CesiumMath.lerp(this._minimumHeight, this._maximumHeight, minLerp.z);\n  const maxHeight = CesiumMath.lerp(this._minimumHeight, this._maximumHeight, maxLerp.z);\n  return getEllipsoidChunkObb(rectangle, minHeight, maxHeight, this._ellipsoid, this._translation, this._rotation, result);\n};\n\n/**\n * Computes an {@link OrientedBoundingBox} for a subregion of the shape.\n *\n * @function\n *\n * @param {Rectangle} rectangle The rectangle.\n * @param {number} minHeight The minimumZ.\n * @param {number} maxHeight The maximumZ.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @param {Cartesian3} translation The translation applied to the shape\n * @param {Matrix3} rotation The rotation applied to the shape\n * @param {OrientedBoundingBox} result The object onto which to store the result.\n * @returns {OrientedBoundingBox} The oriented bounding box that contains this subregion.\n *\n * @private\n */\nfunction getEllipsoidChunkObb(rectangle, minHeight, maxHeight, ellipsoid, translation, rotation, result) {\n  result = OrientedBoundingBox.fromRectangle(rectangle, minHeight, maxHeight, ellipsoid, result);\n  result.center = Cartesian3.add(result.center, translation, result.center);\n  result.halfAxes = Matrix3.multiply(result.halfAxes, rotation, result.halfAxes);\n  return result;\n}\n\n/**\n * Defines the minimum bounds of the shape. Corresponds to minimum longitude, latitude, height.\n * @private\n * @type {Cartesian3}\n * @constant\n * @readonly\n */\nVoxelEllipsoidShape.DefaultMinBounds = Object.freeze(new Cartesian3(-CesiumMath.PI, -CesiumMath.PI_OVER_TWO, -Ellipsoid.WGS84.minimumRadius));\n\n/**\n * Defines the maximum bounds of the shape. Corresponds to maximum longitude, latitude, height.\n * @private\n * @type {Cartesian3}\n * @constant\n * @readonly\n */\nVoxelEllipsoidShape.DefaultMaxBounds = Object.freeze(new Cartesian3(CesiumMath.PI, CesiumMath.PI_OVER_TWO, 10.0 * Ellipsoid.WGS84.maximumRadius));\nexport default VoxelEllipsoidShape;","map":{"version":3,"names":["defined","BoundingSphere","Cartesian2","Cartesian3","Cartographic","Check","Ellipsoid","CesiumMath","Matrix3","Matrix4","OrientedBoundingBox","Rectangle","Transforms","VoxelEllipsoidShape","_orientedBoundingBox","_boundingSphere","_boundTransform","_shapeTransform","_rectangle","_minimumHeight","DefaultMinBounds","z","_maximumHeight","DefaultMaxBounds","_ellipsoid","_translation","_rotation","_shaderUniforms","cameraPositionCartographic","ellipsoidEcToEastNorthUp","ellipsoidRadii","eccentricitySquared","evoluteScale","ellipsoidCurvatureAtLatitude","ellipsoidInverseRadiiSquared","ellipsoidRenderLongitudeMinMax","ellipsoidShapeUvLongitudeRangeOrigin","ellipsoidShapeUvLongitudeMinMaxMid","ellipsoidLocalToShapeUvLongitude","ellipsoidLocalToShapeUvLatitude","ellipsoidRenderLatitudeSinMinMax","ellipsoidInverseHeightDifference","clipMinMaxHeight","_shaderDefines","ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE","undefined","ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_EQUAL_ZERO","ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_UNDER_HALF","ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_OVER_HALF","ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY","ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY","ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE","ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED","ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_UNDER_HALF","ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_EQUAL_HALF","ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_OVER_HALF","ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_UNDER_HALF","ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_EQUAL_HALF","ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_OVER_HALF","ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE","ELLIPSOID_INTERSECTION_INDEX_LONGITUDE","ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX","ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN","ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MAX","ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MIN","_shaderMaximumIntersectionsLength","Object","defineProperties","prototype","orientedBoundingBox","get","boundingSphere","boundTransform","shapeTransform","shaderUniforms","shaderDefines","shaderMaximumIntersectionsLength","scratchActualMinBounds","scratchShapeMinBounds","scratchShapeMaxBounds","scratchClipMinBounds","scratchClipMaxBounds","scratchRenderMinBounds","scratchRenderMaxBounds","scratchScale","scratchShapeOuterExtent","scratchRenderOuterExtent","scratchRenderRectangle","update","modelMatrix","minBounds","maxBounds","clipMinBounds","clipMaxBounds","typeOf","object","epsilonZeroScale","EPSILON10","epsilonLongitudeDiscontinuity","EPSILON3","epsilonLongitude","epsilonLatitude","epsilonLatitudeFlat","radii","getScale","actualMinBounds","clone","minimumComponent","shapeMinBounds","clamp","shapeMaxBounds","clampedClipMinBounds","clampedClipMaxBounds","renderMinBounds","maximumByComponent","renderMaxBounds","minimumByComponent","shapeOuterExtent","add","fromElements","renderOuterExtent","y","equalsEpsilon","ZERO","fromRadians","x","getTranslation","getRotation","fromCartesian3","renderRectangle","getEllipsoidChunkObb","fromRotationTranslation","halfAxes","center","fromOrientedBoundingBox","defaultLongitudeRange","defaultLongitudeRangeHalf","renderIsLongitudeReversed","renderLongitudeRange","renderIsLongitudeRangeZero","renderIsLongitudeRangeUnderHalf","renderIsLongitudeRangeOverHalf","renderHasLongitude","shapeIsLongitudeReversed","shapeLongitudeRange","shapeIsLongitudeRangeUnderHalf","shapeIsLongitudeRangeHalf","shapeIsLongitudeRangeOverHalf","shapeHasLongitude","renderIsLatitudeMaxUnderHalf","renderIsLatitudeMaxHalf","renderIsLatitudeMaxOverHalf","renderHasLatitudeMax","renderIsLatitudeMinUnderHalf","renderIsLatitudeMinHalf","renderIsLatitudeMinOverHalf","renderHasLatitudeMin","renderHasLatitude","shapeLatitudeRange","shapeIsLatitudeMaxUnderHalf","shapeIsLatitudeMaxHalf","shapeIsLatitudeMaxOverHalf","shapeHasLatitudeMax","shapeIsLatitudeMinUnderHalf","shapeIsLatitudeMinHalf","shapeIsLatitudeMinOverHalf","shapeHasLatitudeMin","shapeHasLatitude","key","hasOwnProperty","radiiX","radiiZ","axisRatio","divideComponents","ONE","multiplyComponents","intersectionCount","thickness","uvShapeMinLongitude","uvShapeMaxLongitude","uvLongitudeRangeZero","uvLongitudeRangeOrigin","scale","shiftedMinLongitude","offset","Math","floor","renderIsMinLongitudeDiscontinuity","renderIsMaxLongitudeDiscontinuity","uvRenderMaxLongitude","uvRenderLongitudeRangeZero","uvRenderLongitudeRangeZeroMid","sin","defaultLatitudeRange","scratchCameraPositionCartographic","surfacePositionScratch","enuTransformScratch","enuRotationScratch","updateViewTransforms","frameState","ellipsoid","cameraWC","camera","positionWC","cartesianToCartographic","longitude","latitude","height","surfacePosition","getLocalCurvature","enuToWorld","eastNorthUpToFixedFrame","rotateEnuToWorld","rotateWorldToView","context","uniformState","viewRotation","rotateEnuToView","multiply","transpose","scratchRectangle","computeOrientedBoundingBoxForTile","tileLevel","tileX","tileY","tileZ","result","number","sizeAtLevel","pow","minLongitudeLerp","maxLongitudeLerp","minLatitudeLerp","maxLatitudeLerp","minHeightLerp","maxHeightLerp","rectangle","subsection","minHeight","lerp","maxHeight","scratchQuadrantPosition","scratchInverseRadii","scratchEllipseTrigs","scratchEllipseGuess","scratchEvolute","scratchQ","nearestPointAndRadiusOnEllipse","position","p","abs","inverseRadii","tTrigs","SQRT1_2","v","evolute","i","distance","magnitude","subtract","direction","normalize","q","multiplyByScalar","sign","scratchEllipseRadii","scratchEllipsePosition","scratchSurfacePointAndRadius","scratchNormal2d","convertLocalToShapeUvSpace","positionLocal","atan2","distanceFromZAxis","hypot","posEllipse","surfacePointAndRadius","normal2d","heightSign","heightVector","PI","sampleSizeScratch","scratchTileMinBounds","scratchTileMaxBounds","computeOrientedBoundingBoxForSample","spatialNode","tileDimensions","tileUv","tileSizeAtLevel","level","sampleSize","sampleSizeAtLevel","minLerp","maxLerp","translation","rotation","fromRectangle","freeze","PI_OVER_TWO","WGS84","minimumRadius","maximumRadius"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/VoxelEllipsoidShape.js"],"sourcesContent":["import defined from \"../Core/defined.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Transforms from \"../Core/Transforms.js\";\n\n/**\n * An ellipsoid {@link VoxelShape}.\n *\n * @alias VoxelEllipsoidShape\n * @constructor\n *\n * @see VoxelShape\n * @see VoxelBoxShape\n * @see VoxelCylinderShape\n * @see VoxelShapeType\n *\n * @private\n */\nfunction VoxelEllipsoidShape() {\n  this._orientedBoundingBox = new OrientedBoundingBox();\n  this._boundingSphere = new BoundingSphere();\n  this._boundTransform = new Matrix4();\n  this._shapeTransform = new Matrix4();\n\n  /**\n   * @type {Rectangle}\n   * @private\n   */\n  this._rectangle = new Rectangle();\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._minimumHeight = VoxelEllipsoidShape.DefaultMinBounds.z;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._maximumHeight = VoxelEllipsoidShape.DefaultMaxBounds.z;\n\n  /**\n   * @type {Ellipsoid}\n   * @private\n   */\n  this._ellipsoid = new Ellipsoid();\n\n  /**\n   * @type {Cartesian3}\n   * @private\n   */\n  this._translation = new Cartesian3();\n\n  /**\n   * @type {Matrix3}\n   * @private\n   */\n  this._rotation = new Matrix3();\n\n  this._shaderUniforms = {\n    cameraPositionCartographic: new Cartesian3(),\n    ellipsoidEcToEastNorthUp: new Matrix3(),\n    ellipsoidRadii: new Cartesian3(),\n    eccentricitySquared: 0.0,\n    evoluteScale: new Cartesian2(),\n    ellipsoidCurvatureAtLatitude: new Cartesian2(),\n    ellipsoidInverseRadiiSquared: new Cartesian3(),\n    ellipsoidRenderLongitudeMinMax: new Cartesian2(),\n    ellipsoidShapeUvLongitudeRangeOrigin: 0.0,\n    ellipsoidShapeUvLongitudeMinMaxMid: new Cartesian3(),\n    ellipsoidLocalToShapeUvLongitude: new Cartesian2(),\n    ellipsoidLocalToShapeUvLatitude: new Cartesian2(),\n    ellipsoidRenderLatitudeSinMinMax: new Cartesian2(),\n    ellipsoidInverseHeightDifference: 0.0,\n    clipMinMaxHeight: new Cartesian2(),\n  };\n\n  this._shaderDefines = {\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_EQUAL_ZERO: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_UNDER_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_OVER_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY: undefined,\n    ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE: undefined,\n    ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_UNDER_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_EQUAL_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_OVER_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_UNDER_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_EQUAL_HALF: undefined,\n    ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_OVER_HALF: undefined,\n    ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE: undefined,\n    ELLIPSOID_INTERSECTION_INDEX_LONGITUDE: undefined,\n    ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX: undefined,\n    ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN: undefined,\n    ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MAX: undefined,\n    ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MIN: undefined,\n  };\n\n  this._shaderMaximumIntersectionsLength = 0; // not known until update\n}\n\nObject.defineProperties(VoxelEllipsoidShape.prototype, {\n  /**\n   * An oriented bounding box containing the bounded shape.\n   *\n   * @memberof VoxelEllipsoidShape.prototype\n   * @type {OrientedBoundingBox}\n   * @readonly\n   * @private\n   */\n  orientedBoundingBox: {\n    get: function () {\n      return this._orientedBoundingBox;\n    },\n  },\n\n  /**\n   * A bounding sphere containing the bounded shape.\n   *\n   * @memberof VoxelEllipsoidShape.prototype\n   * @type {BoundingSphere}\n   * @readonly\n   * @private\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    },\n  },\n\n  /**\n   * A transformation matrix containing the bounded shape.\n   *\n   * @memberof VoxelEllipsoidShape.prototype\n   * @type {Matrix4}\n   * @readonly\n   * @private\n   */\n  boundTransform: {\n    get: function () {\n      return this._boundTransform;\n    },\n  },\n\n  /**\n   * A transformation matrix containing the shape, ignoring the bounds.\n   *\n   * @memberof VoxelEllipsoidShape.prototype\n   * @type {Matrix4}\n   * @readonly\n   * @private\n   */\n  shapeTransform: {\n    get: function () {\n      return this._shapeTransform;\n    },\n  },\n\n  /**\n   * @memberof VoxelEllipsoidShape.prototype\n   * @type {Object<string, any>}\n   * @readonly\n   * @private\n   */\n  shaderUniforms: {\n    get: function () {\n      return this._shaderUniforms;\n    },\n  },\n\n  /**\n   * @memberof VoxelEllipsoidShape.prototype\n   * @type {Object<string, any>}\n   * @readonly\n   * @private\n   */\n  shaderDefines: {\n    get: function () {\n      return this._shaderDefines;\n    },\n  },\n\n  /**\n   * The maximum number of intersections against the shape for any ray direction.\n   * @memberof VoxelEllipsoidShape.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  shaderMaximumIntersectionsLength: {\n    get: function () {\n      return this._shaderMaximumIntersectionsLength;\n    },\n  },\n});\n\nconst scratchActualMinBounds = new Cartesian3();\nconst scratchShapeMinBounds = new Cartesian3();\nconst scratchShapeMaxBounds = new Cartesian3();\nconst scratchClipMinBounds = new Cartesian3();\nconst scratchClipMaxBounds = new Cartesian3();\nconst scratchRenderMinBounds = new Cartesian3();\nconst scratchRenderMaxBounds = new Cartesian3();\nconst scratchScale = new Cartesian3();\nconst scratchShapeOuterExtent = new Cartesian3();\nconst scratchRenderOuterExtent = new Cartesian3();\nconst scratchRenderRectangle = new Rectangle();\n\n/**\n * Update the shape's state.\n * @private\n * @param {Matrix4} modelMatrix The model matrix.\n * @param {Cartesian3} minBounds The minimum bounds.\n * @param {Cartesian3} maxBounds The maximum bounds.\n * @param {Cartesian3} [clipMinBounds=VoxelEllipsoidShape.DefaultMinBounds] The minimum clip bounds.\n * @param {Cartesian3} [clipMaxBounds=VoxelEllipsoidShape.DefaultMaxBounds] The maximum clip bounds.\n * @returns {boolean} Whether the shape is visible.\n */\nVoxelEllipsoidShape.prototype.update = function (\n  modelMatrix,\n  minBounds,\n  maxBounds,\n  clipMinBounds,\n  clipMaxBounds,\n) {\n  const { DefaultMinBounds, DefaultMaxBounds } = VoxelEllipsoidShape;\n  clipMinBounds = clipMinBounds ?? DefaultMinBounds;\n  clipMaxBounds = clipMaxBounds ?? DefaultMaxBounds;\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"modelMatrix\", modelMatrix);\n  Check.typeOf.object(\"minBounds\", minBounds);\n  Check.typeOf.object(\"maxBounds\", maxBounds);\n  //>>includeEnd('debug');\n\n  const epsilonZeroScale = CesiumMath.EPSILON10;\n  const epsilonLongitudeDiscontinuity = CesiumMath.EPSILON3; // 0.001 radians = 0.05729578 degrees\n  const epsilonLongitude = CesiumMath.EPSILON10;\n  const epsilonLatitude = CesiumMath.EPSILON10;\n  const epsilonLatitudeFlat = CesiumMath.EPSILON3; // 0.001 radians = 0.05729578 degrees\n\n  // Don't let the height go below the center of the ellipsoid.\n  const radii = Matrix4.getScale(modelMatrix, scratchScale);\n  const actualMinBounds = Cartesian3.clone(\n    DefaultMinBounds,\n    scratchActualMinBounds,\n  );\n  actualMinBounds.z = -Cartesian3.minimumComponent(radii);\n\n  const shapeMinBounds = Cartesian3.clamp(\n    minBounds,\n    actualMinBounds,\n    DefaultMaxBounds,\n    scratchShapeMinBounds,\n  );\n  const shapeMaxBounds = Cartesian3.clamp(\n    maxBounds,\n    actualMinBounds,\n    DefaultMaxBounds,\n    scratchShapeMaxBounds,\n  );\n  const clampedClipMinBounds = Cartesian3.clamp(\n    clipMinBounds,\n    actualMinBounds,\n    DefaultMaxBounds,\n    scratchClipMinBounds,\n  );\n  const clampedClipMaxBounds = Cartesian3.clamp(\n    clipMaxBounds,\n    actualMinBounds,\n    DefaultMaxBounds,\n    scratchClipMaxBounds,\n  );\n  const renderMinBounds = Cartesian3.maximumByComponent(\n    shapeMinBounds,\n    clampedClipMinBounds,\n    scratchRenderMinBounds,\n  );\n  const renderMaxBounds = Cartesian3.minimumByComponent(\n    shapeMaxBounds,\n    clampedClipMaxBounds,\n    scratchRenderMaxBounds,\n  );\n\n  // Compute the farthest a point can be from the center of the ellipsoid.\n  const shapeOuterExtent = Cartesian3.add(\n    radii,\n    Cartesian3.fromElements(\n      shapeMaxBounds.z,\n      shapeMaxBounds.z,\n      shapeMaxBounds.z,\n      scratchShapeOuterExtent,\n    ),\n    scratchShapeOuterExtent,\n  );\n\n  const renderOuterExtent = Cartesian3.add(\n    radii,\n    Cartesian3.fromElements(\n      renderMaxBounds.z,\n      renderMaxBounds.z,\n      renderMaxBounds.z,\n      scratchRenderOuterExtent,\n    ),\n    scratchRenderOuterExtent,\n  );\n\n  // Exit early if the shape is not visible.\n  // Note that minLongitude may be greater than maxLongitude when crossing the 180th meridian.\n  if (\n    renderMinBounds.y > renderMaxBounds.y ||\n    renderMinBounds.y === DefaultMaxBounds.y ||\n    renderMaxBounds.y === DefaultMinBounds.y ||\n    renderMinBounds.z > renderMaxBounds.z ||\n    CesiumMath.equalsEpsilon(\n      renderOuterExtent,\n      Cartesian3.ZERO,\n      undefined,\n      epsilonZeroScale,\n    )\n  ) {\n    return false;\n  }\n\n  this._rectangle = Rectangle.fromRadians(\n    shapeMinBounds.x,\n    shapeMinBounds.y,\n    shapeMaxBounds.x,\n    shapeMaxBounds.y,\n  );\n  this._translation = Matrix4.getTranslation(modelMatrix, this._translation);\n  this._rotation = Matrix4.getRotation(modelMatrix, this._rotation);\n  this._ellipsoid = Ellipsoid.fromCartesian3(radii, this._ellipsoid);\n  this._minimumHeight = shapeMinBounds.z;\n  this._maximumHeight = shapeMaxBounds.z;\n\n  const renderRectangle = Rectangle.fromRadians(\n    renderMinBounds.x,\n    renderMinBounds.y,\n    renderMaxBounds.x,\n    renderMaxBounds.y,\n    scratchRenderRectangle,\n  );\n\n  this._orientedBoundingBox = getEllipsoidChunkObb(\n    renderRectangle,\n    renderMinBounds.z,\n    renderMaxBounds.z,\n    this._ellipsoid,\n    this._translation,\n    this._rotation,\n    this._orientedBoundingBox,\n  );\n\n  this._shapeTransform = Matrix4.fromRotationTranslation(\n    this._rotation,\n    this._translation,\n    this._shapeTransform,\n  );\n\n  this._boundTransform = Matrix4.fromRotationTranslation(\n    this._orientedBoundingBox.halfAxes,\n    this._orientedBoundingBox.center,\n    this._boundTransform,\n  );\n\n  this._boundingSphere = BoundingSphere.fromOrientedBoundingBox(\n    this._orientedBoundingBox,\n    this._boundingSphere,\n  );\n\n  // Longitude\n  const defaultLongitudeRange = DefaultMaxBounds.x - DefaultMinBounds.x;\n  const defaultLongitudeRangeHalf = 0.5 * defaultLongitudeRange;\n  const renderIsLongitudeReversed = renderMaxBounds.x < renderMinBounds.x;\n  const renderLongitudeRange =\n    renderMaxBounds.x -\n    renderMinBounds.x +\n    renderIsLongitudeReversed * defaultLongitudeRange;\n  const renderIsLongitudeRangeZero = renderLongitudeRange <= epsilonLongitude;\n  const renderIsLongitudeRangeUnderHalf =\n    renderLongitudeRange >= defaultLongitudeRangeHalf - epsilonLongitude &&\n    renderLongitudeRange < defaultLongitudeRange - epsilonLongitude;\n  const renderIsLongitudeRangeOverHalf =\n    renderLongitudeRange > epsilonLongitude &&\n    renderLongitudeRange < defaultLongitudeRangeHalf - epsilonLongitude;\n  const renderHasLongitude =\n    renderIsLongitudeRangeZero ||\n    renderIsLongitudeRangeUnderHalf ||\n    renderIsLongitudeRangeOverHalf;\n\n  const shapeIsLongitudeReversed = shapeMaxBounds.x < shapeMinBounds.x;\n  const shapeLongitudeRange =\n    shapeMaxBounds.x -\n    shapeMinBounds.x +\n    shapeIsLongitudeReversed * defaultLongitudeRange;\n  const shapeIsLongitudeRangeUnderHalf =\n    shapeLongitudeRange > defaultLongitudeRangeHalf + epsilonLongitude &&\n    shapeLongitudeRange < defaultLongitudeRange - epsilonLongitude;\n  const shapeIsLongitudeRangeHalf =\n    shapeLongitudeRange >= defaultLongitudeRangeHalf - epsilonLongitude &&\n    shapeLongitudeRange <= defaultLongitudeRangeHalf + epsilonLongitude;\n  const shapeIsLongitudeRangeOverHalf =\n    shapeLongitudeRange < defaultLongitudeRangeHalf - epsilonLongitude;\n  const shapeHasLongitude =\n    shapeIsLongitudeRangeUnderHalf ||\n    shapeIsLongitudeRangeHalf ||\n    shapeIsLongitudeRangeOverHalf;\n\n  // Latitude\n  const renderIsLatitudeMaxUnderHalf = renderMaxBounds.y < -epsilonLatitudeFlat;\n  const renderIsLatitudeMaxHalf =\n    renderMaxBounds.y >= -epsilonLatitudeFlat &&\n    renderMaxBounds.y <= +epsilonLatitudeFlat;\n  const renderIsLatitudeMaxOverHalf =\n    renderMaxBounds.y > +epsilonLatitudeFlat &&\n    renderMaxBounds.y < DefaultMaxBounds.y - epsilonLatitude;\n  const renderHasLatitudeMax =\n    renderIsLatitudeMaxUnderHalf ||\n    renderIsLatitudeMaxHalf ||\n    renderIsLatitudeMaxOverHalf;\n  const renderIsLatitudeMinUnderHalf =\n    renderMinBounds.y > DefaultMinBounds.y + epsilonLatitude &&\n    renderMinBounds.y < -epsilonLatitudeFlat;\n  const renderIsLatitudeMinHalf =\n    renderMinBounds.y >= -epsilonLatitudeFlat &&\n    renderMinBounds.y <= +epsilonLatitudeFlat;\n  const renderIsLatitudeMinOverHalf = renderMinBounds.y > +epsilonLatitudeFlat;\n  const renderHasLatitudeMin =\n    renderIsLatitudeMinUnderHalf ||\n    renderIsLatitudeMinHalf ||\n    renderIsLatitudeMinOverHalf;\n  const renderHasLatitude = renderHasLatitudeMax || renderHasLatitudeMin;\n\n  const shapeLatitudeRange = shapeMaxBounds.y - shapeMinBounds.y;\n  const shapeIsLatitudeMaxUnderHalf = shapeMaxBounds.y < -epsilonLatitudeFlat;\n  const shapeIsLatitudeMaxHalf =\n    shapeMaxBounds.y >= -epsilonLatitudeFlat &&\n    shapeMaxBounds.y <= +epsilonLatitudeFlat;\n  const shapeIsLatitudeMaxOverHalf =\n    shapeMaxBounds.y > +epsilonLatitudeFlat &&\n    shapeMaxBounds.y < DefaultMaxBounds.y - epsilonLatitude;\n  const shapeHasLatitudeMax =\n    shapeIsLatitudeMaxUnderHalf ||\n    shapeIsLatitudeMaxHalf ||\n    shapeIsLatitudeMaxOverHalf;\n  const shapeIsLatitudeMinUnderHalf =\n    shapeMinBounds.y > DefaultMinBounds.y + epsilonLatitude &&\n    shapeMinBounds.y < -epsilonLatitudeFlat;\n  const shapeIsLatitudeMinHalf =\n    shapeMinBounds.y >= -epsilonLatitudeFlat &&\n    shapeMinBounds.y <= +epsilonLatitudeFlat;\n  const shapeIsLatitudeMinOverHalf = shapeMinBounds.y > +epsilonLatitudeFlat;\n  const shapeHasLatitudeMin =\n    shapeIsLatitudeMinUnderHalf ||\n    shapeIsLatitudeMinHalf ||\n    shapeIsLatitudeMinOverHalf;\n  const shapeHasLatitude = shapeHasLatitudeMax || shapeHasLatitudeMin;\n\n  const shaderUniforms = this._shaderUniforms;\n  const shaderDefines = this._shaderDefines;\n\n  // To keep things simple, clear the defines every time\n  for (const key in shaderDefines) {\n    if (shaderDefines.hasOwnProperty(key)) {\n      shaderDefines[key] = undefined;\n    }\n  }\n\n  shaderUniforms.ellipsoidRadii = Cartesian3.clone(\n    shapeOuterExtent,\n    shaderUniforms.ellipsoidRadii,\n  );\n  const { x: radiiX, z: radiiZ } = shaderUniforms.ellipsoidRadii;\n  const axisRatio = radiiZ / radiiX;\n  shaderUniforms.eccentricitySquared = 1.0 - axisRatio * axisRatio;\n  shaderUniforms.evoluteScale = Cartesian2.fromElements(\n    (radiiX * radiiX - radiiZ * radiiZ) / radiiX,\n    (radiiZ * radiiZ - radiiX * radiiX) / radiiZ,\n    shaderUniforms.evoluteScale,\n  );\n\n  // Used to compute geodetic surface normal.\n  shaderUniforms.ellipsoidInverseRadiiSquared = Cartesian3.divideComponents(\n    Cartesian3.ONE,\n    Cartesian3.multiplyComponents(\n      shaderUniforms.ellipsoidRadii,\n      shaderUniforms.ellipsoidRadii,\n      shaderUniforms.ellipsoidInverseRadiiSquared,\n    ),\n    shaderUniforms.ellipsoidInverseRadiiSquared,\n  );\n\n  // Keep track of how many intersections there are going to be.\n  let intersectionCount = 0;\n\n  // Intersects outer and inner ellipsoid for the max and min height.\n  shaderDefines[\"ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MAX\"] = intersectionCount;\n  intersectionCount += 1;\n  shaderDefines[\"ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MIN\"] = intersectionCount;\n  intersectionCount += 1;\n\n  shaderUniforms.clipMinMaxHeight = Cartesian2.fromElements(\n    renderMinBounds.z - shapeMaxBounds.z,\n    renderMaxBounds.z - shapeMaxBounds.z,\n    shaderUniforms.clipMinMaxHeight,\n  );\n\n  // The percent of space that is between the inner and outer ellipsoid.\n  const thickness = shapeMaxBounds.z - shapeMinBounds.z;\n  shaderUniforms.ellipsoidInverseHeightDifference = 1.0 / thickness;\n  if (shapeMinBounds.z === shapeMaxBounds.z) {\n    shaderUniforms.ellipsoidInverseHeightDifference = 0.0;\n  }\n\n  // Intersects a wedge for the min and max longitude.\n  if (renderHasLongitude) {\n    shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE\"] = true;\n    shaderDefines[\"ELLIPSOID_INTERSECTION_INDEX_LONGITUDE\"] = intersectionCount;\n\n    if (renderIsLongitudeRangeUnderHalf) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_UNDER_HALF\"] =\n        true;\n      intersectionCount += 1;\n    } else if (renderIsLongitudeRangeOverHalf) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_OVER_HALF\"] =\n        true;\n      intersectionCount += 2;\n    } else if (renderIsLongitudeRangeZero) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_EQUAL_ZERO\"] =\n        true;\n      intersectionCount += 2;\n    }\n\n    shaderUniforms.ellipsoidRenderLongitudeMinMax = Cartesian2.fromElements(\n      renderMinBounds.x,\n      renderMaxBounds.x,\n      shaderUniforms.ellipsoidRenderLongitudeMinMax,\n    );\n  }\n\n  if (shapeHasLongitude) {\n    shaderDefines[\"ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE\"] = true;\n\n    const uvShapeMinLongitude =\n      (shapeMinBounds.x - DefaultMinBounds.x) / defaultLongitudeRange;\n    const uvShapeMaxLongitude =\n      (shapeMaxBounds.x - DefaultMinBounds.x) / defaultLongitudeRange;\n    const uvLongitudeRangeZero =\n      1.0 - shapeLongitudeRange / defaultLongitudeRange;\n    // Translate the origin of UV angles (in [0,1]) to the center of the unoccupied space\n    const uvLongitudeRangeOrigin =\n      (uvShapeMaxLongitude + 0.5 * uvLongitudeRangeZero) % 1.0;\n    shaderUniforms.ellipsoidShapeUvLongitudeRangeOrigin =\n      uvLongitudeRangeOrigin;\n\n    const shapeIsLongitudeReversed = shapeMaxBounds.x < shapeMinBounds.x;\n    if (shapeIsLongitudeReversed) {\n      shaderDefines[\"ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED\"] =\n        true;\n    }\n\n    if (shapeLongitudeRange <= epsilonLongitude) {\n      shaderUniforms.ellipsoidLocalToShapeUvLongitude = Cartesian2.fromElements(\n        0.0,\n        1.0,\n        shaderUniforms.ellipsoidLocalToShapeUvLongitude,\n      );\n    } else {\n      const scale = defaultLongitudeRange / shapeLongitudeRange;\n      const shiftedMinLongitude = uvShapeMinLongitude - uvLongitudeRangeOrigin;\n      const offset =\n        -scale * (shiftedMinLongitude - Math.floor(shiftedMinLongitude));\n      shaderUniforms.ellipsoidLocalToShapeUvLongitude = Cartesian2.fromElements(\n        scale,\n        offset,\n        shaderUniforms.ellipsoidLocalToShapeUvLongitude,\n      );\n    }\n  }\n\n  if (renderHasLongitude) {\n    const renderIsMinLongitudeDiscontinuity = CesiumMath.equalsEpsilon(\n      renderMinBounds.x,\n      DefaultMinBounds.x,\n      undefined,\n      epsilonLongitudeDiscontinuity,\n    );\n    const renderIsMaxLongitudeDiscontinuity = CesiumMath.equalsEpsilon(\n      renderMaxBounds.x,\n      DefaultMaxBounds.x,\n      undefined,\n      epsilonLongitudeDiscontinuity,\n    );\n\n    if (renderIsMinLongitudeDiscontinuity) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY\"] =\n        true;\n    }\n    if (renderIsMaxLongitudeDiscontinuity) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY\"] =\n        true;\n    }\n    const uvShapeMinLongitude =\n      (shapeMinBounds.x - DefaultMinBounds.x) / defaultLongitudeRange;\n    const uvShapeMaxLongitude =\n      (shapeMaxBounds.x - DefaultMinBounds.x) / defaultLongitudeRange;\n\n    const uvRenderMaxLongitude =\n      (renderMaxBounds.x - DefaultMinBounds.x) / defaultLongitudeRange;\n    const uvRenderLongitudeRangeZero =\n      1.0 - renderLongitudeRange / defaultLongitudeRange;\n    const uvRenderLongitudeRangeZeroMid =\n      (uvRenderMaxLongitude + 0.5 * uvRenderLongitudeRangeZero) % 1.0;\n\n    shaderUniforms.ellipsoidShapeUvLongitudeMinMaxMid = Cartesian3.fromElements(\n      uvShapeMinLongitude,\n      uvShapeMaxLongitude,\n      uvRenderLongitudeRangeZeroMid,\n      shaderUniforms.ellipsoidShapeUvLongitudeMinMaxMid,\n    );\n  }\n\n  if (renderHasLatitude) {\n    // Intersects a cone for min latitude\n    if (renderHasLatitudeMin) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN\"] = true;\n      shaderDefines[\"ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN\"] =\n        intersectionCount;\n\n      if (renderIsLatitudeMinUnderHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_UNDER_HALF\"] =\n          true;\n        intersectionCount += 1;\n      } else if (renderIsLatitudeMinHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_EQUAL_HALF\"] =\n          true;\n        intersectionCount += 1;\n      } else if (renderIsLatitudeMinOverHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_OVER_HALF\"] =\n          true;\n        intersectionCount += 2;\n      }\n    }\n\n    // Intersects a cone for max latitude\n    if (renderHasLatitudeMax) {\n      shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX\"] = true;\n      shaderDefines[\"ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX\"] =\n        intersectionCount;\n\n      if (renderIsLatitudeMaxUnderHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_UNDER_HALF\"] =\n          true;\n        intersectionCount += 2;\n      } else if (renderIsLatitudeMaxHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_EQUAL_HALF\"] =\n          true;\n        intersectionCount += 1;\n      } else if (renderIsLatitudeMaxOverHalf) {\n        shaderDefines[\"ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_OVER_HALF\"] =\n          true;\n        intersectionCount += 1;\n      }\n    }\n\n    shaderUniforms.ellipsoidRenderLatitudeSinMinMax = Cartesian2.fromElements(\n      Math.sin(renderMinBounds.y),\n      Math.sin(renderMaxBounds.y),\n      shaderUniforms.ellipsoidRenderLatitudeSinMinMax,\n    );\n  }\n\n  if (shapeHasLatitude) {\n    shaderDefines[\"ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE\"] = true;\n\n    if (shapeLatitudeRange < epsilonLatitude) {\n      shaderUniforms.ellipsoidLocalToShapeUvLatitude = Cartesian2.fromElements(\n        0.0,\n        1.0,\n        shaderUniforms.ellipsoidLocalToShapeUvLatitude,\n      );\n    } else {\n      const defaultLatitudeRange = DefaultMaxBounds.y - DefaultMinBounds.y;\n      const scale = defaultLatitudeRange / shapeLatitudeRange;\n      const offset =\n        (DefaultMinBounds.y - shapeMinBounds.y) / shapeLatitudeRange;\n      shaderUniforms.ellipsoidLocalToShapeUvLatitude = Cartesian2.fromElements(\n        scale,\n        offset,\n        shaderUniforms.ellipsoidLocalToShapeUvLatitude,\n      );\n    }\n  }\n\n  this._shaderMaximumIntersectionsLength = intersectionCount;\n\n  return true;\n};\n\nconst scratchCameraPositionCartographic = new Cartographic();\nconst surfacePositionScratch = new Cartesian3();\nconst enuTransformScratch = new Matrix4();\nconst enuRotationScratch = new Matrix3();\n/**\n * Update any view-dependent transforms.\n * @private\n * @param {FrameState} frameState The frame state.\n */\nVoxelEllipsoidShape.prototype.updateViewTransforms = function (frameState) {\n  const shaderUniforms = this._shaderUniforms;\n  const ellipsoid = this._ellipsoid;\n  // TODO: incorporate modelMatrix or shapeTransform here?\n  const cameraWC = frameState.camera.positionWC;\n  const cameraPositionCartographic = ellipsoid.cartesianToCartographic(\n    cameraWC,\n    scratchCameraPositionCartographic,\n  );\n  Cartesian3.fromElements(\n    cameraPositionCartographic.longitude,\n    cameraPositionCartographic.latitude,\n    cameraPositionCartographic.height,\n    shaderUniforms.cameraPositionCartographic,\n  );\n\n  // TODO: incorporate modelMatrix here?\n  const surfacePosition = Cartesian3.fromRadians(\n    cameraPositionCartographic.longitude,\n    cameraPositionCartographic.latitude,\n    0.0,\n    ellipsoid,\n    surfacePositionScratch,\n  );\n\n  shaderUniforms.ellipsoidCurvatureAtLatitude = ellipsoid.getLocalCurvature(\n    surfacePosition,\n    shaderUniforms.ellipsoidCurvatureAtLatitude,\n  );\n\n  const enuToWorld = Transforms.eastNorthUpToFixedFrame(\n    surfacePosition,\n    ellipsoid,\n    enuTransformScratch,\n  );\n  const rotateEnuToWorld = Matrix4.getRotation(enuToWorld, enuRotationScratch);\n  const rotateWorldToView = frameState.context.uniformState.viewRotation;\n  const rotateEnuToView = Matrix3.multiply(\n    rotateWorldToView,\n    rotateEnuToWorld,\n    enuRotationScratch,\n  );\n  // Inverse is the transpose since it's a pure rotation.\n  shaderUniforms.ellipsoidEcToEastNorthUp = Matrix3.transpose(\n    rotateEnuToView,\n    shaderUniforms.ellipsoidEcToEastNorthUp,\n  );\n};\n\nconst scratchRectangle = new Rectangle();\n\n/**\n * Computes an oriented bounding box for a specified tile.\n * @private\n * @param {number} tileLevel The tile's level.\n * @param {number} tileX The tile's x coordinate.\n * @param {number} tileY The tile's y coordinate.\n * @param {number} tileZ The tile's z coordinate.\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified tile\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelEllipsoidShape.prototype.computeOrientedBoundingBoxForTile = function (\n  tileLevel,\n  tileX,\n  tileY,\n  tileZ,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"tileLevel\", tileLevel);\n  Check.typeOf.number(\"tileX\", tileX);\n  Check.typeOf.number(\"tileY\", tileY);\n  Check.typeOf.number(\"tileZ\", tileZ);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const sizeAtLevel = 1.0 / Math.pow(2.0, tileLevel);\n  const minLongitudeLerp = tileX * sizeAtLevel;\n  const maxLongitudeLerp = (tileX + 1) * sizeAtLevel;\n  const minLatitudeLerp = tileY * sizeAtLevel;\n  const maxLatitudeLerp = (tileY + 1) * sizeAtLevel;\n  const minHeightLerp = tileZ * sizeAtLevel;\n  const maxHeightLerp = (tileZ + 1) * sizeAtLevel;\n\n  const rectangle = Rectangle.subsection(\n    this._rectangle,\n    minLongitudeLerp,\n    minLatitudeLerp,\n    maxLongitudeLerp,\n    maxLatitudeLerp,\n    scratchRectangle,\n  );\n\n  const minHeight = CesiumMath.lerp(\n    this._minimumHeight,\n    this._maximumHeight,\n    minHeightLerp,\n  );\n\n  const maxHeight = CesiumMath.lerp(\n    this._minimumHeight,\n    this._maximumHeight,\n    maxHeightLerp,\n  );\n\n  return getEllipsoidChunkObb(\n    rectangle,\n    minHeight,\n    maxHeight,\n    this._ellipsoid,\n    this._translation,\n    this._rotation,\n    result,\n  );\n};\n\nconst scratchQuadrantPosition = new Cartesian2();\nconst scratchInverseRadii = new Cartesian2();\nconst scratchEllipseTrigs = new Cartesian2();\nconst scratchEllipseGuess = new Cartesian2();\nconst scratchEvolute = new Cartesian2();\nconst scratchQ = new Cartesian2();\n\n/**\n * Find the nearest point on an ellipse and its radius.\n * @param {Cartesian2} position\n * @param {Cartesian2} radii\n * @param {Cartesian2} evoluteScale\n * @param {Cartesian3} result The Cartesian3 to store the result in. .x and .y components contain the nearest point on the ellipse, .z contains the local radius of curvature.\n * @returns {Cartesian3} The nearest point on the ellipse and its radius.\n * @private\n */\nfunction nearestPointAndRadiusOnEllipse(position, radii, evoluteScale, result) {\n  // Map to the first quadrant\n  const p = Cartesian2.abs(position, scratchQuadrantPosition);\n  const inverseRadii = Cartesian2.fromElements(\n    1.0 / radii.x,\n    1.0 / radii.y,\n    scratchInverseRadii,\n  );\n  // We describe the ellipse parametrically: v = radii * vec2(cos(t), sin(t))\n  // but store the cos and sin of t in a vec2 for efficiency.\n  // Initial guess: t = pi/4\n  let tTrigs = Cartesian2.fromElements(\n    Math.SQRT1_2,\n    Math.SQRT1_2,\n    scratchEllipseTrigs,\n  );\n  // TODO: too much duplication. Move v and evolute declarations inside loop?\n  // Initial guess of point on ellipsoid\n  let v = Cartesian2.multiplyComponents(radii, tTrigs, scratchEllipseGuess);\n  // Center of curvature of the ellipse at v\n  let evolute = Cartesian2.fromElements(\n    evoluteScale.x * tTrigs.x * tTrigs.x * tTrigs.x,\n    evoluteScale.y * tTrigs.y * tTrigs.y * tTrigs.y,\n    scratchEvolute,\n  );\n  for (let i = 0; i < 3; ++i) {\n    // Find the (approximate) intersection of p - evolute with the ellipsoid.\n    const distance = Cartesian2.magnitude(\n      Cartesian2.subtract(v, evolute, scratchQ),\n    );\n    const direction = Cartesian2.normalize(\n      Cartesian2.subtract(p, evolute, scratchQ),\n      scratchQ,\n    );\n    const q = Cartesian2.multiplyByScalar(direction, distance, scratchQ);\n    // Update the estimate of t\n    tTrigs = Cartesian2.multiplyComponents(\n      Cartesian2.add(q, evolute, scratchEllipseTrigs),\n      inverseRadii,\n      scratchEllipseTrigs,\n    );\n    tTrigs = Cartesian2.normalize(\n      Cartesian2.clamp(\n        tTrigs,\n        Cartesian2.ZERO,\n        Cartesian2.ONE,\n        scratchEllipseTrigs,\n      ),\n      scratchEllipseTrigs,\n    );\n    v = Cartesian2.multiplyComponents(radii, tTrigs, scratchEllipseGuess);\n    evolute = Cartesian2.fromElements(\n      evoluteScale.x * tTrigs.x * tTrigs.x * tTrigs.x,\n      evoluteScale.y * tTrigs.y * tTrigs.y * tTrigs.y,\n      scratchEvolute,\n    );\n  }\n\n  // Map back to the original quadrant\n  return Cartesian3.fromElements(\n    Math.sign(position.x) * v.x,\n    Math.sign(position.y) * v.y,\n    Cartesian2.magnitude(Cartesian2.subtract(v, evolute, scratchQ)),\n    result,\n  );\n}\n\nconst scratchEllipseRadii = new Cartesian2();\nconst scratchEllipsePosition = new Cartesian2();\nconst scratchSurfacePointAndRadius = new Cartesian3();\nconst scratchNormal2d = new Cartesian2();\n/**\n * Convert a UV coordinate to the shape's UV space.\n * @private\n * @param {Cartesian3} positionLocal The local position to convert.\n * @param {Cartesian3} result The Cartesian3 to store the result in.\n * @returns {Cartesian3} The converted UV coordinate.\n */\nVoxelEllipsoidShape.prototype.convertLocalToShapeUvSpace = function (\n  positionLocal,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"positionLocal\", positionLocal);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  let longitude = Math.atan2(positionLocal.y, positionLocal.x);\n\n  const {\n    ellipsoidRadii,\n    evoluteScale,\n    ellipsoidInverseRadiiSquared,\n    ellipsoidInverseHeightDifference,\n    ellipsoidShapeUvLongitudeRangeOrigin,\n    ellipsoidLocalToShapeUvLongitude,\n    ellipsoidLocalToShapeUvLatitude,\n  } = this._shaderUniforms;\n\n  const distanceFromZAxis = Math.hypot(positionLocal.x, positionLocal.y);\n  const posEllipse = Cartesian2.fromElements(\n    distanceFromZAxis,\n    positionLocal.z,\n    scratchEllipsePosition,\n  );\n  const surfacePointAndRadius = nearestPointAndRadiusOnEllipse(\n    posEllipse,\n    Cartesian2.fromElements(\n      ellipsoidRadii.x,\n      ellipsoidRadii.z,\n      scratchEllipseRadii,\n    ),\n    evoluteScale,\n    scratchSurfacePointAndRadius,\n  );\n\n  const normal2d = Cartesian2.normalize(\n    Cartesian2.fromElements(\n      surfacePointAndRadius.x * ellipsoidInverseRadiiSquared.x,\n      surfacePointAndRadius.y * ellipsoidInverseRadiiSquared.z,\n      scratchNormal2d,\n    ),\n    scratchNormal2d,\n  );\n  let latitude = Math.atan2(normal2d.y, normal2d.x);\n\n  const heightSign =\n    Cartesian2.magnitude(posEllipse) <\n    Cartesian2.magnitude(surfacePointAndRadius)\n      ? -1.0\n      : 1.0;\n  const heightVector = Cartesian2.subtract(\n    posEllipse,\n    surfacePointAndRadius,\n    scratchEllipsePosition,\n  );\n  let height = heightSign * Cartesian2.magnitude(heightVector);\n\n  const {\n    ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE,\n    ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE,\n  } = this._shaderDefines;\n\n  longitude = (longitude + Math.PI) / (2.0 * Math.PI);\n  if (defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE)) {\n    longitude -= ellipsoidShapeUvLongitudeRangeOrigin;\n    longitude = longitude - Math.floor(longitude);\n    // Scale and shift so [0, 1] covers the occupied space.\n    longitude =\n      longitude * ellipsoidLocalToShapeUvLongitude.x +\n      ellipsoidLocalToShapeUvLongitude.y;\n  }\n\n  latitude = (latitude + Math.PI / 2.0) / Math.PI;\n  if (defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE)) {\n    // Scale and shift so [0, 1] covers the occupied space.\n    latitude =\n      latitude * ellipsoidLocalToShapeUvLatitude.x +\n      ellipsoidLocalToShapeUvLatitude.y;\n  }\n\n  height = 1.0 + height * ellipsoidInverseHeightDifference;\n\n  return Cartesian3.fromElements(longitude, latitude, height, result);\n};\n\nconst sampleSizeScratch = new Cartesian3();\nconst scratchTileMinBounds = new Cartesian3();\nconst scratchTileMaxBounds = new Cartesian3();\n\n/**\n * Computes an oriented bounding box for a specified sample within a specified tile.\n * @private\n * @param {SpatialNode} spatialNode The spatial node containing the sample\n * @param {Cartesian3} tileDimensions The size of the tile in number of samples, before padding\n * @param {Cartesian3} tileUv The sample coordinate within the tile\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified sample\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelEllipsoidShape.prototype.computeOrientedBoundingBoxForSample = function (\n  spatialNode,\n  tileDimensions,\n  tileUv,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"spatialNode\", spatialNode);\n  Check.typeOf.object(\"tileDimensions\", tileDimensions);\n  Check.typeOf.object(\"tileUv\", tileUv);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const tileSizeAtLevel = 1.0 / Math.pow(2.0, spatialNode.level);\n  const sampleSize = Cartesian3.divideComponents(\n    Cartesian3.ONE,\n    tileDimensions,\n    sampleSizeScratch,\n  );\n  const sampleSizeAtLevel = Cartesian3.multiplyByScalar(\n    sampleSize,\n    tileSizeAtLevel,\n    sampleSizeScratch,\n  );\n\n  const minLerp = Cartesian3.multiplyByScalar(\n    Cartesian3.fromElements(\n      spatialNode.x + tileUv.x,\n      spatialNode.y + tileUv.y,\n      spatialNode.z + tileUv.z,\n      scratchTileMinBounds,\n    ),\n    tileSizeAtLevel,\n    scratchTileMinBounds,\n  );\n  const maxLerp = Cartesian3.add(\n    minLerp,\n    sampleSizeAtLevel,\n    scratchTileMaxBounds,\n  );\n\n  const rectangle = Rectangle.subsection(\n    this._rectangle,\n    minLerp.x,\n    minLerp.y,\n    maxLerp.x,\n    maxLerp.y,\n    scratchRectangle,\n  );\n  const minHeight = CesiumMath.lerp(\n    this._minimumHeight,\n    this._maximumHeight,\n    minLerp.z,\n  );\n  const maxHeight = CesiumMath.lerp(\n    this._minimumHeight,\n    this._maximumHeight,\n    maxLerp.z,\n  );\n\n  return getEllipsoidChunkObb(\n    rectangle,\n    minHeight,\n    maxHeight,\n    this._ellipsoid,\n    this._translation,\n    this._rotation,\n    result,\n  );\n};\n\n/**\n * Computes an {@link OrientedBoundingBox} for a subregion of the shape.\n *\n * @function\n *\n * @param {Rectangle} rectangle The rectangle.\n * @param {number} minHeight The minimumZ.\n * @param {number} maxHeight The maximumZ.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @param {Cartesian3} translation The translation applied to the shape\n * @param {Matrix3} rotation The rotation applied to the shape\n * @param {OrientedBoundingBox} result The object onto which to store the result.\n * @returns {OrientedBoundingBox} The oriented bounding box that contains this subregion.\n *\n * @private\n */\nfunction getEllipsoidChunkObb(\n  rectangle,\n  minHeight,\n  maxHeight,\n  ellipsoid,\n  translation,\n  rotation,\n  result,\n) {\n  result = OrientedBoundingBox.fromRectangle(\n    rectangle,\n    minHeight,\n    maxHeight,\n    ellipsoid,\n    result,\n  );\n  result.center = Cartesian3.add(result.center, translation, result.center);\n  result.halfAxes = Matrix3.multiply(\n    result.halfAxes,\n    rotation,\n    result.halfAxes,\n  );\n  return result;\n}\n\n/**\n * Defines the minimum bounds of the shape. Corresponds to minimum longitude, latitude, height.\n * @private\n * @type {Cartesian3}\n * @constant\n * @readonly\n */\nVoxelEllipsoidShape.DefaultMinBounds = Object.freeze(\n  new Cartesian3(\n    -CesiumMath.PI,\n    -CesiumMath.PI_OVER_TWO,\n    -Ellipsoid.WGS84.minimumRadius,\n  ),\n);\n\n/**\n * Defines the maximum bounds of the shape. Corresponds to maximum longitude, latitude, height.\n * @private\n * @type {Cartesian3}\n * @constant\n * @readonly\n */\nVoxelEllipsoidShape.DefaultMaxBounds = Object.freeze(\n  new Cartesian3(\n    CesiumMath.PI,\n    CesiumMath.PI_OVER_TWO,\n    10.0 * Ellipsoid.WGS84.maximumRadius,\n  ),\n);\n\nexport default VoxelEllipsoidShape;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}