{"ast":null,"code":"import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EarthOrientationParameters from \"./EarthOrientationParameters.js\";\nimport EarthOrientationParametersSample from \"./EarthOrientationParametersSample.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport HeadingPitchRoll from \"./HeadingPitchRoll.js\";\nimport Iau2006XysData from \"./Iau2006XysData.js\";\nimport Iau2006XysSample from \"./Iau2006XysSample.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport TimeConstants from \"./TimeConstants.js\";\n\n/**\n * Contains functions for transforming positions to various reference frames.\n *\n * @namespace Transforms\n */\nconst Transforms = {};\nconst vectorProductLocalFrame = {\n  up: {\n    south: \"east\",\n    north: \"west\",\n    west: \"south\",\n    east: \"north\"\n  },\n  down: {\n    south: \"west\",\n    north: \"east\",\n    west: \"north\",\n    east: \"south\"\n  },\n  south: {\n    up: \"west\",\n    down: \"east\",\n    west: \"down\",\n    east: \"up\"\n  },\n  north: {\n    up: \"east\",\n    down: \"west\",\n    west: \"up\",\n    east: \"down\"\n  },\n  west: {\n    up: \"north\",\n    down: \"south\",\n    north: \"down\",\n    south: \"up\"\n  },\n  east: {\n    up: \"south\",\n    down: \"north\",\n    north: \"up\",\n    south: \"down\"\n  }\n};\nconst degeneratePositionLocalFrame = {\n  north: [-1, 0, 0],\n  east: [0, 1, 0],\n  up: [0, 0, 1],\n  south: [1, 0, 0],\n  west: [0, -1, 0],\n  down: [0, 0, -1]\n};\nconst localFrameToFixedFrameCache = {};\nconst scratchCalculateCartesian = {\n  east: new Cartesian3(),\n  north: new Cartesian3(),\n  up: new Cartesian3(),\n  west: new Cartesian3(),\n  south: new Cartesian3(),\n  down: new Cartesian3()\n};\nlet scratchFirstCartesian = new Cartesian3();\nlet scratchSecondCartesian = new Cartesian3();\nlet scratchThirdCartesian = new Cartesian3();\n/**\n * Generates a function that computes a 4x4 transformation matrix from a reference frame\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * @param  {string} firstAxis  name of the first axis of the local reference frame. Must be\n *  'east', 'north', 'up', 'west', 'south' or 'down'.\n * @param  {string} secondAxis  name of the second axis of the local reference frame. Must be\n *  'east', 'north', 'up', 'west', 'south' or 'down'.\n * @return {Transforms.LocalFrameToFixedFrame} The function that will computes a\n * 4x4 transformation matrix from a reference frame, with first axis and second axis compliant with the parameters,\n */\nTransforms.localFrameToFixedFrameGenerator = function (firstAxis, secondAxis) {\n  if (!vectorProductLocalFrame.hasOwnProperty(firstAxis) || !vectorProductLocalFrame[firstAxis].hasOwnProperty(secondAxis)) {\n    throw new DeveloperError(\"firstAxis and secondAxis must be east, north, up, west, south or down.\");\n  }\n  const thirdAxis = vectorProductLocalFrame[firstAxis][secondAxis];\n\n  /**\n   * Computes a 4x4 transformation matrix from a reference frame\n   * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n   * @callback Transforms.LocalFrameToFixedFrame\n   * @param {Cartesian3} origin The center point of the local reference frame.\n   * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n   * @param {Matrix4} [result] The object onto which to store the result.\n   * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n   */\n  let resultat;\n  const hashAxis = firstAxis + secondAxis;\n  if (defined(localFrameToFixedFrameCache[hashAxis])) {\n    resultat = localFrameToFixedFrameCache[hashAxis];\n  } else {\n    resultat = function (origin, ellipsoid, result) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(origin)) {\n        throw new DeveloperError(\"origin is required.\");\n      }\n      if (isNaN(origin.x) || isNaN(origin.y) || isNaN(origin.z)) {\n        throw new DeveloperError(\"origin has a NaN component\");\n      }\n      //>>includeEnd('debug');\n      if (!defined(result)) {\n        result = new Matrix4();\n      }\n      if (Cartesian3.equalsEpsilon(origin, Cartesian3.ZERO, CesiumMath.EPSILON14)) {\n        // If x, y, and z are zero, use the degenerate local frame, which is a special case\n        Cartesian3.unpack(degeneratePositionLocalFrame[firstAxis], 0, scratchFirstCartesian);\n        Cartesian3.unpack(degeneratePositionLocalFrame[secondAxis], 0, scratchSecondCartesian);\n        Cartesian3.unpack(degeneratePositionLocalFrame[thirdAxis], 0, scratchThirdCartesian);\n      } else if (CesiumMath.equalsEpsilon(origin.x, 0.0, CesiumMath.EPSILON14) && CesiumMath.equalsEpsilon(origin.y, 0.0, CesiumMath.EPSILON14)) {\n        // If x and y are zero, assume origin is at a pole, which is a special case.\n        const sign = CesiumMath.sign(origin.z);\n        Cartesian3.unpack(degeneratePositionLocalFrame[firstAxis], 0, scratchFirstCartesian);\n        if (firstAxis !== \"east\" && firstAxis !== \"west\") {\n          Cartesian3.multiplyByScalar(scratchFirstCartesian, sign, scratchFirstCartesian);\n        }\n        Cartesian3.unpack(degeneratePositionLocalFrame[secondAxis], 0, scratchSecondCartesian);\n        if (secondAxis !== \"east\" && secondAxis !== \"west\") {\n          Cartesian3.multiplyByScalar(scratchSecondCartesian, sign, scratchSecondCartesian);\n        }\n        Cartesian3.unpack(degeneratePositionLocalFrame[thirdAxis], 0, scratchThirdCartesian);\n        if (thirdAxis !== \"east\" && thirdAxis !== \"west\") {\n          Cartesian3.multiplyByScalar(scratchThirdCartesian, sign, scratchThirdCartesian);\n        }\n      } else {\n        ellipsoid = ellipsoid ?? Ellipsoid.default;\n        ellipsoid.geodeticSurfaceNormal(origin, scratchCalculateCartesian.up);\n        const up = scratchCalculateCartesian.up;\n        const east = scratchCalculateCartesian.east;\n        east.x = -origin.y;\n        east.y = origin.x;\n        east.z = 0.0;\n        Cartesian3.normalize(east, scratchCalculateCartesian.east);\n        Cartesian3.cross(up, east, scratchCalculateCartesian.north);\n        Cartesian3.multiplyByScalar(scratchCalculateCartesian.up, -1, scratchCalculateCartesian.down);\n        Cartesian3.multiplyByScalar(scratchCalculateCartesian.east, -1, scratchCalculateCartesian.west);\n        Cartesian3.multiplyByScalar(scratchCalculateCartesian.north, -1, scratchCalculateCartesian.south);\n        scratchFirstCartesian = scratchCalculateCartesian[firstAxis];\n        scratchSecondCartesian = scratchCalculateCartesian[secondAxis];\n        scratchThirdCartesian = scratchCalculateCartesian[thirdAxis];\n      }\n      result[0] = scratchFirstCartesian.x;\n      result[1] = scratchFirstCartesian.y;\n      result[2] = scratchFirstCartesian.z;\n      result[3] = 0.0;\n      result[4] = scratchSecondCartesian.x;\n      result[5] = scratchSecondCartesian.y;\n      result[6] = scratchSecondCartesian.z;\n      result[7] = 0.0;\n      result[8] = scratchThirdCartesian.x;\n      result[9] = scratchThirdCartesian.y;\n      result[10] = scratchThirdCartesian.z;\n      result[11] = 0.0;\n      result[12] = origin.x;\n      result[13] = origin.y;\n      result[14] = origin.z;\n      result[15] = 1.0;\n      return result;\n    };\n    localFrameToFixedFrameCache[hashAxis] = resultat;\n  }\n  return resultat;\n};\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local east direction.</li>\n * <li>The <code>y</code> axis points in the local north direction.</li>\n * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local east-north-up at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n */\nTransforms.eastNorthUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\"east\", \"north\");\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an north-east-down axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local north direction.</li>\n * <li>The <code>y</code> axis points in the local east direction.</li>\n * <li>The <code>z</code> axis points in the opposite direction of the ellipsoid surface normal which passes through the position.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local north-east-down at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.northEastDownToFixedFrame(center);\n */\nTransforms.northEastDownToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\"north\", \"east\");\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an north-up-east axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local north direction.</li>\n * <li>The <code>y</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n * <li>The <code>z</code> axis points in the local east direction.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local north-up-east at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.northUpEastToFixedFrame(center);\n */\nTransforms.northUpEastToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\"north\", \"up\");\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an north-west-up axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local north direction.</li>\n * <li>The <code>y</code> axis points in the local west direction.</li>\n * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local north-West-Up at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.northWestUpToFixedFrame(center);\n */\nTransforms.northWestUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\"north\", \"west\");\nconst scratchHPRQuaternion = new Quaternion();\nconst scratchScale = new Cartesian3(1.0, 1.0, 1.0);\nconst scratchHPRMatrix4 = new Matrix4();\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with axes computed from the heading-pitch-roll angles\n * centered at the provided origin to the provided ellipsoid's fixed reference frame. Heading is the rotation from the local east\n * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n *\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {HeadingPitchRoll} headingPitchRoll The heading, pitch, and roll.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation\n *  matrix from a reference frame to the provided ellipsoid's fixed reference frame\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const heading = -Cesium.Math.PI_OVER_TWO;\n * const pitch = Cesium.Math.PI_OVER_FOUR;\n * const roll = 0.0;\n * const hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);\n * const transform = Cesium.Transforms.headingPitchRollToFixedFrame(center, hpr);\n */\nTransforms.headingPitchRollToFixedFrame = function (origin, headingPitchRoll, ellipsoid, fixedFrameTransform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"HeadingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  fixedFrameTransform = fixedFrameTransform ?? Transforms.eastNorthUpToFixedFrame;\n  const hprQuaternion = Quaternion.fromHeadingPitchRoll(headingPitchRoll, scratchHPRQuaternion);\n  const hprMatrix = Matrix4.fromTranslationQuaternionRotationScale(Cartesian3.ZERO, hprQuaternion, scratchScale, scratchHPRMatrix4);\n  result = fixedFrameTransform(origin, ellipsoid, result);\n  return Matrix4.multiply(result, hprMatrix, result);\n};\nconst scratchENUMatrix4 = new Matrix4();\nconst scratchHPRMatrix3 = new Matrix3();\n\n/**\n * Computes a quaternion from a reference frame with axes computed from the heading-pitch-roll angles\n * centered at the provided origin. Heading is the rotation from the local east\n * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n *\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {HeadingPitchRoll} headingPitchRoll The heading, pitch, and roll.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation\n *  matrix from a reference frame to the provided ellipsoid's fixed reference frame\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.\n *\n * @example\n * // Get the quaternion from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const heading = -Cesium.Math.PI_OVER_TWO;\n * const pitch = Cesium.Math.PI_OVER_FOUR;\n * const roll = 0.0;\n * const hpr = new HeadingPitchRoll(heading, pitch, roll);\n * const quaternion = Cesium.Transforms.headingPitchRollQuaternion(center, hpr);\n */\nTransforms.headingPitchRollQuaternion = function (origin, headingPitchRoll, ellipsoid, fixedFrameTransform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"HeadingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  const transform = Transforms.headingPitchRollToFixedFrame(origin, headingPitchRoll, ellipsoid, fixedFrameTransform, scratchENUMatrix4);\n  const rotation = Matrix4.getMatrix3(transform, scratchHPRMatrix3);\n  return Quaternion.fromRotationMatrix(rotation, result);\n};\nconst noScale = new Cartesian3(1.0, 1.0, 1.0);\nconst hprCenterScratch = new Cartesian3();\nconst ffScratch = new Matrix4();\nconst hprTransformScratch = new Matrix4();\nconst hprRotationScratch = new Matrix3();\nconst hprQuaternionScratch = new Quaternion();\n/**\n * Computes heading-pitch-roll angles from a transform in a particular reference frame. Heading is the rotation from the local east\n * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n *\n * @param {Matrix4} transform The transform\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation\n *  matrix from a reference frame to the provided ellipsoid's fixed reference frame\n * @param {HeadingPitchRoll} [result] The object onto which to store the result.\n * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if none was provided.\n */\nTransforms.fixedFrameToHeadingPitchRoll = function (transform, ellipsoid, fixedFrameTransform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  ellipsoid = ellipsoid ?? Ellipsoid.default;\n  fixedFrameTransform = fixedFrameTransform ?? Transforms.eastNorthUpToFixedFrame;\n  if (!defined(result)) {\n    result = new HeadingPitchRoll();\n  }\n  const center = Matrix4.getTranslation(transform, hprCenterScratch);\n  if (Cartesian3.equals(center, Cartesian3.ZERO)) {\n    result.heading = 0;\n    result.pitch = 0;\n    result.roll = 0;\n    return result;\n  }\n  let toFixedFrame = Matrix4.inverseTransformation(fixedFrameTransform(center, ellipsoid, ffScratch), ffScratch);\n  let transformCopy = Matrix4.setScale(transform, noScale, hprTransformScratch);\n  transformCopy = Matrix4.setTranslation(transformCopy, Cartesian3.ZERO, transformCopy);\n  toFixedFrame = Matrix4.multiply(toFixedFrame, transformCopy, toFixedFrame);\n  let quaternionRotation = Quaternion.fromRotationMatrix(Matrix4.getMatrix3(toFixedFrame, hprRotationScratch), hprQuaternionScratch);\n  quaternionRotation = Quaternion.normalize(quaternionRotation, quaternionRotation);\n  return HeadingPitchRoll.fromQuaternion(quaternionRotation, result);\n};\nconst gmstConstant0 = 6 * 3600 + 41 * 60 + 50.54841;\nconst gmstConstant1 = 8640184.812866;\nconst gmstConstant2 = 0.093104;\nconst gmstConstant3 = -6.2e-6;\nconst rateCoef = 1.1772758384668e-19;\nconst wgs84WRPrecessing = 7.2921158553e-5;\nconst twoPiOverSecondsInDay = CesiumMath.TWO_PI / 86400.0;\nlet dateInUtc = new JulianDate();\n\n/**\n * The default function to compute a rotation matrix to transform a point or vector from the International Celestial\n * Reference Frame (GCRF/ICRF) inertial frame axes to the central body, typically Earth, fixed frame axis at a given\n * time for use in lighting and transformation from inertial reference frames. This function may return undefined if\n * the data necessary to do the transformation is not yet loaded.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3|undefined} The rotation matrix, or undefined if the data necessary to do the\n *                   transformation is not yet loaded.\n *\n * @example\n * // Set the default ICRF to fixed transformation to that of the Moon.\n * Cesium.Transforms.computeIcrfToCentralBodyFixedMatrix = Cesium.Transforms.computeIcrfToMoonFixedMatrix;\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeTemeToPseudoFixedMatrix\n * @see Transforms.computeIcrfToMoonFixedMatrix\n */\nTransforms.computeIcrfToCentralBodyFixedMatrix = function (date, result) {\n  let transformMatrix = Transforms.computeIcrfToFixedMatrix(date, result);\n  if (!defined(transformMatrix)) {\n    transformMatrix = Transforms.computeTemeToPseudoFixedMatrix(date, result);\n  }\n  return transformMatrix;\n};\n\n/**\n * Computes a rotation matrix to transform a point or vector from True Equator Mean Equinox (TEME) axes to the\n * pseudo-fixed axes at a given time.  This method treats the UT1 time standard as equivalent to UTC.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.\n *\n * @example\n * //Set the view to the inertial frame.\n * scene.postUpdate.addEventListener(function(scene, time) {\n *    const now = Cesium.JulianDate.now();\n *    const offset = Cesium.Matrix4.multiplyByPoint(camera.transform, camera.position, new Cesium.Cartesian3());\n *    const transform = Cesium.Matrix4.fromRotationTranslation(Cesium.Transforms.computeTemeToPseudoFixedMatrix(now));\n *    const inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());\n *    Cesium.Matrix4.multiplyByPoint(inverseTransform, offset, offset);\n *    camera.lookAtTransform(transform, offset);\n * });\n */\nTransforms.computeTemeToPseudoFixedMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // GMST is actually computed using UT1.  We're using UTC as an approximation of UT1.\n  // We do not want to use the function like convertTaiToUtc in JulianDate because\n  // we explicitly do not want to fail when inside the leap second.\n\n  dateInUtc = JulianDate.addSeconds(date, -JulianDate.computeTaiMinusUtc(date), dateInUtc);\n  const utcDayNumber = dateInUtc.dayNumber;\n  const utcSecondsIntoDay = dateInUtc.secondsOfDay;\n  let t;\n  const diffDays = utcDayNumber - 2451545;\n  if (utcSecondsIntoDay >= 43200.0) {\n    t = (diffDays + 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;\n  } else {\n    t = (diffDays - 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;\n  }\n  const gmst0 = gmstConstant0 + t * (gmstConstant1 + t * (gmstConstant2 + t * gmstConstant3));\n  const angle = gmst0 * twoPiOverSecondsInDay % CesiumMath.TWO_PI;\n  const ratio = wgs84WRPrecessing + rateCoef * (utcDayNumber - 2451545.5);\n  const secondsSinceMidnight = (utcSecondsIntoDay + TimeConstants.SECONDS_PER_DAY * 0.5) % TimeConstants.SECONDS_PER_DAY;\n  const gha = angle + ratio * secondsSinceMidnight;\n  const cosGha = Math.cos(gha);\n  const sinGha = Math.sin(gha);\n  if (!defined(result)) {\n    return new Matrix3(cosGha, sinGha, 0.0, -sinGha, cosGha, 0.0, 0.0, 0.0, 1.0);\n  }\n  result[0] = cosGha;\n  result[1] = -sinGha;\n  result[2] = 0.0;\n  result[3] = sinGha;\n  result[4] = cosGha;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 1.0;\n  return result;\n};\n\n/**\n * The source of IAU 2006 XYS data, used for computing the transformation between the\n * Fixed and ICRF axes.\n * @type {Iau2006XysData}\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeFixedToIcrfMatrix\n *\n * @private\n */\nTransforms.iau2006XysData = new Iau2006XysData();\n\n/**\n * The source of Earth Orientation Parameters (EOP) data, used for computing the transformation\n * between the Fixed and ICRF axes.  By default, zero values are used for all EOP values,\n * yielding a reasonable but not completely accurate representation of the ICRF axes.\n * @type {EarthOrientationParameters}\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeFixedToIcrfMatrix\n *\n * @private\n */\nTransforms.earthOrientationParameters = EarthOrientationParameters.NONE;\nconst ttMinusTai = 32.184;\nconst j2000ttDays = 2451545.0;\n\n/**\n * Preloads the data necessary to transform between the ICRF and Fixed axes, in either\n * direction, over a given interval.  This function returns a promise that, when resolved,\n * indicates that the preload has completed.\n *\n * @param {TimeInterval} timeInterval The interval to preload.\n * @returns {Promise<void>} A promise that, when resolved, indicates that the preload has completed\n *          and evaluation of the transformation between the fixed and ICRF axes will\n *          no longer return undefined for a time inside the interval.\n *\n *\n * @example\n * const interval = new Cesium.TimeInterval(...);\n * await Cesium.Transforms.preloadIcrfFixed(interval));\n * // the data is now loaded\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeFixedToIcrfMatrix\n */\nTransforms.preloadIcrfFixed = function (timeInterval) {\n  const startDayTT = timeInterval.start.dayNumber;\n  const startSecondTT = timeInterval.start.secondsOfDay + ttMinusTai;\n  const stopDayTT = timeInterval.stop.dayNumber;\n  const stopSecondTT = timeInterval.stop.secondsOfDay + ttMinusTai;\n  return Transforms.iau2006XysData.preload(startDayTT, startSecondTT, stopDayTT, stopSecondTT);\n};\n\n/**\n * Computes a rotation matrix to transform a point or vector from the International Celestial\n * Reference Frame (GCRF/ICRF) inertial frame axes to the Earth-Fixed frame axes (ITRF)\n * at a given time.  This function may return undefined if the data necessary to\n * do the transformation is not yet loaded.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3|undefined} The rotation matrix, or undefined if the data necessary to do the\n *                   transformation is not yet loaded.\n *\n *\n * @example\n * scene.postUpdate.addEventListener(function(scene, time) {\n *   // View in ICRF.\n *   const icrfToFixed = Cesium.Transforms.computeIcrfToFixedMatrix(time);\n *   if (Cesium.defined(icrfToFixed)) {\n *     const offset = Cesium.Cartesian3.clone(camera.position);\n *     const transform = Cesium.Matrix4.fromRotationTranslation(icrfToFixed);\n *     camera.lookAtTransform(transform, offset);\n *   }\n * });\n *\n * @see Transforms.preloadIcrfFixed\n */\nTransforms.computeIcrfToFixedMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required.\");\n  }\n  //>>includeEnd('debug');\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n  const fixedToIcrfMtx = Transforms.computeFixedToIcrfMatrix(date, result);\n  if (!defined(fixedToIcrfMtx)) {\n    return undefined;\n  }\n  return Matrix3.transpose(fixedToIcrfMtx, result);\n};\nconst TdtMinusTai = 32.184;\nconst J2000d = 2451545;\nconst scratchHpr = new HeadingPitchRoll();\nconst scratchRotationMatrix = new Matrix3();\nconst dateScratch = new JulianDate();\n\n/**\n * Computes a rotation matrix to transform a point or vector from the Moon-Fixed frame axes\n * to the International Celestial Reference Frame (GCRF/ICRF) inertial frame axes\n * at a given time.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3} The rotation matrix.\n *\n * @example\n * // Transform a point from the Fixed axes to the ICRF axes.\n * const now = Cesium.JulianDate.now();\n * const pointInFixed = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const fixedToIcrf = Cesium.Transforms.computeMoonFixedToIcrfMatrix(now);\n * let pointInInertial = new Cesium.Cartesian3();\n * if (Cesium.defined(fixedToIcrf)) {\n *     pointInInertial = Cesium.Matrix3.multiplyByVector(fixedToIcrf, pointInFixed, pointInInertial);\n * }\n */\nTransforms.computeMoonFixedToIcrfMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  // Converts TAI to TT\n  const secondsTT = JulianDate.addSeconds(date, TdtMinusTai, dateScratch);\n\n  // Converts TT to TDB, interval in days since the standard epoch\n  const d = JulianDate.totalDays(secondsTT) - J2000d;\n\n  // Compute the approximate rotation, using https://articles.adsabs.harvard.edu//full/1980CeMec..22..205D/0000209.000.html\n  const e1 = CesiumMath.toRadians(12.112) - CesiumMath.toRadians(0.052992) * d;\n  const e2 = CesiumMath.toRadians(24.224) - CesiumMath.toRadians(0.105984) * d;\n  const e3 = CesiumMath.toRadians(227.645) + CesiumMath.toRadians(13.012) * d;\n  const e4 = CesiumMath.toRadians(261.105) + CesiumMath.toRadians(13.340716) * d;\n  const e5 = CesiumMath.toRadians(358.0) + CesiumMath.toRadians(0.9856) * d;\n  scratchHpr.pitch = CesiumMath.toRadians(270.0 - 90) - CesiumMath.toRadians(3.878) * Math.sin(e1) - CesiumMath.toRadians(0.12) * Math.sin(e2) + CesiumMath.toRadians(0.07) * Math.sin(e3) - CesiumMath.toRadians(0.017) * Math.sin(e4);\n  scratchHpr.roll = CesiumMath.toRadians(66.53 - 90) + CesiumMath.toRadians(1.543) * Math.cos(e1) + CesiumMath.toRadians(0.24) * Math.cos(e2) - CesiumMath.toRadians(0.028) * Math.cos(e3) + CesiumMath.toRadians(0.007) * Math.cos(e4);\n  scratchHpr.heading = CesiumMath.toRadians(244.375 - 90) + CesiumMath.toRadians(13.17635831) * d + CesiumMath.toRadians(3.558) * Math.sin(e1) + CesiumMath.toRadians(0.121) * Math.sin(e2) - CesiumMath.toRadians(0.064) * Math.sin(e3) + CesiumMath.toRadians(0.016) * Math.sin(e4) + CesiumMath.toRadians(0.025) * Math.sin(e5);\n  return Matrix3.fromHeadingPitchRoll(scratchHpr, scratchRotationMatrix);\n};\n\n/**\n * Computes a rotation matrix to transform a point or vector from the International Celestial\n * Reference Frame (GCRF/ICRF) inertial frame axes to the Moon-Fixed frame axes\n * at a given time.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3} The rotation matrix.\n *\n * @example\n * // Set the default ICRF to fixed transformation to that of the Moon.\n * Cesium.Transforms.computeIcrfToCentralBodyFixedMatrix = Cesium.Transforms.computeIcrfToMoonFixedMatrix;\n */\nTransforms.computeIcrfToMoonFixedMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required.\");\n  }\n  //>>includeEnd('debug');\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n  const fixedToIcrfMtx = Transforms.computeMoonFixedToIcrfMatrix(date, result);\n  if (!defined(fixedToIcrfMtx)) {\n    return undefined;\n  }\n  return Matrix3.transpose(fixedToIcrfMtx, result);\n};\nconst xysScratch = new Iau2006XysSample(0.0, 0.0, 0.0);\nconst eopScratch = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\nconst rotation1Scratch = new Matrix3();\nconst rotation2Scratch = new Matrix3();\n\n/**\n * Computes a rotation matrix to transform a point or vector from the Earth-Fixed frame axes (ITRF)\n * to the International Celestial Reference Frame (GCRF/ICRF) inertial frame axes\n * at a given time.  This function may return undefined if the data necessary to\n * do the transformation is not yet loaded.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3|undefined} The rotation matrix, or undefined if the data necessary to do the\n *                   transformation is not yet loaded.\n *\n *\n * @example\n * // Transform a point from the Fixed axes to the ICRF axes.\n * const now = Cesium.JulianDate.now();\n * const pointInFixed = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const fixedToIcrf = Cesium.Transforms.computeFixedToIcrfMatrix(now);\n * let pointInInertial = new Cesium.Cartesian3();\n * if (Cesium.defined(fixedToIcrf)) {\n *     pointInInertial = Cesium.Matrix3.multiplyByVector(fixedToIcrf, pointInFixed, pointInInertial);\n * }\n *\n * @see Transforms.preloadIcrfFixed\n */\nTransforms.computeFixedToIcrfMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  // Compute pole wander\n  const eop = Transforms.earthOrientationParameters.compute(date, eopScratch);\n  if (!defined(eop)) {\n    return undefined;\n  }\n\n  // There is no external conversion to Terrestrial Time (TT).\n  // So use International Atomic Time (TAI) and convert using offsets.\n  // Here we are assuming that dayTT and secondTT are positive\n  const dayTT = date.dayNumber;\n  // It's possible here that secondTT could roll over 86400\n  // This does not seem to affect the precision (unit tests check for this)\n  const secondTT = date.secondsOfDay + ttMinusTai;\n  const xys = Transforms.iau2006XysData.computeXysRadians(dayTT, secondTT, xysScratch);\n  if (!defined(xys)) {\n    return undefined;\n  }\n  const x = xys.x + eop.xPoleOffset;\n  const y = xys.y + eop.yPoleOffset;\n\n  // Compute XYS rotation\n  const a = 1.0 / (1.0 + Math.sqrt(1.0 - x * x - y * y));\n  const rotation1 = rotation1Scratch;\n  rotation1[0] = 1.0 - a * x * x;\n  rotation1[3] = -a * x * y;\n  rotation1[6] = x;\n  rotation1[1] = -a * x * y;\n  rotation1[4] = 1 - a * y * y;\n  rotation1[7] = y;\n  rotation1[2] = -x;\n  rotation1[5] = -y;\n  rotation1[8] = 1 - a * (x * x + y * y);\n  const rotation2 = Matrix3.fromRotationZ(-xys.s, rotation2Scratch);\n  const matrixQ = Matrix3.multiply(rotation1, rotation2, rotation1Scratch);\n\n  // Similar to TT conversions above\n  // It's possible here that secondTT could roll over 86400\n  // This does not seem to affect the precision (unit tests check for this)\n  const dateUt1day = date.dayNumber;\n  const dateUt1sec = date.secondsOfDay - JulianDate.computeTaiMinusUtc(date) + eop.ut1MinusUtc;\n\n  // Compute Earth rotation angle\n  // The IERS standard for era is\n  //    era = 0.7790572732640 + 1.00273781191135448 * Tu\n  // where\n  //    Tu = JulianDateInUt1 - 2451545.0\n  // However, you get much more precision if you make the following simplification\n  //    era = a + (1 + b) * (JulianDayNumber + FractionOfDay - 2451545)\n  //    era = a + (JulianDayNumber - 2451545) + FractionOfDay + b (JulianDayNumber - 2451545 + FractionOfDay)\n  //    era = a + FractionOfDay + b (JulianDayNumber - 2451545 + FractionOfDay)\n  // since (JulianDayNumber - 2451545) represents an integer number of revolutions which will be discarded anyway.\n  const daysSinceJ2000 = dateUt1day - 2451545;\n  const fractionOfDay = dateUt1sec / TimeConstants.SECONDS_PER_DAY;\n  let era = 0.779057273264 + fractionOfDay + 0.00273781191135448 * (daysSinceJ2000 + fractionOfDay);\n  era = era % 1.0 * CesiumMath.TWO_PI;\n  const earthRotation = Matrix3.fromRotationZ(era, rotation2Scratch);\n\n  // pseudoFixed to ICRF\n  const pfToIcrf = Matrix3.multiply(matrixQ, earthRotation, rotation1Scratch);\n\n  // Compute pole wander matrix\n  const cosxp = Math.cos(eop.xPoleWander);\n  const cosyp = Math.cos(eop.yPoleWander);\n  const sinxp = Math.sin(eop.xPoleWander);\n  const sinyp = Math.sin(eop.yPoleWander);\n  let ttt = dayTT - j2000ttDays + secondTT / TimeConstants.SECONDS_PER_DAY;\n  ttt /= 36525.0;\n\n  // approximate sp value in rad\n  const sp = -47.0e-6 * ttt * CesiumMath.RADIANS_PER_DEGREE / 3600.0;\n  const cossp = Math.cos(sp);\n  const sinsp = Math.sin(sp);\n  const fToPfMtx = rotation2Scratch;\n  fToPfMtx[0] = cosxp * cossp;\n  fToPfMtx[1] = cosxp * sinsp;\n  fToPfMtx[2] = sinxp;\n  fToPfMtx[3] = -cosyp * sinsp + sinyp * sinxp * cossp;\n  fToPfMtx[4] = cosyp * cossp + sinyp * sinxp * sinsp;\n  fToPfMtx[5] = -sinyp * cosxp;\n  fToPfMtx[6] = -sinyp * sinsp - cosyp * sinxp * cossp;\n  fToPfMtx[7] = sinyp * cossp - cosyp * sinxp * sinsp;\n  fToPfMtx[8] = cosyp * cosxp;\n  return Matrix3.multiply(pfToIcrf, fToPfMtx, result);\n};\nconst pointToWindowCoordinatesTemp = new Cartesian4();\n\n/**\n * Transform a point from model coordinates to window coordinates.\n *\n * @param {Matrix4} modelViewProjectionMatrix The 4x4 model-view-projection matrix.\n * @param {Matrix4} viewportTransformation The 4x4 viewport transformation.\n * @param {Cartesian3} point The point to transform.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.\n */\nTransforms.pointToWindowCoordinates = function (modelViewProjectionMatrix, viewportTransformation, point, result) {\n  result = Transforms.pointToGLWindowCoordinates(modelViewProjectionMatrix, viewportTransformation, point, result);\n  result.y = 2.0 * viewportTransformation[5] - result.y;\n  return result;\n};\n\n/**\n * @private\n */\nTransforms.pointToGLWindowCoordinates = function (modelViewProjectionMatrix, viewportTransformation, point, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(modelViewProjectionMatrix)) {\n    throw new DeveloperError(\"modelViewProjectionMatrix is required.\");\n  }\n  if (!defined(viewportTransformation)) {\n    throw new DeveloperError(\"viewportTransformation is required.\");\n  }\n  if (!defined(point)) {\n    throw new DeveloperError(\"point is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n  const tmp = pointToWindowCoordinatesTemp;\n  Matrix4.multiplyByVector(modelViewProjectionMatrix, Cartesian4.fromElements(point.x, point.y, point.z, 1, tmp), tmp);\n  Cartesian4.multiplyByScalar(tmp, 1.0 / tmp.w, tmp);\n  Matrix4.multiplyByVector(viewportTransformation, tmp, tmp);\n  return Cartesian2.fromCartesian4(tmp, result);\n};\nconst normalScratch = new Cartesian3();\nconst rightScratch = new Cartesian3();\nconst upScratch = new Cartesian3();\n\n/**\n * Transform a position and velocity to a rotation matrix.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} velocity The velocity vector to transform.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.\n */\nTransforms.rotationMatrixFromPositionVelocity = function (position, velocity, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n  if (!defined(velocity)) {\n    throw new DeveloperError(\"velocity is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const normal = (ellipsoid ?? Ellipsoid.default).geodeticSurfaceNormal(position, normalScratch);\n  let right = Cartesian3.cross(velocity, normal, rightScratch);\n  if (Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)) {\n    right = Cartesian3.clone(Cartesian3.UNIT_X, right);\n  }\n  const up = Cartesian3.cross(right, velocity, upScratch);\n  Cartesian3.normalize(up, up);\n  Cartesian3.cross(velocity, up, right);\n  Cartesian3.negate(right, right);\n  Cartesian3.normalize(right, right);\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n  result[0] = velocity.x;\n  result[1] = velocity.y;\n  result[2] = velocity.z;\n  result[3] = right.x;\n  result[4] = right.y;\n  result[5] = right.z;\n  result[6] = up.x;\n  result[7] = up.y;\n  result[8] = up.z;\n  return result;\n};\nconst swizzleMatrix = new Matrix4(0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0);\nconst scratchCartographic = new Cartographic();\nconst scratchCartesian3Projection = new Cartesian3();\nconst scratchCenter = new Cartesian3();\nconst scratchRotation = new Matrix3();\nconst scratchFromENU = new Matrix4();\nconst scratchToENU = new Matrix4();\n\n/**\n * @private\n */\nTransforms.basisTo2D = function (projection, matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(projection)) {\n    throw new DeveloperError(\"projection is required.\");\n  }\n  if (!defined(matrix)) {\n    throw new DeveloperError(\"matrix is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const rtcCenter = Matrix4.getTranslation(matrix, scratchCenter);\n  const ellipsoid = projection.ellipsoid;\n  let projectedPosition;\n  if (Cartesian3.equals(rtcCenter, Cartesian3.ZERO)) {\n    projectedPosition = Cartesian3.clone(Cartesian3.ZERO, scratchCartesian3Projection);\n  } else {\n    // Get the 2D Center\n    const cartographic = ellipsoid.cartesianToCartographic(rtcCenter, scratchCartographic);\n    projectedPosition = projection.project(cartographic, scratchCartesian3Projection);\n    Cartesian3.fromElements(projectedPosition.z, projectedPosition.x, projectedPosition.y, projectedPosition);\n  }\n\n  // Assuming the instance are positioned on the ellipsoid, invert the ellipsoidal transform to get the local transform and then convert to 2D\n  const fromENU = Transforms.eastNorthUpToFixedFrame(rtcCenter, ellipsoid, scratchFromENU);\n  const toENU = Matrix4.inverseTransformation(fromENU, scratchToENU);\n  const rotation = Matrix4.getMatrix3(matrix, scratchRotation);\n  const local = Matrix4.multiplyByMatrix3(toENU, rotation, result);\n  Matrix4.multiply(swizzleMatrix, local, result); // Swap x, y, z for 2D\n  Matrix4.setTranslation(result, projectedPosition, result); // Use the projected center\n\n  return result;\n};\n\n/**\n * @private\n */\nTransforms.ellipsoidTo2DModelMatrix = function (projection, center, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(projection)) {\n    throw new DeveloperError(\"projection is required.\");\n  }\n  if (!defined(center)) {\n    throw new DeveloperError(\"center is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const ellipsoid = projection.ellipsoid;\n  const fromENU = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, scratchFromENU);\n  const toENU = Matrix4.inverseTransformation(fromENU, scratchToENU);\n  const cartographic = ellipsoid.cartesianToCartographic(center, scratchCartographic);\n  const projectedPosition = projection.project(cartographic, scratchCartesian3Projection);\n  Cartesian3.fromElements(projectedPosition.z, projectedPosition.x, projectedPosition.y, projectedPosition);\n  const translation = Matrix4.fromTranslation(projectedPosition, scratchFromENU);\n  Matrix4.multiply(swizzleMatrix, toENU, result);\n  Matrix4.multiply(translation, result, result);\n  return result;\n};\nexport default Transforms;","map":{"version":3,"names":["Cartesian2","Cartesian3","Cartesian4","Cartographic","Check","defined","DeveloperError","EarthOrientationParameters","EarthOrientationParametersSample","Ellipsoid","HeadingPitchRoll","Iau2006XysData","Iau2006XysSample","JulianDate","CesiumMath","Matrix3","Matrix4","Quaternion","TimeConstants","Transforms","vectorProductLocalFrame","up","south","north","west","east","down","degeneratePositionLocalFrame","localFrameToFixedFrameCache","scratchCalculateCartesian","scratchFirstCartesian","scratchSecondCartesian","scratchThirdCartesian","localFrameToFixedFrameGenerator","firstAxis","secondAxis","hasOwnProperty","thirdAxis","resultat","hashAxis","origin","ellipsoid","result","isNaN","x","y","z","equalsEpsilon","ZERO","EPSILON14","unpack","sign","multiplyByScalar","default","geodeticSurfaceNormal","normalize","cross","eastNorthUpToFixedFrame","northEastDownToFixedFrame","northUpEastToFixedFrame","northWestUpToFixedFrame","scratchHPRQuaternion","scratchScale","scratchHPRMatrix4","headingPitchRollToFixedFrame","headingPitchRoll","fixedFrameTransform","typeOf","object","hprQuaternion","fromHeadingPitchRoll","hprMatrix","fromTranslationQuaternionRotationScale","multiply","scratchENUMatrix4","scratchHPRMatrix3","headingPitchRollQuaternion","transform","rotation","getMatrix3","fromRotationMatrix","noScale","hprCenterScratch","ffScratch","hprTransformScratch","hprRotationScratch","hprQuaternionScratch","fixedFrameToHeadingPitchRoll","center","getTranslation","equals","heading","pitch","roll","toFixedFrame","inverseTransformation","transformCopy","setScale","setTranslation","quaternionRotation","fromQuaternion","gmstConstant0","gmstConstant1","gmstConstant2","gmstConstant3","rateCoef","wgs84WRPrecessing","twoPiOverSecondsInDay","TWO_PI","dateInUtc","computeIcrfToCentralBodyFixedMatrix","date","transformMatrix","computeIcrfToFixedMatrix","computeTemeToPseudoFixedMatrix","addSeconds","computeTaiMinusUtc","utcDayNumber","dayNumber","utcSecondsIntoDay","secondsOfDay","t","diffDays","DAYS_PER_JULIAN_CENTURY","gmst0","angle","ratio","secondsSinceMidnight","SECONDS_PER_DAY","gha","cosGha","Math","cos","sinGha","sin","iau2006XysData","earthOrientationParameters","NONE","ttMinusTai","j2000ttDays","preloadIcrfFixed","timeInterval","startDayTT","start","startSecondTT","stopDayTT","stop","stopSecondTT","preload","fixedToIcrfMtx","computeFixedToIcrfMatrix","undefined","transpose","TdtMinusTai","J2000d","scratchHpr","scratchRotationMatrix","dateScratch","computeMoonFixedToIcrfMatrix","secondsTT","d","totalDays","e1","toRadians","e2","e3","e4","e5","computeIcrfToMoonFixedMatrix","xysScratch","eopScratch","rotation1Scratch","rotation2Scratch","eop","compute","dayTT","secondTT","xys","computeXysRadians","xPoleOffset","yPoleOffset","a","sqrt","rotation1","rotation2","fromRotationZ","s","matrixQ","dateUt1day","dateUt1sec","ut1MinusUtc","daysSinceJ2000","fractionOfDay","era","earthRotation","pfToIcrf","cosxp","xPoleWander","cosyp","yPoleWander","sinxp","sinyp","ttt","sp","RADIANS_PER_DEGREE","cossp","sinsp","fToPfMtx","pointToWindowCoordinatesTemp","pointToWindowCoordinates","modelViewProjectionMatrix","viewportTransformation","point","pointToGLWindowCoordinates","tmp","multiplyByVector","fromElements","w","fromCartesian4","normalScratch","rightScratch","upScratch","rotationMatrixFromPositionVelocity","position","velocity","normal","right","EPSILON6","clone","UNIT_X","negate","swizzleMatrix","scratchCartographic","scratchCartesian3Projection","scratchCenter","scratchRotation","scratchFromENU","scratchToENU","basisTo2D","projection","matrix","rtcCenter","projectedPosition","cartographic","cartesianToCartographic","project","fromENU","toENU","local","multiplyByMatrix3","ellipsoidTo2DModelMatrix","translation","fromTranslation"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/Transforms.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EarthOrientationParameters from \"./EarthOrientationParameters.js\";\nimport EarthOrientationParametersSample from \"./EarthOrientationParametersSample.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport HeadingPitchRoll from \"./HeadingPitchRoll.js\";\nimport Iau2006XysData from \"./Iau2006XysData.js\";\nimport Iau2006XysSample from \"./Iau2006XysSample.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport TimeConstants from \"./TimeConstants.js\";\n\n/**\n * Contains functions for transforming positions to various reference frames.\n *\n * @namespace Transforms\n */\nconst Transforms = {};\n\nconst vectorProductLocalFrame = {\n  up: {\n    south: \"east\",\n    north: \"west\",\n    west: \"south\",\n    east: \"north\",\n  },\n  down: {\n    south: \"west\",\n    north: \"east\",\n    west: \"north\",\n    east: \"south\",\n  },\n  south: {\n    up: \"west\",\n    down: \"east\",\n    west: \"down\",\n    east: \"up\",\n  },\n  north: {\n    up: \"east\",\n    down: \"west\",\n    west: \"up\",\n    east: \"down\",\n  },\n  west: {\n    up: \"north\",\n    down: \"south\",\n    north: \"down\",\n    south: \"up\",\n  },\n  east: {\n    up: \"south\",\n    down: \"north\",\n    north: \"up\",\n    south: \"down\",\n  },\n};\n\nconst degeneratePositionLocalFrame = {\n  north: [-1, 0, 0],\n  east: [0, 1, 0],\n  up: [0, 0, 1],\n  south: [1, 0, 0],\n  west: [0, -1, 0],\n  down: [0, 0, -1],\n};\n\nconst localFrameToFixedFrameCache = {};\n\nconst scratchCalculateCartesian = {\n  east: new Cartesian3(),\n  north: new Cartesian3(),\n  up: new Cartesian3(),\n  west: new Cartesian3(),\n  south: new Cartesian3(),\n  down: new Cartesian3(),\n};\nlet scratchFirstCartesian = new Cartesian3();\nlet scratchSecondCartesian = new Cartesian3();\nlet scratchThirdCartesian = new Cartesian3();\n/**\n * Generates a function that computes a 4x4 transformation matrix from a reference frame\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * @param  {string} firstAxis  name of the first axis of the local reference frame. Must be\n *  'east', 'north', 'up', 'west', 'south' or 'down'.\n * @param  {string} secondAxis  name of the second axis of the local reference frame. Must be\n *  'east', 'north', 'up', 'west', 'south' or 'down'.\n * @return {Transforms.LocalFrameToFixedFrame} The function that will computes a\n * 4x4 transformation matrix from a reference frame, with first axis and second axis compliant with the parameters,\n */\nTransforms.localFrameToFixedFrameGenerator = function (firstAxis, secondAxis) {\n  if (\n    !vectorProductLocalFrame.hasOwnProperty(firstAxis) ||\n    !vectorProductLocalFrame[firstAxis].hasOwnProperty(secondAxis)\n  ) {\n    throw new DeveloperError(\n      \"firstAxis and secondAxis must be east, north, up, west, south or down.\",\n    );\n  }\n  const thirdAxis = vectorProductLocalFrame[firstAxis][secondAxis];\n\n  /**\n   * Computes a 4x4 transformation matrix from a reference frame\n   * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n   * @callback Transforms.LocalFrameToFixedFrame\n   * @param {Cartesian3} origin The center point of the local reference frame.\n   * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n   * @param {Matrix4} [result] The object onto which to store the result.\n   * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n   */\n  let resultat;\n  const hashAxis = firstAxis + secondAxis;\n  if (defined(localFrameToFixedFrameCache[hashAxis])) {\n    resultat = localFrameToFixedFrameCache[hashAxis];\n  } else {\n    resultat = function (origin, ellipsoid, result) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(origin)) {\n        throw new DeveloperError(\"origin is required.\");\n      }\n      if (isNaN(origin.x) || isNaN(origin.y) || isNaN(origin.z)) {\n        throw new DeveloperError(\"origin has a NaN component\");\n      }\n      //>>includeEnd('debug');\n      if (!defined(result)) {\n        result = new Matrix4();\n      }\n      if (\n        Cartesian3.equalsEpsilon(origin, Cartesian3.ZERO, CesiumMath.EPSILON14)\n      ) {\n        // If x, y, and z are zero, use the degenerate local frame, which is a special case\n        Cartesian3.unpack(\n          degeneratePositionLocalFrame[firstAxis],\n          0,\n          scratchFirstCartesian,\n        );\n        Cartesian3.unpack(\n          degeneratePositionLocalFrame[secondAxis],\n          0,\n          scratchSecondCartesian,\n        );\n        Cartesian3.unpack(\n          degeneratePositionLocalFrame[thirdAxis],\n          0,\n          scratchThirdCartesian,\n        );\n      } else if (\n        CesiumMath.equalsEpsilon(origin.x, 0.0, CesiumMath.EPSILON14) &&\n        CesiumMath.equalsEpsilon(origin.y, 0.0, CesiumMath.EPSILON14)\n      ) {\n        // If x and y are zero, assume origin is at a pole, which is a special case.\n        const sign = CesiumMath.sign(origin.z);\n\n        Cartesian3.unpack(\n          degeneratePositionLocalFrame[firstAxis],\n          0,\n          scratchFirstCartesian,\n        );\n        if (firstAxis !== \"east\" && firstAxis !== \"west\") {\n          Cartesian3.multiplyByScalar(\n            scratchFirstCartesian,\n            sign,\n            scratchFirstCartesian,\n          );\n        }\n\n        Cartesian3.unpack(\n          degeneratePositionLocalFrame[secondAxis],\n          0,\n          scratchSecondCartesian,\n        );\n        if (secondAxis !== \"east\" && secondAxis !== \"west\") {\n          Cartesian3.multiplyByScalar(\n            scratchSecondCartesian,\n            sign,\n            scratchSecondCartesian,\n          );\n        }\n\n        Cartesian3.unpack(\n          degeneratePositionLocalFrame[thirdAxis],\n          0,\n          scratchThirdCartesian,\n        );\n        if (thirdAxis !== \"east\" && thirdAxis !== \"west\") {\n          Cartesian3.multiplyByScalar(\n            scratchThirdCartesian,\n            sign,\n            scratchThirdCartesian,\n          );\n        }\n      } else {\n        ellipsoid = ellipsoid ?? Ellipsoid.default;\n        ellipsoid.geodeticSurfaceNormal(origin, scratchCalculateCartesian.up);\n\n        const up = scratchCalculateCartesian.up;\n        const east = scratchCalculateCartesian.east;\n        east.x = -origin.y;\n        east.y = origin.x;\n        east.z = 0.0;\n        Cartesian3.normalize(east, scratchCalculateCartesian.east);\n        Cartesian3.cross(up, east, scratchCalculateCartesian.north);\n\n        Cartesian3.multiplyByScalar(\n          scratchCalculateCartesian.up,\n          -1,\n          scratchCalculateCartesian.down,\n        );\n        Cartesian3.multiplyByScalar(\n          scratchCalculateCartesian.east,\n          -1,\n          scratchCalculateCartesian.west,\n        );\n        Cartesian3.multiplyByScalar(\n          scratchCalculateCartesian.north,\n          -1,\n          scratchCalculateCartesian.south,\n        );\n\n        scratchFirstCartesian = scratchCalculateCartesian[firstAxis];\n        scratchSecondCartesian = scratchCalculateCartesian[secondAxis];\n        scratchThirdCartesian = scratchCalculateCartesian[thirdAxis];\n      }\n      result[0] = scratchFirstCartesian.x;\n      result[1] = scratchFirstCartesian.y;\n      result[2] = scratchFirstCartesian.z;\n      result[3] = 0.0;\n      result[4] = scratchSecondCartesian.x;\n      result[5] = scratchSecondCartesian.y;\n      result[6] = scratchSecondCartesian.z;\n      result[7] = 0.0;\n      result[8] = scratchThirdCartesian.x;\n      result[9] = scratchThirdCartesian.y;\n      result[10] = scratchThirdCartesian.z;\n      result[11] = 0.0;\n      result[12] = origin.x;\n      result[13] = origin.y;\n      result[14] = origin.z;\n      result[15] = 1.0;\n      return result;\n    };\n    localFrameToFixedFrameCache[hashAxis] = resultat;\n  }\n  return resultat;\n};\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local east direction.</li>\n * <li>The <code>y</code> axis points in the local north direction.</li>\n * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local east-north-up at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n */\nTransforms.eastNorthUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\n  \"east\",\n  \"north\",\n);\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an north-east-down axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local north direction.</li>\n * <li>The <code>y</code> axis points in the local east direction.</li>\n * <li>The <code>z</code> axis points in the opposite direction of the ellipsoid surface normal which passes through the position.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local north-east-down at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.northEastDownToFixedFrame(center);\n */\nTransforms.northEastDownToFixedFrame =\n  Transforms.localFrameToFixedFrameGenerator(\"north\", \"east\");\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an north-up-east axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local north direction.</li>\n * <li>The <code>y</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n * <li>The <code>z</code> axis points in the local east direction.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local north-up-east at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.northUpEastToFixedFrame(center);\n */\nTransforms.northUpEastToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\n  \"north\",\n  \"up\",\n);\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an north-west-up axes\n * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local north direction.</li>\n * <li>The <code>y</code> axis points in the local west direction.</li>\n * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local north-West-Up at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const transform = Cesium.Transforms.northWestUpToFixedFrame(center);\n */\nTransforms.northWestUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\n  \"north\",\n  \"west\",\n);\n\nconst scratchHPRQuaternion = new Quaternion();\nconst scratchScale = new Cartesian3(1.0, 1.0, 1.0);\nconst scratchHPRMatrix4 = new Matrix4();\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with axes computed from the heading-pitch-roll angles\n * centered at the provided origin to the provided ellipsoid's fixed reference frame. Heading is the rotation from the local east\n * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n *\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {HeadingPitchRoll} headingPitchRoll The heading, pitch, and roll.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation\n *  matrix from a reference frame to the provided ellipsoid's fixed reference frame\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const heading = -Cesium.Math.PI_OVER_TWO;\n * const pitch = Cesium.Math.PI_OVER_FOUR;\n * const roll = 0.0;\n * const hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);\n * const transform = Cesium.Transforms.headingPitchRollToFixedFrame(center, hpr);\n */\nTransforms.headingPitchRollToFixedFrame = function (\n  origin,\n  headingPitchRoll,\n  ellipsoid,\n  fixedFrameTransform,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"HeadingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  fixedFrameTransform =\n    fixedFrameTransform ?? Transforms.eastNorthUpToFixedFrame;\n  const hprQuaternion = Quaternion.fromHeadingPitchRoll(\n    headingPitchRoll,\n    scratchHPRQuaternion,\n  );\n  const hprMatrix = Matrix4.fromTranslationQuaternionRotationScale(\n    Cartesian3.ZERO,\n    hprQuaternion,\n    scratchScale,\n    scratchHPRMatrix4,\n  );\n  result = fixedFrameTransform(origin, ellipsoid, result);\n  return Matrix4.multiply(result, hprMatrix, result);\n};\n\nconst scratchENUMatrix4 = new Matrix4();\nconst scratchHPRMatrix3 = new Matrix3();\n\n/**\n * Computes a quaternion from a reference frame with axes computed from the heading-pitch-roll angles\n * centered at the provided origin. Heading is the rotation from the local east\n * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n *\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {HeadingPitchRoll} headingPitchRoll The heading, pitch, and roll.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation\n *  matrix from a reference frame to the provided ellipsoid's fixed reference frame\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.\n *\n * @example\n * // Get the quaternion from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.\n * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const heading = -Cesium.Math.PI_OVER_TWO;\n * const pitch = Cesium.Math.PI_OVER_FOUR;\n * const roll = 0.0;\n * const hpr = new HeadingPitchRoll(heading, pitch, roll);\n * const quaternion = Cesium.Transforms.headingPitchRollQuaternion(center, hpr);\n */\nTransforms.headingPitchRollQuaternion = function (\n  origin,\n  headingPitchRoll,\n  ellipsoid,\n  fixedFrameTransform,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"HeadingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  const transform = Transforms.headingPitchRollToFixedFrame(\n    origin,\n    headingPitchRoll,\n    ellipsoid,\n    fixedFrameTransform,\n    scratchENUMatrix4,\n  );\n  const rotation = Matrix4.getMatrix3(transform, scratchHPRMatrix3);\n  return Quaternion.fromRotationMatrix(rotation, result);\n};\n\nconst noScale = new Cartesian3(1.0, 1.0, 1.0);\nconst hprCenterScratch = new Cartesian3();\nconst ffScratch = new Matrix4();\nconst hprTransformScratch = new Matrix4();\nconst hprRotationScratch = new Matrix3();\nconst hprQuaternionScratch = new Quaternion();\n/**\n * Computes heading-pitch-roll angles from a transform in a particular reference frame. Heading is the rotation from the local east\n * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n *\n * @param {Matrix4} transform The transform\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation\n *  matrix from a reference frame to the provided ellipsoid's fixed reference frame\n * @param {HeadingPitchRoll} [result] The object onto which to store the result.\n * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if none was provided.\n */\nTransforms.fixedFrameToHeadingPitchRoll = function (\n  transform,\n  ellipsoid,\n  fixedFrameTransform,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  ellipsoid = ellipsoid ?? Ellipsoid.default;\n  fixedFrameTransform =\n    fixedFrameTransform ?? Transforms.eastNorthUpToFixedFrame;\n  if (!defined(result)) {\n    result = new HeadingPitchRoll();\n  }\n\n  const center = Matrix4.getTranslation(transform, hprCenterScratch);\n  if (Cartesian3.equals(center, Cartesian3.ZERO)) {\n    result.heading = 0;\n    result.pitch = 0;\n    result.roll = 0;\n    return result;\n  }\n  let toFixedFrame = Matrix4.inverseTransformation(\n    fixedFrameTransform(center, ellipsoid, ffScratch),\n    ffScratch,\n  );\n  let transformCopy = Matrix4.setScale(transform, noScale, hprTransformScratch);\n  transformCopy = Matrix4.setTranslation(\n    transformCopy,\n    Cartesian3.ZERO,\n    transformCopy,\n  );\n\n  toFixedFrame = Matrix4.multiply(toFixedFrame, transformCopy, toFixedFrame);\n  let quaternionRotation = Quaternion.fromRotationMatrix(\n    Matrix4.getMatrix3(toFixedFrame, hprRotationScratch),\n    hprQuaternionScratch,\n  );\n  quaternionRotation = Quaternion.normalize(\n    quaternionRotation,\n    quaternionRotation,\n  );\n\n  return HeadingPitchRoll.fromQuaternion(quaternionRotation, result);\n};\n\nconst gmstConstant0 = 6 * 3600 + 41 * 60 + 50.54841;\nconst gmstConstant1 = 8640184.812866;\nconst gmstConstant2 = 0.093104;\nconst gmstConstant3 = -6.2e-6;\nconst rateCoef = 1.1772758384668e-19;\nconst wgs84WRPrecessing = 7.2921158553e-5;\nconst twoPiOverSecondsInDay = CesiumMath.TWO_PI / 86400.0;\nlet dateInUtc = new JulianDate();\n\n/**\n * The default function to compute a rotation matrix to transform a point or vector from the International Celestial\n * Reference Frame (GCRF/ICRF) inertial frame axes to the central body, typically Earth, fixed frame axis at a given\n * time for use in lighting and transformation from inertial reference frames. This function may return undefined if\n * the data necessary to do the transformation is not yet loaded.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3|undefined} The rotation matrix, or undefined if the data necessary to do the\n *                   transformation is not yet loaded.\n *\n * @example\n * // Set the default ICRF to fixed transformation to that of the Moon.\n * Cesium.Transforms.computeIcrfToCentralBodyFixedMatrix = Cesium.Transforms.computeIcrfToMoonFixedMatrix;\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeTemeToPseudoFixedMatrix\n * @see Transforms.computeIcrfToMoonFixedMatrix\n */\nTransforms.computeIcrfToCentralBodyFixedMatrix = function (date, result) {\n  let transformMatrix = Transforms.computeIcrfToFixedMatrix(date, result);\n  if (!defined(transformMatrix)) {\n    transformMatrix = Transforms.computeTemeToPseudoFixedMatrix(date, result);\n  }\n\n  return transformMatrix;\n};\n\n/**\n * Computes a rotation matrix to transform a point or vector from True Equator Mean Equinox (TEME) axes to the\n * pseudo-fixed axes at a given time.  This method treats the UT1 time standard as equivalent to UTC.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.\n *\n * @example\n * //Set the view to the inertial frame.\n * scene.postUpdate.addEventListener(function(scene, time) {\n *    const now = Cesium.JulianDate.now();\n *    const offset = Cesium.Matrix4.multiplyByPoint(camera.transform, camera.position, new Cesium.Cartesian3());\n *    const transform = Cesium.Matrix4.fromRotationTranslation(Cesium.Transforms.computeTemeToPseudoFixedMatrix(now));\n *    const inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());\n *    Cesium.Matrix4.multiplyByPoint(inverseTransform, offset, offset);\n *    camera.lookAtTransform(transform, offset);\n * });\n */\nTransforms.computeTemeToPseudoFixedMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // GMST is actually computed using UT1.  We're using UTC as an approximation of UT1.\n  // We do not want to use the function like convertTaiToUtc in JulianDate because\n  // we explicitly do not want to fail when inside the leap second.\n\n  dateInUtc = JulianDate.addSeconds(\n    date,\n    -JulianDate.computeTaiMinusUtc(date),\n    dateInUtc,\n  );\n  const utcDayNumber = dateInUtc.dayNumber;\n  const utcSecondsIntoDay = dateInUtc.secondsOfDay;\n\n  let t;\n  const diffDays = utcDayNumber - 2451545;\n  if (utcSecondsIntoDay >= 43200.0) {\n    t = (diffDays + 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;\n  } else {\n    t = (diffDays - 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;\n  }\n\n  const gmst0 =\n    gmstConstant0 +\n    t * (gmstConstant1 + t * (gmstConstant2 + t * gmstConstant3));\n  const angle = (gmst0 * twoPiOverSecondsInDay) % CesiumMath.TWO_PI;\n  const ratio = wgs84WRPrecessing + rateCoef * (utcDayNumber - 2451545.5);\n  const secondsSinceMidnight =\n    (utcSecondsIntoDay + TimeConstants.SECONDS_PER_DAY * 0.5) %\n    TimeConstants.SECONDS_PER_DAY;\n  const gha = angle + ratio * secondsSinceMidnight;\n  const cosGha = Math.cos(gha);\n  const sinGha = Math.sin(gha);\n\n  if (!defined(result)) {\n    return new Matrix3(\n      cosGha,\n      sinGha,\n      0.0,\n      -sinGha,\n      cosGha,\n      0.0,\n      0.0,\n      0.0,\n      1.0,\n    );\n  }\n  result[0] = cosGha;\n  result[1] = -sinGha;\n  result[2] = 0.0;\n  result[3] = sinGha;\n  result[4] = cosGha;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 1.0;\n  return result;\n};\n\n/**\n * The source of IAU 2006 XYS data, used for computing the transformation between the\n * Fixed and ICRF axes.\n * @type {Iau2006XysData}\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeFixedToIcrfMatrix\n *\n * @private\n */\nTransforms.iau2006XysData = new Iau2006XysData();\n\n/**\n * The source of Earth Orientation Parameters (EOP) data, used for computing the transformation\n * between the Fixed and ICRF axes.  By default, zero values are used for all EOP values,\n * yielding a reasonable but not completely accurate representation of the ICRF axes.\n * @type {EarthOrientationParameters}\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeFixedToIcrfMatrix\n *\n * @private\n */\nTransforms.earthOrientationParameters = EarthOrientationParameters.NONE;\n\nconst ttMinusTai = 32.184;\nconst j2000ttDays = 2451545.0;\n\n/**\n * Preloads the data necessary to transform between the ICRF and Fixed axes, in either\n * direction, over a given interval.  This function returns a promise that, when resolved,\n * indicates that the preload has completed.\n *\n * @param {TimeInterval} timeInterval The interval to preload.\n * @returns {Promise<void>} A promise that, when resolved, indicates that the preload has completed\n *          and evaluation of the transformation between the fixed and ICRF axes will\n *          no longer return undefined for a time inside the interval.\n *\n *\n * @example\n * const interval = new Cesium.TimeInterval(...);\n * await Cesium.Transforms.preloadIcrfFixed(interval));\n * // the data is now loaded\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeFixedToIcrfMatrix\n */\nTransforms.preloadIcrfFixed = function (timeInterval) {\n  const startDayTT = timeInterval.start.dayNumber;\n  const startSecondTT = timeInterval.start.secondsOfDay + ttMinusTai;\n  const stopDayTT = timeInterval.stop.dayNumber;\n  const stopSecondTT = timeInterval.stop.secondsOfDay + ttMinusTai;\n\n  return Transforms.iau2006XysData.preload(\n    startDayTT,\n    startSecondTT,\n    stopDayTT,\n    stopSecondTT,\n  );\n};\n\n/**\n * Computes a rotation matrix to transform a point or vector from the International Celestial\n * Reference Frame (GCRF/ICRF) inertial frame axes to the Earth-Fixed frame axes (ITRF)\n * at a given time.  This function may return undefined if the data necessary to\n * do the transformation is not yet loaded.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3|undefined} The rotation matrix, or undefined if the data necessary to do the\n *                   transformation is not yet loaded.\n *\n *\n * @example\n * scene.postUpdate.addEventListener(function(scene, time) {\n *   // View in ICRF.\n *   const icrfToFixed = Cesium.Transforms.computeIcrfToFixedMatrix(time);\n *   if (Cesium.defined(icrfToFixed)) {\n *     const offset = Cesium.Cartesian3.clone(camera.position);\n *     const transform = Cesium.Matrix4.fromRotationTranslation(icrfToFixed);\n *     camera.lookAtTransform(transform, offset);\n *   }\n * });\n *\n * @see Transforms.preloadIcrfFixed\n */\nTransforms.computeIcrfToFixedMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required.\");\n  }\n  //>>includeEnd('debug');\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  const fixedToIcrfMtx = Transforms.computeFixedToIcrfMatrix(date, result);\n  if (!defined(fixedToIcrfMtx)) {\n    return undefined;\n  }\n\n  return Matrix3.transpose(fixedToIcrfMtx, result);\n};\n\nconst TdtMinusTai = 32.184;\nconst J2000d = 2451545;\nconst scratchHpr = new HeadingPitchRoll();\nconst scratchRotationMatrix = new Matrix3();\nconst dateScratch = new JulianDate();\n\n/**\n * Computes a rotation matrix to transform a point or vector from the Moon-Fixed frame axes\n * to the International Celestial Reference Frame (GCRF/ICRF) inertial frame axes\n * at a given time.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3} The rotation matrix.\n *\n * @example\n * // Transform a point from the Fixed axes to the ICRF axes.\n * const now = Cesium.JulianDate.now();\n * const pointInFixed = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const fixedToIcrf = Cesium.Transforms.computeMoonFixedToIcrfMatrix(now);\n * let pointInInertial = new Cesium.Cartesian3();\n * if (Cesium.defined(fixedToIcrf)) {\n *     pointInInertial = Cesium.Matrix3.multiplyByVector(fixedToIcrf, pointInFixed, pointInInertial);\n * }\n */\nTransforms.computeMoonFixedToIcrfMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  // Converts TAI to TT\n  const secondsTT = JulianDate.addSeconds(date, TdtMinusTai, dateScratch);\n\n  // Converts TT to TDB, interval in days since the standard epoch\n  const d = JulianDate.totalDays(secondsTT) - J2000d;\n\n  // Compute the approximate rotation, using https://articles.adsabs.harvard.edu//full/1980CeMec..22..205D/0000209.000.html\n  const e1 = CesiumMath.toRadians(12.112) - CesiumMath.toRadians(0.052992) * d;\n  const e2 = CesiumMath.toRadians(24.224) - CesiumMath.toRadians(0.105984) * d;\n  const e3 = CesiumMath.toRadians(227.645) + CesiumMath.toRadians(13.012) * d;\n  const e4 =\n    CesiumMath.toRadians(261.105) + CesiumMath.toRadians(13.340716) * d;\n  const e5 = CesiumMath.toRadians(358.0) + CesiumMath.toRadians(0.9856) * d;\n\n  scratchHpr.pitch =\n    CesiumMath.toRadians(270.0 - 90) -\n    CesiumMath.toRadians(3.878) * Math.sin(e1) -\n    CesiumMath.toRadians(0.12) * Math.sin(e2) +\n    CesiumMath.toRadians(0.07) * Math.sin(e3) -\n    CesiumMath.toRadians(0.017) * Math.sin(e4);\n  scratchHpr.roll =\n    CesiumMath.toRadians(66.53 - 90) +\n    CesiumMath.toRadians(1.543) * Math.cos(e1) +\n    CesiumMath.toRadians(0.24) * Math.cos(e2) -\n    CesiumMath.toRadians(0.028) * Math.cos(e3) +\n    CesiumMath.toRadians(0.007) * Math.cos(e4);\n  scratchHpr.heading =\n    CesiumMath.toRadians(244.375 - 90) +\n    CesiumMath.toRadians(13.17635831) * d +\n    CesiumMath.toRadians(3.558) * Math.sin(e1) +\n    CesiumMath.toRadians(0.121) * Math.sin(e2) -\n    CesiumMath.toRadians(0.064) * Math.sin(e3) +\n    CesiumMath.toRadians(0.016) * Math.sin(e4) +\n    CesiumMath.toRadians(0.025) * Math.sin(e5);\n  return Matrix3.fromHeadingPitchRoll(scratchHpr, scratchRotationMatrix);\n};\n\n/**\n * Computes a rotation matrix to transform a point or vector from the International Celestial\n * Reference Frame (GCRF/ICRF) inertial frame axes to the Moon-Fixed frame axes\n * at a given time.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3} The rotation matrix.\n *\n * @example\n * // Set the default ICRF to fixed transformation to that of the Moon.\n * Cesium.Transforms.computeIcrfToCentralBodyFixedMatrix = Cesium.Transforms.computeIcrfToMoonFixedMatrix;\n */\nTransforms.computeIcrfToMoonFixedMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required.\");\n  }\n  //>>includeEnd('debug');\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  const fixedToIcrfMtx = Transforms.computeMoonFixedToIcrfMatrix(date, result);\n  if (!defined(fixedToIcrfMtx)) {\n    return undefined;\n  }\n\n  return Matrix3.transpose(fixedToIcrfMtx, result);\n};\n\nconst xysScratch = new Iau2006XysSample(0.0, 0.0, 0.0);\nconst eopScratch = new EarthOrientationParametersSample(\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n);\nconst rotation1Scratch = new Matrix3();\nconst rotation2Scratch = new Matrix3();\n\n/**\n * Computes a rotation matrix to transform a point or vector from the Earth-Fixed frame axes (ITRF)\n * to the International Celestial Reference Frame (GCRF/ICRF) inertial frame axes\n * at a given time.  This function may return undefined if the data necessary to\n * do the transformation is not yet loaded.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3|undefined} The rotation matrix, or undefined if the data necessary to do the\n *                   transformation is not yet loaded.\n *\n *\n * @example\n * // Transform a point from the Fixed axes to the ICRF axes.\n * const now = Cesium.JulianDate.now();\n * const pointInFixed = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const fixedToIcrf = Cesium.Transforms.computeFixedToIcrfMatrix(now);\n * let pointInInertial = new Cesium.Cartesian3();\n * if (Cesium.defined(fixedToIcrf)) {\n *     pointInInertial = Cesium.Matrix3.multiplyByVector(fixedToIcrf, pointInFixed, pointInInertial);\n * }\n *\n * @see Transforms.preloadIcrfFixed\n */\nTransforms.computeFixedToIcrfMatrix = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(\"date is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  // Compute pole wander\n  const eop = Transforms.earthOrientationParameters.compute(date, eopScratch);\n  if (!defined(eop)) {\n    return undefined;\n  }\n\n  // There is no external conversion to Terrestrial Time (TT).\n  // So use International Atomic Time (TAI) and convert using offsets.\n  // Here we are assuming that dayTT and secondTT are positive\n  const dayTT = date.dayNumber;\n  // It's possible here that secondTT could roll over 86400\n  // This does not seem to affect the precision (unit tests check for this)\n  const secondTT = date.secondsOfDay + ttMinusTai;\n\n  const xys = Transforms.iau2006XysData.computeXysRadians(\n    dayTT,\n    secondTT,\n    xysScratch,\n  );\n  if (!defined(xys)) {\n    return undefined;\n  }\n\n  const x = xys.x + eop.xPoleOffset;\n  const y = xys.y + eop.yPoleOffset;\n\n  // Compute XYS rotation\n  const a = 1.0 / (1.0 + Math.sqrt(1.0 - x * x - y * y));\n\n  const rotation1 = rotation1Scratch;\n  rotation1[0] = 1.0 - a * x * x;\n  rotation1[3] = -a * x * y;\n  rotation1[6] = x;\n  rotation1[1] = -a * x * y;\n  rotation1[4] = 1 - a * y * y;\n  rotation1[7] = y;\n  rotation1[2] = -x;\n  rotation1[5] = -y;\n  rotation1[8] = 1 - a * (x * x + y * y);\n\n  const rotation2 = Matrix3.fromRotationZ(-xys.s, rotation2Scratch);\n  const matrixQ = Matrix3.multiply(rotation1, rotation2, rotation1Scratch);\n\n  // Similar to TT conversions above\n  // It's possible here that secondTT could roll over 86400\n  // This does not seem to affect the precision (unit tests check for this)\n  const dateUt1day = date.dayNumber;\n  const dateUt1sec =\n    date.secondsOfDay - JulianDate.computeTaiMinusUtc(date) + eop.ut1MinusUtc;\n\n  // Compute Earth rotation angle\n  // The IERS standard for era is\n  //    era = 0.7790572732640 + 1.00273781191135448 * Tu\n  // where\n  //    Tu = JulianDateInUt1 - 2451545.0\n  // However, you get much more precision if you make the following simplification\n  //    era = a + (1 + b) * (JulianDayNumber + FractionOfDay - 2451545)\n  //    era = a + (JulianDayNumber - 2451545) + FractionOfDay + b (JulianDayNumber - 2451545 + FractionOfDay)\n  //    era = a + FractionOfDay + b (JulianDayNumber - 2451545 + FractionOfDay)\n  // since (JulianDayNumber - 2451545) represents an integer number of revolutions which will be discarded anyway.\n  const daysSinceJ2000 = dateUt1day - 2451545;\n  const fractionOfDay = dateUt1sec / TimeConstants.SECONDS_PER_DAY;\n  let era =\n    0.779057273264 +\n    fractionOfDay +\n    0.00273781191135448 * (daysSinceJ2000 + fractionOfDay);\n  era = (era % 1.0) * CesiumMath.TWO_PI;\n\n  const earthRotation = Matrix3.fromRotationZ(era, rotation2Scratch);\n\n  // pseudoFixed to ICRF\n  const pfToIcrf = Matrix3.multiply(matrixQ, earthRotation, rotation1Scratch);\n\n  // Compute pole wander matrix\n  const cosxp = Math.cos(eop.xPoleWander);\n  const cosyp = Math.cos(eop.yPoleWander);\n  const sinxp = Math.sin(eop.xPoleWander);\n  const sinyp = Math.sin(eop.yPoleWander);\n\n  let ttt = dayTT - j2000ttDays + secondTT / TimeConstants.SECONDS_PER_DAY;\n  ttt /= 36525.0;\n\n  // approximate sp value in rad\n  const sp = (-47.0e-6 * ttt * CesiumMath.RADIANS_PER_DEGREE) / 3600.0;\n  const cossp = Math.cos(sp);\n  const sinsp = Math.sin(sp);\n\n  const fToPfMtx = rotation2Scratch;\n  fToPfMtx[0] = cosxp * cossp;\n  fToPfMtx[1] = cosxp * sinsp;\n  fToPfMtx[2] = sinxp;\n  fToPfMtx[3] = -cosyp * sinsp + sinyp * sinxp * cossp;\n  fToPfMtx[4] = cosyp * cossp + sinyp * sinxp * sinsp;\n  fToPfMtx[5] = -sinyp * cosxp;\n  fToPfMtx[6] = -sinyp * sinsp - cosyp * sinxp * cossp;\n  fToPfMtx[7] = sinyp * cossp - cosyp * sinxp * sinsp;\n  fToPfMtx[8] = cosyp * cosxp;\n\n  return Matrix3.multiply(pfToIcrf, fToPfMtx, result);\n};\n\nconst pointToWindowCoordinatesTemp = new Cartesian4();\n\n/**\n * Transform a point from model coordinates to window coordinates.\n *\n * @param {Matrix4} modelViewProjectionMatrix The 4x4 model-view-projection matrix.\n * @param {Matrix4} viewportTransformation The 4x4 viewport transformation.\n * @param {Cartesian3} point The point to transform.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.\n */\nTransforms.pointToWindowCoordinates = function (\n  modelViewProjectionMatrix,\n  viewportTransformation,\n  point,\n  result,\n) {\n  result = Transforms.pointToGLWindowCoordinates(\n    modelViewProjectionMatrix,\n    viewportTransformation,\n    point,\n    result,\n  );\n  result.y = 2.0 * viewportTransformation[5] - result.y;\n  return result;\n};\n\n/**\n * @private\n */\nTransforms.pointToGLWindowCoordinates = function (\n  modelViewProjectionMatrix,\n  viewportTransformation,\n  point,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(modelViewProjectionMatrix)) {\n    throw new DeveloperError(\"modelViewProjectionMatrix is required.\");\n  }\n\n  if (!defined(viewportTransformation)) {\n    throw new DeveloperError(\"viewportTransformation is required.\");\n  }\n\n  if (!defined(point)) {\n    throw new DeveloperError(\"point is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  const tmp = pointToWindowCoordinatesTemp;\n\n  Matrix4.multiplyByVector(\n    modelViewProjectionMatrix,\n    Cartesian4.fromElements(point.x, point.y, point.z, 1, tmp),\n    tmp,\n  );\n  Cartesian4.multiplyByScalar(tmp, 1.0 / tmp.w, tmp);\n  Matrix4.multiplyByVector(viewportTransformation, tmp, tmp);\n  return Cartesian2.fromCartesian4(tmp, result);\n};\n\nconst normalScratch = new Cartesian3();\nconst rightScratch = new Cartesian3();\nconst upScratch = new Cartesian3();\n\n/**\n * Transform a position and velocity to a rotation matrix.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} velocity The velocity vector to transform.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.\n */\nTransforms.rotationMatrixFromPositionVelocity = function (\n  position,\n  velocity,\n  ellipsoid,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n\n  if (!defined(velocity)) {\n    throw new DeveloperError(\"velocity is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const normal = (ellipsoid ?? Ellipsoid.default).geodeticSurfaceNormal(\n    position,\n    normalScratch,\n  );\n  let right = Cartesian3.cross(velocity, normal, rightScratch);\n\n  if (Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)) {\n    right = Cartesian3.clone(Cartesian3.UNIT_X, right);\n  }\n\n  const up = Cartesian3.cross(right, velocity, upScratch);\n  Cartesian3.normalize(up, up);\n  Cartesian3.cross(velocity, up, right);\n  Cartesian3.negate(right, right);\n  Cartesian3.normalize(right, right);\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  result[0] = velocity.x;\n  result[1] = velocity.y;\n  result[2] = velocity.z;\n  result[3] = right.x;\n  result[4] = right.y;\n  result[5] = right.z;\n  result[6] = up.x;\n  result[7] = up.y;\n  result[8] = up.z;\n\n  return result;\n};\n\nconst swizzleMatrix = new Matrix4(\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0,\n);\n\nconst scratchCartographic = new Cartographic();\nconst scratchCartesian3Projection = new Cartesian3();\nconst scratchCenter = new Cartesian3();\nconst scratchRotation = new Matrix3();\nconst scratchFromENU = new Matrix4();\nconst scratchToENU = new Matrix4();\n\n/**\n * @private\n */\nTransforms.basisTo2D = function (projection, matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(projection)) {\n    throw new DeveloperError(\"projection is required.\");\n  }\n  if (!defined(matrix)) {\n    throw new DeveloperError(\"matrix is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const rtcCenter = Matrix4.getTranslation(matrix, scratchCenter);\n  const ellipsoid = projection.ellipsoid;\n\n  let projectedPosition;\n  if (Cartesian3.equals(rtcCenter, Cartesian3.ZERO)) {\n    projectedPosition = Cartesian3.clone(\n      Cartesian3.ZERO,\n      scratchCartesian3Projection,\n    );\n  } else {\n    // Get the 2D Center\n    const cartographic = ellipsoid.cartesianToCartographic(\n      rtcCenter,\n      scratchCartographic,\n    );\n\n    projectedPosition = projection.project(\n      cartographic,\n      scratchCartesian3Projection,\n    );\n    Cartesian3.fromElements(\n      projectedPosition.z,\n      projectedPosition.x,\n      projectedPosition.y,\n      projectedPosition,\n    );\n  }\n\n  // Assuming the instance are positioned on the ellipsoid, invert the ellipsoidal transform to get the local transform and then convert to 2D\n  const fromENU = Transforms.eastNorthUpToFixedFrame(\n    rtcCenter,\n    ellipsoid,\n    scratchFromENU,\n  );\n  const toENU = Matrix4.inverseTransformation(fromENU, scratchToENU);\n  const rotation = Matrix4.getMatrix3(matrix, scratchRotation);\n  const local = Matrix4.multiplyByMatrix3(toENU, rotation, result);\n  Matrix4.multiply(swizzleMatrix, local, result); // Swap x, y, z for 2D\n  Matrix4.setTranslation(result, projectedPosition, result); // Use the projected center\n\n  return result;\n};\n\n/**\n * @private\n */\nTransforms.ellipsoidTo2DModelMatrix = function (projection, center, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(projection)) {\n    throw new DeveloperError(\"projection is required.\");\n  }\n  if (!defined(center)) {\n    throw new DeveloperError(\"center is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const ellipsoid = projection.ellipsoid;\n\n  const fromENU = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    scratchFromENU,\n  );\n  const toENU = Matrix4.inverseTransformation(fromENU, scratchToENU);\n\n  const cartographic = ellipsoid.cartesianToCartographic(\n    center,\n    scratchCartographic,\n  );\n  const projectedPosition = projection.project(\n    cartographic,\n    scratchCartesian3Projection,\n  );\n  Cartesian3.fromElements(\n    projectedPosition.z,\n    projectedPosition.x,\n    projectedPosition.y,\n    projectedPosition,\n  );\n\n  const translation = Matrix4.fromTranslation(\n    projectedPosition,\n    scratchFromENU,\n  );\n  Matrix4.multiply(swizzleMatrix, toENU, result);\n  Matrix4.multiply(translation, result, result);\n\n  return result;\n};\nexport default Transforms;\n"],"mappings":"AAAA,OAAOA,UAAU,MAAM,iBAAiB;AACxC,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,KAAK,MAAM,YAAY;AAC9B,OAAOC,OAAO,MAAM,cAAc;AAClC,OAAOC,cAAc,MAAM,qBAAqB;AAChD,OAAOC,0BAA0B,MAAM,iCAAiC;AACxE,OAAOC,gCAAgC,MAAM,uCAAuC;AACpF,OAAOC,SAAS,MAAM,gBAAgB;AACtC,OAAOC,gBAAgB,MAAM,uBAAuB;AACpD,OAAOC,cAAc,MAAM,qBAAqB;AAChD,OAAOC,gBAAgB,MAAM,uBAAuB;AACpD,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,UAAU,MAAM,WAAW;AAClC,OAAOC,OAAO,MAAM,cAAc;AAClC,OAAOC,OAAO,MAAM,cAAc;AAClC,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,aAAa,MAAM,oBAAoB;;AAE9C;AACA;AACA;AACA;AACA;AACA,MAAMC,UAAU,GAAG,CAAC,CAAC;AAErB,MAAMC,uBAAuB,GAAG;EAC9BC,EAAE,EAAE;IACFC,KAAK,EAAE,MAAM;IACbC,KAAK,EAAE,MAAM;IACbC,IAAI,EAAE,OAAO;IACbC,IAAI,EAAE;EACR,CAAC;EACDC,IAAI,EAAE;IACJJ,KAAK,EAAE,MAAM;IACbC,KAAK,EAAE,MAAM;IACbC,IAAI,EAAE,OAAO;IACbC,IAAI,EAAE;EACR,CAAC;EACDH,KAAK,EAAE;IACLD,EAAE,EAAE,MAAM;IACVK,IAAI,EAAE,MAAM;IACZF,IAAI,EAAE,MAAM;IACZC,IAAI,EAAE;EACR,CAAC;EACDF,KAAK,EAAE;IACLF,EAAE,EAAE,MAAM;IACVK,IAAI,EAAE,MAAM;IACZF,IAAI,EAAE,IAAI;IACVC,IAAI,EAAE;EACR,CAAC;EACDD,IAAI,EAAE;IACJH,EAAE,EAAE,OAAO;IACXK,IAAI,EAAE,OAAO;IACbH,KAAK,EAAE,MAAM;IACbD,KAAK,EAAE;EACT,CAAC;EACDG,IAAI,EAAE;IACJJ,EAAE,EAAE,OAAO;IACXK,IAAI,EAAE,OAAO;IACbH,KAAK,EAAE,IAAI;IACXD,KAAK,EAAE;EACT;AACF,CAAC;AAED,MAAMK,4BAA4B,GAAG;EACnCJ,KAAK,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACjBE,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACfJ,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACbC,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAChBE,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;EAChBE,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AACjB,CAAC;AAED,MAAME,2BAA2B,GAAG,CAAC,CAAC;AAEtC,MAAMC,yBAAyB,GAAG;EAChCJ,IAAI,EAAE,IAAIxB,UAAU,CAAC,CAAC;EACtBsB,KAAK,EAAE,IAAItB,UAAU,CAAC,CAAC;EACvBoB,EAAE,EAAE,IAAIpB,UAAU,CAAC,CAAC;EACpBuB,IAAI,EAAE,IAAIvB,UAAU,CAAC,CAAC;EACtBqB,KAAK,EAAE,IAAIrB,UAAU,CAAC,CAAC;EACvByB,IAAI,EAAE,IAAIzB,UAAU,CAAC;AACvB,CAAC;AACD,IAAI6B,qBAAqB,GAAG,IAAI7B,UAAU,CAAC,CAAC;AAC5C,IAAI8B,sBAAsB,GAAG,IAAI9B,UAAU,CAAC,CAAC;AAC7C,IAAI+B,qBAAqB,GAAG,IAAI/B,UAAU,CAAC,CAAC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAkB,UAAU,CAACc,+BAA+B,GAAG,UAAUC,SAAS,EAAEC,UAAU,EAAE;EAC5E,IACE,CAACf,uBAAuB,CAACgB,cAAc,CAACF,SAAS,CAAC,IAClD,CAACd,uBAAuB,CAACc,SAAS,CAAC,CAACE,cAAc,CAACD,UAAU,CAAC,EAC9D;IACA,MAAM,IAAI7B,cAAc,CACtB,wEACF,CAAC;EACH;EACA,MAAM+B,SAAS,GAAGjB,uBAAuB,CAACc,SAAS,CAAC,CAACC,UAAU,CAAC;;EAEhE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAIG,QAAQ;EACZ,MAAMC,QAAQ,GAAGL,SAAS,GAAGC,UAAU;EACvC,IAAI9B,OAAO,CAACuB,2BAA2B,CAACW,QAAQ,CAAC,CAAC,EAAE;IAClDD,QAAQ,GAAGV,2BAA2B,CAACW,QAAQ,CAAC;EAClD,CAAC,MAAM;IACLD,QAAQ,GAAG,SAAAA,CAAUE,MAAM,EAAEC,SAAS,EAAEC,MAAM,EAAE;MAC9C;MACA,IAAI,CAACrC,OAAO,CAACmC,MAAM,CAAC,EAAE;QACpB,MAAM,IAAIlC,cAAc,CAAC,qBAAqB,CAAC;MACjD;MACA,IAAIqC,KAAK,CAACH,MAAM,CAACI,CAAC,CAAC,IAAID,KAAK,CAACH,MAAM,CAACK,CAAC,CAAC,IAAIF,KAAK,CAACH,MAAM,CAACM,CAAC,CAAC,EAAE;QACzD,MAAM,IAAIxC,cAAc,CAAC,4BAA4B,CAAC;MACxD;MACA;MACA,IAAI,CAACD,OAAO,CAACqC,MAAM,CAAC,EAAE;QACpBA,MAAM,GAAG,IAAI1B,OAAO,CAAC,CAAC;MACxB;MACA,IACEf,UAAU,CAAC8C,aAAa,CAACP,MAAM,EAAEvC,UAAU,CAAC+C,IAAI,EAAElC,UAAU,CAACmC,SAAS,CAAC,EACvE;QACA;QACAhD,UAAU,CAACiD,MAAM,CACfvB,4BAA4B,CAACO,SAAS,CAAC,EACvC,CAAC,EACDJ,qBACF,CAAC;QACD7B,UAAU,CAACiD,MAAM,CACfvB,4BAA4B,CAACQ,UAAU,CAAC,EACxC,CAAC,EACDJ,sBACF,CAAC;QACD9B,UAAU,CAACiD,MAAM,CACfvB,4BAA4B,CAACU,SAAS,CAAC,EACvC,CAAC,EACDL,qBACF,CAAC;MACH,CAAC,MAAM,IACLlB,UAAU,CAACiC,aAAa,CAACP,MAAM,CAACI,CAAC,EAAE,GAAG,EAAE9B,UAAU,CAACmC,SAAS,CAAC,IAC7DnC,UAAU,CAACiC,aAAa,CAACP,MAAM,CAACK,CAAC,EAAE,GAAG,EAAE/B,UAAU,CAACmC,SAAS,CAAC,EAC7D;QACA;QACA,MAAME,IAAI,GAAGrC,UAAU,CAACqC,IAAI,CAACX,MAAM,CAACM,CAAC,CAAC;QAEtC7C,UAAU,CAACiD,MAAM,CACfvB,4BAA4B,CAACO,SAAS,CAAC,EACvC,CAAC,EACDJ,qBACF,CAAC;QACD,IAAII,SAAS,KAAK,MAAM,IAAIA,SAAS,KAAK,MAAM,EAAE;UAChDjC,UAAU,CAACmD,gBAAgB,CACzBtB,qBAAqB,EACrBqB,IAAI,EACJrB,qBACF,CAAC;QACH;QAEA7B,UAAU,CAACiD,MAAM,CACfvB,4BAA4B,CAACQ,UAAU,CAAC,EACxC,CAAC,EACDJ,sBACF,CAAC;QACD,IAAII,UAAU,KAAK,MAAM,IAAIA,UAAU,KAAK,MAAM,EAAE;UAClDlC,UAAU,CAACmD,gBAAgB,CACzBrB,sBAAsB,EACtBoB,IAAI,EACJpB,sBACF,CAAC;QACH;QAEA9B,UAAU,CAACiD,MAAM,CACfvB,4BAA4B,CAACU,SAAS,CAAC,EACvC,CAAC,EACDL,qBACF,CAAC;QACD,IAAIK,SAAS,KAAK,MAAM,IAAIA,SAAS,KAAK,MAAM,EAAE;UAChDpC,UAAU,CAACmD,gBAAgB,CACzBpB,qBAAqB,EACrBmB,IAAI,EACJnB,qBACF,CAAC;QACH;MACF,CAAC,MAAM;QACLS,SAAS,GAAGA,SAAS,IAAIhC,SAAS,CAAC4C,OAAO;QAC1CZ,SAAS,CAACa,qBAAqB,CAACd,MAAM,EAAEX,yBAAyB,CAACR,EAAE,CAAC;QAErE,MAAMA,EAAE,GAAGQ,yBAAyB,CAACR,EAAE;QACvC,MAAMI,IAAI,GAAGI,yBAAyB,CAACJ,IAAI;QAC3CA,IAAI,CAACmB,CAAC,GAAG,CAACJ,MAAM,CAACK,CAAC;QAClBpB,IAAI,CAACoB,CAAC,GAAGL,MAAM,CAACI,CAAC;QACjBnB,IAAI,CAACqB,CAAC,GAAG,GAAG;QACZ7C,UAAU,CAACsD,SAAS,CAAC9B,IAAI,EAAEI,yBAAyB,CAACJ,IAAI,CAAC;QAC1DxB,UAAU,CAACuD,KAAK,CAACnC,EAAE,EAAEI,IAAI,EAAEI,yBAAyB,CAACN,KAAK,CAAC;QAE3DtB,UAAU,CAACmD,gBAAgB,CACzBvB,yBAAyB,CAACR,EAAE,EAC5B,CAAC,CAAC,EACFQ,yBAAyB,CAACH,IAC5B,CAAC;QACDzB,UAAU,CAACmD,gBAAgB,CACzBvB,yBAAyB,CAACJ,IAAI,EAC9B,CAAC,CAAC,EACFI,yBAAyB,CAACL,IAC5B,CAAC;QACDvB,UAAU,CAACmD,gBAAgB,CACzBvB,yBAAyB,CAACN,KAAK,EAC/B,CAAC,CAAC,EACFM,yBAAyB,CAACP,KAC5B,CAAC;QAEDQ,qBAAqB,GAAGD,yBAAyB,CAACK,SAAS,CAAC;QAC5DH,sBAAsB,GAAGF,yBAAyB,CAACM,UAAU,CAAC;QAC9DH,qBAAqB,GAAGH,yBAAyB,CAACQ,SAAS,CAAC;MAC9D;MACAK,MAAM,CAAC,CAAC,CAAC,GAAGZ,qBAAqB,CAACc,CAAC;MACnCF,MAAM,CAAC,CAAC,CAAC,GAAGZ,qBAAqB,CAACe,CAAC;MACnCH,MAAM,CAAC,CAAC,CAAC,GAAGZ,qBAAqB,CAACgB,CAAC;MACnCJ,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG;MACfA,MAAM,CAAC,CAAC,CAAC,GAAGX,sBAAsB,CAACa,CAAC;MACpCF,MAAM,CAAC,CAAC,CAAC,GAAGX,sBAAsB,CAACc,CAAC;MACpCH,MAAM,CAAC,CAAC,CAAC,GAAGX,sBAAsB,CAACe,CAAC;MACpCJ,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG;MACfA,MAAM,CAAC,CAAC,CAAC,GAAGV,qBAAqB,CAACY,CAAC;MACnCF,MAAM,CAAC,CAAC,CAAC,GAAGV,qBAAqB,CAACa,CAAC;MACnCH,MAAM,CAAC,EAAE,CAAC,GAAGV,qBAAqB,CAACc,CAAC;MACpCJ,MAAM,CAAC,EAAE,CAAC,GAAG,GAAG;MAChBA,MAAM,CAAC,EAAE,CAAC,GAAGF,MAAM,CAACI,CAAC;MACrBF,MAAM,CAAC,EAAE,CAAC,GAAGF,MAAM,CAACK,CAAC;MACrBH,MAAM,CAAC,EAAE,CAAC,GAAGF,MAAM,CAACM,CAAC;MACrBJ,MAAM,CAAC,EAAE,CAAC,GAAG,GAAG;MAChB,OAAOA,MAAM;IACf,CAAC;IACDd,2BAA2B,CAACW,QAAQ,CAAC,GAAGD,QAAQ;EAClD;EACA,OAAOA,QAAQ;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAnB,UAAU,CAACsC,uBAAuB,GAAGtC,UAAU,CAACc,+BAA+B,CAC7E,MAAM,EACN,OACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAd,UAAU,CAACuC,yBAAyB,GAClCvC,UAAU,CAACc,+BAA+B,CAAC,OAAO,EAAE,MAAM,CAAC;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAd,UAAU,CAACwC,uBAAuB,GAAGxC,UAAU,CAACc,+BAA+B,CAC7E,OAAO,EACP,IACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAd,UAAU,CAACyC,uBAAuB,GAAGzC,UAAU,CAACc,+BAA+B,CAC7E,OAAO,EACP,MACF,CAAC;AAED,MAAM4B,oBAAoB,GAAG,IAAI5C,UAAU,CAAC,CAAC;AAC7C,MAAM6C,YAAY,GAAG,IAAI7D,UAAU,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AAClD,MAAM8D,iBAAiB,GAAG,IAAI/C,OAAO,CAAC,CAAC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAG,UAAU,CAAC6C,4BAA4B,GAAG,UACxCxB,MAAM,EACNyB,gBAAgB,EAChBxB,SAAS,EACTyB,mBAAmB,EACnBxB,MAAM,EACN;EACA;EACAtC,KAAK,CAAC+D,MAAM,CAACC,MAAM,C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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}