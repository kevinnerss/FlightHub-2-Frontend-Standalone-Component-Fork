{"ast":null,"code":"import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defined from \"../Core/defined.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport Primitive from \"../Scene/Primitive.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport Property from \"./Property.js\";\nconst colorScratch = new Color();\nconst distanceDisplayConditionScratch = new DistanceDisplayCondition();\nconst defaultDistanceDisplayCondition = new DistanceDisplayCondition();\nconst defaultOffset = Cartesian3.ZERO;\nconst offsetScratch = new Cartesian3();\nfunction Batch(primitives, translucent, width, shadows) {\n  this.translucent = translucent;\n  this.width = width;\n  this.shadows = shadows;\n  this.primitives = primitives;\n  this.createPrimitive = false;\n  this.waitingOnCreate = false;\n  this.primitive = undefined;\n  this.oldPrimitive = undefined;\n  this.geometry = new AssociativeArray();\n  this.updaters = new AssociativeArray();\n  this.updatersWithAttributes = new AssociativeArray();\n  this.attributes = new AssociativeArray();\n  this.itemsToRemove = [];\n  this.subscriptions = new AssociativeArray();\n  this.showsUpdated = new AssociativeArray();\n}\nBatch.prototype.add = function (updater, instance) {\n  const id = updater.id;\n  this.createPrimitive = true;\n  this.geometry.set(id, instance);\n  this.updaters.set(id, updater);\n  if (!updater.hasConstantOutline || !updater.outlineColorProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty) || !Property.isConstant(updater.terrainOffsetProperty)) {\n    this.updatersWithAttributes.set(id, updater);\n  } else {\n    const that = this;\n    this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function (entity, propertyName, newValue, oldValue) {\n      if (propertyName === \"isShowing\") {\n        that.showsUpdated.set(updater.id, updater);\n      }\n    }));\n  }\n};\nBatch.prototype.remove = function (updater) {\n  const id = updater.id;\n  this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n  if (this.updaters.remove(id)) {\n    this.updatersWithAttributes.remove(id);\n    const unsubscribe = this.subscriptions.get(id);\n    if (defined(unsubscribe)) {\n      unsubscribe();\n      this.subscriptions.remove(id);\n      this.showsUpdated.remove(id);\n    }\n    return true;\n  }\n  return false;\n};\nBatch.prototype.update = function (time) {\n  let isUpdated = true;\n  let removedCount = 0;\n  let primitive = this.primitive;\n  const primitives = this.primitives;\n  let i;\n  if (this.createPrimitive) {\n    const geometries = this.geometry.values;\n    const geometriesLength = geometries.length;\n    if (geometriesLength > 0) {\n      if (defined(primitive)) {\n        if (!defined(this.oldPrimitive)) {\n          this.oldPrimitive = primitive;\n        } else {\n          primitives.remove(primitive);\n        }\n      }\n      primitive = new Primitive({\n        show: false,\n        asynchronous: true,\n        geometryInstances: geometries.slice(),\n        appearance: new PerInstanceColorAppearance({\n          flat: true,\n          translucent: this.translucent,\n          renderState: {\n            lineWidth: this.width\n          }\n        }),\n        shadows: this.shadows\n      });\n      primitives.add(primitive);\n      isUpdated = false;\n    } else {\n      if (defined(primitive)) {\n        primitives.remove(primitive);\n        primitive = undefined;\n      }\n      const oldPrimitive = this.oldPrimitive;\n      if (defined(oldPrimitive)) {\n        primitives.remove(oldPrimitive);\n        this.oldPrimitive = undefined;\n      }\n    }\n    this.attributes.removeAll();\n    this.primitive = primitive;\n    this.createPrimitive = false;\n    this.waitingOnCreate = true;\n  } else if (defined(primitive) && primitive.ready) {\n    primitive.show = true;\n    if (defined(this.oldPrimitive)) {\n      primitives.remove(this.oldPrimitive);\n      this.oldPrimitive = undefined;\n    }\n    const updatersWithAttributes = this.updatersWithAttributes.values;\n    const length = updatersWithAttributes.length;\n    const waitingOnCreate = this.waitingOnCreate;\n    for (i = 0; i < length; i++) {\n      const updater = updatersWithAttributes[i];\n      const instance = this.geometry.get(updater.id);\n      let attributes = this.attributes.get(instance.id.id);\n      if (!defined(attributes)) {\n        attributes = primitive.getGeometryInstanceAttributes(instance.id);\n        this.attributes.set(instance.id.id, attributes);\n      }\n      if (!updater.outlineColorProperty.isConstant || waitingOnCreate) {\n        const outlineColorProperty = updater.outlineColorProperty;\n        const outlineColor = Property.getValueOrDefault(outlineColorProperty, time, Color.WHITE, colorScratch);\n        if (!Color.equals(attributes._lastColor, outlineColor)) {\n          attributes._lastColor = Color.clone(outlineColor, attributes._lastColor);\n          attributes.color = ColorGeometryInstanceAttribute.toValue(outlineColor, attributes.color);\n          if (this.translucent && attributes.color[3] === 255 || !this.translucent && attributes.color[3] !== 255) {\n            this.itemsToRemove[removedCount++] = updater;\n          }\n        }\n      }\n      const show = updater.entity.isShowing && (updater.hasConstantOutline || updater.isOutlineVisible(time));\n      const currentShow = attributes.show[0] === 1;\n      if (show !== currentShow) {\n        attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n      }\n      const distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n      if (!Property.isConstant(distanceDisplayConditionProperty)) {\n        const distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n        if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n          attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n          attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n        }\n      }\n      const offsetProperty = updater.terrainOffsetProperty;\n      if (!Property.isConstant(offsetProperty)) {\n        const offset = Property.getValueOrDefault(offsetProperty, time, defaultOffset, offsetScratch);\n        if (!Cartesian3.equals(offset, attributes._lastOffset)) {\n          attributes._lastOffset = Cartesian3.clone(offset, attributes._lastOffset);\n          attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n        }\n      }\n    }\n    this.updateShows(primitive);\n    this.waitingOnCreate = false;\n  } else if (defined(primitive) && !primitive.ready) {\n    isUpdated = false;\n  }\n  this.itemsToRemove.length = removedCount;\n  return isUpdated;\n};\nBatch.prototype.updateShows = function (primitive) {\n  const showsUpdated = this.showsUpdated.values;\n  const length = showsUpdated.length;\n  for (let i = 0; i < length; i++) {\n    const updater = showsUpdated[i];\n    const instance = this.geometry.get(updater.id);\n    let attributes = this.attributes.get(instance.id.id);\n    if (!defined(attributes)) {\n      attributes = primitive.getGeometryInstanceAttributes(instance.id);\n      this.attributes.set(instance.id.id, attributes);\n    }\n    const show = updater.entity.isShowing;\n    const currentShow = attributes.show[0] === 1;\n    if (show !== currentShow) {\n      attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n      instance.attributes.show.value[0] = attributes.show[0];\n    }\n  }\n  this.showsUpdated.removeAll();\n};\nBatch.prototype.contains = function (updater) {\n  return this.updaters.contains(updater.id);\n};\nBatch.prototype.getBoundingSphere = function (updater, result) {\n  const primitive = this.primitive;\n  if (!primitive.ready) {\n    return BoundingSphereState.PENDING;\n  }\n  const attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n  if (!defined(attributes) || !defined(attributes.boundingSphere) ||\n  //\n  defined(attributes.show) && attributes.show[0] === 0) {\n    return BoundingSphereState.FAILED;\n  }\n  attributes.boundingSphere.clone(result);\n  return BoundingSphereState.DONE;\n};\nBatch.prototype.removeAllPrimitives = function () {\n  const primitives = this.primitives;\n  const primitive = this.primitive;\n  if (defined(primitive)) {\n    primitives.remove(primitive);\n    this.primitive = undefined;\n    this.geometry.removeAll();\n    this.updaters.removeAll();\n  }\n  const oldPrimitive = this.oldPrimitive;\n  if (defined(oldPrimitive)) {\n    primitives.remove(oldPrimitive);\n    this.oldPrimitive = undefined;\n  }\n};\n\n/**\n * @private\n */\nfunction StaticOutlineGeometryBatch(primitives, scene, shadows) {\n  this._primitives = primitives;\n  this._scene = scene;\n  this._shadows = shadows;\n  this._solidBatches = new AssociativeArray();\n  this._translucentBatches = new AssociativeArray();\n}\nStaticOutlineGeometryBatch.prototype.add = function (time, updater) {\n  const instance = updater.createOutlineGeometryInstance(time);\n  const width = this._scene.clampLineWidth(updater.outlineWidth);\n  let batches;\n  let batch;\n  if (instance.attributes.color.value[3] === 255) {\n    batches = this._solidBatches;\n    batch = batches.get(width);\n    if (!defined(batch)) {\n      batch = new Batch(this._primitives, false, width, this._shadows);\n      batches.set(width, batch);\n    }\n    batch.add(updater, instance);\n  } else {\n    batches = this._translucentBatches;\n    batch = batches.get(width);\n    if (!defined(batch)) {\n      batch = new Batch(this._primitives, true, width, this._shadows);\n      batches.set(width, batch);\n    }\n    batch.add(updater, instance);\n  }\n};\nStaticOutlineGeometryBatch.prototype.remove = function (updater) {\n  let i;\n  const solidBatches = this._solidBatches.values;\n  const solidBatchesLength = solidBatches.length;\n  for (i = 0; i < solidBatchesLength; i++) {\n    if (solidBatches[i].remove(updater)) {\n      return;\n    }\n  }\n  const translucentBatches = this._translucentBatches.values;\n  const translucentBatchesLength = translucentBatches.length;\n  for (i = 0; i < translucentBatchesLength; i++) {\n    if (translucentBatches[i].remove(updater)) {\n      return;\n    }\n  }\n};\nStaticOutlineGeometryBatch.prototype.update = function (time) {\n  let i;\n  let x;\n  let updater;\n  let batch;\n  const solidBatches = this._solidBatches.values;\n  const solidBatchesLength = solidBatches.length;\n  const translucentBatches = this._translucentBatches.values;\n  const translucentBatchesLength = translucentBatches.length;\n  let itemsToRemove;\n  let isUpdated = true;\n  let needUpdate = false;\n  do {\n    needUpdate = false;\n    for (x = 0; x < solidBatchesLength; x++) {\n      batch = solidBatches[x];\n      //Perform initial update\n      isUpdated = batch.update(time);\n\n      //If any items swapped between solid/translucent, we need to\n      //move them between batches\n      itemsToRemove = batch.itemsToRemove;\n      const solidsToMoveLength = itemsToRemove.length;\n      if (solidsToMoveLength > 0) {\n        needUpdate = true;\n        for (i = 0; i < solidsToMoveLength; i++) {\n          updater = itemsToRemove[i];\n          batch.remove(updater);\n          this.add(time, updater);\n        }\n      }\n    }\n    for (x = 0; x < translucentBatchesLength; x++) {\n      batch = translucentBatches[x];\n      //Perform initial update\n      isUpdated = batch.update(time);\n\n      //If any items swapped between solid/translucent, we need to\n      //move them between batches\n      itemsToRemove = batch.itemsToRemove;\n      const translucentToMoveLength = itemsToRemove.length;\n      if (translucentToMoveLength > 0) {\n        needUpdate = true;\n        for (i = 0; i < translucentToMoveLength; i++) {\n          updater = itemsToRemove[i];\n          batch.remove(updater);\n          this.add(time, updater);\n        }\n      }\n    }\n  } while (needUpdate);\n  return isUpdated;\n};\nStaticOutlineGeometryBatch.prototype.getBoundingSphere = function (updater, result) {\n  let i;\n  const solidBatches = this._solidBatches.values;\n  const solidBatchesLength = solidBatches.length;\n  for (i = 0; i < solidBatchesLength; i++) {\n    const solidBatch = solidBatches[i];\n    if (solidBatch.contains(updater)) {\n      return solidBatch.getBoundingSphere(updater, result);\n    }\n  }\n  const translucentBatches = this._translucentBatches.values;\n  const translucentBatchesLength = translucentBatches.length;\n  for (i = 0; i < translucentBatchesLength; i++) {\n    const translucentBatch = translucentBatches[i];\n    if (translucentBatch.contains(updater)) {\n      return translucentBatch.getBoundingSphere(updater, result);\n    }\n  }\n  return BoundingSphereState.FAILED;\n};\nStaticOutlineGeometryBatch.prototype.removeAllPrimitives = function () {\n  let i;\n  const solidBatches = this._solidBatches.values;\n  const solidBatchesLength = solidBatches.length;\n  for (i = 0; i < solidBatchesLength; i++) {\n    solidBatches[i].removeAllPrimitives();\n  }\n  const translucentBatches = this._translucentBatches.values;\n  const translucentBatchesLength = translucentBatches.length;\n  for (i = 0; i < translucentBatchesLength; i++) {\n    translucentBatches[i].removeAllPrimitives();\n  }\n};\nexport default StaticOutlineGeometryBatch;","map":{"version":3,"names":["AssociativeArray","Cartesian3","Color","ColorGeometryInstanceAttribute","defined","DistanceDisplayCondition","DistanceDisplayConditionGeometryInstanceAttribute","OffsetGeometryInstanceAttribute","ShowGeometryInstanceAttribute","PerInstanceColorAppearance","Primitive","BoundingSphereState","Property","colorScratch","distanceDisplayConditionScratch","defaultDistanceDisplayCondition","defaultOffset","ZERO","offsetScratch","Batch","primitives","translucent","width","shadows","createPrimitive","waitingOnCreate","primitive","undefined","oldPrimitive","geometry","updaters","updatersWithAttributes","attributes","itemsToRemove","subscriptions","showsUpdated","prototype","add","updater","instance","id","set","hasConstantOutline","outlineColorProperty","isConstant","distanceDisplayConditionProperty","terrainOffsetProperty","that","entity","definitionChanged","addEventListener","propertyName","newValue","oldValue","remove","unsubscribe","get","update","time","isUpdated","removedCount","i","geometries","values","geometriesLength","length","show","asynchronous","geometryInstances","slice","appearance","flat","renderState","lineWidth","removeAll","ready","getGeometryInstanceAttributes","outlineColor","getValueOrDefault","WHITE","equals","_lastColor","clone","color","toValue","isShowing","isOutlineVisible","currentShow","distanceDisplayCondition","_lastDistanceDisplayCondition","offsetProperty","offset","_lastOffset","updateShows","value","contains","getBoundingSphere","result","PENDING","boundingSphere","FAILED","DONE","removeAllPrimitives","StaticOutlineGeometryBatch","scene","_primitives","_scene","_shadows","_solidBatches","_translucentBatches","createOutlineGeometryInstance","clampLineWidth","outlineWidth","batches","batch","solidBatches","solidBatchesLength","translucentBatches","translucentBatchesLength","x","needUpdate","solidsToMoveLength","translucentToMoveLength","solidBatch","translucentBatch"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/DataSources/StaticOutlineGeometryBatch.js"],"sourcesContent":["import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defined from \"../Core/defined.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport Primitive from \"../Scene/Primitive.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport Property from \"./Property.js\";\n\nconst colorScratch = new Color();\nconst distanceDisplayConditionScratch = new DistanceDisplayCondition();\nconst defaultDistanceDisplayCondition = new DistanceDisplayCondition();\nconst defaultOffset = Cartesian3.ZERO;\nconst offsetScratch = new Cartesian3();\n\nfunction Batch(primitives, translucent, width, shadows) {\n  this.translucent = translucent;\n  this.width = width;\n  this.shadows = shadows;\n  this.primitives = primitives;\n  this.createPrimitive = false;\n  this.waitingOnCreate = false;\n  this.primitive = undefined;\n  this.oldPrimitive = undefined;\n  this.geometry = new AssociativeArray();\n  this.updaters = new AssociativeArray();\n  this.updatersWithAttributes = new AssociativeArray();\n  this.attributes = new AssociativeArray();\n  this.itemsToRemove = [];\n  this.subscriptions = new AssociativeArray();\n  this.showsUpdated = new AssociativeArray();\n}\nBatch.prototype.add = function (updater, instance) {\n  const id = updater.id;\n  this.createPrimitive = true;\n  this.geometry.set(id, instance);\n  this.updaters.set(id, updater);\n  if (\n    !updater.hasConstantOutline ||\n    !updater.outlineColorProperty.isConstant ||\n    !Property.isConstant(updater.distanceDisplayConditionProperty) ||\n    !Property.isConstant(updater.terrainOffsetProperty)\n  ) {\n    this.updatersWithAttributes.set(id, updater);\n  } else {\n    const that = this;\n    this.subscriptions.set(\n      id,\n      updater.entity.definitionChanged.addEventListener(\n        function (entity, propertyName, newValue, oldValue) {\n          if (propertyName === \"isShowing\") {\n            that.showsUpdated.set(updater.id, updater);\n          }\n        },\n      ),\n    );\n  }\n};\n\nBatch.prototype.remove = function (updater) {\n  const id = updater.id;\n  this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n  if (this.updaters.remove(id)) {\n    this.updatersWithAttributes.remove(id);\n    const unsubscribe = this.subscriptions.get(id);\n    if (defined(unsubscribe)) {\n      unsubscribe();\n      this.subscriptions.remove(id);\n      this.showsUpdated.remove(id);\n    }\n    return true;\n  }\n  return false;\n};\n\nBatch.prototype.update = function (time) {\n  let isUpdated = true;\n  let removedCount = 0;\n  let primitive = this.primitive;\n  const primitives = this.primitives;\n  let i;\n\n  if (this.createPrimitive) {\n    const geometries = this.geometry.values;\n    const geometriesLength = geometries.length;\n    if (geometriesLength > 0) {\n      if (defined(primitive)) {\n        if (!defined(this.oldPrimitive)) {\n          this.oldPrimitive = primitive;\n        } else {\n          primitives.remove(primitive);\n        }\n      }\n\n      primitive = new Primitive({\n        show: false,\n        asynchronous: true,\n        geometryInstances: geometries.slice(),\n        appearance: new PerInstanceColorAppearance({\n          flat: true,\n          translucent: this.translucent,\n          renderState: {\n            lineWidth: this.width,\n          },\n        }),\n        shadows: this.shadows,\n      });\n\n      primitives.add(primitive);\n      isUpdated = false;\n    } else {\n      if (defined(primitive)) {\n        primitives.remove(primitive);\n        primitive = undefined;\n      }\n      const oldPrimitive = this.oldPrimitive;\n      if (defined(oldPrimitive)) {\n        primitives.remove(oldPrimitive);\n        this.oldPrimitive = undefined;\n      }\n    }\n\n    this.attributes.removeAll();\n    this.primitive = primitive;\n    this.createPrimitive = false;\n    this.waitingOnCreate = true;\n  } else if (defined(primitive) && primitive.ready) {\n    primitive.show = true;\n    if (defined(this.oldPrimitive)) {\n      primitives.remove(this.oldPrimitive);\n      this.oldPrimitive = undefined;\n    }\n\n    const updatersWithAttributes = this.updatersWithAttributes.values;\n    const length = updatersWithAttributes.length;\n    const waitingOnCreate = this.waitingOnCreate;\n    for (i = 0; i < length; i++) {\n      const updater = updatersWithAttributes[i];\n      const instance = this.geometry.get(updater.id);\n\n      let attributes = this.attributes.get(instance.id.id);\n      if (!defined(attributes)) {\n        attributes = primitive.getGeometryInstanceAttributes(instance.id);\n        this.attributes.set(instance.id.id, attributes);\n      }\n\n      if (!updater.outlineColorProperty.isConstant || waitingOnCreate) {\n        const outlineColorProperty = updater.outlineColorProperty;\n        const outlineColor = Property.getValueOrDefault(\n          outlineColorProperty,\n          time,\n          Color.WHITE,\n          colorScratch,\n        );\n        if (!Color.equals(attributes._lastColor, outlineColor)) {\n          attributes._lastColor = Color.clone(\n            outlineColor,\n            attributes._lastColor,\n          );\n          attributes.color = ColorGeometryInstanceAttribute.toValue(\n            outlineColor,\n            attributes.color,\n          );\n          if (\n            (this.translucent && attributes.color[3] === 255) ||\n            (!this.translucent && attributes.color[3] !== 255)\n          ) {\n            this.itemsToRemove[removedCount++] = updater;\n          }\n        }\n      }\n\n      const show =\n        updater.entity.isShowing &&\n        (updater.hasConstantOutline || updater.isOutlineVisible(time));\n      const currentShow = attributes.show[0] === 1;\n      if (show !== currentShow) {\n        attributes.show = ShowGeometryInstanceAttribute.toValue(\n          show,\n          attributes.show,\n        );\n      }\n\n      const distanceDisplayConditionProperty =\n        updater.distanceDisplayConditionProperty;\n      if (!Property.isConstant(distanceDisplayConditionProperty)) {\n        const distanceDisplayCondition = Property.getValueOrDefault(\n          distanceDisplayConditionProperty,\n          time,\n          defaultDistanceDisplayCondition,\n          distanceDisplayConditionScratch,\n        );\n        if (\n          !DistanceDisplayCondition.equals(\n            distanceDisplayCondition,\n            attributes._lastDistanceDisplayCondition,\n          )\n        ) {\n          attributes._lastDistanceDisplayCondition =\n            DistanceDisplayCondition.clone(\n              distanceDisplayCondition,\n              attributes._lastDistanceDisplayCondition,\n            );\n          attributes.distanceDisplayCondition =\n            DistanceDisplayConditionGeometryInstanceAttribute.toValue(\n              distanceDisplayCondition,\n              attributes.distanceDisplayCondition,\n            );\n        }\n      }\n\n      const offsetProperty = updater.terrainOffsetProperty;\n      if (!Property.isConstant(offsetProperty)) {\n        const offset = Property.getValueOrDefault(\n          offsetProperty,\n          time,\n          defaultOffset,\n          offsetScratch,\n        );\n        if (!Cartesian3.equals(offset, attributes._lastOffset)) {\n          attributes._lastOffset = Cartesian3.clone(\n            offset,\n            attributes._lastOffset,\n          );\n          attributes.offset = OffsetGeometryInstanceAttribute.toValue(\n            offset,\n            attributes.offset,\n          );\n        }\n      }\n    }\n\n    this.updateShows(primitive);\n    this.waitingOnCreate = false;\n  } else if (defined(primitive) && !primitive.ready) {\n    isUpdated = false;\n  }\n\n  this.itemsToRemove.length = removedCount;\n  return isUpdated;\n};\n\nBatch.prototype.updateShows = function (primitive) {\n  const showsUpdated = this.showsUpdated.values;\n  const length = showsUpdated.length;\n  for (let i = 0; i < length; i++) {\n    const updater = showsUpdated[i];\n    const instance = this.geometry.get(updater.id);\n\n    let attributes = this.attributes.get(instance.id.id);\n    if (!defined(attributes)) {\n      attributes = primitive.getGeometryInstanceAttributes(instance.id);\n      this.attributes.set(instance.id.id, attributes);\n    }\n\n    const show = updater.entity.isShowing;\n    const currentShow = attributes.show[0] === 1;\n    if (show !== currentShow) {\n      attributes.show = ShowGeometryInstanceAttribute.toValue(\n        show,\n        attributes.show,\n      );\n      instance.attributes.show.value[0] = attributes.show[0];\n    }\n  }\n  this.showsUpdated.removeAll();\n};\n\nBatch.prototype.contains = function (updater) {\n  return this.updaters.contains(updater.id);\n};\n\nBatch.prototype.getBoundingSphere = function (updater, result) {\n  const primitive = this.primitive;\n  if (!primitive.ready) {\n    return BoundingSphereState.PENDING;\n  }\n  const attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n  if (\n    !defined(attributes) ||\n    !defined(attributes.boundingSphere) || //\n    (defined(attributes.show) && attributes.show[0] === 0)\n  ) {\n    return BoundingSphereState.FAILED;\n  }\n  attributes.boundingSphere.clone(result);\n  return BoundingSphereState.DONE;\n};\n\nBatch.prototype.removeAllPrimitives = function () {\n  const primitives = this.primitives;\n\n  const primitive = this.primitive;\n  if (defined(primitive)) {\n    primitives.remove(primitive);\n    this.primitive = undefined;\n    this.geometry.removeAll();\n    this.updaters.removeAll();\n  }\n\n  const oldPrimitive = this.oldPrimitive;\n  if (defined(oldPrimitive)) {\n    primitives.remove(oldPrimitive);\n    this.oldPrimitive = undefined;\n  }\n};\n\n/**\n * @private\n */\nfunction StaticOutlineGeometryBatch(primitives, scene, shadows) {\n  this._primitives = primitives;\n  this._scene = scene;\n  this._shadows = shadows;\n  this._solidBatches = new AssociativeArray();\n  this._translucentBatches = new AssociativeArray();\n}\nStaticOutlineGeometryBatch.prototype.add = function (time, updater) {\n  const instance = updater.createOutlineGeometryInstance(time);\n  const width = this._scene.clampLineWidth(updater.outlineWidth);\n  let batches;\n  let batch;\n  if (instance.attributes.color.value[3] === 255) {\n    batches = this._solidBatches;\n    batch = batches.get(width);\n    if (!defined(batch)) {\n      batch = new Batch(this._primitives, false, width, this._shadows);\n      batches.set(width, batch);\n    }\n    batch.add(updater, instance);\n  } else {\n    batches = this._translucentBatches;\n    batch = batches.get(width);\n    if (!defined(batch)) {\n      batch = new Batch(this._primitives, true, width, this._shadows);\n      batches.set(width, batch);\n    }\n    batch.add(updater, instance);\n  }\n};\n\nStaticOutlineGeometryBatch.prototype.remove = function (updater) {\n  let i;\n\n  const solidBatches = this._solidBatches.values;\n  const solidBatchesLength = solidBatches.length;\n  for (i = 0; i < solidBatchesLength; i++) {\n    if (solidBatches[i].remove(updater)) {\n      return;\n    }\n  }\n\n  const translucentBatches = this._translucentBatches.values;\n  const translucentBatchesLength = translucentBatches.length;\n  for (i = 0; i < translucentBatchesLength; i++) {\n    if (translucentBatches[i].remove(updater)) {\n      return;\n    }\n  }\n};\n\nStaticOutlineGeometryBatch.prototype.update = function (time) {\n  let i;\n  let x;\n  let updater;\n  let batch;\n  const solidBatches = this._solidBatches.values;\n  const solidBatchesLength = solidBatches.length;\n  const translucentBatches = this._translucentBatches.values;\n  const translucentBatchesLength = translucentBatches.length;\n  let itemsToRemove;\n  let isUpdated = true;\n  let needUpdate = false;\n\n  do {\n    needUpdate = false;\n    for (x = 0; x < solidBatchesLength; x++) {\n      batch = solidBatches[x];\n      //Perform initial update\n      isUpdated = batch.update(time);\n\n      //If any items swapped between solid/translucent, we need to\n      //move them between batches\n      itemsToRemove = batch.itemsToRemove;\n      const solidsToMoveLength = itemsToRemove.length;\n      if (solidsToMoveLength > 0) {\n        needUpdate = true;\n        for (i = 0; i < solidsToMoveLength; i++) {\n          updater = itemsToRemove[i];\n          batch.remove(updater);\n          this.add(time, updater);\n        }\n      }\n    }\n    for (x = 0; x < translucentBatchesLength; x++) {\n      batch = translucentBatches[x];\n      //Perform initial update\n      isUpdated = batch.update(time);\n\n      //If any items swapped between solid/translucent, we need to\n      //move them between batches\n      itemsToRemove = batch.itemsToRemove;\n      const translucentToMoveLength = itemsToRemove.length;\n      if (translucentToMoveLength > 0) {\n        needUpdate = true;\n        for (i = 0; i < translucentToMoveLength; i++) {\n          updater = itemsToRemove[i];\n          batch.remove(updater);\n          this.add(time, updater);\n        }\n      }\n    }\n  } while (needUpdate);\n\n  return isUpdated;\n};\n\nStaticOutlineGeometryBatch.prototype.getBoundingSphere = function (\n  updater,\n  result,\n) {\n  let i;\n\n  const solidBatches = this._solidBatches.values;\n  const solidBatchesLength = solidBatches.length;\n  for (i = 0; i < solidBatchesLength; i++) {\n    const solidBatch = solidBatches[i];\n    if (solidBatch.contains(updater)) {\n      return solidBatch.getBoundingSphere(updater, result);\n    }\n  }\n\n  const translucentBatches = this._translucentBatches.values;\n  const translucentBatchesLength = translucentBatches.length;\n  for (i = 0; i < translucentBatchesLength; i++) {\n    const translucentBatch = translucentBatches[i];\n    if (translucentBatch.contains(updater)) {\n      return translucentBatch.getBoundingSphere(updater, result);\n    }\n  }\n\n  return BoundingSphereState.FAILED;\n};\n\nStaticOutlineGeometryBatch.prototype.removeAllPrimitives = function () {\n  let i;\n\n  const solidBatches = this._solidBatches.values;\n  const solidBatchesLength = solidBatches.length;\n  for (i = 0; i < solidBatchesLength; i++) {\n    solidBatches[i].removeAllPrimitives();\n  }\n\n  const translucentBatches = this._translucentBatches.values;\n  const translucentBatchesLength = translucentBatches.length;\n  for (i = 0; i < translucentBatchesLength; i++) {\n    translucentBatches[i].removeAllPrimitives();\n  }\n};\nexport default StaticOutlineGeometryBatch;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}