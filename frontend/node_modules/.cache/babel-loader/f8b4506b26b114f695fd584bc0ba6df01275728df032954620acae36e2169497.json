{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"// See Intersection.glsl for the definition of intersectScene\\n\\\n// See IntersectionUtils.glsl for the definition of nextIntersection\\n\\\n// See convertLocalToBoxUv.glsl, convertLocalToCylinderUv.glsl, or convertLocalToEllipsoidUv.glsl\\n\\\n// for the definitions of convertLocalToShapeSpaceDerivative and getTileAndUvCoordinate. \\n\\\n// The appropriate functions are selected based on the VoxelPrimitive shape type, \\n\\\n// and added to the shader in Scene/VoxelRenderResources.js.\\n\\\n// See Octree.glsl for the definitions of TraversalData, SampleData,\\n\\\n// traverseOctreeFromBeginning, and traverseOctreeFromExisting\\n\\\n// See Megatexture.glsl for the definition of accumulatePropertiesFromMegatexture\\n\\\n\\n\\\n#define STEP_COUNT_MAX 1000 // Harcoded value because GLSL doesn't like variable length loops\\n\\\n#if defined(PICKING_VOXEL)\\n\\\n    #define ALPHA_ACCUM_MAX 0.1\\n\\\n#else\\n\\\n    #define ALPHA_ACCUM_MAX 0.98 // Must be > 0.0 and <= 1.0\\n\\\n#endif\\n\\\n\\n\\\nuniform mat4 u_transformPositionViewToLocal;\\n\\\nuniform mat3 u_transformDirectionViewToLocal;\\n\\\nuniform vec3 u_cameraPositionLocal;\\n\\\nuniform vec3 u_cameraDirectionLocal;\\n\\\nuniform float u_stepSize;\\n\\\n\\n\\\n#if defined(PICKING)\\n\\\n    uniform vec4 u_pickColor;\\n\\\n#endif\\n\\\n\\n\\\nvec3 getSampleSize(in int level) {\\n\\\n    vec3 sampleCount = exp2(float(level)) * vec3(u_dimensions);\\n\\\n    vec3 sampleSizeUv = 1.0 / sampleCount;\\n\\\n    return scaleShapeUvToShapeSpace(sampleSizeUv);\\n\\\n}\\n\\\n\\n\\\n#define MINIMUM_STEP_SCALAR (0.02)\\n\\\n#define SHIFT_FRACTION (0.001)\\n\\\n\\n\\\n/**\\n\\\n * Given a coordinate within a tile, and sample spacings along a ray through\\n\\\n * the coordinate, find the distance to the points where the ray entered and\\n\\\n * exited the voxel cell, along with the surface normals at those points.\\n\\\n * The surface normals are returned in shape space coordinates.\\n\\\n */\\n\\\nRayShapeIntersection getVoxelIntersection(in vec3 tileUv, in vec3 sampleSizeAlongRay) {\\n\\\n    vec3 voxelCoord = tileUv * vec3(u_dimensions);\\n\\\n    vec3 directions = sign(sampleSizeAlongRay);\\n\\\n    vec3 positiveDirections = max(directions, 0.0);\\n\\\n    vec3 entryCoord = mix(ceil(voxelCoord), floor(voxelCoord), positiveDirections);\\n\\\n    vec3 exitCoord = entryCoord + directions;\\n\\\n\\n\\\n    vec3 distanceFromEntry = -abs((entryCoord - voxelCoord) * sampleSizeAlongRay);\\n\\\n    float lastEntry = maxComponent(distanceFromEntry);\\n\\\n    bvec3 isLastEntry = equal(distanceFromEntry, vec3(lastEntry));\\n\\\n    vec3 entryNormal = -1.0 * vec3(isLastEntry) * directions;\\n\\\n    vec4 entry = vec4(entryNormal, lastEntry);\\n\\\n\\n\\\n    vec3 distanceToExit = abs((exitCoord - voxelCoord) * sampleSizeAlongRay);\\n\\\n    float firstExit = minComponent(distanceToExit);\\n\\\n    bvec3 isFirstExit = equal(distanceToExit, vec3(firstExit));\\n\\\n    vec3 exitNormal = vec3(isFirstExit) * directions;\\n\\\n    vec4 exit = vec4(exitNormal, firstExit);\\n\\\n\\n\\\n    return RayShapeIntersection(entry, exit);\\n\\\n}\\n\\\n\\n\\\nvec4 getStepSize(in SampleData sampleData, in Ray viewRay, in RayShapeIntersection shapeIntersection, in mat3 jacobianT, in float currentT) {\\n\\\n    vec3 gradient = viewRay.dir * jacobianT;\\n\\\n    vec3 sampleSizeAlongRay = getSampleSize(sampleData.tileCoords.w) / gradient;\\n\\\n\\n\\\n    RayShapeIntersection voxelIntersection = getVoxelIntersection(sampleData.tileUv, sampleSizeAlongRay);\\n\\\n\\n\\\n    // Transform normal from shape space to Cartesian space to eye space\\n\\\n    vec3 voxelNormal = jacobianT * voxelIntersection.entry.xyz;\\n\\\n    voxelNormal = normalize(czm_normal * voxelNormal);\\n\\\n\\n\\\n    // Compare with the shape intersection, to choose the appropriate normal\\n\\\n    vec4 voxelEntry = vec4(voxelNormal, currentT + voxelIntersection.entry.w);\\n\\\n    vec4 entry = intersectionMax(shapeIntersection.entry, voxelEntry);\\n\\\n\\n\\\n    float fixedStep = minComponent(abs(sampleSizeAlongRay)) * u_stepSize;\\n\\\n    float shift = fixedStep * SHIFT_FRACTION;\\n\\\n    float dt = voxelIntersection.exit.w + shift;\\n\\\n    if ((currentT + dt) > shapeIntersection.exit.w) {\\n\\\n        // Stop at end of shape\\n\\\n        dt = shapeIntersection.exit.w - currentT + shift;\\n\\\n    }\\n\\\n    float stepSize = clamp(dt, fixedStep * MINIMUM_STEP_SCALAR, fixedStep + shift);\\n\\\n\\n\\\n    return vec4(entry.xyz, stepSize);\\n\\\n}\\n\\\n\\n\\\nvec2 packIntToVec2(int value) {\\n\\\n    float shifted = float(value) / 255.0;\\n\\\n    float lowBits = fract(shifted);\\n\\\n    float highBits = floor(shifted) / 255.0;\\n\\\n    return vec2(highBits, lowBits);\\n\\\n}\\n\\\n\\n\\\nvec2 packFloatToVec2(float value) {\\n\\\n    float lowBits = fract(value);\\n\\\n    float highBits = floor(value) / 255.0;\\n\\\n    return vec2(highBits, lowBits);\\n\\\n}\\n\\\n\\n\\\nint getSampleIndex(in SampleData sampleData) {\\n\\\n    // tileUv = 1.0 is a valid coordinate but sampleIndex = u_inputDimensions is not.\\n\\\n    // (tileUv = 1.0 corresponds to the far edge of the last sample, at index = u_inputDimensions - 1).\\n\\\n    // Clamp to [0, voxelDimensions - 0.5) to avoid numerical error before flooring\\n\\\n    vec3 maxCoordinate = vec3(u_inputDimensions) - vec3(0.5);\\n\\\n    vec3 inputCoordinate = clamp(sampleData.inputCoordinate, vec3(0.0), maxCoordinate);\\n\\\n    ivec3 sampleIndex = ivec3(floor(inputCoordinate));\\n\\\n    // Convert to a 1D index for lookup in a 1D data array\\n\\\n    return sampleIndex.x + u_inputDimensions.x * (sampleIndex.y + u_inputDimensions.y * sampleIndex.z);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Compute the view ray at the current fragment, in the local coordinates of the shape.\\n\\\n */\\n\\\nRay getViewRayLocal() {\\n\\\n    vec4 eyeCoordinates = czm_windowToEyeCoordinates(gl_FragCoord);\\n\\\n    vec3 origin;\\n\\\n    vec3 direction;\\n\\\n    if (czm_orthographicIn3D == 1.0) {\\n\\\n        eyeCoordinates.z = 0.0;\\n\\\n        origin = (u_transformPositionViewToLocal * eyeCoordinates).xyz;\\n\\\n        direction = u_cameraDirectionLocal;\\n\\\n    } else {\\n\\\n        origin = u_cameraPositionLocal;\\n\\\n        direction = u_transformDirectionViewToLocal * normalize(eyeCoordinates.xyz);\\n\\\n    }\\n\\\n    return Ray(origin, direction);\\n\\\n}\\n\\\n\\n\\\nRay getViewRayEC() {\\n\\\n    vec4 eyeCoordinates = czm_windowToEyeCoordinates(gl_FragCoord);\\n\\\n    vec3 viewPosEC = (czm_orthographicIn3D == 1.0)\\n\\\n        ? vec3(eyeCoordinates.xy, 0.0)\\n\\\n        : vec3(0.0);\\n\\\n    vec3 viewDirEC = normalize(eyeCoordinates.xyz);\\n\\\n    return Ray(viewPosEC, viewDirEC);\\n\\\n}\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    Ray viewRayLocal = getViewRayLocal();\\n\\\n    Ray viewRayEC = getViewRayEC();\\n\\\n\\n\\\n    Intersections ix;\\n\\\n    vec2 screenCoord = (gl_FragCoord.xy - czm_viewport.xy) / czm_viewport.zw; // [0,1]\\n\\\n    RayShapeIntersection shapeIntersection = intersectScene(screenCoord, viewRayLocal, viewRayEC, ix);\\n\\\n    // Exit early if the scene was completely missed.\\n\\\n    if (shapeIntersection.entry.w == NO_HIT) {\\n\\\n        discard;\\n\\\n    }\\n\\\n\\n\\\n    float currentT = shapeIntersection.entry.w;\\n\\\n    float endT = shapeIntersection.exit.w;\\n\\\n\\n\\\n    vec3 positionEC = viewRayEC.pos + currentT * viewRayEC.dir;\\n\\\n    TileAndUvCoordinate tileAndUv = getTileAndUvCoordinate(positionEC);\\n\\\n    vec3 positionLocal = viewRayLocal.pos + currentT * viewRayLocal.dir;\\n\\\n    mat3 jacobianT = convertLocalToShapeSpaceDerivative(positionLocal);\\n\\\n\\n\\\n    // Traverse the tree from the start position\\n\\\n    TraversalData traversalData;\\n\\\n    SampleData sampleDatas[SAMPLE_COUNT];\\n\\\n    traverseOctreeFromBeginning(tileAndUv, traversalData, sampleDatas);\\n\\\n    vec4 step = getStepSize(sampleDatas[0], viewRayLocal, shapeIntersection, jacobianT, currentT);\\n\\\n\\n\\\n    FragmentInput fragmentInput;\\n\\\n    #if defined(STATISTICS)\\n\\\n        setStatistics(fragmentInput.metadataStatistics);\\n\\\n    #endif\\n\\\n\\n\\\n    czm_modelMaterial materialOutput;\\n\\\n    vec4 colorAccum = vec4(0.0);\\n\\\n\\n\\\n    for (int stepCount = 0; stepCount < STEP_COUNT_MAX; ++stepCount) {\\n\\\n        // Read properties from the megatexture based on the traversal state\\n\\\n        Properties properties = accumulatePropertiesFromMegatexture(sampleDatas);\\n\\\n\\n\\\n        // Prepare the custom shader inputs\\n\\\n        copyPropertiesToMetadata(properties, fragmentInput.metadata);\\n\\\n\\n\\\n        fragmentInput.attributes.positionEC = positionEC;\\n\\\n        // Re-normalize normals: some shape intersections may have been scaled to encode positive/negative shapes\\n\\\n        fragmentInput.attributes.normalEC = normalize(step.xyz);\\n\\\n\\n\\\n        fragmentInput.voxel.viewDirUv = viewRayLocal.dir;\\n\\\n\\n\\\n        fragmentInput.voxel.travelDistance = step.w;\\n\\\n        fragmentInput.voxel.stepCount = stepCount;\\n\\\n        fragmentInput.voxel.tileIndex = sampleDatas[0].megatextureIndex;\\n\\\n        fragmentInput.voxel.sampleIndex = getSampleIndex(sampleDatas[0]);\\n\\\n        fragmentInput.voxel.distanceToDepthBuffer = ix.distanceToDepthBuffer - currentT;\\n\\\n\\n\\\n        // Run the custom shader\\n\\\n        fragmentMain(fragmentInput, materialOutput);\\n\\\n\\n\\\n        // Sanitize the custom shader output\\n\\\n        vec4 color = vec4(materialOutput.diffuse, materialOutput.alpha);\\n\\\n        color.rgb = max(color.rgb, vec3(0.0));\\n\\\n        color.a = clamp(color.a, 0.0, 1.0);\\n\\\n\\n\\\n        // Pre-multiplied alpha blend\\n\\\n        colorAccum += (1.0 - colorAccum.a) * vec4(color.rgb * color.a, color.a);\\n\\\n\\n\\\n        // Stop traversing if the alpha has been fully saturated\\n\\\n        if (colorAccum.a > ALPHA_ACCUM_MAX) {\\n\\\n            colorAccum.a = ALPHA_ACCUM_MAX;\\n\\\n            break;\\n\\\n        }\\n\\\n\\n\\\n        if (step.w == 0.0) {\\n\\\n            // Shape is infinitely thin. The ray may have hit the edge of a\\n\\\n            // foreground voxel. Step ahead slightly to check for more voxels\\n\\\n            step.w == 0.00001;\\n\\\n        }\\n\\\n\\n\\\n        // Keep raymarching\\n\\\n        currentT += step.w;\\n\\\n        // Check if there's more intersections.\\n\\\n        if (currentT > endT) {\\n\\\n            #if (INTERSECTION_COUNT == 1)\\n\\\n                break;\\n\\\n            #else\\n\\\n                shapeIntersection = nextIntersection(ix);\\n\\\n                if (shapeIntersection.entry.w == NO_HIT) {\\n\\\n                    break;\\n\\\n                } else {\\n\\\n                    // Found another intersection. Resume raymarching there\\n\\\n                    currentT = shapeIntersection.entry.w;\\n\\\n                    endT = shapeIntersection.exit.w;\\n\\\n                }\\n\\\n            #endif\\n\\\n        }\\n\\\n        positionEC = viewRayEC.pos + currentT * viewRayEC.dir;\\n\\\n        tileAndUv = getTileAndUvCoordinate(positionEC);\\n\\\n        positionLocal = viewRayLocal.pos + currentT * viewRayLocal.dir;\\n\\\n        jacobianT = convertLocalToShapeSpaceDerivative(positionLocal);\\n\\\n\\n\\\n        // Traverse the tree from the current ray position.\\n\\\n        // This is similar to traverseOctreeFromBeginning but is faster when the ray is in the same tile as the previous step.\\n\\\n        traverseOctreeFromExisting(tileAndUv, traversalData, sampleDatas);\\n\\\n        step = getStepSize(sampleDatas[0], viewRayLocal, shapeIntersection, jacobianT, currentT);\\n\\\n    }\\n\\\n\\n\\\n    // Convert the alpha from [0,ALPHA_ACCUM_MAX] to [0,1]\\n\\\n    colorAccum.a /= ALPHA_ACCUM_MAX;\\n\\\n\\n\\\n    #if defined(PICKING)\\n\\\n        // If alpha is 0.0 there is nothing to pick\\n\\\n        if (colorAccum.a == 0.0) {\\n\\\n            discard;\\n\\\n        }\\n\\\n        out_FragColor = u_pickColor;\\n\\\n    #elif defined(PICKING_VOXEL)\\n\\\n        // If alpha is 0.0 there is nothing to pick\\n\\\n        if (colorAccum.a == 0.0) {\\n\\\n            discard;\\n\\\n        }\\n\\\n        vec2 megatextureId = packIntToVec2(sampleDatas[0].megatextureIndex);\\n\\\n        vec2 sampleIndex = packIntToVec2(getSampleIndex(sampleDatas[0]));\\n\\\n        out_FragColor = vec4(megatextureId, sampleIndex);\\n\\\n    #else\\n\\\n        out_FragColor = colorAccum;\\n\\\n    #endif\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Shaders/Voxels/VoxelFS.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"// See Intersection.glsl for the definition of intersectScene\\n\\\n// See IntersectionUtils.glsl for the definition of nextIntersection\\n\\\n// See convertLocalToBoxUv.glsl, convertLocalToCylinderUv.glsl, or convertLocalToEllipsoidUv.glsl\\n\\\n// for the definitions of convertLocalToShapeSpaceDerivative and getTileAndUvCoordinate. \\n\\\n// The appropriate functions are selected based on the VoxelPrimitive shape type, \\n\\\n// and added to the shader in Scene/VoxelRenderResources.js.\\n\\\n// See Octree.glsl for the definitions of TraversalData, SampleData,\\n\\\n// traverseOctreeFromBeginning, and traverseOctreeFromExisting\\n\\\n// See Megatexture.glsl for the definition of accumulatePropertiesFromMegatexture\\n\\\n\\n\\\n#define STEP_COUNT_MAX 1000 // Harcoded value because GLSL doesn't like variable length loops\\n\\\n#if defined(PICKING_VOXEL)\\n\\\n    #define ALPHA_ACCUM_MAX 0.1\\n\\\n#else\\n\\\n    #define ALPHA_ACCUM_MAX 0.98 // Must be > 0.0 and <= 1.0\\n\\\n#endif\\n\\\n\\n\\\nuniform mat4 u_transformPositionViewToLocal;\\n\\\nuniform mat3 u_transformDirectionViewToLocal;\\n\\\nuniform vec3 u_cameraPositionLocal;\\n\\\nuniform vec3 u_cameraDirectionLocal;\\n\\\nuniform float u_stepSize;\\n\\\n\\n\\\n#if defined(PICKING)\\n\\\n    uniform vec4 u_pickColor;\\n\\\n#endif\\n\\\n\\n\\\nvec3 getSampleSize(in int level) {\\n\\\n    vec3 sampleCount = exp2(float(level)) * vec3(u_dimensions);\\n\\\n    vec3 sampleSizeUv = 1.0 / sampleCount;\\n\\\n    return scaleShapeUvToShapeSpace(sampleSizeUv);\\n\\\n}\\n\\\n\\n\\\n#define MINIMUM_STEP_SCALAR (0.02)\\n\\\n#define SHIFT_FRACTION (0.001)\\n\\\n\\n\\\n/**\\n\\\n * Given a coordinate within a tile, and sample spacings along a ray through\\n\\\n * the coordinate, find the distance to the points where the ray entered and\\n\\\n * exited the voxel cell, along with the surface normals at those points.\\n\\\n * The surface normals are returned in shape space coordinates.\\n\\\n */\\n\\\nRayShapeIntersection getVoxelIntersection(in vec3 tileUv, in vec3 sampleSizeAlongRay) {\\n\\\n    vec3 voxelCoord = tileUv * vec3(u_dimensions);\\n\\\n    vec3 directions = sign(sampleSizeAlongRay);\\n\\\n    vec3 positiveDirections = max(directions, 0.0);\\n\\\n    vec3 entryCoord = mix(ceil(voxelCoord), floor(voxelCoord), positiveDirections);\\n\\\n    vec3 exitCoord = entryCoord + directions;\\n\\\n\\n\\\n    vec3 distanceFromEntry = -abs((entryCoord - voxelCoord) * sampleSizeAlongRay);\\n\\\n    float lastEntry = maxComponent(distanceFromEntry);\\n\\\n    bvec3 isLastEntry = equal(distanceFromEntry, vec3(lastEntry));\\n\\\n    vec3 entryNormal = -1.0 * vec3(isLastEntry) * directions;\\n\\\n    vec4 entry = vec4(entryNormal, lastEntry);\\n\\\n\\n\\\n    vec3 distanceToExit = abs((exitCoord - voxelCoord) * sampleSizeAlongRay);\\n\\\n    float firstExit = minComponent(distanceToExit);\\n\\\n    bvec3 isFirstExit = equal(distanceToExit, vec3(firstExit));\\n\\\n    vec3 exitNormal = vec3(isFirstExit) * directions;\\n\\\n    vec4 exit = vec4(exitNormal, firstExit);\\n\\\n\\n\\\n    return RayShapeIntersection(entry, exit);\\n\\\n}\\n\\\n\\n\\\nvec4 getStepSize(in SampleData sampleData, in Ray viewRay, in RayShapeIntersection shapeIntersection, in mat3 jacobianT, in float currentT) {\\n\\\n    vec3 gradient = viewRay.dir * jacobianT;\\n\\\n    vec3 sampleSizeAlongRay = getSampleSize(sampleData.tileCoords.w) / gradient;\\n\\\n\\n\\\n    RayShapeIntersection voxelIntersection = getVoxelIntersection(sampleData.tileUv, sampleSizeAlongRay);\\n\\\n\\n\\\n    // Transform normal from shape space to Cartesian space to eye space\\n\\\n    vec3 voxelNormal = jacobianT * voxelIntersection.entry.xyz;\\n\\\n    voxelNormal = normalize(czm_normal * voxelNormal);\\n\\\n\\n\\\n    // Compare with the shape intersection, to choose the appropriate normal\\n\\\n    vec4 voxelEntry = vec4(voxelNormal, currentT + voxelIntersection.entry.w);\\n\\\n    vec4 entry = intersectionMax(shapeIntersection.entry, voxelEntry);\\n\\\n\\n\\\n    float fixedStep = minComponent(abs(sampleSizeAlongRay)) * u_stepSize;\\n\\\n    float shift = fixedStep * SHIFT_FRACTION;\\n\\\n    float dt = voxelIntersection.exit.w + shift;\\n\\\n    if ((currentT + dt) > shapeIntersection.exit.w) {\\n\\\n        // Stop at end of shape\\n\\\n        dt = shapeIntersection.exit.w - currentT + shift;\\n\\\n    }\\n\\\n    float stepSize = clamp(dt, fixedStep * MINIMUM_STEP_SCALAR, fixedStep + shift);\\n\\\n\\n\\\n    return vec4(entry.xyz, stepSize);\\n\\\n}\\n\\\n\\n\\\nvec2 packIntToVec2(int value) {\\n\\\n    float shifted = float(value) / 255.0;\\n\\\n    float lowBits = fract(shifted);\\n\\\n    float highBits = floor(shifted) / 255.0;\\n\\\n    return vec2(highBits, lowBits);\\n\\\n}\\n\\\n\\n\\\nvec2 packFloatToVec2(float value) {\\n\\\n    float lowBits = fract(value);\\n\\\n    float highBits = floor(value) / 255.0;\\n\\\n    return vec2(highBits, lowBits);\\n\\\n}\\n\\\n\\n\\\nint getSampleIndex(in SampleData sampleData) {\\n\\\n    // tileUv = 1.0 is a valid coordinate but sampleIndex = u_inputDimensions is not.\\n\\\n    // (tileUv = 1.0 corresponds to the far edge of the last sample, at index = u_inputDimensions - 1).\\n\\\n    // Clamp to [0, voxelDimensions - 0.5) to avoid numerical error before flooring\\n\\\n    vec3 maxCoordinate = vec3(u_inputDimensions) - vec3(0.5);\\n\\\n    vec3 inputCoordinate = clamp(sampleData.inputCoordinate, vec3(0.0), maxCoordinate);\\n\\\n    ivec3 sampleIndex = ivec3(floor(inputCoordinate));\\n\\\n    // Convert to a 1D index for lookup in a 1D data array\\n\\\n    return sampleIndex.x + u_inputDimensions.x * (sampleIndex.y + u_inputDimensions.y * sampleIndex.z);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Compute the view ray at the current fragment, in the local coordinates of the shape.\\n\\\n */\\n\\\nRay getViewRayLocal() {\\n\\\n    vec4 eyeCoordinates = czm_windowToEyeCoordinates(gl_FragCoord);\\n\\\n    vec3 origin;\\n\\\n    vec3 direction;\\n\\\n    if (czm_orthographicIn3D == 1.0) {\\n\\\n        eyeCoordinates.z = 0.0;\\n\\\n        origin = (u_transformPositionViewToLocal * eyeCoordinates).xyz;\\n\\\n        direction = u_cameraDirectionLocal;\\n\\\n    } else {\\n\\\n        origin = u_cameraPositionLocal;\\n\\\n        direction = u_transformDirectionViewToLocal * normalize(eyeCoordinates.xyz);\\n\\\n    }\\n\\\n    return Ray(origin, direction);\\n\\\n}\\n\\\n\\n\\\nRay getViewRayEC() {\\n\\\n    vec4 eyeCoordinates = czm_windowToEyeCoordinates(gl_FragCoord);\\n\\\n    vec3 viewPosEC = (czm_orthographicIn3D == 1.0)\\n\\\n        ? vec3(eyeCoordinates.xy, 0.0)\\n\\\n        : vec3(0.0);\\n\\\n    vec3 viewDirEC = normalize(eyeCoordinates.xyz);\\n\\\n    return Ray(viewPosEC, viewDirEC);\\n\\\n}\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    Ray viewRayLocal = getViewRayLocal();\\n\\\n    Ray viewRayEC = getViewRayEC();\\n\\\n\\n\\\n    Intersections ix;\\n\\\n    vec2 screenCoord = (gl_FragCoord.xy - czm_viewport.xy) / czm_viewport.zw; // [0,1]\\n\\\n    RayShapeIntersection shapeIntersection = intersectScene(screenCoord, viewRayLocal, viewRayEC, ix);\\n\\\n    // Exit early if the scene was completely missed.\\n\\\n    if (shapeIntersection.entry.w == NO_HIT) {\\n\\\n        discard;\\n\\\n    }\\n\\\n\\n\\\n    float currentT = shapeIntersection.entry.w;\\n\\\n    float endT = shapeIntersection.exit.w;\\n\\\n\\n\\\n    vec3 positionEC = viewRayEC.pos + currentT * viewRayEC.dir;\\n\\\n    TileAndUvCoordinate tileAndUv = getTileAndUvCoordinate(positionEC);\\n\\\n    vec3 positionLocal = viewRayLocal.pos + currentT * viewRayLocal.dir;\\n\\\n    mat3 jacobianT = convertLocalToShapeSpaceDerivative(positionLocal);\\n\\\n\\n\\\n    // Traverse the tree from the start position\\n\\\n    TraversalData traversalData;\\n\\\n    SampleData sampleDatas[SAMPLE_COUNT];\\n\\\n    traverseOctreeFromBeginning(tileAndUv, traversalData, sampleDatas);\\n\\\n    vec4 step = getStepSize(sampleDatas[0], viewRayLocal, shapeIntersection, jacobianT, currentT);\\n\\\n\\n\\\n    FragmentInput fragmentInput;\\n\\\n    #if defined(STATISTICS)\\n\\\n        setStatistics(fragmentInput.metadataStatistics);\\n\\\n    #endif\\n\\\n\\n\\\n    czm_modelMaterial materialOutput;\\n\\\n    vec4 colorAccum = vec4(0.0);\\n\\\n\\n\\\n    for (int stepCount = 0; stepCount < STEP_COUNT_MAX; ++stepCount) {\\n\\\n        // Read properties from the megatexture based on the traversal state\\n\\\n        Properties properties = accumulatePropertiesFromMegatexture(sampleDatas);\\n\\\n\\n\\\n        // Prepare the custom shader inputs\\n\\\n        copyPropertiesToMetadata(properties, fragmentInput.metadata);\\n\\\n\\n\\\n        fragmentInput.attributes.positionEC = positionEC;\\n\\\n        // Re-normalize normals: some shape intersections may have been scaled to encode positive/negative shapes\\n\\\n        fragmentInput.attributes.normalEC = normalize(step.xyz);\\n\\\n\\n\\\n        fragmentInput.voxel.viewDirUv = viewRayLocal.dir;\\n\\\n\\n\\\n        fragmentInput.voxel.travelDistance = step.w;\\n\\\n        fragmentInput.voxel.stepCount = stepCount;\\n\\\n        fragmentInput.voxel.tileIndex = sampleDatas[0].megatextureIndex;\\n\\\n        fragmentInput.voxel.sampleIndex = getSampleIndex(sampleDatas[0]);\\n\\\n        fragmentInput.voxel.distanceToDepthBuffer = ix.distanceToDepthBuffer - currentT;\\n\\\n\\n\\\n        // Run the custom shader\\n\\\n        fragmentMain(fragmentInput, materialOutput);\\n\\\n\\n\\\n        // Sanitize the custom shader output\\n\\\n        vec4 color = vec4(materialOutput.diffuse, materialOutput.alpha);\\n\\\n        color.rgb = max(color.rgb, vec3(0.0));\\n\\\n        color.a = clamp(color.a, 0.0, 1.0);\\n\\\n\\n\\\n        // Pre-multiplied alpha blend\\n\\\n        colorAccum += (1.0 - colorAccum.a) * vec4(color.rgb * color.a, color.a);\\n\\\n\\n\\\n        // Stop traversing if the alpha has been fully saturated\\n\\\n        if (colorAccum.a > ALPHA_ACCUM_MAX) {\\n\\\n            colorAccum.a = ALPHA_ACCUM_MAX;\\n\\\n            break;\\n\\\n        }\\n\\\n\\n\\\n        if (step.w == 0.0) {\\n\\\n            // Shape is infinitely thin. The ray may have hit the edge of a\\n\\\n            // foreground voxel. Step ahead slightly to check for more voxels\\n\\\n            step.w == 0.00001;\\n\\\n        }\\n\\\n\\n\\\n        // Keep raymarching\\n\\\n        currentT += step.w;\\n\\\n        // Check if there's more intersections.\\n\\\n        if (currentT > endT) {\\n\\\n            #if (INTERSECTION_COUNT == 1)\\n\\\n                break;\\n\\\n            #else\\n\\\n                shapeIntersection = nextIntersection(ix);\\n\\\n                if (shapeIntersection.entry.w == NO_HIT) {\\n\\\n                    break;\\n\\\n                } else {\\n\\\n                    // Found another intersection. Resume raymarching there\\n\\\n                    currentT = shapeIntersection.entry.w;\\n\\\n                    endT = shapeIntersection.exit.w;\\n\\\n                }\\n\\\n            #endif\\n\\\n        }\\n\\\n        positionEC = viewRayEC.pos + currentT * viewRayEC.dir;\\n\\\n        tileAndUv = getTileAndUvCoordinate(positionEC);\\n\\\n        positionLocal = viewRayLocal.pos + currentT * viewRayLocal.dir;\\n\\\n        jacobianT = convertLocalToShapeSpaceDerivative(positionLocal);\\n\\\n\\n\\\n        // Traverse the tree from the current ray position.\\n\\\n        // This is similar to traverseOctreeFromBeginning but is faster when the ray is in the same tile as the previous step.\\n\\\n        traverseOctreeFromExisting(tileAndUv, traversalData, sampleDatas);\\n\\\n        step = getStepSize(sampleDatas[0], viewRayLocal, shapeIntersection, jacobianT, currentT);\\n\\\n    }\\n\\\n\\n\\\n    // Convert the alpha from [0,ALPHA_ACCUM_MAX] to [0,1]\\n\\\n    colorAccum.a /= ALPHA_ACCUM_MAX;\\n\\\n\\n\\\n    #if defined(PICKING)\\n\\\n        // If alpha is 0.0 there is nothing to pick\\n\\\n        if (colorAccum.a == 0.0) {\\n\\\n            discard;\\n\\\n        }\\n\\\n        out_FragColor = u_pickColor;\\n\\\n    #elif defined(PICKING_VOXEL)\\n\\\n        // If alpha is 0.0 there is nothing to pick\\n\\\n        if (colorAccum.a == 0.0) {\\n\\\n            discard;\\n\\\n        }\\n\\\n        vec2 megatextureId = packIntToVec2(sampleDatas[0].megatextureIndex);\\n\\\n        vec2 sampleIndex = packIntToVec2(getSampleIndex(sampleDatas[0]));\\n\\\n        out_FragColor = vec4(megatextureId, sampleIndex);\\n\\\n    #else\\n\\\n        out_FragColor = colorAccum;\\n\\\n    #endif\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}