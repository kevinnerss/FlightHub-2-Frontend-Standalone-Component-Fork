{"ast":null,"code":"import AssociativeArray from \"../../Core/AssociativeArray.js\";\nimport Check from \"../../Core/Check.js\";\n\n/**\n * Rendering statistics for a single model.\n *\n * @alias ModelStatistics\n * @constructor\n *\n * @see Cesium3DTilesetStatistics\n *\n * @private\n */\nfunction ModelStatistics() {\n  /**\n   * Total number of points across all POINTS primitives in this model.\n   *\n   * @type {number}\n   * @private\n   */\n  this.pointsLength = 0;\n\n  /**\n   * Total number of triangles across all TRIANGLES, TRIANGLE_STRIP or\n   * TRIANGLE_FAN primitives in this model.\n   *\n   * @type {number}\n   * @private\n   */\n  this.trianglesLength = 0;\n\n  /**\n   * Total size of all geometry buffers in bytes. This accounts for the vertex\n   * attributes (which includes feature IDs and property attributes) and index\n   * buffers of all the model's primitives. Any attributes generated by the\n   * pipeline are included in this total.\n   *\n   * @type {number}\n   * @private\n   */\n  this.geometryByteLength = 0;\n\n  /**\n   * Total size of all textures in bytes. This includes materials,\n   * feature ID textures, and property textures.\n   *\n   * @type {number}\n   * @private\n   */\n  this.texturesByteLength = 0;\n\n  /**\n   * Total size of property tables. This excludes the batch textures used for\n   * picking and styling.\n   *\n   * @type {number}\n   * @private\n   */\n  this.propertyTablesByteLength = 0;\n\n  // Sets of buffers and textures that have already been counted.\n  // This is to prevent double-counting cached assets.\n  this._bufferIdSet = {};\n\n  /**\n   * The mapping from `texture.id` strings to the byte length of the\n   * respective texture\n   *\n   * @type {object}\n   * @private\n   */\n  this._textureIdByteLengths = {};\n\n  // Associated array of batch textures that have already been counted.\n  // This allows for quick look-up to check if a texture has been counted,\n  // while also allowing for dynamic texture counting.\n  this._batchTextureIdMap = new AssociativeArray();\n}\nObject.defineProperties(ModelStatistics.prototype, {\n  /**\n   * Total size of the batch textures used for picking and styling.\n   * Batch textures are created asynchronously, so this iterates\n   * over the textures to ensure their memory values are accurate.\n   *\n   * @memberof ModelStatistics.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  batchTexturesByteLength: {\n    get: function () {\n      const length = this._batchTextureIdMap.length;\n      const values = this._batchTextureIdMap.values;\n      let memory = 0;\n      for (let i = 0; i < length; i++) {\n        memory += values[i].byteLength;\n      }\n      return memory;\n    }\n  }\n});\n\n/**\n * Reset the memory counts for this model. This should be called each time the\n * draw command pipeline is rebuilt.\n *\n * @private\n */\nModelStatistics.prototype.clear = function () {\n  this.pointsLength = 0;\n  this.trianglesLength = 0;\n  this.geometryByteLength = 0;\n  this.texturesByteLength = 0;\n  this.propertyTablesByteLength = 0;\n  this._bufferIdSet = {};\n  this._textureIdByteLengths = {};\n  this._batchTextureIdMap.removeAll();\n};\n\n/**\n * Counts the given buffer's memory in bytes. If a buffer has\n * already been counted by these statistics, it will not be\n * counted again.\n *\n * @param {Buffer} buffer The GPU buffer associated with the model.\n * @param {boolean} hasCpuCopy Whether the buffer has a copy on the CPU via typed array.\n *\n * @private\n */\nModelStatistics.prototype.addBuffer = function (buffer, hasCpuCopy) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"buffer\", buffer);\n  Check.typeOf.bool(\"hasCpuCopy\", hasCpuCopy);\n  //>>includeEnd('debug');\n\n  if (!this._bufferIdSet.hasOwnProperty(buffer._id)) {\n    // If there's a CPU copy, count the memory twice.\n    const copies = hasCpuCopy ? 2 : 1;\n    this.geometryByteLength += buffer.sizeInBytes * copies;\n  }\n\n  // Simulate set insertion.\n  this._bufferIdSet[buffer._id] = true;\n};\n\n/**\n * Counts the given texture's memory in bytes. If a texture has\n * already been counted by these statistics, it will not be\n * counted again.\n * <p>\n * This is used to count the materials and property textures of\n * a model. Batch textures function differently and are counted\n * using <code>addBatchTexture</code> instead.\n * </p>\n *\n * @param {Texture} texture The texture associated with the model.\n *\n * @private\n */\nModelStatistics.prototype.addTexture = function (texture) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"texture\", texture);\n  //>>includeEnd('debug');\n\n  if (!this._textureIdByteLengths.hasOwnProperty(texture._id)) {\n    this.texturesByteLength += texture.sizeInBytes;\n    this._textureIdByteLengths[texture._id] = texture.sizeInBytes;\n  }\n};\n\n/**\n * Returns an array containing the `texture.id` values for all textures\n * that are part of the model.\n *\n * @returns {string[]} The texture IDs\n */\nModelStatistics.prototype.getTextureIds = function () {\n  return Object.keys(this._textureIdByteLengths);\n};\n\n/**\n * Returns the length, in bytes, of the texture data for the texture with\n * the given ID that is part of the model, or `undefined` if the model\n * does not contain the texture with the given ID.\n *\n * @param {string} textureId The texture ID\n * @returns {number|undefined} The texture byte length\n */\nModelStatistics.prototype.getTextureByteLengthById = function (textureId) {\n  return this._textureIdByteLengths[textureId];\n};\n\n/**\n * Counts the batch texture's memory in bytes. If a batch texture\n * has already been counted by these statistics, it will not be\n * counted again.\n * <p>\n * Batch textures are handled differently than other textures. They\n * include the batch and pick textures for the feature table, which\n * are created dynamically. As such, they may not have both textures\n * loaded by the time they are added to the statistics. Their memory\n * will thus be counted dynamically.\n * </p>\n *\n * @param {BatchTexture} batchTexture The batch texture associated with the model.\n *\n * @private\n */\nModelStatistics.prototype.addBatchTexture = function (batchTexture) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"batchTexture\", batchTexture);\n  //>>includeEnd('debug');\n\n  if (!this._batchTextureIdMap.contains(batchTexture._id)) {\n    this._batchTextureIdMap.set(batchTexture._id, batchTexture);\n  }\n};\nexport default ModelStatistics;","map":{"version":3,"names":["AssociativeArray","Check","ModelStatistics","pointsLength","trianglesLength","geometryByteLength","texturesByteLength","propertyTablesByteLength","_bufferIdSet","_textureIdByteLengths","_batchTextureIdMap","Object","defineProperties","prototype","batchTexturesByteLength","get","length","values","memory","i","byteLength","clear","removeAll","addBuffer","buffer","hasCpuCopy","typeOf","object","bool","hasOwnProperty","_id","copies","sizeInBytes","addTexture","texture","getTextureIds","keys","getTextureByteLengthById","textureId","addBatchTexture","batchTexture","contains","set"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Model/ModelStatistics.js"],"sourcesContent":["import AssociativeArray from \"../../Core/AssociativeArray.js\";\nimport Check from \"../../Core/Check.js\";\n\n/**\n * Rendering statistics for a single model.\n *\n * @alias ModelStatistics\n * @constructor\n *\n * @see Cesium3DTilesetStatistics\n *\n * @private\n */\nfunction ModelStatistics() {\n  /**\n   * Total number of points across all POINTS primitives in this model.\n   *\n   * @type {number}\n   * @private\n   */\n  this.pointsLength = 0;\n\n  /**\n   * Total number of triangles across all TRIANGLES, TRIANGLE_STRIP or\n   * TRIANGLE_FAN primitives in this model.\n   *\n   * @type {number}\n   * @private\n   */\n  this.trianglesLength = 0;\n\n  /**\n   * Total size of all geometry buffers in bytes. This accounts for the vertex\n   * attributes (which includes feature IDs and property attributes) and index\n   * buffers of all the model's primitives. Any attributes generated by the\n   * pipeline are included in this total.\n   *\n   * @type {number}\n   * @private\n   */\n  this.geometryByteLength = 0;\n\n  /**\n   * Total size of all textures in bytes. This includes materials,\n   * feature ID textures, and property textures.\n   *\n   * @type {number}\n   * @private\n   */\n  this.texturesByteLength = 0;\n\n  /**\n   * Total size of property tables. This excludes the batch textures used for\n   * picking and styling.\n   *\n   * @type {number}\n   * @private\n   */\n  this.propertyTablesByteLength = 0;\n\n  // Sets of buffers and textures that have already been counted.\n  // This is to prevent double-counting cached assets.\n  this._bufferIdSet = {};\n\n  /**\n   * The mapping from `texture.id` strings to the byte length of the\n   * respective texture\n   *\n   * @type {object}\n   * @private\n   */\n  this._textureIdByteLengths = {};\n\n  // Associated array of batch textures that have already been counted.\n  // This allows for quick look-up to check if a texture has been counted,\n  // while also allowing for dynamic texture counting.\n  this._batchTextureIdMap = new AssociativeArray();\n}\n\nObject.defineProperties(ModelStatistics.prototype, {\n  /**\n   * Total size of the batch textures used for picking and styling.\n   * Batch textures are created asynchronously, so this iterates\n   * over the textures to ensure their memory values are accurate.\n   *\n   * @memberof ModelStatistics.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  batchTexturesByteLength: {\n    get: function () {\n      const length = this._batchTextureIdMap.length;\n      const values = this._batchTextureIdMap.values;\n\n      let memory = 0;\n      for (let i = 0; i < length; i++) {\n        memory += values[i].byteLength;\n      }\n\n      return memory;\n    },\n  },\n});\n\n/**\n * Reset the memory counts for this model. This should be called each time the\n * draw command pipeline is rebuilt.\n *\n * @private\n */\nModelStatistics.prototype.clear = function () {\n  this.pointsLength = 0;\n  this.trianglesLength = 0;\n  this.geometryByteLength = 0;\n  this.texturesByteLength = 0;\n  this.propertyTablesByteLength = 0;\n\n  this._bufferIdSet = {};\n  this._textureIdByteLengths = {};\n  this._batchTextureIdMap.removeAll();\n};\n\n/**\n * Counts the given buffer's memory in bytes. If a buffer has\n * already been counted by these statistics, it will not be\n * counted again.\n *\n * @param {Buffer} buffer The GPU buffer associated with the model.\n * @param {boolean} hasCpuCopy Whether the buffer has a copy on the CPU via typed array.\n *\n * @private\n */\nModelStatistics.prototype.addBuffer = function (buffer, hasCpuCopy) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"buffer\", buffer);\n  Check.typeOf.bool(\"hasCpuCopy\", hasCpuCopy);\n  //>>includeEnd('debug');\n\n  if (!this._bufferIdSet.hasOwnProperty(buffer._id)) {\n    // If there's a CPU copy, count the memory twice.\n    const copies = hasCpuCopy ? 2 : 1;\n    this.geometryByteLength += buffer.sizeInBytes * copies;\n  }\n\n  // Simulate set insertion.\n  this._bufferIdSet[buffer._id] = true;\n};\n\n/**\n * Counts the given texture's memory in bytes. If a texture has\n * already been counted by these statistics, it will not be\n * counted again.\n * <p>\n * This is used to count the materials and property textures of\n * a model. Batch textures function differently and are counted\n * using <code>addBatchTexture</code> instead.\n * </p>\n *\n * @param {Texture} texture The texture associated with the model.\n *\n * @private\n */\nModelStatistics.prototype.addTexture = function (texture) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"texture\", texture);\n  //>>includeEnd('debug');\n\n  if (!this._textureIdByteLengths.hasOwnProperty(texture._id)) {\n    this.texturesByteLength += texture.sizeInBytes;\n    this._textureIdByteLengths[texture._id] = texture.sizeInBytes;\n  }\n};\n\n/**\n * Returns an array containing the `texture.id` values for all textures\n * that are part of the model.\n *\n * @returns {string[]} The texture IDs\n */\nModelStatistics.prototype.getTextureIds = function () {\n  return Object.keys(this._textureIdByteLengths);\n};\n\n/**\n * Returns the length, in bytes, of the texture data for the texture with\n * the given ID that is part of the model, or `undefined` if the model\n * does not contain the texture with the given ID.\n *\n * @param {string} textureId The texture ID\n * @returns {number|undefined} The texture byte length\n */\nModelStatistics.prototype.getTextureByteLengthById = function (textureId) {\n  return this._textureIdByteLengths[textureId];\n};\n\n/**\n * Counts the batch texture's memory in bytes. If a batch texture\n * has already been counted by these statistics, it will not be\n * counted again.\n * <p>\n * Batch textures are handled differently than other textures. They\n * include the batch and pick textures for the feature table, which\n * are created dynamically. As such, they may not have both textures\n * loaded by the time they are added to the statistics. Their memory\n * will thus be counted dynamically.\n * </p>\n *\n * @param {BatchTexture} batchTexture The batch texture associated with the model.\n *\n * @private\n */\nModelStatistics.prototype.addBatchTexture = function (batchTexture) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"batchTexture\", batchTexture);\n  //>>includeEnd('debug');\n\n  if (!this._batchTextureIdMap.contains(batchTexture._id)) {\n    this._batchTextureIdMap.set(batchTexture._id, batchTexture);\n  }\n};\n\nexport default ModelStatistics;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}