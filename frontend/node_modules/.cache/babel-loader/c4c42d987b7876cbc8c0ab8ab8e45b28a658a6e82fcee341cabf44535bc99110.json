{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport ForEach from \"./ForEach.js\";\nimport forEachTextureInMaterial from \"./forEachTextureInMaterial.js\";\nimport usesExtension from \"./usesExtension.js\";\nimport defined from \"../../Core/defined.js\";\nconst allElementTypes = [\"mesh\", \"node\", \"material\", \"accessor\", \"bufferView\", \"buffer\", \"texture\", \"sampler\", \"image\"];\n\n/**\n * Removes unused elements from gltf.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @param {string[]} [elementTypes=['mesh', 'node', 'material', 'accessor', 'bufferView', 'buffer']] Element types to be removed. Needs to be a subset of ['mesh', 'node', 'material', 'accessor', 'bufferView', 'buffer'], other items will be ignored.\n *\n * @private\n */\nfunction removeUnusedElements(gltf, elementTypes) {\n  elementTypes = elementTypes ?? allElementTypes;\n  allElementTypes.forEach(function (type) {\n    if (elementTypes.indexOf(type) > -1) {\n      removeUnusedElementsByType(gltf, type);\n    }\n  });\n  return gltf;\n}\nconst TypeToGltfElementName = {\n  accessor: \"accessors\",\n  buffer: \"buffers\",\n  bufferView: \"bufferViews\",\n  image: \"images\",\n  node: \"nodes\",\n  material: \"materials\",\n  mesh: \"meshes\",\n  sampler: \"samplers\",\n  texture: \"textures\"\n};\nfunction removeUnusedElementsByType(gltf, type) {\n  const name = TypeToGltfElementName[type];\n  const arrayOfObjects = gltf[name];\n  if (defined(arrayOfObjects)) {\n    let removed = 0;\n    const usedIds = getListOfElementsIdsInUse[type](gltf);\n    const length = arrayOfObjects.length;\n    for (let i = 0; i < length; ++i) {\n      if (!usedIds[i]) {\n        Remove[type](gltf, i - removed);\n        removed++;\n      }\n    }\n  }\n}\n\n/**\n * Contains functions for removing elements from a glTF hierarchy.\n * Since top-level glTF elements are arrays, when something is removed, referring\n * indices need to be updated.\n * @constructor\n *\n * @private\n */\nfunction Remove() {}\nRemove.accessor = function (gltf, accessorId) {\n  const accessors = gltf.accessors;\n  accessors.splice(accessorId, 1);\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      // Update accessor ids for the primitives.\n      ForEach.meshPrimitiveAttribute(primitive, function (attributeAccessorId, semantic) {\n        if (attributeAccessorId > accessorId) {\n          primitive.attributes[semantic]--;\n        }\n      });\n\n      // Update accessor ids for the targets.\n      ForEach.meshPrimitiveTarget(primitive, function (target) {\n        ForEach.meshPrimitiveTargetAttribute(target, function (attributeAccessorId, semantic) {\n          if (attributeAccessorId > accessorId) {\n            target[semantic]--;\n          }\n        });\n      });\n      const indices = primitive.indices;\n      if (defined(indices) && indices > accessorId) {\n        primitive.indices--;\n      }\n      const ext = primitive.extensions;\n      if (defined(ext) && defined(ext.CESIUM_primitive_outline) && ext.CESIUM_primitive_outline.indices > accessorId) {\n        --ext.CESIUM_primitive_outline.indices;\n      }\n    });\n  });\n  ForEach.skin(gltf, function (skin) {\n    if (defined(skin.inverseBindMatrices) && skin.inverseBindMatrices > accessorId) {\n      skin.inverseBindMatrices--;\n    }\n  });\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      if (defined(sampler.input) && sampler.input > accessorId) {\n        sampler.input--;\n      }\n      if (defined(sampler.output) && sampler.output > accessorId) {\n        sampler.output--;\n      }\n    });\n  });\n};\nRemove.buffer = function (gltf, bufferId) {\n  const buffers = gltf.buffers;\n  buffers.splice(bufferId, 1);\n  ForEach.bufferView(gltf, function (bufferView) {\n    if (defined(bufferView.buffer) && bufferView.buffer > bufferId) {\n      bufferView.buffer--;\n    }\n    if (defined(bufferView.extensions) && defined(bufferView.extensions.EXT_meshopt_compression)) {\n      bufferView.extensions.EXT_meshopt_compression.buffer--;\n    }\n  });\n};\nRemove.bufferView = function (gltf, bufferViewId) {\n  const bufferViews = gltf.bufferViews;\n  bufferViews.splice(bufferViewId, 1);\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView) && accessor.bufferView > bufferViewId) {\n      accessor.bufferView--;\n    }\n  });\n  ForEach.shader(gltf, function (shader) {\n    if (defined(shader.bufferView) && shader.bufferView > bufferViewId) {\n      shader.bufferView--;\n    }\n  });\n  ForEach.image(gltf, function (image) {\n    if (defined(image.bufferView) && image.bufferView > bufferViewId) {\n      image.bufferView--;\n    }\n  });\n  if (usesExtension(gltf, \"KHR_draco_mesh_compression\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        if (defined(primitive.extensions) && defined(primitive.extensions.KHR_draco_mesh_compression)) {\n          if (primitive.extensions.KHR_draco_mesh_compression.bufferView > bufferViewId) {\n            primitive.extensions.KHR_draco_mesh_compression.bufferView--;\n          }\n        }\n      });\n    });\n  }\n  if (usesExtension(gltf, \"EXT_feature_metadata\")) {\n    const extension = gltf.extensions.EXT_feature_metadata;\n    const featureTables = extension.featureTables;\n    for (const featureTableId in featureTables) {\n      if (featureTables.hasOwnProperty(featureTableId)) {\n        const featureTable = featureTables[featureTableId];\n        const properties = featureTable.properties;\n        if (defined(properties)) {\n          for (const propertyId in properties) {\n            if (properties.hasOwnProperty(propertyId)) {\n              const property = properties[propertyId];\n              if (defined(property.bufferView) && property.bufferView > bufferViewId) {\n                property.bufferView--;\n              }\n              if (defined(property.arrayOffsetBufferView) && property.arrayOffsetBufferView > bufferViewId) {\n                property.arrayOffsetBufferView--;\n              }\n              if (defined(property.stringOffsetBufferView) && property.stringOffsetBufferView > bufferViewId) {\n                property.stringOffsetBufferView--;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  if (usesExtension(gltf, \"EXT_structural_metadata\")) {\n    const extension = gltf.extensions.EXT_structural_metadata;\n    const propertyTables = extension.propertyTables;\n    if (defined(propertyTables)) {\n      const propertyTablesLength = propertyTables.length;\n      for (let i = 0; i < propertyTablesLength; ++i) {\n        const propertyTable = propertyTables[i];\n        const properties = propertyTable.properties;\n        for (const propertyId in properties) {\n          if (properties.hasOwnProperty(propertyId)) {\n            const property = properties[propertyId];\n            if (defined(property.values) && property.values > bufferViewId) {\n              property.values--;\n            }\n            if (defined(property.arrayOffsets) && property.arrayOffsets > bufferViewId) {\n              property.arrayOffsets--;\n            }\n            if (defined(property.stringOffsets) && property.stringOffsets > bufferViewId) {\n              property.stringOffsets--;\n            }\n          }\n        }\n      }\n    }\n  }\n};\nRemove.image = function (gltf, imageId) {\n  const images = gltf.images;\n  images.splice(imageId, 1);\n  ForEach.texture(gltf, function (texture) {\n    if (defined(texture.source)) {\n      if (texture.source > imageId) {\n        --texture.source;\n      }\n    }\n    const ext = texture.extensions;\n    if (defined(ext) && defined(ext.EXT_texture_webp) && ext.EXT_texture_webp.source > imageId) {\n      --texture.extensions.EXT_texture_webp.source;\n    } else if (defined(ext) && defined(ext.KHR_texture_basisu) && ext.KHR_texture_basisu.source > imageId) {\n      --texture.extensions.KHR_texture_basisu.source;\n    }\n  });\n};\nRemove.mesh = function (gltf, meshId) {\n  const meshes = gltf.meshes;\n  meshes.splice(meshId, 1);\n  ForEach.node(gltf, function (node) {\n    if (defined(node.mesh)) {\n      if (node.mesh > meshId) {\n        node.mesh--;\n      } else if (node.mesh === meshId) {\n        // Remove reference to deleted mesh\n        delete node.mesh;\n      }\n    }\n  });\n};\nRemove.node = function (gltf, nodeId) {\n  const nodes = gltf.nodes;\n  nodes.splice(nodeId, 1);\n\n  // Shift all node references\n  ForEach.skin(gltf, function (skin) {\n    if (defined(skin.skeleton) && skin.skeleton > nodeId) {\n      skin.skeleton--;\n    }\n    skin.joints = skin.joints.map(function (x) {\n      return x > nodeId ? x - 1 : x;\n    });\n  });\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationChannel(animation, function (channel) {\n      if (defined(channel.target) && defined(channel.target.node) && channel.target.node > nodeId) {\n        channel.target.node--;\n      }\n    });\n  });\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueUniform(technique, function (uniform) {\n      if (defined(uniform.node) && uniform.node > nodeId) {\n        uniform.node--;\n      }\n    });\n  });\n  ForEach.node(gltf, function (node) {\n    if (!defined(node.children)) {\n      return;\n    }\n    node.children = node.children.filter(function (x) {\n      return x !== nodeId; // Remove\n    }).map(function (x) {\n      return x > nodeId ? x - 1 : x; // Shift indices\n    });\n  });\n  ForEach.scene(gltf, function (scene) {\n    scene.nodes = scene.nodes.filter(function (x) {\n      return x !== nodeId; // Remove\n    }).map(function (x) {\n      return x > nodeId ? x - 1 : x; // Shift indices\n    });\n  });\n};\nRemove.material = function (gltf, materialId) {\n  const materials = gltf.materials;\n  materials.splice(materialId, 1);\n\n  // Shift other material ids\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      if (defined(primitive.material) && primitive.material > materialId) {\n        primitive.material--;\n      }\n    });\n  });\n};\nRemove.sampler = function (gltf, samplerId) {\n  const samplers = gltf.samplers;\n  samplers.splice(samplerId, 1);\n  ForEach.texture(gltf, function (texture) {\n    if (defined(texture.sampler)) {\n      if (texture.sampler > samplerId) {\n        --texture.sampler;\n      }\n    }\n  });\n};\nRemove.texture = function (gltf, textureId) {\n  const textures = gltf.textures;\n  textures.splice(textureId, 1);\n  ForEach.material(gltf, function (material) {\n    forEachTextureInMaterial(material, function (textureIndex, textureInfo) {\n      if (textureInfo.index > textureId) {\n        --textureInfo.index;\n      }\n    });\n  });\n  if (usesExtension(gltf, \"EXT_feature_metadata\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        const extensions = primitive.extensions;\n        if (defined(extensions) && defined(extensions.EXT_feature_metadata)) {\n          const extension = extensions.EXT_feature_metadata;\n          const featureIdTextures = extension.featureIdTextures;\n          if (defined(featureIdTextures)) {\n            const featureIdTexturesLength = featureIdTextures.length;\n            for (let i = 0; i < featureIdTexturesLength; ++i) {\n              const featureIdTexture = featureIdTextures[i];\n              const textureInfo = featureIdTexture.featureIds.texture;\n              if (textureInfo.index > textureId) {\n                --textureInfo.index;\n              }\n            }\n          }\n        }\n      });\n    });\n    const extension = gltf.extensions.EXT_feature_metadata;\n    const featureTextures = extension.featureTextures;\n    for (const featureTextureId in featureTextures) {\n      if (featureTextures.hasOwnProperty(featureTextureId)) {\n        const featureTexture = featureTextures[featureTextureId];\n        const properties = featureTexture.properties;\n        if (defined(properties)) {\n          for (const propertyId in properties) {\n            if (properties.hasOwnProperty(propertyId)) {\n              const property = properties[propertyId];\n              const textureInfo = property.texture;\n              if (textureInfo.index > textureId) {\n                --textureInfo.index;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  if (usesExtension(gltf, \"EXT_mesh_features\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        const extensions = primitive.extensions;\n        if (defined(extensions) && defined(extensions.EXT_mesh_features)) {\n          const extension = extensions.EXT_mesh_features;\n          const featureIds = extension.featureIds;\n          if (defined(featureIds)) {\n            const featureIdsLength = featureIds.length;\n            for (let i = 0; i < featureIdsLength; ++i) {\n              const featureId = featureIds[i];\n              if (defined(featureId.texture)) {\n                if (featureId.texture.index > textureId) {\n                  --featureId.texture.index;\n                }\n              }\n            }\n          }\n        }\n      });\n    });\n  }\n  if (usesExtension(gltf, \"EXT_structural_metadata\")) {\n    const extension = gltf.extensions.EXT_structural_metadata;\n    const propertyTextures = extension.propertyTextures;\n    if (defined(propertyTextures)) {\n      const propertyTexturesLength = propertyTextures.length;\n      for (let i = 0; i < propertyTexturesLength; ++i) {\n        const propertyTexture = propertyTextures[i];\n        const properties = propertyTexture.properties;\n        for (const propertyId in properties) {\n          if (properties.hasOwnProperty(propertyId)) {\n            const property = properties[propertyId];\n            if (property.index > textureId) {\n              --property.index;\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\n/**\n * Contains functions for getting a list of element ids in use by the glTF asset.\n * @constructor\n *\n * @private\n */\nfunction getListOfElementsIdsInUse() {}\ngetListOfElementsIdsInUse.accessor = function (gltf) {\n  // Calculate accessor's that are currently in use.\n  const usedAccessorIds = {};\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      ForEach.meshPrimitiveAttribute(primitive, function (accessorId) {\n        usedAccessorIds[accessorId] = true;\n      });\n      ForEach.meshPrimitiveTarget(primitive, function (target) {\n        ForEach.meshPrimitiveTargetAttribute(target, function (accessorId) {\n          usedAccessorIds[accessorId] = true;\n        });\n      });\n      const indices = primitive.indices;\n      if (defined(indices)) {\n        usedAccessorIds[indices] = true;\n      }\n    });\n  });\n  ForEach.skin(gltf, function (skin) {\n    if (defined(skin.inverseBindMatrices)) {\n      usedAccessorIds[skin.inverseBindMatrices] = true;\n    }\n  });\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      if (defined(sampler.input)) {\n        usedAccessorIds[sampler.input] = true;\n      }\n      if (defined(sampler.output)) {\n        usedAccessorIds[sampler.output] = true;\n      }\n    });\n  });\n  if (usesExtension(gltf, \"EXT_mesh_gpu_instancing\")) {\n    ForEach.node(gltf, function (node) {\n      if (defined(node.extensions) && defined(node.extensions.EXT_mesh_gpu_instancing)) {\n        Object.keys(node.extensions.EXT_mesh_gpu_instancing.attributes).forEach(function (key) {\n          const attributeAccessorId = node.extensions.EXT_mesh_gpu_instancing.attributes[key];\n          usedAccessorIds[attributeAccessorId] = true;\n        });\n      }\n    });\n  }\n  if (usesExtension(gltf, \"CESIUM_primitive_outline\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        const extensions = primitive.extensions;\n        if (defined(extensions) && defined(extensions.CESIUM_primitive_outline)) {\n          const extension = extensions.CESIUM_primitive_outline;\n          const indicesAccessorId = extension.indices;\n          if (defined(indicesAccessorId)) {\n            usedAccessorIds[indicesAccessorId] = true;\n          }\n        }\n      });\n    });\n  }\n  return usedAccessorIds;\n};\ngetListOfElementsIdsInUse.buffer = function (gltf) {\n  // Calculate buffer's that are currently in use.\n  const usedBufferIds = {};\n  ForEach.bufferView(gltf, function (bufferView) {\n    if (defined(bufferView.buffer)) {\n      usedBufferIds[bufferView.buffer] = true;\n    }\n    if (defined(bufferView.extensions) && defined(bufferView.extensions.EXT_meshopt_compression)) {\n      usedBufferIds[bufferView.extensions.EXT_meshopt_compression.buffer] = true;\n    }\n  });\n  return usedBufferIds;\n};\ngetListOfElementsIdsInUse.bufferView = function (gltf) {\n  // Calculate bufferView's that are currently in use.\n  const usedBufferViewIds = {};\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView)) {\n      usedBufferViewIds[accessor.bufferView] = true;\n    }\n  });\n  ForEach.shader(gltf, function (shader) {\n    if (defined(shader.bufferView)) {\n      usedBufferViewIds[shader.bufferView] = true;\n    }\n  });\n  ForEach.image(gltf, function (image) {\n    if (defined(image.bufferView)) {\n      usedBufferViewIds[image.bufferView] = true;\n    }\n  });\n  if (usesExtension(gltf, \"KHR_draco_mesh_compression\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        if (defined(primitive.extensions) && defined(primitive.extensions.KHR_draco_mesh_compression)) {\n          usedBufferViewIds[primitive.extensions.KHR_draco_mesh_compression.bufferView] = true;\n        }\n      });\n    });\n  }\n  if (usesExtension(gltf, \"EXT_feature_metadata\")) {\n    const extension = gltf.extensions.EXT_feature_metadata;\n    const featureTables = extension.featureTables;\n    for (const featureTableId in featureTables) {\n      if (featureTables.hasOwnProperty(featureTableId)) {\n        const featureTable = featureTables[featureTableId];\n        const properties = featureTable.properties;\n        if (defined(properties)) {\n          for (const propertyId in properties) {\n            if (properties.hasOwnProperty(propertyId)) {\n              const property = properties[propertyId];\n              if (defined(property.bufferView)) {\n                usedBufferViewIds[property.bufferView] = true;\n              }\n              if (defined(property.arrayOffsetBufferView)) {\n                usedBufferViewIds[property.arrayOffsetBufferView] = true;\n              }\n              if (defined(property.stringOffsetBufferView)) {\n                usedBufferViewIds[property.stringOffsetBufferView] = true;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  if (usesExtension(gltf, \"EXT_structural_metadata\")) {\n    const extension = gltf.extensions.EXT_structural_metadata;\n    const propertyTables = extension.propertyTables;\n    if (defined(propertyTables)) {\n      const propertyTablesLength = propertyTables.length;\n      for (let i = 0; i < propertyTablesLength; ++i) {\n        const propertyTable = propertyTables[i];\n        const properties = propertyTable.properties;\n        for (const propertyId in properties) {\n          if (properties.hasOwnProperty(propertyId)) {\n            const property = properties[propertyId];\n            if (defined(property.values)) {\n              usedBufferViewIds[property.values] = true;\n            }\n            if (defined(property.arrayOffsets)) {\n              usedBufferViewIds[property.arrayOffsets] = true;\n            }\n            if (defined(property.stringOffsets)) {\n              usedBufferViewIds[property.stringOffsets] = true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return usedBufferViewIds;\n};\ngetListOfElementsIdsInUse.image = function (gltf) {\n  const usedImageIds = {};\n  ForEach.texture(gltf, function (texture) {\n    if (defined(texture.source)) {\n      usedImageIds[texture.source] = true;\n    }\n    if (defined(texture.extensions) && defined(texture.extensions.EXT_texture_webp)) {\n      usedImageIds[texture.extensions.EXT_texture_webp.source] = true;\n    } else if (defined(texture.extensions) && defined(texture.extensions.KHR_texture_basisu)) {\n      usedImageIds[texture.extensions.KHR_texture_basisu.source] = true;\n    }\n  });\n  return usedImageIds;\n};\ngetListOfElementsIdsInUse.mesh = function (gltf) {\n  const usedMeshIds = {};\n  ForEach.node(gltf, function (node) {\n    if (defined(node.mesh && defined(gltf.meshes))) {\n      const mesh = gltf.meshes[node.mesh];\n      if (defined(mesh) && defined(mesh.primitives) && mesh.primitives.length > 0) {\n        usedMeshIds[node.mesh] = true;\n      }\n    }\n  });\n  return usedMeshIds;\n};\n\n// Check if node is empty. It is considered empty if neither referencing\n// mesh, camera, extensions and has no children\nfunction nodeIsEmpty(gltf, nodeId, usedNodeIds) {\n  const node = gltf.nodes[nodeId];\n  if (defined(node.mesh) || defined(node.camera) || defined(node.skin) || defined(node.weights) || defined(node.extras) || defined(node.extensions) && Object.keys(node.extensions).length !== 0 || defined(usedNodeIds[nodeId])) {\n    return false;\n  }\n\n  // Empty if no children or children are all empty nodes\n  return !defined(node.children) || node.children.filter(function (n) {\n    return !nodeIsEmpty(gltf, n, usedNodeIds);\n  }).length === 0;\n}\ngetListOfElementsIdsInUse.node = function (gltf) {\n  const usedNodeIds = {};\n  ForEach.skin(gltf, function (skin) {\n    if (defined(skin.skeleton)) {\n      usedNodeIds[skin.skeleton] = true;\n    }\n    ForEach.skinJoint(skin, function (joint) {\n      usedNodeIds[joint] = true;\n    });\n  });\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationChannel(animation, function (channel) {\n      if (defined(channel.target) && defined(channel.target.node)) {\n        usedNodeIds[channel.target.node] = true;\n      }\n    });\n  });\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueUniform(technique, function (uniform) {\n      if (defined(uniform.node)) {\n        usedNodeIds[uniform.node] = true;\n      }\n    });\n  });\n  ForEach.node(gltf, function (node, nodeId) {\n    if (!nodeIsEmpty(gltf, nodeId, usedNodeIds)) {\n      usedNodeIds[nodeId] = true;\n    }\n  });\n  return usedNodeIds;\n};\ngetListOfElementsIdsInUse.material = function (gltf) {\n  const usedMaterialIds = {};\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      if (defined(primitive.material)) {\n        usedMaterialIds[primitive.material] = true;\n      }\n    });\n  });\n  return usedMaterialIds;\n};\ngetListOfElementsIdsInUse.texture = function (gltf) {\n  const usedTextureIds = {};\n  ForEach.material(gltf, function (material) {\n    forEachTextureInMaterial(material, function (textureId) {\n      usedTextureIds[textureId] = true;\n    });\n  });\n  if (usesExtension(gltf, \"EXT_feature_metadata\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        const extensions = primitive.extensions;\n        if (defined(extensions) && defined(extensions.EXT_feature_metadata)) {\n          const extension = extensions.EXT_feature_metadata;\n          const featureIdTextures = extension.featureIdTextures;\n          if (defined(featureIdTextures)) {\n            const featureIdTexturesLength = featureIdTextures.length;\n            for (let i = 0; i < featureIdTexturesLength; ++i) {\n              const featureIdTexture = featureIdTextures[i];\n              const textureInfo = featureIdTexture.featureIds.texture;\n              usedTextureIds[textureInfo.index] = true;\n            }\n          }\n        }\n      });\n    });\n    const extension = gltf.extensions.EXT_feature_metadata;\n    const featureTextures = extension.featureTextures;\n    for (const featureTextureId in featureTextures) {\n      if (featureTextures.hasOwnProperty(featureTextureId)) {\n        const featureTexture = featureTextures[featureTextureId];\n        const properties = featureTexture.properties;\n        if (defined(properties)) {\n          for (const propertyId in properties) {\n            if (properties.hasOwnProperty(propertyId)) {\n              const property = properties[propertyId];\n              const textureInfo = property.texture;\n              usedTextureIds[textureInfo.index] = true;\n            }\n          }\n        }\n      }\n    }\n  }\n  if (usesExtension(gltf, \"EXT_mesh_features\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        const extensions = primitive.extensions;\n        if (defined(extensions) && defined(extensions.EXT_mesh_features)) {\n          const extension = extensions.EXT_mesh_features;\n          const featureIds = extension.featureIds;\n          if (defined(featureIds)) {\n            const featureIdsLength = featureIds.length;\n            for (let i = 0; i < featureIdsLength; ++i) {\n              const featureId = featureIds[i];\n              if (defined(featureId.texture)) {\n                usedTextureIds[featureId.texture.index] = true;\n              }\n            }\n          }\n        }\n      });\n    });\n  }\n  if (usesExtension(gltf, \"EXT_structural_metadata\")) {\n    const extension = gltf.extensions.EXT_structural_metadata;\n    const propertyTextures = extension.propertyTextures;\n    if (defined(propertyTextures)) {\n      const propertyTexturesLength = propertyTextures.length;\n      for (let i = 0; i < propertyTexturesLength; ++i) {\n        const propertyTexture = propertyTextures[i];\n        const properties = propertyTexture.properties;\n        for (const propertyId in properties) {\n          if (properties.hasOwnProperty(propertyId)) {\n            const property = properties[propertyId];\n            usedTextureIds[property.index] = true;\n          }\n        }\n      }\n    }\n  }\n  return usedTextureIds;\n};\ngetListOfElementsIdsInUse.sampler = function (gltf) {\n  const usedSamplerIds = {};\n  ForEach.texture(gltf, function (texture) {\n    if (defined(texture.sampler)) {\n      usedSamplerIds[texture.sampler] = true;\n    }\n  });\n  return usedSamplerIds;\n};\nexport default removeUnusedElements;","map":{"version":3,"names":["ForEach","forEachTextureInMaterial","usesExtension","defined","allElementTypes","removeUnusedElements","gltf","elementTypes","forEach","type","indexOf","removeUnusedElementsByType","TypeToGltfElementName","accessor","buffer","bufferView","image","node","material","mesh","sampler","texture","name","arrayOfObjects","removed","usedIds","getListOfElementsIdsInUse","length","i","Remove","accessorId","accessors","splice","meshPrimitive","primitive","meshPrimitiveAttribute","attributeAccessorId","semantic","attributes","meshPrimitiveTarget","target","meshPrimitiveTargetAttribute","indices","ext","extensions","CESIUM_primitive_outline","skin","inverseBindMatrices","animation","animationSampler","input","output","bufferId","buffers","EXT_meshopt_compression","bufferViewId","bufferViews","shader","KHR_draco_mesh_compression","extension","EXT_feature_metadata","featureTables","featureTableId","hasOwnProperty","featureTable","properties","propertyId","property","arrayOffsetBufferView","stringOffsetBufferView","EXT_structural_metadata","propertyTables","propertyTablesLength","propertyTable","values","arrayOffsets","stringOffsets","imageId","images","source","EXT_texture_webp","KHR_texture_basisu","meshId","meshes","nodeId","nodes","skeleton","joints","map","x","animationChannel","channel","technique","techniqueUniform","uniform","children","filter","scene","materialId","materials","samplerId","samplers","textureId","textures","textureIndex","textureInfo","index","featureIdTextures","featureIdTexturesLength","featureIdTexture","featureIds","featureTextures","featureTextureId","featureTexture","EXT_mesh_features","featureIdsLength","featureId","propertyTextures","propertyTexturesLength","propertyTexture","usedAccessorIds","EXT_mesh_gpu_instancing","Object","keys","key","indicesAccessorId","usedBufferIds","usedBufferViewIds","usedImageIds","usedMeshIds","primitives","nodeIsEmpty","usedNodeIds","camera","weights","extras","n","skinJoint","joint","usedMaterialIds","usedTextureIds","usedSamplerIds"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/GltfPipeline/removeUnusedElements.js"],"sourcesContent":["import ForEach from \"./ForEach.js\";\nimport forEachTextureInMaterial from \"./forEachTextureInMaterial.js\";\nimport usesExtension from \"./usesExtension.js\";\nimport defined from \"../../Core/defined.js\";\n\nconst allElementTypes = [\n  \"mesh\",\n  \"node\",\n  \"material\",\n  \"accessor\",\n  \"bufferView\",\n  \"buffer\",\n  \"texture\",\n  \"sampler\",\n  \"image\",\n];\n\n/**\n * Removes unused elements from gltf.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @param {string[]} [elementTypes=['mesh', 'node', 'material', 'accessor', 'bufferView', 'buffer']] Element types to be removed. Needs to be a subset of ['mesh', 'node', 'material', 'accessor', 'bufferView', 'buffer'], other items will be ignored.\n *\n * @private\n */\nfunction removeUnusedElements(gltf, elementTypes) {\n  elementTypes = elementTypes ?? allElementTypes;\n  allElementTypes.forEach(function (type) {\n    if (elementTypes.indexOf(type) > -1) {\n      removeUnusedElementsByType(gltf, type);\n    }\n  });\n  return gltf;\n}\n\nconst TypeToGltfElementName = {\n  accessor: \"accessors\",\n  buffer: \"buffers\",\n  bufferView: \"bufferViews\",\n  image: \"images\",\n  node: \"nodes\",\n  material: \"materials\",\n  mesh: \"meshes\",\n  sampler: \"samplers\",\n  texture: \"textures\",\n};\n\nfunction removeUnusedElementsByType(gltf, type) {\n  const name = TypeToGltfElementName[type];\n  const arrayOfObjects = gltf[name];\n\n  if (defined(arrayOfObjects)) {\n    let removed = 0;\n    const usedIds = getListOfElementsIdsInUse[type](gltf);\n    const length = arrayOfObjects.length;\n\n    for (let i = 0; i < length; ++i) {\n      if (!usedIds[i]) {\n        Remove[type](gltf, i - removed);\n        removed++;\n      }\n    }\n  }\n}\n\n/**\n * Contains functions for removing elements from a glTF hierarchy.\n * Since top-level glTF elements are arrays, when something is removed, referring\n * indices need to be updated.\n * @constructor\n *\n * @private\n */\nfunction Remove() {}\n\nRemove.accessor = function (gltf, accessorId) {\n  const accessors = gltf.accessors;\n\n  accessors.splice(accessorId, 1);\n\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      // Update accessor ids for the primitives.\n      ForEach.meshPrimitiveAttribute(\n        primitive,\n        function (attributeAccessorId, semantic) {\n          if (attributeAccessorId > accessorId) {\n            primitive.attributes[semantic]--;\n          }\n        },\n      );\n\n      // Update accessor ids for the targets.\n      ForEach.meshPrimitiveTarget(primitive, function (target) {\n        ForEach.meshPrimitiveTargetAttribute(\n          target,\n          function (attributeAccessorId, semantic) {\n            if (attributeAccessorId > accessorId) {\n              target[semantic]--;\n            }\n          },\n        );\n      });\n      const indices = primitive.indices;\n      if (defined(indices) && indices > accessorId) {\n        primitive.indices--;\n      }\n\n      const ext = primitive.extensions;\n      if (\n        defined(ext) &&\n        defined(ext.CESIUM_primitive_outline) &&\n        ext.CESIUM_primitive_outline.indices > accessorId\n      ) {\n        --ext.CESIUM_primitive_outline.indices;\n      }\n    });\n  });\n\n  ForEach.skin(gltf, function (skin) {\n    if (\n      defined(skin.inverseBindMatrices) &&\n      skin.inverseBindMatrices > accessorId\n    ) {\n      skin.inverseBindMatrices--;\n    }\n  });\n\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      if (defined(sampler.input) && sampler.input > accessorId) {\n        sampler.input--;\n      }\n      if (defined(sampler.output) && sampler.output > accessorId) {\n        sampler.output--;\n      }\n    });\n  });\n};\n\nRemove.buffer = function (gltf, bufferId) {\n  const buffers = gltf.buffers;\n\n  buffers.splice(bufferId, 1);\n\n  ForEach.bufferView(gltf, function (bufferView) {\n    if (defined(bufferView.buffer) && bufferView.buffer > bufferId) {\n      bufferView.buffer--;\n    }\n\n    if (\n      defined(bufferView.extensions) &&\n      defined(bufferView.extensions.EXT_meshopt_compression)\n    ) {\n      bufferView.extensions.EXT_meshopt_compression.buffer--;\n    }\n  });\n};\n\nRemove.bufferView = function (gltf, bufferViewId) {\n  const bufferViews = gltf.bufferViews;\n\n  bufferViews.splice(bufferViewId, 1);\n\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView) && accessor.bufferView > bufferViewId) {\n      accessor.bufferView--;\n    }\n  });\n\n  ForEach.shader(gltf, function (shader) {\n    if (defined(shader.bufferView) && shader.bufferView > bufferViewId) {\n      shader.bufferView--;\n    }\n  });\n\n  ForEach.image(gltf, function (image) {\n    if (defined(image.bufferView) && image.bufferView > bufferViewId) {\n      image.bufferView--;\n    }\n  });\n\n  if (usesExtension(gltf, \"KHR_draco_mesh_compression\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        if (\n          defined(primitive.extensions) &&\n          defined(primitive.extensions.KHR_draco_mesh_compression)\n        ) {\n          if (\n            primitive.extensions.KHR_draco_mesh_compression.bufferView >\n            bufferViewId\n          ) {\n            primitive.extensions.KHR_draco_mesh_compression.bufferView--;\n          }\n        }\n      });\n    });\n  }\n\n  if (usesExtension(gltf, \"EXT_feature_metadata\")) {\n    const extension = gltf.extensions.EXT_feature_metadata;\n    const featureTables = extension.featureTables;\n    for (const featureTableId in featureTables) {\n      if (featureTables.hasOwnProperty(featureTableId)) {\n        const featureTable = featureTables[featureTableId];\n        const properties = featureTable.properties;\n        if (defined(properties)) {\n          for (const propertyId in properties) {\n            if (properties.hasOwnProperty(propertyId)) {\n              const property = properties[propertyId];\n              if (\n                defined(property.bufferView) &&\n                property.bufferView > bufferViewId\n              ) {\n                property.bufferView--;\n              }\n              if (\n                defined(property.arrayOffsetBufferView) &&\n                property.arrayOffsetBufferView > bufferViewId\n              ) {\n                property.arrayOffsetBufferView--;\n              }\n              if (\n                defined(property.stringOffsetBufferView) &&\n                property.stringOffsetBufferView > bufferViewId\n              ) {\n                property.stringOffsetBufferView--;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (usesExtension(gltf, \"EXT_structural_metadata\")) {\n    const extension = gltf.extensions.EXT_structural_metadata;\n    const propertyTables = extension.propertyTables;\n    if (defined(propertyTables)) {\n      const propertyTablesLength = propertyTables.length;\n      for (let i = 0; i < propertyTablesLength; ++i) {\n        const propertyTable = propertyTables[i];\n        const properties = propertyTable.properties;\n        for (const propertyId in properties) {\n          if (properties.hasOwnProperty(propertyId)) {\n            const property = properties[propertyId];\n            if (defined(property.values) && property.values > bufferViewId) {\n              property.values--;\n            }\n            if (\n              defined(property.arrayOffsets) &&\n              property.arrayOffsets > bufferViewId\n            ) {\n              property.arrayOffsets--;\n            }\n            if (\n              defined(property.stringOffsets) &&\n              property.stringOffsets > bufferViewId\n            ) {\n              property.stringOffsets--;\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nRemove.image = function (gltf, imageId) {\n  const images = gltf.images;\n  images.splice(imageId, 1);\n\n  ForEach.texture(gltf, function (texture) {\n    if (defined(texture.source)) {\n      if (texture.source > imageId) {\n        --texture.source;\n      }\n    }\n    const ext = texture.extensions;\n    if (\n      defined(ext) &&\n      defined(ext.EXT_texture_webp) &&\n      ext.EXT_texture_webp.source > imageId\n    ) {\n      --texture.extensions.EXT_texture_webp.source;\n    } else if (\n      defined(ext) &&\n      defined(ext.KHR_texture_basisu) &&\n      ext.KHR_texture_basisu.source > imageId\n    ) {\n      --texture.extensions.KHR_texture_basisu.source;\n    }\n  });\n};\n\nRemove.mesh = function (gltf, meshId) {\n  const meshes = gltf.meshes;\n  meshes.splice(meshId, 1);\n\n  ForEach.node(gltf, function (node) {\n    if (defined(node.mesh)) {\n      if (node.mesh > meshId) {\n        node.mesh--;\n      } else if (node.mesh === meshId) {\n        // Remove reference to deleted mesh\n        delete node.mesh;\n      }\n    }\n  });\n};\n\nRemove.node = function (gltf, nodeId) {\n  const nodes = gltf.nodes;\n  nodes.splice(nodeId, 1);\n\n  // Shift all node references\n  ForEach.skin(gltf, function (skin) {\n    if (defined(skin.skeleton) && skin.skeleton > nodeId) {\n      skin.skeleton--;\n    }\n\n    skin.joints = skin.joints.map(function (x) {\n      return x > nodeId ? x - 1 : x;\n    });\n  });\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationChannel(animation, function (channel) {\n      if (\n        defined(channel.target) &&\n        defined(channel.target.node) &&\n        channel.target.node > nodeId\n      ) {\n        channel.target.node--;\n      }\n    });\n  });\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueUniform(technique, function (uniform) {\n      if (defined(uniform.node) && uniform.node > nodeId) {\n        uniform.node--;\n      }\n    });\n  });\n  ForEach.node(gltf, function (node) {\n    if (!defined(node.children)) {\n      return;\n    }\n\n    node.children = node.children\n      .filter(function (x) {\n        return x !== nodeId; // Remove\n      })\n      .map(function (x) {\n        return x > nodeId ? x - 1 : x; // Shift indices\n      });\n  });\n  ForEach.scene(gltf, function (scene) {\n    scene.nodes = scene.nodes\n      .filter(function (x) {\n        return x !== nodeId; // Remove\n      })\n      .map(function (x) {\n        return x > nodeId ? x - 1 : x; // Shift indices\n      });\n  });\n};\n\nRemove.material = function (gltf, materialId) {\n  const materials = gltf.materials;\n  materials.splice(materialId, 1);\n\n  // Shift other material ids\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      if (defined(primitive.material) && primitive.material > materialId) {\n        primitive.material--;\n      }\n    });\n  });\n};\n\nRemove.sampler = function (gltf, samplerId) {\n  const samplers = gltf.samplers;\n  samplers.splice(samplerId, 1);\n\n  ForEach.texture(gltf, function (texture) {\n    if (defined(texture.sampler)) {\n      if (texture.sampler > samplerId) {\n        --texture.sampler;\n      }\n    }\n  });\n};\n\nRemove.texture = function (gltf, textureId) {\n  const textures = gltf.textures;\n  textures.splice(textureId, 1);\n\n  ForEach.material(gltf, function (material) {\n    forEachTextureInMaterial(material, function (textureIndex, textureInfo) {\n      if (textureInfo.index > textureId) {\n        --textureInfo.index;\n      }\n    });\n  });\n\n  if (usesExtension(gltf, \"EXT_feature_metadata\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        const extensions = primitive.extensions;\n        if (defined(extensions) && defined(extensions.EXT_feature_metadata)) {\n          const extension = extensions.EXT_feature_metadata;\n          const featureIdTextures = extension.featureIdTextures;\n          if (defined(featureIdTextures)) {\n            const featureIdTexturesLength = featureIdTextures.length;\n            for (let i = 0; i < featureIdTexturesLength; ++i) {\n              const featureIdTexture = featureIdTextures[i];\n              const textureInfo = featureIdTexture.featureIds.texture;\n              if (textureInfo.index > textureId) {\n                --textureInfo.index;\n              }\n            }\n          }\n        }\n      });\n    });\n\n    const extension = gltf.extensions.EXT_feature_metadata;\n    const featureTextures = extension.featureTextures;\n    for (const featureTextureId in featureTextures) {\n      if (featureTextures.hasOwnProperty(featureTextureId)) {\n        const featureTexture = featureTextures[featureTextureId];\n        const properties = featureTexture.properties;\n        if (defined(properties)) {\n          for (const propertyId in properties) {\n            if (properties.hasOwnProperty(propertyId)) {\n              const property = properties[propertyId];\n              const textureInfo = property.texture;\n              if (textureInfo.index > textureId) {\n                --textureInfo.index;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (usesExtension(gltf, \"EXT_mesh_features\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        const extensions = primitive.extensions;\n        if (defined(extensions) && defined(extensions.EXT_mesh_features)) {\n          const extension = extensions.EXT_mesh_features;\n          const featureIds = extension.featureIds;\n          if (defined(featureIds)) {\n            const featureIdsLength = featureIds.length;\n            for (let i = 0; i < featureIdsLength; ++i) {\n              const featureId = featureIds[i];\n              if (defined(featureId.texture)) {\n                if (featureId.texture.index > textureId) {\n                  --featureId.texture.index;\n                }\n              }\n            }\n          }\n        }\n      });\n    });\n  }\n\n  if (usesExtension(gltf, \"EXT_structural_metadata\")) {\n    const extension = gltf.extensions.EXT_structural_metadata;\n    const propertyTextures = extension.propertyTextures;\n    if (defined(propertyTextures)) {\n      const propertyTexturesLength = propertyTextures.length;\n      for (let i = 0; i < propertyTexturesLength; ++i) {\n        const propertyTexture = propertyTextures[i];\n        const properties = propertyTexture.properties;\n        for (const propertyId in properties) {\n          if (properties.hasOwnProperty(propertyId)) {\n            const property = properties[propertyId];\n            if (property.index > textureId) {\n              --property.index;\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\n/**\n * Contains functions for getting a list of element ids in use by the glTF asset.\n * @constructor\n *\n * @private\n */\nfunction getListOfElementsIdsInUse() {}\n\ngetListOfElementsIdsInUse.accessor = function (gltf) {\n  // Calculate accessor's that are currently in use.\n  const usedAccessorIds = {};\n\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      ForEach.meshPrimitiveAttribute(primitive, function (accessorId) {\n        usedAccessorIds[accessorId] = true;\n      });\n      ForEach.meshPrimitiveTarget(primitive, function (target) {\n        ForEach.meshPrimitiveTargetAttribute(target, function (accessorId) {\n          usedAccessorIds[accessorId] = true;\n        });\n      });\n      const indices = primitive.indices;\n      if (defined(indices)) {\n        usedAccessorIds[indices] = true;\n      }\n    });\n  });\n\n  ForEach.skin(gltf, function (skin) {\n    if (defined(skin.inverseBindMatrices)) {\n      usedAccessorIds[skin.inverseBindMatrices] = true;\n    }\n  });\n\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      if (defined(sampler.input)) {\n        usedAccessorIds[sampler.input] = true;\n      }\n      if (defined(sampler.output)) {\n        usedAccessorIds[sampler.output] = true;\n      }\n    });\n  });\n\n  if (usesExtension(gltf, \"EXT_mesh_gpu_instancing\")) {\n    ForEach.node(gltf, function (node) {\n      if (\n        defined(node.extensions) &&\n        defined(node.extensions.EXT_mesh_gpu_instancing)\n      ) {\n        Object.keys(node.extensions.EXT_mesh_gpu_instancing.attributes).forEach(\n          function (key) {\n            const attributeAccessorId =\n              node.extensions.EXT_mesh_gpu_instancing.attributes[key];\n            usedAccessorIds[attributeAccessorId] = true;\n          },\n        );\n      }\n    });\n  }\n\n  if (usesExtension(gltf, \"CESIUM_primitive_outline\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        const extensions = primitive.extensions;\n        if (\n          defined(extensions) &&\n          defined(extensions.CESIUM_primitive_outline)\n        ) {\n          const extension = extensions.CESIUM_primitive_outline;\n          const indicesAccessorId = extension.indices;\n          if (defined(indicesAccessorId)) {\n            usedAccessorIds[indicesAccessorId] = true;\n          }\n        }\n      });\n    });\n  }\n\n  return usedAccessorIds;\n};\n\ngetListOfElementsIdsInUse.buffer = function (gltf) {\n  // Calculate buffer's that are currently in use.\n  const usedBufferIds = {};\n\n  ForEach.bufferView(gltf, function (bufferView) {\n    if (defined(bufferView.buffer)) {\n      usedBufferIds[bufferView.buffer] = true;\n    }\n    if (\n      defined(bufferView.extensions) &&\n      defined(bufferView.extensions.EXT_meshopt_compression)\n    ) {\n      usedBufferIds[bufferView.extensions.EXT_meshopt_compression.buffer] =\n        true;\n    }\n  });\n\n  return usedBufferIds;\n};\n\ngetListOfElementsIdsInUse.bufferView = function (gltf) {\n  // Calculate bufferView's that are currently in use.\n  const usedBufferViewIds = {};\n\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView)) {\n      usedBufferViewIds[accessor.bufferView] = true;\n    }\n  });\n\n  ForEach.shader(gltf, function (shader) {\n    if (defined(shader.bufferView)) {\n      usedBufferViewIds[shader.bufferView] = true;\n    }\n  });\n\n  ForEach.image(gltf, function (image) {\n    if (defined(image.bufferView)) {\n      usedBufferViewIds[image.bufferView] = true;\n    }\n  });\n\n  if (usesExtension(gltf, \"KHR_draco_mesh_compression\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        if (\n          defined(primitive.extensions) &&\n          defined(primitive.extensions.KHR_draco_mesh_compression)\n        ) {\n          usedBufferViewIds[\n            primitive.extensions.KHR_draco_mesh_compression.bufferView\n          ] = true;\n        }\n      });\n    });\n  }\n\n  if (usesExtension(gltf, \"EXT_feature_metadata\")) {\n    const extension = gltf.extensions.EXT_feature_metadata;\n    const featureTables = extension.featureTables;\n    for (const featureTableId in featureTables) {\n      if (featureTables.hasOwnProperty(featureTableId)) {\n        const featureTable = featureTables[featureTableId];\n        const properties = featureTable.properties;\n        if (defined(properties)) {\n          for (const propertyId in properties) {\n            if (properties.hasOwnProperty(propertyId)) {\n              const property = properties[propertyId];\n              if (defined(property.bufferView)) {\n                usedBufferViewIds[property.bufferView] = true;\n              }\n              if (defined(property.arrayOffsetBufferView)) {\n                usedBufferViewIds[property.arrayOffsetBufferView] = true;\n              }\n              if (defined(property.stringOffsetBufferView)) {\n                usedBufferViewIds[property.stringOffsetBufferView] = true;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (usesExtension(gltf, \"EXT_structural_metadata\")) {\n    const extension = gltf.extensions.EXT_structural_metadata;\n    const propertyTables = extension.propertyTables;\n    if (defined(propertyTables)) {\n      const propertyTablesLength = propertyTables.length;\n      for (let i = 0; i < propertyTablesLength; ++i) {\n        const propertyTable = propertyTables[i];\n        const properties = propertyTable.properties;\n        for (const propertyId in properties) {\n          if (properties.hasOwnProperty(propertyId)) {\n            const property = properties[propertyId];\n            if (defined(property.values)) {\n              usedBufferViewIds[property.values] = true;\n            }\n            if (defined(property.arrayOffsets)) {\n              usedBufferViewIds[property.arrayOffsets] = true;\n            }\n            if (defined(property.stringOffsets)) {\n              usedBufferViewIds[property.stringOffsets] = true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return usedBufferViewIds;\n};\n\ngetListOfElementsIdsInUse.image = function (gltf) {\n  const usedImageIds = {};\n\n  ForEach.texture(gltf, function (texture) {\n    if (defined(texture.source)) {\n      usedImageIds[texture.source] = true;\n    }\n\n    if (\n      defined(texture.extensions) &&\n      defined(texture.extensions.EXT_texture_webp)\n    ) {\n      usedImageIds[texture.extensions.EXT_texture_webp.source] = true;\n    } else if (\n      defined(texture.extensions) &&\n      defined(texture.extensions.KHR_texture_basisu)\n    ) {\n      usedImageIds[texture.extensions.KHR_texture_basisu.source] = true;\n    }\n  });\n  return usedImageIds;\n};\n\ngetListOfElementsIdsInUse.mesh = function (gltf) {\n  const usedMeshIds = {};\n  ForEach.node(gltf, function (node) {\n    if (defined(node.mesh && defined(gltf.meshes))) {\n      const mesh = gltf.meshes[node.mesh];\n      if (\n        defined(mesh) &&\n        defined(mesh.primitives) &&\n        mesh.primitives.length > 0\n      ) {\n        usedMeshIds[node.mesh] = true;\n      }\n    }\n  });\n\n  return usedMeshIds;\n};\n\n// Check if node is empty. It is considered empty if neither referencing\n// mesh, camera, extensions and has no children\nfunction nodeIsEmpty(gltf, nodeId, usedNodeIds) {\n  const node = gltf.nodes[nodeId];\n  if (\n    defined(node.mesh) ||\n    defined(node.camera) ||\n    defined(node.skin) ||\n    defined(node.weights) ||\n    defined(node.extras) ||\n    (defined(node.extensions) && Object.keys(node.extensions).length !== 0) ||\n    defined(usedNodeIds[nodeId])\n  ) {\n    return false;\n  }\n\n  // Empty if no children or children are all empty nodes\n  return (\n    !defined(node.children) ||\n    node.children.filter(function (n) {\n      return !nodeIsEmpty(gltf, n, usedNodeIds);\n    }).length === 0\n  );\n}\n\ngetListOfElementsIdsInUse.node = function (gltf) {\n  const usedNodeIds = {};\n  ForEach.skin(gltf, function (skin) {\n    if (defined(skin.skeleton)) {\n      usedNodeIds[skin.skeleton] = true;\n    }\n\n    ForEach.skinJoint(skin, function (joint) {\n      usedNodeIds[joint] = true;\n    });\n  });\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationChannel(animation, function (channel) {\n      if (defined(channel.target) && defined(channel.target.node)) {\n        usedNodeIds[channel.target.node] = true;\n      }\n    });\n  });\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueUniform(technique, function (uniform) {\n      if (defined(uniform.node)) {\n        usedNodeIds[uniform.node] = true;\n      }\n    });\n  });\n  ForEach.node(gltf, function (node, nodeId) {\n    if (!nodeIsEmpty(gltf, nodeId, usedNodeIds)) {\n      usedNodeIds[nodeId] = true;\n    }\n  });\n\n  return usedNodeIds;\n};\n\ngetListOfElementsIdsInUse.material = function (gltf) {\n  const usedMaterialIds = {};\n\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      if (defined(primitive.material)) {\n        usedMaterialIds[primitive.material] = true;\n      }\n    });\n  });\n\n  return usedMaterialIds;\n};\n\ngetListOfElementsIdsInUse.texture = function (gltf) {\n  const usedTextureIds = {};\n\n  ForEach.material(gltf, function (material) {\n    forEachTextureInMaterial(material, function (textureId) {\n      usedTextureIds[textureId] = true;\n    });\n  });\n\n  if (usesExtension(gltf, \"EXT_feature_metadata\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        const extensions = primitive.extensions;\n        if (defined(extensions) && defined(extensions.EXT_feature_metadata)) {\n          const extension = extensions.EXT_feature_metadata;\n          const featureIdTextures = extension.featureIdTextures;\n          if (defined(featureIdTextures)) {\n            const featureIdTexturesLength = featureIdTextures.length;\n            for (let i = 0; i < featureIdTexturesLength; ++i) {\n              const featureIdTexture = featureIdTextures[i];\n              const textureInfo = featureIdTexture.featureIds.texture;\n              usedTextureIds[textureInfo.index] = true;\n            }\n          }\n        }\n      });\n    });\n\n    const extension = gltf.extensions.EXT_feature_metadata;\n    const featureTextures = extension.featureTextures;\n    for (const featureTextureId in featureTextures) {\n      if (featureTextures.hasOwnProperty(featureTextureId)) {\n        const featureTexture = featureTextures[featureTextureId];\n        const properties = featureTexture.properties;\n        if (defined(properties)) {\n          for (const propertyId in properties) {\n            if (properties.hasOwnProperty(propertyId)) {\n              const property = properties[propertyId];\n              const textureInfo = property.texture;\n              usedTextureIds[textureInfo.index] = true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (usesExtension(gltf, \"EXT_mesh_features\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        const extensions = primitive.extensions;\n        if (defined(extensions) && defined(extensions.EXT_mesh_features)) {\n          const extension = extensions.EXT_mesh_features;\n          const featureIds = extension.featureIds;\n          if (defined(featureIds)) {\n            const featureIdsLength = featureIds.length;\n            for (let i = 0; i < featureIdsLength; ++i) {\n              const featureId = featureIds[i];\n              if (defined(featureId.texture)) {\n                usedTextureIds[featureId.texture.index] = true;\n              }\n            }\n          }\n        }\n      });\n    });\n  }\n\n  if (usesExtension(gltf, \"EXT_structural_metadata\")) {\n    const extension = gltf.extensions.EXT_structural_metadata;\n    const propertyTextures = extension.propertyTextures;\n    if (defined(propertyTextures)) {\n      const propertyTexturesLength = propertyTextures.length;\n      for (let i = 0; i < propertyTexturesLength; ++i) {\n        const propertyTexture = propertyTextures[i];\n        const properties = propertyTexture.properties;\n        for (const propertyId in properties) {\n          if (properties.hasOwnProperty(propertyId)) {\n            const property = properties[propertyId];\n            usedTextureIds[property.index] = true;\n          }\n        }\n      }\n    }\n  }\n\n  return usedTextureIds;\n};\n\ngetListOfElementsIdsInUse.sampler = function (gltf) {\n  const usedSamplerIds = {};\n\n  ForEach.texture(gltf, function (texture) {\n    if (defined(texture.sampler)) {\n      usedSamplerIds[texture.sampler] = true;\n    }\n  });\n\n  return usedSamplerIds;\n};\n\nexport default removeUnusedElements;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}