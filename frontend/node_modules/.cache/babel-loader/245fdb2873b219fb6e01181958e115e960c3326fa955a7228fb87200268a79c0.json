{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"void modelClippingPolygonsStage(ProcessedAttributes attributes)\\n\\\n{\\n\\\n    vec2 sphericalLatLong = czm_approximateSphericalCoordinates(v_positionWC);\\n\\\n    sphericalLatLong.y = czm_branchFreeTernary(sphericalLatLong.y < czm_pi, sphericalLatLong.y, sphericalLatLong.y - czm_twoPi);\\n\\\n\\n\\\n    vec2 minDistance = vec2(czm_infinity);\\n\\\n    v_regionIndex = -1;\\n\\\n    v_clippingPosition = vec2(czm_infinity);\\n\\\n\\n\\\n    for (int regionIndex = 0; regionIndex < CLIPPING_POLYGON_REGIONS_LENGTH; regionIndex++) {\\n\\\n        vec4 extents = czm_unpackClippingExtents(model_clippingExtents, regionIndex);\\n\\\n        vec2 rectUv = (sphericalLatLong.yx - extents.yx) * extents.wz;\\n\\\n\\n\\\n        vec2 clamped = clamp(rectUv, vec2(0.0), vec2(1.0));\\n\\\n        vec2 distance = abs(rectUv - clamped) * extents.wz;\\n\\\n        \\n\\\n        if (minDistance.x > distance.x || minDistance.y > distance.y) {\\n\\\n            minDistance = distance;\\n\\\n            v_clippingPosition = rectUv;\\n\\\n        }\\n\\\n\\n\\\n        float threshold = 0.01;\\n\\\n        if (rectUv.x > threshold && rectUv.y > threshold && rectUv.x < 1.0 - threshold && rectUv.y < 1.0 - threshold) {\\n\\\n            v_regionIndex = regionIndex;\\n\\\n        }\\n\\\n    }\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Shaders/Model/ModelClippingPolygonsStageVS.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"void modelClippingPolygonsStage(ProcessedAttributes attributes)\\n\\\n{\\n\\\n    vec2 sphericalLatLong = czm_approximateSphericalCoordinates(v_positionWC);\\n\\\n    sphericalLatLong.y = czm_branchFreeTernary(sphericalLatLong.y < czm_pi, sphericalLatLong.y, sphericalLatLong.y - czm_twoPi);\\n\\\n\\n\\\n    vec2 minDistance = vec2(czm_infinity);\\n\\\n    v_regionIndex = -1;\\n\\\n    v_clippingPosition = vec2(czm_infinity);\\n\\\n\\n\\\n    for (int regionIndex = 0; regionIndex < CLIPPING_POLYGON_REGIONS_LENGTH; regionIndex++) {\\n\\\n        vec4 extents = czm_unpackClippingExtents(model_clippingExtents, regionIndex);\\n\\\n        vec2 rectUv = (sphericalLatLong.yx - extents.yx) * extents.wz;\\n\\\n\\n\\\n        vec2 clamped = clamp(rectUv, vec2(0.0), vec2(1.0));\\n\\\n        vec2 distance = abs(rectUv - clamped) * extents.wz;\\n\\\n        \\n\\\n        if (minDistance.x > distance.x || minDistance.y > distance.y) {\\n\\\n            minDistance = distance;\\n\\\n            v_clippingPosition = rectUv;\\n\\\n        }\\n\\\n\\n\\\n        float threshold = 0.01;\\n\\\n        if (rectUv.x > threshold && rectUv.y > threshold && rectUv.x < 1.0 - threshold && rectUv.y < 1.0 - threshold) {\\n\\\n            v_regionIndex = regionIndex;\\n\\\n        }\\n\\\n    }\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}