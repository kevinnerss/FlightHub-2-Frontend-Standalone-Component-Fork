{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"void filterByPassType(vec4 featureColor)\\n\\\n{\\n\\\n    bool styleTranslucent = (featureColor.a != 1.0);\\n\\\n    // Only render translucent features in the translucent pass (if the style or the original command has translucency).\\n\\\n    if (czm_pass == czm_passTranslucent && !styleTranslucent && !model_commandTranslucent)\\n\\\n    {   \\n\\\n        // If the model has a translucent silhouette, it needs to render during the silhouette color command,\\n\\\n        // (i.e. the command where model_silhouettePass = true), even if the model isn't translucent.\\n\\\n        #ifdef HAS_SILHOUETTE\\n\\\n        if(!model_silhouettePass) {\\n\\\n            discard;\\n\\\n        }\\n\\\n        #else\\n\\\n        discard;\\n\\\n        #endif\\n\\\n    }\\n\\\n    // If the current pass is not the translucent pass and the style is not translucent, don't render the feature.\\n\\\n    else if (czm_pass != czm_passTranslucent && styleTranslucent)\\n\\\n    {\\n\\\n        discard;\\n\\\n    }\\n\\\n}\\n\\\n\\n\\\nvoid cpuStylingStage(inout czm_modelMaterial material, SelectedFeature feature)\\n\\\n{\\n\\\n    vec4 featureColor = feature.color;\\n\\\n    if (featureColor.a == 0.0)\\n\\\n    {\\n\\\n        discard;\\n\\\n    }\\n\\\n\\n\\\n    // If a feature ID vertex attribute is used, the pass type filter is applied in the vertex shader.\\n\\\n    // So, we only apply in in the fragment shader if the feature ID texture is used.\\n\\\n    #if defined(HAS_SELECTED_FEATURE_ID_TEXTURE) && !defined(HAS_CLASSIFICATION)\\n\\\n    filterByPassType(featureColor);\\n\\\n    #endif\\n\\\n\\n\\\n    featureColor = czm_gammaCorrect(featureColor);\\n\\\n\\n\\\n    // Classification models compute the diffuse differently.\\n\\\n    #ifdef HAS_CLASSIFICATION\\n\\\n    material.diffuse = featureColor.rgb * featureColor.a;\\n\\\n    #else\\n\\\n    float highlight = ceil(model_colorBlend);\\n\\\n    material.diffuse *= mix(featureColor.rgb, vec3(1.0), highlight);\\n\\\n    #endif\\n\\\n    \\n\\\n    material.alpha *= featureColor.a;\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Shaders/Model/CPUStylingStageFS.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"void filterByPassType(vec4 featureColor)\\n\\\n{\\n\\\n    bool styleTranslucent = (featureColor.a != 1.0);\\n\\\n    // Only render translucent features in the translucent pass (if the style or the original command has translucency).\\n\\\n    if (czm_pass == czm_passTranslucent && !styleTranslucent && !model_commandTranslucent)\\n\\\n    {   \\n\\\n        // If the model has a translucent silhouette, it needs to render during the silhouette color command,\\n\\\n        // (i.e. the command where model_silhouettePass = true), even if the model isn't translucent.\\n\\\n        #ifdef HAS_SILHOUETTE\\n\\\n        if(!model_silhouettePass) {\\n\\\n            discard;\\n\\\n        }\\n\\\n        #else\\n\\\n        discard;\\n\\\n        #endif\\n\\\n    }\\n\\\n    // If the current pass is not the translucent pass and the style is not translucent, don't render the feature.\\n\\\n    else if (czm_pass != czm_passTranslucent && styleTranslucent)\\n\\\n    {\\n\\\n        discard;\\n\\\n    }\\n\\\n}\\n\\\n\\n\\\nvoid cpuStylingStage(inout czm_modelMaterial material, SelectedFeature feature)\\n\\\n{\\n\\\n    vec4 featureColor = feature.color;\\n\\\n    if (featureColor.a == 0.0)\\n\\\n    {\\n\\\n        discard;\\n\\\n    }\\n\\\n\\n\\\n    // If a feature ID vertex attribute is used, the pass type filter is applied in the vertex shader.\\n\\\n    // So, we only apply in in the fragment shader if the feature ID texture is used.\\n\\\n    #if defined(HAS_SELECTED_FEATURE_ID_TEXTURE) && !defined(HAS_CLASSIFICATION)\\n\\\n    filterByPassType(featureColor);\\n\\\n    #endif\\n\\\n\\n\\\n    featureColor = czm_gammaCorrect(featureColor);\\n\\\n\\n\\\n    // Classification models compute the diffuse differently.\\n\\\n    #ifdef HAS_CLASSIFICATION\\n\\\n    material.diffuse = featureColor.rgb * featureColor.a;\\n\\\n    #else\\n\\\n    float highlight = ceil(model_colorBlend);\\n\\\n    material.diffuse *= mix(featureColor.rgb, vec3(1.0), highlight);\\n\\\n    #endif\\n\\\n    \\n\\\n    material.alpha *= featureColor.a;\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}