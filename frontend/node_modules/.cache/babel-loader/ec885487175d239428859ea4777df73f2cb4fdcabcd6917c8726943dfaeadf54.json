{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport ShadowVolumeFS from \"../Shaders/ShadowVolumeFS.js\";\nimport VectorTileVS from \"../Shaders/VectorTileVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileFeature from \"./Cesium3DTileFeature.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport Expression from \"./Expression.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\nimport Vector3DTileBatch from \"./Vector3DTileBatch.js\";\n\n/**\n * Creates a batch of classification meshes.\n *\n * @alias Vector3DTilePrimitive\n * @constructor\n *\n * @param {object} options An object with following properties:\n * @param {Float32Array} options.positions The positions of the meshes.\n * @param {Uint16Array|Uint32Array} options.indices The indices of the triangulated meshes. The indices must be contiguous so that\n * the indices for mesh n are in [i, i + indexCounts[n]] where i = sum{indexCounts[0], indexCounts[n - 1]}.\n * @param {Uint32Array} options.indexCounts The number of indices for each mesh.\n * @param {Uint32Array} options.indexOffsets The offset into the index buffer for each mesh.\n * @param {Vector3DTileBatch[]} options.batchedIndices The index offset and count for each batch with the same color.\n * @param {Cartesian3} [options.center=Cartesian3.ZERO] The RTC center.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table for the tile containing the batched meshes.\n * @param {Uint16Array} options.batchIds The batch ids for each mesh.\n * @param {Uint16Array} options.vertexBatchIds The batch id for each vertex.\n * @param {BoundingSphere} options.boundingVolume The bounding volume for the entire batch of meshes.\n * @param {BoundingSphere[]} options.boundingVolumes The bounding volume for each mesh.\n * @param {ClassificationType} [options.classificationType] What this tile will classify.\n *\n * @private\n */\nfunction Vector3DTilePrimitive(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  this._batchTable = options.batchTable;\n  this._batchIds = options.batchIds;\n\n  // These arrays are released after VAO creation.\n  this._positions = options.positions;\n  this._vertexBatchIds = options.vertexBatchIds;\n\n  // These arrays are kept for re-batching indices based on colors.\n  // If WebGL 2 is supported, indices will be released and re-batching uses buffer-to-buffer copies.\n  this._indices = options.indices;\n  this._indexCounts = options.indexCounts;\n  this._indexOffsets = options.indexOffsets;\n  this._batchedIndices = options.batchedIndices;\n  this._boundingVolume = options.boundingVolume;\n  this._boundingVolumes = options.boundingVolumes;\n  this._center = options.center ?? Cartesian3.ZERO;\n  this._va = undefined;\n  this._sp = undefined;\n  this._spStencil = undefined;\n  this._spPick = undefined;\n  this._uniformMap = undefined;\n\n  // Only used with WebGL 2 to ping-pong ibos after copy.\n  this._vaSwap = undefined;\n  this._rsStencilDepthPass = undefined;\n  this._rsStencilDepthPass3DTiles = undefined;\n  this._rsColorPass = undefined;\n  this._rsPickPass = undefined;\n  this._rsWireframe = undefined;\n  this._commands = [];\n  this._commandsIgnoreShow = [];\n  this._pickCommands = [];\n  this._constantColor = Color.clone(Color.WHITE);\n  this._highlightColor = this._constantColor;\n  this._batchDirty = true;\n  this._pickCommandsDirty = true;\n  this._framesSinceLastRebatch = 0;\n  this._updatingAllCommands = false;\n  this._trianglesLength = this._indices.length / 3;\n  this._geometryByteLength = this._indices.byteLength + this._positions.byteLength + this._vertexBatchIds.byteLength;\n\n  /**\n   * Draw the wireframe of the classification meshes.\n   * @type {boolean}\n   * @default false\n   */\n  this.debugWireframe = false;\n  this._debugWireframe = this.debugWireframe;\n  this._wireframeDirty = false;\n\n  /**\n   * Forces a re-batch instead of waiting after a number of frames have been rendered. For testing only.\n   * @type {boolean}\n   * @default false\n   */\n  this.forceRebatch = false;\n\n  /**\n   * What this tile will classify.\n   * @type {ClassificationType}\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType = options.classificationType ?? ClassificationType.BOTH;\n\n  // Hidden options\n  this._vertexShaderSource = options._vertexShaderSource;\n  this._fragmentShaderSource = options._fragmentShaderSource;\n  this._attributeLocations = options._attributeLocations;\n  this._uniformMap = options._uniformMap;\n  this._pickId = options._pickId;\n  this._modelMatrix = options._modelMatrix;\n  this._boundingSphere = options._boundingSphere;\n  this._batchIdLookUp = {};\n  const length = this._batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = this._batchIds[i];\n    this._batchIdLookUp[batchId] = i;\n  }\n}\nObject.defineProperties(Vector3DTilePrimitive.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTilePrimitive.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  trianglesLength: {\n    get: function () {\n      return this._trianglesLength;\n    }\n  },\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTilePrimitive.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    }\n  }\n});\nconst defaultAttributeLocations = {\n  position: 0,\n  a_batchId: 1\n};\nfunction createVertexArray(primitive, context) {\n  if (defined(primitive._va)) {\n    return;\n  }\n  const positionBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: primitive._positions,\n    usage: BufferUsage.STATIC_DRAW\n  });\n  const idBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: primitive._vertexBatchIds,\n    usage: BufferUsage.STATIC_DRAW\n  });\n  const indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: primitive._indices,\n    usage: BufferUsage.DYNAMIC_DRAW,\n    indexDatatype: primitive._indices.BYTES_PER_ELEMENT === 2 ? IndexDatatype.UNSIGNED_SHORT : IndexDatatype.UNSIGNED_INT\n  });\n  const vertexAttributes = [{\n    index: 0,\n    vertexBuffer: positionBuffer,\n    componentDatatype: ComponentDatatype.fromTypedArray(primitive._positions),\n    componentsPerAttribute: 3\n  }, {\n    index: 1,\n    vertexBuffer: idBuffer,\n    componentDatatype: ComponentDatatype.fromTypedArray(primitive._vertexBatchIds),\n    componentsPerAttribute: 1\n  }];\n  primitive._va = new VertexArray({\n    context: context,\n    attributes: vertexAttributes,\n    indexBuffer: indexBuffer\n  });\n  if (context.webgl2) {\n    primitive._vaSwap = new VertexArray({\n      context: context,\n      attributes: vertexAttributes,\n      indexBuffer: Buffer.createIndexBuffer({\n        context: context,\n        sizeInBytes: indexBuffer.sizeInBytes,\n        usage: BufferUsage.DYNAMIC_DRAW,\n        indexDatatype: indexBuffer.indexDatatype\n      })\n    });\n  }\n  primitive._batchedPositions = undefined;\n  primitive._transferrableBatchIds = undefined;\n  primitive._vertexBatchIds = undefined;\n}\nfunction createShaders(primitive, context) {\n  if (defined(primitive._sp)) {\n    return;\n  }\n  const batchTable = primitive._batchTable;\n  const attributeLocations = primitive._attributeLocations ?? defaultAttributeLocations;\n  let pickId = primitive._pickId;\n  const vertexShaderSource = primitive._vertexShaderSource;\n  let fragmentShaderSource = primitive._fragmentShaderSource;\n  if (defined(vertexShaderSource)) {\n    primitive._sp = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vertexShaderSource,\n      fragmentShaderSource: fragmentShaderSource,\n      attributeLocations: attributeLocations\n    });\n    primitive._spStencil = primitive._sp;\n    fragmentShaderSource = ShaderSource.replaceMain(fragmentShaderSource, \"czm_non_pick_main\");\n    fragmentShaderSource = `${fragmentShaderSource}void main() \\n` + `{ \\n` + `    czm_non_pick_main(); \\n` + `    out_FragColor = ${pickId}; \\n` + `} \\n`;\n    primitive._spPick = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vertexShaderSource,\n      fragmentShaderSource: fragmentShaderSource,\n      attributeLocations: attributeLocations\n    });\n    return;\n  }\n  const vsSource = batchTable.getVertexShaderCallback(false, \"a_batchId\", undefined)(VectorTileVS);\n  let fsSource = batchTable.getFragmentShaderCallback(false, undefined, true)(ShadowVolumeFS);\n  pickId = batchTable.getPickId();\n  let vs = new ShaderSource({\n    sources: [vsSource]\n  });\n  let fs = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [fsSource]\n  });\n  primitive._sp = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n  vs = new ShaderSource({\n    sources: [VectorTileVS]\n  });\n  fs = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [ShadowVolumeFS]\n  });\n  primitive._spStencil = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n  fsSource = ShaderSource.replaceMain(fsSource, \"czm_non_pick_main\");\n  fsSource = `${fsSource}\\n` + `void main() \\n` + `{ \\n` + `    czm_non_pick_main(); \\n` + `    out_FragColor = ${pickId}; \\n` + `} \\n`;\n  const pickVS = new ShaderSource({\n    sources: [vsSource]\n  });\n  const pickFS = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [fsSource]\n  });\n  primitive._spPick = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: pickVS,\n    fragmentShaderSource: pickFS,\n    attributeLocations: attributeLocations\n  });\n}\nfunction getStencilDepthRenderState(mask3DTiles) {\n  const stencilFunction = mask3DTiles ? StencilFunction.EQUAL : StencilFunction.ALWAYS;\n  return {\n    colorMask: {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false\n    },\n    stencilTest: {\n      enabled: true,\n      frontFunction: stencilFunction,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.DECREMENT_WRAP,\n        zPass: StencilOperation.KEEP\n      },\n      backFunction: stencilFunction,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.INCREMENT_WRAP,\n        zPass: StencilOperation.KEEP\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK\n    },\n    stencilMask: StencilConstants.CLASSIFICATION_MASK,\n    depthTest: {\n      enabled: true,\n      func: DepthFunction.LESS_OR_EQUAL\n    },\n    depthMask: false\n  };\n}\nconst colorRenderState = {\n  stencilTest: {\n    enabled: true,\n    frontFunction: StencilFunction.NOT_EQUAL,\n    frontOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO\n    },\n    backFunction: StencilFunction.NOT_EQUAL,\n    backOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO\n    },\n    reference: 0,\n    mask: StencilConstants.CLASSIFICATION_MASK\n  },\n  stencilMask: StencilConstants.CLASSIFICATION_MASK,\n  depthTest: {\n    enabled: false\n  },\n  depthMask: false,\n  blending: BlendingState.PRE_MULTIPLIED_ALPHA_BLEND\n};\nconst pickRenderState = {\n  stencilTest: {\n    enabled: true,\n    frontFunction: StencilFunction.NOT_EQUAL,\n    frontOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO\n    },\n    backFunction: StencilFunction.NOT_EQUAL,\n    backOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO\n    },\n    reference: 0,\n    mask: StencilConstants.CLASSIFICATION_MASK\n  },\n  stencilMask: StencilConstants.CLASSIFICATION_MASK,\n  depthTest: {\n    enabled: false\n  },\n  depthMask: false\n};\nfunction createRenderStates(primitive) {\n  if (defined(primitive._rsStencilDepthPass)) {\n    return;\n  }\n  primitive._rsStencilDepthPass = RenderState.fromCache(getStencilDepthRenderState(false));\n  primitive._rsStencilDepthPass3DTiles = RenderState.fromCache(getStencilDepthRenderState(true));\n  primitive._rsColorPass = RenderState.fromCache(colorRenderState);\n  primitive._rsPickPass = RenderState.fromCache(pickRenderState);\n}\nconst modifiedModelViewScratch = new Matrix4();\nconst rtcScratch = new Cartesian3();\nfunction createUniformMap(primitive, context) {\n  if (defined(primitive._uniformMap)) {\n    return;\n  }\n  const uniformMap = {\n    u_modifiedModelViewProjection: function () {\n      const viewMatrix = context.uniformState.view;\n      const projectionMatrix = context.uniformState.projection;\n      Matrix4.clone(viewMatrix, modifiedModelViewScratch);\n      Matrix4.multiplyByPoint(modifiedModelViewScratch, primitive._center, rtcScratch);\n      Matrix4.setTranslation(modifiedModelViewScratch, rtcScratch, modifiedModelViewScratch);\n      Matrix4.multiply(projectionMatrix, modifiedModelViewScratch, modifiedModelViewScratch);\n      return modifiedModelViewScratch;\n    },\n    u_highlightColor: function () {\n      return primitive._highlightColor;\n    }\n  };\n  primitive._uniformMap = primitive._batchTable.getUniformMapCallback()(uniformMap);\n}\nfunction copyIndicesCPU(indices, newIndices, currentOffset, offsets, counts, batchIds, batchIdLookUp) {\n  const sizeInBytes = indices.constructor.BYTES_PER_ELEMENT;\n  const batchedIdsLength = batchIds.length;\n  for (let j = 0; j < batchedIdsLength; ++j) {\n    const batchedId = batchIds[j];\n    const index = batchIdLookUp[batchedId];\n    const offset = offsets[index];\n    const count = counts[index];\n    const subarray = new indices.constructor(indices.buffer, sizeInBytes * offset, count);\n    newIndices.set(subarray, currentOffset);\n    offsets[index] = currentOffset;\n    currentOffset += count;\n  }\n  return currentOffset;\n}\nfunction rebatchCPU(primitive, batchedIndices) {\n  const indices = primitive._indices;\n  const indexOffsets = primitive._indexOffsets;\n  const indexCounts = primitive._indexCounts;\n  const batchIdLookUp = primitive._batchIdLookUp;\n  const newIndices = new indices.constructor(indices.length);\n  let current = batchedIndices.pop();\n  const newBatchedIndices = [current];\n  let currentOffset = copyIndicesCPU(indices, newIndices, 0, indexOffsets, indexCounts, current.batchIds, batchIdLookUp);\n  current.offset = 0;\n  current.count = currentOffset;\n  while (batchedIndices.length > 0) {\n    const next = batchedIndices.pop();\n    if (Color.equals(next.color, current.color)) {\n      currentOffset = copyIndicesCPU(indices, newIndices, currentOffset, indexOffsets, indexCounts, next.batchIds, batchIdLookUp);\n      current.batchIds = current.batchIds.concat(next.batchIds);\n      current.count = currentOffset - current.offset;\n    } else {\n      const offset = currentOffset;\n      currentOffset = copyIndicesCPU(indices, newIndices, currentOffset, indexOffsets, indexCounts, next.batchIds, batchIdLookUp);\n      next.offset = offset;\n      next.count = currentOffset - offset;\n      newBatchedIndices.push(next);\n      current = next;\n    }\n  }\n  primitive._va.indexBuffer.copyFromArrayView(newIndices);\n  primitive._indices = newIndices;\n  primitive._batchedIndices = newBatchedIndices;\n}\nfunction copyIndicesGPU(readBuffer, writeBuffer, currentOffset, offsets, counts, batchIds, batchIdLookUp) {\n  const sizeInBytes = readBuffer.bytesPerIndex;\n  const batchedIdsLength = batchIds.length;\n  for (let j = 0; j < batchedIdsLength; ++j) {\n    const batchedId = batchIds[j];\n    const index = batchIdLookUp[batchedId];\n    const offset = offsets[index];\n    const count = counts[index];\n    writeBuffer.copyFromBuffer(readBuffer, offset * sizeInBytes, currentOffset * sizeInBytes, count * sizeInBytes);\n    offsets[index] = currentOffset;\n    currentOffset += count;\n  }\n  return currentOffset;\n}\nfunction rebatchGPU(primitive, batchedIndices) {\n  const indexOffsets = primitive._indexOffsets;\n  const indexCounts = primitive._indexCounts;\n  const batchIdLookUp = primitive._batchIdLookUp;\n  let current = batchedIndices.pop();\n  const newBatchedIndices = [current];\n  const readBuffer = primitive._va.indexBuffer;\n  const writeBuffer = primitive._vaSwap.indexBuffer;\n  let currentOffset = copyIndicesGPU(readBuffer, writeBuffer, 0, indexOffsets, indexCounts, current.batchIds, batchIdLookUp);\n  current.offset = 0;\n  current.count = currentOffset;\n  while (batchedIndices.length > 0) {\n    const next = batchedIndices.pop();\n    if (Color.equals(next.color, current.color)) {\n      currentOffset = copyIndicesGPU(readBuffer, writeBuffer, currentOffset, indexOffsets, indexCounts, next.batchIds, batchIdLookUp);\n      current.batchIds = current.batchIds.concat(next.batchIds);\n      current.count = currentOffset - current.offset;\n    } else {\n      const offset = currentOffset;\n      currentOffset = copyIndicesGPU(readBuffer, writeBuffer, currentOffset, indexOffsets, indexCounts, next.batchIds, batchIdLookUp);\n      next.offset = offset;\n      next.count = currentOffset - offset;\n      newBatchedIndices.push(next);\n      current = next;\n    }\n  }\n  const temp = primitive._va;\n  primitive._va = primitive._vaSwap;\n  primitive._vaSwap = temp;\n  primitive._batchedIndices = newBatchedIndices;\n}\nfunction compareColors(a, b) {\n  return b.color.toRgba() - a.color.toRgba();\n}\n\n// PERFORMANCE_IDEA: For WebGL 2, we can use copyBufferSubData for buffer-to-buffer copies.\n// PERFORMANCE_IDEA: Not supported, but we could use glMultiDrawElements here.\nfunction rebatchCommands(primitive, context) {\n  if (!primitive._batchDirty) {\n    return false;\n  }\n  const batchedIndices = primitive._batchedIndices;\n  const length = batchedIndices.length;\n  let needToRebatch = false;\n  const colorCounts = {};\n  for (let i = 0; i < length; ++i) {\n    const color = batchedIndices[i].color;\n    const rgba = color.toRgba();\n    if (defined(colorCounts[rgba])) {\n      needToRebatch = true;\n      break;\n    } else {\n      colorCounts[rgba] = true;\n    }\n  }\n  if (!needToRebatch) {\n    primitive._batchDirty = false;\n    return false;\n  }\n  if (needToRebatch && !primitive.forceRebatch && primitive._framesSinceLastRebatch < 120) {\n    ++primitive._framesSinceLastRebatch;\n    return;\n  }\n  batchedIndices.sort(compareColors);\n  if (context.webgl2) {\n    rebatchGPU(primitive, batchedIndices);\n  } else {\n    rebatchCPU(primitive, batchedIndices);\n  }\n  primitive._framesSinceLastRebatch = 0;\n  primitive._batchDirty = false;\n  primitive._pickCommandsDirty = true;\n  primitive._wireframeDirty = true;\n  return true;\n}\nfunction createColorCommands(primitive, context) {\n  const needsRebatch = rebatchCommands(primitive, context);\n  const commands = primitive._commands;\n  const batchedIndices = primitive._batchedIndices;\n  const length = batchedIndices.length;\n  const commandsLength = length * 2;\n  if (defined(commands) && !needsRebatch && commands.length === commandsLength) {\n    return;\n  }\n  commands.length = commandsLength;\n  const vertexArray = primitive._va;\n  const sp = primitive._sp;\n  const modelMatrix = primitive._modelMatrix ?? Matrix4.IDENTITY;\n  const uniformMap = primitive._uniformMap;\n  const bv = primitive._boundingVolume;\n  for (let j = 0; j < length; ++j) {\n    const offset = batchedIndices[j].offset;\n    const count = batchedIndices[j].count;\n    let stencilDepthCommand = commands[j * 2];\n    if (!defined(stencilDepthCommand)) {\n      stencilDepthCommand = commands[j * 2] = new DrawCommand({\n        owner: primitive\n      });\n    }\n    stencilDepthCommand.vertexArray = vertexArray;\n    stencilDepthCommand.modelMatrix = modelMatrix;\n    stencilDepthCommand.offset = offset;\n    stencilDepthCommand.count = count;\n    stencilDepthCommand.renderState = primitive._rsStencilDepthPass;\n    stencilDepthCommand.shaderProgram = sp;\n    stencilDepthCommand.uniformMap = uniformMap;\n    stencilDepthCommand.boundingVolume = bv;\n    stencilDepthCommand.cull = false;\n    stencilDepthCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n    const stencilDepthDerivedCommand = DrawCommand.shallowClone(stencilDepthCommand, stencilDepthCommand.derivedCommands.tileset);\n    stencilDepthDerivedCommand.renderState = primitive._rsStencilDepthPass3DTiles;\n    stencilDepthDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    stencilDepthCommand.derivedCommands.tileset = stencilDepthDerivedCommand;\n    let colorCommand = commands[j * 2 + 1];\n    if (!defined(colorCommand)) {\n      colorCommand = commands[j * 2 + 1] = new DrawCommand({\n        owner: primitive\n      });\n    }\n    colorCommand.vertexArray = vertexArray;\n    colorCommand.modelMatrix = modelMatrix;\n    colorCommand.offset = offset;\n    colorCommand.count = count;\n    colorCommand.renderState = primitive._rsColorPass;\n    colorCommand.shaderProgram = sp;\n    colorCommand.uniformMap = uniformMap;\n    colorCommand.boundingVolume = bv;\n    colorCommand.cull = false;\n    colorCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n    const colorDerivedCommand = DrawCommand.shallowClone(colorCommand, colorCommand.derivedCommands.tileset);\n    colorDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    colorCommand.derivedCommands.tileset = colorDerivedCommand;\n  }\n  primitive._commandsDirty = true;\n}\nfunction createColorCommandsIgnoreShow(primitive, frameState) {\n  if (primitive.classificationType === ClassificationType.TERRAIN || !frameState.invertClassification || defined(primitive._commandsIgnoreShow) && !primitive._commandsDirty) {\n    return;\n  }\n  const commands = primitive._commands;\n  const commandsIgnoreShow = primitive._commandsIgnoreShow;\n  const spStencil = primitive._spStencil;\n  const commandsLength = commands.length;\n  const length = commandsIgnoreShow.length = commandsLength / 2;\n  let commandIndex = 0;\n  for (let j = 0; j < length; ++j) {\n    const commandIgnoreShow = commandsIgnoreShow[j] = DrawCommand.shallowClone(commands[commandIndex], commandsIgnoreShow[j]);\n    commandIgnoreShow.shaderProgram = spStencil;\n    commandIgnoreShow.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW;\n    commandIndex += 2;\n  }\n  primitive._commandsDirty = false;\n}\nfunction createPickCommands(primitive) {\n  if (!primitive._pickCommandsDirty) {\n    return;\n  }\n  const length = primitive._indexOffsets.length;\n  const pickCommands = primitive._pickCommands;\n  pickCommands.length = length * 2;\n  const vertexArray = primitive._va;\n  const spStencil = primitive._spStencil;\n  const spPick = primitive._spPick;\n  const modelMatrix = primitive._modelMatrix ?? Matrix4.IDENTITY;\n  const uniformMap = primitive._uniformMap;\n  for (let j = 0; j < length; ++j) {\n    const offset = primitive._indexOffsets[j];\n    const count = primitive._indexCounts[j];\n    const bv = defined(primitive._boundingVolumes) ? primitive._boundingVolumes[j] : primitive.boundingVolume;\n    let stencilDepthCommand = pickCommands[j * 2];\n    if (!defined(stencilDepthCommand)) {\n      stencilDepthCommand = pickCommands[j * 2] = new DrawCommand({\n        owner: primitive,\n        pickOnly: true\n      });\n    }\n    stencilDepthCommand.vertexArray = vertexArray;\n    stencilDepthCommand.modelMatrix = modelMatrix;\n    stencilDepthCommand.offset = offset;\n    stencilDepthCommand.count = count;\n    stencilDepthCommand.renderState = primitive._rsStencilDepthPass;\n    stencilDepthCommand.shaderProgram = spStencil;\n    stencilDepthCommand.uniformMap = uniformMap;\n    stencilDepthCommand.boundingVolume = bv;\n    stencilDepthCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n    const stencilDepthDerivedCommand = DrawCommand.shallowClone(stencilDepthCommand, stencilDepthCommand.derivedCommands.tileset);\n    stencilDepthDerivedCommand.renderState = primitive._rsStencilDepthPass3DTiles;\n    stencilDepthDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    stencilDepthCommand.derivedCommands.tileset = stencilDepthDerivedCommand;\n    let colorCommand = pickCommands[j * 2 + 1];\n    if (!defined(colorCommand)) {\n      colorCommand = pickCommands[j * 2 + 1] = new DrawCommand({\n        owner: primitive,\n        pickOnly: true\n      });\n    }\n    colorCommand.vertexArray = vertexArray;\n    colorCommand.modelMatrix = modelMatrix;\n    colorCommand.offset = offset;\n    colorCommand.count = count;\n    colorCommand.renderState = primitive._rsPickPass;\n    colorCommand.shaderProgram = spPick;\n    colorCommand.uniformMap = uniformMap;\n    colorCommand.boundingVolume = bv;\n    colorCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n    const colorDerivedCommand = DrawCommand.shallowClone(colorCommand, colorCommand.derivedCommands.tileset);\n    colorDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    colorCommand.derivedCommands.tileset = colorDerivedCommand;\n  }\n  primitive._pickCommandsDirty = false;\n}\n\n/**\n * Creates features for each mesh and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\nVector3DTilePrimitive.prototype.createFeatures = function (content, features) {\n  const batchIds = this._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    features[batchId] = new Cesium3DTileFeature(content, batchId);\n  }\n};\n\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (mesh batch table color * color).\n *\n * @param {boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\nVector3DTilePrimitive.prototype.applyDebugSettings = function (enabled, color) {\n  this._highlightColor = enabled ? color : this._constantColor;\n};\nfunction clearStyle(polygons, features) {\n  polygons._updatingAllCommands = true;\n  const batchIds = polygons._batchIds;\n  let length = batchIds.length;\n  let i;\n  for (i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    const feature = features[batchId];\n    feature.show = true;\n    feature.color = Color.WHITE;\n  }\n  const batchedIndices = polygons._batchedIndices;\n  length = batchedIndices.length;\n  for (i = 0; i < length; ++i) {\n    batchedIndices[i].color = Color.clone(Color.WHITE);\n  }\n  polygons._updatingAllCommands = false;\n  polygons._batchDirty = true;\n}\nconst scratchColor = new Color();\nconst DEFAULT_COLOR_VALUE = Color.WHITE;\nconst DEFAULT_SHOW_VALUE = true;\nconst complexExpressionReg = /\\$/;\n\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The array of features.\n */\nVector3DTilePrimitive.prototype.applyStyle = function (style, features) {\n  if (!defined(style)) {\n    clearStyle(this, features);\n    return;\n  }\n  const colorExpression = style.color;\n  const isSimpleStyle = colorExpression instanceof Expression && !complexExpressionReg.test(colorExpression.expression);\n  this._updatingAllCommands = isSimpleStyle;\n  const batchIds = this._batchIds;\n  let length = batchIds.length;\n  let i;\n  for (i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    const feature = features[batchId];\n    feature.color = defined(style.color) ? style.color.evaluateColor(feature, scratchColor) : DEFAULT_COLOR_VALUE;\n    feature.show = defined(style.show) ? style.show.evaluate(feature) : DEFAULT_SHOW_VALUE;\n  }\n  if (isSimpleStyle) {\n    const batchedIndices = this._batchedIndices;\n    length = batchedIndices.length;\n    for (i = 0; i < length; ++i) {\n      batchedIndices[i].color = Color.clone(Color.WHITE);\n    }\n    this._updatingAllCommands = false;\n    this._batchDirty = true;\n  }\n};\n\n/**\n * Call when updating the color of a mesh with batchId changes color. The meshes will need to be re-batched\n * on the next update.\n *\n * @param {number} batchId The batch id of the meshes whose color has changed.\n * @param {Color} color The new polygon color.\n */\nVector3DTilePrimitive.prototype.updateCommands = function (batchId, color) {\n  if (this._updatingAllCommands) {\n    return;\n  }\n  const batchIdLookUp = this._batchIdLookUp;\n  const index = batchIdLookUp[batchId];\n  if (!defined(index)) {\n    return;\n  }\n  const indexOffsets = this._indexOffsets;\n  const indexCounts = this._indexCounts;\n  const offset = indexOffsets[index];\n  const count = indexCounts[index];\n  const batchedIndices = this._batchedIndices;\n  const length = batchedIndices.length;\n  let i;\n  for (i = 0; i < length; ++i) {\n    const batchedOffset = batchedIndices[i].offset;\n    const batchedCount = batchedIndices[i].count;\n    if (offset >= batchedOffset && offset < batchedOffset + batchedCount) {\n      break;\n    }\n  }\n  batchedIndices.push(new Vector3DTileBatch({\n    color: Color.clone(color),\n    offset: offset,\n    count: count,\n    batchIds: [batchId]\n  }));\n  const startIds = [];\n  const endIds = [];\n  const batchIds = batchedIndices[i].batchIds;\n  const batchIdsLength = batchIds.length;\n  for (let j = 0; j < batchIdsLength; ++j) {\n    const id = batchIds[j];\n    if (id === batchId) {\n      continue;\n    }\n    const offsetIndex = batchIdLookUp[id];\n    if (indexOffsets[offsetIndex] < offset) {\n      startIds.push(id);\n    } else {\n      endIds.push(id);\n    }\n  }\n  if (endIds.length !== 0) {\n    batchedIndices.push(new Vector3DTileBatch({\n      color: Color.clone(batchedIndices[i].color),\n      offset: offset + count,\n      count: batchedIndices[i].offset + batchedIndices[i].count - (offset + count),\n      batchIds: endIds\n    }));\n  }\n  if (startIds.length !== 0) {\n    batchedIndices[i].count = offset - batchedIndices[i].offset;\n    batchedIndices[i].batchIds = startIds;\n  } else {\n    batchedIndices.splice(i, 1);\n  }\n  this._batchDirty = true;\n};\nfunction queueCommands(primitive, frameState, commands, commandsIgnoreShow) {\n  const classificationType = primitive.classificationType;\n  const queueTerrainCommands = classificationType !== ClassificationType.CESIUM_3D_TILE;\n  const queue3DTilesCommands = classificationType !== ClassificationType.TERRAIN;\n  const commandList = frameState.commandList;\n  let commandLength = commands.length;\n  let command;\n  let i;\n  for (i = 0; i < commandLength; ++i) {\n    if (queueTerrainCommands) {\n      command = commands[i];\n      command.pass = Pass.TERRAIN_CLASSIFICATION;\n      commandList.push(command);\n    }\n    if (queue3DTilesCommands) {\n      command = commands[i].derivedCommands.tileset;\n      command.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n      commandList.push(command);\n    }\n  }\n  if (!frameState.invertClassification || !defined(commandsIgnoreShow)) {\n    return;\n  }\n  commandLength = commandsIgnoreShow.length;\n  for (i = 0; i < commandLength; ++i) {\n    commandList.push(commandsIgnoreShow[i]);\n  }\n}\nfunction queueWireframeCommands(frameState, commands) {\n  const commandList = frameState.commandList;\n  const commandLength = commands.length;\n  for (let i = 0; i < commandLength; i += 2) {\n    const command = commands[i + 1];\n    command.pass = Pass.OPAQUE;\n    commandList.push(command);\n  }\n}\nfunction updateWireframe(primitive) {\n  let earlyExit = primitive.debugWireframe === primitive._debugWireframe;\n  earlyExit = earlyExit && !(primitive.debugWireframe && primitive._wireframeDirty);\n  if (earlyExit) {\n    return;\n  }\n  if (!defined(primitive._rsWireframe)) {\n    primitive._rsWireframe = RenderState.fromCache({});\n  }\n  let rs;\n  let type;\n  if (primitive.debugWireframe) {\n    rs = primitive._rsWireframe;\n    type = PrimitiveType.LINES;\n  } else {\n    rs = primitive._rsColorPass;\n    type = PrimitiveType.TRIANGLES;\n  }\n  const commands = primitive._commands;\n  const commandLength = commands.length;\n  for (let i = 0; i < commandLength; i += 2) {\n    const command = commands[i + 1];\n    command.renderState = rs;\n    command.primitiveType = type;\n  }\n  primitive._debugWireframe = primitive.debugWireframe;\n  primitive._wireframeDirty = false;\n}\n\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\nVector3DTilePrimitive.prototype.update = function (frameState) {\n  const context = frameState.context;\n  createVertexArray(this, context);\n  createShaders(this, context);\n  createRenderStates(this);\n  createUniformMap(this, context);\n  const passes = frameState.passes;\n  if (passes.render) {\n    createColorCommands(this, context);\n    createColorCommandsIgnoreShow(this, frameState);\n    updateWireframe(this);\n    if (this._debugWireframe) {\n      queueWireframeCommands(frameState, this._commands);\n    } else {\n      queueCommands(this, frameState, this._commands, this._commandsIgnoreShow);\n    }\n  }\n  if (passes.pick) {\n    createPickCommands(this);\n    queueCommands(this, frameState, this._pickCommands);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nVector3DTilePrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVector3DTilePrimitive.prototype.destroy = function () {\n  this._va = this._va && this._va.destroy();\n  this._sp = this._sp && this._sp.destroy();\n  this._spPick = this._spPick && this._spPick.destroy();\n  this._vaSwap = this._vaSwap && this._vaSwap.destroy();\n  return destroyObject(this);\n};\nexport default Vector3DTilePrimitive;","map":{"version":3,"names":["Cartesian3","Color","ComponentDatatype","Frozen","defined","destroyObject","IndexDatatype","Matrix4","PrimitiveType","Buffer","BufferUsage","DrawCommand","Pass","RenderState","ShaderProgram","ShaderSource","VertexArray","ShadowVolumeFS","VectorTileVS","BlendingState","Cesium3DTileFeature","ClassificationType","DepthFunction","Expression","StencilConstants","StencilFunction","StencilOperation","Vector3DTileBatch","Vector3DTilePrimitive","options","EMPTY_OBJECT","_batchTable","batchTable","_batchIds","batchIds","_positions","positions","_vertexBatchIds","vertexBatchIds","_indices","indices","_indexCounts","indexCounts","_indexOffsets","indexOffsets","_batchedIndices","batchedIndices","_boundingVolume","boundingVolume","_boundingVolumes","boundingVolumes","_center","center","ZERO","_va","undefined","_sp","_spStencil","_spPick","_uniformMap","_vaSwap","_rsStencilDepthPass","_rsStencilDepthPass3DTiles","_rsColorPass","_rsPickPass","_rsWireframe","_commands","_commandsIgnoreShow","_pickCommands","_constantColor","clone","WHITE","_highlightColor","_batchDirty","_pickCommandsDirty","_framesSinceLastRebatch","_updatingAllCommands","_trianglesLength","length","_geometryByteLength","byteLength","debugWireframe","_debugWireframe","_wireframeDirty","forceRebatch","classificationType","BOTH","_vertexShaderSource","_fragmentShaderSource","_attributeLocations","_pickId","_modelMatrix","_boundingSphere","_batchIdLookUp","i","batchId","Object","defineProperties","prototype","trianglesLength","get","geometryByteLength","defaultAttributeLocations","position","a_batchId","createVertexArray","primitive","context","positionBuffer","createVertexBuffer","typedArray","usage","STATIC_DRAW","idBuffer","indexBuffer","createIndexBuffer","DYNAMIC_DRAW","indexDatatype","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT","vertexAttributes","index","vertexBuffer","componentDatatype","fromTypedArray","componentsPerAttribute","attributes","webgl2","sizeInBytes","_batchedPositions","_transferrableBatchIds","createShaders","attributeLocations","pickId","vertexShaderSource","fragmentShaderSource","fromCache","replaceMain","vsSource","getVertexShaderCallback","fsSource","getFragmentShaderCallback","getPickId","vs","sources","fs","defines","pickVS","pickFS","getStencilDepthRenderState","mask3DTiles","stencilFunction","EQUAL","ALWAYS","colorMask","red","green","blue","alpha","stencilTest","enabled","frontFunction","frontOperation","fail","KEEP","zFail","DECREMENT_WRAP","zPass","backFunction","backOperation","INCREMENT_WRAP","reference","CESIUM_3D_TILE_MASK","mask","stencilMask","CLASSIFICATION_MASK","depthTest","func","LESS_OR_EQUAL","depthMask","colorRenderState","NOT_EQUAL","blending","PRE_MULTIPLIED_ALPHA_BLEND","pickRenderState","createRenderStates","modifiedModelViewScratch","rtcScratch","createUniformMap","uniformMap","u_modifiedModelViewProjection","viewMatrix","uniformState","view","projectionMatrix","projection","multiplyByPoint","setTranslation","multiply","u_highlightColor","getUniformMapCallback","copyIndicesCPU","newIndices","currentOffset","offsets","counts","batchIdLookUp","constructor","batchedIdsLength","j","batchedId","offset","count","subarray","buffer","set","rebatchCPU","current","pop","newBatchedIndices","next","equals","color","concat","push","copyFromArrayView","copyIndicesGPU","readBuffer","writeBuffer","bytesPerIndex","copyFromBuffer","rebatchGPU","temp","compareColors","a","b","toRgba","rebatchCommands","needToRebatch","colorCounts","rgba","sort","createColorCommands","needsRebatch","commands","commandsLength","vertexArray","sp","modelMatrix","IDENTITY","bv","stencilDepthCommand","owner","renderState","shaderProgram","cull","pass","TERRAIN_CLASSIFICATION","stencilDepthDerivedCommand","shallowClone","derivedCommands","tileset","CESIUM_3D_TILE_CLASSIFICATION","colorCommand","colorDerivedCommand","_commandsDirty","createColorCommandsIgnoreShow","frameState","TERRAIN","invertClassification","commandsIgnoreShow","spStencil","commandIndex","commandIgnoreShow","CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW","createPickCommands","pickCommands","spPick","pickOnly","createFeatures","content","features","applyDebugSettings","clearStyle","polygons","feature","show","scratchColor","DEFAULT_COLOR_VALUE","DEFAULT_SHOW_VALUE","complexExpressionReg","applyStyle","style","colorExpression","isSimpleStyle","test","expression","evaluateColor","evaluate","updateCommands","batchedOffset","batchedCount","startIds","endIds","batchIdsLength","id","offsetIndex","splice","queueCommands","queueTerrainCommands","CESIUM_3D_TILE","queue3DTilesCommands","commandList","commandLength","command","queueWireframeCommands","OPAQUE","updateWireframe","earlyExit","rs","type","LINES","TRIANGLES","primitiveType","update","passes","render","pick","isDestroyed","destroy"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Vector3DTilePrimitive.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport ShadowVolumeFS from \"../Shaders/ShadowVolumeFS.js\";\nimport VectorTileVS from \"../Shaders/VectorTileVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileFeature from \"./Cesium3DTileFeature.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport Expression from \"./Expression.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\nimport Vector3DTileBatch from \"./Vector3DTileBatch.js\";\n\n/**\n * Creates a batch of classification meshes.\n *\n * @alias Vector3DTilePrimitive\n * @constructor\n *\n * @param {object} options An object with following properties:\n * @param {Float32Array} options.positions The positions of the meshes.\n * @param {Uint16Array|Uint32Array} options.indices The indices of the triangulated meshes. The indices must be contiguous so that\n * the indices for mesh n are in [i, i + indexCounts[n]] where i = sum{indexCounts[0], indexCounts[n - 1]}.\n * @param {Uint32Array} options.indexCounts The number of indices for each mesh.\n * @param {Uint32Array} options.indexOffsets The offset into the index buffer for each mesh.\n * @param {Vector3DTileBatch[]} options.batchedIndices The index offset and count for each batch with the same color.\n * @param {Cartesian3} [options.center=Cartesian3.ZERO] The RTC center.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table for the tile containing the batched meshes.\n * @param {Uint16Array} options.batchIds The batch ids for each mesh.\n * @param {Uint16Array} options.vertexBatchIds The batch id for each vertex.\n * @param {BoundingSphere} options.boundingVolume The bounding volume for the entire batch of meshes.\n * @param {BoundingSphere[]} options.boundingVolumes The bounding volume for each mesh.\n * @param {ClassificationType} [options.classificationType] What this tile will classify.\n *\n * @private\n */\nfunction Vector3DTilePrimitive(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  this._batchTable = options.batchTable;\n  this._batchIds = options.batchIds;\n\n  // These arrays are released after VAO creation.\n  this._positions = options.positions;\n  this._vertexBatchIds = options.vertexBatchIds;\n\n  // These arrays are kept for re-batching indices based on colors.\n  // If WebGL 2 is supported, indices will be released and re-batching uses buffer-to-buffer copies.\n  this._indices = options.indices;\n  this._indexCounts = options.indexCounts;\n  this._indexOffsets = options.indexOffsets;\n  this._batchedIndices = options.batchedIndices;\n\n  this._boundingVolume = options.boundingVolume;\n  this._boundingVolumes = options.boundingVolumes;\n\n  this._center = options.center ?? Cartesian3.ZERO;\n\n  this._va = undefined;\n  this._sp = undefined;\n  this._spStencil = undefined;\n  this._spPick = undefined;\n  this._uniformMap = undefined;\n\n  // Only used with WebGL 2 to ping-pong ibos after copy.\n  this._vaSwap = undefined;\n\n  this._rsStencilDepthPass = undefined;\n  this._rsStencilDepthPass3DTiles = undefined;\n  this._rsColorPass = undefined;\n  this._rsPickPass = undefined;\n  this._rsWireframe = undefined;\n\n  this._commands = [];\n  this._commandsIgnoreShow = [];\n  this._pickCommands = [];\n\n  this._constantColor = Color.clone(Color.WHITE);\n  this._highlightColor = this._constantColor;\n\n  this._batchDirty = true;\n  this._pickCommandsDirty = true;\n  this._framesSinceLastRebatch = 0;\n\n  this._updatingAllCommands = false;\n\n  this._trianglesLength = this._indices.length / 3;\n  this._geometryByteLength =\n    this._indices.byteLength +\n    this._positions.byteLength +\n    this._vertexBatchIds.byteLength;\n\n  /**\n   * Draw the wireframe of the classification meshes.\n   * @type {boolean}\n   * @default false\n   */\n  this.debugWireframe = false;\n  this._debugWireframe = this.debugWireframe;\n  this._wireframeDirty = false;\n\n  /**\n   * Forces a re-batch instead of waiting after a number of frames have been rendered. For testing only.\n   * @type {boolean}\n   * @default false\n   */\n  this.forceRebatch = false;\n\n  /**\n   * What this tile will classify.\n   * @type {ClassificationType}\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType =\n    options.classificationType ?? ClassificationType.BOTH;\n\n  // Hidden options\n  this._vertexShaderSource = options._vertexShaderSource;\n  this._fragmentShaderSource = options._fragmentShaderSource;\n  this._attributeLocations = options._attributeLocations;\n  this._uniformMap = options._uniformMap;\n  this._pickId = options._pickId;\n  this._modelMatrix = options._modelMatrix;\n  this._boundingSphere = options._boundingSphere;\n\n  this._batchIdLookUp = {};\n\n  const length = this._batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = this._batchIds[i];\n    this._batchIdLookUp[batchId] = i;\n  }\n}\n\nObject.defineProperties(Vector3DTilePrimitive.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTilePrimitive.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  trianglesLength: {\n    get: function () {\n      return this._trianglesLength;\n    },\n  },\n\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTilePrimitive.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    },\n  },\n});\n\nconst defaultAttributeLocations = {\n  position: 0,\n  a_batchId: 1,\n};\n\nfunction createVertexArray(primitive, context) {\n  if (defined(primitive._va)) {\n    return;\n  }\n\n  const positionBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: primitive._positions,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  const idBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: primitive._vertexBatchIds,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  const indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: primitive._indices,\n    usage: BufferUsage.DYNAMIC_DRAW,\n    indexDatatype:\n      primitive._indices.BYTES_PER_ELEMENT === 2\n        ? IndexDatatype.UNSIGNED_SHORT\n        : IndexDatatype.UNSIGNED_INT,\n  });\n\n  const vertexAttributes = [\n    {\n      index: 0,\n      vertexBuffer: positionBuffer,\n      componentDatatype: ComponentDatatype.fromTypedArray(primitive._positions),\n      componentsPerAttribute: 3,\n    },\n    {\n      index: 1,\n      vertexBuffer: idBuffer,\n      componentDatatype: ComponentDatatype.fromTypedArray(\n        primitive._vertexBatchIds,\n      ),\n      componentsPerAttribute: 1,\n    },\n  ];\n\n  primitive._va = new VertexArray({\n    context: context,\n    attributes: vertexAttributes,\n    indexBuffer: indexBuffer,\n  });\n\n  if (context.webgl2) {\n    primitive._vaSwap = new VertexArray({\n      context: context,\n      attributes: vertexAttributes,\n      indexBuffer: Buffer.createIndexBuffer({\n        context: context,\n        sizeInBytes: indexBuffer.sizeInBytes,\n        usage: BufferUsage.DYNAMIC_DRAW,\n        indexDatatype: indexBuffer.indexDatatype,\n      }),\n    });\n  }\n\n  primitive._batchedPositions = undefined;\n  primitive._transferrableBatchIds = undefined;\n  primitive._vertexBatchIds = undefined;\n}\n\nfunction createShaders(primitive, context) {\n  if (defined(primitive._sp)) {\n    return;\n  }\n\n  const batchTable = primitive._batchTable;\n  const attributeLocations =\n    primitive._attributeLocations ?? defaultAttributeLocations;\n\n  let pickId = primitive._pickId;\n  const vertexShaderSource = primitive._vertexShaderSource;\n  let fragmentShaderSource = primitive._fragmentShaderSource;\n  if (defined(vertexShaderSource)) {\n    primitive._sp = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vertexShaderSource,\n      fragmentShaderSource: fragmentShaderSource,\n      attributeLocations: attributeLocations,\n    });\n    primitive._spStencil = primitive._sp;\n\n    fragmentShaderSource = ShaderSource.replaceMain(\n      fragmentShaderSource,\n      \"czm_non_pick_main\",\n    );\n    fragmentShaderSource =\n      `${fragmentShaderSource}void main() \\n` +\n      `{ \\n` +\n      `    czm_non_pick_main(); \\n` +\n      `    out_FragColor = ${pickId}; \\n` +\n      `} \\n`;\n    primitive._spPick = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vertexShaderSource,\n      fragmentShaderSource: fragmentShaderSource,\n      attributeLocations: attributeLocations,\n    });\n    return;\n  }\n\n  const vsSource = batchTable.getVertexShaderCallback(\n    false,\n    \"a_batchId\",\n    undefined,\n  )(VectorTileVS);\n  let fsSource = batchTable.getFragmentShaderCallback(\n    false,\n    undefined,\n    true,\n  )(ShadowVolumeFS);\n\n  pickId = batchTable.getPickId();\n\n  let vs = new ShaderSource({\n    sources: [vsSource],\n  });\n  let fs = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [fsSource],\n  });\n\n  primitive._sp = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n\n  vs = new ShaderSource({\n    sources: [VectorTileVS],\n  });\n  fs = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [ShadowVolumeFS],\n  });\n\n  primitive._spStencil = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n\n  fsSource = ShaderSource.replaceMain(fsSource, \"czm_non_pick_main\");\n  fsSource =\n    `${fsSource}\\n` +\n    `void main() \\n` +\n    `{ \\n` +\n    `    czm_non_pick_main(); \\n` +\n    `    out_FragColor = ${pickId}; \\n` +\n    `} \\n`;\n\n  const pickVS = new ShaderSource({\n    sources: [vsSource],\n  });\n  const pickFS = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [fsSource],\n  });\n  primitive._spPick = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: pickVS,\n    fragmentShaderSource: pickFS,\n    attributeLocations: attributeLocations,\n  });\n}\n\nfunction getStencilDepthRenderState(mask3DTiles) {\n  const stencilFunction = mask3DTiles\n    ? StencilFunction.EQUAL\n    : StencilFunction.ALWAYS;\n  return {\n    colorMask: {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false,\n    },\n    stencilTest: {\n      enabled: true,\n      frontFunction: stencilFunction,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.DECREMENT_WRAP,\n        zPass: StencilOperation.KEEP,\n      },\n      backFunction: stencilFunction,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.INCREMENT_WRAP,\n        zPass: StencilOperation.KEEP,\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK,\n    },\n    stencilMask: StencilConstants.CLASSIFICATION_MASK,\n    depthTest: {\n      enabled: true,\n      func: DepthFunction.LESS_OR_EQUAL,\n    },\n    depthMask: false,\n  };\n}\n\nconst colorRenderState = {\n  stencilTest: {\n    enabled: true,\n    frontFunction: StencilFunction.NOT_EQUAL,\n    frontOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO,\n    },\n    backFunction: StencilFunction.NOT_EQUAL,\n    backOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO,\n    },\n    reference: 0,\n    mask: StencilConstants.CLASSIFICATION_MASK,\n  },\n  stencilMask: StencilConstants.CLASSIFICATION_MASK,\n  depthTest: {\n    enabled: false,\n  },\n  depthMask: false,\n  blending: BlendingState.PRE_MULTIPLIED_ALPHA_BLEND,\n};\n\nconst pickRenderState = {\n  stencilTest: {\n    enabled: true,\n    frontFunction: StencilFunction.NOT_EQUAL,\n    frontOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO,\n    },\n    backFunction: StencilFunction.NOT_EQUAL,\n    backOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO,\n    },\n    reference: 0,\n    mask: StencilConstants.CLASSIFICATION_MASK,\n  },\n  stencilMask: StencilConstants.CLASSIFICATION_MASK,\n  depthTest: {\n    enabled: false,\n  },\n  depthMask: false,\n};\n\nfunction createRenderStates(primitive) {\n  if (defined(primitive._rsStencilDepthPass)) {\n    return;\n  }\n\n  primitive._rsStencilDepthPass = RenderState.fromCache(\n    getStencilDepthRenderState(false),\n  );\n  primitive._rsStencilDepthPass3DTiles = RenderState.fromCache(\n    getStencilDepthRenderState(true),\n  );\n  primitive._rsColorPass = RenderState.fromCache(colorRenderState);\n  primitive._rsPickPass = RenderState.fromCache(pickRenderState);\n}\n\nconst modifiedModelViewScratch = new Matrix4();\nconst rtcScratch = new Cartesian3();\n\nfunction createUniformMap(primitive, context) {\n  if (defined(primitive._uniformMap)) {\n    return;\n  }\n\n  const uniformMap = {\n    u_modifiedModelViewProjection: function () {\n      const viewMatrix = context.uniformState.view;\n      const projectionMatrix = context.uniformState.projection;\n      Matrix4.clone(viewMatrix, modifiedModelViewScratch);\n      Matrix4.multiplyByPoint(\n        modifiedModelViewScratch,\n        primitive._center,\n        rtcScratch,\n      );\n      Matrix4.setTranslation(\n        modifiedModelViewScratch,\n        rtcScratch,\n        modifiedModelViewScratch,\n      );\n      Matrix4.multiply(\n        projectionMatrix,\n        modifiedModelViewScratch,\n        modifiedModelViewScratch,\n      );\n      return modifiedModelViewScratch;\n    },\n    u_highlightColor: function () {\n      return primitive._highlightColor;\n    },\n  };\n\n  primitive._uniformMap =\n    primitive._batchTable.getUniformMapCallback()(uniformMap);\n}\n\nfunction copyIndicesCPU(\n  indices,\n  newIndices,\n  currentOffset,\n  offsets,\n  counts,\n  batchIds,\n  batchIdLookUp,\n) {\n  const sizeInBytes = indices.constructor.BYTES_PER_ELEMENT;\n\n  const batchedIdsLength = batchIds.length;\n  for (let j = 0; j < batchedIdsLength; ++j) {\n    const batchedId = batchIds[j];\n    const index = batchIdLookUp[batchedId];\n    const offset = offsets[index];\n    const count = counts[index];\n\n    const subarray = new indices.constructor(\n      indices.buffer,\n      sizeInBytes * offset,\n      count,\n    );\n    newIndices.set(subarray, currentOffset);\n\n    offsets[index] = currentOffset;\n    currentOffset += count;\n  }\n\n  return currentOffset;\n}\n\nfunction rebatchCPU(primitive, batchedIndices) {\n  const indices = primitive._indices;\n  const indexOffsets = primitive._indexOffsets;\n  const indexCounts = primitive._indexCounts;\n  const batchIdLookUp = primitive._batchIdLookUp;\n\n  const newIndices = new indices.constructor(indices.length);\n\n  let current = batchedIndices.pop();\n  const newBatchedIndices = [current];\n\n  let currentOffset = copyIndicesCPU(\n    indices,\n    newIndices,\n    0,\n    indexOffsets,\n    indexCounts,\n    current.batchIds,\n    batchIdLookUp,\n  );\n\n  current.offset = 0;\n  current.count = currentOffset;\n\n  while (batchedIndices.length > 0) {\n    const next = batchedIndices.pop();\n    if (Color.equals(next.color, current.color)) {\n      currentOffset = copyIndicesCPU(\n        indices,\n        newIndices,\n        currentOffset,\n        indexOffsets,\n        indexCounts,\n        next.batchIds,\n        batchIdLookUp,\n      );\n      current.batchIds = current.batchIds.concat(next.batchIds);\n      current.count = currentOffset - current.offset;\n    } else {\n      const offset = currentOffset;\n      currentOffset = copyIndicesCPU(\n        indices,\n        newIndices,\n        currentOffset,\n        indexOffsets,\n        indexCounts,\n        next.batchIds,\n        batchIdLookUp,\n      );\n\n      next.offset = offset;\n      next.count = currentOffset - offset;\n      newBatchedIndices.push(next);\n      current = next;\n    }\n  }\n\n  primitive._va.indexBuffer.copyFromArrayView(newIndices);\n\n  primitive._indices = newIndices;\n  primitive._batchedIndices = newBatchedIndices;\n}\n\nfunction copyIndicesGPU(\n  readBuffer,\n  writeBuffer,\n  currentOffset,\n  offsets,\n  counts,\n  batchIds,\n  batchIdLookUp,\n) {\n  const sizeInBytes = readBuffer.bytesPerIndex;\n\n  const batchedIdsLength = batchIds.length;\n  for (let j = 0; j < batchedIdsLength; ++j) {\n    const batchedId = batchIds[j];\n    const index = batchIdLookUp[batchedId];\n    const offset = offsets[index];\n    const count = counts[index];\n\n    writeBuffer.copyFromBuffer(\n      readBuffer,\n      offset * sizeInBytes,\n      currentOffset * sizeInBytes,\n      count * sizeInBytes,\n    );\n\n    offsets[index] = currentOffset;\n    currentOffset += count;\n  }\n\n  return currentOffset;\n}\n\nfunction rebatchGPU(primitive, batchedIndices) {\n  const indexOffsets = primitive._indexOffsets;\n  const indexCounts = primitive._indexCounts;\n  const batchIdLookUp = primitive._batchIdLookUp;\n\n  let current = batchedIndices.pop();\n  const newBatchedIndices = [current];\n\n  const readBuffer = primitive._va.indexBuffer;\n  const writeBuffer = primitive._vaSwap.indexBuffer;\n\n  let currentOffset = copyIndicesGPU(\n    readBuffer,\n    writeBuffer,\n    0,\n    indexOffsets,\n    indexCounts,\n    current.batchIds,\n    batchIdLookUp,\n  );\n\n  current.offset = 0;\n  current.count = currentOffset;\n\n  while (batchedIndices.length > 0) {\n    const next = batchedIndices.pop();\n    if (Color.equals(next.color, current.color)) {\n      currentOffset = copyIndicesGPU(\n        readBuffer,\n        writeBuffer,\n        currentOffset,\n        indexOffsets,\n        indexCounts,\n        next.batchIds,\n        batchIdLookUp,\n      );\n      current.batchIds = current.batchIds.concat(next.batchIds);\n      current.count = currentOffset - current.offset;\n    } else {\n      const offset = currentOffset;\n      currentOffset = copyIndicesGPU(\n        readBuffer,\n        writeBuffer,\n        currentOffset,\n        indexOffsets,\n        indexCounts,\n        next.batchIds,\n        batchIdLookUp,\n      );\n      next.offset = offset;\n      next.count = currentOffset - offset;\n      newBatchedIndices.push(next);\n      current = next;\n    }\n  }\n\n  const temp = primitive._va;\n  primitive._va = primitive._vaSwap;\n  primitive._vaSwap = temp;\n\n  primitive._batchedIndices = newBatchedIndices;\n}\n\nfunction compareColors(a, b) {\n  return b.color.toRgba() - a.color.toRgba();\n}\n\n// PERFORMANCE_IDEA: For WebGL 2, we can use copyBufferSubData for buffer-to-buffer copies.\n// PERFORMANCE_IDEA: Not supported, but we could use glMultiDrawElements here.\nfunction rebatchCommands(primitive, context) {\n  if (!primitive._batchDirty) {\n    return false;\n  }\n\n  const batchedIndices = primitive._batchedIndices;\n  const length = batchedIndices.length;\n\n  let needToRebatch = false;\n  const colorCounts = {};\n\n  for (let i = 0; i < length; ++i) {\n    const color = batchedIndices[i].color;\n    const rgba = color.toRgba();\n    if (defined(colorCounts[rgba])) {\n      needToRebatch = true;\n      break;\n    } else {\n      colorCounts[rgba] = true;\n    }\n  }\n\n  if (!needToRebatch) {\n    primitive._batchDirty = false;\n    return false;\n  }\n\n  if (\n    needToRebatch &&\n    !primitive.forceRebatch &&\n    primitive._framesSinceLastRebatch < 120\n  ) {\n    ++primitive._framesSinceLastRebatch;\n    return;\n  }\n\n  batchedIndices.sort(compareColors);\n\n  if (context.webgl2) {\n    rebatchGPU(primitive, batchedIndices);\n  } else {\n    rebatchCPU(primitive, batchedIndices);\n  }\n\n  primitive._framesSinceLastRebatch = 0;\n  primitive._batchDirty = false;\n  primitive._pickCommandsDirty = true;\n  primitive._wireframeDirty = true;\n  return true;\n}\n\nfunction createColorCommands(primitive, context) {\n  const needsRebatch = rebatchCommands(primitive, context);\n\n  const commands = primitive._commands;\n  const batchedIndices = primitive._batchedIndices;\n  const length = batchedIndices.length;\n  const commandsLength = length * 2;\n\n  if (\n    defined(commands) &&\n    !needsRebatch &&\n    commands.length === commandsLength\n  ) {\n    return;\n  }\n\n  commands.length = commandsLength;\n\n  const vertexArray = primitive._va;\n  const sp = primitive._sp;\n  const modelMatrix = primitive._modelMatrix ?? Matrix4.IDENTITY;\n  const uniformMap = primitive._uniformMap;\n  const bv = primitive._boundingVolume;\n\n  for (let j = 0; j < length; ++j) {\n    const offset = batchedIndices[j].offset;\n    const count = batchedIndices[j].count;\n\n    let stencilDepthCommand = commands[j * 2];\n    if (!defined(stencilDepthCommand)) {\n      stencilDepthCommand = commands[j * 2] = new DrawCommand({\n        owner: primitive,\n      });\n    }\n\n    stencilDepthCommand.vertexArray = vertexArray;\n    stencilDepthCommand.modelMatrix = modelMatrix;\n    stencilDepthCommand.offset = offset;\n    stencilDepthCommand.count = count;\n    stencilDepthCommand.renderState = primitive._rsStencilDepthPass;\n    stencilDepthCommand.shaderProgram = sp;\n    stencilDepthCommand.uniformMap = uniformMap;\n    stencilDepthCommand.boundingVolume = bv;\n    stencilDepthCommand.cull = false;\n    stencilDepthCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    const stencilDepthDerivedCommand = DrawCommand.shallowClone(\n      stencilDepthCommand,\n      stencilDepthCommand.derivedCommands.tileset,\n    );\n    stencilDepthDerivedCommand.renderState =\n      primitive._rsStencilDepthPass3DTiles;\n    stencilDepthDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    stencilDepthCommand.derivedCommands.tileset = stencilDepthDerivedCommand;\n\n    let colorCommand = commands[j * 2 + 1];\n    if (!defined(colorCommand)) {\n      colorCommand = commands[j * 2 + 1] = new DrawCommand({\n        owner: primitive,\n      });\n    }\n\n    colorCommand.vertexArray = vertexArray;\n    colorCommand.modelMatrix = modelMatrix;\n    colorCommand.offset = offset;\n    colorCommand.count = count;\n    colorCommand.renderState = primitive._rsColorPass;\n    colorCommand.shaderProgram = sp;\n    colorCommand.uniformMap = uniformMap;\n    colorCommand.boundingVolume = bv;\n    colorCommand.cull = false;\n    colorCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    const colorDerivedCommand = DrawCommand.shallowClone(\n      colorCommand,\n      colorCommand.derivedCommands.tileset,\n    );\n    colorDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    colorCommand.derivedCommands.tileset = colorDerivedCommand;\n  }\n\n  primitive._commandsDirty = true;\n}\n\nfunction createColorCommandsIgnoreShow(primitive, frameState) {\n  if (\n    primitive.classificationType === ClassificationType.TERRAIN ||\n    !frameState.invertClassification ||\n    (defined(primitive._commandsIgnoreShow) && !primitive._commandsDirty)\n  ) {\n    return;\n  }\n\n  const commands = primitive._commands;\n  const commandsIgnoreShow = primitive._commandsIgnoreShow;\n  const spStencil = primitive._spStencil;\n\n  const commandsLength = commands.length;\n  const length = (commandsIgnoreShow.length = commandsLength / 2);\n\n  let commandIndex = 0;\n  for (let j = 0; j < length; ++j) {\n    const commandIgnoreShow = (commandsIgnoreShow[j] = DrawCommand.shallowClone(\n      commands[commandIndex],\n      commandsIgnoreShow[j],\n    ));\n    commandIgnoreShow.shaderProgram = spStencil;\n    commandIgnoreShow.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW;\n\n    commandIndex += 2;\n  }\n\n  primitive._commandsDirty = false;\n}\n\nfunction createPickCommands(primitive) {\n  if (!primitive._pickCommandsDirty) {\n    return;\n  }\n\n  const length = primitive._indexOffsets.length;\n  const pickCommands = primitive._pickCommands;\n  pickCommands.length = length * 2;\n\n  const vertexArray = primitive._va;\n  const spStencil = primitive._spStencil;\n  const spPick = primitive._spPick;\n  const modelMatrix = primitive._modelMatrix ?? Matrix4.IDENTITY;\n  const uniformMap = primitive._uniformMap;\n\n  for (let j = 0; j < length; ++j) {\n    const offset = primitive._indexOffsets[j];\n    const count = primitive._indexCounts[j];\n    const bv = defined(primitive._boundingVolumes)\n      ? primitive._boundingVolumes[j]\n      : primitive.boundingVolume;\n\n    let stencilDepthCommand = pickCommands[j * 2];\n    if (!defined(stencilDepthCommand)) {\n      stencilDepthCommand = pickCommands[j * 2] = new DrawCommand({\n        owner: primitive,\n        pickOnly: true,\n      });\n    }\n\n    stencilDepthCommand.vertexArray = vertexArray;\n    stencilDepthCommand.modelMatrix = modelMatrix;\n    stencilDepthCommand.offset = offset;\n    stencilDepthCommand.count = count;\n    stencilDepthCommand.renderState = primitive._rsStencilDepthPass;\n    stencilDepthCommand.shaderProgram = spStencil;\n    stencilDepthCommand.uniformMap = uniformMap;\n    stencilDepthCommand.boundingVolume = bv;\n    stencilDepthCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    const stencilDepthDerivedCommand = DrawCommand.shallowClone(\n      stencilDepthCommand,\n      stencilDepthCommand.derivedCommands.tileset,\n    );\n    stencilDepthDerivedCommand.renderState =\n      primitive._rsStencilDepthPass3DTiles;\n    stencilDepthDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    stencilDepthCommand.derivedCommands.tileset = stencilDepthDerivedCommand;\n\n    let colorCommand = pickCommands[j * 2 + 1];\n    if (!defined(colorCommand)) {\n      colorCommand = pickCommands[j * 2 + 1] = new DrawCommand({\n        owner: primitive,\n        pickOnly: true,\n      });\n    }\n\n    colorCommand.vertexArray = vertexArray;\n    colorCommand.modelMatrix = modelMatrix;\n    colorCommand.offset = offset;\n    colorCommand.count = count;\n    colorCommand.renderState = primitive._rsPickPass;\n    colorCommand.shaderProgram = spPick;\n    colorCommand.uniformMap = uniformMap;\n    colorCommand.boundingVolume = bv;\n    colorCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    const colorDerivedCommand = DrawCommand.shallowClone(\n      colorCommand,\n      colorCommand.derivedCommands.tileset,\n    );\n    colorDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    colorCommand.derivedCommands.tileset = colorDerivedCommand;\n  }\n\n  primitive._pickCommandsDirty = false;\n}\n\n/**\n * Creates features for each mesh and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\nVector3DTilePrimitive.prototype.createFeatures = function (content, features) {\n  const batchIds = this._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    features[batchId] = new Cesium3DTileFeature(content, batchId);\n  }\n};\n\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (mesh batch table color * color).\n *\n * @param {boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\nVector3DTilePrimitive.prototype.applyDebugSettings = function (enabled, color) {\n  this._highlightColor = enabled ? color : this._constantColor;\n};\n\nfunction clearStyle(polygons, features) {\n  polygons._updatingAllCommands = true;\n\n  const batchIds = polygons._batchIds;\n  let length = batchIds.length;\n  let i;\n\n  for (i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    const feature = features[batchId];\n\n    feature.show = true;\n    feature.color = Color.WHITE;\n  }\n\n  const batchedIndices = polygons._batchedIndices;\n  length = batchedIndices.length;\n\n  for (i = 0; i < length; ++i) {\n    batchedIndices[i].color = Color.clone(Color.WHITE);\n  }\n\n  polygons._updatingAllCommands = false;\n  polygons._batchDirty = true;\n}\n\nconst scratchColor = new Color();\n\nconst DEFAULT_COLOR_VALUE = Color.WHITE;\nconst DEFAULT_SHOW_VALUE = true;\n\nconst complexExpressionReg = /\\$/;\n\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The array of features.\n */\nVector3DTilePrimitive.prototype.applyStyle = function (style, features) {\n  if (!defined(style)) {\n    clearStyle(this, features);\n    return;\n  }\n\n  const colorExpression = style.color;\n  const isSimpleStyle =\n    colorExpression instanceof Expression &&\n    !complexExpressionReg.test(colorExpression.expression);\n  this._updatingAllCommands = isSimpleStyle;\n\n  const batchIds = this._batchIds;\n  let length = batchIds.length;\n  let i;\n\n  for (i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    const feature = features[batchId];\n\n    feature.color = defined(style.color)\n      ? style.color.evaluateColor(feature, scratchColor)\n      : DEFAULT_COLOR_VALUE;\n    feature.show = defined(style.show)\n      ? style.show.evaluate(feature)\n      : DEFAULT_SHOW_VALUE;\n  }\n\n  if (isSimpleStyle) {\n    const batchedIndices = this._batchedIndices;\n    length = batchedIndices.length;\n\n    for (i = 0; i < length; ++i) {\n      batchedIndices[i].color = Color.clone(Color.WHITE);\n    }\n\n    this._updatingAllCommands = false;\n    this._batchDirty = true;\n  }\n};\n\n/**\n * Call when updating the color of a mesh with batchId changes color. The meshes will need to be re-batched\n * on the next update.\n *\n * @param {number} batchId The batch id of the meshes whose color has changed.\n * @param {Color} color The new polygon color.\n */\nVector3DTilePrimitive.prototype.updateCommands = function (batchId, color) {\n  if (this._updatingAllCommands) {\n    return;\n  }\n\n  const batchIdLookUp = this._batchIdLookUp;\n  const index = batchIdLookUp[batchId];\n  if (!defined(index)) {\n    return;\n  }\n\n  const indexOffsets = this._indexOffsets;\n  const indexCounts = this._indexCounts;\n\n  const offset = indexOffsets[index];\n  const count = indexCounts[index];\n\n  const batchedIndices = this._batchedIndices;\n  const length = batchedIndices.length;\n\n  let i;\n  for (i = 0; i < length; ++i) {\n    const batchedOffset = batchedIndices[i].offset;\n    const batchedCount = batchedIndices[i].count;\n\n    if (offset >= batchedOffset && offset < batchedOffset + batchedCount) {\n      break;\n    }\n  }\n\n  batchedIndices.push(\n    new Vector3DTileBatch({\n      color: Color.clone(color),\n      offset: offset,\n      count: count,\n      batchIds: [batchId],\n    }),\n  );\n\n  const startIds = [];\n  const endIds = [];\n\n  const batchIds = batchedIndices[i].batchIds;\n  const batchIdsLength = batchIds.length;\n\n  for (let j = 0; j < batchIdsLength; ++j) {\n    const id = batchIds[j];\n    if (id === batchId) {\n      continue;\n    }\n\n    const offsetIndex = batchIdLookUp[id];\n    if (indexOffsets[offsetIndex] < offset) {\n      startIds.push(id);\n    } else {\n      endIds.push(id);\n    }\n  }\n\n  if (endIds.length !== 0) {\n    batchedIndices.push(\n      new Vector3DTileBatch({\n        color: Color.clone(batchedIndices[i].color),\n        offset: offset + count,\n        count:\n          batchedIndices[i].offset + batchedIndices[i].count - (offset + count),\n        batchIds: endIds,\n      }),\n    );\n  }\n\n  if (startIds.length !== 0) {\n    batchedIndices[i].count = offset - batchedIndices[i].offset;\n    batchedIndices[i].batchIds = startIds;\n  } else {\n    batchedIndices.splice(i, 1);\n  }\n\n  this._batchDirty = true;\n};\n\nfunction queueCommands(primitive, frameState, commands, commandsIgnoreShow) {\n  const classificationType = primitive.classificationType;\n  const queueTerrainCommands =\n    classificationType !== ClassificationType.CESIUM_3D_TILE;\n  const queue3DTilesCommands =\n    classificationType !== ClassificationType.TERRAIN;\n\n  const commandList = frameState.commandList;\n  let commandLength = commands.length;\n  let command;\n  let i;\n  for (i = 0; i < commandLength; ++i) {\n    if (queueTerrainCommands) {\n      command = commands[i];\n      command.pass = Pass.TERRAIN_CLASSIFICATION;\n      commandList.push(command);\n    }\n    if (queue3DTilesCommands) {\n      command = commands[i].derivedCommands.tileset;\n      command.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n      commandList.push(command);\n    }\n  }\n\n  if (!frameState.invertClassification || !defined(commandsIgnoreShow)) {\n    return;\n  }\n\n  commandLength = commandsIgnoreShow.length;\n  for (i = 0; i < commandLength; ++i) {\n    commandList.push(commandsIgnoreShow[i]);\n  }\n}\n\nfunction queueWireframeCommands(frameState, commands) {\n  const commandList = frameState.commandList;\n  const commandLength = commands.length;\n  for (let i = 0; i < commandLength; i += 2) {\n    const command = commands[i + 1];\n    command.pass = Pass.OPAQUE;\n    commandList.push(command);\n  }\n}\n\nfunction updateWireframe(primitive) {\n  let earlyExit = primitive.debugWireframe === primitive._debugWireframe;\n  earlyExit =\n    earlyExit && !(primitive.debugWireframe && primitive._wireframeDirty);\n  if (earlyExit) {\n    return;\n  }\n\n  if (!defined(primitive._rsWireframe)) {\n    primitive._rsWireframe = RenderState.fromCache({});\n  }\n\n  let rs;\n  let type;\n\n  if (primitive.debugWireframe) {\n    rs = primitive._rsWireframe;\n    type = PrimitiveType.LINES;\n  } else {\n    rs = primitive._rsColorPass;\n    type = PrimitiveType.TRIANGLES;\n  }\n\n  const commands = primitive._commands;\n  const commandLength = commands.length;\n  for (let i = 0; i < commandLength; i += 2) {\n    const command = commands[i + 1];\n    command.renderState = rs;\n    command.primitiveType = type;\n  }\n\n  primitive._debugWireframe = primitive.debugWireframe;\n  primitive._wireframeDirty = false;\n}\n\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\nVector3DTilePrimitive.prototype.update = function (frameState) {\n  const context = frameState.context;\n\n  createVertexArray(this, context);\n  createShaders(this, context);\n  createRenderStates(this);\n  createUniformMap(this, context);\n\n  const passes = frameState.passes;\n  if (passes.render) {\n    createColorCommands(this, context);\n    createColorCommandsIgnoreShow(this, frameState);\n    updateWireframe(this);\n\n    if (this._debugWireframe) {\n      queueWireframeCommands(frameState, this._commands);\n    } else {\n      queueCommands(this, frameState, this._commands, this._commandsIgnoreShow);\n    }\n  }\n\n  if (passes.pick) {\n    createPickCommands(this);\n    queueCommands(this, frameState, this._pickCommands);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nVector3DTilePrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVector3DTilePrimitive.prototype.destroy = function () {\n  this._va = this._va && this._va.destroy();\n  this._sp = this._sp && this._sp.destroy();\n  this._spPick = this._spPick && this._spPick.destroy();\n  this._vaSwap = this._vaSwap && this._vaSwap.destroy();\n  return destroyObject(this);\n};\nexport default Vector3DTilePrimitive;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}