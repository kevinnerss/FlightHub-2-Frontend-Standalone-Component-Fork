{"ast":null,"code":"import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Resource from \"../Core/Resource.js\";\nimport ColorBlendMode from \"../Scene/ColorBlendMode.js\";\nimport HeightReference, { isHeightReferenceClamp } from \"../Scene/HeightReference.js\";\nimport Model from \"../Scene/Model/Model.js\";\nimport ModelAnimationLoop from \"../Scene/ModelAnimationLoop.js\";\nimport ShadowMode from \"../Scene/ShadowMode.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport Property from \"./Property.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nconst defaultScale = 1.0;\nconst defaultEnableVerticalExaggeration = true;\nconst defaultMinimumPixelSize = 0.0;\nconst defaultIncrementallyLoadTextures = true;\nconst defaultClampAnimations = true;\nconst defaultShadows = ShadowMode.ENABLED;\nconst defaultHeightReference = HeightReference.NONE;\nconst defaultSilhouetteColor = Color.RED;\nconst defaultSilhouetteSize = 0.0;\nconst defaultColor = Color.WHITE;\nconst defaultColorBlendMode = ColorBlendMode.HIGHLIGHT;\nconst defaultColorBlendAmount = 0.5;\nconst defaultImageBasedLightingFactor = new Cartesian2(1.0, 1.0);\nconst defaultEnvironmentMapOptions = {\n  maximumPositionEpsilon: Number.POSITIVE_INFINITY\n};\nconst modelMatrixScratch = new Matrix4();\nconst nodeMatrixScratch = new Matrix4();\nconst scratchColor = new Color();\nconst scratchArray = new Array(4);\nconst scratchCartesian = new Cartesian3();\n\n/**\n * A {@link Visualizer} which maps {@link Entity#model} to a {@link Model}.\n * @alias ModelVisualizer\n * @constructor\n *\n * @param {Scene} scene The scene the primitives will be rendered in.\n * @param {EntityCollection} entityCollection The entityCollection to visualize.\n */\nfunction ModelVisualizer(scene, entityCollection) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scene\", scene);\n  Check.typeOf.object(\"entityCollection\", entityCollection);\n  //>>includeEnd('debug');\n\n  entityCollection.collectionChanged.addEventListener(ModelVisualizer.prototype._onCollectionChanged, this);\n  this._scene = scene;\n  this._primitives = scene.primitives;\n  this._entityCollection = entityCollection;\n  this._modelHash = {};\n  this._entitiesToVisualize = new AssociativeArray();\n  this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n}\nasync function createModelPrimitive(visualizer, entity, resource, incrementallyLoadTextures, environmentMapOptions) {\n  const primitives = visualizer._primitives;\n  const modelHash = visualizer._modelHash;\n  try {\n    const model = await Model.fromGltfAsync({\n      url: resource,\n      incrementallyLoadTextures: incrementallyLoadTextures,\n      scene: visualizer._scene,\n      environmentMapOptions: environmentMapOptions\n    });\n    if (visualizer.isDestroyed() || !defined(modelHash[entity.id])) {\n      return;\n    }\n    model.id = entity;\n    primitives.add(model);\n    modelHash[entity.id].modelPrimitive = model;\n    model.errorEvent.addEventListener(error => {\n      if (!defined(modelHash[entity.id])) {\n        return;\n      }\n      console.log(error);\n\n      // Texture failures when incrementallyLoadTextures\n      // will not affect the ability to compute the bounding sphere\n      if (error.name !== \"TextureError\" && model.incrementallyLoadTextures) {\n        modelHash[entity.id].loadFailed = true;\n      }\n    });\n  } catch (error) {\n    if (visualizer.isDestroyed() || !defined(modelHash[entity.id])) {\n      return;\n    }\n    console.log(error);\n    modelHash[entity.id].loadFailed = true;\n  }\n}\n\n/**\n * Updates models created this visualizer to match their\n * Entity counterpart at the given time.\n *\n * @param {JulianDate} time The time to update to.\n * @returns {boolean} This function always returns true.\n */\nModelVisualizer.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(time)) {\n    throw new DeveloperError(\"time is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const entities = this._entitiesToVisualize.values;\n  const modelHash = this._modelHash;\n  const primitives = this._primitives;\n  for (let i = 0, len = entities.length; i < len; i++) {\n    const entity = entities[i];\n    const modelGraphics = entity._model;\n    let resource;\n    let modelData = modelHash[entity.id];\n    let show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(modelGraphics._show, time, true);\n    let modelMatrix;\n    if (show) {\n      modelMatrix = entity.computeModelMatrix(time, modelMatrixScratch);\n      resource = Resource.createIfNeeded(Property.getValueOrUndefined(modelGraphics._uri, time));\n      show = defined(modelMatrix) && defined(resource);\n    }\n    if (!show) {\n      if (defined(modelData) && modelData.modelPrimitive) {\n        modelData.modelPrimitive.show = false;\n      }\n      continue;\n    }\n    if (!defined(modelData) || resource.url !== modelData.url) {\n      if (defined(modelData?.modelPrimitive)) {\n        primitives.removeAndDestroy(modelData.modelPrimitive);\n        delete modelHash[entity.id];\n      }\n      modelData = {\n        modelPrimitive: undefined,\n        url: resource.url,\n        animationsRunning: false,\n        nodeTransformationsScratch: {},\n        articulationsScratch: {},\n        loadFailed: false,\n        modelUpdated: false,\n        environmentMapOptionsScratch: {\n          ...defaultEnvironmentMapOptions\n        }\n      };\n      modelHash[entity.id] = modelData;\n      const incrementallyLoadTextures = Property.getValueOrDefault(modelGraphics._incrementallyLoadTextures, time, defaultIncrementallyLoadTextures);\n      const environmentMapOptions = Property.getValueOrDefault(modelGraphics._environmentMapOptions, time, defaultEnvironmentMapOptions, modelData.environmentMapOptionsScratch);\n      createModelPrimitive(this, entity, resource, incrementallyLoadTextures, environmentMapOptions);\n    }\n    const model = modelData.modelPrimitive;\n    if (!defined(model)) {\n      continue;\n    }\n    model.show = true;\n    model.scale = Property.getValueOrDefault(modelGraphics._scale, time, defaultScale);\n    model.enableVerticalExaggeration = Property.getValueOrDefault(modelGraphics._enableVerticalExaggeration, time, defaultEnableVerticalExaggeration);\n    model.minimumPixelSize = Property.getValueOrDefault(modelGraphics._minimumPixelSize, time, defaultMinimumPixelSize);\n    model.maximumScale = Property.getValueOrUndefined(modelGraphics._maximumScale, time);\n    model.modelMatrix = Matrix4.clone(modelMatrix, model.modelMatrix);\n    model.shadows = Property.getValueOrDefault(modelGraphics._shadows, time, defaultShadows);\n    model.heightReference = Property.getValueOrDefault(modelGraphics._heightReference, time, defaultHeightReference);\n    model.distanceDisplayCondition = Property.getValueOrUndefined(modelGraphics._distanceDisplayCondition, time);\n    model.silhouetteColor = Property.getValueOrDefault(modelGraphics._silhouetteColor, time, defaultSilhouetteColor, scratchColor);\n    model.silhouetteSize = Property.getValueOrDefault(modelGraphics._silhouetteSize, time, defaultSilhouetteSize);\n    model.color = Property.getValueOrDefault(modelGraphics._color, time, defaultColor, scratchColor);\n    model.colorBlendMode = Property.getValueOrDefault(modelGraphics._colorBlendMode, time, defaultColorBlendMode);\n    model.colorBlendAmount = Property.getValueOrDefault(modelGraphics._colorBlendAmount, time, defaultColorBlendAmount);\n    model.clippingPlanes = Property.getValueOrUndefined(modelGraphics._clippingPlanes, time);\n    model.clampAnimations = Property.getValueOrDefault(modelGraphics._clampAnimations, time, defaultClampAnimations);\n    model.imageBasedLighting.imageBasedLightingFactor = Property.getValueOrDefault(modelGraphics._imageBasedLightingFactor, time, defaultImageBasedLightingFactor);\n    let lightColor = Property.getValueOrUndefined(modelGraphics._lightColor, time);\n\n    // Convert from Color to Cartesian3\n    if (defined(lightColor)) {\n      Color.pack(lightColor, scratchArray, 0);\n      lightColor = Cartesian3.unpack(scratchArray, 0, scratchCartesian);\n    }\n    model.lightColor = lightColor;\n    model.customShader = Property.getValueOrUndefined(modelGraphics._customShader, time);\n\n    // It's possible for getBoundingSphere to run before\n    // model becomes ready and these properties are updated\n    modelHash[entity.id].modelUpdated = true;\n    if (model.ready) {\n      const runAnimations = Property.getValueOrDefault(modelGraphics._runAnimations, time, true);\n      if (modelData.animationsRunning !== runAnimations) {\n        if (runAnimations) {\n          model.activeAnimations.addAll({\n            loop: ModelAnimationLoop.REPEAT\n          });\n        } else {\n          model.activeAnimations.removeAll();\n        }\n        modelData.animationsRunning = runAnimations;\n      }\n\n      // Apply node transformations\n      const nodeTransformations = Property.getValueOrUndefined(modelGraphics._nodeTransformations, time, modelData.nodeTransformationsScratch);\n      if (defined(nodeTransformations)) {\n        const nodeNames = Object.keys(nodeTransformations);\n        for (let nodeIndex = 0, nodeLength = nodeNames.length; nodeIndex < nodeLength; ++nodeIndex) {\n          const nodeName = nodeNames[nodeIndex];\n          const nodeTransformation = nodeTransformations[nodeName];\n          if (!defined(nodeTransformation)) {\n            continue;\n          }\n          const modelNode = model.getNode(nodeName);\n          if (!defined(modelNode)) {\n            continue;\n          }\n          const transformationMatrix = Matrix4.fromTranslationRotationScale(nodeTransformation, nodeMatrixScratch);\n          modelNode.matrix = Matrix4.multiply(modelNode.originalMatrix, transformationMatrix, transformationMatrix);\n        }\n      }\n\n      // Apply articulations\n      let anyArticulationUpdated = false;\n      const articulations = Property.getValueOrUndefined(modelGraphics._articulations, time, modelData.articulationsScratch);\n      if (defined(articulations)) {\n        const articulationStageKeys = Object.keys(articulations);\n        for (let s = 0, numKeys = articulationStageKeys.length; s < numKeys; ++s) {\n          const key = articulationStageKeys[s];\n          const articulationStageValue = articulations[key];\n          if (!defined(articulationStageValue)) {\n            continue;\n          }\n          anyArticulationUpdated = true;\n          model.setArticulationStage(key, articulationStageValue);\n        }\n      }\n      if (anyArticulationUpdated) {\n        model.applyArticulations();\n      }\n    }\n  }\n  return true;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n */\nModelVisualizer.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes and destroys all primitives created by this instance.\n */\nModelVisualizer.prototype.destroy = function () {\n  this._entityCollection.collectionChanged.removeEventListener(ModelVisualizer.prototype._onCollectionChanged, this);\n  const entities = this._entitiesToVisualize.values;\n  const modelHash = this._modelHash;\n  const primitives = this._primitives;\n  for (let i = entities.length - 1; i > -1; i--) {\n    removeModel(this, entities[i], modelHash, primitives);\n  }\n  return destroyObject(this);\n};\nconst scratchPosition = new Cartesian3();\nconst scratchCartographic = new Cartographic();\n/**\n * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n * The bounding sphere is in the fixed frame of the scene's globe.\n *\n * @param {Entity} entity The entity whose bounding sphere to compute.\n * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n *                       BoundingSphereState.PENDING if the result is still being computed, or\n *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n * @private\n */\nModelVisualizer.prototype.getBoundingSphere = function (entity, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entity)) {\n    throw new DeveloperError(\"entity is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const modelData = this._modelHash[entity.id];\n  if (!defined(modelData)) {\n    return BoundingSphereState.FAILED;\n  }\n  if (modelData.loadFailed) {\n    return BoundingSphereState.FAILED;\n  }\n  const model = modelData.modelPrimitive;\n  if (!defined(model) || !model.show) {\n    return BoundingSphereState.PENDING;\n  }\n  if (!model.ready || !modelData.modelUpdated) {\n    return BoundingSphereState.PENDING;\n  }\n  const scene = this._scene;\n  const ellipsoid = scene.ellipsoid ?? Ellipsoid.default;\n  const hasHeightReference = model.heightReference !== HeightReference.NONE;\n  if (hasHeightReference) {\n    const modelMatrix = model.modelMatrix;\n    scratchPosition.x = modelMatrix[12];\n    scratchPosition.y = modelMatrix[13];\n    scratchPosition.z = modelMatrix[14];\n    const cartoPosition = ellipsoid.cartesianToCartographic(scratchPosition, scratchCartographic);\n    const height = scene.getHeight(cartoPosition, model.heightReference);\n    if (defined(height)) {\n      if (isHeightReferenceClamp(model.heightReference)) {\n        cartoPosition.height = height;\n      } else {\n        cartoPosition.height += height;\n      }\n    }\n    BoundingSphere.clone(model.boundingSphere, result);\n    result.center = ellipsoid.cartographicToCartesian(cartoPosition);\n    return BoundingSphereState.DONE;\n  }\n  BoundingSphere.clone(model.boundingSphere, result);\n  return BoundingSphereState.DONE;\n};\n\n/**\n * @private\n */\nModelVisualizer.prototype._onCollectionChanged = function (entityCollection, added, removed, changed) {\n  let i;\n  let entity;\n  const entities = this._entitiesToVisualize;\n  const modelHash = this._modelHash;\n  const primitives = this._primitives;\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    if (defined(entity._model) && defined(entity._position)) {\n      entities.set(entity.id, entity);\n    }\n  }\n  for (i = changed.length - 1; i > -1; i--) {\n    entity = changed[i];\n    if (defined(entity._model) && defined(entity._position)) {\n      clearNodeTransformationsArticulationsScratch(entity, modelHash);\n      entities.set(entity.id, entity);\n    } else {\n      removeModel(this, entity, modelHash, primitives);\n      entities.remove(entity.id);\n    }\n  }\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    removeModel(this, entity, modelHash, primitives);\n    entities.remove(entity.id);\n  }\n};\nfunction removeModel(visualizer, entity, modelHash, primitives) {\n  const modelData = modelHash[entity.id];\n  if (defined(modelData)) {\n    primitives.removeAndDestroy(modelData.modelPrimitive);\n    delete modelHash[entity.id];\n  }\n}\nfunction clearNodeTransformationsArticulationsScratch(entity, modelHash) {\n  const modelData = modelHash[entity.id];\n  if (defined(modelData)) {\n    modelData.nodeTransformationsScratch = {};\n    modelData.articulationsScratch = {};\n  }\n}\nexport default ModelVisualizer;","map":{"version":3,"names":["AssociativeArray","BoundingSphere","Cartesian2","Cartesian3","Check","Color","defined","destroyObject","DeveloperError","Ellipsoid","Matrix4","Resource","ColorBlendMode","HeightReference","isHeightReferenceClamp","Model","ModelAnimationLoop","ShadowMode","BoundingSphereState","Property","Cartographic","defaultScale","defaultEnableVerticalExaggeration","defaultMinimumPixelSize","defaultIncrementallyLoadTextures","defaultClampAnimations","defaultShadows","ENABLED","defaultHeightReference","NONE","defaultSilhouetteColor","RED","defaultSilhouetteSize","defaultColor","WHITE","defaultColorBlendMode","HIGHLIGHT","defaultColorBlendAmount","defaultImageBasedLightingFactor","defaultEnvironmentMapOptions","maximumPositionEpsilon","Number","POSITIVE_INFINITY","modelMatrixScratch","nodeMatrixScratch","scratchColor","scratchArray","Array","scratchCartesian","ModelVisualizer","scene","entityCollection","typeOf","object","collectionChanged","addEventListener","prototype","_onCollectionChanged","_scene","_primitives","primitives","_entityCollection","_modelHash","_entitiesToVisualize","values","createModelPrimitive","visualizer","entity","resource","incrementallyLoadTextures","environmentMapOptions","modelHash","model","fromGltfAsync","url","isDestroyed","id","add","modelPrimitive","errorEvent","error","console","log","name","loadFailed","update","time","entities","i","len","length","modelGraphics","_model","modelData","show","isShowing","isAvailable","getValueOrDefault","_show","modelMatrix","computeModelMatrix","createIfNeeded","getValueOrUndefined","_uri","removeAndDestroy","undefined","animationsRunning","nodeTransformationsScratch","articulationsScratch","modelUpdated","environmentMapOptionsScratch","_incrementallyLoadTextures","_environmentMapOptions","scale","_scale","enableVerticalExaggeration","_enableVerticalExaggeration","minimumPixelSize","_minimumPixelSize","maximumScale","_maximumScale","clone","shadows","_shadows","heightReference","_heightReference","distanceDisplayCondition","_distanceDisplayCondition","silhouetteColor","_silhouetteColor","silhouetteSize","_silhouetteSize","color","_color","colorBlendMode","_colorBlendMode","colorBlendAmount","_colorBlendAmount","clippingPlanes","_clippingPlanes","clampAnimations","_clampAnimations","imageBasedLighting","imageBasedLightingFactor","_imageBasedLightingFactor","lightColor","_lightColor","pack","unpack","customShader","_customShader","ready","runAnimations","_runAnimations","activeAnimations","addAll","loop","REPEAT","removeAll","nodeTransformations","_nodeTransformations","nodeNames","Object","keys","nodeIndex","nodeLength","nodeName","nodeTransformation","modelNode","getNode","transformationMatrix","fromTranslationRotationScale","matrix","multiply","originalMatrix","anyArticulationUpdated","articulations","_articulations","articulationStageKeys","s","numKeys","key","articulationStageValue","setArticulationStage","applyArticulations","destroy","removeEventListener","removeModel","scratchPosition","scratchCartographic","getBoundingSphere","result","FAILED","PENDING","ellipsoid","default","hasHeightReference","x","y","z","cartoPosition","cartesianToCartographic","height","getHeight","boundingSphere","center","cartographicToCartesian","DONE","added","removed","changed","_position","set","clearNodeTransformationsArticulationsScratch","remove"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/DataSources/ModelVisualizer.js"],"sourcesContent":["import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Resource from \"../Core/Resource.js\";\nimport ColorBlendMode from \"../Scene/ColorBlendMode.js\";\nimport HeightReference, {\n  isHeightReferenceClamp,\n} from \"../Scene/HeightReference.js\";\nimport Model from \"../Scene/Model/Model.js\";\nimport ModelAnimationLoop from \"../Scene/ModelAnimationLoop.js\";\nimport ShadowMode from \"../Scene/ShadowMode.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport Property from \"./Property.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\n\nconst defaultScale = 1.0;\nconst defaultEnableVerticalExaggeration = true;\nconst defaultMinimumPixelSize = 0.0;\nconst defaultIncrementallyLoadTextures = true;\nconst defaultClampAnimations = true;\nconst defaultShadows = ShadowMode.ENABLED;\nconst defaultHeightReference = HeightReference.NONE;\nconst defaultSilhouetteColor = Color.RED;\nconst defaultSilhouetteSize = 0.0;\nconst defaultColor = Color.WHITE;\nconst defaultColorBlendMode = ColorBlendMode.HIGHLIGHT;\nconst defaultColorBlendAmount = 0.5;\nconst defaultImageBasedLightingFactor = new Cartesian2(1.0, 1.0);\nconst defaultEnvironmentMapOptions = {\n  maximumPositionEpsilon: Number.POSITIVE_INFINITY,\n};\n\nconst modelMatrixScratch = new Matrix4();\nconst nodeMatrixScratch = new Matrix4();\n\nconst scratchColor = new Color();\nconst scratchArray = new Array(4);\nconst scratchCartesian = new Cartesian3();\n\n/**\n * A {@link Visualizer} which maps {@link Entity#model} to a {@link Model}.\n * @alias ModelVisualizer\n * @constructor\n *\n * @param {Scene} scene The scene the primitives will be rendered in.\n * @param {EntityCollection} entityCollection The entityCollection to visualize.\n */\nfunction ModelVisualizer(scene, entityCollection) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scene\", scene);\n  Check.typeOf.object(\"entityCollection\", entityCollection);\n  //>>includeEnd('debug');\n\n  entityCollection.collectionChanged.addEventListener(\n    ModelVisualizer.prototype._onCollectionChanged,\n    this,\n  );\n\n  this._scene = scene;\n  this._primitives = scene.primitives;\n  this._entityCollection = entityCollection;\n  this._modelHash = {};\n  this._entitiesToVisualize = new AssociativeArray();\n\n  this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n}\n\nasync function createModelPrimitive(\n  visualizer,\n  entity,\n  resource,\n  incrementallyLoadTextures,\n  environmentMapOptions,\n) {\n  const primitives = visualizer._primitives;\n  const modelHash = visualizer._modelHash;\n\n  try {\n    const model = await Model.fromGltfAsync({\n      url: resource,\n      incrementallyLoadTextures: incrementallyLoadTextures,\n      scene: visualizer._scene,\n      environmentMapOptions: environmentMapOptions,\n    });\n\n    if (visualizer.isDestroyed() || !defined(modelHash[entity.id])) {\n      return;\n    }\n\n    model.id = entity;\n    primitives.add(model);\n    modelHash[entity.id].modelPrimitive = model;\n    model.errorEvent.addEventListener((error) => {\n      if (!defined(modelHash[entity.id])) {\n        return;\n      }\n\n      console.log(error);\n\n      // Texture failures when incrementallyLoadTextures\n      // will not affect the ability to compute the bounding sphere\n      if (error.name !== \"TextureError\" && model.incrementallyLoadTextures) {\n        modelHash[entity.id].loadFailed = true;\n      }\n    });\n  } catch (error) {\n    if (visualizer.isDestroyed() || !defined(modelHash[entity.id])) {\n      return;\n    }\n\n    console.log(error);\n    modelHash[entity.id].loadFailed = true;\n  }\n}\n\n/**\n * Updates models created this visualizer to match their\n * Entity counterpart at the given time.\n *\n * @param {JulianDate} time The time to update to.\n * @returns {boolean} This function always returns true.\n */\nModelVisualizer.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(time)) {\n    throw new DeveloperError(\"time is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const entities = this._entitiesToVisualize.values;\n  const modelHash = this._modelHash;\n  const primitives = this._primitives;\n\n  for (let i = 0, len = entities.length; i < len; i++) {\n    const entity = entities[i];\n    const modelGraphics = entity._model;\n\n    let resource;\n    let modelData = modelHash[entity.id];\n    let show =\n      entity.isShowing &&\n      entity.isAvailable(time) &&\n      Property.getValueOrDefault(modelGraphics._show, time, true);\n\n    let modelMatrix;\n    if (show) {\n      modelMatrix = entity.computeModelMatrix(time, modelMatrixScratch);\n      resource = Resource.createIfNeeded(\n        Property.getValueOrUndefined(modelGraphics._uri, time),\n      );\n      show = defined(modelMatrix) && defined(resource);\n    }\n\n    if (!show) {\n      if (defined(modelData) && modelData.modelPrimitive) {\n        modelData.modelPrimitive.show = false;\n      }\n      continue;\n    }\n\n    if (!defined(modelData) || resource.url !== modelData.url) {\n      if (defined(modelData?.modelPrimitive)) {\n        primitives.removeAndDestroy(modelData.modelPrimitive);\n        delete modelHash[entity.id];\n      }\n\n      modelData = {\n        modelPrimitive: undefined,\n        url: resource.url,\n        animationsRunning: false,\n        nodeTransformationsScratch: {},\n        articulationsScratch: {},\n        loadFailed: false,\n        modelUpdated: false,\n        environmentMapOptionsScratch: {\n          ...defaultEnvironmentMapOptions,\n        },\n      };\n      modelHash[entity.id] = modelData;\n\n      const incrementallyLoadTextures = Property.getValueOrDefault(\n        modelGraphics._incrementallyLoadTextures,\n        time,\n        defaultIncrementallyLoadTextures,\n      );\n\n      const environmentMapOptions = Property.getValueOrDefault(\n        modelGraphics._environmentMapOptions,\n        time,\n        defaultEnvironmentMapOptions,\n        modelData.environmentMapOptionsScratch,\n      );\n\n      createModelPrimitive(\n        this,\n        entity,\n        resource,\n        incrementallyLoadTextures,\n        environmentMapOptions,\n      );\n    }\n\n    const model = modelData.modelPrimitive;\n    if (!defined(model)) {\n      continue;\n    }\n\n    model.show = true;\n    model.scale = Property.getValueOrDefault(\n      modelGraphics._scale,\n      time,\n      defaultScale,\n    );\n\n    model.enableVerticalExaggeration = Property.getValueOrDefault(\n      modelGraphics._enableVerticalExaggeration,\n      time,\n      defaultEnableVerticalExaggeration,\n    );\n\n    model.minimumPixelSize = Property.getValueOrDefault(\n      modelGraphics._minimumPixelSize,\n      time,\n      defaultMinimumPixelSize,\n    );\n    model.maximumScale = Property.getValueOrUndefined(\n      modelGraphics._maximumScale,\n      time,\n    );\n    model.modelMatrix = Matrix4.clone(modelMatrix, model.modelMatrix);\n    model.shadows = Property.getValueOrDefault(\n      modelGraphics._shadows,\n      time,\n      defaultShadows,\n    );\n    model.heightReference = Property.getValueOrDefault(\n      modelGraphics._heightReference,\n      time,\n      defaultHeightReference,\n    );\n    model.distanceDisplayCondition = Property.getValueOrUndefined(\n      modelGraphics._distanceDisplayCondition,\n      time,\n    );\n    model.silhouetteColor = Property.getValueOrDefault(\n      modelGraphics._silhouetteColor,\n      time,\n      defaultSilhouetteColor,\n      scratchColor,\n    );\n    model.silhouetteSize = Property.getValueOrDefault(\n      modelGraphics._silhouetteSize,\n      time,\n      defaultSilhouetteSize,\n    );\n    model.color = Property.getValueOrDefault(\n      modelGraphics._color,\n      time,\n      defaultColor,\n      scratchColor,\n    );\n    model.colorBlendMode = Property.getValueOrDefault(\n      modelGraphics._colorBlendMode,\n      time,\n      defaultColorBlendMode,\n    );\n    model.colorBlendAmount = Property.getValueOrDefault(\n      modelGraphics._colorBlendAmount,\n      time,\n      defaultColorBlendAmount,\n    );\n    model.clippingPlanes = Property.getValueOrUndefined(\n      modelGraphics._clippingPlanes,\n      time,\n    );\n    model.clampAnimations = Property.getValueOrDefault(\n      modelGraphics._clampAnimations,\n      time,\n      defaultClampAnimations,\n    );\n    model.imageBasedLighting.imageBasedLightingFactor =\n      Property.getValueOrDefault(\n        modelGraphics._imageBasedLightingFactor,\n        time,\n        defaultImageBasedLightingFactor,\n      );\n    let lightColor = Property.getValueOrUndefined(\n      modelGraphics._lightColor,\n      time,\n    );\n\n    // Convert from Color to Cartesian3\n    if (defined(lightColor)) {\n      Color.pack(lightColor, scratchArray, 0);\n      lightColor = Cartesian3.unpack(scratchArray, 0, scratchCartesian);\n    }\n\n    model.lightColor = lightColor;\n    model.customShader = Property.getValueOrUndefined(\n      modelGraphics._customShader,\n      time,\n    );\n\n    // It's possible for getBoundingSphere to run before\n    // model becomes ready and these properties are updated\n    modelHash[entity.id].modelUpdated = true;\n\n    if (model.ready) {\n      const runAnimations = Property.getValueOrDefault(\n        modelGraphics._runAnimations,\n        time,\n        true,\n      );\n      if (modelData.animationsRunning !== runAnimations) {\n        if (runAnimations) {\n          model.activeAnimations.addAll({\n            loop: ModelAnimationLoop.REPEAT,\n          });\n        } else {\n          model.activeAnimations.removeAll();\n        }\n        modelData.animationsRunning = runAnimations;\n      }\n\n      // Apply node transformations\n      const nodeTransformations = Property.getValueOrUndefined(\n        modelGraphics._nodeTransformations,\n        time,\n        modelData.nodeTransformationsScratch,\n      );\n      if (defined(nodeTransformations)) {\n        const nodeNames = Object.keys(nodeTransformations);\n        for (\n          let nodeIndex = 0, nodeLength = nodeNames.length;\n          nodeIndex < nodeLength;\n          ++nodeIndex\n        ) {\n          const nodeName = nodeNames[nodeIndex];\n\n          const nodeTransformation = nodeTransformations[nodeName];\n          if (!defined(nodeTransformation)) {\n            continue;\n          }\n\n          const modelNode = model.getNode(nodeName);\n          if (!defined(modelNode)) {\n            continue;\n          }\n\n          const transformationMatrix = Matrix4.fromTranslationRotationScale(\n            nodeTransformation,\n            nodeMatrixScratch,\n          );\n          modelNode.matrix = Matrix4.multiply(\n            modelNode.originalMatrix,\n            transformationMatrix,\n            transformationMatrix,\n          );\n        }\n      }\n\n      // Apply articulations\n      let anyArticulationUpdated = false;\n      const articulations = Property.getValueOrUndefined(\n        modelGraphics._articulations,\n        time,\n        modelData.articulationsScratch,\n      );\n      if (defined(articulations)) {\n        const articulationStageKeys = Object.keys(articulations);\n        for (\n          let s = 0, numKeys = articulationStageKeys.length;\n          s < numKeys;\n          ++s\n        ) {\n          const key = articulationStageKeys[s];\n\n          const articulationStageValue = articulations[key];\n          if (!defined(articulationStageValue)) {\n            continue;\n          }\n\n          anyArticulationUpdated = true;\n          model.setArticulationStage(key, articulationStageValue);\n        }\n      }\n\n      if (anyArticulationUpdated) {\n        model.applyArticulations();\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n */\nModelVisualizer.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes and destroys all primitives created by this instance.\n */\nModelVisualizer.prototype.destroy = function () {\n  this._entityCollection.collectionChanged.removeEventListener(\n    ModelVisualizer.prototype._onCollectionChanged,\n    this,\n  );\n  const entities = this._entitiesToVisualize.values;\n  const modelHash = this._modelHash;\n  const primitives = this._primitives;\n  for (let i = entities.length - 1; i > -1; i--) {\n    removeModel(this, entities[i], modelHash, primitives);\n  }\n  return destroyObject(this);\n};\n\nconst scratchPosition = new Cartesian3();\nconst scratchCartographic = new Cartographic();\n/**\n * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n * The bounding sphere is in the fixed frame of the scene's globe.\n *\n * @param {Entity} entity The entity whose bounding sphere to compute.\n * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n *                       BoundingSphereState.PENDING if the result is still being computed, or\n *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n * @private\n */\nModelVisualizer.prototype.getBoundingSphere = function (entity, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entity)) {\n    throw new DeveloperError(\"entity is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const modelData = this._modelHash[entity.id];\n  if (!defined(modelData)) {\n    return BoundingSphereState.FAILED;\n  }\n\n  if (modelData.loadFailed) {\n    return BoundingSphereState.FAILED;\n  }\n\n  const model = modelData.modelPrimitive;\n  if (!defined(model) || !model.show) {\n    return BoundingSphereState.PENDING;\n  }\n\n  if (!model.ready || !modelData.modelUpdated) {\n    return BoundingSphereState.PENDING;\n  }\n\n  const scene = this._scene;\n  const ellipsoid = scene.ellipsoid ?? Ellipsoid.default;\n\n  const hasHeightReference = model.heightReference !== HeightReference.NONE;\n  if (hasHeightReference) {\n    const modelMatrix = model.modelMatrix;\n    scratchPosition.x = modelMatrix[12];\n    scratchPosition.y = modelMatrix[13];\n    scratchPosition.z = modelMatrix[14];\n    const cartoPosition = ellipsoid.cartesianToCartographic(\n      scratchPosition,\n      scratchCartographic,\n    );\n\n    const height = scene.getHeight(cartoPosition, model.heightReference);\n    if (defined(height)) {\n      if (isHeightReferenceClamp(model.heightReference)) {\n        cartoPosition.height = height;\n      } else {\n        cartoPosition.height += height;\n      }\n    }\n\n    BoundingSphere.clone(model.boundingSphere, result);\n    result.center = ellipsoid.cartographicToCartesian(cartoPosition);\n    return BoundingSphereState.DONE;\n  }\n\n  BoundingSphere.clone(model.boundingSphere, result);\n  return BoundingSphereState.DONE;\n};\n\n/**\n * @private\n */\nModelVisualizer.prototype._onCollectionChanged = function (\n  entityCollection,\n  added,\n  removed,\n  changed,\n) {\n  let i;\n  let entity;\n  const entities = this._entitiesToVisualize;\n  const modelHash = this._modelHash;\n  const primitives = this._primitives;\n\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    if (defined(entity._model) && defined(entity._position)) {\n      entities.set(entity.id, entity);\n    }\n  }\n\n  for (i = changed.length - 1; i > -1; i--) {\n    entity = changed[i];\n    if (defined(entity._model) && defined(entity._position)) {\n      clearNodeTransformationsArticulationsScratch(entity, modelHash);\n      entities.set(entity.id, entity);\n    } else {\n      removeModel(this, entity, modelHash, primitives);\n      entities.remove(entity.id);\n    }\n  }\n\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    removeModel(this, entity, modelHash, primitives);\n    entities.remove(entity.id);\n  }\n};\n\nfunction removeModel(visualizer, entity, modelHash, primitives) {\n  const modelData = modelHash[entity.id];\n  if (defined(modelData)) {\n    primitives.removeAndDestroy(modelData.modelPrimitive);\n    delete modelHash[entity.id];\n  }\n}\n\nfunction clearNodeTransformationsArticulationsScratch(entity, modelHash) {\n  const modelData = modelHash[entity.id];\n  if (defined(modelData)) {\n    modelData.nodeTransformationsScratch = {};\n    modelData.articulationsScratch = {};\n  }\n}\n\nexport default ModelVisualizer;\n"],"mappings":"AAAA,OAAOA,gBAAgB,MAAM,6BAA6B;AAC1D,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,aAAa,MAAM,0BAA0B;AACpD,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,SAAS,MAAM,sBAAsB;AAC5C,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,QAAQ,MAAM,qBAAqB;AAC1C,OAAOC,cAAc,MAAM,4BAA4B;AACvD,OAAOC,eAAe,IACpBC,sBAAsB,QACjB,6BAA6B;AACpC,OAAOC,KAAK,MAAM,yBAAyB;AAC3C,OAAOC,kBAAkB,MAAM,gCAAgC;AAC/D,OAAOC,UAAU,MAAM,wBAAwB;AAC/C,OAAOC,mBAAmB,MAAM,0BAA0B;AAC1D,OAAOC,QAAQ,MAAM,eAAe;AACpC,OAAOC,YAAY,MAAM,yBAAyB;AAElD,MAAMC,YAAY,GAAG,GAAG;AACxB,MAAMC,iCAAiC,GAAG,IAAI;AAC9C,MAAMC,uBAAuB,GAAG,GAAG;AACnC,MAAMC,gCAAgC,GAAG,IAAI;AAC7C,MAAMC,sBAAsB,GAAG,IAAI;AACnC,MAAMC,cAAc,GAAGT,UAAU,CAACU,OAAO;AACzC,MAAMC,sBAAsB,GAAGf,eAAe,CAACgB,IAAI;AACnD,MAAMC,sBAAsB,GAAGzB,KAAK,CAAC0B,GAAG;AACxC,MAAMC,qBAAqB,GAAG,GAAG;AACjC,MAAMC,YAAY,GAAG5B,KAAK,CAAC6B,KAAK;AAChC,MAAMC,qBAAqB,GAAGvB,cAAc,CAACwB,SAAS;AACtD,MAAMC,uBAAuB,GAAG,GAAG;AACnC,MAAMC,+BAA+B,GAAG,IAAIpC,UAAU,CAAC,GAAG,EAAE,GAAG,CAAC;AAChE,MAAMqC,4BAA4B,GAAG;EACnCC,sBAAsB,EAAEC,MAAM,CAACC;AACjC,CAAC;AAED,MAAMC,kBAAkB,GAAG,IAAIjC,OAAO,CAAC,CAAC;AACxC,MAAMkC,iBAAiB,GAAG,IAAIlC,OAAO,CAAC,CAAC;AAEvC,MAAMmC,YAAY,GAAG,IAAIxC,KAAK,CAAC,CAAC;AAChC,MAAMyC,YAAY,GAAG,IAAIC,KAAK,CAAC,CAAC,CAAC;AACjC,MAAMC,gBAAgB,GAAG,IAAI7C,UAAU,CAAC,CAAC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS8C,eAAeA,CAACC,KAAK,EAAEC,gBAAgB,EAAE;EAChD;EACA/C,KAAK,CAACgD,MAAM,CAACC,MAAM,CAAC,OAAO,EAAEH,KAAK,CAAC;EACnC9C,KAAK,CAACgD,MAAM,CAACC,MAAM,CAAC,kBAAkB,EAAEF,gBAAgB,CAAC;EACzD;;EAEAA,gBAAgB,CAACG,iBAAiB,CAACC,gBAAgB,CACjDN,eAAe,CAACO,SAAS,CAACC,oBAAoB,EAC9C,IACF,CAAC;EAED,IAAI,CAACC,MAAM,GAAGR,KAAK;EACnB,IAAI,CAACS,WAAW,GAAGT,KAAK,CAACU,UAAU;EACnC,IAAI,CAACC,iBAAiB,GAAGV,gBAAgB;EACzC,IAAI,CAACW,UAAU,GAAG,CAAC,CAAC;EACpB,IAAI,CAACC,oBAAoB,GAAG,IAAI/D,gBAAgB,CAAC,CAAC;EAElD,IAAI,CAACyD,oBAAoB,CAACN,gBAAgB,EAAEA,gBAAgB,CAACa,MAAM,EAAE,EAAE,EAAE,EAAE,CAAC;AAC9E;AAEA,eAAeC,oBAAoBA,CACjCC,UAAU,EACVC,MAAM,EACNC,QAAQ,EACRC,yBAAyB,EACzBC,qBAAqB,EACrB;EACA,MAAMV,UAAU,GAAGM,UAAU,CAACP,WAAW;EACzC,MAAMY,SAAS,GAAGL,UAAU,CAACJ,UAAU;EAEvC,IAAI;IACF,MAAMU,KAAK,GAAG,MAAMzD,KAAK,CAAC0D,aAAa,CAAC;MACtCC,GAAG,EAAEN,QAAQ;MACbC,yBAAyB,EAAEA,yBAAyB;MACpDnB,KAAK,EAAEgB,UAAU,CAACR,MAAM;MACxBY,qBAAqB,EAAEA;IACzB,CAAC,CAAC;IAEF,IAAIJ,UAAU,CAACS,WAAW,CAAC,CAAC,IAAI,CAACrE,OAAO,CAACiE,SAAS,CAACJ,MAAM,CAACS,EAAE,CAAC,CAAC,EAAE;MAC9D;IACF;IAEAJ,KAAK,CAACI,EAAE,GAAGT,MAAM;IACjBP,UAAU,CAACiB,GAAG,CAACL,KAAK,CAAC;IACrBD,SAAS,CAACJ,MAAM,CAACS,EAAE,CAAC,CAACE,cAAc,GAAGN,KAAK;IAC3CA,KAAK,CAACO,UAAU,CAACxB,gBAAgB,CAAEyB,KAAK,IAAK;MAC3C,IAAI,CAAC1E,OAAO,CAACiE,SAAS,CAACJ,MAAM,CAACS,EAAE,CAAC,CAAC,EAAE;QAClC;MACF;MAEAK,OAAO,CAACC,GAAG,CAACF,KAAK,CAAC;;MAElB;MACA;MACA,IAAIA,KAAK,CAACG,IAAI,KAAK,cAAc,IAAIX,KAAK,CAACH,yBAAyB,EAAE;QACpEE,SAAS,CAACJ,MAAM,CAACS,EAAE,CAAC,CAACQ,UAAU,GAAG,IAAI;MACxC;IACF,CAAC,CAAC;EACJ,CAAC,CAAC,OAAOJ,KAAK,EAAE;IACd,IAAId,UAAU,CAACS,WAAW,CAAC,CAAC,IAAI,CAACrE,OAAO,CAACiE,SAAS,CAACJ,MAAM,CAACS,EAAE,CAAC,CAAC,EAAE;MAC9D;IACF;IAEAK,OAAO,CAACC,GAAG,CAACF,KAAK,CAAC;IAClBT,SAAS,CAACJ,MAAM,CAACS,EAAE,CAAC,CAACQ,UAAU,GAAG,IAAI;EACxC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACAnC,eAAe,CAACO,SAAS,CAAC6B,MAAM,GAAG,UAAUC,IAAI,EAAE;EACjD;EACA,IAAI,CAAChF,OAAO,CAACgF,IAAI,CAAC,EAAE;IAClB,MAAM,IAAI9E,cAAc,CAAC,mBAAmB,CAAC;EAC/C;EACA;;EAEA,MAAM+E,QAAQ,GAAG,IAAI,CAACxB,oBAAoB,CAACC,MAAM;EACjD,MAAMO,SAAS,GAAG,IAAI,CAACT,UAAU;EACjC,MAAMF,UAAU,GAAG,IAAI,CAACD,WAAW;EAEnC,KAAK,IAAI6B,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGF,QAAQ,CAACG,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;IACnD,MAAMrB,MAAM,GAAGoB,QAAQ,CAACC,CAAC,CAAC;IAC1B,MAAMG,aAAa,GAAGxB,MAAM,CAACyB,MAAM;IAEnC,IAAIxB,QAAQ;IACZ,IAAIyB,SAAS,GAAGtB,SAAS,CAACJ,MAAM,CAACS,EAAE,CAAC;IACpC,IAAIkB,IAAI,GACN3B,MAAM,CAAC4B,SAAS,IAChB5B,MAAM,CAAC6B,WAAW,CAACV,IAAI,CAAC,IACxBnE,QAAQ,CAAC8E,iBAAiB,CAACN,aAAa,CAACO,KAAK,EAAEZ,IAAI,EAAE,IAAI,CAAC;IAE7D,IAAIa,WAAW;IACf,IAAIL,IAAI,EAAE;MACRK,WAAW,GAAGhC,MAAM,CAACiC,kBAAkB,CAACd,IAAI,EAAE3C,kBAAkB,CAAC;MACjEyB,QAAQ,GAAGzD,QAAQ,CAAC0F,cAAc,CAChClF,QAAQ,CAACmF,mBAAmB,CAACX,aAAa,CAACY,IAAI,EAAEjB,IAAI,CACvD,CAAC;MACDQ,IAAI,GAAGxF,OAAO,CAAC6F,WAAW,CAAC,IAAI7F,OAAO,CAAC8D,QAAQ,CAAC;IAClD;IAEA,IAAI,CAAC0B,IAAI,EAAE;MACT,IAAIxF,OAAO,CAACuF,SAAS,CAAC,IAAIA,SAAS,CAACf,cAAc,EAAE;QAClDe,SAAS,CAACf,cAAc,CAACgB,IAAI,GAAG,KAAK;MACvC;MACA;IACF;IAEA,IAAI,CAACxF,OAAO,CAACuF,SAAS,CAAC,IAAIzB,QAAQ,CAACM,GAAG,KAAKmB,SAAS,CAACnB,GAAG,EAAE;MACzD,IAAIpE,OAAO,CAACuF,SAAS,EAAEf,cAAc,CAAC,EAAE;QACtClB,UAAU,CAAC4C,gBAAgB,CAACX,SAAS,CAACf,cAAc,CAAC;QACrD,OAAOP,SAAS,CAACJ,MAAM,CAACS,EAAE,CAAC;MAC7B;MAEAiB,SAAS,GAAG;QACVf,cAAc,EAAE2B,SAAS;QACzB/B,GAAG,EAAEN,QAAQ,CAACM,GAAG;QACjBgC,iBAAiB,EAAE,KAAK;QACxBC,0BAA0B,EAAE,CAAC,CAAC;QAC9BC,oBAAoB,EAAE,CAAC,CAAC;QACxBxB,UAAU,EAAE,KAAK;QACjByB,YAAY,EAAE,KAAK;QACnBC,4BAA4B,EAAE;UAC5B,GAAGvE;QACL;MACF,CAAC;MACDgC,SAAS,CAACJ,MAAM,CAACS,EAAE,CAAC,GAAGiB,SAAS;MAEhC,MAAMxB,yBAAyB,GAAGlD,QAAQ,CAAC8E,iBAAiB,CAC1DN,aAAa,CAACoB,0BAA0B,EACxCzB,IAAI,EACJ9D,gCACF,CAAC;MAED,MAAM8C,qBAAqB,GAAGnD,QAAQ,CAAC8E,iBAAiB,CACtDN,aAAa,CAACqB,sBAAsB,EACpC1B,IAAI,EACJ/C,4BAA4B,EAC5BsD,SAAS,CAACiB,4BACZ,CAAC;MAED7C,oBAAoB,CAClB,IAAI,EACJE,MAAM,EACNC,QAAQ,EACRC,yBAAyB,EACzBC,qBACF,CAAC;IACH;IAEA,MAAME,KAAK,GAAGqB,SAAS,CAACf,cAAc;IACtC,IAAI,CAACxE,OAAO,CAACkE,KAAK,CAAC,EAAE;MACnB;IACF;IAEAA,KAAK,CAACsB,IAAI,GAAG,IAAI;IACjBtB,KAAK,CAACyC,KAAK,GAAG9F,QAAQ,CAAC8E,iBAAiB,CACtCN,aAAa,CAACuB,MAAM,EACpB5B,IAAI,EACJjE,YACF,CAAC;IAEDmD,KAAK,CAAC2C,0BAA0B,GAAGhG,QAAQ,CAAC8E,iBAAiB,CAC3DN,aAAa,CAACyB,2BAA2B,EACzC9B,IAAI,EACJhE,iCACF,CAAC;IAEDkD,KAAK,CAAC6C,gBAAgB,GAAGlG,QAAQ,CAAC8E,iBAAiB,CACjDN,aAAa,CAAC2B,iBAAiB,EAC/BhC,IAAI,EACJ/D,uBACF,CAAC;IACDiD,KAAK,CAAC+C,YAAY,GAAGpG,QAAQ,CAACmF,mBAAmB,CAC/CX,aAAa,CAAC6B,aAAa,EAC3BlC,IACF,CAAC;IACDd,KAAK,CAAC2B,WAAW,GAAGzF,OAAO,CAAC+G,KAAK,CAACtB,WAAW,EAAE3B,KAAK,CAAC2B,WAAW,CAAC;IACjE3B,KAAK,CAACkD,OAAO,GAAGvG,QAAQ,CAAC8E,iBAAiB,CACxCN,aAAa,CAACgC,QAAQ,EACtBrC,IAAI,EACJ5D,cACF,CAAC;IACD8C,KAAK,CAACoD,eAAe,GAAGzG,QAAQ,CAAC8E,iBAAiB,CAChDN,aAAa,CAACkC,gBAAgB,EAC9BvC,IAAI,EACJ1D,sBACF,CAAC;IACD4C,KAAK,CAACsD,wBAAwB,GAAG3G,QAAQ,CAACmF,mBAAmB,CAC3DX,aAAa,CAACoC,yBAAyB,EACvCzC,IACF,CAAC;IACDd,KAAK,CAACwD,eAAe,GAAG7G,QAAQ,CAAC8E,iBAAiB,CAChDN,aAAa,CAACsC,gBAAgB,EAC9B3C,IAAI,EACJxD,sBAAsB,EACtBe,YACF,CAAC;IACD2B,KAAK,CAAC0D,cAAc,GAAG/G,QAAQ,CAAC8E,iBAAiB,CAC/CN,aAAa,CAACwC,eAAe,EAC7B7C,IAAI,EACJtD,qBACF,CAAC;IACDwC,KAAK,CAAC4D,KAAK,GAAGjH,QAAQ,CAAC8E,iBAAiB,CACtCN,aAAa,CAAC0C,MAAM,EACpB/C,IAAI,EACJrD,YAAY,EACZY,YACF,CAAC;IACD2B,KAAK,CAAC8D,cAAc,GAAGnH,QAAQ,CAAC8E,iBAAiB,CAC/CN,aAAa,CAAC4C,eAAe,EAC7BjD,IAAI,EACJnD,qBACF,CAAC;IACDqC,KAAK,CAACgE,gBAAgB,GAAGrH,QAAQ,CAAC8E,iBAAiB,CACjDN,aAAa,CAAC8C,iBAAiB,EAC/BnD,IAAI,EACJjD,uBACF,CAAC;IACDmC,KAAK,CAACkE,cAAc,GAAGvH,QAAQ,CAACmF,mBAAmB,CACjDX,aAAa,CAACgD,eAAe,EAC7BrD,IACF,CAAC;IACDd,KAAK,CAACoE,eAAe,GAAGzH,QAAQ,CAAC8E,iBAAiB,CAChDN,aAAa,CAACkD,gBAAgB,EAC9BvD,IAAI,EACJ7D,sBACF,CAAC;IACD+C,KAAK,CAACsE,kBAAkB,CAACC,wBAAwB,GAC/C5H,QAAQ,CAAC8E,iBAAiB,CACxBN,aAAa,CAACqD,yBAAyB,EACvC1D,IAAI,EACJhD,+BACF,CAAC;IACH,IAAI2G,UAAU,GAAG9H,QAAQ,CAACmF,mBAAmB,CAC3CX,aAAa,CAACuD,WAAW,EACzB5D,IACF,CAAC;;IAED;IACA,IAAIhF,OAAO,CAAC2I,UAAU,CAAC,EAAE;MACvB5I,KAAK,CAAC8I,IAAI,CAACF,UAAU,EAAEnG,YAAY,EAAE,CAAC,CAAC;MACvCmG,UAAU,GAAG9I,UAAU,CAACiJ,MAAM,CAACtG,YAAY,EAAE,CAAC,EAAEE,gBAAgB,CAAC;IACnE;IAEAwB,KAAK,CAACyE,UAAU,GAAGA,UAAU;IAC7BzE,KAAK,CAAC6E,YAAY,GAAGlI,QAAQ,CAACmF,mBAAmB,CAC/CX,aAAa,CAAC2D,aAAa,EAC3BhE,IACF,CAAC;;IAED;IACA;IACAf,SAAS,CAACJ,MAAM,CAACS,EAAE,CAAC,CAACiC,YAAY,GAAG,IAAI;IAExC,IAAIrC,KAAK,CAAC+E,KAAK,EAAE;MACf,MAAMC,aAAa,GAAGrI,QAAQ,CAAC8E,iBAAiB,CAC9CN,aAAa,CAAC8D,cAAc,EAC5BnE,IAAI,EACJ,IACF,CAAC;MACD,IAAIO,SAAS,CAACa,iBAAiB,KAAK8C,aAAa,EAAE;QACjD,IAAIA,aAAa,EAAE;UACjBhF,KAAK,CAACkF,gBAAgB,CAACC,MAAM,CAAC;YAC5BC,IAAI,EAAE5I,kBAAkB,CAAC6I;UAC3B,CAAC,CAAC;QACJ,CAAC,MAAM;UACLrF,KAAK,CAACkF,gBAAgB,CAACI,SAAS,CAAC,CAAC;QACpC;QACAjE,SAAS,CAACa,iBAAiB,GAAG8C,aAAa;MAC7C;;MAEA;MACA,MAAMO,mBAAmB,GAAG5I,QAAQ,CAACmF,mBAAmB,CACtDX,aAAa,CAACqE,oBAAoB,EAClC1E,IAAI,EACJO,SAAS,CAACc,0BACZ,CAAC;MACD,IAAIrG,OAAO,CAACyJ,mBAAmB,CAAC,EAAE;QAChC,MAAME,SAAS,GAAGC,MAAM,CAACC,IAAI,CAACJ,mBAAmB,CAAC;QAClD,KACE,IAAIK,SAAS,GAAG,CAAC,EAAEC,UAAU,GAAGJ,SAAS,CAACvE,MAAM,EAChD0E,SAAS,GAAGC,UAAU,EACtB,EAAED,SAAS,EACX;UACA,MAAME,QAAQ,GAAGL,SAAS,CAACG,SAAS,CAAC;UAErC,MAAMG,kBAAkB,GAAGR,mBAAmB,CAACO,QAAQ,CAAC;UACxD,IAAI,CAAChK,OAAO,CAACiK,kBAAkB,CAAC,EAAE;YAChC;UACF;UAEA,MAAMC,SAAS,GAAGhG,KAAK,CAACiG,OAAO,CAACH,QAAQ,CAAC;UACzC,IAAI,CAAChK,OAAO,CAACkK,SAAS,CAAC,EAAE;YACvB;UACF;UAEA,MAAME,oBAAoB,GAAGhK,OAAO,CAACiK,4BAA4B,CAC/DJ,kBAAkB,EAClB3H,iBACF,CAAC;UACD4H,SAAS,CAACI,MAAM,GAAGlK,OAAO,CAACmK,QAAQ,CACjCL,SAAS,CAACM,cAAc,EACxBJ,oBAAoB,EACpBA,oBACF,CAAC;QACH;MACF;;MAEA;MACA,IAAIK,sBAAsB,GAAG,KAAK;MAClC,MAAMC,aAAa,GAAG7J,QAAQ,CAACmF,mBAAmB,CAChDX,aAAa,CAACsF,cAAc,EAC5B3F,IAAI,EACJO,SAAS,CAACe,oBACZ,CAAC;MACD,IAAItG,OAAO,CAAC0K,aAAa,CAAC,EAAE;QAC1B,MAAME,qBAAqB,GAAGhB,MAAM,CAACC,IAAI,CAACa,aAAa,CAAC;QACxD,KACE,IAAIG,CAAC,GAAG,CAAC,EAAEC,OAAO,GAAGF,qBAAqB,CAACxF,MAAM,EACjDyF,CAAC,GAAGC,OAAO,EACX,EAAED,CAAC,EACH;UACA,MAAME,GAAG,GAAGH,qBAAqB,CAACC,CAAC,CAAC;UAEpC,MAAMG,sBAAsB,GAAGN,aAAa,CAACK,GAAG,CAAC;UACjD,IAAI,CAAC/K,OAAO,CAACgL,sBAAsB,CAAC,EAAE;YACpC;UACF;UAEAP,sBAAsB,GAAG,IAAI;UAC7BvG,KAAK,CAAC+G,oBAAoB,CAACF,GAAG,EAAEC,sBAAsB,CAAC;QACzD;MACF;MAEA,IAAIP,sBAAsB,EAAE;QAC1BvG,KAAK,CAACgH,kBAAkB,CAAC,CAAC;MAC5B;IACF;EACF;EAEA,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAvI,eAAe,CAACO,SAAS,CAACmB,WAAW,GAAG,YAAY;EAClD,OAAO,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA1B,eAAe,CAACO,SAAS,CAACiI,OAAO,GAAG,YAAY;EAC9C,IAAI,CAAC5H,iBAAiB,CAACP,iBAAiB,CAACoI,mBAAmB,CAC1DzI,eAAe,CAACO,SAAS,CAACC,oBAAoB,EAC9C,IACF,CAAC;EACD,MAAM8B,QAAQ,GAAG,IAAI,CAACxB,oBAAoB,CAACC,MAAM;EACjD,MAAMO,SAAS,GAAG,IAAI,CAACT,UAAU;EACjC,MAAMF,UAAU,GAAG,IAAI,CAACD,WAAW;EACnC,KAAK,IAAI6B,CAAC,GAAGD,QAAQ,CAACG,MAAM,GAAG,CAAC,EAAEF,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC7CmG,WAAW,CAAC,IAAI,EAAEpG,QAAQ,CAACC,CAAC,CAAC,EAAEjB,SAAS,EAAEX,UAAU,CAAC;EACvD;EACA,OAAOrD,aAAa,CAAC,IAAI,CAAC;AAC5B,CAAC;AAED,MAAMqL,eAAe,GAAG,IAAIzL,UAAU,CAAC,CAAC;AACxC,MAAM0L,mBAAmB,GAAG,IAAIzK,YAAY,CAAC,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA6B,eAAe,CAACO,SAAS,CAACsI,iBAAiB,GAAG,UAAU3H,MAAM,EAAE4H,MAAM,EAAE;EACtE;EACA,IAAI,CAACzL,OAAO,CAAC6D,MAAM,CAAC,EAAE;IACpB,MAAM,IAAI3D,cAAc,CAAC,qBAAqB,CAAC;EACjD;EACA,IAAI,CAACF,OAAO,CAACyL,MAAM,CAAC,EAAE;IACpB,MAAM,IAAIvL,cAAc,CAAC,qBAAqB,CAAC;EACjD;EACA;;EAEA,MAAMqF,SAAS,GAAG,IAAI,CAAC/B,UAAU,CAACK,MAAM,CAACS,EAAE,CAAC;EAC5C,IAAI,CAACtE,OAAO,CAACuF,SAAS,CAAC,EAAE;IACvB,OAAO3E,mBAAmB,CAAC8K,MAAM;EACnC;EAEA,IAAInG,SAAS,CAACT,UAAU,EAAE;IACxB,OAAOlE,mBAAmB,CAAC8K,MAAM;EACnC;EAEA,MAAMxH,KAAK,GAAGqB,SAAS,CAACf,cAAc;EACtC,IAAI,CAACxE,OAAO,CAACkE,KAAK,CAAC,IAAI,CAACA,KAAK,CAACsB,IAAI,EAAE;IAClC,OAAO5E,mBAAmB,CAAC+K,OAAO;EACpC;EAEA,IAAI,CAACzH,KAAK,CAAC+E,KAAK,IAAI,CAAC1D,SAAS,CAACgB,YAAY,EAAE;IAC3C,OAAO3F,mBAAmB,CAAC+K,OAAO;EACpC;EAEA,MAAM/I,KAAK,GAAG,IAAI,CAACQ,MAAM;EACzB,MAAMwI,SAAS,GAAGhJ,KAAK,CAACgJ,SAAS,IAAIzL,SAAS,CAAC0L,OAAO;EAEtD,MAAMC,kBAAkB,GAAG5H,KAAK,CAACoD,eAAe,KAAK/G,eAAe,CAACgB,IAAI;EACzE,IAAIuK,kBAAkB,EAAE;IACtB,MAAMjG,WAAW,GAAG3B,KAAK,CAAC2B,WAAW;IACrCyF,eAAe,CAACS,CAAC,GAAGlG,WAAW,CAAC,EAAE,CAAC;IACnCyF,eAAe,CAACU,CAAC,GAAGnG,WAAW,CAAC,EAAE,CAAC;IACnCyF,eAAe,CAACW,CAAC,GAAGpG,WAAW,CAAC,EAAE,CAAC;IACnC,MAAMqG,aAAa,GAAGN,SAAS,CAACO,uBAAuB,CACrDb,eAAe,EACfC,mBACF,CAAC;IAED,MAAMa,MAAM,GAAGxJ,KAAK,CAACyJ,SAAS,CAACH,aAAa,EAAEhI,KAAK,CAACoD,eAAe,CAAC;IACpE,IAAItH,OAAO,CAACoM,MAAM,CAAC,EAAE;MACnB,IAAI5L,sBAAsB,CAAC0D,KAAK,CAACoD,eAAe,CAAC,EAAE;QACjD4E,aAAa,CAACE,MAAM,GAAGA,MAAM;MAC/B,CAAC,MAAM;QACLF,aAAa,CAACE,MAAM,IAAIA,MAAM;MAChC;IACF;IAEAzM,cAAc,CAACwH,KAAK,CAACjD,KAAK,CAACoI,cAAc,EAAEb,MAAM,CAAC;IAClDA,MAAM,CAACc,MAAM,GAAGX,SAAS,CAACY,uBAAuB,CAACN,aAAa,CAAC;IAChE,OAAOtL,mBAAmB,CAAC6L,IAAI;EACjC;EAEA9M,cAAc,CAACwH,KAAK,CAACjD,KAAK,CAACoI,cAAc,EAAEb,MAAM,CAAC;EAClD,OAAO7K,mBAAmB,CAAC6L,IAAI;AACjC,CAAC;;AAED;AACA;AACA;AACA9J,eAAe,CAACO,SAAS,CAACC,oBAAoB,GAAG,UAC/CN,gBAAgB,EAChB6J,KAAK,EACLC,OAAO,EACPC,OAAO,EACP;EACA,IAAI1H,CAAC;EACL,IAAIrB,MAAM;EACV,MAAMoB,QAAQ,GAAG,IAAI,CAACxB,oBAAoB;EAC1C,MAAMQ,SAAS,GAAG,IAAI,CAACT,UAAU;EACjC,MAAMF,UAAU,GAAG,IAAI,CAACD,WAAW;EAEnC,KAAK6B,CAAC,GAAGwH,KAAK,CAACtH,MAAM,GAAG,CAAC,EAAEF,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,EAAE,EAAE;IACtCrB,MAAM,GAAG6I,KAAK,CAACxH,CAAC,CAAC;IACjB,IAAIlF,OAAO,CAAC6D,MAAM,CAACyB,MAAM,CAAC,IAAItF,OAAO,CAAC6D,MAAM,CAACgJ,SAAS,CAAC,EAAE;MACvD5H,QAAQ,CAAC6H,GAAG,CAACjJ,MAAM,CAACS,EAAE,EAAET,MAAM,CAAC;IACjC;EACF;EAEA,KAAKqB,CAAC,GAAG0H,OAAO,CAACxH,MAAM,GAAG,CAAC,EAAEF,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,EAAE,EAAE;IACxCrB,MAAM,GAAG+I,OAAO,CAAC1H,CAAC,CAAC;IACnB,IAAIlF,OAAO,CAAC6D,MAAM,CAACyB,MAAM,CAAC,IAAItF,OAAO,CAAC6D,MAAM,CAACgJ,SAAS,CAAC,EAAE;MACvDE,4CAA4C,CAAClJ,MAAM,EAAEI,SAAS,CAAC;MAC/DgB,QAAQ,CAAC6H,GAAG,CAACjJ,MAAM,CAACS,EAAE,EAAET,MAAM,CAAC;IACjC,CAAC,MAAM;MACLwH,WAAW,CAAC,IAAI,EAAExH,MAAM,EAAEI,SAAS,EAAEX,UAAU,CAAC;MAChD2B,QAAQ,CAAC+H,MAAM,CAACnJ,MAAM,CAACS,EAAE,CAAC;IAC5B;EACF;EAEA,KAAKY,CAAC,GAAGyH,OAAO,CAACvH,MAAM,GAAG,CAAC,EAAEF,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,EAAE,EAAE;IACxCrB,MAAM,GAAG8I,OAAO,CAACzH,CAAC,CAAC;IACnBmG,WAAW,CAAC,IAAI,EAAExH,MAAM,EAAEI,SAAS,EAAEX,UAAU,CAAC;IAChD2B,QAAQ,CAAC+H,MAAM,CAACnJ,MAAM,CAACS,EAAE,CAAC;EAC5B;AACF,CAAC;AAED,SAAS+G,WAAWA,CAACzH,UAAU,EAAEC,MAAM,EAAEI,SAAS,EAAEX,UAAU,EAAE;EAC9D,MAAMiC,SAAS,GAAGtB,SAAS,CAACJ,MAAM,CAACS,EAAE,CAAC;EACtC,IAAItE,OAAO,CAACuF,SAAS,CAAC,EAAE;IACtBjC,UAAU,CAAC4C,gBAAgB,CAACX,SAAS,CAACf,cAAc,CAAC;IACrD,OAAOP,SAAS,CAACJ,MAAM,CAACS,EAAE,CAAC;EAC7B;AACF;AAEA,SAASyI,4CAA4CA,CAAClJ,MAAM,EAAEI,SAAS,EAAE;EACvE,MAAMsB,SAAS,GAAGtB,SAAS,CAACJ,MAAM,CAACS,EAAE,CAAC;EACtC,IAAItE,OAAO,CAACuF,SAAS,CAAC,EAAE;IACtBA,SAAS,CAACc,0BAA0B,GAAG,CAAC,CAAC;IACzCd,SAAS,CAACe,oBAAoB,GAAG,CAAC,CAAC;EACrC;AACF;AAEA,eAAe3D,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}