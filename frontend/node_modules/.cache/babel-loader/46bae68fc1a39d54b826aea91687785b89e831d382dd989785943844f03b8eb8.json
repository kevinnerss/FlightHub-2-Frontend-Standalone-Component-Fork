{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\n\n/**\n * Geocodes queries containing longitude and latitude coordinates and an optional height.\n * Query format: `longitude latitude (height)` with longitude/latitude in degrees and height in meters.\n *\n * @alias CartographicGeocoderService\n * @constructor\n */\nfunction CartographicGeocoderService() {}\nObject.defineProperties(CartographicGeocoderService.prototype, {\n  /**\n   * Gets the credit to display after a geocode is performed. Typically this is used to credit\n   * the geocoder service.\n   * @memberof CartographicGeocoderService.prototype\n   * @type {Credit|undefined}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return undefined;\n    }\n  }\n});\n\n/**\n * @function\n *\n * @param {string} query The query to be sent to the geocoder service\n * @returns {Promise<GeocoderService.Result[]>}\n */\nCartographicGeocoderService.prototype.geocode = function (query) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"query\", query);\n  //>>includeEnd('debug');\n\n  const splitQuery = query.match(/[^\\s,\\n]+/g);\n  if (splitQuery.length === 2 || splitQuery.length === 3) {\n    let longitude = +splitQuery[0];\n    let latitude = +splitQuery[1];\n    const height = splitQuery.length === 3 ? +splitQuery[2] : 300.0;\n    if (isNaN(longitude) && isNaN(latitude)) {\n      const coordTest = /^(\\d+.?\\d*)([nsew])/i;\n      for (let i = 0; i < splitQuery.length; ++i) {\n        const splitCoord = splitQuery[i].match(coordTest);\n        if (coordTest.test(splitQuery[i]) && splitCoord.length === 3) {\n          if (/^[ns]/i.test(splitCoord[2])) {\n            latitude = /^[n]/i.test(splitCoord[2]) ? +splitCoord[1] : -splitCoord[1];\n          } else if (/^[ew]/i.test(splitCoord[2])) {\n            longitude = /^[e]/i.test(splitCoord[2]) ? +splitCoord[1] : -splitCoord[1];\n          }\n        }\n      }\n    }\n    if (!isNaN(longitude) && !isNaN(latitude) && !isNaN(height)) {\n      const result = {\n        displayName: query,\n        destination: Cartesian3.fromDegrees(longitude, latitude, height)\n      };\n      return Promise.resolve([result]);\n    }\n  }\n  return Promise.resolve([]);\n};\nexport default CartographicGeocoderService;","map":{"version":3,"names":["Cartesian3","Check","CartographicGeocoderService","Object","defineProperties","prototype","credit","get","undefined","geocode","query","typeOf","string","splitQuery","match","length","longitude","latitude","height","isNaN","coordTest","i","splitCoord","test","result","displayName","destination","fromDegrees","Promise","resolve"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/CartographicGeocoderService.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\n\n/**\n * Geocodes queries containing longitude and latitude coordinates and an optional height.\n * Query format: `longitude latitude (height)` with longitude/latitude in degrees and height in meters.\n *\n * @alias CartographicGeocoderService\n * @constructor\n */\nfunction CartographicGeocoderService() {}\n\nObject.defineProperties(CartographicGeocoderService.prototype, {\n  /**\n   * Gets the credit to display after a geocode is performed. Typically this is used to credit\n   * the geocoder service.\n   * @memberof CartographicGeocoderService.prototype\n   * @type {Credit|undefined}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return undefined;\n    },\n  },\n});\n\n/**\n * @function\n *\n * @param {string} query The query to be sent to the geocoder service\n * @returns {Promise<GeocoderService.Result[]>}\n */\nCartographicGeocoderService.prototype.geocode = function (query) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"query\", query);\n  //>>includeEnd('debug');\n\n  const splitQuery = query.match(/[^\\s,\\n]+/g);\n  if (splitQuery.length === 2 || splitQuery.length === 3) {\n    let longitude = +splitQuery[0];\n    let latitude = +splitQuery[1];\n    const height = splitQuery.length === 3 ? +splitQuery[2] : 300.0;\n\n    if (isNaN(longitude) && isNaN(latitude)) {\n      const coordTest = /^(\\d+.?\\d*)([nsew])/i;\n      for (let i = 0; i < splitQuery.length; ++i) {\n        const splitCoord = splitQuery[i].match(coordTest);\n        if (coordTest.test(splitQuery[i]) && splitCoord.length === 3) {\n          if (/^[ns]/i.test(splitCoord[2])) {\n            latitude = /^[n]/i.test(splitCoord[2])\n              ? +splitCoord[1]\n              : -splitCoord[1];\n          } else if (/^[ew]/i.test(splitCoord[2])) {\n            longitude = /^[e]/i.test(splitCoord[2])\n              ? +splitCoord[1]\n              : -splitCoord[1];\n          }\n        }\n      }\n    }\n\n    if (!isNaN(longitude) && !isNaN(latitude) && !isNaN(height)) {\n      const result = {\n        displayName: query,\n        destination: Cartesian3.fromDegrees(longitude, latitude, height),\n      };\n      return Promise.resolve([result]);\n    }\n  }\n  return Promise.resolve([]);\n};\nexport default CartographicGeocoderService;\n"],"mappings":"AAAA,OAAOA,UAAU,MAAM,iBAAiB;AACxC,OAAOC,KAAK,MAAM,YAAY;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,2BAA2BA,CAAA,EAAG,CAAC;AAExCC,MAAM,CAACC,gBAAgB,CAACF,2BAA2B,CAACG,SAAS,EAAE;EAC7D;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,MAAM,EAAE;IACNC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAOC,SAAS;IAClB;EACF;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACAN,2BAA2B,CAACG,SAAS,CAACI,OAAO,GAAG,UAAUC,KAAK,EAAE;EAC/D;EACAT,KAAK,CAACU,MAAM,CAACC,MAAM,CAAC,OAAO,EAAEF,KAAK,CAAC;EACnC;;EAEA,MAAMG,UAAU,GAAGH,KAAK,CAACI,KAAK,CAAC,YAAY,CAAC;EAC5C,IAAID,UAAU,CAACE,MAAM,KAAK,CAAC,IAAIF,UAAU,CAACE,MAAM,KAAK,CAAC,EAAE;IACtD,IAAIC,SAAS,GAAG,CAACH,UAAU,CAAC,CAAC,CAAC;IAC9B,IAAII,QAAQ,GAAG,CAACJ,UAAU,CAAC,CAAC,CAAC;IAC7B,MAAMK,MAAM,GAAGL,UAAU,CAACE,MAAM,KAAK,CAAC,GAAG,CAACF,UAAU,CAAC,CAAC,CAAC,GAAG,KAAK;IAE/D,IAAIM,KAAK,CAACH,SAAS,CAAC,IAAIG,KAAK,CAACF,QAAQ,CAAC,EAAE;MACvC,MAAMG,SAAS,GAAG,sBAAsB;MACxC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,UAAU,CAACE,MAAM,EAAE,EAAEM,CAAC,EAAE;QAC1C,MAAMC,UAAU,GAAGT,UAAU,CAACQ,CAAC,CAAC,CAACP,KAAK,CAACM,SAAS,CAAC;QACjD,IAAIA,SAAS,CAACG,IAAI,CAACV,UAAU,CAACQ,CAAC,CAAC,CAAC,IAAIC,UAAU,CAACP,MAAM,KAAK,CAAC,EAAE;UAC5D,IAAI,QAAQ,CAACQ,IAAI,CAACD,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;YAChCL,QAAQ,GAAG,OAAO,CAACM,IAAI,CAACD,UAAU,CAAC,CAAC,CAAC,CAAC,GAClC,CAACA,UAAU,CAAC,CAAC,CAAC,GACd,CAACA,UAAU,CAAC,CAAC,CAAC;UACpB,CAAC,MAAM,IAAI,QAAQ,CAACC,IAAI,CAACD,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;YACvCN,SAAS,GAAG,OAAO,CAACO,IAAI,CAACD,UAAU,CAAC,CAAC,CAAC,CAAC,GACnC,CAACA,UAAU,CAAC,CAAC,CAAC,GACd,CAACA,UAAU,CAAC,CAAC,CAAC;UACpB;QACF;MACF;IACF;IAEA,IAAI,CAACH,KAAK,CAACH,SAAS,CAAC,IAAI,CAACG,KAAK,CAACF,QAAQ,CAAC,IAAI,CAACE,KAAK,CAACD,MAAM,CAAC,EAAE;MAC3D,MAAMM,MAAM,GAAG;QACbC,WAAW,EAAEf,KAAK;QAClBgB,WAAW,EAAE1B,UAAU,CAAC2B,WAAW,CAACX,SAAS,EAAEC,QAAQ,EAAEC,MAAM;MACjE,CAAC;MACD,OAAOU,OAAO,CAACC,OAAO,CAAC,CAACL,MAAM,CAAC,CAAC;IAClC;EACF;EACA,OAAOI,OAAO,CAACC,OAAO,CAAC,EAAE,CAAC;AAC5B,CAAC;AACD,eAAe3B,2BAA2B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}