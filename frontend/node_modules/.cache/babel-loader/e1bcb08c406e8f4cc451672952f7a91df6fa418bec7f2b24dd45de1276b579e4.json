{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nconst factorial = CesiumMath.factorial;\nfunction calculateCoefficientTerm(x, zIndices, xTable, derivOrder, termOrder, reservedIndices) {\n  let result = 0;\n  let reserved;\n  let i;\n  let j;\n  if (derivOrder > 0) {\n    for (i = 0; i < termOrder; i++) {\n      reserved = false;\n      for (j = 0; j < reservedIndices.length && !reserved; j++) {\n        if (i === reservedIndices[j]) {\n          reserved = true;\n        }\n      }\n      if (!reserved) {\n        reservedIndices.push(i);\n        result += calculateCoefficientTerm(x, zIndices, xTable, derivOrder - 1, termOrder, reservedIndices);\n        reservedIndices.splice(reservedIndices.length - 1, 1);\n      }\n    }\n    return result;\n  }\n  result = 1;\n  for (i = 0; i < termOrder; i++) {\n    reserved = false;\n    for (j = 0; j < reservedIndices.length && !reserved; j++) {\n      if (i === reservedIndices[j]) {\n        reserved = true;\n      }\n    }\n    if (!reserved) {\n      result *= x - xTable[zIndices[i]];\n    }\n  }\n  return result;\n}\n\n/**\n * An {@link InterpolationAlgorithm} for performing Hermite interpolation.\n *\n * @namespace HermitePolynomialApproximation\n */\nconst HermitePolynomialApproximation = {\n  type: \"Hermite\"\n};\n\n/**\n * Given the desired degree, returns the number of data points required for interpolation.\n *\n * @param {number} degree The desired degree of interpolation.\n * @param {number} [inputOrder=0]  The order of the inputs (0 means just the data, 1 means the data and its derivative, etc).\n * @returns {number} The number of required data points needed for the desired degree of interpolation.\n * @exception {DeveloperError} degree must be 0 or greater.\n * @exception {DeveloperError} inputOrder must be 0 or greater.\n */\nHermitePolynomialApproximation.getRequiredDataPoints = function (degree, inputOrder) {\n  inputOrder = inputOrder ?? 0;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(degree)) {\n    throw new DeveloperError(\"degree is required.\");\n  }\n  if (degree < 0) {\n    throw new DeveloperError(\"degree must be 0 or greater.\");\n  }\n  if (inputOrder < 0) {\n    throw new DeveloperError(\"inputOrder must be 0 or greater.\");\n  }\n  //>>includeEnd('debug');\n\n  return Math.max(Math.floor((degree + 1) / (inputOrder + 1)), 2);\n};\n\n/**\n * Interpolates values using Hermite Polynomial Approximation.\n *\n * @param {number} x The independent variable for which the dependent variables will be interpolated.\n * @param {number[]} xTable The array of independent variables to use to interpolate.  The values\n * in this array must be in increasing order and the same value must not occur twice in the array.\n * @param {number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n * @param {number} yStride The number of dependent variable values in yTable corresponding to\n * each independent variable value in xTable.\n * @param {number[]} [result] An existing array into which to store the result.\n * @returns {number[]} The array of interpolated values, or the result parameter if one was provided.\n */\nHermitePolynomialApproximation.interpolateOrderZero = function (x, xTable, yTable, yStride, result) {\n  if (!defined(result)) {\n    result = new Array(yStride);\n  }\n  let i;\n  let j;\n  let d;\n  let s;\n  let len;\n  let index;\n  const length = xTable.length;\n  const coefficients = new Array(yStride);\n  for (i = 0; i < yStride; i++) {\n    result[i] = 0;\n    const l = new Array(length);\n    coefficients[i] = l;\n    for (j = 0; j < length; j++) {\n      l[j] = [];\n    }\n  }\n  const zIndicesLength = length,\n    zIndices = new Array(zIndicesLength);\n  for (i = 0; i < zIndicesLength; i++) {\n    zIndices[i] = i;\n  }\n  let highestNonZeroCoef = length - 1;\n  for (s = 0; s < yStride; s++) {\n    for (j = 0; j < zIndicesLength; j++) {\n      index = zIndices[j] * yStride + s;\n      coefficients[s][0].push(yTable[index]);\n    }\n    for (i = 1; i < zIndicesLength; i++) {\n      let nonZeroCoefficients = false;\n      for (j = 0; j < zIndicesLength - i; j++) {\n        const zj = xTable[zIndices[j]];\n        const zn = xTable[zIndices[j + i]];\n        let numerator;\n        if (zn - zj <= 0) {\n          index = zIndices[j] * yStride + yStride * i + s;\n          numerator = yTable[index];\n          coefficients[s][i].push(numerator / factorial(i));\n        } else {\n          numerator = coefficients[s][i - 1][j + 1] - coefficients[s][i - 1][j];\n          coefficients[s][i].push(numerator / (zn - zj));\n        }\n        nonZeroCoefficients = nonZeroCoefficients || numerator !== 0;\n      }\n      if (!nonZeroCoefficients) {\n        highestNonZeroCoef = i - 1;\n      }\n    }\n  }\n  for (d = 0, len = 0; d <= len; d++) {\n    for (i = d; i <= highestNonZeroCoef; i++) {\n      const tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, []);\n      for (s = 0; s < yStride; s++) {\n        const coeff = coefficients[s][i][0];\n        result[s + d * yStride] += coeff * tempTerm;\n      }\n    }\n  }\n  return result;\n};\nconst arrayScratch = [];\n\n/**\n * Interpolates values using Hermite Polynomial Approximation.\n *\n * @param {number} x The independent variable for which the dependent variables will be interpolated.\n * @param {number[]} xTable The array of independent variables to use to interpolate.  The values\n * in this array must be in increasing order and the same value must not occur twice in the array.\n * @param {number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n * @param {number} yStride The number of dependent variable values in yTable corresponding to\n * each independent variable value in xTable.\n * @param {number} inputOrder The number of derivatives supplied for input.\n * @param {number} outputOrder The number of derivatives desired for output.\n * @param {number[]} [result] An existing array into which to store the result.\n *\n * @returns {number[]} The array of interpolated values, or the result parameter if one was provided.\n */\nHermitePolynomialApproximation.interpolate = function (x, xTable, yTable, yStride, inputOrder, outputOrder, result) {\n  const resultLength = yStride * (outputOrder + 1);\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  }\n  for (let r = 0; r < resultLength; r++) {\n    result[r] = 0;\n  }\n  const length = xTable.length;\n  // The zIndices array holds copies of the addresses of the xTable values\n  // in the range we're looking at. Even though this just holds information already\n  // available in xTable this is a much more convenient format.\n  const zIndices = new Array(length * (inputOrder + 1));\n  let i;\n  for (i = 0; i < length; i++) {\n    for (let j = 0; j < inputOrder + 1; j++) {\n      zIndices[i * (inputOrder + 1) + j] = i;\n    }\n  }\n  const zIndiceslength = zIndices.length;\n  const coefficients = arrayScratch;\n  const highestNonZeroCoef = fillCoefficientList(coefficients, zIndices, xTable, yTable, yStride, inputOrder);\n  const reservedIndices = [];\n  const tmp = zIndiceslength * (zIndiceslength + 1) / 2;\n  const loopStop = Math.min(highestNonZeroCoef, outputOrder);\n  for (let d = 0; d <= loopStop; d++) {\n    for (i = d; i <= highestNonZeroCoef; i++) {\n      reservedIndices.length = 0;\n      const tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, reservedIndices);\n      const dimTwo = Math.floor(i * (1 - i) / 2) + zIndiceslength * i;\n      for (let s = 0; s < yStride; s++) {\n        const dimOne = Math.floor(s * tmp);\n        const coef = coefficients[dimOne + dimTwo];\n        result[s + d * yStride] += coef * tempTerm;\n      }\n    }\n  }\n  return result;\n};\nfunction fillCoefficientList(coefficients, zIndices, xTable, yTable, yStride, inputOrder) {\n  let j;\n  let index;\n  let highestNonZero = -1;\n  const zIndiceslength = zIndices.length;\n  const tmp = zIndiceslength * (zIndiceslength + 1) / 2;\n  for (let s = 0; s < yStride; s++) {\n    const dimOne = Math.floor(s * tmp);\n    for (j = 0; j < zIndiceslength; j++) {\n      index = zIndices[j] * yStride * (inputOrder + 1) + s;\n      coefficients[dimOne + j] = yTable[index];\n    }\n    for (let i = 1; i < zIndiceslength; i++) {\n      let coefIndex = 0;\n      const dimTwo = Math.floor(i * (1 - i) / 2) + zIndiceslength * i;\n      let nonZeroCoefficients = false;\n      for (j = 0; j < zIndiceslength - i; j++) {\n        const zj = xTable[zIndices[j]];\n        const zn = xTable[zIndices[j + i]];\n        let numerator;\n        let coefficient;\n        if (zn - zj <= 0) {\n          index = zIndices[j] * yStride * (inputOrder + 1) + yStride * i + s;\n          numerator = yTable[index];\n          coefficient = numerator / CesiumMath.factorial(i);\n          coefficients[dimOne + dimTwo + coefIndex] = coefficient;\n          coefIndex++;\n        } else {\n          const dimTwoMinusOne = Math.floor((i - 1) * (2 - i) / 2) + zIndiceslength * (i - 1);\n          numerator = coefficients[dimOne + dimTwoMinusOne + j + 1] - coefficients[dimOne + dimTwoMinusOne + j];\n          coefficient = numerator / (zn - zj);\n          coefficients[dimOne + dimTwo + coefIndex] = coefficient;\n          coefIndex++;\n        }\n        nonZeroCoefficients = nonZeroCoefficients || numerator !== 0.0;\n      }\n      if (nonZeroCoefficients) {\n        highestNonZero = Math.max(highestNonZero, i);\n      }\n    }\n  }\n  return highestNonZero;\n}\nexport default HermitePolynomialApproximation;","map":{"version":3,"names":["defined","DeveloperError","CesiumMath","factorial","calculateCoefficientTerm","x","zIndices","xTable","derivOrder","termOrder","reservedIndices","result","reserved","i","j","length","push","splice","HermitePolynomialApproximation","type","getRequiredDataPoints","degree","inputOrder","Math","max","floor","interpolateOrderZero","yTable","yStride","Array","d","s","len","index","coefficients","l","zIndicesLength","highestNonZeroCoef","nonZeroCoefficients","zj","zn","numerator","tempTerm","coeff","arrayScratch","interpolate","outputOrder","resultLength","r","zIndiceslength","fillCoefficientList","tmp","loopStop","min","dimTwo","dimOne","coef","highestNonZero","coefIndex","coefficient","dimTwoMinusOne"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/HermitePolynomialApproximation.js"],"sourcesContent":["import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\nconst factorial = CesiumMath.factorial;\n\nfunction calculateCoefficientTerm(\n  x,\n  zIndices,\n  xTable,\n  derivOrder,\n  termOrder,\n  reservedIndices,\n) {\n  let result = 0;\n  let reserved;\n  let i;\n  let j;\n\n  if (derivOrder > 0) {\n    for (i = 0; i < termOrder; i++) {\n      reserved = false;\n      for (j = 0; j < reservedIndices.length && !reserved; j++) {\n        if (i === reservedIndices[j]) {\n          reserved = true;\n        }\n      }\n\n      if (!reserved) {\n        reservedIndices.push(i);\n        result += calculateCoefficientTerm(\n          x,\n          zIndices,\n          xTable,\n          derivOrder - 1,\n          termOrder,\n          reservedIndices,\n        );\n        reservedIndices.splice(reservedIndices.length - 1, 1);\n      }\n    }\n\n    return result;\n  }\n\n  result = 1;\n  for (i = 0; i < termOrder; i++) {\n    reserved = false;\n    for (j = 0; j < reservedIndices.length && !reserved; j++) {\n      if (i === reservedIndices[j]) {\n        reserved = true;\n      }\n    }\n\n    if (!reserved) {\n      result *= x - xTable[zIndices[i]];\n    }\n  }\n\n  return result;\n}\n\n/**\n * An {@link InterpolationAlgorithm} for performing Hermite interpolation.\n *\n * @namespace HermitePolynomialApproximation\n */\nconst HermitePolynomialApproximation = {\n  type: \"Hermite\",\n};\n\n/**\n * Given the desired degree, returns the number of data points required for interpolation.\n *\n * @param {number} degree The desired degree of interpolation.\n * @param {number} [inputOrder=0]  The order of the inputs (0 means just the data, 1 means the data and its derivative, etc).\n * @returns {number} The number of required data points needed for the desired degree of interpolation.\n * @exception {DeveloperError} degree must be 0 or greater.\n * @exception {DeveloperError} inputOrder must be 0 or greater.\n */\nHermitePolynomialApproximation.getRequiredDataPoints = function (\n  degree,\n  inputOrder,\n) {\n  inputOrder = inputOrder ?? 0;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(degree)) {\n    throw new DeveloperError(\"degree is required.\");\n  }\n  if (degree < 0) {\n    throw new DeveloperError(\"degree must be 0 or greater.\");\n  }\n  if (inputOrder < 0) {\n    throw new DeveloperError(\"inputOrder must be 0 or greater.\");\n  }\n  //>>includeEnd('debug');\n\n  return Math.max(Math.floor((degree + 1) / (inputOrder + 1)), 2);\n};\n\n/**\n * Interpolates values using Hermite Polynomial Approximation.\n *\n * @param {number} x The independent variable for which the dependent variables will be interpolated.\n * @param {number[]} xTable The array of independent variables to use to interpolate.  The values\n * in this array must be in increasing order and the same value must not occur twice in the array.\n * @param {number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n * @param {number} yStride The number of dependent variable values in yTable corresponding to\n * each independent variable value in xTable.\n * @param {number[]} [result] An existing array into which to store the result.\n * @returns {number[]} The array of interpolated values, or the result parameter if one was provided.\n */\nHermitePolynomialApproximation.interpolateOrderZero = function (\n  x,\n  xTable,\n  yTable,\n  yStride,\n  result,\n) {\n  if (!defined(result)) {\n    result = new Array(yStride);\n  }\n\n  let i;\n  let j;\n  let d;\n  let s;\n  let len;\n  let index;\n  const length = xTable.length;\n  const coefficients = new Array(yStride);\n\n  for (i = 0; i < yStride; i++) {\n    result[i] = 0;\n\n    const l = new Array(length);\n    coefficients[i] = l;\n    for (j = 0; j < length; j++) {\n      l[j] = [];\n    }\n  }\n\n  const zIndicesLength = length,\n    zIndices = new Array(zIndicesLength);\n\n  for (i = 0; i < zIndicesLength; i++) {\n    zIndices[i] = i;\n  }\n\n  let highestNonZeroCoef = length - 1;\n  for (s = 0; s < yStride; s++) {\n    for (j = 0; j < zIndicesLength; j++) {\n      index = zIndices[j] * yStride + s;\n      coefficients[s][0].push(yTable[index]);\n    }\n\n    for (i = 1; i < zIndicesLength; i++) {\n      let nonZeroCoefficients = false;\n      for (j = 0; j < zIndicesLength - i; j++) {\n        const zj = xTable[zIndices[j]];\n        const zn = xTable[zIndices[j + i]];\n\n        let numerator;\n        if (zn - zj <= 0) {\n          index = zIndices[j] * yStride + yStride * i + s;\n          numerator = yTable[index];\n          coefficients[s][i].push(numerator / factorial(i));\n        } else {\n          numerator = coefficients[s][i - 1][j + 1] - coefficients[s][i - 1][j];\n          coefficients[s][i].push(numerator / (zn - zj));\n        }\n        nonZeroCoefficients = nonZeroCoefficients || numerator !== 0;\n      }\n\n      if (!nonZeroCoefficients) {\n        highestNonZeroCoef = i - 1;\n      }\n    }\n  }\n\n  for (d = 0, len = 0; d <= len; d++) {\n    for (i = d; i <= highestNonZeroCoef; i++) {\n      const tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, []);\n      for (s = 0; s < yStride; s++) {\n        const coeff = coefficients[s][i][0];\n        result[s + d * yStride] += coeff * tempTerm;\n      }\n    }\n  }\n\n  return result;\n};\n\nconst arrayScratch = [];\n\n/**\n * Interpolates values using Hermite Polynomial Approximation.\n *\n * @param {number} x The independent variable for which the dependent variables will be interpolated.\n * @param {number[]} xTable The array of independent variables to use to interpolate.  The values\n * in this array must be in increasing order and the same value must not occur twice in the array.\n * @param {number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n * @param {number} yStride The number of dependent variable values in yTable corresponding to\n * each independent variable value in xTable.\n * @param {number} inputOrder The number of derivatives supplied for input.\n * @param {number} outputOrder The number of derivatives desired for output.\n * @param {number[]} [result] An existing array into which to store the result.\n *\n * @returns {number[]} The array of interpolated values, or the result parameter if one was provided.\n */\nHermitePolynomialApproximation.interpolate = function (\n  x,\n  xTable,\n  yTable,\n  yStride,\n  inputOrder,\n  outputOrder,\n  result,\n) {\n  const resultLength = yStride * (outputOrder + 1);\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  }\n  for (let r = 0; r < resultLength; r++) {\n    result[r] = 0;\n  }\n\n  const length = xTable.length;\n  // The zIndices array holds copies of the addresses of the xTable values\n  // in the range we're looking at. Even though this just holds information already\n  // available in xTable this is a much more convenient format.\n  const zIndices = new Array(length * (inputOrder + 1));\n  let i;\n  for (i = 0; i < length; i++) {\n    for (let j = 0; j < inputOrder + 1; j++) {\n      zIndices[i * (inputOrder + 1) + j] = i;\n    }\n  }\n\n  const zIndiceslength = zIndices.length;\n  const coefficients = arrayScratch;\n  const highestNonZeroCoef = fillCoefficientList(\n    coefficients,\n    zIndices,\n    xTable,\n    yTable,\n    yStride,\n    inputOrder,\n  );\n  const reservedIndices = [];\n\n  const tmp = (zIndiceslength * (zIndiceslength + 1)) / 2;\n  const loopStop = Math.min(highestNonZeroCoef, outputOrder);\n  for (let d = 0; d <= loopStop; d++) {\n    for (i = d; i <= highestNonZeroCoef; i++) {\n      reservedIndices.length = 0;\n      const tempTerm = calculateCoefficientTerm(\n        x,\n        zIndices,\n        xTable,\n        d,\n        i,\n        reservedIndices,\n      );\n      const dimTwo = Math.floor((i * (1 - i)) / 2) + zIndiceslength * i;\n\n      for (let s = 0; s < yStride; s++) {\n        const dimOne = Math.floor(s * tmp);\n        const coef = coefficients[dimOne + dimTwo];\n        result[s + d * yStride] += coef * tempTerm;\n      }\n    }\n  }\n\n  return result;\n};\n\nfunction fillCoefficientList(\n  coefficients,\n  zIndices,\n  xTable,\n  yTable,\n  yStride,\n  inputOrder,\n) {\n  let j;\n  let index;\n  let highestNonZero = -1;\n  const zIndiceslength = zIndices.length;\n  const tmp = (zIndiceslength * (zIndiceslength + 1)) / 2;\n\n  for (let s = 0; s < yStride; s++) {\n    const dimOne = Math.floor(s * tmp);\n\n    for (j = 0; j < zIndiceslength; j++) {\n      index = zIndices[j] * yStride * (inputOrder + 1) + s;\n      coefficients[dimOne + j] = yTable[index];\n    }\n\n    for (let i = 1; i < zIndiceslength; i++) {\n      let coefIndex = 0;\n      const dimTwo = Math.floor((i * (1 - i)) / 2) + zIndiceslength * i;\n      let nonZeroCoefficients = false;\n\n      for (j = 0; j < zIndiceslength - i; j++) {\n        const zj = xTable[zIndices[j]];\n        const zn = xTable[zIndices[j + i]];\n\n        let numerator;\n        let coefficient;\n        if (zn - zj <= 0) {\n          index = zIndices[j] * yStride * (inputOrder + 1) + yStride * i + s;\n          numerator = yTable[index];\n          coefficient = numerator / CesiumMath.factorial(i);\n          coefficients[dimOne + dimTwo + coefIndex] = coefficient;\n          coefIndex++;\n        } else {\n          const dimTwoMinusOne =\n            Math.floor(((i - 1) * (2 - i)) / 2) + zIndiceslength * (i - 1);\n          numerator =\n            coefficients[dimOne + dimTwoMinusOne + j + 1] -\n            coefficients[dimOne + dimTwoMinusOne + j];\n          coefficient = numerator / (zn - zj);\n          coefficients[dimOne + dimTwo + coefIndex] = coefficient;\n          coefIndex++;\n        }\n        nonZeroCoefficients = nonZeroCoefficients || numerator !== 0.0;\n      }\n\n      if (nonZeroCoefficients) {\n        highestNonZero = Math.max(highestNonZero, i);\n      }\n    }\n  }\n\n  return highestNonZero;\n}\nexport default HermitePolynomialApproximation;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}