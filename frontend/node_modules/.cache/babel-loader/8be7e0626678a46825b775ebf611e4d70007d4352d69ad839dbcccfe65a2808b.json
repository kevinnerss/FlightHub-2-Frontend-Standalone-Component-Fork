{"ast":null,"code":"import binarySearch from \"../Core/binarySearch.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport KeyframeNode from \"./KeyframeNode.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\n\n/**\n * @alias SpatialNode\n * @constructor\n *\n * @param {number} level\n * @param {number} x\n * @param {number} y\n * @param {number} z\n * @param {SpatialNode} parent\n * @param {VoxelShape} shape\n * @param {Cartesian3} voxelDimensions\n *\n * @private\n */\nfunction SpatialNode(level, x, y, z, parent, shape, voxelDimensions) {\n  /**\n   * @type {SpatialNode[]}\n   */\n  this.children = undefined;\n  this.parent = parent;\n  this.level = level;\n  this.x = x;\n  this.y = y;\n  this.z = z;\n\n  /**\n   * @type {Cartesian3}\n   */\n  this.dimensions = Cartesian3.clone(voxelDimensions);\n  /**\n   * @type {KeyframeNode[]}\n   */\n  this.keyframeNodes = [];\n  /**\n   * @type {KeyframeNode[]}\n   */\n  this.renderableKeyframeNodes = [];\n  this.renderableKeyframeNodeLerp = 0.0;\n  /**\n   * @type {KeyframeNode}\n   */\n  this.renderableKeyframeNodePrevious = undefined;\n  /**\n   * @type {KeyframeNode}\n   */\n  this.renderableKeyframeNodeNext = undefined;\n  this.orientedBoundingBox = new OrientedBoundingBox();\n  this.approximateVoxelSize = 0.0;\n  this.screenSpaceError = 0.0;\n  this.visitedFrameNumber = -1;\n  this.computeBoundingVolumes(shape);\n}\nconst scratchObbHalfScale = new Cartesian3();\n\n/**\n * @param {VoxelShape} shape\n */\nSpatialNode.prototype.computeBoundingVolumes = function (shape) {\n  this.orientedBoundingBox = shape.computeOrientedBoundingBoxForTile(this.level, this.x, this.y, this.z, this.orientedBoundingBox);\n  const halfScale = Matrix3.getScale(this.orientedBoundingBox.halfAxes, scratchObbHalfScale);\n  const maximumScale = 2.0 * Cartesian3.maximumComponent(halfScale);\n  this.approximateVoxelSize = maximumScale / Cartesian3.minimumComponent(this.dimensions);\n};\n\n/**\n * @param {VoxelShape} shape The shape of the parent VoxelPrimitive\n * @private\n */\nSpatialNode.prototype.constructChildNodes = function (shape) {\n  const {\n    level,\n    x,\n    y,\n    z\n  } = this;\n  const xMin = x * 2;\n  const yMin = y * 2;\n  const zMin = z * 2;\n  const yMax = yMin + 1;\n  const xMax = xMin + 1;\n  const zMax = zMin + 1;\n  const childLevel = level + 1;\n  const childCoords = [[childLevel, xMin, yMin, zMin], [childLevel, xMax, yMin, zMin], [childLevel, xMin, yMax, zMin], [childLevel, xMax, yMax, zMin], [childLevel, xMin, yMin, zMax], [childLevel, xMax, yMin, zMax], [childLevel, xMin, yMax, zMax], [childLevel, xMax, yMax, zMax]];\n  this.children = childCoords.map(([level, x, y, z]) => {\n    return new SpatialNode(level, x, y, z, this, shape, this.dimensions);\n  });\n};\n\n/**\n * @param {FrameState} frameState\n * @param {number} visibilityPlaneMask\n * @returns {number} A plane mask as described in {@link CullingVolume#computeVisibilityWithPlaneMask}.\n */\nSpatialNode.prototype.visibility = function (frameState, visibilityPlaneMask) {\n  const obb = this.orientedBoundingBox;\n  const cullingVolume = frameState.cullingVolume;\n  return cullingVolume.computeVisibilityWithPlaneMask(obb, visibilityPlaneMask);\n};\n\n/**\n * @param {Cartesian3} cameraPosition\n * @param {number} screenSpaceErrorMultiplier\n */\nSpatialNode.prototype.computeScreenSpaceError = function (cameraPosition, screenSpaceErrorMultiplier) {\n  const obb = this.orientedBoundingBox;\n  let distance = Math.sqrt(obb.distanceSquaredTo(cameraPosition));\n  // Avoid divide-by-zero when viewer is inside the tile.\n  distance = Math.max(distance, CesiumMath.EPSILON7);\n  const approximateVoxelSize = this.approximateVoxelSize;\n  const error = screenSpaceErrorMultiplier * (approximateVoxelSize / distance);\n  this.screenSpaceError = error;\n};\n\n// This object imitates a KeyframeNode. Only used for binary search function.\nconst scratchBinarySearchKeyframeNode = {\n  keyframe: 0\n};\n\n/**\n * Find the index of a given key frame position within an array of KeyframeNodes,\n * or the complement (~) of the index where it would be in the sorted array.\n * @param {number} keyframe\n * @param {KeyframeNode[]} keyframeNodes\n * @returns {number}\n * @private\n */\nfunction findKeyframeIndex(keyframe, keyframeNodes) {\n  scratchBinarySearchKeyframeNode.keyframe = keyframe;\n  return binarySearch(keyframeNodes, scratchBinarySearchKeyframeNode, KeyframeNode.searchComparator);\n}\n\n/**\n * Computes the most suitable keyframes for rendering, balancing between temporal and visual quality.\n *\n * @param {number} keyframeLocation\n */\nSpatialNode.prototype.computeSurroundingRenderableKeyframeNodes = function (keyframeLocation) {\n  let spatialNode = this;\n  const startLevel = spatialNode.level;\n  const targetKeyframePrev = Math.floor(keyframeLocation);\n  const targetKeyframeNext = Math.ceil(keyframeLocation);\n  let bestKeyframeNodePrev;\n  let bestKeyframeNodeNext;\n  let minimumDistancePrev = +Number.MAX_VALUE;\n  let minimumDistanceNext = +Number.MAX_VALUE;\n  while (defined(spatialNode)) {\n    const {\n      renderableKeyframeNodes\n    } = spatialNode;\n    if (renderableKeyframeNodes.length >= 1) {\n      const indexPrev = getKeyframeIndexPrev(targetKeyframePrev, renderableKeyframeNodes);\n      const keyframeNodePrev = renderableKeyframeNodes[indexPrev];\n      const indexNext = targetKeyframeNext === targetKeyframePrev || targetKeyframePrev < keyframeNodePrev.keyframe ? indexPrev : Math.min(indexPrev + 1, renderableKeyframeNodes.length - 1);\n      const keyframeNodeNext = renderableKeyframeNodes[indexNext];\n      const distancePrev = targetKeyframePrev - keyframeNodePrev.keyframe;\n      const weightedDistancePrev = getWeightedKeyframeDistance(startLevel - spatialNode.level, distancePrev);\n      if (weightedDistancePrev < minimumDistancePrev) {\n        minimumDistancePrev = weightedDistancePrev;\n        bestKeyframeNodePrev = keyframeNodePrev;\n      }\n      const distanceNext = keyframeNodeNext.keyframe - targetKeyframeNext;\n      const weightedDistanceNext = getWeightedKeyframeDistance(startLevel - spatialNode.level, distanceNext);\n      if (weightedDistanceNext < minimumDistanceNext) {\n        minimumDistanceNext = weightedDistanceNext;\n        bestKeyframeNodeNext = keyframeNodeNext;\n      }\n      if (distancePrev === 0 && distanceNext === 0) {\n        // Nothing higher up will be better, so break early.\n        break;\n      }\n    }\n    spatialNode = spatialNode.parent;\n  }\n  this.renderableKeyframeNodePrevious = bestKeyframeNodePrev;\n  this.renderableKeyframeNodeNext = bestKeyframeNodeNext;\n  if (!defined(bestKeyframeNodePrev) || !defined(bestKeyframeNodeNext)) {\n    return;\n  }\n  const bestKeyframePrev = bestKeyframeNodePrev.keyframe;\n  const bestKeyframeNext = bestKeyframeNodeNext.keyframe;\n  this.renderableKeyframeNodeLerp = bestKeyframePrev === bestKeyframeNext ? 0.0 : CesiumMath.clamp((keyframeLocation - bestKeyframePrev) / (bestKeyframeNext - bestKeyframePrev), 0.0, 1.0);\n};\nfunction getKeyframeIndexPrev(targetKeyframe, keyframeNodes) {\n  const keyframeIndex = findKeyframeIndex(targetKeyframe, keyframeNodes);\n  return keyframeIndex < 0 ? CesiumMath.clamp(~keyframeIndex - 1, 0, keyframeNodes.length - 1) : keyframeIndex;\n}\nfunction getWeightedKeyframeDistance(levelDistance, keyframeDistance) {\n  // Balance quality between visual (levelDistance) and temporal (keyframeDistance)\n  const levelWeight = Math.exp(levelDistance * 4.0);\n  // Keyframes on the opposite of the desired direction are deprioritized.\n  const keyframeWeight = keyframeDistance >= 0 ? 1.0 : -200.0;\n  return levelDistance * levelWeight + keyframeDistance * keyframeWeight;\n}\n\n/**\n * @param {number} frameNumber\n * @returns {boolean}\n */\nSpatialNode.prototype.isVisited = function (frameNumber) {\n  return this.visitedFrameNumber === frameNumber;\n};\n\n/**\n * @param {number} keyframe\n */\nSpatialNode.prototype.createKeyframeNode = function (keyframe) {\n  let index = findKeyframeIndex(keyframe, this.keyframeNodes);\n  if (index < 0) {\n    index = ~index; // convert to insertion index\n    const keyframeNode = new KeyframeNode(this, keyframe);\n    this.keyframeNodes.splice(index, 0, keyframeNode);\n  }\n};\n\n/**\n * @param {KeyframeNode} keyframeNode\n * @param {Megatexture[]} megatextures\n */\nSpatialNode.prototype.destroyKeyframeNode = function (keyframeNode, megatextures) {\n  const keyframe = keyframeNode.keyframe;\n  const keyframeIndex = findKeyframeIndex(keyframe, this.keyframeNodes);\n  if (keyframeIndex < 0) {\n    throw new DeveloperError(\"Keyframe node does not exist.\");\n  }\n  this.keyframeNodes.splice(keyframeIndex, 1);\n  if (keyframeNode.megatextureIndex !== -1) {\n    for (let i = 0; i < megatextures.length; i++) {\n      megatextures[i].remove(keyframeNode.megatextureIndex);\n    }\n    const renderableKeyframeNodeIndex = findKeyframeIndex(keyframe, this.renderableKeyframeNodes);\n    if (renderableKeyframeNodeIndex < 0) {\n      throw new DeveloperError(\"Renderable keyframe node does not exist.\");\n    }\n    this.renderableKeyframeNodes.splice(renderableKeyframeNodeIndex, 1);\n  }\n  keyframeNode.unload();\n};\n\n/**\n * @param {KeyframeNode} keyframeNode\n * @param {Megatexture[]} megatextures\n */\nSpatialNode.prototype.addKeyframeNodeToMegatextures = function (keyframeNode, megatextures) {\n  if (keyframeNode.megatextureIndex !== -1 || keyframeNode.content.metadata.length !== megatextures.length) {\n    throw new DeveloperError(\"Keyframe node cannot be added to megatexture\");\n  }\n  const {\n    metadata\n  } = keyframeNode.content;\n  for (let i = 0; i < megatextures.length; i++) {\n    const megatexture = megatextures[i];\n    keyframeNode.megatextureIndex = megatexture.add(metadata[i]);\n  }\n  const renderableKeyframeNodes = this.renderableKeyframeNodes;\n  let renderableKeyframeNodeIndex = findKeyframeIndex(keyframeNode.keyframe, renderableKeyframeNodes);\n  if (renderableKeyframeNodeIndex >= 0) {\n    throw new DeveloperError(\"Keyframe already renderable\");\n  }\n  renderableKeyframeNodeIndex = ~renderableKeyframeNodeIndex;\n  renderableKeyframeNodes.splice(renderableKeyframeNodeIndex, 0, keyframeNode);\n};\n\n/**\n * @param {number} frameNumber\n * @returns {boolean}\n */\nSpatialNode.prototype.isRenderable = function (frameNumber) {\n  const previousNode = this.renderableKeyframeNodePrevious;\n  const nextNode = this.renderableKeyframeNodeNext;\n  const level = this.level;\n  return defined(previousNode) && defined(nextNode) && (previousNode.spatialNode.level === level || nextNode.spatialNode.level === level) && this.visitedFrameNumber === frameNumber;\n};\nexport default SpatialNode;","map":{"version":3,"names":["binarySearch","Cartesian3","CesiumMath","defined","DeveloperError","KeyframeNode","Matrix3","OrientedBoundingBox","SpatialNode","level","x","y","z","parent","shape","voxelDimensions","children","undefined","dimensions","clone","keyframeNodes","renderableKeyframeNodes","renderableKeyframeNodeLerp","renderableKeyframeNodePrevious","renderableKeyframeNodeNext","orientedBoundingBox","approximateVoxelSize","screenSpaceError","visitedFrameNumber","computeBoundingVolumes","scratchObbHalfScale","prototype","computeOrientedBoundingBoxForTile","halfScale","getScale","halfAxes","maximumScale","maximumComponent","minimumComponent","constructChildNodes","xMin","yMin","zMin","yMax","xMax","zMax","childLevel","childCoords","map","visibility","frameState","visibilityPlaneMask","obb","cullingVolume","computeVisibilityWithPlaneMask","computeScreenSpaceError","cameraPosition","screenSpaceErrorMultiplier","distance","Math","sqrt","distanceSquaredTo","max","EPSILON7","error","scratchBinarySearchKeyframeNode","keyframe","findKeyframeIndex","searchComparator","computeSurroundingRenderableKeyframeNodes","keyframeLocation","spatialNode","startLevel","targetKeyframePrev","floor","targetKeyframeNext","ceil","bestKeyframeNodePrev","bestKeyframeNodeNext","minimumDistancePrev","Number","MAX_VALUE","minimumDistanceNext","length","indexPrev","getKeyframeIndexPrev","keyframeNodePrev","indexNext","min","keyframeNodeNext","distancePrev","weightedDistancePrev","getWeightedKeyframeDistance","distanceNext","weightedDistanceNext","bestKeyframePrev","bestKeyframeNext","clamp","targetKeyframe","keyframeIndex","levelDistance","keyframeDistance","levelWeight","exp","keyframeWeight","isVisited","frameNumber","createKeyframeNode","index","keyframeNode","splice","destroyKeyframeNode","megatextures","megatextureIndex","i","remove","renderableKeyframeNodeIndex","unload","addKeyframeNodeToMegatextures","content","metadata","megatexture","add","isRenderable","previousNode","nextNode"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/SpatialNode.js"],"sourcesContent":["import binarySearch from \"../Core/binarySearch.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport KeyframeNode from \"./KeyframeNode.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\n\n/**\n * @alias SpatialNode\n * @constructor\n *\n * @param {number} level\n * @param {number} x\n * @param {number} y\n * @param {number} z\n * @param {SpatialNode} parent\n * @param {VoxelShape} shape\n * @param {Cartesian3} voxelDimensions\n *\n * @private\n */\nfunction SpatialNode(level, x, y, z, parent, shape, voxelDimensions) {\n  /**\n   * @type {SpatialNode[]}\n   */\n  this.children = undefined;\n  this.parent = parent;\n\n  this.level = level;\n  this.x = x;\n  this.y = y;\n  this.z = z;\n\n  /**\n   * @type {Cartesian3}\n   */\n  this.dimensions = Cartesian3.clone(voxelDimensions);\n  /**\n   * @type {KeyframeNode[]}\n   */\n  this.keyframeNodes = [];\n  /**\n   * @type {KeyframeNode[]}\n   */\n  this.renderableKeyframeNodes = [];\n\n  this.renderableKeyframeNodeLerp = 0.0;\n  /**\n   * @type {KeyframeNode}\n   */\n  this.renderableKeyframeNodePrevious = undefined;\n  /**\n   * @type {KeyframeNode}\n   */\n  this.renderableKeyframeNodeNext = undefined;\n\n  this.orientedBoundingBox = new OrientedBoundingBox();\n  this.approximateVoxelSize = 0.0;\n  this.screenSpaceError = 0.0;\n  this.visitedFrameNumber = -1;\n\n  this.computeBoundingVolumes(shape);\n}\n\nconst scratchObbHalfScale = new Cartesian3();\n\n/**\n * @param {VoxelShape} shape\n */\nSpatialNode.prototype.computeBoundingVolumes = function (shape) {\n  this.orientedBoundingBox = shape.computeOrientedBoundingBoxForTile(\n    this.level,\n    this.x,\n    this.y,\n    this.z,\n    this.orientedBoundingBox,\n  );\n\n  const halfScale = Matrix3.getScale(\n    this.orientedBoundingBox.halfAxes,\n    scratchObbHalfScale,\n  );\n  const maximumScale = 2.0 * Cartesian3.maximumComponent(halfScale);\n  this.approximateVoxelSize =\n    maximumScale / Cartesian3.minimumComponent(this.dimensions);\n};\n\n/**\n * @param {VoxelShape} shape The shape of the parent VoxelPrimitive\n * @private\n */\nSpatialNode.prototype.constructChildNodes = function (shape) {\n  const { level, x, y, z } = this;\n  const xMin = x * 2;\n  const yMin = y * 2;\n  const zMin = z * 2;\n  const yMax = yMin + 1;\n  const xMax = xMin + 1;\n  const zMax = zMin + 1;\n  const childLevel = level + 1;\n\n  const childCoords = [\n    [childLevel, xMin, yMin, zMin],\n    [childLevel, xMax, yMin, zMin],\n    [childLevel, xMin, yMax, zMin],\n    [childLevel, xMax, yMax, zMin],\n    [childLevel, xMin, yMin, zMax],\n    [childLevel, xMax, yMin, zMax],\n    [childLevel, xMin, yMax, zMax],\n    [childLevel, xMax, yMax, zMax],\n  ];\n\n  this.children = childCoords.map(([level, x, y, z]) => {\n    return new SpatialNode(level, x, y, z, this, shape, this.dimensions);\n  });\n};\n\n/**\n * @param {FrameState} frameState\n * @param {number} visibilityPlaneMask\n * @returns {number} A plane mask as described in {@link CullingVolume#computeVisibilityWithPlaneMask}.\n */\nSpatialNode.prototype.visibility = function (frameState, visibilityPlaneMask) {\n  const obb = this.orientedBoundingBox;\n  const cullingVolume = frameState.cullingVolume;\n  return cullingVolume.computeVisibilityWithPlaneMask(obb, visibilityPlaneMask);\n};\n\n/**\n * @param {Cartesian3} cameraPosition\n * @param {number} screenSpaceErrorMultiplier\n */\nSpatialNode.prototype.computeScreenSpaceError = function (\n  cameraPosition,\n  screenSpaceErrorMultiplier,\n) {\n  const obb = this.orientedBoundingBox;\n\n  let distance = Math.sqrt(obb.distanceSquaredTo(cameraPosition));\n  // Avoid divide-by-zero when viewer is inside the tile.\n  distance = Math.max(distance, CesiumMath.EPSILON7);\n  const approximateVoxelSize = this.approximateVoxelSize;\n  const error = screenSpaceErrorMultiplier * (approximateVoxelSize / distance);\n  this.screenSpaceError = error;\n};\n\n// This object imitates a KeyframeNode. Only used for binary search function.\nconst scratchBinarySearchKeyframeNode = {\n  keyframe: 0,\n};\n\n/**\n * Find the index of a given key frame position within an array of KeyframeNodes,\n * or the complement (~) of the index where it would be in the sorted array.\n * @param {number} keyframe\n * @param {KeyframeNode[]} keyframeNodes\n * @returns {number}\n * @private\n */\nfunction findKeyframeIndex(keyframe, keyframeNodes) {\n  scratchBinarySearchKeyframeNode.keyframe = keyframe;\n  return binarySearch(\n    keyframeNodes,\n    scratchBinarySearchKeyframeNode,\n    KeyframeNode.searchComparator,\n  );\n}\n\n/**\n * Computes the most suitable keyframes for rendering, balancing between temporal and visual quality.\n *\n * @param {number} keyframeLocation\n */\nSpatialNode.prototype.computeSurroundingRenderableKeyframeNodes = function (\n  keyframeLocation,\n) {\n  let spatialNode = this;\n  const startLevel = spatialNode.level;\n\n  const targetKeyframePrev = Math.floor(keyframeLocation);\n  const targetKeyframeNext = Math.ceil(keyframeLocation);\n\n  let bestKeyframeNodePrev;\n  let bestKeyframeNodeNext;\n  let minimumDistancePrev = +Number.MAX_VALUE;\n  let minimumDistanceNext = +Number.MAX_VALUE;\n\n  while (defined(spatialNode)) {\n    const { renderableKeyframeNodes } = spatialNode;\n\n    if (renderableKeyframeNodes.length >= 1) {\n      const indexPrev = getKeyframeIndexPrev(\n        targetKeyframePrev,\n        renderableKeyframeNodes,\n      );\n      const keyframeNodePrev = renderableKeyframeNodes[indexPrev];\n\n      const indexNext =\n        targetKeyframeNext === targetKeyframePrev ||\n        targetKeyframePrev < keyframeNodePrev.keyframe\n          ? indexPrev\n          : Math.min(indexPrev + 1, renderableKeyframeNodes.length - 1);\n      const keyframeNodeNext = renderableKeyframeNodes[indexNext];\n\n      const distancePrev = targetKeyframePrev - keyframeNodePrev.keyframe;\n      const weightedDistancePrev = getWeightedKeyframeDistance(\n        startLevel - spatialNode.level,\n        distancePrev,\n      );\n      if (weightedDistancePrev < minimumDistancePrev) {\n        minimumDistancePrev = weightedDistancePrev;\n        bestKeyframeNodePrev = keyframeNodePrev;\n      }\n\n      const distanceNext = keyframeNodeNext.keyframe - targetKeyframeNext;\n      const weightedDistanceNext = getWeightedKeyframeDistance(\n        startLevel - spatialNode.level,\n        distanceNext,\n      );\n      if (weightedDistanceNext < minimumDistanceNext) {\n        minimumDistanceNext = weightedDistanceNext;\n        bestKeyframeNodeNext = keyframeNodeNext;\n      }\n\n      if (distancePrev === 0 && distanceNext === 0) {\n        // Nothing higher up will be better, so break early.\n        break;\n      }\n    }\n\n    spatialNode = spatialNode.parent;\n  }\n\n  this.renderableKeyframeNodePrevious = bestKeyframeNodePrev;\n  this.renderableKeyframeNodeNext = bestKeyframeNodeNext;\n\n  if (!defined(bestKeyframeNodePrev) || !defined(bestKeyframeNodeNext)) {\n    return;\n  }\n\n  const bestKeyframePrev = bestKeyframeNodePrev.keyframe;\n  const bestKeyframeNext = bestKeyframeNodeNext.keyframe;\n  this.renderableKeyframeNodeLerp =\n    bestKeyframePrev === bestKeyframeNext\n      ? 0.0\n      : CesiumMath.clamp(\n          (keyframeLocation - bestKeyframePrev) /\n            (bestKeyframeNext - bestKeyframePrev),\n          0.0,\n          1.0,\n        );\n};\n\nfunction getKeyframeIndexPrev(targetKeyframe, keyframeNodes) {\n  const keyframeIndex = findKeyframeIndex(targetKeyframe, keyframeNodes);\n  return keyframeIndex < 0\n    ? CesiumMath.clamp(~keyframeIndex - 1, 0, keyframeNodes.length - 1)\n    : keyframeIndex;\n}\n\nfunction getWeightedKeyframeDistance(levelDistance, keyframeDistance) {\n  // Balance quality between visual (levelDistance) and temporal (keyframeDistance)\n  const levelWeight = Math.exp(levelDistance * 4.0);\n  // Keyframes on the opposite of the desired direction are deprioritized.\n  const keyframeWeight = keyframeDistance >= 0 ? 1.0 : -200.0;\n  return levelDistance * levelWeight + keyframeDistance * keyframeWeight;\n}\n\n/**\n * @param {number} frameNumber\n * @returns {boolean}\n */\nSpatialNode.prototype.isVisited = function (frameNumber) {\n  return this.visitedFrameNumber === frameNumber;\n};\n\n/**\n * @param {number} keyframe\n */\nSpatialNode.prototype.createKeyframeNode = function (keyframe) {\n  let index = findKeyframeIndex(keyframe, this.keyframeNodes);\n  if (index < 0) {\n    index = ~index; // convert to insertion index\n    const keyframeNode = new KeyframeNode(this, keyframe);\n    this.keyframeNodes.splice(index, 0, keyframeNode);\n  }\n};\n\n/**\n * @param {KeyframeNode} keyframeNode\n * @param {Megatexture[]} megatextures\n */\nSpatialNode.prototype.destroyKeyframeNode = function (\n  keyframeNode,\n  megatextures,\n) {\n  const keyframe = keyframeNode.keyframe;\n  const keyframeIndex = findKeyframeIndex(keyframe, this.keyframeNodes);\n  if (keyframeIndex < 0) {\n    throw new DeveloperError(\"Keyframe node does not exist.\");\n  }\n\n  this.keyframeNodes.splice(keyframeIndex, 1);\n\n  if (keyframeNode.megatextureIndex !== -1) {\n    for (let i = 0; i < megatextures.length; i++) {\n      megatextures[i].remove(keyframeNode.megatextureIndex);\n    }\n\n    const renderableKeyframeNodeIndex = findKeyframeIndex(\n      keyframe,\n      this.renderableKeyframeNodes,\n    );\n    if (renderableKeyframeNodeIndex < 0) {\n      throw new DeveloperError(\"Renderable keyframe node does not exist.\");\n    }\n\n    this.renderableKeyframeNodes.splice(renderableKeyframeNodeIndex, 1);\n  }\n\n  keyframeNode.unload();\n};\n\n/**\n * @param {KeyframeNode} keyframeNode\n * @param {Megatexture[]} megatextures\n */\nSpatialNode.prototype.addKeyframeNodeToMegatextures = function (\n  keyframeNode,\n  megatextures,\n) {\n  if (\n    keyframeNode.megatextureIndex !== -1 ||\n    keyframeNode.content.metadata.length !== megatextures.length\n  ) {\n    throw new DeveloperError(\"Keyframe node cannot be added to megatexture\");\n  }\n\n  const { metadata } = keyframeNode.content;\n  for (let i = 0; i < megatextures.length; i++) {\n    const megatexture = megatextures[i];\n    keyframeNode.megatextureIndex = megatexture.add(metadata[i]);\n  }\n\n  const renderableKeyframeNodes = this.renderableKeyframeNodes;\n  let renderableKeyframeNodeIndex = findKeyframeIndex(\n    keyframeNode.keyframe,\n    renderableKeyframeNodes,\n  );\n  if (renderableKeyframeNodeIndex >= 0) {\n    throw new DeveloperError(\"Keyframe already renderable\");\n  }\n  renderableKeyframeNodeIndex = ~renderableKeyframeNodeIndex;\n  renderableKeyframeNodes.splice(renderableKeyframeNodeIndex, 0, keyframeNode);\n};\n\n/**\n * @param {number} frameNumber\n * @returns {boolean}\n */\nSpatialNode.prototype.isRenderable = function (frameNumber) {\n  const previousNode = this.renderableKeyframeNodePrevious;\n  const nextNode = this.renderableKeyframeNodeNext;\n  const level = this.level;\n\n  return (\n    defined(previousNode) &&\n    defined(nextNode) &&\n    (previousNode.spatialNode.level === level ||\n      nextNode.spatialNode.level === level) &&\n    this.visitedFrameNumber === frameNumber\n  );\n};\n\nexport default SpatialNode;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}