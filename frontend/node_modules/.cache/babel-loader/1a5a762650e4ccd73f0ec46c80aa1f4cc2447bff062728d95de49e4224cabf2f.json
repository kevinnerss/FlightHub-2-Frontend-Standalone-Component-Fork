{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport MetadataEntity from \"./MetadataEntity.js\";\nimport MetadataTableProperty from \"./MetadataTableProperty.js\";\n\n/**\n * A table containing binary metadata for a collection of entities. This is\n * used for representing binary properties of a batch table, as well as binary\n * metadata in 3D Tiles next extensions.\n * <p>\n * For 3D Tiles Next details, see the {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_metadata|3DTILES_metadata Extension} for 3D Tiles, as well as the {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata|EXT_feature_metadata Extension} for glTF.\n * </p>\n *\n * @param {object} options Object with the following properties:\n * @param {number} options.count The number of entities in the table.\n * @param {object} [options.properties] A dictionary containing properties.\n * @param {MetadataClass} options.class The class that properties conform to.\n * @param {Object<string, Uint8Array>} [options.bufferViews] An object mapping bufferView IDs to Uint8Array objects.\n *\n * @alias MetadataTable\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction MetadataTable(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const count = options.count;\n  const metadataClass = options.class;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThan(\"options.count\", count, 0);\n  Check.typeOf.object(\"options.class\", metadataClass);\n  //>>includeEnd('debug');\n\n  let byteLength = 0;\n  const properties = {};\n  if (defined(options.properties)) {\n    for (const propertyId in options.properties) {\n      if (options.properties.hasOwnProperty(propertyId)) {\n        const property = new MetadataTableProperty({\n          count: count,\n          property: options.properties[propertyId],\n          classProperty: metadataClass.properties[propertyId],\n          bufferViews: options.bufferViews\n        });\n        properties[propertyId] = property;\n        byteLength += property.byteLength;\n      }\n    }\n  }\n  this._count = count;\n  this._class = metadataClass;\n  this._properties = properties;\n  this._byteLength = byteLength;\n}\nObject.defineProperties(MetadataTable.prototype, {\n  /**\n   * The number of entities in the table.\n   *\n   * @memberof MetadataTable.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  count: {\n    get: function () {\n      return this._count;\n    }\n  },\n  /**\n   * The class that properties conform to.\n   *\n   * @memberof MetadataTable.prototype\n   * @type {MetadataClass}\n   * @readonly\n   * @private\n   */\n  class: {\n    get: function () {\n      return this._class;\n    }\n  },\n  /**\n   * The size of all typed arrays used in this table.\n   *\n   * @memberof MetadataTable.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  byteLength: {\n    get: function () {\n      return this._byteLength;\n    }\n  }\n});\n\n/**\n * Returns whether the table has this property.\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {boolean} Whether the table has this property.\n * @private\n */\nMetadataTable.prototype.hasProperty = function (propertyId) {\n  return MetadataEntity.hasProperty(propertyId, this._properties, this._class);\n};\n\n/**\n * Returns whether the table has a property with the given semantic.\n *\n * @param {string} semantic The case-sensitive semantic of the property.\n * @returns {boolean} Whether the table has a property with the given semantic.\n * @private\n */\nMetadataTable.prototype.hasPropertyBySemantic = function (semantic) {\n  return MetadataEntity.hasPropertyBySemantic(semantic, this._properties, this._class);\n};\n\n/**\n * Returns an array of property IDs.\n *\n * @param {string[]} [results] An array into which to store the results.\n * @returns {string[]} The property IDs.\n * @private\n */\nMetadataTable.prototype.getPropertyIds = function (results) {\n  return MetadataEntity.getPropertyIds(this._properties, this._class, results);\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n * <p>\n * If the property is an enum the name of the enum is returned.\n * </p>\n * <p>\n * If the property is normalized the normalized value is returned. The value is\n * in the range [-1.0, 1.0] for signed integer types and [0.0, 1.0] for unsigned\n * integer types.\n * </p>\n * <p>\n * If the property is not normalized and type or componentType is INT64 or\n * UINT64 a BigInt will be returned. On platforms that don't support BigInt a\n * number will be returned instead. Note that numbers only support up to 52 bits\n * of integer precision. Values greater than 2^53 - 1 or less than -(2^53 - 1)\n * may lose precision when read.\n * </p>\n *\n * @param {number} index The index of the entity.\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the entity does not have this property.\n *\n * @exception {DeveloperError} index is required and between zero and count - 1\n * @private\n */\nMetadataTable.prototype.getProperty = function (index, propertyId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  //>>includeEnd('debug');\n\n  const property = this._properties[propertyId];\n  let value;\n  if (defined(property)) {\n    value = property.get(index);\n  } else {\n    value = getDefault(this._class, propertyId);\n  }\n  return value;\n};\n\n/**\n * Sets the value of the property with the given ID.\n * <p>\n * If the property is an enum the name of the enum must be provided, not the\n * integer value.\n * </p>\n * <p>\n * If the property is normalized a normalized value must be provided to this\n * function. The value must be in the range [-1.0, 1.0] for signed integer\n * types and [0.0, 1.0] for unsigned integer types.\n * </p>\n * <p>\n * If the property is not normalized and type or componentType is INT64 or\n * UINT64 a BigInt may be provided. On platforms that don't support BigInt a\n * number may be provided instead. Note that numbers only support up to 52 bits\n * of integer precision. Values greater than 2^53 - 1 or less than -(2^53 - 1)\n * may lose precision when set.\"\n * </p>\n *\n * @param {number} index The index of the entity.\n * @param {string} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n *\n * @exception {DeveloperError} index is required and between zero and count - 1\n * @exception {DeveloperError} value does not match type\n * @exception {DeveloperError} value is out of range for type\n * @exception {DeveloperError} Array length does not match componentCount\n * @private\n */\nMetadataTable.prototype.setProperty = function (index, propertyId, value) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  //>>includeEnd('debug');\n\n  const property = this._properties[propertyId];\n  if (defined(property)) {\n    property.set(index, value);\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns a copy of the value of the property with the given semantic.\n *\n * @param {number} index The index of the entity.\n * @param {string} semantic The case-sensitive semantic of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the entity does not have this semantic.\n *\n * @exception {DeveloperError} index is required and between zero and count - 1\n * @private\n */\nMetadataTable.prototype.getPropertyBySemantic = function (index, semantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  let property;\n  const propertiesBySemantic = this._class.propertiesBySemantic;\n  if (defined(propertiesBySemantic)) {\n    property = propertiesBySemantic[semantic];\n  }\n  if (defined(property)) {\n    return this.getProperty(index, property.id);\n  }\n  return undefined;\n};\n\n/**\n * Sets the value of the property with the given semantic.\n *\n * @param {number} index The index of the entity.\n * @param {string} semantic The case-sensitive semantic of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n *\n * @exception {DeveloperError} index is required and between zero and count - 1\n * @exception {DeveloperError} value does not match type\n * @exception {DeveloperError} value is out of range for type\n * @exception {DeveloperError} Array length does not match componentCount\n * @private\n */\nMetadataTable.prototype.setPropertyBySemantic = function (index, semantic, value) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  let property;\n  const propertiesBySemantic = this._class.propertiesBySemantic;\n  if (defined(propertiesBySemantic)) {\n    property = propertiesBySemantic[semantic];\n  }\n  if (defined(property)) {\n    return this.setProperty(index, property.id, value);\n  }\n  return false;\n};\n\n/**\n * Returns a typed array containing the property values for a given propertyId.\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {*} The typed array containing the property values or <code>undefined</code> if the property values are not stored in a typed array.\n *\n * @private\n */\nMetadataTable.prototype.getPropertyTypedArray = function (propertyId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  //>>includeEnd('debug');\n\n  const property = this._properties[propertyId];\n  if (defined(property)) {\n    return property.getTypedArray();\n  }\n  return undefined;\n};\n\n/**\n * Returns a typed array containing the property values for the property with the given semantic.\n *\n * @param {string} semantic The case-sensitive semantic of the property.\n * @returns {*} The typed array containing the property values or <code>undefined</code> if the property values are not stored in a typed array.\n *\n * @private\n */\nMetadataTable.prototype.getPropertyTypedArrayBySemantic = function (semantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  let property;\n  const propertiesBySemantic = this._class.propertiesBySemantic;\n  if (defined(propertiesBySemantic)) {\n    property = propertiesBySemantic[semantic];\n  }\n  if (defined(property)) {\n    return this.getPropertyTypedArray(property.id);\n  }\n  return undefined;\n};\nfunction getDefault(classDefinition, propertyId) {\n  const classProperties = classDefinition.properties;\n  if (!defined(classProperties)) {\n    return undefined;\n  }\n  const classProperty = classProperties[propertyId];\n  if (defined(classProperty) && defined(classProperty.default)) {\n    let value = classProperty.default;\n    if (classProperty.isArray) {\n      value = clone(value, true);\n    }\n    value = classProperty.normalize(value);\n    return classProperty.unpackVectorAndMatrixTypes(value);\n  }\n}\nexport default MetadataTable;","map":{"version":3,"names":["Check","clone","Frozen","defined","MetadataEntity","MetadataTableProperty","MetadataTable","options","EMPTY_OBJECT","count","metadataClass","class","typeOf","number","greaterThan","object","byteLength","properties","propertyId","hasOwnProperty","property","classProperty","bufferViews","_count","_class","_properties","_byteLength","Object","defineProperties","prototype","get","hasProperty","hasPropertyBySemantic","semantic","getPropertyIds","results","getProperty","index","string","value","getDefault","setProperty","set","getPropertyBySemantic","propertiesBySemantic","id","undefined","setPropertyBySemantic","getPropertyTypedArray","getTypedArray","getPropertyTypedArrayBySemantic","classDefinition","classProperties","default","isArray","normalize","unpackVectorAndMatrixTypes"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/MetadataTable.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport MetadataEntity from \"./MetadataEntity.js\";\nimport MetadataTableProperty from \"./MetadataTableProperty.js\";\n\n/**\n * A table containing binary metadata for a collection of entities. This is\n * used for representing binary properties of a batch table, as well as binary\n * metadata in 3D Tiles next extensions.\n * <p>\n * For 3D Tiles Next details, see the {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_metadata|3DTILES_metadata Extension} for 3D Tiles, as well as the {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata|EXT_feature_metadata Extension} for glTF.\n * </p>\n *\n * @param {object} options Object with the following properties:\n * @param {number} options.count The number of entities in the table.\n * @param {object} [options.properties] A dictionary containing properties.\n * @param {MetadataClass} options.class The class that properties conform to.\n * @param {Object<string, Uint8Array>} [options.bufferViews] An object mapping bufferView IDs to Uint8Array objects.\n *\n * @alias MetadataTable\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction MetadataTable(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const count = options.count;\n  const metadataClass = options.class;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThan(\"options.count\", count, 0);\n  Check.typeOf.object(\"options.class\", metadataClass);\n  //>>includeEnd('debug');\n\n  let byteLength = 0;\n  const properties = {};\n  if (defined(options.properties)) {\n    for (const propertyId in options.properties) {\n      if (options.properties.hasOwnProperty(propertyId)) {\n        const property = new MetadataTableProperty({\n          count: count,\n          property: options.properties[propertyId],\n          classProperty: metadataClass.properties[propertyId],\n          bufferViews: options.bufferViews,\n        });\n        properties[propertyId] = property;\n        byteLength += property.byteLength;\n      }\n    }\n  }\n\n  this._count = count;\n  this._class = metadataClass;\n  this._properties = properties;\n  this._byteLength = byteLength;\n}\n\nObject.defineProperties(MetadataTable.prototype, {\n  /**\n   * The number of entities in the table.\n   *\n   * @memberof MetadataTable.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  count: {\n    get: function () {\n      return this._count;\n    },\n  },\n\n  /**\n   * The class that properties conform to.\n   *\n   * @memberof MetadataTable.prototype\n   * @type {MetadataClass}\n   * @readonly\n   * @private\n   */\n  class: {\n    get: function () {\n      return this._class;\n    },\n  },\n\n  /**\n   * The size of all typed arrays used in this table.\n   *\n   * @memberof MetadataTable.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  byteLength: {\n    get: function () {\n      return this._byteLength;\n    },\n  },\n});\n\n/**\n * Returns whether the table has this property.\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {boolean} Whether the table has this property.\n * @private\n */\nMetadataTable.prototype.hasProperty = function (propertyId) {\n  return MetadataEntity.hasProperty(propertyId, this._properties, this._class);\n};\n\n/**\n * Returns whether the table has a property with the given semantic.\n *\n * @param {string} semantic The case-sensitive semantic of the property.\n * @returns {boolean} Whether the table has a property with the given semantic.\n * @private\n */\nMetadataTable.prototype.hasPropertyBySemantic = function (semantic) {\n  return MetadataEntity.hasPropertyBySemantic(\n    semantic,\n    this._properties,\n    this._class,\n  );\n};\n\n/**\n * Returns an array of property IDs.\n *\n * @param {string[]} [results] An array into which to store the results.\n * @returns {string[]} The property IDs.\n * @private\n */\nMetadataTable.prototype.getPropertyIds = function (results) {\n  return MetadataEntity.getPropertyIds(this._properties, this._class, results);\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n * <p>\n * If the property is an enum the name of the enum is returned.\n * </p>\n * <p>\n * If the property is normalized the normalized value is returned. The value is\n * in the range [-1.0, 1.0] for signed integer types and [0.0, 1.0] for unsigned\n * integer types.\n * </p>\n * <p>\n * If the property is not normalized and type or componentType is INT64 or\n * UINT64 a BigInt will be returned. On platforms that don't support BigInt a\n * number will be returned instead. Note that numbers only support up to 52 bits\n * of integer precision. Values greater than 2^53 - 1 or less than -(2^53 - 1)\n * may lose precision when read.\n * </p>\n *\n * @param {number} index The index of the entity.\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the entity does not have this property.\n *\n * @exception {DeveloperError} index is required and between zero and count - 1\n * @private\n */\nMetadataTable.prototype.getProperty = function (index, propertyId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  //>>includeEnd('debug');\n\n  const property = this._properties[propertyId];\n\n  let value;\n  if (defined(property)) {\n    value = property.get(index);\n  } else {\n    value = getDefault(this._class, propertyId);\n  }\n\n  return value;\n};\n\n/**\n * Sets the value of the property with the given ID.\n * <p>\n * If the property is an enum the name of the enum must be provided, not the\n * integer value.\n * </p>\n * <p>\n * If the property is normalized a normalized value must be provided to this\n * function. The value must be in the range [-1.0, 1.0] for signed integer\n * types and [0.0, 1.0] for unsigned integer types.\n * </p>\n * <p>\n * If the property is not normalized and type or componentType is INT64 or\n * UINT64 a BigInt may be provided. On platforms that don't support BigInt a\n * number may be provided instead. Note that numbers only support up to 52 bits\n * of integer precision. Values greater than 2^53 - 1 or less than -(2^53 - 1)\n * may lose precision when set.\"\n * </p>\n *\n * @param {number} index The index of the entity.\n * @param {string} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n *\n * @exception {DeveloperError} index is required and between zero and count - 1\n * @exception {DeveloperError} value does not match type\n * @exception {DeveloperError} value is out of range for type\n * @exception {DeveloperError} Array length does not match componentCount\n * @private\n */\nMetadataTable.prototype.setProperty = function (index, propertyId, value) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  //>>includeEnd('debug');\n\n  const property = this._properties[propertyId];\n  if (defined(property)) {\n    property.set(index, value);\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Returns a copy of the value of the property with the given semantic.\n *\n * @param {number} index The index of the entity.\n * @param {string} semantic The case-sensitive semantic of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the entity does not have this semantic.\n *\n * @exception {DeveloperError} index is required and between zero and count - 1\n * @private\n */\nMetadataTable.prototype.getPropertyBySemantic = function (index, semantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  let property;\n  const propertiesBySemantic = this._class.propertiesBySemantic;\n  if (defined(propertiesBySemantic)) {\n    property = propertiesBySemantic[semantic];\n  }\n\n  if (defined(property)) {\n    return this.getProperty(index, property.id);\n  }\n\n  return undefined;\n};\n\n/**\n * Sets the value of the property with the given semantic.\n *\n * @param {number} index The index of the entity.\n * @param {string} semantic The case-sensitive semantic of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n *\n * @exception {DeveloperError} index is required and between zero and count - 1\n * @exception {DeveloperError} value does not match type\n * @exception {DeveloperError} value is out of range for type\n * @exception {DeveloperError} Array length does not match componentCount\n * @private\n */\nMetadataTable.prototype.setPropertyBySemantic = function (\n  index,\n  semantic,\n  value,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  let property;\n  const propertiesBySemantic = this._class.propertiesBySemantic;\n  if (defined(propertiesBySemantic)) {\n    property = propertiesBySemantic[semantic];\n  }\n\n  if (defined(property)) {\n    return this.setProperty(index, property.id, value);\n  }\n\n  return false;\n};\n\n/**\n * Returns a typed array containing the property values for a given propertyId.\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {*} The typed array containing the property values or <code>undefined</code> if the property values are not stored in a typed array.\n *\n * @private\n */\nMetadataTable.prototype.getPropertyTypedArray = function (propertyId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  //>>includeEnd('debug');\n\n  const property = this._properties[propertyId];\n\n  if (defined(property)) {\n    return property.getTypedArray();\n  }\n\n  return undefined;\n};\n\n/**\n * Returns a typed array containing the property values for the property with the given semantic.\n *\n * @param {string} semantic The case-sensitive semantic of the property.\n * @returns {*} The typed array containing the property values or <code>undefined</code> if the property values are not stored in a typed array.\n *\n * @private\n */\nMetadataTable.prototype.getPropertyTypedArrayBySemantic = function (semantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  let property;\n  const propertiesBySemantic = this._class.propertiesBySemantic;\n  if (defined(propertiesBySemantic)) {\n    property = propertiesBySemantic[semantic];\n  }\n\n  if (defined(property)) {\n    return this.getPropertyTypedArray(property.id);\n  }\n\n  return undefined;\n};\n\nfunction getDefault(classDefinition, propertyId) {\n  const classProperties = classDefinition.properties;\n  if (!defined(classProperties)) {\n    return undefined;\n  }\n\n  const classProperty = classProperties[propertyId];\n  if (defined(classProperty) && defined(classProperty.default)) {\n    let value = classProperty.default;\n    if (classProperty.isArray) {\n      value = clone(value, true);\n    }\n    value = classProperty.normalize(value);\n    return classProperty.unpackVectorAndMatrixTypes(value);\n  }\n}\n\nexport default MetadataTable;\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,kBAAkB;AACpC,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,MAAM,MAAM,mBAAmB;AACtC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,cAAc,MAAM,qBAAqB;AAChD,OAAOC,qBAAqB,MAAM,4BAA4B;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,aAAaA,CAACC,OAAO,EAAE;EAC9BA,OAAO,GAAGA,OAAO,IAAIL,MAAM,CAACM,YAAY;EACxC,MAAMC,KAAK,GAAGF,OAAO,CAACE,KAAK;EAC3B,MAAMC,aAAa,GAAGH,OAAO,CAACI,KAAK;;EAEnC;EACAX,KAAK,CAACY,MAAM,CAACC,MAAM,CAACC,WAAW,CAAC,eAAe,EAAEL,KAAK,EAAE,CAAC,CAAC;EAC1DT,KAAK,CAACY,MAAM,CAACG,MAAM,CAAC,eAAe,EAAEL,aAAa,CAAC;EACnD;;EAEA,IAAIM,UAAU,GAAG,CAAC;EAClB,MAAMC,UAAU,GAAG,CAAC,CAAC;EACrB,IAAId,OAAO,CAACI,OAAO,CAACU,UAAU,CAAC,EAAE;IAC/B,KAAK,MAAMC,UAAU,IAAIX,OAAO,CAACU,UAAU,EAAE;MAC3C,IAAIV,OAAO,CAACU,UAAU,CAACE,cAAc,CAACD,UAAU,CAAC,EAAE;QACjD,MAAME,QAAQ,GAAG,IAAIf,qBAAqB,CAAC;UACzCI,KAAK,EAAEA,KAAK;UACZW,QAAQ,EAAEb,OAAO,CAACU,UAAU,CAACC,UAAU,CAAC;UACxCG,aAAa,EAAEX,aAAa,CAACO,UAAU,CAACC,UAAU,CAAC;UACnDI,WAAW,EAAEf,OAAO,CAACe;QACvB,CAAC,CAAC;QACFL,UAAU,CAACC,UAAU,CAAC,GAAGE,QAAQ;QACjCJ,UAAU,IAAII,QAAQ,CAACJ,UAAU;MACnC;IACF;EACF;EAEA,IAAI,CAACO,MAAM,GAAGd,KAAK;EACnB,IAAI,CAACe,MAAM,GAAGd,aAAa;EAC3B,IAAI,CAACe,WAAW,GAAGR,UAAU;EAC7B,IAAI,CAACS,WAAW,GAAGV,UAAU;AAC/B;AAEAW,MAAM,CAACC,gBAAgB,CAACtB,aAAa,CAACuB,SAAS,EAAE;EAC/C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEpB,KAAK,EAAE;IACLqB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACP,MAAM;IACpB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEZ,KAAK,EAAE;IACLmB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACN,MAAM;IACpB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACER,UAAU,EAAE;IACVc,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACJ,WAAW;IACzB;EACF;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACApB,aAAa,CAACuB,SAAS,CAACE,WAAW,GAAG,UAAUb,UAAU,EAAE;EAC1D,OAAOd,cAAc,CAAC2B,WAAW,CAACb,UAAU,EAAE,IAAI,CAACO,WAAW,EAAE,IAAI,CAACD,MAAM,CAAC;AAC9E,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAlB,aAAa,CAACuB,SAAS,CAACG,qBAAqB,GAAG,UAAUC,QAAQ,EAAE;EAClE,OAAO7B,cAAc,CAAC4B,qBAAqB,CACzCC,QAAQ,EACR,IAAI,CAACR,WAAW,EAChB,IAAI,CAACD,MACP,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAlB,aAAa,CAACuB,SAAS,CAACK,cAAc,GAAG,UAAUC,OAAO,EAAE;EAC1D,OAAO/B,cAAc,CAAC8B,cAAc,CAAC,IAAI,CAACT,WAAW,EAAE,IAAI,CAACD,MAAM,EAAEW,OAAO,CAAC;AAC9E,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA7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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}