{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.every.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.iterator.some.js\";\n/*!\n * vue-router v4.6.3\n * (c) 2025 Eduardo San Martin Morote\n * @license MIT\n */\nimport { getCurrentInstance, inject, onActivated, onDeactivated, onUnmounted, watch } from \"vue\";\nimport { setupDevtoolsPlugin } from \"@vue/devtools-api\";\n\n//#region src/utils/env.ts\nconst isBrowser = typeof document !== \"undefined\";\n\n//#endregion\n//#region src/utils/index.ts\n/**\n* Identity function that returns the value as is.\n*\n* @param v - the value to return\n*\n* @internal\n*/\nconst identityFn = v => v;\n/**\n* Allows differentiating lazy components from functional components and vue-class-component\n* @internal\n*\n* @param component\n*/\nfunction isRouteComponent(component) {\n  return typeof component === \"object\" || \"displayName\" in component || \"props\" in component || \"__vccOpts\" in component;\n}\nfunction isESModule(obj) {\n  return obj.__esModule || obj[Symbol.toStringTag] === \"Module\" || obj.default && isRouteComponent(obj.default);\n}\nconst assign = Object.assign;\nfunction applyToParams(fn, params) {\n  const newParams = {};\n  for (const key in params) {\n    const value = params[key];\n    newParams[key] = isArray(value) ? value.map(fn) : fn(value);\n  }\n  return newParams;\n}\nconst noop = () => {};\n/**\n* Typesafe alternative to Array.isArray\n* https://github.com/microsoft/TypeScript/pull/48228\n*/\nconst isArray = Array.isArray;\nfunction mergeOptions(defaults, partialOptions) {\n  const options = {};\n  for (const key in defaults) options[key] = key in partialOptions ? partialOptions[key] : defaults[key];\n  return options;\n}\n\n//#endregion\n//#region src/warning.ts\nfunction warn$1(msg) {\n  const args = Array.from(arguments).slice(1);\n  console.warn.apply(console, [\"[Vue Router warn]: \" + msg].concat(args));\n}\n\n//#endregion\n//#region src/encoding.ts\n/**\n* Encoding Rules (␣ = Space)\n* - Path: ␣ \" < > # ? { }\n* - Query: ␣ \" < > # & =\n* - Hash: ␣ \" < > `\n*\n* On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)\n* defines some extra characters to be encoded. Most browsers do not encode them\n* in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to\n* also encode `!'()*`. Leaving un-encoded only ASCII alphanumeric(`a-zA-Z0-9`)\n* plus `-._~`. This extra safety should be applied to query by patching the\n* string returned by encodeURIComponent encodeURI also encodes `[\\]^`. `\\`\n* should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\\`\n* into a `/` if directly typed in. The _backtick_ (`````) should also be\n* encoded everywhere because some browsers like FF encode it when directly\n* written while others don't. Safari and IE don't encode ``\"<>{}``` in hash.\n*/\nconst HASH_RE = /#/g;\nconst AMPERSAND_RE = /&/g;\nconst SLASH_RE = /\\//g;\nconst EQUAL_RE = /=/g;\nconst IM_RE = /\\?/g;\nconst PLUS_RE = /\\+/g;\n/**\n* NOTE: It's not clear to me if we should encode the + symbol in queries, it\n* seems to be less flexible than not doing so and I can't find out the legacy\n* systems requiring this for regular requests like text/html. In the standard,\n* the encoding of the plus character is only mentioned for\n* application/x-www-form-urlencoded\n* (https://url.spec.whatwg.org/#urlencoded-parsing) and most browsers seems lo\n* leave the plus character as is in queries. To be more flexible, we allow the\n* plus character on the query, but it can also be manually encoded by the user.\n*\n* Resources:\n* - https://url.spec.whatwg.org/#urlencoded-parsing\n* - https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20\n*/\nconst ENC_BRACKET_OPEN_RE = /%5B/g;\nconst ENC_BRACKET_CLOSE_RE = /%5D/g;\nconst ENC_CARET_RE = /%5E/g;\nconst ENC_BACKTICK_RE = /%60/g;\nconst ENC_CURLY_OPEN_RE = /%7B/g;\nconst ENC_PIPE_RE = /%7C/g;\nconst ENC_CURLY_CLOSE_RE = /%7D/g;\nconst ENC_SPACE_RE = /%20/g;\n/**\n* Encode characters that need to be encoded on the path, search and hash\n* sections of the URL.\n*\n* @internal\n* @param text - string to encode\n* @returns encoded string\n*/\nfunction commonEncode(text) {\n  return text == null ? \"\" : encodeURI(\"\" + text).replace(ENC_PIPE_RE, \"|\").replace(ENC_BRACKET_OPEN_RE, \"[\").replace(ENC_BRACKET_CLOSE_RE, \"]\");\n}\n/**\n* Encode characters that need to be encoded on the hash section of the URL.\n*\n* @param text - string to encode\n* @returns encoded string\n*/\nfunction encodeHash(text) {\n  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\n/**\n* Encode characters that need to be encoded query values on the query\n* section of the URL.\n*\n* @param text - string to encode\n* @returns encoded string\n*/\nfunction encodeQueryValue(text) {\n  return commonEncode(text).replace(PLUS_RE, \"%2B\").replace(ENC_SPACE_RE, \"+\").replace(HASH_RE, \"%23\").replace(AMPERSAND_RE, \"%26\").replace(ENC_BACKTICK_RE, \"`\").replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\n/**\n* Like `encodeQueryValue` but also encodes the `=` character.\n*\n* @param text - string to encode\n*/\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, \"%3D\");\n}\n/**\n* Encode characters that need to be encoded on the path section of the URL.\n*\n* @param text - string to encode\n* @returns encoded string\n*/\nfunction encodePath(text) {\n  return commonEncode(text).replace(HASH_RE, \"%23\").replace(IM_RE, \"%3F\");\n}\n/**\n* Encode characters that need to be encoded on the path section of the URL as a\n* param. This function encodes everything {@link encodePath} does plus the\n* slash (`/`) character. If `text` is `null` or `undefined`, returns an empty\n* string instead.\n*\n* @param text - string to encode\n* @returns encoded string\n*/\nfunction encodeParam(text) {\n  return encodePath(text).replace(SLASH_RE, \"%2F\");\n}\nfunction decode(text) {\n  if (text == null) return null;\n  try {\n    return decodeURIComponent(\"\" + text);\n  } catch (err) {\n    process.env.NODE_ENV !== \"production\" && warn$1(`Error decoding \"${text}\". Using original value`);\n  }\n  return \"\" + text;\n}\n\n//#endregion\n//#region src/location.ts\nconst TRAILING_SLASH_RE = /\\/$/;\nconst removeTrailingSlash = path => path.replace(TRAILING_SLASH_RE, \"\");\n/**\n* Transforms a URI into a normalized history location\n*\n* @param parseQuery\n* @param location - URI to normalize\n* @param currentLocation - current absolute location. Allows resolving relative\n* paths. Must start with `/`. Defaults to `/`\n* @returns a normalized history location\n*/\nfunction parseURL(parseQuery$1, location, currentLocation = \"/\") {\n  let path,\n    query = {},\n    searchString = \"\",\n    hash = \"\";\n  const hashPos = location.indexOf(\"#\");\n  let searchPos = location.indexOf(\"?\");\n  searchPos = hashPos >= 0 && searchPos > hashPos ? -1 : searchPos;\n  if (searchPos >= 0) {\n    path = location.slice(0, searchPos);\n    searchString = location.slice(searchPos, hashPos > 0 ? hashPos : location.length);\n    query = parseQuery$1(searchString.slice(1));\n  }\n  if (hashPos >= 0) {\n    path = path || location.slice(0, hashPos);\n    hash = location.slice(hashPos, location.length);\n  }\n  path = resolveRelativePath(path != null ? path : location, currentLocation);\n  return {\n    fullPath: path + searchString + hash,\n    path,\n    query,\n    hash: decode(hash)\n  };\n}\nfunction NEW_stringifyURL(stringifyQuery$1, path, query, hash = \"\") {\n  const searchText = stringifyQuery$1(query);\n  return path + (searchText && \"?\") + searchText + encodeHash(hash);\n}\n/**\n* Stringifies a URL object\n*\n* @param stringifyQuery\n* @param location\n*/\nfunction stringifyURL(stringifyQuery$1, location) {\n  const query = location.query ? stringifyQuery$1(location.query) : \"\";\n  return location.path + (query && \"?\") + query + (location.hash || \"\");\n}\n/**\n* Strips off the base from the beginning of a location.pathname in a non-case-sensitive way.\n*\n* @param pathname - location.pathname\n* @param base - base to strip off\n*/\nfunction stripBase(pathname, base) {\n  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase())) return pathname;\n  return pathname.slice(base.length) || \"/\";\n}\n/**\n* Checks if two RouteLocation are equal. This means that both locations are\n* pointing towards the same {@link RouteRecord} and that all `params`, `query`\n* parameters and `hash` are the same\n*\n* @param stringifyQuery - A function that takes a query object of type LocationQueryRaw and returns a string representation of it.\n* @param a - first {@link RouteLocation}\n* @param b - second {@link RouteLocation}\n*/\nfunction isSameRouteLocation(stringifyQuery$1, a, b) {\n  const aLastIndex = a.matched.length - 1;\n  const bLastIndex = b.matched.length - 1;\n  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery$1(a.query) === stringifyQuery$1(b.query) && a.hash === b.hash;\n}\n/**\n* Check if two `RouteRecords` are equal. Takes into account aliases: they are\n* considered equal to the `RouteRecord` they are aliasing.\n*\n* @param a - first {@link RouteRecord}\n* @param b - second {@link RouteRecord}\n*/\nfunction isSameRouteRecord(a, b) {\n  return (a.aliasOf || a) === (b.aliasOf || b);\n}\nfunction isSameRouteLocationParams(a, b) {\n  if (Object.keys(a).length !== Object.keys(b).length) return false;\n  for (const key in a) if (!isSameRouteLocationParamsValue(a[key], b[key])) return false;\n  return true;\n}\nfunction isSameRouteLocationParamsValue(a, b) {\n  return isArray(a) ? isEquivalentArray(a, b) : isArray(b) ? isEquivalentArray(b, a) : a === b;\n}\n/**\n* Check if two arrays are the same or if an array with one single entry is the\n* same as another primitive value. Used to check query and parameters\n*\n* @param a - array of values\n* @param b - array of values or a single value\n*/\nfunction isEquivalentArray(a, b) {\n  return isArray(b) ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;\n}\n/**\n* Resolves a relative path that starts with `.`.\n*\n* @param to - path location we are resolving\n* @param from - currentLocation.path, should start with `/`\n*/\nfunction resolveRelativePath(to, from) {\n  if (to.startsWith(\"/\")) return to;\n  if (process.env.NODE_ENV !== \"production\" && !from.startsWith(\"/\")) {\n    warn$1(`Cannot resolve a relative location without an absolute path. Trying to resolve \"${to}\" from \"${from}\". It should look like \"/${from}\".`);\n    return to;\n  }\n  if (!to) return from;\n  const fromSegments = from.split(\"/\");\n  const toSegments = to.split(\"/\");\n  const lastToSegment = toSegments[toSegments.length - 1];\n  if (lastToSegment === \"..\" || lastToSegment === \".\") toSegments.push(\"\");\n  let position = fromSegments.length - 1;\n  let toPosition;\n  let segment;\n  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {\n    segment = toSegments[toPosition];\n    if (segment === \".\") continue;\n    if (segment === \"..\") {\n      if (position > 1) position--;\n    } else break;\n  }\n  return fromSegments.slice(0, position).join(\"/\") + \"/\" + toSegments.slice(toPosition).join(\"/\");\n}\n/**\n* Initial route location where the router is. Can be used in navigation guards\n* to differentiate the initial navigation.\n*\n* @example\n* ```js\n* import { START_LOCATION } from 'vue-router'\n*\n* router.beforeEach((to, from) => {\n*   if (from === START_LOCATION) {\n*     // initial navigation\n*   }\n* })\n* ```\n*/\nconst START_LOCATION_NORMALIZED = {\n  path: \"/\",\n  name: void 0,\n  params: {},\n  query: {},\n  hash: \"\",\n  fullPath: \"/\",\n  matched: [],\n  meta: {},\n  redirectedFrom: void 0\n};\n\n//#endregion\n//#region src/history/common.ts\nlet NavigationType = /* @__PURE__ */function (NavigationType$1) {\n  NavigationType$1[\"pop\"] = \"pop\";\n  NavigationType$1[\"push\"] = \"push\";\n  return NavigationType$1;\n}({});\nlet NavigationDirection = /* @__PURE__ */function (NavigationDirection$1) {\n  NavigationDirection$1[\"back\"] = \"back\";\n  NavigationDirection$1[\"forward\"] = \"forward\";\n  NavigationDirection$1[\"unknown\"] = \"\";\n  return NavigationDirection$1;\n}({});\n/**\n* Starting location for Histories\n*/\nconst START = \"\";\n/**\n* Normalizes a base by removing any trailing slash and reading the base tag if\n* present.\n*\n* @param base - base to normalize\n*/\nfunction normalizeBase(base) {\n  if (!base) if (isBrowser) {\n    const baseEl = document.querySelector(\"base\");\n    base = baseEl && baseEl.getAttribute(\"href\") || \"/\";\n    base = base.replace(/^\\w+:\\/\\/[^\\/]+/, \"\");\n  } else base = \"/\";\n  if (base[0] !== \"/\" && base[0] !== \"#\") base = \"/\" + base;\n  return removeTrailingSlash(base);\n}\nconst BEFORE_HASH_RE = /^[^#]+#/;\nfunction createHref(base, location) {\n  return base.replace(BEFORE_HASH_RE, \"#\") + location;\n}\n\n//#endregion\n//#region src/scrollBehavior.ts\nfunction getElementPosition(el, offset) {\n  const docRect = document.documentElement.getBoundingClientRect();\n  const elRect = el.getBoundingClientRect();\n  return {\n    behavior: offset.behavior,\n    left: elRect.left - docRect.left - (offset.left || 0),\n    top: elRect.top - docRect.top - (offset.top || 0)\n  };\n}\nconst computeScrollPosition = () => ({\n  left: window.scrollX,\n  top: window.scrollY\n});\nfunction scrollToPosition(position) {\n  let scrollToOptions;\n  if (\"el\" in position) {\n    const positionEl = position.el;\n    const isIdSelector = typeof positionEl === \"string\" && positionEl.startsWith(\"#\");\n    /**\n    * `id`s can accept pretty much any characters, including CSS combinators\n    * like `>` or `~`. It's still possible to retrieve elements using\n    * `document.getElementById('~')` but it needs to be escaped when using\n    * `document.querySelector('#\\\\~')` for it to be valid. The only\n    * requirements for `id`s are them to be unique on the page and to not be\n    * empty (`id=\"\"`). Because of that, when passing an id selector, it should\n    * be properly escaped for it to work with `querySelector`. We could check\n    * for the id selector to be simple (no CSS combinators `+ >~`) but that\n    * would make things inconsistent since they are valid characters for an\n    * `id` but would need to be escaped when using `querySelector`, breaking\n    * their usage and ending up in no selector returned. Selectors need to be\n    * escaped:\n    *\n    * - `#1-thing` becomes `#\\31 -thing`\n    * - `#with~symbols` becomes `#with\\\\~symbols`\n    *\n    * - More information about  the topic can be found at\n    *   https://mathiasbynens.be/notes/html5-id-class.\n    * - Practical example: https://mathiasbynens.be/demo/html5-id\n    */\n    if (process.env.NODE_ENV !== \"production\" && typeof position.el === \"string\") {\n      if (!isIdSelector || !document.getElementById(position.el.slice(1))) try {\n        const foundEl = document.querySelector(position.el);\n        if (isIdSelector && foundEl) {\n          warn$1(`The selector \"${position.el}\" should be passed as \"el: document.querySelector('${position.el}')\" because it starts with \"#\".`);\n          return;\n        }\n      } catch (err) {\n        warn$1(`The selector \"${position.el}\" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);\n        return;\n      }\n    }\n    const el = typeof positionEl === \"string\" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;\n    if (!el) {\n      process.env.NODE_ENV !== \"production\" && warn$1(`Couldn't find element using selector \"${position.el}\" returned by scrollBehavior.`);\n      return;\n    }\n    scrollToOptions = getElementPosition(el, position);\n  } else scrollToOptions = position;\n  if (\"scrollBehavior\" in document.documentElement.style) window.scrollTo(scrollToOptions);else window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.scrollX, scrollToOptions.top != null ? scrollToOptions.top : window.scrollY);\n}\nfunction getScrollKey(path, delta) {\n  return (history.state ? history.state.position - delta : -1) + path;\n}\nconst scrollPositions = /* @__PURE__ */new Map();\nfunction saveScrollPosition(key, scrollPosition) {\n  scrollPositions.set(key, scrollPosition);\n}\nfunction getSavedScrollPosition(key) {\n  const scroll = scrollPositions.get(key);\n  scrollPositions.delete(key);\n  return scroll;\n}\n/**\n* ScrollBehavior instance used by the router to compute and restore the scroll\n* position when navigating.\n*/\n\n//#endregion\n//#region src/types/typeGuards.ts\nfunction isRouteLocation(route) {\n  return typeof route === \"string\" || route && typeof route === \"object\";\n}\nfunction isRouteName(name) {\n  return typeof name === \"string\" || typeof name === \"symbol\";\n}\n\n//#endregion\n//#region src/errors.ts\n/**\n* Flags so we can combine them when checking for multiple errors. This is the internal version of\n* {@link NavigationFailureType}.\n*\n* @internal\n*/\nlet ErrorTypes = /* @__PURE__ */function (ErrorTypes$1) {\n  ErrorTypes$1[ErrorTypes$1[\"MATCHER_NOT_FOUND\"] = 1] = \"MATCHER_NOT_FOUND\";\n  ErrorTypes$1[ErrorTypes$1[\"NAVIGATION_GUARD_REDIRECT\"] = 2] = \"NAVIGATION_GUARD_REDIRECT\";\n  ErrorTypes$1[ErrorTypes$1[\"NAVIGATION_ABORTED\"] = 4] = \"NAVIGATION_ABORTED\";\n  ErrorTypes$1[ErrorTypes$1[\"NAVIGATION_CANCELLED\"] = 8] = \"NAVIGATION_CANCELLED\";\n  ErrorTypes$1[ErrorTypes$1[\"NAVIGATION_DUPLICATED\"] = 16] = \"NAVIGATION_DUPLICATED\";\n  return ErrorTypes$1;\n}({});\nconst NavigationFailureSymbol = Symbol(process.env.NODE_ENV !== \"production\" ? \"navigation failure\" : \"\");\n/**\n* Enumeration with all possible types for navigation failures. Can be passed to\n* {@link isNavigationFailure} to check for specific failures.\n*/\nlet NavigationFailureType = /* @__PURE__ */function (NavigationFailureType$1) {\n  /**\n  * An aborted navigation is a navigation that failed because a navigation\n  * guard returned `false` or called `next(false)`\n  */\n  NavigationFailureType$1[NavigationFailureType$1[\"aborted\"] = 4] = \"aborted\";\n  /**\n  * A cancelled navigation is a navigation that failed because a more recent\n  * navigation finished started (not necessarily finished).\n  */\n  NavigationFailureType$1[NavigationFailureType$1[\"cancelled\"] = 8] = \"cancelled\";\n  /**\n  * A duplicated navigation is a navigation that failed because it was\n  * initiated while already being at the exact same location.\n  */\n  NavigationFailureType$1[NavigationFailureType$1[\"duplicated\"] = 16] = \"duplicated\";\n  return NavigationFailureType$1;\n}({});\nconst ErrorTypeMessages = {\n  [ErrorTypes.MATCHER_NOT_FOUND]({\n    location,\n    currentLocation\n  }) {\n    return `No match for\\n ${JSON.stringify(location)}${currentLocation ? \"\\nwhile being at\\n\" + JSON.stringify(currentLocation) : \"\"}`;\n  },\n  [ErrorTypes.NAVIGATION_GUARD_REDIRECT]({\n    from,\n    to\n  }) {\n    return `Redirected from \"${from.fullPath}\" to \"${stringifyRoute(to)}\" via a navigation guard.`;\n  },\n  [ErrorTypes.NAVIGATION_ABORTED]({\n    from,\n    to\n  }) {\n    return `Navigation aborted from \"${from.fullPath}\" to \"${to.fullPath}\" via a navigation guard.`;\n  },\n  [ErrorTypes.NAVIGATION_CANCELLED]({\n    from,\n    to\n  }) {\n    return `Navigation cancelled from \"${from.fullPath}\" to \"${to.fullPath}\" with a new navigation.`;\n  },\n  [ErrorTypes.NAVIGATION_DUPLICATED]({\n    from,\n    to\n  }) {\n    return `Avoided redundant navigation to current location: \"${from.fullPath}\".`;\n  }\n};\n/**\n* Creates a typed NavigationFailure object.\n* @internal\n* @param type - NavigationFailureType\n* @param params - { from, to }\n*/\nfunction createRouterError(type, params) {\n  if (process.env.NODE_ENV !== \"production\" || false) return assign(new Error(ErrorTypeMessages[type](params)), {\n    type,\n    [NavigationFailureSymbol]: true\n  }, params);else return assign(/* @__PURE__ */new Error(), {\n    type,\n    [NavigationFailureSymbol]: true\n  }, params);\n}\nfunction isNavigationFailure(error, type) {\n  return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));\n}\nconst propertiesToLog = [\"params\", \"query\", \"hash\"];\nfunction stringifyRoute(to) {\n  if (typeof to === \"string\") return to;\n  if (to.path != null) return to.path;\n  const location = {};\n  for (const key of propertiesToLog) if (key in to) location[key] = to[key];\n  return JSON.stringify(location, null, 2);\n}\n\n//#endregion\n//#region src/query.ts\n/**\n* Transforms a queryString into a {@link LocationQuery} object. Accept both, a\n* version with the leading `?` and without Should work as URLSearchParams\n\n* @internal\n*\n* @param search - search string to parse\n* @returns a query object\n*/\nfunction parseQuery(search) {\n  const query = {};\n  if (search === \"\" || search === \"?\") return query;\n  const searchParams = (search[0] === \"?\" ? search.slice(1) : search).split(\"&\");\n  for (let i = 0; i < searchParams.length; ++i) {\n    const searchParam = searchParams[i].replace(PLUS_RE, \" \");\n    const eqPos = searchParam.indexOf(\"=\");\n    const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));\n    const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));\n    if (key in query) {\n      let currentValue = query[key];\n      if (!isArray(currentValue)) currentValue = query[key] = [currentValue];\n      currentValue.push(value);\n    } else query[key] = value;\n  }\n  return query;\n}\n/**\n* Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it\n* doesn't prepend a `?`\n*\n* @internal\n*\n* @param query - query object to stringify\n* @returns string version of the query without the leading `?`\n*/\nfunction stringifyQuery(query) {\n  let search = \"\";\n  for (let key in query) {\n    const value = query[key];\n    key = encodeQueryKey(key);\n    if (value == null) {\n      if (value !== void 0) search += (search.length ? \"&\" : \"\") + key;\n      continue;\n    }\n    (isArray(value) ? value.map(v => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)]).forEach(value$1 => {\n      if (value$1 !== void 0) {\n        search += (search.length ? \"&\" : \"\") + key;\n        if (value$1 != null) search += \"=\" + value$1;\n      }\n    });\n  }\n  return search;\n}\n/**\n* Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting\n* numbers into strings, removing keys with an undefined value and replacing\n* undefined with null in arrays\n*\n* @param query - query object to normalize\n* @returns a normalized query object\n*/\nfunction normalizeQuery(query) {\n  const normalizedQuery = {};\n  for (const key in query) {\n    const value = query[key];\n    if (value !== void 0) normalizedQuery[key] = isArray(value) ? value.map(v => v == null ? null : \"\" + v) : value == null ? value : \"\" + value;\n  }\n  return normalizedQuery;\n}\n\n//#endregion\n//#region src/injectionSymbols.ts\n/**\n* RouteRecord being rendered by the closest ancestor Router View. Used for\n* `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View\n* Location Matched\n*\n* @internal\n*/\nconst matchedRouteKey = Symbol(process.env.NODE_ENV !== \"production\" ? \"router view location matched\" : \"\");\n/**\n* Allows overriding the router view depth to control which component in\n* `matched` is rendered. rvd stands for Router View Depth\n*\n* @internal\n*/\nconst viewDepthKey = Symbol(process.env.NODE_ENV !== \"production\" ? \"router view depth\" : \"\");\n/**\n* Allows overriding the router instance returned by `useRouter` in tests. r\n* stands for router\n*\n* @internal\n*/\nconst routerKey = Symbol(process.env.NODE_ENV !== \"production\" ? \"router\" : \"\");\n/**\n* Allows overriding the current route returned by `useRoute` in tests. rl\n* stands for route location\n*\n* @internal\n*/\nconst routeLocationKey = Symbol(process.env.NODE_ENV !== \"production\" ? \"route location\" : \"\");\n/**\n* Allows overriding the current route used by router-view. Internally this is\n* used when the `route` prop is passed.\n*\n* @internal\n*/\nconst routerViewLocationKey = Symbol(process.env.NODE_ENV !== \"production\" ? \"router view location\" : \"\");\n\n//#endregion\n//#region src/utils/callbacks.ts\n/**\n* Create a list of callbacks that can be reset. Used to create before and after navigation guards list\n*/\nfunction useCallbacks() {\n  let handlers = [];\n  function add(handler) {\n    handlers.push(handler);\n    return () => {\n      const i = handlers.indexOf(handler);\n      if (i > -1) handlers.splice(i, 1);\n    };\n  }\n  function reset() {\n    handlers = [];\n  }\n  return {\n    add,\n    list: () => handlers.slice(),\n    reset\n  };\n}\n\n//#endregion\n//#region src/navigationGuards.ts\nfunction registerGuard(record, name, guard) {\n  const removeFromList = () => {\n    record[name].delete(guard);\n  };\n  onUnmounted(removeFromList);\n  onDeactivated(removeFromList);\n  onActivated(() => {\n    record[name].add(guard);\n  });\n  record[name].add(guard);\n}\n/**\n* Add a navigation guard that triggers whenever the component for the current\n* location is about to be left. Similar to {@link beforeRouteLeave} but can be\n* used in any component. The guard is removed when the component is unmounted.\n*\n* @param leaveGuard - {@link NavigationGuard}\n*/\nfunction onBeforeRouteLeave(leaveGuard) {\n  if (process.env.NODE_ENV !== \"production\" && !getCurrentInstance()) {\n    warn$1(\"getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function\");\n    return;\n  }\n  const activeRecord = inject(matchedRouteKey, {}).value;\n  if (!activeRecord) {\n    process.env.NODE_ENV !== \"production\" && warn$1(\"No active route record was found when calling `onBeforeRouteLeave()`. Make sure you call this function inside a component child of <router-view>. Maybe you called it inside of App.vue?\");\n    return;\n  }\n  registerGuard(activeRecord, \"leaveGuards\", leaveGuard);\n}\n/**\n* Add a navigation guard that triggers whenever the current location is about\n* to be updated. Similar to {@link beforeRouteUpdate} but can be used in any\n* component. The guard is removed when the component is unmounted.\n*\n* @param updateGuard - {@link NavigationGuard}\n*/\nfunction onBeforeRouteUpdate(updateGuard) {\n  if (process.env.NODE_ENV !== \"production\" && !getCurrentInstance()) {\n    warn$1(\"getCurrentInstance() returned null. onBeforeRouteUpdate() must be called at the top of a setup function\");\n    return;\n  }\n  const activeRecord = inject(matchedRouteKey, {}).value;\n  if (!activeRecord) {\n    process.env.NODE_ENV !== \"production\" && warn$1(\"No active route record was found when calling `onBeforeRouteUpdate()`. Make sure you call this function inside a component child of <router-view>. Maybe you called it inside of App.vue?\");\n    return;\n  }\n  registerGuard(activeRecord, \"updateGuards\", updateGuard);\n}\nfunction guardToPromiseFn(guard, to, from, record, name, runWithContext = fn => fn()) {\n  const enterCallbackArray = record && (record.enterCallbacks[name] = record.enterCallbacks[name] || []);\n  return () => new Promise((resolve, reject) => {\n    const next = valid => {\n      if (valid === false) reject(createRouterError(ErrorTypes.NAVIGATION_ABORTED, {\n        from,\n        to\n      }));else if (valid instanceof Error) reject(valid);else if (isRouteLocation(valid)) reject(createRouterError(ErrorTypes.NAVIGATION_GUARD_REDIRECT, {\n        from: to,\n        to: valid\n      }));else {\n        if (enterCallbackArray && record.enterCallbacks[name] === enterCallbackArray && typeof valid === \"function\") enterCallbackArray.push(valid);\n        resolve();\n      }\n    };\n    const guardReturn = runWithContext(() => guard.call(record && record.instances[name], to, from, process.env.NODE_ENV !== \"production\" ? canOnlyBeCalledOnce(next, to, from) : next));\n    let guardCall = Promise.resolve(guardReturn);\n    if (guard.length < 3) guardCall = guardCall.then(next);\n    if (process.env.NODE_ENV !== \"production\" && guard.length > 2) {\n      const message = `The \"next\" callback was never called inside of ${guard.name ? \"\\\"\" + guard.name + \"\\\"\" : \"\"}:\\n${guard.toString()}\\n. If you are returning a value instead of calling \"next\", make sure to remove the \"next\" parameter from your function.`;\n      if (typeof guardReturn === \"object\" && \"then\" in guardReturn) guardCall = guardCall.then(resolvedValue => {\n        if (!next._called) {\n          warn$1(message);\n          return Promise.reject(/* @__PURE__ */new Error(\"Invalid navigation guard\"));\n        }\n        return resolvedValue;\n      });else if (guardReturn !== void 0) {\n        if (!next._called) {\n          warn$1(message);\n          reject(/* @__PURE__ */new Error(\"Invalid navigation guard\"));\n          return;\n        }\n      }\n    }\n    guardCall.catch(err => reject(err));\n  });\n}\nfunction canOnlyBeCalledOnce(next, to, from) {\n  let called = 0;\n  return function () {\n    if (called++ === 1) warn$1(`The \"next\" callback was called more than once in one navigation guard when going from \"${from.fullPath}\" to \"${to.fullPath}\". It should be called exactly one time in each navigation guard. This will fail in production.`);\n    next._called = true;\n    if (called === 1) next.apply(null, arguments);\n  };\n}\nfunction extractComponentsGuards(matched, guardType, to, from, runWithContext = fn => fn()) {\n  const guards = [];\n  for (const record of matched) {\n    if (process.env.NODE_ENV !== \"production\" && !record.components && record.children && !record.children.length) warn$1(`Record with path \"${record.path}\" is either missing a \"component(s)\" or \"children\" property.`);\n    for (const name in record.components) {\n      let rawComponent = record.components[name];\n      if (process.env.NODE_ENV !== \"production\") {\n        if (!rawComponent || typeof rawComponent !== \"object\" && typeof rawComponent !== \"function\") {\n          warn$1(`Component \"${name}\" in record with path \"${record.path}\" is not a valid component. Received \"${String(rawComponent)}\".`);\n          throw new Error(\"Invalid route component\");\n        } else if (\"then\" in rawComponent) {\n          warn$1(`Component \"${name}\" in record with path \"${record.path}\" is a Promise instead of a function that returns a Promise. Did you write \"import('./MyPage.vue')\" instead of \"() => import('./MyPage.vue')\" ? This will break in production if not fixed.`);\n          const promise = rawComponent;\n          rawComponent = () => promise;\n        } else if (rawComponent.__asyncLoader && !rawComponent.__warnedDefineAsync) {\n          rawComponent.__warnedDefineAsync = true;\n          warn$1(`Component \"${name}\" in record with path \"${record.path}\" is defined using \"defineAsyncComponent()\". Write \"() => import('./MyPage.vue')\" instead of \"defineAsyncComponent(() => import('./MyPage.vue'))\".`);\n        }\n      }\n      if (guardType !== \"beforeRouteEnter\" && !record.instances[name]) continue;\n      if (isRouteComponent(rawComponent)) {\n        const guard = (rawComponent.__vccOpts || rawComponent)[guardType];\n        guard && guards.push(guardToPromiseFn(guard, to, from, record, name, runWithContext));\n      } else {\n        let componentPromise = rawComponent();\n        if (process.env.NODE_ENV !== \"production\" && !(\"catch\" in componentPromise)) {\n          warn$1(`Component \"${name}\" in record with path \"${record.path}\" is a function that does not return a Promise. If you were passing a functional component, make sure to add a \"displayName\" to the component. This will break in production if not fixed.`);\n          componentPromise = Promise.resolve(componentPromise);\n        }\n        guards.push(() => componentPromise.then(resolved => {\n          if (!resolved) throw new Error(`Couldn't resolve component \"${name}\" at \"${record.path}\"`);\n          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;\n          record.mods[name] = resolved;\n          record.components[name] = resolvedComponent;\n          const guard = (resolvedComponent.__vccOpts || resolvedComponent)[guardType];\n          return guard && guardToPromiseFn(guard, to, from, record, name, runWithContext)();\n        }));\n      }\n    }\n  }\n  return guards;\n}\n/**\n* Ensures a route is loaded, so it can be passed as o prop to `<RouterView>`.\n*\n* @param route - resolved route to load\n*/\nfunction loadRouteLocation(route) {\n  return route.matched.every(record => record.redirect) ? Promise.reject(/* @__PURE__ */new Error(\"Cannot load a route that redirects.\")) : Promise.all(route.matched.map(record => record.components && Promise.all(Object.keys(record.components).reduce((promises, name) => {\n    const rawComponent = record.components[name];\n    if (typeof rawComponent === \"function\" && !(\"displayName\" in rawComponent)) promises.push(rawComponent().then(resolved => {\n      if (!resolved) return Promise.reject(/* @__PURE__ */new Error(`Couldn't resolve component \"${name}\" at \"${record.path}\". Ensure you passed a function that returns a promise.`));\n      const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;\n      record.mods[name] = resolved;\n      record.components[name] = resolvedComponent;\n    }));\n    return promises;\n  }, [])))).then(() => route);\n}\n/**\n* Split the leaving, updating, and entering records.\n* @internal\n*\n* @param  to - Location we are navigating to\n* @param from - Location we are navigating from\n*/\nfunction extractChangingRecords(to, from) {\n  const leavingRecords = [];\n  const updatingRecords = [];\n  const enteringRecords = [];\n  const len = Math.max(from.matched.length, to.matched.length);\n  for (let i = 0; i < len; i++) {\n    const recordFrom = from.matched[i];\n    if (recordFrom) if (to.matched.find(record => isSameRouteRecord(record, recordFrom))) updatingRecords.push(recordFrom);else leavingRecords.push(recordFrom);\n    const recordTo = to.matched[i];\n    if (recordTo) {\n      if (!from.matched.find(record => isSameRouteRecord(record, recordTo))) enteringRecords.push(recordTo);\n    }\n  }\n  return [leavingRecords, updatingRecords, enteringRecords];\n}\n\n//#endregion\n//#region src/devtools.ts\n/**\n* Copies a route location and removes any problematic properties that cannot be shown in devtools (e.g. Vue instances).\n*\n* @param routeLocation - routeLocation to format\n* @param tooltip - optional tooltip\n* @returns a copy of the routeLocation\n*/\nfunction formatRouteLocation(routeLocation, tooltip) {\n  const copy = assign({}, routeLocation, {\n    matched: routeLocation.matched.map(matched => omit(matched, [\"instances\", \"children\", \"aliasOf\"]))\n  });\n  return {\n    _custom: {\n      type: null,\n      readOnly: true,\n      display: routeLocation.fullPath,\n      tooltip,\n      value: copy\n    }\n  };\n}\nfunction formatDisplay(display) {\n  return {\n    _custom: {\n      display\n    }\n  };\n}\nlet routerId = 0;\nfunction addDevtools(app, router, matcher) {\n  if (router.__hasDevtools) return;\n  router.__hasDevtools = true;\n  const id = routerId++;\n  setupDevtoolsPlugin({\n    id: \"org.vuejs.router\" + (id ? \".\" + id : \"\"),\n    label: \"Vue Router\",\n    packageName: \"vue-router\",\n    homepage: \"https://router.vuejs.org\",\n    logo: \"https://router.vuejs.org/logo.png\",\n    componentStateTypes: [\"Routing\"],\n    app\n  }, api => {\n    if (typeof api.now !== \"function\") warn$1(\"[Vue Router]: You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.\");\n    api.on.inspectComponent((payload, ctx) => {\n      if (payload.instanceData) payload.instanceData.state.push({\n        type: \"Routing\",\n        key: \"$route\",\n        editable: false,\n        value: formatRouteLocation(router.currentRoute.value, \"Current Route\")\n      });\n    });\n    api.on.visitComponentTree(({\n      treeNode: node,\n      componentInstance\n    }) => {\n      if (componentInstance.__vrv_devtools) {\n        const info = componentInstance.__vrv_devtools;\n        node.tags.push({\n          label: (info.name ? `${info.name.toString()}: ` : \"\") + info.path,\n          textColor: 0,\n          tooltip: \"This component is rendered by &lt;router-view&gt;\",\n          backgroundColor: PINK_500\n        });\n      }\n      if (isArray(componentInstance.__vrl_devtools)) {\n        componentInstance.__devtoolsApi = api;\n        componentInstance.__vrl_devtools.forEach(devtoolsData => {\n          let label = devtoolsData.route.path;\n          let backgroundColor = ORANGE_400;\n          let tooltip = \"\";\n          let textColor = 0;\n          if (devtoolsData.error) {\n            label = devtoolsData.error;\n            backgroundColor = RED_100;\n            textColor = RED_700;\n          } else if (devtoolsData.isExactActive) {\n            backgroundColor = LIME_500;\n            tooltip = \"This is exactly active\";\n          } else if (devtoolsData.isActive) {\n            backgroundColor = BLUE_600;\n            tooltip = \"This link is active\";\n          }\n          node.tags.push({\n            label,\n            textColor,\n            tooltip,\n            backgroundColor\n          });\n        });\n      }\n    });\n    watch(router.currentRoute, () => {\n      refreshRoutesView();\n      api.notifyComponentUpdate();\n      api.sendInspectorTree(routerInspectorId);\n      api.sendInspectorState(routerInspectorId);\n    });\n    const navigationsLayerId = \"router:navigations:\" + id;\n    api.addTimelineLayer({\n      id: navigationsLayerId,\n      label: `Router${id ? \" \" + id : \"\"} Navigations`,\n      color: 4237508\n    });\n    router.onError((error, to) => {\n      api.addTimelineEvent({\n        layerId: navigationsLayerId,\n        event: {\n          title: \"Error during Navigation\",\n          subtitle: to.fullPath,\n          logType: \"error\",\n          time: api.now(),\n          data: {\n            error\n          },\n          groupId: to.meta.__navigationId\n        }\n      });\n    });\n    let navigationId = 0;\n    router.beforeEach((to, from) => {\n      const data = {\n        guard: formatDisplay(\"beforeEach\"),\n        from: formatRouteLocation(from, \"Current Location during this navigation\"),\n        to: formatRouteLocation(to, \"Target location\")\n      };\n      Object.defineProperty(to.meta, \"__navigationId\", {\n        value: navigationId++\n      });\n      api.addTimelineEvent({\n        layerId: navigationsLayerId,\n        event: {\n          time: api.now(),\n          title: \"Start of navigation\",\n          subtitle: to.fullPath,\n          data,\n          groupId: to.meta.__navigationId\n        }\n      });\n    });\n    router.afterEach((to, from, failure) => {\n      const data = {\n        guard: formatDisplay(\"afterEach\")\n      };\n      if (failure) {\n        data.failure = {\n          _custom: {\n            type: Error,\n            readOnly: true,\n            display: failure ? failure.message : \"\",\n            tooltip: \"Navigation Failure\",\n            value: failure\n          }\n        };\n        data.status = formatDisplay(\"❌\");\n      } else data.status = formatDisplay(\"✅\");\n      data.from = formatRouteLocation(from, \"Current Location during this navigation\");\n      data.to = formatRouteLocation(to, \"Target location\");\n      api.addTimelineEvent({\n        layerId: navigationsLayerId,\n        event: {\n          title: \"End of navigation\",\n          subtitle: to.fullPath,\n          time: api.now(),\n          data,\n          logType: failure ? \"warning\" : \"default\",\n          groupId: to.meta.__navigationId\n        }\n      });\n    });\n    /**\n    * Inspector of Existing routes\n    */\n    const routerInspectorId = \"router-inspector:\" + id;\n    api.addInspector({\n      id: routerInspectorId,\n      label: \"Routes\" + (id ? \" \" + id : \"\"),\n      icon: \"book\",\n      treeFilterPlaceholder: \"Search routes\"\n    });\n    function refreshRoutesView() {\n      if (!activeRoutesPayload) return;\n      const payload = activeRoutesPayload;\n      let routes = matcher.getRoutes().filter(route => !route.parent || !route.parent.record.components);\n      routes.forEach(resetMatchStateOnRouteRecord);\n      if (payload.filter) routes = routes.filter(route => isRouteMatching(route, payload.filter.toLowerCase()));\n      routes.forEach(route => markRouteRecordActive(route, router.currentRoute.value));\n      payload.rootNodes = routes.map(formatRouteRecordForInspector);\n    }\n    let activeRoutesPayload;\n    api.on.getInspectorTree(payload => {\n      activeRoutesPayload = payload;\n      if (payload.app === app && payload.inspectorId === routerInspectorId) refreshRoutesView();\n    });\n    /**\n    * Display information about the currently selected route record\n    */\n    api.on.getInspectorState(payload => {\n      if (payload.app === app && payload.inspectorId === routerInspectorId) {\n        const route = matcher.getRoutes().find(route$1 => route$1.record.__vd_id === payload.nodeId);\n        if (route) payload.state = {\n          options: formatRouteRecordMatcherForStateInspector(route)\n        };\n      }\n    });\n    api.sendInspectorTree(routerInspectorId);\n    api.sendInspectorState(routerInspectorId);\n  });\n}\nfunction modifierForKey(key) {\n  if (key.optional) return key.repeatable ? \"*\" : \"?\";else return key.repeatable ? \"+\" : \"\";\n}\nfunction formatRouteRecordMatcherForStateInspector(route) {\n  const {\n    record\n  } = route;\n  const fields = [{\n    editable: false,\n    key: \"path\",\n    value: record.path\n  }];\n  if (record.name != null) fields.push({\n    editable: false,\n    key: \"name\",\n    value: record.name\n  });\n  fields.push({\n    editable: false,\n    key: \"regexp\",\n    value: route.re\n  });\n  if (route.keys.length) fields.push({\n    editable: false,\n    key: \"keys\",\n    value: {\n      _custom: {\n        type: null,\n        readOnly: true,\n        display: route.keys.map(key => `${key.name}${modifierForKey(key)}`).join(\" \"),\n        tooltip: \"Param keys\",\n        value: route.keys\n      }\n    }\n  });\n  if (record.redirect != null) fields.push({\n    editable: false,\n    key: \"redirect\",\n    value: record.redirect\n  });\n  if (route.alias.length) fields.push({\n    editable: false,\n    key: \"aliases\",\n    value: route.alias.map(alias => alias.record.path)\n  });\n  if (Object.keys(route.record.meta).length) fields.push({\n    editable: false,\n    key: \"meta\",\n    value: route.record.meta\n  });\n  fields.push({\n    key: \"score\",\n    editable: false,\n    value: {\n      _custom: {\n        type: null,\n        readOnly: true,\n        display: route.score.map(score => score.join(\", \")).join(\" | \"),\n        tooltip: \"Score used to sort routes\",\n        value: route.score\n      }\n    }\n  });\n  return fields;\n}\n/**\n* Extracted from tailwind palette\n*/\nconst PINK_500 = 15485081;\nconst BLUE_600 = 2450411;\nconst LIME_500 = 8702998;\nconst CYAN_400 = 2282478;\nconst ORANGE_400 = 16486972;\nconst DARK = 6710886;\nconst RED_100 = 16704226;\nconst RED_700 = 12131356;\nfunction formatRouteRecordForInspector(route) {\n  const tags = [];\n  const {\n    record\n  } = route;\n  if (record.name != null) tags.push({\n    label: String(record.name),\n    textColor: 0,\n    backgroundColor: CYAN_400\n  });\n  if (record.aliasOf) tags.push({\n    label: \"alias\",\n    textColor: 0,\n    backgroundColor: ORANGE_400\n  });\n  if (route.__vd_match) tags.push({\n    label: \"matches\",\n    textColor: 0,\n    backgroundColor: PINK_500\n  });\n  if (route.__vd_exactActive) tags.push({\n    label: \"exact\",\n    textColor: 0,\n    backgroundColor: LIME_500\n  });\n  if (route.__vd_active) tags.push({\n    label: \"active\",\n    textColor: 0,\n    backgroundColor: BLUE_600\n  });\n  if (record.redirect) tags.push({\n    label: typeof record.redirect === \"string\" ? `redirect: ${record.redirect}` : \"redirects\",\n    textColor: 16777215,\n    backgroundColor: DARK\n  });\n  let id = record.__vd_id;\n  if (id == null) {\n    id = String(routeRecordId++);\n    record.__vd_id = id;\n  }\n  return {\n    id,\n    label: record.path,\n    tags,\n    children: route.children.map(formatRouteRecordForInspector)\n  };\n}\nlet routeRecordId = 0;\nconst EXTRACT_REGEXP_RE = /^\\/(.*)\\/([a-z]*)$/;\nfunction markRouteRecordActive(route, currentRoute) {\n  const isExactActive = currentRoute.matched.length && isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);\n  route.__vd_exactActive = route.__vd_active = isExactActive;\n  if (!isExactActive) route.__vd_active = currentRoute.matched.some(match => isSameRouteRecord(match, route.record));\n  route.children.forEach(childRoute => markRouteRecordActive(childRoute, currentRoute));\n}\nfunction resetMatchStateOnRouteRecord(route) {\n  route.__vd_match = false;\n  route.children.forEach(resetMatchStateOnRouteRecord);\n}\nfunction isRouteMatching(route, filter) {\n  const found = String(route.re).match(EXTRACT_REGEXP_RE);\n  route.__vd_match = false;\n  if (!found || found.length < 3) return false;\n  if (new RegExp(found[1].replace(/\\$$/, \"\"), found[2]).test(filter)) {\n    route.children.forEach(child => isRouteMatching(child, filter));\n    if (route.record.path !== \"/\" || filter === \"/\") {\n      route.__vd_match = route.re.test(filter);\n      return true;\n    }\n    return false;\n  }\n  const path = route.record.path.toLowerCase();\n  const decodedPath = decode(path);\n  if (!filter.startsWith(\"/\") && (decodedPath.includes(filter) || path.includes(filter))) return true;\n  if (decodedPath.startsWith(filter) || path.startsWith(filter)) return true;\n  if (route.record.name && String(route.record.name).includes(filter)) return true;\n  return route.children.some(child => isRouteMatching(child, filter));\n}\nfunction omit(obj, keys) {\n  const ret = {};\n  for (const key in obj) if (!keys.includes(key)) ret[key] = obj[key];\n  return ret;\n}\n\n//#endregion\nexport { ErrorTypes, NEW_stringifyURL, NavigationDirection, NavigationFailureType, NavigationType, START, START_LOCATION_NORMALIZED, addDevtools, applyToParams, assign, computeScrollPosition, createHref, createRouterError, decode, encodeHash, encodeParam, encodePath, extractChangingRecords, extractComponentsGuards, getSavedScrollPosition, getScrollKey, guardToPromiseFn, identityFn, isArray, isBrowser, isNavigationFailure, isRouteLocation, isRouteName, isSameRouteLocation, isSameRouteLocationParams, isSameRouteRecord, loadRouteLocation, matchedRouteKey, mergeOptions, noop, normalizeBase, normalizeQuery, onBeforeRouteLeave, onBeforeRouteUpdate, parseQuery, parseURL, resolveRelativePath, routeLocationKey, routerKey, routerViewLocationKey, saveScrollPosition, scrollToPosition, stringifyQuery, stringifyURL, stripBase, useCallbacks, viewDepthKey, warn$1 as warn };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}