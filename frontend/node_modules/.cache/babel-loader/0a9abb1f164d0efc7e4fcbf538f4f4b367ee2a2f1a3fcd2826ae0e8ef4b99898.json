{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Color from \"../Core/Color.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport ComputeCommand from \"../Renderer/ComputeCommand.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport CubeMap from \"../Renderer/CubeMap.js\";\nimport Framebuffer from \"../Renderer/Framebuffer.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport Atmosphere from \"./Atmosphere.js\";\nimport DynamicAtmosphereLightingType from \"./DynamicAtmosphereLightingType.js\";\nimport AtmosphereCommon from \"../Shaders/AtmosphereCommon.js\";\nimport ComputeIrradianceFS from \"../Shaders/ComputeIrradianceFS.js\";\nimport ComputeRadianceMapFS from \"../Shaders/ComputeRadianceMapFS.js\";\nimport ConvolveSpecularMapFS from \"../Shaders/ConvolveSpecularMapFS.js\";\nimport ConvolveSpecularMapVS from \"../Shaders/ConvolveSpecularMapVS.js\";\n\n/**\n * @typedef {object} DynamicEnvironmentMapManager.ConstructorOptions\n * Options for the DynamicEnvironmentMapManager constructor\n * @property {boolean} [enabled=true] If true, the environment map and related properties will continue to update.\n * @property {number} [mipmapLevels=7] The number of mipmap levels to generate for specular maps. More mipmap levels will produce a higher resolution specular reflection.\n * @property {number} [maximumSecondsDifference=3600] The maximum amount of elapsed seconds before a new environment map is created.\n * @property {number} [maximumPositionEpsilon=1000] The maximum difference in position before a new environment map is created, in meters. Small differences in position will not visibly affect results.\n * @property {number} [atmosphereScatteringIntensity=2.0] The intensity of the scattered light emitted from the atmosphere. This should be adjusted relative to the value of {@link Scene.light} intensity.\n * @property {number} [gamma=1.0] The gamma correction to apply to the range of light emitted from the environment. 1.0 uses the unmodified emitted light color.\n * @property {number} [brightness=1.0] The brightness of light emitted from the environment. 1.0 uses the unmodified emitted environment color. Less than 1.0 makes the light darker while greater than 1.0 makes it brighter.\n * @property {number} [saturation=1.0] The saturation of the light emitted from the environment. 1.0 uses the unmodified emitted environment color. Less than 1.0 reduces the saturation while greater than 1.0 increases it.\n * @property {Color} [groundColor=DynamicEnvironmentMapManager.AVERAGE_EARTH_GROUND_COLOR] Solid color used to represent the ground.\n * @property {number} [groundAlbedo=0.31] The percentage of light reflected from the ground. The average earth albedo is 0.31.\n */\n\n/**\n * Generates an environment map at the given position based on scene's current lighting conditions. From this, it produces multiple levels of specular maps and spherical harmonic coefficients than can be used with {@link ImageBasedLighting} for models or tilesets.\n * @alias DynamicEnvironmentMapManager\n * @constructor\n * @param {DynamicEnvironmentMapManager.ConstructorOptions} [options] An object describing initialization options.\n *\n * @example\n * // Enable time-of-day environment mapping in a scene\n * scene.atmosphere.dynamicLighting = Cesium.DynamicAtmosphereLightingType.SUNLIGHT;\n *\n * // Decrease the directional lighting contribution\n * scene.light.intensity = 0.5\n *\n * // Increase the intensity of of the environment map lighting contribution\n * const environmentMapManager = tileset.environmentMapManager;\n * environmentMapManager.atmosphereScatteringIntensity = 3.0;\n *\n * @example\n * // Change the ground color used for a model's environment map to a forest green\n * const environmentMapManager = model.environmentMapManager;\n * environmentMapManager.groundColor = Cesium.Color.fromCssColorString(\"#203b34\");\n */\nfunction DynamicEnvironmentMapManager(options) {\n  this._position = undefined;\n  this._radianceMapDirty = false;\n  this._radianceCommandsDirty = false;\n  this._convolutionsCommandsDirty = false;\n  this._irradianceCommandDirty = false;\n  this._irradianceTextureDirty = false;\n  this._sphericalHarmonicCoefficientsDirty = false;\n  this._shouldRegenerateShaders = false;\n  this._shouldReset = false;\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const mipmapLevels = Math.min(options.mipmapLevels ?? 7, Math.log2(ContextLimits.maximumCubeMapSize));\n  this._mipmapLevels = mipmapLevels;\n  this._radianceMapComputeCommands = new Array(6);\n  this._convolutionComputeCommands = new Array((mipmapLevels - 1) * 6);\n  this._irradianceComputeCommand = undefined;\n  this._radianceMapFS = undefined;\n  this._irradianceMapFS = undefined;\n  this._convolveSP = undefined;\n  this._va = undefined;\n  this._radianceMapTextures = new Array(6);\n  this._specularMapTextures = new Array((mipmapLevels - 1) * 6);\n  this._radianceCubeMap = undefined;\n  this._irradianceMapTexture = undefined;\n  this._sphericalHarmonicCoefficients = DynamicEnvironmentMapManager.DEFAULT_SPHERICAL_HARMONIC_COEFFICIENTS.slice();\n  this._lastTime = new JulianDate();\n  const width = Math.pow(2, mipmapLevels - 1);\n  this._textureDimensions = new Cartesian2(width, width);\n  this._radiiAndDynamicAtmosphereColor = new Cartesian3();\n  this._sceneEnvironmentMap = undefined;\n  this._backgroundColor = undefined;\n\n  // If this DynamicEnvironmentMapManager has an owner, only its owner should update or destroy it.\n  // This is because in a Cesium3DTileset multiple models may reference one tileset's DynamicEnvironmentMapManager.\n  this._owner = undefined;\n\n  /**\n   * If true, the environment map and related properties will continue to update.\n   * @type {boolean}\n   * @default true\n   */\n  this.enabled = options.enabled ?? true;\n\n  /**\n   * Disables updates. For internal use.\n   * @private\n   * @default true\n   */\n  this.shouldUpdate = true;\n\n  /**\n   * The maximum amount of elapsed seconds before a new environment map is created.\n   * @type {number}\n   * @default 3600\n   */\n  this.maximumSecondsDifference = options.maximumSecondsDifference ?? 60 * 60;\n\n  /**\n   * The maximum difference in position before a new environment map is created, in meters. Small differences in position will not visibly affect results.\n   * @type {number}\n   * @default 1000\n   */\n  this.maximumPositionEpsilon = options.maximumPositionEpsilon ?? 1000.0;\n\n  /**\n   * The intensity of the scattered light emitted from the atmosphere. This should be adjusted relative to the value of {@link Scene.light} intensity.\n   * @type {number}\n   * @default 2.0\n   * @see DirectionalLight.intensity\n   * @see SunLight.intensity\n   */\n  this.atmosphereScatteringIntensity = options.atmosphereScatteringIntensity ?? 2.0;\n\n  /**\n   * The gamma correction to apply to the range of light emitted from the environment. 1.0 uses the unmodified incoming light color.\n   * @type {number}\n   * @default 1.0\n   */\n  this.gamma = options.gamma ?? 1.0;\n\n  /**\n   * The brightness of light emitted from the environment. 1.0 uses the unmodified emitted environment color. Less than 1.0\n   * makes the light darker while greater than 1.0 makes it brighter.\n   * @type {number}\n   * @default 1.0\n   */\n  this.brightness = options.brightness ?? 1.0;\n\n  /**\n   * The saturation of the light emitted from the environment. 1.0 uses the unmodified emitted environment color. Less than 1.0 reduces the\n   * saturation while greater than 1.0 increases it.\n   * @type {number}\n   * @default 1.0\n   */\n  this.saturation = options.saturation ?? 1.0;\n\n  /**\n   * Solid color used to represent the ground.\n   * @type {Color}\n   * @default DynamicEnvironmentMapManager.AVERAGE_EARTH_GROUND_COLOR\n   */\n  this.groundColor = options.groundColor ?? DynamicEnvironmentMapManager.AVERAGE_EARTH_GROUND_COLOR;\n\n  /**\n   * The percentage of light reflected from the ground. The average earth albedo is 0.31.\n   * @type {number}\n   * @default 0.31\n   */\n  this.groundAlbedo = options.groundAlbedo ?? 0.31;\n}\nObject.defineProperties(DynamicEnvironmentMapManager.prototype, {\n  /**\n   * A reference to the DynamicEnvironmentMapManager's owner, if any.\n   * @memberof DynamicEnvironmentMapManager.prototype\n   * @type {object|undefined}\n   * @readonly\n   * @private\n   */\n  owner: {\n    get: function () {\n      return this._owner;\n    }\n  },\n  /**\n   * True if model shaders need to be regenerated to account for updates.\n   * @memberof DynamicEnvironmentMapManager.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  shouldRegenerateShaders: {\n    get: function () {\n      return this._shouldRegenerateShaders;\n    }\n  },\n  /**\n   * The position around which the environment map is generated.\n   * @memberof DynamicEnvironmentMapManager.prototype\n   * @type {Cartesian3|undefined}\n   */\n  position: {\n    get: function () {\n      return this._position;\n    },\n    set: function (value) {\n      if (Cartesian3.equalsEpsilon(value, this._position, 0.0, this.maximumPositionEpsilon)) {\n        return;\n      }\n      this._position = Cartesian3.clone(value, this._position);\n      this._shouldReset = true;\n    }\n  },\n  /**\n   * The computed radiance map, or <code>undefined</code> if it has not yet been created.\n   * @memberof DynamicEnvironmentMapManager.prototype\n   * @type {CubeMap|undefined}\n   * @readonly\n   * @private\n   */\n  radianceCubeMap: {\n    get: function () {\n      return this._radianceCubeMap;\n    }\n  },\n  /**\n   * The maximum number of mip levels available in the radiance cubemap.\n   * @memberof DynamicEnvironmentMapManager.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  maximumMipmapLevel: {\n    get: function () {\n      return this._mipmapLevels;\n    }\n  },\n  /**\n   * The third order spherical harmonic coefficients used for the diffuse color of image-based lighting.\n   * <p>\n   * There are nine <code>Cartesian3</code> coefficients.\n   * The order of the coefficients is: L<sub>0,0</sub>, L<sub>1,-1</sub>, L<sub>1,0</sub>, L<sub>1,1</sub>, L<sub>2,-2</sub>, L<sub>2,-1</sub>, L<sub>2,0</sub>, L<sub>2,1</sub>, L<sub>2,2</sub>\n   * </p>\n   * @memberof DynamicEnvironmentMapManager.prototype\n   * @readonly\n   * @type {Cartesian3[]}\n   * @see {@link https://graphics.stanford.edu/papers/envmap/envmap.pdf|An Efficient Representation for Irradiance Environment Maps}\n   * @private\n   */\n  sphericalHarmonicCoefficients: {\n    get: function () {\n      return this._sphericalHarmonicCoefficients;\n    }\n  }\n});\n\n// Internally manage a queue of commands across all instances to prevent too many commands from being added in a single frame and using too much memory at once.\nDynamicEnvironmentMapManager._maximumComputeCommandCount = 8; // This value is updated once a context is created.\nDynamicEnvironmentMapManager._activeComputeCommandCount = 0;\nDynamicEnvironmentMapManager._nextFrameCommandQueue = [];\n/**\n * Add a command to the queue. If possible, it will be added to the list of commands for the next frame. Otherwise, it will be added to a backlog\n * and attempted next frame.\n * @private\n * @param {ComputeCommand} command The created command\n * @param {FrameState} frameState The current frame state\n */\nDynamicEnvironmentMapManager._queueCommand = (command, frameState) => {\n  if (DynamicEnvironmentMapManager._activeComputeCommandCount >= DynamicEnvironmentMapManager._maximumComputeCommandCount) {\n    // Command will instead be scheduled next frame\n    DynamicEnvironmentMapManager._nextFrameCommandQueue.push(command);\n    return;\n  }\n  frameState.commandList.push(command);\n  DynamicEnvironmentMapManager._activeComputeCommandCount++;\n};\n/**\n * If there are any backlogged commands, queue up as many as possible for the next frame.\n * @private\n * @param {FrameState} frameState The current frame state\n */\nDynamicEnvironmentMapManager._updateCommandQueue = frameState => {\n  DynamicEnvironmentMapManager._maximumComputeCommandCount = Math.log2(ContextLimits.maximumCubeMapSize); // Scale relative to GPU resources available\n\n  if (DynamicEnvironmentMapManager._nextFrameCommandQueue.length > 0 && DynamicEnvironmentMapManager._activeComputeCommandCount < DynamicEnvironmentMapManager._maximumComputeCommandCount) {\n    let command = DynamicEnvironmentMapManager._nextFrameCommandQueue.shift();\n    while (defined(command) && DynamicEnvironmentMapManager._activeComputeCommandCount < DynamicEnvironmentMapManager._maximumComputeCommandCount) {\n      if (command.owner.isDestroyed() || command.canceled) {\n        command = DynamicEnvironmentMapManager._nextFrameCommandQueue.shift();\n        continue;\n      }\n      frameState.commandList.push(command);\n      DynamicEnvironmentMapManager._activeComputeCommandCount++;\n      command = DynamicEnvironmentMapManager._nextFrameCommandQueue.shift();\n    }\n    if (defined(command)) {\n      DynamicEnvironmentMapManager._nextFrameCommandQueue.push(command);\n    }\n  }\n};\n\n/**\n * Sets the owner for the input DynamicEnvironmentMapManager if there wasn't another owner.\n * Destroys the owner's previous DynamicEnvironmentMapManager if setting is successful.\n * @param {DynamicEnvironmentMapManager} [environmentMapManager] A DynamicEnvironmentMapManager (or undefined) being attached to an object\n * @param {object} owner An Object that should receive the new DynamicEnvironmentMapManager\n * @param {string} key The Key for the Object to reference the DynamicEnvironmentMapManager\n * @private\n */\nDynamicEnvironmentMapManager.setOwner = function (environmentMapManager, owner, key) {\n  // Don't destroy the DynamicEnvironmentMapManager if it's already owned by newOwner\n  if (environmentMapManager === owner[key]) {\n    return;\n  }\n  // Destroy the existing DynamicEnvironmentMapManager, if any\n  owner[key] = owner[key] && owner[key].destroy();\n  if (defined(environmentMapManager)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (defined(environmentMapManager._owner)) {\n      throw new DeveloperError(\"DynamicEnvironmentMapManager should only be assigned to one object\");\n    }\n    //>>includeEnd('debug');\n    environmentMapManager._owner = owner;\n    owner[key] = environmentMapManager;\n  }\n};\n\n/**\n * Cancels any in-progress commands and marks the environment map as dirty.\n * @private\n */\nDynamicEnvironmentMapManager.prototype.reset = function () {\n  let length = this._radianceMapComputeCommands.length;\n  for (let i = 0; i < length; ++i) {\n    if (defined(this._radianceMapComputeCommands[i])) {\n      this._radianceMapComputeCommands[i].canceled = true;\n    }\n    this._radianceMapComputeCommands[i] = undefined;\n  }\n  length = this._convolutionComputeCommands.length;\n  for (let i = 0; i < length; ++i) {\n    if (defined(this._convolutionComputeCommands[i])) {\n      this._convolutionComputeCommands[i].canceled = true;\n    }\n    this._convolutionComputeCommands[i] = undefined;\n  }\n  if (defined(this._irradianceComputeCommand)) {\n    this._irradianceComputeCommand.canceled = true;\n    this._irradianceComputeCommand = undefined;\n  }\n  this._radianceMapDirty = true;\n  this._radianceCommandsDirty = true;\n  this._convolutionsCommandsDirty = false;\n  this._irradianceCommandDirty = false;\n};\nconst scratchPackedAtmosphere = new Cartesian3();\nconst scratchSurfacePosition = new Cartesian3();\n\n/**\n * Update atmosphere properties and returns true if the environment map needs to be regenerated.\n * @param {DynamicEnvironmentMapManager} manager this manager\n * @param {FrameState} frameState the current frameState\n * @returns {boolean} true if the environment map needs to be regenerated.\n * @private\n */\nfunction atmosphereNeedsUpdate(manager, frameState) {\n  const position = manager._position;\n  const atmosphere = frameState.atmosphere;\n  const ellipsoid = frameState.mapProjection.ellipsoid;\n  const surfacePosition = ellipsoid.scaleToGeodeticSurface(position, scratchSurfacePosition);\n  const outerEllipsoidScale = 1.025;\n\n  // Pack outer radius, inner radius, and dynamic atmosphere flag\n  const radiiAndDynamicAtmosphereColor = scratchPackedAtmosphere;\n  const radius = defined(surfacePosition) ? Cartesian3.magnitude(surfacePosition) : ellipsoid.maximumRadius;\n  radiiAndDynamicAtmosphereColor.x = radius * outerEllipsoidScale;\n  radiiAndDynamicAtmosphereColor.y = radius;\n  radiiAndDynamicAtmosphereColor.z = atmosphere.dynamicLighting;\n  if (!Cartesian3.equalsEpsilon(manager._radiiAndDynamicAtmosphereColor, radiiAndDynamicAtmosphereColor) || frameState.environmentMap !== manager._sceneEnvironmentMap || frameState.backgroundColor !== manager._backgroundColor) {\n    Cartesian3.clone(radiiAndDynamicAtmosphereColor, manager._radiiAndDynamicAtmosphereColor);\n    manager._sceneEnvironmentMap = frameState.environmentMap;\n    manager._backgroundColor = frameState.backgroundColor;\n    return true;\n  }\n  return false;\n}\nconst scratchCartesian = new Cartesian3();\nconst scratchMatrix = new Matrix4();\nconst scratchAdjustments = new Cartesian4();\nconst scratchColor = new Color();\n\n/**\n * Renders the highest resolution specular map by creating compute commands for each cube face\n * @param {DynamicEnvironmentMapManager} manager this manager\n * @param {FrameState} frameState the current frameState\n * @private\n */\nfunction updateRadianceMap(manager, frameState) {\n  const context = frameState.context;\n  const textureDimensions = manager._textureDimensions;\n  if (!defined(manager._radianceCubeMap)) {\n    manager._radianceCubeMap = new CubeMap({\n      context: context,\n      width: textureDimensions.x,\n      height: textureDimensions.y,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      pixelFormat: PixelFormat.RGBA\n    });\n  }\n  if (manager._radianceCommandsDirty) {\n    let fs = manager._radianceMapFS;\n    if (!defined(fs)) {\n      fs = new ShaderSource({\n        sources: [AtmosphereCommon, ComputeRadianceMapFS]\n      });\n      manager._radianceMapFS = fs;\n    }\n    if (Atmosphere.requiresColorCorrect(frameState.atmosphere)) {\n      fs.defines.push(\"ATMOSPHERE_COLOR_CORRECT\");\n    }\n    const position = manager._position;\n    const radiiAndDynamicAtmosphereColor = manager._radiiAndDynamicAtmosphereColor;\n    const ellipsoid = frameState.mapProjection.ellipsoid;\n    const enuToFixedFrame = Transforms.eastNorthUpToFixedFrame(position, ellipsoid, scratchMatrix);\n    const adjustments = scratchAdjustments;\n    adjustments.x = manager.brightness;\n    adjustments.y = manager.saturation;\n    adjustments.z = manager.gamma;\n    adjustments.w = manager.atmosphereScatteringIntensity;\n    if (manager.brightness !== 1.0 || manager.saturation !== 1.0 || manager.gamma !== 1.0) {\n      fs.defines.push(\"ENVIRONMENT_COLOR_CORRECT\");\n    }\n    let i = 0;\n    for (const face of CubeMap.faceNames()) {\n      let texture = manager._radianceMapTextures[i];\n      // Destroy any existing textures that have no yet been cleaned up\n      if (defined(texture) && !texture.isDestroyed()) {\n        texture.destroy();\n      }\n      texture = new Texture({\n        context: context,\n        width: textureDimensions.x,\n        height: textureDimensions.y,\n        pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n        pixelFormat: PixelFormat.RGBA\n      });\n      manager._radianceMapTextures[i] = texture;\n      const index = i;\n      const command = new ComputeCommand({\n        fragmentShaderSource: fs,\n        outputTexture: texture,\n        uniformMap: {\n          u_radiiAndDynamicAtmosphereColor: () => radiiAndDynamicAtmosphereColor,\n          u_enuToFixedFrame: () => enuToFixedFrame,\n          u_faceDirection: () => CubeMap.getDirection(face, scratchCartesian),\n          u_positionWC: () => position,\n          u_brightnessSaturationGammaIntensity: () => adjustments,\n          u_groundColor: () => {\n            return manager.groundColor.withAlpha(manager.groundAlbedo, scratchColor);\n          }\n        },\n        owner: manager\n      });\n      command.postExecute = () => {\n        if (manager.isDestroyed() || command.canceled) {\n          DynamicEnvironmentMapManager._activeComputeCommandCount--;\n          return;\n        }\n        const commands = manager._radianceMapComputeCommands;\n        commands[index] = undefined;\n        const framebuffer = new Framebuffer({\n          context: context,\n          colorTextures: [manager._radianceMapTextures[index]]\n        });\n\n        // Copy the output texture into the corresponding cubemap face\n        framebuffer._bind();\n        manager._radianceCubeMap[face].copyFromFramebuffer();\n        framebuffer._unBind();\n        framebuffer.destroy();\n        DynamicEnvironmentMapManager._activeComputeCommandCount--;\n        if (!commands.some(defined)) {\n          manager._convolutionsCommandsDirty = true;\n          manager._shouldRegenerateShaders = true;\n        }\n      };\n      manager._radianceMapComputeCommands[i] = command;\n      DynamicEnvironmentMapManager._queueCommand(command, frameState);\n      i++;\n    }\n    manager._radianceCommandsDirty = false;\n  }\n}\n\n/**\n * Creates a mipmap chain for the cubemap by convolving the environment map for each roughness level\n * @param {DynamicEnvironmentMapManager} manager this manager\n * @param {FrameState} frameState the current frameState\n * @private\n */\nfunction updateSpecularMaps(manager, frameState) {\n  const radianceCubeMap = manager._radianceCubeMap;\n  radianceCubeMap.generateMipmap();\n  const mipmapLevels = manager._mipmapLevels;\n  const textureDimensions = manager._textureDimensions;\n  let width = textureDimensions.x / 2;\n  let height = textureDimensions.y / 2;\n  const context = frameState.context;\n  let facesCopied = 0;\n  const getPostExecute = (command, index, texture, face, level) => () => {\n    if (manager.isDestroyed() || command.canceled) {\n      DynamicEnvironmentMapManager._activeComputeCommandCount--;\n      return;\n    }\n\n    // Copy output texture to corresponding face and mipmap level\n    const commands = manager._convolutionComputeCommands;\n    commands[index] = undefined;\n    radianceCubeMap.copyFace(frameState, texture, face, level);\n    facesCopied++;\n    DynamicEnvironmentMapManager._activeComputeCommandCount--;\n    texture.destroy();\n    manager._specularMapTextures[index] = undefined;\n\n    // All faces for each mipmap level have been copied\n    const length = manager._specularMapTextures.length;\n    if (facesCopied >= length) {\n      manager._irradianceCommandDirty = true;\n      radianceCubeMap.sampler = new Sampler({\n        minificationFilter: TextureMinificationFilter.LINEAR_MIPMAP_LINEAR\n      });\n      manager._shouldRegenerateShaders = true;\n\n      // Cleanup shared resources\n      manager._va.destroy();\n      manager._va = undefined;\n      manager._convolveSP.destroy();\n      manager._convolveSP = undefined;\n    }\n  };\n  let index = 0;\n  for (let level = 1; level < mipmapLevels; ++level) {\n    for (const face of CubeMap.faceNames()) {\n      if (defined(manager._specularMapTextures[index])) {\n        manager._specularMapTextures[index].destroy();\n      }\n      const texture = manager._specularMapTextures[index] = new Texture({\n        context: context,\n        width: width,\n        height: height,\n        pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n        pixelFormat: PixelFormat.RGBA\n      });\n      let vertexArray = manager._va;\n      if (!defined(vertexArray)) {\n        vertexArray = CubeMap.createVertexArray(context, face);\n        manager._va = vertexArray;\n      }\n      let shaderProgram = manager._convolveSP;\n      if (!defined(shaderProgram)) {\n        shaderProgram = ShaderProgram.fromCache({\n          context: context,\n          vertexShaderSource: ConvolveSpecularMapVS,\n          fragmentShaderSource: ConvolveSpecularMapFS,\n          attributeLocations: {\n            positions: 0\n          }\n        });\n        manager._convolveSP = shaderProgram;\n      }\n      const command = new ComputeCommand({\n        shaderProgram: shaderProgram,\n        vertexArray: vertexArray,\n        outputTexture: texture,\n        // Persist so we can use a shared shader progam and vertex array across all commands\n        // Shared resources are instead destroyed in postExecute\n        persists: true,\n        owner: manager,\n        uniformMap: {\n          u_roughness: () => level / (mipmapLevels - 1),\n          u_radianceTexture: () => radianceCubeMap ?? context.defaultTexture,\n          u_faceDirection: () => {\n            return CubeMap.getDirection(face, scratchCartesian);\n          }\n        }\n      });\n      command.postExecute = getPostExecute(command, index, texture, face, level);\n      manager._convolutionComputeCommands[index] = command;\n      DynamicEnvironmentMapManager._queueCommand(command, frameState);\n      ++index;\n    }\n    width /= 2;\n    height /= 2;\n  }\n}\nconst irradianceTextureDimensions = new Cartesian2(3, 3); // 9 coefficients\n\n/**\n * Computes spherical harmonic coefficients by convolving the environment map.\n * @param {DynamicEnvironmentMapManager} manager this manager\n * @param {FrameState} frameState the current frameState\n * @private\n */\nfunction updateIrradianceResources(manager, frameState) {\n  const context = frameState.context;\n  const dimensions = irradianceTextureDimensions;\n  let texture = manager._irradianceMapTexture;\n  if (defined(texture) && !texture.isDestroyed()) {\n    texture.destroy();\n  }\n  texture = new Texture({\n    context: context,\n    width: dimensions.x,\n    height: dimensions.y,\n    pixelDatatype: PixelDatatype.FLOAT,\n    pixelFormat: PixelFormat.RGBA\n  });\n  manager._irradianceMapTexture = texture;\n  let fs = manager._irradianceMapFS;\n  if (!defined(fs)) {\n    fs = new ShaderSource({\n      sources: [ComputeIrradianceFS]\n    });\n    manager._irradianceMapFS = fs;\n  }\n  const command = new ComputeCommand({\n    fragmentShaderSource: fs,\n    outputTexture: texture,\n    owner: manager,\n    uniformMap: {\n      u_radianceMap: () => manager._radianceCubeMap ?? context.defaultTexture\n    }\n  });\n  command.postExecute = () => {\n    if (manager.isDestroyed() || command.canceled) {\n      DynamicEnvironmentMapManager._activeComputeCommandCount--;\n      return;\n    }\n    manager._irradianceTextureDirty = false;\n    manager._irradianceComputeCommand = undefined;\n    manager._sphericalHarmonicCoefficientsDirty = true;\n    manager._irradianceMapFS = undefined;\n    DynamicEnvironmentMapManager._activeComputeCommandCount--;\n  };\n  manager._irradianceComputeCommand = command;\n  DynamicEnvironmentMapManager._queueCommand(command, frameState);\n  manager._irradianceTextureDirty = true;\n}\n\n/**\n * Copies coefficients from the output texture using readPixels.\n * @param {DynamicEnvironmentMapManager} manager this manager\n * @param {FrameState} frameState the current frameState\n * @private\n */\nfunction updateSphericalHarmonicCoefficients(manager, frameState) {\n  const context = frameState.context;\n  if (!defined(manager._irradianceMapTexture)) {\n    // Operation was canceled\n    return;\n  }\n  const framebuffer = new Framebuffer({\n    context: context,\n    colorTextures: [manager._irradianceMapTexture],\n    destroyAttachments: false\n  });\n  const dimensions = irradianceTextureDimensions;\n  const data = context.readPixels({\n    x: 0,\n    y: 0,\n    width: dimensions.x,\n    height: dimensions.y,\n    framebuffer: framebuffer\n  });\n  for (let i = 0; i < 9; ++i) {\n    manager._sphericalHarmonicCoefficients[i] = Cartesian3.unpack(data, i * 4);\n    Cartesian3.multiplyByScalar(manager._sphericalHarmonicCoefficients[i], manager.atmosphereScatteringIntensity, manager._sphericalHarmonicCoefficients[i]);\n  }\n  framebuffer.destroy();\n  manager._irradianceMapTexture.destroy();\n  manager._irradianceMapTexture = undefined;\n  manager._shouldRegenerateShaders = true;\n}\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * build the resources for the environment maps.\n * <p>\n * Do not call this function directly.\n * </p>\n * @private\n */\nDynamicEnvironmentMapManager.prototype.update = function (frameState) {\n  const mode = frameState.mode;\n  const isSupported =\n  // A FrameState type works here because the function only references the context parameter.\n  // @ts-ignore\n  DynamicEnvironmentMapManager.isDynamicUpdateSupported(frameState);\n  if (!isSupported || !this.enabled || !this.shouldUpdate || !defined(this._position) || mode === SceneMode.MORPHING) {\n    this._shouldRegenerateShaders = false;\n    return;\n  }\n  DynamicEnvironmentMapManager._updateCommandQueue(frameState);\n  const dynamicLighting = frameState.atmosphere.dynamicLighting;\n  const regenerateEnvironmentMap = atmosphereNeedsUpdate(this, frameState) || dynamicLighting === DynamicAtmosphereLightingType.SUNLIGHT && !JulianDate.equalsEpsilon(frameState.time, this._lastTime, this.maximumSecondsDifference);\n  if (this._shouldReset || regenerateEnvironmentMap) {\n    this.reset();\n    this._shouldReset = false;\n    this._lastTime = JulianDate.clone(frameState.time, this._lastTime);\n    return;\n  }\n  if (this._radianceMapDirty) {\n    updateRadianceMap(this, frameState);\n    this._radianceMapDirty = false;\n  }\n  if (this._convolutionsCommandsDirty) {\n    updateSpecularMaps(this, frameState);\n    this._convolutionsCommandsDirty = false;\n  }\n  if (this._irradianceCommandDirty) {\n    updateIrradianceResources(this, frameState);\n    this._irradianceCommandDirty = false;\n  }\n  if (this._irradianceTextureDirty) {\n    this._shouldRegenerateShaders = false;\n    return;\n  }\n  if (this._sphericalHarmonicCoefficientsDirty) {\n    updateSphericalHarmonicCoefficients(this, frameState);\n    this._sphericalHarmonicCoefficientsDirty = false;\n    return;\n  }\n  this._shouldRegenerateShaders = false;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n * @see DynamicEnvironmentMapManager#destroy\n */\nDynamicEnvironmentMapManager.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * @throws {DeveloperError} This object was destroyed, i.e., destroy() was called.\n * @example\n * mapManager = mapManager && mapManager.destroy();\n * @see DynamicEnvironmentMapManager#isDestroyed\n */\nDynamicEnvironmentMapManager.prototype.destroy = function () {\n  // Cancel in-progress commands\n  let length = this._radianceMapComputeCommands.length;\n  for (let i = 0; i < length; ++i) {\n    this._radianceMapComputeCommands[i] = undefined;\n  }\n  length = this._convolutionComputeCommands.length;\n  for (let i = 0; i < length; ++i) {\n    this._convolutionComputeCommands[i] = undefined;\n  }\n  this._irradianceMapComputeCommand = undefined;\n\n  // Destroy all textures\n  length = this._radianceMapTextures.length;\n  for (let i = 0; i < length; ++i) {\n    this._radianceMapTextures[i] = this._radianceMapTextures[i] && !this._radianceMapTextures[i].isDestroyed() && this._radianceMapTextures[i].destroy();\n  }\n  length = this._specularMapTextures.length;\n  for (let i = 0; i < length; ++i) {\n    this._specularMapTextures[i] = this._specularMapTextures[i] && !this._specularMapTextures[i].isDestroyed() && this._specularMapTextures[i].destroy();\n  }\n  this._radianceCubeMap = this._radianceCubeMap && this._radianceCubeMap.destroy();\n  this._irradianceMapTexture = this._irradianceMapTexture && !this._irradianceMapTexture.isDestroyed() && this._irradianceMapTexture.destroy();\n  if (defined(this._va)) {\n    this._va.destroy();\n  }\n  if (defined(this._convolveSP)) {\n    this._convolveSP.destroy();\n  }\n  return destroyObject(this);\n};\n\n/**\n * Returns <code>true</code> if dynamic updates are supported in the current WebGL rendering context.\n * Dynamic updates requires the EXT_color_buffer_float or EXT_color_buffer_half_float extension.\n *\n * @param {Scene} scene The object containing the rendering context\n * @returns {boolean} true if supported\n */\nDynamicEnvironmentMapManager.isDynamicUpdateSupported = function (scene) {\n  const context = scene.context;\n  return context.halfFloatingPointTexture || context.colorBufferFloat;\n};\n\n/**\n * Average hue of ground color on earth, a warm green-gray.\n * @type {Color}\n * @readonly\n */\nDynamicEnvironmentMapManager.AVERAGE_EARTH_GROUND_COLOR = Object.freeze(Color.fromCssColorString(\"#717145\"));\n\n/**\n * The default third order spherical harmonic coefficients used for the diffuse color of image-based lighting, a white ambient light with low intensity.\n * <p>\n * There are nine <code>Cartesian3</code> coefficients.\n * The order of the coefficients is: L<sub>0,0</sub>, L<sub>1,-1</sub>, L<sub>1,0</sub>, L<sub>1,1</sub>, L<sub>2,-2</sub>, L<sub>2,-1</sub>, L<sub>2,0</sub>, L<sub>2,1</sub>, L<sub>2,2</sub>\n * </p>\n * @readonly\n * @type {Cartesian3[]}\n * @see {@link https://graphics.stanford.edu/papers/envmap/envmap.pdf|An Efficient Representation for Irradiance Environment Maps}\n */\nDynamicEnvironmentMapManager.DEFAULT_SPHERICAL_HARMONIC_COEFFICIENTS = Object.freeze([Object.freeze(new Cartesian3(0.35449, 0.35449, 0.35449)), Cartesian3.ZERO, Cartesian3.ZERO, Cartesian3.ZERO, Cartesian3.ZERO, Cartesian3.ZERO, Cartesian3.ZERO, Cartesian3.ZERO, Cartesian3.ZERO]);\nexport default DynamicEnvironmentMapManager;","map":{"version":3,"names":["Cartesian2","Cartesian3","Cartesian4","Color","Frozen","defined","destroyObject","DeveloperError","JulianDate","Matrix4","PixelFormat","SceneMode","Transforms","ComputeCommand","ContextLimits","CubeMap","Framebuffer","Texture","PixelDatatype","Sampler","ShaderProgram","ShaderSource","TextureMinificationFilter","Atmosphere","DynamicAtmosphereLightingType","AtmosphereCommon","ComputeIrradianceFS","ComputeRadianceMapFS","ConvolveSpecularMapFS","ConvolveSpecularMapVS","DynamicEnvironmentMapManager","options","_position","undefined","_radianceMapDirty","_radianceCommandsDirty","_convolutionsCommandsDirty","_irradianceCommandDirty","_irradianceTextureDirty","_sphericalHarmonicCoefficientsDirty","_shouldRegenerateShaders","_shouldReset","EMPTY_OBJECT","mipmapLevels","Math","min","log2","maximumCubeMapSize","_mipmapLevels","_radianceMapComputeCommands","Array","_convolutionComputeCommands","_irradianceComputeCommand","_radianceMapFS","_irradianceMapFS","_convolveSP","_va","_radianceMapTextures","_specularMapTextures","_radianceCubeMap","_irradianceMapTexture","_sphericalHarmonicCoefficients","DEFAULT_SPHERICAL_HARMONIC_COEFFICIENTS","slice","_lastTime","width","pow","_textureDimensions","_radiiAndDynamicAtmosphereColor","_sceneEnvironmentMap","_backgroundColor","_owner","enabled","shouldUpdate","maximumSecondsDifference","maximumPositionEpsilon","atmosphereScatteringIntensity","gamma","brightness","saturation","groundColor","AVERAGE_EARTH_GROUND_COLOR","groundAlbedo","Object","defineProperties","prototype","owner","get","shouldRegenerateShaders","position","set","value","equalsEpsilon","clone","radianceCubeMap","maximumMipmapLevel","sphericalHarmonicCoefficients","_maximumComputeCommandCount","_activeComputeCommandCount","_nextFrameCommandQueue","_queueCommand","command","frameState","push","commandList","_updateCommandQueue","length","shift","isDestroyed","canceled","setOwner","environmentMapManager","key","destroy","reset","i","scratchPackedAtmosphere","scratchSurfacePosition","atmosphereNeedsUpdate","manager","atmosphere","ellipsoid","mapProjection","surfacePosition","scaleToGeodeticSurface","outerEllipsoidScale","radiiAndDynamicAtmosphereColor","radius","magnitude","maximumRadius","x","y","z","dynamicLighting","environmentMap","backgroundColor","scratchCartesian","scratchMatrix","scratchAdjustments","scratchColor","updateRadianceMap","context","textureDimensions","height","pixelDatatype","UNSIGNED_BYTE","pixelFormat","RGBA","fs","sources","requiresColorCorrect","defines","enuToFixedFrame","eastNorthUpToFixedFrame","adjustments","w","face","faceNames","texture","index","fragmentShaderSource","outputTexture","uniformMap","u_radiiAndDynamicAtmosphereColor","u_enuToFixedFrame","u_faceDirection","getDirection","u_positionWC","u_brightnessSaturationGammaIntensity","u_groundColor","withAlpha","postExecute","commands","framebuffer","colorTextures","_bind","copyFromFramebuffer","_unBind","some","updateSpecularMaps","generateMipmap","facesCopied","getPostExecute","level","copyFace","sampler","minificationFilter","LINEAR_MIPMAP_LINEAR","vertexArray","createVertexArray","shaderProgram","fromCache","vertexShaderSource","attributeLocations","positions","persists","u_roughness","u_radianceTexture","defaultTexture","irradianceTextureDimensions","updateIrradianceResources","dimensions","FLOAT","u_radianceMap","updateSphericalHarmonicCoefficients","destroyAttachments","data","readPixels","unpack","multiplyByScalar","update","mode","isSupported","isDynamicUpdateSupported","MORPHING","regenerateEnvironmentMap","SUNLIGHT","time","_irradianceMapComputeCommand","scene","halfFloatingPointTexture","colorBufferFloat","freeze","fromCssColorString","ZERO"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/DynamicEnvironmentMapManager.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Color from \"../Core/Color.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport ComputeCommand from \"../Renderer/ComputeCommand.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport CubeMap from \"../Renderer/CubeMap.js\";\nimport Framebuffer from \"../Renderer/Framebuffer.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport Atmosphere from \"./Atmosphere.js\";\nimport DynamicAtmosphereLightingType from \"./DynamicAtmosphereLightingType.js\";\nimport AtmosphereCommon from \"../Shaders/AtmosphereCommon.js\";\nimport ComputeIrradianceFS from \"../Shaders/ComputeIrradianceFS.js\";\nimport ComputeRadianceMapFS from \"../Shaders/ComputeRadianceMapFS.js\";\nimport ConvolveSpecularMapFS from \"../Shaders/ConvolveSpecularMapFS.js\";\nimport ConvolveSpecularMapVS from \"../Shaders/ConvolveSpecularMapVS.js\";\n\n/**\n * @typedef {object} DynamicEnvironmentMapManager.ConstructorOptions\n * Options for the DynamicEnvironmentMapManager constructor\n * @property {boolean} [enabled=true] If true, the environment map and related properties will continue to update.\n * @property {number} [mipmapLevels=7] The number of mipmap levels to generate for specular maps. More mipmap levels will produce a higher resolution specular reflection.\n * @property {number} [maximumSecondsDifference=3600] The maximum amount of elapsed seconds before a new environment map is created.\n * @property {number} [maximumPositionEpsilon=1000] The maximum difference in position before a new environment map is created, in meters. Small differences in position will not visibly affect results.\n * @property {number} [atmosphereScatteringIntensity=2.0] The intensity of the scattered light emitted from the atmosphere. This should be adjusted relative to the value of {@link Scene.light} intensity.\n * @property {number} [gamma=1.0] The gamma correction to apply to the range of light emitted from the environment. 1.0 uses the unmodified emitted light color.\n * @property {number} [brightness=1.0] The brightness of light emitted from the environment. 1.0 uses the unmodified emitted environment color. Less than 1.0 makes the light darker while greater than 1.0 makes it brighter.\n * @property {number} [saturation=1.0] The saturation of the light emitted from the environment. 1.0 uses the unmodified emitted environment color. Less than 1.0 reduces the saturation while greater than 1.0 increases it.\n * @property {Color} [groundColor=DynamicEnvironmentMapManager.AVERAGE_EARTH_GROUND_COLOR] Solid color used to represent the ground.\n * @property {number} [groundAlbedo=0.31] The percentage of light reflected from the ground. The average earth albedo is 0.31.\n */\n\n/**\n * Generates an environment map at the given position based on scene's current lighting conditions. From this, it produces multiple levels of specular maps and spherical harmonic coefficients than can be used with {@link ImageBasedLighting} for models or tilesets.\n * @alias DynamicEnvironmentMapManager\n * @constructor\n * @param {DynamicEnvironmentMapManager.ConstructorOptions} [options] An object describing initialization options.\n *\n * @example\n * // Enable time-of-day environment mapping in a scene\n * scene.atmosphere.dynamicLighting = Cesium.DynamicAtmosphereLightingType.SUNLIGHT;\n *\n * // Decrease the directional lighting contribution\n * scene.light.intensity = 0.5\n *\n * // Increase the intensity of of the environment map lighting contribution\n * const environmentMapManager = tileset.environmentMapManager;\n * environmentMapManager.atmosphereScatteringIntensity = 3.0;\n *\n * @example\n * // Change the ground color used for a model's environment map to a forest green\n * const environmentMapManager = model.environmentMapManager;\n * environmentMapManager.groundColor = Cesium.Color.fromCssColorString(\"#203b34\");\n */\nfunction DynamicEnvironmentMapManager(options) {\n  this._position = undefined;\n\n  this._radianceMapDirty = false;\n  this._radianceCommandsDirty = false;\n  this._convolutionsCommandsDirty = false;\n  this._irradianceCommandDirty = false;\n  this._irradianceTextureDirty = false;\n  this._sphericalHarmonicCoefficientsDirty = false;\n\n  this._shouldRegenerateShaders = false;\n  this._shouldReset = false;\n\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const mipmapLevels = Math.min(\n    options.mipmapLevels ?? 7,\n    Math.log2(ContextLimits.maximumCubeMapSize),\n  );\n\n  this._mipmapLevels = mipmapLevels;\n  this._radianceMapComputeCommands = new Array(6);\n  this._convolutionComputeCommands = new Array((mipmapLevels - 1) * 6);\n  this._irradianceComputeCommand = undefined;\n\n  this._radianceMapFS = undefined;\n  this._irradianceMapFS = undefined;\n  this._convolveSP = undefined;\n  this._va = undefined;\n\n  this._radianceMapTextures = new Array(6);\n  this._specularMapTextures = new Array((mipmapLevels - 1) * 6);\n  this._radianceCubeMap = undefined;\n  this._irradianceMapTexture = undefined;\n\n  this._sphericalHarmonicCoefficients =\n    DynamicEnvironmentMapManager.DEFAULT_SPHERICAL_HARMONIC_COEFFICIENTS.slice();\n\n  this._lastTime = new JulianDate();\n  const width = Math.pow(2, mipmapLevels - 1);\n  this._textureDimensions = new Cartesian2(width, width);\n\n  this._radiiAndDynamicAtmosphereColor = new Cartesian3();\n  this._sceneEnvironmentMap = undefined;\n  this._backgroundColor = undefined;\n\n  // If this DynamicEnvironmentMapManager has an owner, only its owner should update or destroy it.\n  // This is because in a Cesium3DTileset multiple models may reference one tileset's DynamicEnvironmentMapManager.\n  this._owner = undefined;\n\n  /**\n   * If true, the environment map and related properties will continue to update.\n   * @type {boolean}\n   * @default true\n   */\n  this.enabled = options.enabled ?? true;\n\n  /**\n   * Disables updates. For internal use.\n   * @private\n   * @default true\n   */\n  this.shouldUpdate = true;\n\n  /**\n   * The maximum amount of elapsed seconds before a new environment map is created.\n   * @type {number}\n   * @default 3600\n   */\n  this.maximumSecondsDifference = options.maximumSecondsDifference ?? 60 * 60;\n\n  /**\n   * The maximum difference in position before a new environment map is created, in meters. Small differences in position will not visibly affect results.\n   * @type {number}\n   * @default 1000\n   */\n  this.maximumPositionEpsilon = options.maximumPositionEpsilon ?? 1000.0;\n\n  /**\n   * The intensity of the scattered light emitted from the atmosphere. This should be adjusted relative to the value of {@link Scene.light} intensity.\n   * @type {number}\n   * @default 2.0\n   * @see DirectionalLight.intensity\n   * @see SunLight.intensity\n   */\n  this.atmosphereScatteringIntensity =\n    options.atmosphereScatteringIntensity ?? 2.0;\n\n  /**\n   * The gamma correction to apply to the range of light emitted from the environment. 1.0 uses the unmodified incoming light color.\n   * @type {number}\n   * @default 1.0\n   */\n  this.gamma = options.gamma ?? 1.0;\n\n  /**\n   * The brightness of light emitted from the environment. 1.0 uses the unmodified emitted environment color. Less than 1.0\n   * makes the light darker while greater than 1.0 makes it brighter.\n   * @type {number}\n   * @default 1.0\n   */\n  this.brightness = options.brightness ?? 1.0;\n\n  /**\n   * The saturation of the light emitted from the environment. 1.0 uses the unmodified emitted environment color. Less than 1.0 reduces the\n   * saturation while greater than 1.0 increases it.\n   * @type {number}\n   * @default 1.0\n   */\n  this.saturation = options.saturation ?? 1.0;\n\n  /**\n   * Solid color used to represent the ground.\n   * @type {Color}\n   * @default DynamicEnvironmentMapManager.AVERAGE_EARTH_GROUND_COLOR\n   */\n  this.groundColor =\n    options.groundColor ??\n    DynamicEnvironmentMapManager.AVERAGE_EARTH_GROUND_COLOR;\n\n  /**\n   * The percentage of light reflected from the ground. The average earth albedo is 0.31.\n   * @type {number}\n   * @default 0.31\n   */\n  this.groundAlbedo = options.groundAlbedo ?? 0.31;\n}\n\nObject.defineProperties(DynamicEnvironmentMapManager.prototype, {\n  /**\n   * A reference to the DynamicEnvironmentMapManager's owner, if any.\n   * @memberof DynamicEnvironmentMapManager.prototype\n   * @type {object|undefined}\n   * @readonly\n   * @private\n   */\n  owner: {\n    get: function () {\n      return this._owner;\n    },\n  },\n\n  /**\n   * True if model shaders need to be regenerated to account for updates.\n   * @memberof DynamicEnvironmentMapManager.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  shouldRegenerateShaders: {\n    get: function () {\n      return this._shouldRegenerateShaders;\n    },\n  },\n\n  /**\n   * The position around which the environment map is generated.\n   * @memberof DynamicEnvironmentMapManager.prototype\n   * @type {Cartesian3|undefined}\n   */\n  position: {\n    get: function () {\n      return this._position;\n    },\n    set: function (value) {\n      if (\n        Cartesian3.equalsEpsilon(\n          value,\n          this._position,\n          0.0,\n          this.maximumPositionEpsilon,\n        )\n      ) {\n        return;\n      }\n\n      this._position = Cartesian3.clone(value, this._position);\n      this._shouldReset = true;\n    },\n  },\n\n  /**\n   * The computed radiance map, or <code>undefined</code> if it has not yet been created.\n   * @memberof DynamicEnvironmentMapManager.prototype\n   * @type {CubeMap|undefined}\n   * @readonly\n   * @private\n   */\n  radianceCubeMap: {\n    get: function () {\n      return this._radianceCubeMap;\n    },\n  },\n\n  /**\n   * The maximum number of mip levels available in the radiance cubemap.\n   * @memberof DynamicEnvironmentMapManager.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  maximumMipmapLevel: {\n    get: function () {\n      return this._mipmapLevels;\n    },\n  },\n\n  /**\n   * The third order spherical harmonic coefficients used for the diffuse color of image-based lighting.\n   * <p>\n   * There are nine <code>Cartesian3</code> coefficients.\n   * The order of the coefficients is: L<sub>0,0</sub>, L<sub>1,-1</sub>, L<sub>1,0</sub>, L<sub>1,1</sub>, L<sub>2,-2</sub>, L<sub>2,-1</sub>, L<sub>2,0</sub>, L<sub>2,1</sub>, L<sub>2,2</sub>\n   * </p>\n   * @memberof DynamicEnvironmentMapManager.prototype\n   * @readonly\n   * @type {Cartesian3[]}\n   * @see {@link https://graphics.stanford.edu/papers/envmap/envmap.pdf|An Efficient Representation for Irradiance Environment Maps}\n   * @private\n   */\n  sphericalHarmonicCoefficients: {\n    get: function () {\n      return this._sphericalHarmonicCoefficients;\n    },\n  },\n});\n\n// Internally manage a queue of commands across all instances to prevent too many commands from being added in a single frame and using too much memory at once.\nDynamicEnvironmentMapManager._maximumComputeCommandCount = 8; // This value is updated once a context is created.\nDynamicEnvironmentMapManager._activeComputeCommandCount = 0;\nDynamicEnvironmentMapManager._nextFrameCommandQueue = [];\n/**\n * Add a command to the queue. If possible, it will be added to the list of commands for the next frame. Otherwise, it will be added to a backlog\n * and attempted next frame.\n * @private\n * @param {ComputeCommand} command The created command\n * @param {FrameState} frameState The current frame state\n */\nDynamicEnvironmentMapManager._queueCommand = (command, frameState) => {\n  if (\n    DynamicEnvironmentMapManager._activeComputeCommandCount >=\n    DynamicEnvironmentMapManager._maximumComputeCommandCount\n  ) {\n    // Command will instead be scheduled next frame\n    DynamicEnvironmentMapManager._nextFrameCommandQueue.push(command);\n    return;\n  }\n\n  frameState.commandList.push(command);\n  DynamicEnvironmentMapManager._activeComputeCommandCount++;\n};\n/**\n * If there are any backlogged commands, queue up as many as possible for the next frame.\n * @private\n * @param {FrameState} frameState The current frame state\n */\nDynamicEnvironmentMapManager._updateCommandQueue = (frameState) => {\n  DynamicEnvironmentMapManager._maximumComputeCommandCount = Math.log2(\n    ContextLimits.maximumCubeMapSize,\n  ); // Scale relative to GPU resources available\n\n  if (\n    DynamicEnvironmentMapManager._nextFrameCommandQueue.length > 0 &&\n    DynamicEnvironmentMapManager._activeComputeCommandCount <\n      DynamicEnvironmentMapManager._maximumComputeCommandCount\n  ) {\n    let command = DynamicEnvironmentMapManager._nextFrameCommandQueue.shift();\n    while (\n      defined(command) &&\n      DynamicEnvironmentMapManager._activeComputeCommandCount <\n        DynamicEnvironmentMapManager._maximumComputeCommandCount\n    ) {\n      if (command.owner.isDestroyed() || command.canceled) {\n        command = DynamicEnvironmentMapManager._nextFrameCommandQueue.shift();\n        continue;\n      }\n\n      frameState.commandList.push(command);\n      DynamicEnvironmentMapManager._activeComputeCommandCount++;\n      command = DynamicEnvironmentMapManager._nextFrameCommandQueue.shift();\n    }\n\n    if (defined(command)) {\n      DynamicEnvironmentMapManager._nextFrameCommandQueue.push(command);\n    }\n  }\n};\n\n/**\n * Sets the owner for the input DynamicEnvironmentMapManager if there wasn't another owner.\n * Destroys the owner's previous DynamicEnvironmentMapManager if setting is successful.\n * @param {DynamicEnvironmentMapManager} [environmentMapManager] A DynamicEnvironmentMapManager (or undefined) being attached to an object\n * @param {object} owner An Object that should receive the new DynamicEnvironmentMapManager\n * @param {string} key The Key for the Object to reference the DynamicEnvironmentMapManager\n * @private\n */\nDynamicEnvironmentMapManager.setOwner = function (\n  environmentMapManager,\n  owner,\n  key,\n) {\n  // Don't destroy the DynamicEnvironmentMapManager if it's already owned by newOwner\n  if (environmentMapManager === owner[key]) {\n    return;\n  }\n  // Destroy the existing DynamicEnvironmentMapManager, if any\n  owner[key] = owner[key] && owner[key].destroy();\n  if (defined(environmentMapManager)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (defined(environmentMapManager._owner)) {\n      throw new DeveloperError(\n        \"DynamicEnvironmentMapManager should only be assigned to one object\",\n      );\n    }\n    //>>includeEnd('debug');\n    environmentMapManager._owner = owner;\n    owner[key] = environmentMapManager;\n  }\n};\n\n/**\n * Cancels any in-progress commands and marks the environment map as dirty.\n * @private\n */\nDynamicEnvironmentMapManager.prototype.reset = function () {\n  let length = this._radianceMapComputeCommands.length;\n  for (let i = 0; i < length; ++i) {\n    if (defined(this._radianceMapComputeCommands[i])) {\n      this._radianceMapComputeCommands[i].canceled = true;\n    }\n    this._radianceMapComputeCommands[i] = undefined;\n  }\n\n  length = this._convolutionComputeCommands.length;\n  for (let i = 0; i < length; ++i) {\n    if (defined(this._convolutionComputeCommands[i])) {\n      this._convolutionComputeCommands[i].canceled = true;\n    }\n    this._convolutionComputeCommands[i] = undefined;\n  }\n\n  if (defined(this._irradianceComputeCommand)) {\n    this._irradianceComputeCommand.canceled = true;\n    this._irradianceComputeCommand = undefined;\n  }\n\n  this._radianceMapDirty = true;\n  this._radianceCommandsDirty = true;\n  this._convolutionsCommandsDirty = false;\n  this._irradianceCommandDirty = false;\n};\n\nconst scratchPackedAtmosphere = new Cartesian3();\nconst scratchSurfacePosition = new Cartesian3();\n\n/**\n * Update atmosphere properties and returns true if the environment map needs to be regenerated.\n * @param {DynamicEnvironmentMapManager} manager this manager\n * @param {FrameState} frameState the current frameState\n * @returns {boolean} true if the environment map needs to be regenerated.\n * @private\n */\nfunction atmosphereNeedsUpdate(manager, frameState) {\n  const position = manager._position;\n  const atmosphere = frameState.atmosphere;\n\n  const ellipsoid = frameState.mapProjection.ellipsoid;\n  const surfacePosition = ellipsoid.scaleToGeodeticSurface(\n    position,\n    scratchSurfacePosition,\n  );\n  const outerEllipsoidScale = 1.025;\n\n  // Pack outer radius, inner radius, and dynamic atmosphere flag\n  const radiiAndDynamicAtmosphereColor = scratchPackedAtmosphere;\n  const radius = defined(surfacePosition)\n    ? Cartesian3.magnitude(surfacePosition)\n    : ellipsoid.maximumRadius;\n  radiiAndDynamicAtmosphereColor.x = radius * outerEllipsoidScale;\n  radiiAndDynamicAtmosphereColor.y = radius;\n  radiiAndDynamicAtmosphereColor.z = atmosphere.dynamicLighting;\n\n  if (\n    !Cartesian3.equalsEpsilon(\n      manager._radiiAndDynamicAtmosphereColor,\n      radiiAndDynamicAtmosphereColor,\n    ) ||\n    frameState.environmentMap !== manager._sceneEnvironmentMap ||\n    frameState.backgroundColor !== manager._backgroundColor\n  ) {\n    Cartesian3.clone(\n      radiiAndDynamicAtmosphereColor,\n      manager._radiiAndDynamicAtmosphereColor,\n    );\n    manager._sceneEnvironmentMap = frameState.environmentMap;\n    manager._backgroundColor = frameState.backgroundColor;\n    return true;\n  }\n\n  return false;\n}\n\nconst scratchCartesian = new Cartesian3();\nconst scratchMatrix = new Matrix4();\nconst scratchAdjustments = new Cartesian4();\nconst scratchColor = new Color();\n\n/**\n * Renders the highest resolution specular map by creating compute commands for each cube face\n * @param {DynamicEnvironmentMapManager} manager this manager\n * @param {FrameState} frameState the current frameState\n * @private\n */\nfunction updateRadianceMap(manager, frameState) {\n  const context = frameState.context;\n  const textureDimensions = manager._textureDimensions;\n\n  if (!defined(manager._radianceCubeMap)) {\n    manager._radianceCubeMap = new CubeMap({\n      context: context,\n      width: textureDimensions.x,\n      height: textureDimensions.y,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      pixelFormat: PixelFormat.RGBA,\n    });\n  }\n\n  if (manager._radianceCommandsDirty) {\n    let fs = manager._radianceMapFS;\n    if (!defined(fs)) {\n      fs = new ShaderSource({\n        sources: [AtmosphereCommon, ComputeRadianceMapFS],\n      });\n      manager._radianceMapFS = fs;\n    }\n\n    if (Atmosphere.requiresColorCorrect(frameState.atmosphere)) {\n      fs.defines.push(\"ATMOSPHERE_COLOR_CORRECT\");\n    }\n\n    const position = manager._position;\n    const radiiAndDynamicAtmosphereColor =\n      manager._radiiAndDynamicAtmosphereColor;\n\n    const ellipsoid = frameState.mapProjection.ellipsoid;\n    const enuToFixedFrame = Transforms.eastNorthUpToFixedFrame(\n      position,\n      ellipsoid,\n      scratchMatrix,\n    );\n\n    const adjustments = scratchAdjustments;\n\n    adjustments.x = manager.brightness;\n    adjustments.y = manager.saturation;\n    adjustments.z = manager.gamma;\n    adjustments.w = manager.atmosphereScatteringIntensity;\n\n    if (\n      manager.brightness !== 1.0 ||\n      manager.saturation !== 1.0 ||\n      manager.gamma !== 1.0\n    ) {\n      fs.defines.push(\"ENVIRONMENT_COLOR_CORRECT\");\n    }\n\n    let i = 0;\n    for (const face of CubeMap.faceNames()) {\n      let texture = manager._radianceMapTextures[i];\n      // Destroy any existing textures that have no yet been cleaned up\n      if (defined(texture) && !texture.isDestroyed()) {\n        texture.destroy();\n      }\n\n      texture = new Texture({\n        context: context,\n        width: textureDimensions.x,\n        height: textureDimensions.y,\n        pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n        pixelFormat: PixelFormat.RGBA,\n      });\n      manager._radianceMapTextures[i] = texture;\n\n      const index = i;\n      const command = new ComputeCommand({\n        fragmentShaderSource: fs,\n        outputTexture: texture,\n        uniformMap: {\n          u_radiiAndDynamicAtmosphereColor: () =>\n            radiiAndDynamicAtmosphereColor,\n          u_enuToFixedFrame: () => enuToFixedFrame,\n          u_faceDirection: () => CubeMap.getDirection(face, scratchCartesian),\n          u_positionWC: () => position,\n          u_brightnessSaturationGammaIntensity: () => adjustments,\n          u_groundColor: () => {\n            return manager.groundColor.withAlpha(\n              manager.groundAlbedo,\n              scratchColor,\n            );\n          },\n        },\n        owner: manager,\n      });\n      command.postExecute = () => {\n        if (manager.isDestroyed() || command.canceled) {\n          DynamicEnvironmentMapManager._activeComputeCommandCount--;\n          return;\n        }\n\n        const commands = manager._radianceMapComputeCommands;\n        commands[index] = undefined;\n\n        const framebuffer = new Framebuffer({\n          context: context,\n          colorTextures: [manager._radianceMapTextures[index]],\n        });\n\n        // Copy the output texture into the corresponding cubemap face\n        framebuffer._bind();\n        manager._radianceCubeMap[face].copyFromFramebuffer();\n        framebuffer._unBind();\n        framebuffer.destroy();\n\n        DynamicEnvironmentMapManager._activeComputeCommandCount--;\n\n        if (!commands.some(defined)) {\n          manager._convolutionsCommandsDirty = true;\n          manager._shouldRegenerateShaders = true;\n        }\n      };\n\n      manager._radianceMapComputeCommands[i] = command;\n      DynamicEnvironmentMapManager._queueCommand(command, frameState);\n      i++;\n    }\n    manager._radianceCommandsDirty = false;\n  }\n}\n\n/**\n * Creates a mipmap chain for the cubemap by convolving the environment map for each roughness level\n * @param {DynamicEnvironmentMapManager} manager this manager\n * @param {FrameState} frameState the current frameState\n * @private\n */\nfunction updateSpecularMaps(manager, frameState) {\n  const radianceCubeMap = manager._radianceCubeMap;\n  radianceCubeMap.generateMipmap();\n\n  const mipmapLevels = manager._mipmapLevels;\n  const textureDimensions = manager._textureDimensions;\n  let width = textureDimensions.x / 2;\n  let height = textureDimensions.y / 2;\n  const context = frameState.context;\n\n  let facesCopied = 0;\n  const getPostExecute = (command, index, texture, face, level) => () => {\n    if (manager.isDestroyed() || command.canceled) {\n      DynamicEnvironmentMapManager._activeComputeCommandCount--;\n      return;\n    }\n\n    // Copy output texture to corresponding face and mipmap level\n    const commands = manager._convolutionComputeCommands;\n    commands[index] = undefined;\n\n    radianceCubeMap.copyFace(frameState, texture, face, level);\n    facesCopied++;\n    DynamicEnvironmentMapManager._activeComputeCommandCount--;\n\n    texture.destroy();\n    manager._specularMapTextures[index] = undefined;\n\n    // All faces for each mipmap level have been copied\n    const length = manager._specularMapTextures.length;\n    if (facesCopied >= length) {\n      manager._irradianceCommandDirty = true;\n      radianceCubeMap.sampler = new Sampler({\n        minificationFilter: TextureMinificationFilter.LINEAR_MIPMAP_LINEAR,\n      });\n\n      manager._shouldRegenerateShaders = true;\n\n      // Cleanup shared resources\n      manager._va.destroy();\n      manager._va = undefined;\n      manager._convolveSP.destroy();\n      manager._convolveSP = undefined;\n    }\n  };\n\n  let index = 0;\n  for (let level = 1; level < mipmapLevels; ++level) {\n    for (const face of CubeMap.faceNames()) {\n      if (defined(manager._specularMapTextures[index])) {\n        manager._specularMapTextures[index].destroy();\n      }\n\n      const texture = (manager._specularMapTextures[index] = new Texture({\n        context: context,\n        width: width,\n        height: height,\n        pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n        pixelFormat: PixelFormat.RGBA,\n      }));\n\n      let vertexArray = manager._va;\n      if (!defined(vertexArray)) {\n        vertexArray = CubeMap.createVertexArray(context, face);\n        manager._va = vertexArray;\n      }\n\n      let shaderProgram = manager._convolveSP;\n      if (!defined(shaderProgram)) {\n        shaderProgram = ShaderProgram.fromCache({\n          context: context,\n          vertexShaderSource: ConvolveSpecularMapVS,\n          fragmentShaderSource: ConvolveSpecularMapFS,\n          attributeLocations: {\n            positions: 0,\n          },\n        });\n        manager._convolveSP = shaderProgram;\n      }\n\n      const command = new ComputeCommand({\n        shaderProgram: shaderProgram,\n        vertexArray: vertexArray,\n        outputTexture: texture,\n        // Persist so we can use a shared shader progam and vertex array across all commands\n        // Shared resources are instead destroyed in postExecute\n        persists: true,\n        owner: manager,\n        uniformMap: {\n          u_roughness: () => level / (mipmapLevels - 1),\n          u_radianceTexture: () => radianceCubeMap ?? context.defaultTexture,\n          u_faceDirection: () => {\n            return CubeMap.getDirection(face, scratchCartesian);\n          },\n        },\n      });\n      command.postExecute = getPostExecute(\n        command,\n        index,\n        texture,\n        face,\n        level,\n      );\n      manager._convolutionComputeCommands[index] = command;\n      DynamicEnvironmentMapManager._queueCommand(command, frameState);\n      ++index;\n    }\n\n    width /= 2;\n    height /= 2;\n  }\n}\n\nconst irradianceTextureDimensions = new Cartesian2(3, 3); // 9 coefficients\n\n/**\n * Computes spherical harmonic coefficients by convolving the environment map.\n * @param {DynamicEnvironmentMapManager} manager this manager\n * @param {FrameState} frameState the current frameState\n * @private\n */\nfunction updateIrradianceResources(manager, frameState) {\n  const context = frameState.context;\n  const dimensions = irradianceTextureDimensions;\n\n  let texture = manager._irradianceMapTexture;\n  if (defined(texture) && !texture.isDestroyed()) {\n    texture.destroy();\n  }\n\n  texture = new Texture({\n    context: context,\n    width: dimensions.x,\n    height: dimensions.y,\n    pixelDatatype: PixelDatatype.FLOAT,\n    pixelFormat: PixelFormat.RGBA,\n  });\n  manager._irradianceMapTexture = texture;\n\n  let fs = manager._irradianceMapFS;\n  if (!defined(fs)) {\n    fs = new ShaderSource({\n      sources: [ComputeIrradianceFS],\n    });\n    manager._irradianceMapFS = fs;\n  }\n\n  const command = new ComputeCommand({\n    fragmentShaderSource: fs,\n    outputTexture: texture,\n    owner: manager,\n    uniformMap: {\n      u_radianceMap: () => manager._radianceCubeMap ?? context.defaultTexture,\n    },\n  });\n\n  command.postExecute = () => {\n    if (manager.isDestroyed() || command.canceled) {\n      DynamicEnvironmentMapManager._activeComputeCommandCount--;\n      return;\n    }\n    manager._irradianceTextureDirty = false;\n    manager._irradianceComputeCommand = undefined;\n    manager._sphericalHarmonicCoefficientsDirty = true;\n    manager._irradianceMapFS = undefined;\n\n    DynamicEnvironmentMapManager._activeComputeCommandCount--;\n  };\n\n  manager._irradianceComputeCommand = command;\n  DynamicEnvironmentMapManager._queueCommand(command, frameState);\n  manager._irradianceTextureDirty = true;\n}\n\n/**\n * Copies coefficients from the output texture using readPixels.\n * @param {DynamicEnvironmentMapManager} manager this manager\n * @param {FrameState} frameState the current frameState\n * @private\n */\nfunction updateSphericalHarmonicCoefficients(manager, frameState) {\n  const context = frameState.context;\n\n  if (!defined(manager._irradianceMapTexture)) {\n    // Operation was canceled\n    return;\n  }\n\n  const framebuffer = new Framebuffer({\n    context: context,\n    colorTextures: [manager._irradianceMapTexture],\n    destroyAttachments: false,\n  });\n\n  const dimensions = irradianceTextureDimensions;\n  const data = context.readPixels({\n    x: 0,\n    y: 0,\n    width: dimensions.x,\n    height: dimensions.y,\n    framebuffer: framebuffer,\n  });\n\n  for (let i = 0; i < 9; ++i) {\n    manager._sphericalHarmonicCoefficients[i] = Cartesian3.unpack(data, i * 4);\n    Cartesian3.multiplyByScalar(\n      manager._sphericalHarmonicCoefficients[i],\n      manager.atmosphereScatteringIntensity,\n      manager._sphericalHarmonicCoefficients[i],\n    );\n  }\n\n  framebuffer.destroy();\n  manager._irradianceMapTexture.destroy();\n  manager._irradianceMapTexture = undefined;\n  manager._shouldRegenerateShaders = true;\n}\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * build the resources for the environment maps.\n * <p>\n * Do not call this function directly.\n * </p>\n * @private\n */\nDynamicEnvironmentMapManager.prototype.update = function (frameState) {\n  const mode = frameState.mode;\n  const isSupported =\n    // A FrameState type works here because the function only references the context parameter.\n    // @ts-ignore\n    DynamicEnvironmentMapManager.isDynamicUpdateSupported(frameState);\n\n  if (\n    !isSupported ||\n    !this.enabled ||\n    !this.shouldUpdate ||\n    !defined(this._position) ||\n    mode === SceneMode.MORPHING\n  ) {\n    this._shouldRegenerateShaders = false;\n    return;\n  }\n\n  DynamicEnvironmentMapManager._updateCommandQueue(frameState);\n\n  const dynamicLighting = frameState.atmosphere.dynamicLighting;\n  const regenerateEnvironmentMap =\n    atmosphereNeedsUpdate(this, frameState) ||\n    (dynamicLighting === DynamicAtmosphereLightingType.SUNLIGHT &&\n      !JulianDate.equalsEpsilon(\n        frameState.time,\n        this._lastTime,\n        this.maximumSecondsDifference,\n      ));\n\n  if (this._shouldReset || regenerateEnvironmentMap) {\n    this.reset();\n    this._shouldReset = false;\n    this._lastTime = JulianDate.clone(frameState.time, this._lastTime);\n    return;\n  }\n\n  if (this._radianceMapDirty) {\n    updateRadianceMap(this, frameState);\n    this._radianceMapDirty = false;\n  }\n\n  if (this._convolutionsCommandsDirty) {\n    updateSpecularMaps(this, frameState);\n    this._convolutionsCommandsDirty = false;\n  }\n\n  if (this._irradianceCommandDirty) {\n    updateIrradianceResources(this, frameState);\n    this._irradianceCommandDirty = false;\n  }\n\n  if (this._irradianceTextureDirty) {\n    this._shouldRegenerateShaders = false;\n    return;\n  }\n\n  if (this._sphericalHarmonicCoefficientsDirty) {\n    updateSphericalHarmonicCoefficients(this, frameState);\n    this._sphericalHarmonicCoefficientsDirty = false;\n    return;\n  }\n\n  this._shouldRegenerateShaders = false;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n * @see DynamicEnvironmentMapManager#destroy\n */\nDynamicEnvironmentMapManager.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * @throws {DeveloperError} This object was destroyed, i.e., destroy() was called.\n * @example\n * mapManager = mapManager && mapManager.destroy();\n * @see DynamicEnvironmentMapManager#isDestroyed\n */\nDynamicEnvironmentMapManager.prototype.destroy = function () {\n  // Cancel in-progress commands\n  let length = this._radianceMapComputeCommands.length;\n  for (let i = 0; i < length; ++i) {\n    this._radianceMapComputeCommands[i] = undefined;\n  }\n\n  length = this._convolutionComputeCommands.length;\n  for (let i = 0; i < length; ++i) {\n    this._convolutionComputeCommands[i] = undefined;\n  }\n\n  this._irradianceMapComputeCommand = undefined;\n\n  // Destroy all textures\n  length = this._radianceMapTextures.length;\n  for (let i = 0; i < length; ++i) {\n    this._radianceMapTextures[i] =\n      this._radianceMapTextures[i] &&\n      !this._radianceMapTextures[i].isDestroyed() &&\n      this._radianceMapTextures[i].destroy();\n  }\n\n  length = this._specularMapTextures.length;\n  for (let i = 0; i < length; ++i) {\n    this._specularMapTextures[i] =\n      this._specularMapTextures[i] &&\n      !this._specularMapTextures[i].isDestroyed() &&\n      this._specularMapTextures[i].destroy();\n  }\n\n  this._radianceCubeMap =\n    this._radianceCubeMap && this._radianceCubeMap.destroy();\n  this._irradianceMapTexture =\n    this._irradianceMapTexture &&\n    !this._irradianceMapTexture.isDestroyed() &&\n    this._irradianceMapTexture.destroy();\n\n  if (defined(this._va)) {\n    this._va.destroy();\n  }\n\n  if (defined(this._convolveSP)) {\n    this._convolveSP.destroy();\n  }\n\n  return destroyObject(this);\n};\n\n/**\n * Returns <code>true</code> if dynamic updates are supported in the current WebGL rendering context.\n * Dynamic updates requires the EXT_color_buffer_float or EXT_color_buffer_half_float extension.\n *\n * @param {Scene} scene The object containing the rendering context\n * @returns {boolean} true if supported\n */\nDynamicEnvironmentMapManager.isDynamicUpdateSupported = function (scene) {\n  const context = scene.context;\n  return context.halfFloatingPointTexture || context.colorBufferFloat;\n};\n\n/**\n * Average hue of ground color on earth, a warm green-gray.\n * @type {Color}\n * @readonly\n */\nDynamicEnvironmentMapManager.AVERAGE_EARTH_GROUND_COLOR = Object.freeze(\n  Color.fromCssColorString(\"#717145\"),\n);\n\n/**\n * The default third order spherical harmonic coefficients used for the diffuse color of image-based lighting, a white ambient light with low intensity.\n * <p>\n * There are nine <code>Cartesian3</code> coefficients.\n * The order of the coefficients is: L<sub>0,0</sub>, L<sub>1,-1</sub>, L<sub>1,0</sub>, L<sub>1,1</sub>, L<sub>2,-2</sub>, L<sub>2,-1</sub>, L<sub>2,0</sub>, L<sub>2,1</sub>, L<sub>2,2</sub>\n * </p>\n * @readonly\n * @type {Cartesian3[]}\n * @see {@link https://graphics.stanford.edu/papers/envmap/envmap.pdf|An Efficient Representation for Irradiance Environment Maps}\n */\nDynamicEnvironmentMapManager.DEFAULT_SPHERICAL_HARMONIC_COEFFICIENTS =\n  Object.freeze([\n    Object.freeze(new Cartesian3(0.35449, 0.35449, 0.35449)),\n    Cartesian3.ZERO,\n    Cartesian3.ZERO,\n    Cartesian3.ZERO,\n    Cartesian3.ZERO,\n    Cartesian3.ZERO,\n    Cartesian3.ZERO,\n    Cartesian3.ZERO,\n    Cartesian3.ZERO,\n  ]);\n\nexport default DynamicEnvironmentMapManager;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}