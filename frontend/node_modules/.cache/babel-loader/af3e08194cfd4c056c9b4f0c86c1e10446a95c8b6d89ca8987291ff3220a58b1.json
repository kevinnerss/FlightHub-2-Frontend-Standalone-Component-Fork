{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport { ClockRange, defined, destroyObject, DeveloperError, getElement, JulianDate } from \"@cesium/engine\";\nimport TimelineHighlightRange from \"./TimelineHighlightRange.js\";\nimport TimelineTrack from \"./TimelineTrack.js\";\nlet timelineWheelDelta = 1e12;\nconst timelineMouseMode = {\n  none: 0,\n  scrub: 1,\n  slide: 2,\n  zoom: 3,\n  touchOnly: 4\n};\nconst timelineTouchMode = {\n  none: 0,\n  scrub: 1,\n  slideZoom: 2,\n  singleTap: 3,\n  ignore: 4\n};\nconst timelineTicScales = [0.001, 0.002, 0.005, 0.01, 0.02, 0.05, 0.1, 0.25, 0.5, 1.0, 2.0, 5.0, 10.0, 15.0, 30.0, 60.0,\n// 1min\n120.0,\n// 2min\n300.0,\n// 5min\n600.0,\n// 10min\n900.0,\n// 15min\n1800.0,\n// 30min\n3600.0,\n// 1hr\n7200.0,\n// 2hr\n14400.0,\n// 4hr\n21600.0,\n// 6hr\n43200.0,\n// 12hr\n86400.0,\n// 24hr\n172800.0,\n// 2days\n345600.0,\n// 4days\n604800.0,\n// 7days\n1296000.0,\n// 15days\n2592000.0,\n// 30days\n5184000.0,\n// 60days\n7776000.0,\n// 90days\n15552000.0,\n// 180days\n31536000.0,\n// 365days\n63072000.0,\n// 2years\n126144000.0,\n// 4years\n157680000.0,\n// 5years\n315360000.0,\n// 10years\n630720000.0,\n// 20years\n1261440000.0,\n// 40years\n1576800000.0,\n// 50years\n3153600000.0,\n// 100years\n6307200000.0,\n// 200years\n12614400000.0,\n// 400years\n15768000000.0,\n// 500years\n31536000000.0 // 1000years\n];\nconst timelineMonthNames = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\n/**\n * The Timeline is a widget for displaying and controlling the current scene time.\n * @alias Timeline\n * @constructor\n *\n * @param {Element} container The parent HTML container node for this widget.\n * @param {Clock} clock The clock to use.\n */\nfunction Timeline(container, clock) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(container)) {\n    throw new DeveloperError(\"container is required.\");\n  }\n  if (!defined(clock)) {\n    throw new DeveloperError(\"clock is required.\");\n  }\n  //>>includeEnd('debug');\n\n  container = getElement(container);\n  const ownerDocument = container.ownerDocument;\n\n  /**\n   * Gets the parent container.\n   * @type {Element}\n   */\n  this.container = container;\n  const topDiv = ownerDocument.createElement(\"div\");\n  topDiv.className = \"cesium-timeline-main\";\n  container.appendChild(topDiv);\n  this._topDiv = topDiv;\n  this._endJulian = undefined;\n  this._epochJulian = undefined;\n  this._lastXPos = undefined;\n  this._scrubElement = undefined;\n  this._startJulian = undefined;\n  this._timeBarSecondsSpan = undefined;\n  this._clock = clock;\n  this._scrubJulian = clock.currentTime;\n  this._mainTicSpan = -1;\n  this._mouseMode = timelineMouseMode.none;\n  this._touchMode = timelineTouchMode.none;\n  this._touchState = {\n    centerX: 0,\n    spanX: 0\n  };\n  this._mouseX = 0;\n  this._timelineDrag = 0;\n  this._timelineDragLocation = undefined;\n  this._lastHeight = undefined;\n  this._lastWidth = undefined;\n  this._topDiv.innerHTML = '<div class=\"cesium-timeline-bar\"></div><div class=\"cesium-timeline-trackContainer\">' + '<canvas class=\"cesium-timeline-tracks\" width=\"10\" height=\"1\">' + '</canvas></div><div class=\"cesium-timeline-needle\"></div><span class=\"cesium-timeline-ruler\"></span>';\n  this._timeBarEle = this._topDiv.childNodes[0];\n  this._trackContainer = this._topDiv.childNodes[1];\n  this._trackListEle = this._topDiv.childNodes[1].childNodes[0];\n  this._needleEle = this._topDiv.childNodes[2];\n  this._rulerEle = this._topDiv.childNodes[3];\n  this._context = this._trackListEle.getContext(\"2d\");\n  this._trackList = [];\n  this._highlightRanges = [];\n  this.zoomTo(clock.startTime, clock.stopTime);\n  this._onMouseDown = createMouseDownCallback(this);\n  this._onMouseUp = createMouseUpCallback(this);\n  this._onMouseMove = createMouseMoveCallback(this);\n  this._onMouseWheel = createMouseWheelCallback(this);\n  this._onTouchStart = createTouchStartCallback(this);\n  this._onTouchMove = createTouchMoveCallback(this);\n  this._onTouchEnd = createTouchEndCallback(this);\n  const timeBarEle = this._timeBarEle;\n  ownerDocument.addEventListener(\"mouseup\", this._onMouseUp, false);\n  ownerDocument.addEventListener(\"mousemove\", this._onMouseMove, false);\n  timeBarEle.addEventListener(\"mousedown\", this._onMouseDown, false);\n  timeBarEle.addEventListener(\"DOMMouseScroll\", this._onMouseWheel, false); // Mozilla mouse wheel\n  timeBarEle.addEventListener(\"mousewheel\", this._onMouseWheel, false);\n  timeBarEle.addEventListener(\"touchstart\", this._onTouchStart, false);\n  timeBarEle.addEventListener(\"touchmove\", this._onTouchMove, false);\n  timeBarEle.addEventListener(\"touchend\", this._onTouchEnd, false);\n  timeBarEle.addEventListener(\"touchcancel\", this._onTouchEnd, false);\n  this._topDiv.oncontextmenu = function () {\n    return false;\n  };\n  clock.onTick.addEventListener(this.updateFromClock, this);\n  this.updateFromClock();\n}\n\n/**\n * @private\n */\nTimeline.prototype.addEventListener = function (type, listener, useCapture) {\n  this._topDiv.addEventListener(type, listener, useCapture);\n};\n\n/**\n * @private\n */\nTimeline.prototype.removeEventListener = function (type, listener, useCapture) {\n  this._topDiv.removeEventListener(type, listener, useCapture);\n};\n\n/**\n * @returns {boolean} true if the object has been destroyed, false otherwise.\n */\nTimeline.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the widget.  Should be called if permanently\n * removing the widget from layout.\n */\nTimeline.prototype.destroy = function () {\n  this._clock.onTick.removeEventListener(this.updateFromClock, this);\n  const doc = this.container.ownerDocument;\n  doc.removeEventListener(\"mouseup\", this._onMouseUp, false);\n  doc.removeEventListener(\"mousemove\", this._onMouseMove, false);\n  const timeBarEle = this._timeBarEle;\n  timeBarEle.removeEventListener(\"mousedown\", this._onMouseDown, false);\n  timeBarEle.removeEventListener(\"DOMMouseScroll\", this._onMouseWheel, false); // Mozilla mouse wheel\n  timeBarEle.removeEventListener(\"mousewheel\", this._onMouseWheel, false);\n  timeBarEle.removeEventListener(\"touchstart\", this._onTouchStart, false);\n  timeBarEle.removeEventListener(\"touchmove\", this._onTouchMove, false);\n  timeBarEle.removeEventListener(\"touchend\", this._onTouchEnd, false);\n  timeBarEle.removeEventListener(\"touchcancel\", this._onTouchEnd, false);\n  this.container.removeChild(this._topDiv);\n  destroyObject(this);\n};\n\n/**\n * @private\n */\nTimeline.prototype.addHighlightRange = function (color, heightInPx, base) {\n  const newHighlightRange = new TimelineHighlightRange(color, heightInPx, base);\n  this._highlightRanges.push(newHighlightRange);\n  this.resize();\n  return newHighlightRange;\n};\n\n/**\n * @private\n */\nTimeline.prototype.addTrack = function (interval, heightInPx, color, backgroundColor) {\n  const newTrack = new TimelineTrack(interval, heightInPx, color, backgroundColor);\n  this._trackList.push(newTrack);\n  this._lastHeight = undefined;\n  this.resize();\n  return newTrack;\n};\n\n/**\n * Sets the view to the provided times.\n *\n * @param {JulianDate} startTime The start time.\n * @param {JulianDate} stopTime The stop time.\n */\nTimeline.prototype.zoomTo = function (startTime, stopTime) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(startTime)) {\n    throw new DeveloperError(\"startTime is required.\");\n  }\n  if (!defined(stopTime)) {\n    throw new DeveloperError(\"stopTime is required\");\n  }\n  if (JulianDate.lessThanOrEquals(stopTime, startTime)) {\n    throw new DeveloperError(\"Start time must come before end time.\");\n  }\n  //>>includeEnd('debug');\n\n  this._startJulian = startTime;\n  this._endJulian = stopTime;\n  this._timeBarSecondsSpan = JulianDate.secondsDifference(stopTime, startTime);\n\n  // If clock is not unbounded, clamp timeline range to clock.\n  if (this._clock && this._clock.clockRange !== ClockRange.UNBOUNDED) {\n    const clockStart = this._clock.startTime;\n    const clockEnd = this._clock.stopTime;\n    const clockSpan = JulianDate.secondsDifference(clockEnd, clockStart);\n    const startOffset = JulianDate.secondsDifference(clockStart, this._startJulian);\n    const endOffset = JulianDate.secondsDifference(clockEnd, this._endJulian);\n    if (this._timeBarSecondsSpan >= clockSpan) {\n      // if new duration longer than clock range duration, clamp to full range.\n      this._timeBarSecondsSpan = clockSpan;\n      this._startJulian = this._clock.startTime;\n      this._endJulian = this._clock.stopTime;\n    } else if (startOffset > 0) {\n      // if timeline start is before clock start, shift right\n      this._endJulian = JulianDate.addSeconds(this._endJulian, startOffset, new JulianDate());\n      this._startJulian = clockStart;\n      this._timeBarSecondsSpan = JulianDate.secondsDifference(this._endJulian, this._startJulian);\n    } else if (endOffset < 0) {\n      // if timeline end is after clock end, shift left\n      this._startJulian = JulianDate.addSeconds(this._startJulian, endOffset, new JulianDate());\n      this._endJulian = clockEnd;\n      this._timeBarSecondsSpan = JulianDate.secondsDifference(this._endJulian, this._startJulian);\n    }\n  }\n  this._makeTics();\n  const evt = document.createEvent(\"Event\");\n  evt.initEvent(\"setzoom\", true, true);\n  evt.startJulian = this._startJulian;\n  evt.endJulian = this._endJulian;\n  evt.epochJulian = this._epochJulian;\n  evt.totalSpan = this._timeBarSecondsSpan;\n  evt.mainTicSpan = this._mainTicSpan;\n  this._topDiv.dispatchEvent(evt);\n};\n\n/**\n * @private\n */\nTimeline.prototype.zoomFrom = function (amount) {\n  let centerSec = JulianDate.secondsDifference(this._scrubJulian, this._startJulian);\n  if (amount > 1 || centerSec < 0 || centerSec > this._timeBarSecondsSpan) {\n    centerSec = this._timeBarSecondsSpan * 0.5;\n  } else {\n    centerSec += centerSec - this._timeBarSecondsSpan * 0.5;\n  }\n  const centerSecFlip = this._timeBarSecondsSpan - centerSec;\n  this.zoomTo(JulianDate.addSeconds(this._startJulian, centerSec - centerSec * amount, new JulianDate()), JulianDate.addSeconds(this._endJulian, centerSecFlip * amount - centerSecFlip, new JulianDate()));\n};\nfunction twoDigits(num) {\n  return num < 10 ? `0${num.toString()}` : num.toString();\n}\n\n/**\n * @private\n */\nTimeline.prototype.makeLabel = function (time) {\n  const gregorian = JulianDate.toGregorianDate(time);\n  const millisecond = gregorian.millisecond;\n  let millisecondString = \" UTC\";\n  if (millisecond > 0 && this._timeBarSecondsSpan < 3600) {\n    millisecondString = Math.floor(millisecond).toString();\n    while (millisecondString.length < 3) {\n      millisecondString = `0${millisecondString}`;\n    }\n    millisecondString = `.${millisecondString}`;\n  }\n  return `${timelineMonthNames[gregorian.month - 1]} ${gregorian.day} ${gregorian.year} ${twoDigits(gregorian.hour)}:${twoDigits(gregorian.minute)}:${twoDigits(gregorian.second)}${millisecondString}`;\n};\n\n/**\n * @private\n */\nTimeline.prototype.smallestTicInPixels = 7.0;\n\n/**\n * @private\n */\nTimeline.prototype._makeTics = function () {\n  const timeBar = this._timeBarEle;\n  const seconds = JulianDate.secondsDifference(this._scrubJulian, this._startJulian);\n  const xPos = Math.round(seconds * this._topDiv.clientWidth / this._timeBarSecondsSpan);\n  const scrubX = xPos - 8;\n  let tic;\n  const widget = this;\n  this._needleEle.style.left = `${xPos.toString()}px`;\n  let tics = \"\";\n  const minimumDuration = 0.01;\n  const maximumDuration = 31536000000.0; // ~1000 years\n  const epsilon = 1e-10;\n\n  // If time step size is known, enter it here...\n  let minSize = 0;\n  let duration = this._timeBarSecondsSpan;\n  if (duration < minimumDuration) {\n    duration = minimumDuration;\n    this._timeBarSecondsSpan = minimumDuration;\n    this._endJulian = JulianDate.addSeconds(this._startJulian, minimumDuration, new JulianDate());\n  } else if (duration > maximumDuration) {\n    duration = maximumDuration;\n    this._timeBarSecondsSpan = maximumDuration;\n    this._endJulian = JulianDate.addSeconds(this._startJulian, maximumDuration, new JulianDate());\n  }\n  let timeBarWidth = this._timeBarEle.clientWidth;\n  if (timeBarWidth < 10) {\n    timeBarWidth = 10;\n  }\n  const startJulian = this._startJulian;\n\n  // epsilonTime: a small fraction of one pixel width of the timeline, measured in seconds.\n  const epsilonTime = Math.min(duration / timeBarWidth * 1e-5, 0.4);\n\n  // epochJulian: a nearby time to be considered \"zero seconds\", should be a round-ish number by human standards.\n  let epochJulian;\n  const gregorianDate = JulianDate.toGregorianDate(startJulian);\n  if (duration > 315360000) {\n    // 3650+ days visible, epoch is start of the first visible century.\n    epochJulian = JulianDate.fromDate(new Date(Date.UTC(Math.floor(gregorianDate.year / 100) * 100, 0)));\n  } else if (duration > 31536000) {\n    // 365+ days visible, epoch is start of the first visible decade.\n    epochJulian = JulianDate.fromDate(new Date(Date.UTC(Math.floor(gregorianDate.year / 10) * 10, 0)));\n  } else if (duration > 86400) {\n    // 1+ day(s) visible, epoch is start of the year.\n    epochJulian = JulianDate.fromDate(new Date(Date.UTC(gregorianDate.year, 0)));\n  } else {\n    // Less than a day on timeline, epoch is midnight of the visible day.\n    epochJulian = JulianDate.fromDate(new Date(Date.UTC(gregorianDate.year, gregorianDate.month, gregorianDate.day)));\n  }\n\n  // startTime: Seconds offset of the left side of the timeline from epochJulian.\n  const startTime = JulianDate.secondsDifference(this._startJulian, JulianDate.addSeconds(epochJulian, epsilonTime, new JulianDate()));\n  // endTime: Seconds offset of the right side of the timeline from epochJulian.\n  let endTime = startTime + duration;\n  this._epochJulian = epochJulian;\n  function getStartTic(ticScale) {\n    return Math.floor(startTime / ticScale) * ticScale;\n  }\n  function getNextTic(tic, ticScale) {\n    return Math.ceil(tic / ticScale + 0.5) * ticScale;\n  }\n  function getAlpha(time) {\n    return (time - startTime) / duration;\n  }\n  function remainder(x, y) {\n    //return x % y;\n    return x - y * Math.round(x / y);\n  }\n\n  // Width in pixels of a typical label, plus padding\n  this._rulerEle.innerHTML = this.makeLabel(JulianDate.addSeconds(this._endJulian, -minimumDuration, new JulianDate()));\n  let sampleWidth = this._rulerEle.offsetWidth + 20;\n  if (sampleWidth < 30) {\n    // Workaround an apparent IE bug with measuring the width after going full-screen from inside an iframe.\n    sampleWidth = 180;\n  }\n  const origMinSize = minSize;\n  minSize -= epsilon;\n  const renderState = {\n    startTime: startTime,\n    startJulian: startJulian,\n    epochJulian: epochJulian,\n    duration: duration,\n    timeBarWidth: timeBarWidth,\n    getAlpha: getAlpha\n  };\n  this._highlightRanges.forEach(function (highlightRange) {\n    tics += highlightRange.render(renderState);\n  });\n\n  // Calculate tic mark label spacing in the TimeBar.\n  let mainTic = 0.0,\n    subTic = 0.0,\n    tinyTic = 0.0;\n  // Ideal labeled tic as percentage of zoom interval\n  let idealTic = sampleWidth / timeBarWidth;\n  if (idealTic > 1.0) {\n    // Clamp to width of window, for thin windows.\n    idealTic = 1.0;\n  }\n  // Ideal labeled tic size in seconds\n  idealTic *= this._timeBarSecondsSpan;\n  let ticIndex = -1,\n    smallestIndex = -1;\n  const ticScaleLen = timelineTicScales.length;\n  let i;\n  for (i = 0; i < ticScaleLen; ++i) {\n    const sc = timelineTicScales[i];\n    ++ticIndex;\n    mainTic = sc;\n    // Find acceptable main tic size not smaller than ideal size.\n    if (sc > idealTic && sc > minSize) {\n      break;\n    }\n    if (smallestIndex < 0 && timeBarWidth * (sc / this._timeBarSecondsSpan) >= this.smallestTicInPixels) {\n      smallestIndex = ticIndex;\n    }\n  }\n  if (ticIndex > 0) {\n    while (ticIndex > 0) {\n      // Compute sub-tic size that evenly divides main tic.\n      --ticIndex;\n      if (Math.abs(remainder(mainTic, timelineTicScales[ticIndex])) < 0.00001) {\n        if (timelineTicScales[ticIndex] >= minSize) {\n          subTic = timelineTicScales[ticIndex];\n        }\n        break;\n      }\n    }\n    if (smallestIndex >= 0) {\n      while (smallestIndex < ticIndex) {\n        // Compute tiny tic size that evenly divides sub-tic.\n        if (Math.abs(remainder(subTic, timelineTicScales[smallestIndex])) < 0.00001 && timelineTicScales[smallestIndex] >= minSize) {\n          tinyTic = timelineTicScales[smallestIndex];\n          break;\n        }\n        ++smallestIndex;\n      }\n    }\n  }\n  minSize = origMinSize;\n  if (minSize > epsilon && tinyTic < 0.00001 && Math.abs(minSize - mainTic) > epsilon) {\n    tinyTic = minSize;\n    if (minSize <= mainTic + epsilon) {\n      subTic = 0.0;\n    }\n  }\n  let lastTextLeft = -999999,\n    textWidth;\n  if (timeBarWidth * (tinyTic / this._timeBarSecondsSpan) >= 3.0) {\n    for (tic = getStartTic(tinyTic); tic <= endTime; tic = getNextTic(tic, tinyTic)) {\n      tics += `<span class=\"cesium-timeline-ticTiny\" style=\"left: ${Math.round(timeBarWidth * getAlpha(tic)).toString()}px;\"></span>`;\n    }\n  }\n  if (timeBarWidth * (subTic / this._timeBarSecondsSpan) >= 3.0) {\n    for (tic = getStartTic(subTic); tic <= endTime; tic = getNextTic(tic, subTic)) {\n      tics += `<span class=\"cesium-timeline-ticSub\" style=\"left: ${Math.round(timeBarWidth * getAlpha(tic)).toString()}px;\"></span>`;\n    }\n  }\n  if (timeBarWidth * (mainTic / this._timeBarSecondsSpan) >= 2.0) {\n    this._mainTicSpan = mainTic;\n    endTime += mainTic;\n    tic = getStartTic(mainTic);\n    const leapSecond = JulianDate.computeTaiMinusUtc(epochJulian);\n    while (tic <= endTime) {\n      let ticTime = JulianDate.addSeconds(startJulian, tic - startTime, new JulianDate());\n      if (mainTic > 2.1) {\n        const ticLeap = JulianDate.computeTaiMinusUtc(ticTime);\n        if (Math.abs(ticLeap - leapSecond) > 0.1) {\n          tic += ticLeap - leapSecond;\n          ticTime = JulianDate.addSeconds(startJulian, tic - startTime, new JulianDate());\n        }\n      }\n      const ticLeft = Math.round(timeBarWidth * getAlpha(tic));\n      const ticLabel = this.makeLabel(ticTime);\n      this._rulerEle.innerHTML = ticLabel;\n      textWidth = this._rulerEle.offsetWidth;\n      if (textWidth < 10) {\n        // IE iframe fullscreen sampleWidth workaround, continued.\n        textWidth = sampleWidth;\n      }\n      const labelLeft = ticLeft - (textWidth / 2 - 1);\n      if (labelLeft > lastTextLeft) {\n        lastTextLeft = labelLeft + textWidth + 5;\n        tics += `<span class=\"cesium-timeline-ticMain\" style=\"left: ${ticLeft.toString()}px;\"></span>` + `<span class=\"cesium-timeline-ticLabel\" style=\"left: ${labelLeft.toString()}px;\">${ticLabel}</span>`;\n      } else {\n        tics += `<span class=\"cesium-timeline-ticSub\" style=\"left: ${ticLeft.toString()}px;\"></span>`;\n      }\n      tic = getNextTic(tic, mainTic);\n    }\n  } else {\n    this._mainTicSpan = -1;\n  }\n  tics += `<span class=\"cesium-timeline-icon16\" style=\"left:${scrubX}px;bottom:0;background-position: 0 0;\"></span>`;\n  timeBar.innerHTML = tics;\n  this._scrubElement = timeBar.lastChild;\n\n  // Clear track canvas.\n  this._context.clearRect(0, 0, this._trackListEle.width, this._trackListEle.height);\n  renderState.y = 0;\n  this._trackList.forEach(function (track) {\n    track.render(widget._context, renderState);\n    renderState.y += track.height;\n  });\n};\n\n/**\n * @private\n */\nTimeline.prototype.updateFromClock = function () {\n  this._scrubJulian = this._clock.currentTime;\n  const scrubElement = this._scrubElement;\n  if (defined(this._scrubElement)) {\n    const seconds = JulianDate.secondsDifference(this._scrubJulian, this._startJulian);\n    const xPos = Math.round(seconds * this._topDiv.clientWidth / this._timeBarSecondsSpan);\n    if (this._lastXPos !== xPos) {\n      this._lastXPos = xPos;\n      scrubElement.style.left = `${xPos - 8}px`;\n      this._needleEle.style.left = `${xPos}px`;\n    }\n  }\n  if (defined(this._timelineDragLocation)) {\n    this._setTimeBarTime(this._timelineDragLocation, this._timelineDragLocation * this._timeBarSecondsSpan / this._topDiv.clientWidth);\n    this.zoomTo(JulianDate.addSeconds(this._startJulian, this._timelineDrag, new JulianDate()), JulianDate.addSeconds(this._endJulian, this._timelineDrag, new JulianDate()));\n  }\n};\n\n/**\n * @private\n */\nTimeline.prototype._setTimeBarTime = function (xPos, seconds) {\n  xPos = Math.round(xPos);\n  this._scrubJulian = JulianDate.addSeconds(this._startJulian, seconds, new JulianDate());\n  if (this._scrubElement) {\n    const scrubX = xPos - 8;\n    this._scrubElement.style.left = `${scrubX.toString()}px`;\n    this._needleEle.style.left = `${xPos.toString()}px`;\n  }\n  const evt = document.createEvent(\"Event\");\n  evt.initEvent(\"settime\", true, true);\n  evt.clientX = xPos;\n  evt.timeSeconds = seconds;\n  evt.timeJulian = this._scrubJulian;\n  evt.clock = this._clock;\n  this._topDiv.dispatchEvent(evt);\n};\nfunction createMouseDownCallback(timeline) {\n  return function (e) {\n    if (timeline._mouseMode !== timelineMouseMode.touchOnly) {\n      if (e.button === 0) {\n        timeline._mouseMode = timelineMouseMode.scrub;\n        if (timeline._scrubElement) {\n          timeline._scrubElement.style.backgroundPosition = \"-16px 0\";\n        }\n        timeline._onMouseMove(e);\n      } else {\n        timeline._mouseX = e.clientX;\n        if (e.button === 2) {\n          timeline._mouseMode = timelineMouseMode.zoom;\n        } else {\n          timeline._mouseMode = timelineMouseMode.slide;\n        }\n      }\n    }\n    e.preventDefault();\n  };\n}\nfunction createMouseUpCallback(timeline) {\n  return function (e) {\n    timeline._mouseMode = timelineMouseMode.none;\n    if (timeline._scrubElement) {\n      timeline._scrubElement.style.backgroundPosition = \"0 0\";\n    }\n    timeline._timelineDrag = 0;\n    timeline._timelineDragLocation = undefined;\n  };\n}\nfunction createMouseMoveCallback(timeline) {\n  return function (e) {\n    let dx;\n    if (timeline._mouseMode === timelineMouseMode.scrub) {\n      e.preventDefault();\n      const x = e.clientX - timeline._topDiv.getBoundingClientRect().left;\n      if (x < 0) {\n        timeline._timelineDragLocation = 0;\n        timeline._timelineDrag = -0.01 * timeline._timeBarSecondsSpan;\n      } else if (x > timeline._topDiv.clientWidth) {\n        timeline._timelineDragLocation = timeline._topDiv.clientWidth;\n        timeline._timelineDrag = 0.01 * timeline._timeBarSecondsSpan;\n      } else {\n        timeline._timelineDragLocation = undefined;\n        timeline._setTimeBarTime(x, x * timeline._timeBarSecondsSpan / timeline._topDiv.clientWidth);\n      }\n    } else if (timeline._mouseMode === timelineMouseMode.slide) {\n      dx = timeline._mouseX - e.clientX;\n      timeline._mouseX = e.clientX;\n      if (dx !== 0) {\n        const dsec = dx * timeline._timeBarSecondsSpan / timeline._topDiv.clientWidth;\n        timeline.zoomTo(JulianDate.addSeconds(timeline._startJulian, dsec, new JulianDate()), JulianDate.addSeconds(timeline._endJulian, dsec, new JulianDate()));\n      }\n    } else if (timeline._mouseMode === timelineMouseMode.zoom) {\n      dx = timeline._mouseX - e.clientX;\n      timeline._mouseX = e.clientX;\n      if (dx !== 0) {\n        timeline.zoomFrom(Math.pow(1.01, dx));\n      }\n    }\n  };\n}\nfunction createMouseWheelCallback(timeline) {\n  return function (e) {\n    let dy = e.wheelDeltaY || e.wheelDelta || -e.detail;\n    timelineWheelDelta = Math.max(Math.min(Math.abs(dy), timelineWheelDelta), 1);\n    dy /= timelineWheelDelta;\n    timeline.zoomFrom(Math.pow(1.05, -dy));\n  };\n}\nfunction createTouchStartCallback(timeline) {\n  return function (e) {\n    const len = e.touches.length;\n    let seconds, xPos;\n    const leftX = timeline._topDiv.getBoundingClientRect().left;\n    e.preventDefault();\n    timeline._mouseMode = timelineMouseMode.touchOnly;\n    if (len === 1) {\n      seconds = JulianDate.secondsDifference(timeline._scrubJulian, timeline._startJulian);\n      xPos = Math.round(seconds * timeline._topDiv.clientWidth / timeline._timeBarSecondsSpan + leftX);\n      if (Math.abs(e.touches[0].clientX - xPos) < 50) {\n        timeline._touchMode = timelineTouchMode.scrub;\n        if (timeline._scrubElement) {\n          timeline._scrubElement.style.backgroundPosition = len === 1 ? \"-16px 0\" : \"0 0\";\n        }\n      } else {\n        timeline._touchMode = timelineTouchMode.singleTap;\n        timeline._touchState.centerX = e.touches[0].clientX - leftX;\n      }\n    } else if (len === 2) {\n      timeline._touchMode = timelineTouchMode.slideZoom;\n      timeline._touchState.centerX = (e.touches[0].clientX + e.touches[1].clientX) * 0.5 - leftX;\n      timeline._touchState.spanX = Math.abs(e.touches[0].clientX - e.touches[1].clientX);\n    } else {\n      timeline._touchMode = timelineTouchMode.ignore;\n    }\n  };\n}\nfunction createTouchEndCallback(timeline) {\n  return function (e) {\n    const len = e.touches.length,\n      leftX = timeline._topDiv.getBoundingClientRect().left;\n    if (timeline._touchMode === timelineTouchMode.singleTap) {\n      timeline._touchMode = timelineTouchMode.scrub;\n      timeline._onTouchMove(e);\n    } else if (timeline._touchMode === timelineTouchMode.scrub) {\n      timeline._onTouchMove(e);\n    }\n    timeline._mouseMode = timelineMouseMode.touchOnly;\n    if (len !== 1) {\n      timeline._touchMode = len > 0 ? timelineTouchMode.ignore : timelineTouchMode.none;\n    } else if (timeline._touchMode === timelineTouchMode.slideZoom) {\n      timeline._touchState.centerX = e.touches[0].clientX - leftX;\n    }\n    if (timeline._scrubElement) {\n      timeline._scrubElement.style.backgroundPosition = \"0 0\";\n    }\n  };\n}\nfunction createTouchMoveCallback(timeline) {\n  return function (e) {\n    let dx,\n      x,\n      len,\n      newCenter,\n      newSpan,\n      newStartTime,\n      zoom = 1;\n    const leftX = timeline._topDiv.getBoundingClientRect().left;\n    if (timeline._touchMode === timelineTouchMode.singleTap) {\n      timeline._touchMode = timelineTouchMode.slideZoom;\n    }\n    timeline._mouseMode = timelineMouseMode.touchOnly;\n    if (timeline._touchMode === timelineTouchMode.scrub) {\n      e.preventDefault();\n      if (e.changedTouches.length === 1) {\n        x = e.changedTouches[0].clientX - leftX;\n        if (x >= 0 && x <= timeline._topDiv.clientWidth) {\n          timeline._setTimeBarTime(x, x * timeline._timeBarSecondsSpan / timeline._topDiv.clientWidth);\n        }\n      }\n    } else if (timeline._touchMode === timelineTouchMode.slideZoom) {\n      len = e.touches.length;\n      if (len === 2) {\n        newCenter = (e.touches[0].clientX + e.touches[1].clientX) * 0.5 - leftX;\n        newSpan = Math.abs(e.touches[0].clientX - e.touches[1].clientX);\n      } else if (len === 1) {\n        newCenter = e.touches[0].clientX - leftX;\n        newSpan = 0;\n      }\n      if (defined(newCenter)) {\n        if (newSpan > 0 && timeline._touchState.spanX > 0) {\n          // Zoom and slide\n          zoom = timeline._touchState.spanX / newSpan;\n          newStartTime = JulianDate.addSeconds(timeline._startJulian, (timeline._touchState.centerX * timeline._timeBarSecondsSpan - newCenter * timeline._timeBarSecondsSpan * zoom) / timeline._topDiv.clientWidth, new JulianDate());\n        } else {\n          // Slide to newCenter\n          dx = timeline._touchState.centerX - newCenter;\n          newStartTime = JulianDate.addSeconds(timeline._startJulian, dx * timeline._timeBarSecondsSpan / timeline._topDiv.clientWidth, new JulianDate());\n        }\n        timeline.zoomTo(newStartTime, JulianDate.addSeconds(newStartTime, timeline._timeBarSecondsSpan * zoom, new JulianDate()));\n        timeline._touchState.centerX = newCenter;\n        timeline._touchState.spanX = newSpan;\n      }\n    }\n  };\n}\n\n/**\n * Resizes the widget to match the container size.\n */\nTimeline.prototype.resize = function () {\n  const width = this.container.clientWidth;\n  const height = this.container.clientHeight;\n  if (width === this._lastWidth && height === this._lastHeight) {\n    return;\n  }\n  this._trackContainer.style.height = `${height}px`;\n  let trackListHeight = 1;\n  this._trackList.forEach(function (track) {\n    trackListHeight += track.height;\n  });\n  this._trackListEle.style.height = `${trackListHeight.toString()}px`;\n  this._trackListEle.width = this._trackListEle.clientWidth;\n  this._trackListEle.height = trackListHeight;\n  this._makeTics();\n  this._lastXPos = undefined;\n  this._lastWidth = width;\n  this._lastHeight = height;\n};\nexport default Timeline;","map":{"version":3,"names":["ClockRange","defined","destroyObject","DeveloperError","getElement","JulianDate","TimelineHighlightRange","TimelineTrack","timelineWheelDelta","timelineMouseMode","none","scrub","slide","zoom","touchOnly","timelineTouchMode","slideZoom","singleTap","ignore","timelineTicScales","timelineMonthNames","Timeline","container","clock","ownerDocument","topDiv","createElement","className","appendChild","_topDiv","_endJulian","undefined","_epochJulian","_lastXPos","_scrubElement","_startJulian","_timeBarSecondsSpan","_clock","_scrubJulian","currentTime","_mainTicSpan","_mouseMode","_touchMode","_touchState","centerX","spanX","_mouseX","_timelineDrag","_timelineDragLocation","_lastHeight","_lastWidth","innerHTML","_timeBarEle","childNodes","_trackContainer","_trackListEle","_needleEle","_rulerEle","_context","getContext","_trackList","_highlightRanges","zoomTo","startTime","stopTime","_onMouseDown","createMouseDownCallback","_onMouseUp","createMouseUpCallback","_onMouseMove","createMouseMoveCallback","_onMouseWheel","createMouseWheelCallback","_onTouchStart","createTouchStartCallback","_onTouchMove","createTouchMoveCallback","_onTouchEnd","createTouchEndCallback","timeBarEle","addEventListener","oncontextmenu","onTick","updateFromClock","prototype","type","listener","useCapture","removeEventListener","isDestroyed","destroy","doc","removeChild","addHighlightRange","color","heightInPx","base","newHighlightRange","push","resize","addTrack","interval","backgroundColor","newTrack","lessThanOrEquals","secondsDifference","clockRange","UNBOUNDED","clockStart","clockEnd","clockSpan","startOffset","endOffset","addSeconds","_makeTics","evt","document","createEvent","initEvent","startJulian","endJulian","epochJulian","totalSpan","mainTicSpan","dispatchEvent","zoomFrom","amount","centerSec","centerSecFlip","twoDigits","num","toString","makeLabel","time","gregorian","toGregorianDate","millisecond","millisecondString","Math","floor","length","month","day","year","hour","minute","second","smallestTicInPixels","timeBar","seconds","xPos","round","clientWidth","scrubX","tic","widget","style","left","tics","minimumDuration","maximumDuration","epsilon","minSize","duration","timeBarWidth","epsilonTime","min","gregorianDate","fromDate","Date","UTC","endTime","getStartTic","ticScale","getNextTic","ceil","getAlpha","remainder","x","y","sampleWidth","offsetWidth","origMinSize","renderState","forEach","highlightRange","render","mainTic","subTic","tinyTic","idealTic","ticIndex","smallestIndex","ticScaleLen","i","sc","abs","lastTextLeft","textWidth","leapSecond","computeTaiMinusUtc","ticTime","ticLeap","ticLeft","ticLabel","labelLeft","lastChild","clearRect","width","height","track","scrubElement","_setTimeBarTime","clientX","timeSeconds","timeJulian","timeline","e","button","backgroundPosition","preventDefault","dx","getBoundingClientRect","dsec","pow","dy","wheelDeltaY","wheelDelta","detail","max","len","touches","leftX","newCenter","newSpan","newStartTime","changedTouches","clientHeight","trackListHeight"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/widgets/Source/Timeline/Timeline.js"],"sourcesContent":["import {\n  ClockRange,\n  defined,\n  destroyObject,\n  DeveloperError,\n  getElement,\n  JulianDate,\n} from \"@cesium/engine\";\nimport TimelineHighlightRange from \"./TimelineHighlightRange.js\";\nimport TimelineTrack from \"./TimelineTrack.js\";\n\nlet timelineWheelDelta = 1e12;\n\nconst timelineMouseMode = {\n  none: 0,\n  scrub: 1,\n  slide: 2,\n  zoom: 3,\n  touchOnly: 4,\n};\nconst timelineTouchMode = {\n  none: 0,\n  scrub: 1,\n  slideZoom: 2,\n  singleTap: 3,\n  ignore: 4,\n};\n\nconst timelineTicScales = [\n  0.001,\n  0.002,\n  0.005,\n  0.01,\n  0.02,\n  0.05,\n  0.1,\n  0.25,\n  0.5,\n  1.0,\n  2.0,\n  5.0,\n  10.0,\n  15.0,\n  30.0,\n  60.0, // 1min\n  120.0, // 2min\n  300.0, // 5min\n  600.0, // 10min\n  900.0, // 15min\n  1800.0, // 30min\n  3600.0, // 1hr\n  7200.0, // 2hr\n  14400.0, // 4hr\n  21600.0, // 6hr\n  43200.0, // 12hr\n  86400.0, // 24hr\n  172800.0, // 2days\n  345600.0, // 4days\n  604800.0, // 7days\n  1296000.0, // 15days\n  2592000.0, // 30days\n  5184000.0, // 60days\n  7776000.0, // 90days\n  15552000.0, // 180days\n  31536000.0, // 365days\n  63072000.0, // 2years\n  126144000.0, // 4years\n  157680000.0, // 5years\n  315360000.0, // 10years\n  630720000.0, // 20years\n  1261440000.0, // 40years\n  1576800000.0, // 50years\n  3153600000.0, // 100years\n  6307200000.0, // 200years\n  12614400000.0, // 400years\n  15768000000.0, // 500years\n  31536000000.0, // 1000years\n];\n\nconst timelineMonthNames = [\n  \"Jan\",\n  \"Feb\",\n  \"Mar\",\n  \"Apr\",\n  \"May\",\n  \"Jun\",\n  \"Jul\",\n  \"Aug\",\n  \"Sep\",\n  \"Oct\",\n  \"Nov\",\n  \"Dec\",\n];\n\n/**\n * The Timeline is a widget for displaying and controlling the current scene time.\n * @alias Timeline\n * @constructor\n *\n * @param {Element} container The parent HTML container node for this widget.\n * @param {Clock} clock The clock to use.\n */\nfunction Timeline(container, clock) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(container)) {\n    throw new DeveloperError(\"container is required.\");\n  }\n  if (!defined(clock)) {\n    throw new DeveloperError(\"clock is required.\");\n  }\n  //>>includeEnd('debug');\n\n  container = getElement(container);\n\n  const ownerDocument = container.ownerDocument;\n\n  /**\n   * Gets the parent container.\n   * @type {Element}\n   */\n  this.container = container;\n\n  const topDiv = ownerDocument.createElement(\"div\");\n  topDiv.className = \"cesium-timeline-main\";\n  container.appendChild(topDiv);\n  this._topDiv = topDiv;\n\n  this._endJulian = undefined;\n  this._epochJulian = undefined;\n  this._lastXPos = undefined;\n  this._scrubElement = undefined;\n  this._startJulian = undefined;\n  this._timeBarSecondsSpan = undefined;\n  this._clock = clock;\n  this._scrubJulian = clock.currentTime;\n  this._mainTicSpan = -1;\n  this._mouseMode = timelineMouseMode.none;\n  this._touchMode = timelineTouchMode.none;\n  this._touchState = {\n    centerX: 0,\n    spanX: 0,\n  };\n  this._mouseX = 0;\n  this._timelineDrag = 0;\n  this._timelineDragLocation = undefined;\n  this._lastHeight = undefined;\n  this._lastWidth = undefined;\n\n  this._topDiv.innerHTML =\n    '<div class=\"cesium-timeline-bar\"></div><div class=\"cesium-timeline-trackContainer\">' +\n    '<canvas class=\"cesium-timeline-tracks\" width=\"10\" height=\"1\">' +\n    '</canvas></div><div class=\"cesium-timeline-needle\"></div><span class=\"cesium-timeline-ruler\"></span>';\n  this._timeBarEle = this._topDiv.childNodes[0];\n  this._trackContainer = this._topDiv.childNodes[1];\n  this._trackListEle = this._topDiv.childNodes[1].childNodes[0];\n  this._needleEle = this._topDiv.childNodes[2];\n  this._rulerEle = this._topDiv.childNodes[3];\n  this._context = this._trackListEle.getContext(\"2d\");\n\n  this._trackList = [];\n  this._highlightRanges = [];\n\n  this.zoomTo(clock.startTime, clock.stopTime);\n\n  this._onMouseDown = createMouseDownCallback(this);\n  this._onMouseUp = createMouseUpCallback(this);\n  this._onMouseMove = createMouseMoveCallback(this);\n  this._onMouseWheel = createMouseWheelCallback(this);\n  this._onTouchStart = createTouchStartCallback(this);\n  this._onTouchMove = createTouchMoveCallback(this);\n  this._onTouchEnd = createTouchEndCallback(this);\n\n  const timeBarEle = this._timeBarEle;\n  ownerDocument.addEventListener(\"mouseup\", this._onMouseUp, false);\n  ownerDocument.addEventListener(\"mousemove\", this._onMouseMove, false);\n  timeBarEle.addEventListener(\"mousedown\", this._onMouseDown, false);\n  timeBarEle.addEventListener(\"DOMMouseScroll\", this._onMouseWheel, false); // Mozilla mouse wheel\n  timeBarEle.addEventListener(\"mousewheel\", this._onMouseWheel, false);\n  timeBarEle.addEventListener(\"touchstart\", this._onTouchStart, false);\n  timeBarEle.addEventListener(\"touchmove\", this._onTouchMove, false);\n  timeBarEle.addEventListener(\"touchend\", this._onTouchEnd, false);\n  timeBarEle.addEventListener(\"touchcancel\", this._onTouchEnd, false);\n\n  this._topDiv.oncontextmenu = function () {\n    return false;\n  };\n\n  clock.onTick.addEventListener(this.updateFromClock, this);\n  this.updateFromClock();\n}\n\n/**\n * @private\n */\nTimeline.prototype.addEventListener = function (type, listener, useCapture) {\n  this._topDiv.addEventListener(type, listener, useCapture);\n};\n\n/**\n * @private\n */\nTimeline.prototype.removeEventListener = function (type, listener, useCapture) {\n  this._topDiv.removeEventListener(type, listener, useCapture);\n};\n\n/**\n * @returns {boolean} true if the object has been destroyed, false otherwise.\n */\nTimeline.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the widget.  Should be called if permanently\n * removing the widget from layout.\n */\nTimeline.prototype.destroy = function () {\n  this._clock.onTick.removeEventListener(this.updateFromClock, this);\n\n  const doc = this.container.ownerDocument;\n  doc.removeEventListener(\"mouseup\", this._onMouseUp, false);\n  doc.removeEventListener(\"mousemove\", this._onMouseMove, false);\n\n  const timeBarEle = this._timeBarEle;\n  timeBarEle.removeEventListener(\"mousedown\", this._onMouseDown, false);\n  timeBarEle.removeEventListener(\"DOMMouseScroll\", this._onMouseWheel, false); // Mozilla mouse wheel\n  timeBarEle.removeEventListener(\"mousewheel\", this._onMouseWheel, false);\n  timeBarEle.removeEventListener(\"touchstart\", this._onTouchStart, false);\n  timeBarEle.removeEventListener(\"touchmove\", this._onTouchMove, false);\n  timeBarEle.removeEventListener(\"touchend\", this._onTouchEnd, false);\n  timeBarEle.removeEventListener(\"touchcancel\", this._onTouchEnd, false);\n  this.container.removeChild(this._topDiv);\n  destroyObject(this);\n};\n\n/**\n * @private\n */\nTimeline.prototype.addHighlightRange = function (color, heightInPx, base) {\n  const newHighlightRange = new TimelineHighlightRange(color, heightInPx, base);\n  this._highlightRanges.push(newHighlightRange);\n  this.resize();\n  return newHighlightRange;\n};\n\n/**\n * @private\n */\nTimeline.prototype.addTrack = function (\n  interval,\n  heightInPx,\n  color,\n  backgroundColor,\n) {\n  const newTrack = new TimelineTrack(\n    interval,\n    heightInPx,\n    color,\n    backgroundColor,\n  );\n  this._trackList.push(newTrack);\n  this._lastHeight = undefined;\n  this.resize();\n  return newTrack;\n};\n\n/**\n * Sets the view to the provided times.\n *\n * @param {JulianDate} startTime The start time.\n * @param {JulianDate} stopTime The stop time.\n */\nTimeline.prototype.zoomTo = function (startTime, stopTime) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(startTime)) {\n    throw new DeveloperError(\"startTime is required.\");\n  }\n  if (!defined(stopTime)) {\n    throw new DeveloperError(\"stopTime is required\");\n  }\n  if (JulianDate.lessThanOrEquals(stopTime, startTime)) {\n    throw new DeveloperError(\"Start time must come before end time.\");\n  }\n  //>>includeEnd('debug');\n\n  this._startJulian = startTime;\n  this._endJulian = stopTime;\n  this._timeBarSecondsSpan = JulianDate.secondsDifference(stopTime, startTime);\n\n  // If clock is not unbounded, clamp timeline range to clock.\n  if (this._clock && this._clock.clockRange !== ClockRange.UNBOUNDED) {\n    const clockStart = this._clock.startTime;\n    const clockEnd = this._clock.stopTime;\n    const clockSpan = JulianDate.secondsDifference(clockEnd, clockStart);\n    const startOffset = JulianDate.secondsDifference(\n      clockStart,\n      this._startJulian,\n    );\n    const endOffset = JulianDate.secondsDifference(clockEnd, this._endJulian);\n\n    if (this._timeBarSecondsSpan >= clockSpan) {\n      // if new duration longer than clock range duration, clamp to full range.\n      this._timeBarSecondsSpan = clockSpan;\n      this._startJulian = this._clock.startTime;\n      this._endJulian = this._clock.stopTime;\n    } else if (startOffset > 0) {\n      // if timeline start is before clock start, shift right\n      this._endJulian = JulianDate.addSeconds(\n        this._endJulian,\n        startOffset,\n        new JulianDate(),\n      );\n      this._startJulian = clockStart;\n      this._timeBarSecondsSpan = JulianDate.secondsDifference(\n        this._endJulian,\n        this._startJulian,\n      );\n    } else if (endOffset < 0) {\n      // if timeline end is after clock end, shift left\n      this._startJulian = JulianDate.addSeconds(\n        this._startJulian,\n        endOffset,\n        new JulianDate(),\n      );\n      this._endJulian = clockEnd;\n      this._timeBarSecondsSpan = JulianDate.secondsDifference(\n        this._endJulian,\n        this._startJulian,\n      );\n    }\n  }\n\n  this._makeTics();\n\n  const evt = document.createEvent(\"Event\");\n  evt.initEvent(\"setzoom\", true, true);\n  evt.startJulian = this._startJulian;\n  evt.endJulian = this._endJulian;\n  evt.epochJulian = this._epochJulian;\n  evt.totalSpan = this._timeBarSecondsSpan;\n  evt.mainTicSpan = this._mainTicSpan;\n  this._topDiv.dispatchEvent(evt);\n};\n\n/**\n * @private\n */\nTimeline.prototype.zoomFrom = function (amount) {\n  let centerSec = JulianDate.secondsDifference(\n    this._scrubJulian,\n    this._startJulian,\n  );\n  if (amount > 1 || centerSec < 0 || centerSec > this._timeBarSecondsSpan) {\n    centerSec = this._timeBarSecondsSpan * 0.5;\n  } else {\n    centerSec += centerSec - this._timeBarSecondsSpan * 0.5;\n  }\n  const centerSecFlip = this._timeBarSecondsSpan - centerSec;\n  this.zoomTo(\n    JulianDate.addSeconds(\n      this._startJulian,\n      centerSec - centerSec * amount,\n      new JulianDate(),\n    ),\n    JulianDate.addSeconds(\n      this._endJulian,\n      centerSecFlip * amount - centerSecFlip,\n      new JulianDate(),\n    ),\n  );\n};\n\nfunction twoDigits(num) {\n  return num < 10 ? `0${num.toString()}` : num.toString();\n}\n\n/**\n * @private\n */\nTimeline.prototype.makeLabel = function (time) {\n  const gregorian = JulianDate.toGregorianDate(time);\n  const millisecond = gregorian.millisecond;\n  let millisecondString = \" UTC\";\n  if (millisecond > 0 && this._timeBarSecondsSpan < 3600) {\n    millisecondString = Math.floor(millisecond).toString();\n    while (millisecondString.length < 3) {\n      millisecondString = `0${millisecondString}`;\n    }\n    millisecondString = `.${millisecondString}`;\n  }\n\n  return `${timelineMonthNames[gregorian.month - 1]} ${gregorian.day} ${\n    gregorian.year\n  } ${twoDigits(gregorian.hour)}:${twoDigits(gregorian.minute)}:${twoDigits(\n    gregorian.second,\n  )}${millisecondString}`;\n};\n\n/**\n * @private\n */\nTimeline.prototype.smallestTicInPixels = 7.0;\n\n/**\n * @private\n */\nTimeline.prototype._makeTics = function () {\n  const timeBar = this._timeBarEle;\n\n  const seconds = JulianDate.secondsDifference(\n    this._scrubJulian,\n    this._startJulian,\n  );\n  const xPos = Math.round(\n    (seconds * this._topDiv.clientWidth) / this._timeBarSecondsSpan,\n  );\n  const scrubX = xPos - 8;\n  let tic;\n  const widget = this;\n\n  this._needleEle.style.left = `${xPos.toString()}px`;\n\n  let tics = \"\";\n\n  const minimumDuration = 0.01;\n  const maximumDuration = 31536000000.0; // ~1000 years\n  const epsilon = 1e-10;\n\n  // If time step size is known, enter it here...\n  let minSize = 0;\n\n  let duration = this._timeBarSecondsSpan;\n  if (duration < minimumDuration) {\n    duration = minimumDuration;\n    this._timeBarSecondsSpan = minimumDuration;\n    this._endJulian = JulianDate.addSeconds(\n      this._startJulian,\n      minimumDuration,\n      new JulianDate(),\n    );\n  } else if (duration > maximumDuration) {\n    duration = maximumDuration;\n    this._timeBarSecondsSpan = maximumDuration;\n    this._endJulian = JulianDate.addSeconds(\n      this._startJulian,\n      maximumDuration,\n      new JulianDate(),\n    );\n  }\n\n  let timeBarWidth = this._timeBarEle.clientWidth;\n  if (timeBarWidth < 10) {\n    timeBarWidth = 10;\n  }\n  const startJulian = this._startJulian;\n\n  // epsilonTime: a small fraction of one pixel width of the timeline, measured in seconds.\n  const epsilonTime = Math.min((duration / timeBarWidth) * 1e-5, 0.4);\n\n  // epochJulian: a nearby time to be considered \"zero seconds\", should be a round-ish number by human standards.\n  let epochJulian;\n  const gregorianDate = JulianDate.toGregorianDate(startJulian);\n  if (duration > 315360000) {\n    // 3650+ days visible, epoch is start of the first visible century.\n    epochJulian = JulianDate.fromDate(\n      new Date(Date.UTC(Math.floor(gregorianDate.year / 100) * 100, 0)),\n    );\n  } else if (duration > 31536000) {\n    // 365+ days visible, epoch is start of the first visible decade.\n    epochJulian = JulianDate.fromDate(\n      new Date(Date.UTC(Math.floor(gregorianDate.year / 10) * 10, 0)),\n    );\n  } else if (duration > 86400) {\n    // 1+ day(s) visible, epoch is start of the year.\n    epochJulian = JulianDate.fromDate(\n      new Date(Date.UTC(gregorianDate.year, 0)),\n    );\n  } else {\n    // Less than a day on timeline, epoch is midnight of the visible day.\n    epochJulian = JulianDate.fromDate(\n      new Date(\n        Date.UTC(gregorianDate.year, gregorianDate.month, gregorianDate.day),\n      ),\n    );\n  }\n\n  // startTime: Seconds offset of the left side of the timeline from epochJulian.\n  const startTime = JulianDate.secondsDifference(\n    this._startJulian,\n    JulianDate.addSeconds(epochJulian, epsilonTime, new JulianDate()),\n  );\n  // endTime: Seconds offset of the right side of the timeline from epochJulian.\n  let endTime = startTime + duration;\n  this._epochJulian = epochJulian;\n\n  function getStartTic(ticScale) {\n    return Math.floor(startTime / ticScale) * ticScale;\n  }\n\n  function getNextTic(tic, ticScale) {\n    return Math.ceil(tic / ticScale + 0.5) * ticScale;\n  }\n\n  function getAlpha(time) {\n    return (time - startTime) / duration;\n  }\n\n  function remainder(x, y) {\n    //return x % y;\n    return x - y * Math.round(x / y);\n  }\n\n  // Width in pixels of a typical label, plus padding\n  this._rulerEle.innerHTML = this.makeLabel(\n    JulianDate.addSeconds(this._endJulian, -minimumDuration, new JulianDate()),\n  );\n  let sampleWidth = this._rulerEle.offsetWidth + 20;\n  if (sampleWidth < 30) {\n    // Workaround an apparent IE bug with measuring the width after going full-screen from inside an iframe.\n    sampleWidth = 180;\n  }\n\n  const origMinSize = minSize;\n  minSize -= epsilon;\n\n  const renderState = {\n    startTime: startTime,\n    startJulian: startJulian,\n    epochJulian: epochJulian,\n    duration: duration,\n    timeBarWidth: timeBarWidth,\n    getAlpha: getAlpha,\n  };\n  this._highlightRanges.forEach(function (highlightRange) {\n    tics += highlightRange.render(renderState);\n  });\n\n  // Calculate tic mark label spacing in the TimeBar.\n  let mainTic = 0.0,\n    subTic = 0.0,\n    tinyTic = 0.0;\n  // Ideal labeled tic as percentage of zoom interval\n  let idealTic = sampleWidth / timeBarWidth;\n  if (idealTic > 1.0) {\n    // Clamp to width of window, for thin windows.\n    idealTic = 1.0;\n  }\n  // Ideal labeled tic size in seconds\n  idealTic *= this._timeBarSecondsSpan;\n  let ticIndex = -1,\n    smallestIndex = -1;\n\n  const ticScaleLen = timelineTicScales.length;\n  let i;\n  for (i = 0; i < ticScaleLen; ++i) {\n    const sc = timelineTicScales[i];\n    ++ticIndex;\n    mainTic = sc;\n    // Find acceptable main tic size not smaller than ideal size.\n    if (sc > idealTic && sc > minSize) {\n      break;\n    }\n    if (\n      smallestIndex < 0 &&\n      timeBarWidth * (sc / this._timeBarSecondsSpan) >= this.smallestTicInPixels\n    ) {\n      smallestIndex = ticIndex;\n    }\n  }\n  if (ticIndex > 0) {\n    while (ticIndex > 0) {\n      // Compute sub-tic size that evenly divides main tic.\n      --ticIndex;\n      if (Math.abs(remainder(mainTic, timelineTicScales[ticIndex])) < 0.00001) {\n        if (timelineTicScales[ticIndex] >= minSize) {\n          subTic = timelineTicScales[ticIndex];\n        }\n        break;\n      }\n    }\n\n    if (smallestIndex >= 0) {\n      while (smallestIndex < ticIndex) {\n        // Compute tiny tic size that evenly divides sub-tic.\n        if (\n          Math.abs(remainder(subTic, timelineTicScales[smallestIndex])) <\n            0.00001 &&\n          timelineTicScales[smallestIndex] >= minSize\n        ) {\n          tinyTic = timelineTicScales[smallestIndex];\n          break;\n        }\n        ++smallestIndex;\n      }\n    }\n  }\n\n  minSize = origMinSize;\n  if (\n    minSize > epsilon &&\n    tinyTic < 0.00001 &&\n    Math.abs(minSize - mainTic) > epsilon\n  ) {\n    tinyTic = minSize;\n    if (minSize <= mainTic + epsilon) {\n      subTic = 0.0;\n    }\n  }\n\n  let lastTextLeft = -999999,\n    textWidth;\n  if (timeBarWidth * (tinyTic / this._timeBarSecondsSpan) >= 3.0) {\n    for (\n      tic = getStartTic(tinyTic);\n      tic <= endTime;\n      tic = getNextTic(tic, tinyTic)\n    ) {\n      tics += `<span class=\"cesium-timeline-ticTiny\" style=\"left: ${Math.round(\n        timeBarWidth * getAlpha(tic),\n      ).toString()}px;\"></span>`;\n    }\n  }\n  if (timeBarWidth * (subTic / this._timeBarSecondsSpan) >= 3.0) {\n    for (\n      tic = getStartTic(subTic);\n      tic <= endTime;\n      tic = getNextTic(tic, subTic)\n    ) {\n      tics += `<span class=\"cesium-timeline-ticSub\" style=\"left: ${Math.round(\n        timeBarWidth * getAlpha(tic),\n      ).toString()}px;\"></span>`;\n    }\n  }\n  if (timeBarWidth * (mainTic / this._timeBarSecondsSpan) >= 2.0) {\n    this._mainTicSpan = mainTic;\n    endTime += mainTic;\n    tic = getStartTic(mainTic);\n    const leapSecond = JulianDate.computeTaiMinusUtc(epochJulian);\n    while (tic <= endTime) {\n      let ticTime = JulianDate.addSeconds(\n        startJulian,\n        tic - startTime,\n        new JulianDate(),\n      );\n      if (mainTic > 2.1) {\n        const ticLeap = JulianDate.computeTaiMinusUtc(ticTime);\n        if (Math.abs(ticLeap - leapSecond) > 0.1) {\n          tic += ticLeap - leapSecond;\n          ticTime = JulianDate.addSeconds(\n            startJulian,\n            tic - startTime,\n            new JulianDate(),\n          );\n        }\n      }\n      const ticLeft = Math.round(timeBarWidth * getAlpha(tic));\n      const ticLabel = this.makeLabel(ticTime);\n      this._rulerEle.innerHTML = ticLabel;\n      textWidth = this._rulerEle.offsetWidth;\n      if (textWidth < 10) {\n        // IE iframe fullscreen sampleWidth workaround, continued.\n        textWidth = sampleWidth;\n      }\n      const labelLeft = ticLeft - (textWidth / 2 - 1);\n      if (labelLeft > lastTextLeft) {\n        lastTextLeft = labelLeft + textWidth + 5;\n        tics +=\n          `<span class=\"cesium-timeline-ticMain\" style=\"left: ${ticLeft.toString()}px;\"></span>` +\n          `<span class=\"cesium-timeline-ticLabel\" style=\"left: ${labelLeft.toString()}px;\">${ticLabel}</span>`;\n      } else {\n        tics += `<span class=\"cesium-timeline-ticSub\" style=\"left: ${ticLeft.toString()}px;\"></span>`;\n      }\n      tic = getNextTic(tic, mainTic);\n    }\n  } else {\n    this._mainTicSpan = -1;\n  }\n\n  tics += `<span class=\"cesium-timeline-icon16\" style=\"left:${scrubX}px;bottom:0;background-position: 0 0;\"></span>`;\n  timeBar.innerHTML = tics;\n  this._scrubElement = timeBar.lastChild;\n\n  // Clear track canvas.\n  this._context.clearRect(\n    0,\n    0,\n    this._trackListEle.width,\n    this._trackListEle.height,\n  );\n\n  renderState.y = 0;\n  this._trackList.forEach(function (track) {\n    track.render(widget._context, renderState);\n    renderState.y += track.height;\n  });\n};\n\n/**\n * @private\n */\nTimeline.prototype.updateFromClock = function () {\n  this._scrubJulian = this._clock.currentTime;\n  const scrubElement = this._scrubElement;\n  if (defined(this._scrubElement)) {\n    const seconds = JulianDate.secondsDifference(\n      this._scrubJulian,\n      this._startJulian,\n    );\n    const xPos = Math.round(\n      (seconds * this._topDiv.clientWidth) / this._timeBarSecondsSpan,\n    );\n\n    if (this._lastXPos !== xPos) {\n      this._lastXPos = xPos;\n\n      scrubElement.style.left = `${xPos - 8}px`;\n      this._needleEle.style.left = `${xPos}px`;\n    }\n  }\n  if (defined(this._timelineDragLocation)) {\n    this._setTimeBarTime(\n      this._timelineDragLocation,\n      (this._timelineDragLocation * this._timeBarSecondsSpan) /\n        this._topDiv.clientWidth,\n    );\n    this.zoomTo(\n      JulianDate.addSeconds(\n        this._startJulian,\n        this._timelineDrag,\n        new JulianDate(),\n      ),\n      JulianDate.addSeconds(\n        this._endJulian,\n        this._timelineDrag,\n        new JulianDate(),\n      ),\n    );\n  }\n};\n\n/**\n * @private\n */\nTimeline.prototype._setTimeBarTime = function (xPos, seconds) {\n  xPos = Math.round(xPos);\n  this._scrubJulian = JulianDate.addSeconds(\n    this._startJulian,\n    seconds,\n    new JulianDate(),\n  );\n  if (this._scrubElement) {\n    const scrubX = xPos - 8;\n    this._scrubElement.style.left = `${scrubX.toString()}px`;\n    this._needleEle.style.left = `${xPos.toString()}px`;\n  }\n\n  const evt = document.createEvent(\"Event\");\n  evt.initEvent(\"settime\", true, true);\n  evt.clientX = xPos;\n  evt.timeSeconds = seconds;\n  evt.timeJulian = this._scrubJulian;\n  evt.clock = this._clock;\n  this._topDiv.dispatchEvent(evt);\n};\n\nfunction createMouseDownCallback(timeline) {\n  return function (e) {\n    if (timeline._mouseMode !== timelineMouseMode.touchOnly) {\n      if (e.button === 0) {\n        timeline._mouseMode = timelineMouseMode.scrub;\n        if (timeline._scrubElement) {\n          timeline._scrubElement.style.backgroundPosition = \"-16px 0\";\n        }\n        timeline._onMouseMove(e);\n      } else {\n        timeline._mouseX = e.clientX;\n        if (e.button === 2) {\n          timeline._mouseMode = timelineMouseMode.zoom;\n        } else {\n          timeline._mouseMode = timelineMouseMode.slide;\n        }\n      }\n    }\n    e.preventDefault();\n  };\n}\n\nfunction createMouseUpCallback(timeline) {\n  return function (e) {\n    timeline._mouseMode = timelineMouseMode.none;\n    if (timeline._scrubElement) {\n      timeline._scrubElement.style.backgroundPosition = \"0 0\";\n    }\n    timeline._timelineDrag = 0;\n    timeline._timelineDragLocation = undefined;\n  };\n}\n\nfunction createMouseMoveCallback(timeline) {\n  return function (e) {\n    let dx;\n    if (timeline._mouseMode === timelineMouseMode.scrub) {\n      e.preventDefault();\n      const x = e.clientX - timeline._topDiv.getBoundingClientRect().left;\n\n      if (x < 0) {\n        timeline._timelineDragLocation = 0;\n        timeline._timelineDrag = -0.01 * timeline._timeBarSecondsSpan;\n      } else if (x > timeline._topDiv.clientWidth) {\n        timeline._timelineDragLocation = timeline._topDiv.clientWidth;\n        timeline._timelineDrag = 0.01 * timeline._timeBarSecondsSpan;\n      } else {\n        timeline._timelineDragLocation = undefined;\n        timeline._setTimeBarTime(\n          x,\n          (x * timeline._timeBarSecondsSpan) / timeline._topDiv.clientWidth,\n        );\n      }\n    } else if (timeline._mouseMode === timelineMouseMode.slide) {\n      dx = timeline._mouseX - e.clientX;\n      timeline._mouseX = e.clientX;\n      if (dx !== 0) {\n        const dsec =\n          (dx * timeline._timeBarSecondsSpan) / timeline._topDiv.clientWidth;\n        timeline.zoomTo(\n          JulianDate.addSeconds(timeline._startJulian, dsec, new JulianDate()),\n          JulianDate.addSeconds(timeline._endJulian, dsec, new JulianDate()),\n        );\n      }\n    } else if (timeline._mouseMode === timelineMouseMode.zoom) {\n      dx = timeline._mouseX - e.clientX;\n      timeline._mouseX = e.clientX;\n      if (dx !== 0) {\n        timeline.zoomFrom(Math.pow(1.01, dx));\n      }\n    }\n  };\n}\n\nfunction createMouseWheelCallback(timeline) {\n  return function (e) {\n    let dy = e.wheelDeltaY || e.wheelDelta || -e.detail;\n    timelineWheelDelta = Math.max(\n      Math.min(Math.abs(dy), timelineWheelDelta),\n      1,\n    );\n    dy /= timelineWheelDelta;\n    timeline.zoomFrom(Math.pow(1.05, -dy));\n  };\n}\n\nfunction createTouchStartCallback(timeline) {\n  return function (e) {\n    const len = e.touches.length;\n    let seconds, xPos;\n    const leftX = timeline._topDiv.getBoundingClientRect().left;\n    e.preventDefault();\n    timeline._mouseMode = timelineMouseMode.touchOnly;\n    if (len === 1) {\n      seconds = JulianDate.secondsDifference(\n        timeline._scrubJulian,\n        timeline._startJulian,\n      );\n      xPos = Math.round(\n        (seconds * timeline._topDiv.clientWidth) /\n          timeline._timeBarSecondsSpan +\n          leftX,\n      );\n      if (Math.abs(e.touches[0].clientX - xPos) < 50) {\n        timeline._touchMode = timelineTouchMode.scrub;\n        if (timeline._scrubElement) {\n          timeline._scrubElement.style.backgroundPosition =\n            len === 1 ? \"-16px 0\" : \"0 0\";\n        }\n      } else {\n        timeline._touchMode = timelineTouchMode.singleTap;\n        timeline._touchState.centerX = e.touches[0].clientX - leftX;\n      }\n    } else if (len === 2) {\n      timeline._touchMode = timelineTouchMode.slideZoom;\n      timeline._touchState.centerX =\n        (e.touches[0].clientX + e.touches[1].clientX) * 0.5 - leftX;\n      timeline._touchState.spanX = Math.abs(\n        e.touches[0].clientX - e.touches[1].clientX,\n      );\n    } else {\n      timeline._touchMode = timelineTouchMode.ignore;\n    }\n  };\n}\n\nfunction createTouchEndCallback(timeline) {\n  return function (e) {\n    const len = e.touches.length,\n      leftX = timeline._topDiv.getBoundingClientRect().left;\n    if (timeline._touchMode === timelineTouchMode.singleTap) {\n      timeline._touchMode = timelineTouchMode.scrub;\n      timeline._onTouchMove(e);\n    } else if (timeline._touchMode === timelineTouchMode.scrub) {\n      timeline._onTouchMove(e);\n    }\n    timeline._mouseMode = timelineMouseMode.touchOnly;\n    if (len !== 1) {\n      timeline._touchMode =\n        len > 0 ? timelineTouchMode.ignore : timelineTouchMode.none;\n    } else if (timeline._touchMode === timelineTouchMode.slideZoom) {\n      timeline._touchState.centerX = e.touches[0].clientX - leftX;\n    }\n    if (timeline._scrubElement) {\n      timeline._scrubElement.style.backgroundPosition = \"0 0\";\n    }\n  };\n}\n\nfunction createTouchMoveCallback(timeline) {\n  return function (e) {\n    let dx,\n      x,\n      len,\n      newCenter,\n      newSpan,\n      newStartTime,\n      zoom = 1;\n    const leftX = timeline._topDiv.getBoundingClientRect().left;\n    if (timeline._touchMode === timelineTouchMode.singleTap) {\n      timeline._touchMode = timelineTouchMode.slideZoom;\n    }\n    timeline._mouseMode = timelineMouseMode.touchOnly;\n    if (timeline._touchMode === timelineTouchMode.scrub) {\n      e.preventDefault();\n      if (e.changedTouches.length === 1) {\n        x = e.changedTouches[0].clientX - leftX;\n        if (x >= 0 && x <= timeline._topDiv.clientWidth) {\n          timeline._setTimeBarTime(\n            x,\n            (x * timeline._timeBarSecondsSpan) / timeline._topDiv.clientWidth,\n          );\n        }\n      }\n    } else if (timeline._touchMode === timelineTouchMode.slideZoom) {\n      len = e.touches.length;\n      if (len === 2) {\n        newCenter = (e.touches[0].clientX + e.touches[1].clientX) * 0.5 - leftX;\n        newSpan = Math.abs(e.touches[0].clientX - e.touches[1].clientX);\n      } else if (len === 1) {\n        newCenter = e.touches[0].clientX - leftX;\n        newSpan = 0;\n      }\n\n      if (defined(newCenter)) {\n        if (newSpan > 0 && timeline._touchState.spanX > 0) {\n          // Zoom and slide\n          zoom = timeline._touchState.spanX / newSpan;\n          newStartTime = JulianDate.addSeconds(\n            timeline._startJulian,\n            (timeline._touchState.centerX * timeline._timeBarSecondsSpan -\n              newCenter * timeline._timeBarSecondsSpan * zoom) /\n              timeline._topDiv.clientWidth,\n            new JulianDate(),\n          );\n        } else {\n          // Slide to newCenter\n          dx = timeline._touchState.centerX - newCenter;\n          newStartTime = JulianDate.addSeconds(\n            timeline._startJulian,\n            (dx * timeline._timeBarSecondsSpan) / timeline._topDiv.clientWidth,\n            new JulianDate(),\n          );\n        }\n\n        timeline.zoomTo(\n          newStartTime,\n          JulianDate.addSeconds(\n            newStartTime,\n            timeline._timeBarSecondsSpan * zoom,\n            new JulianDate(),\n          ),\n        );\n        timeline._touchState.centerX = newCenter;\n        timeline._touchState.spanX = newSpan;\n      }\n    }\n  };\n}\n\n/**\n * Resizes the widget to match the container size.\n */\nTimeline.prototype.resize = function () {\n  const width = this.container.clientWidth;\n  const height = this.container.clientHeight;\n\n  if (width === this._lastWidth && height === this._lastHeight) {\n    return;\n  }\n\n  this._trackContainer.style.height = `${height}px`;\n\n  let trackListHeight = 1;\n  this._trackList.forEach(function (track) {\n    trackListHeight += track.height;\n  });\n  this._trackListEle.style.height = `${trackListHeight.toString()}px`;\n  this._trackListEle.width = this._trackListEle.clientWidth;\n  this._trackListEle.height = trackListHeight;\n  this._makeTics();\n\n  this._lastXPos = undefined;\n  this._lastWidth = width;\n  this._lastHeight = height;\n};\nexport default Timeline;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}