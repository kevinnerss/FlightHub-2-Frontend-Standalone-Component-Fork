{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport EllipsoidalOccluder from \"../Core/EllipsoidalOccluder.js\";\nimport Event from \"../Core/Event.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Billboard from \"../Scene/Billboard.js\";\nimport BillboardCollection from \"../Scene/BillboardCollection.js\";\nimport Label from \"../Scene/Label.js\";\nimport LabelCollection from \"../Scene/LabelCollection.js\";\nimport PointPrimitive from \"../Scene/PointPrimitive.js\";\nimport PointPrimitiveCollection from \"../Scene/PointPrimitiveCollection.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport KDBush from \"kdbush\";\n\n/**\n * Defines how screen space objects (billboards, points, labels) are clustered.\n *\n * @param {object} [options] An object with the following properties:\n * @param {boolean} [options.enabled=false] Whether or not to enable clustering.\n * @param {number} [options.pixelRange=80] The pixel range to extend the screen space bounding box.\n * @param {number} [options.minimumClusterSize=2] The minimum number of screen space objects that can be clustered.\n * @param {boolean} [options.clusterBillboards=true] Whether or not to cluster the billboards of an entity.\n * @param {boolean} [options.clusterLabels=true] Whether or not to cluster the labels of an entity.\n * @param {boolean} [options.clusterPoints=true] Whether or not to cluster the points of an entity.\n * @param {boolean} [options.show=true] Determines if the entities in the cluster will be shown.\n *\n * @alias EntityCluster\n * @constructor\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Clustering.html|Cesium Sandcastle Clustering Demo}\n */\nfunction EntityCluster(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  this._enabled = options.enabled ?? false;\n  this._pixelRange = options.pixelRange ?? 80;\n  this._minimumClusterSize = options.minimumClusterSize ?? 2;\n  this._clusterBillboards = options.clusterBillboards ?? true;\n  this._clusterLabels = options.clusterLabels ?? true;\n  this._clusterPoints = options.clusterPoints ?? true;\n  this._labelCollection = undefined;\n  this._billboardCollection = undefined;\n  this._pointCollection = undefined;\n  this._clusterBillboardCollection = undefined;\n  this._clusterLabelCollection = undefined;\n  this._clusterPointCollection = undefined;\n  this._collectionIndicesByEntity = {};\n  this._unusedLabelIndices = [];\n  this._unusedBillboardIndices = [];\n  this._unusedPointIndices = [];\n  this._previousClusters = [];\n  this._previousHeight = undefined;\n  this._enabledDirty = false;\n  this._clusterDirty = false;\n  this._cluster = undefined;\n  this._removeEventListener = undefined;\n  this._clusterEvent = new Event();\n\n  /**\n   * Determines if entities in this collection will be shown.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.show = options.show ?? true;\n}\nfunction expandBoundingBox(bbox, pixelRange) {\n  bbox.x -= pixelRange;\n  bbox.y -= pixelRange;\n  bbox.width += pixelRange * 2.0;\n  bbox.height += pixelRange * 2.0;\n}\nconst labelBoundingBoxScratch = new BoundingRectangle();\nfunction getBoundingBox(item, coord, pixelRange, entityCluster, result) {\n  if (defined(item._labelCollection) && entityCluster._clusterLabels) {\n    result = Label.getScreenSpaceBoundingBox(item, coord, result);\n  } else if (defined(item._billboardCollection) && entityCluster._clusterBillboards) {\n    result = Billboard.getScreenSpaceBoundingBox(item, coord, result);\n  } else if (defined(item._pointPrimitiveCollection) && entityCluster._clusterPoints) {\n    result = PointPrimitive.getScreenSpaceBoundingBox(item, coord, result);\n  }\n  expandBoundingBox(result, pixelRange);\n  if (entityCluster._clusterLabels && !defined(item._labelCollection) && defined(item.id) && hasLabelIndex(entityCluster, item.id.id) && defined(item.id._label)) {\n    const labelIndex = entityCluster._collectionIndicesByEntity[item.id.id].labelIndex;\n    const label = entityCluster._labelCollection.get(labelIndex);\n    const labelBBox = Label.getScreenSpaceBoundingBox(label, coord, labelBoundingBoxScratch);\n    expandBoundingBox(labelBBox, pixelRange);\n    result = BoundingRectangle.union(result, labelBBox, result);\n  }\n  return result;\n}\nfunction addNonClusteredItem(item, entityCluster) {\n  item.clusterShow = true;\n  if (!defined(item._labelCollection) && defined(item.id) && hasLabelIndex(entityCluster, item.id.id) && defined(item.id._label)) {\n    const labelIndex = entityCluster._collectionIndicesByEntity[item.id.id].labelIndex;\n    const label = entityCluster._labelCollection.get(labelIndex);\n    label.clusterShow = true;\n  }\n}\nfunction addCluster(position, numPoints, ids, entityCluster) {\n  const cluster = {\n    billboard: entityCluster._clusterBillboardCollection.add(),\n    label: entityCluster._clusterLabelCollection.add(),\n    point: entityCluster._clusterPointCollection.add()\n  };\n  cluster.billboard.show = false;\n  cluster.point.show = false;\n  cluster.label.show = true;\n  cluster.label.text = numPoints.toLocaleString();\n  cluster.label.id = ids;\n  cluster.billboard.position = cluster.label.position = cluster.point.position = position;\n  entityCluster._clusterEvent.raiseEvent(ids, cluster);\n}\nfunction hasLabelIndex(entityCluster, entityId) {\n  return defined(entityCluster) && defined(entityCluster._collectionIndicesByEntity[entityId]) && defined(entityCluster._collectionIndicesByEntity[entityId].labelIndex);\n}\nfunction getScreenSpacePositions(collection, points, scene, occluder, entityCluster) {\n  if (!defined(collection)) {\n    return;\n  }\n  const length = collection.length;\n  for (let i = 0; i < length; ++i) {\n    const item = collection.get(i);\n    item.clusterShow = false;\n    if (!item.show || entityCluster._scene.mode === SceneMode.SCENE3D && !occluder.isPointVisible(item.position)) {\n      continue;\n    }\n    const canClusterLabels = entityCluster._clusterLabels && defined(item._labelCollection);\n    const canClusterBillboards = entityCluster._clusterBillboards && defined(item.id._billboard);\n    const canClusterPoints = entityCluster._clusterPoints && defined(item.id._point);\n    if (canClusterLabels && (canClusterPoints || canClusterBillboards)) {\n      continue;\n    }\n    const coord = item.computeScreenSpacePosition(scene);\n    if (!defined(coord)) {\n      continue;\n    }\n    points.push({\n      index: i,\n      collection: collection,\n      clustered: false,\n      coord: coord\n    });\n  }\n}\nconst pointBoundinRectangleScratch = new BoundingRectangle();\nconst totalBoundingRectangleScratch = new BoundingRectangle();\nconst neighborBoundingRectangleScratch = new BoundingRectangle();\nfunction createDeclutterCallback(entityCluster) {\n  return function (amount) {\n    if (defined(amount) && amount < 0.05 || !entityCluster.enabled) {\n      return;\n    }\n    const scene = entityCluster._scene;\n    const labelCollection = entityCluster._labelCollection;\n    const billboardCollection = entityCluster._billboardCollection;\n    const pointCollection = entityCluster._pointCollection;\n    if (!defined(labelCollection) && !defined(billboardCollection) && !defined(pointCollection) || !entityCluster._clusterBillboards && !entityCluster._clusterLabels && !entityCluster._clusterPoints) {\n      return;\n    }\n    let clusteredLabelCollection = entityCluster._clusterLabelCollection;\n    let clusteredBillboardCollection = entityCluster._clusterBillboardCollection;\n    let clusteredPointCollection = entityCluster._clusterPointCollection;\n    if (defined(clusteredLabelCollection)) {\n      clusteredLabelCollection.removeAll();\n    } else {\n      clusteredLabelCollection = entityCluster._clusterLabelCollection = new LabelCollection({\n        scene: scene\n      });\n    }\n    if (defined(clusteredBillboardCollection)) {\n      clusteredBillboardCollection.removeAll();\n    } else {\n      clusteredBillboardCollection = entityCluster._clusterBillboardCollection = new BillboardCollection({\n        scene: scene\n      });\n    }\n    if (defined(clusteredPointCollection)) {\n      clusteredPointCollection.removeAll();\n    } else {\n      clusteredPointCollection = entityCluster._clusterPointCollection = new PointPrimitiveCollection();\n    }\n    const pixelRange = entityCluster._pixelRange;\n    const minimumClusterSize = entityCluster._minimumClusterSize;\n    const clusters = entityCluster._previousClusters;\n    const newClusters = [];\n    const previousHeight = entityCluster._previousHeight;\n    const currentHeight = scene.camera.positionCartographic.height;\n    const ellipsoid = scene.ellipsoid;\n    const cameraPosition = scene.camera.positionWC;\n    const occluder = new EllipsoidalOccluder(ellipsoid, cameraPosition);\n    const points = [];\n    if (entityCluster._clusterLabels) {\n      getScreenSpacePositions(labelCollection, points, scene, occluder, entityCluster);\n    }\n    if (entityCluster._clusterBillboards) {\n      getScreenSpacePositions(billboardCollection, points, scene, occluder, entityCluster);\n    }\n    if (entityCluster._clusterPoints) {\n      getScreenSpacePositions(pointCollection, points, scene, occluder, entityCluster);\n    }\n    let i;\n    let j;\n    let length;\n    let bbox;\n    let neighbors;\n    let neighborLength;\n    let neighborIndex;\n    let neighborPoint;\n    let ids;\n    let numPoints;\n    let collection;\n    let collectionIndex;\n    if (points.length > 0) {\n      const index = new KDBush(points.length, 64, Uint32Array);\n      for (let p = 0; p < points.length; ++p) {\n        index.add(points[p].coord.x, points[p].coord.y);\n      }\n      index.finish();\n      if (currentHeight < previousHeight) {\n        length = clusters.length;\n        for (i = 0; i < length; ++i) {\n          const cluster = clusters[i];\n          if (!occluder.isPointVisible(cluster.position)) {\n            continue;\n          }\n          const coord = Billboard._computeScreenSpacePosition(Matrix4.IDENTITY, cluster.position, Cartesian3.ZERO, Cartesian2.ZERO, scene);\n          if (!defined(coord)) {\n            continue;\n          }\n          const factor = 1.0 - currentHeight / previousHeight;\n          let width = cluster.width = cluster.width * factor;\n          let height = cluster.height = cluster.height * factor;\n          width = Math.max(width, cluster.minimumWidth);\n          height = Math.max(height, cluster.minimumHeight);\n          const minX = coord.x - width * 0.5;\n          const minY = coord.y - height * 0.5;\n          const maxX = coord.x + width;\n          const maxY = coord.y + height;\n          neighbors = index.range(minX, minY, maxX, maxY);\n          neighborLength = neighbors.length;\n          numPoints = 0;\n          ids = [];\n          for (j = 0; j < neighborLength; ++j) {\n            neighborIndex = neighbors[j];\n            neighborPoint = points[neighborIndex];\n            if (!neighborPoint.clustered) {\n              ++numPoints;\n              collection = neighborPoint.collection;\n              collectionIndex = neighborPoint.index;\n              ids.push(collection.get(collectionIndex).id);\n            }\n          }\n          if (numPoints >= minimumClusterSize) {\n            addCluster(cluster.position, numPoints, ids, entityCluster);\n            newClusters.push(cluster);\n            for (j = 0; j < neighborLength; ++j) {\n              points[neighbors[j]].clustered = true;\n            }\n          }\n        }\n      }\n      length = points.length;\n      for (i = 0; i < length; ++i) {\n        const point = points[i];\n        if (point.clustered) {\n          continue;\n        }\n        point.clustered = true;\n        collection = point.collection;\n        collectionIndex = point.index;\n        const item = collection.get(collectionIndex);\n        bbox = getBoundingBox(item, point.coord, pixelRange, entityCluster, pointBoundinRectangleScratch);\n        const totalBBox = BoundingRectangle.clone(bbox, totalBoundingRectangleScratch);\n        neighbors = index.range(bbox.x, bbox.y, bbox.x + bbox.width, bbox.y + bbox.height);\n        neighborLength = neighbors.length;\n        const clusterPosition = Cartesian3.clone(item.position);\n        numPoints = 1;\n        ids = [item.id];\n        for (j = 0; j < neighborLength; ++j) {\n          neighborIndex = neighbors[j];\n          neighborPoint = points[neighborIndex];\n          if (!neighborPoint.clustered) {\n            const neighborItem = neighborPoint.collection.get(neighborPoint.index);\n            const neighborBBox = getBoundingBox(neighborItem, neighborPoint.coord, pixelRange, entityCluster, neighborBoundingRectangleScratch);\n            Cartesian3.add(neighborItem.position, clusterPosition, clusterPosition);\n            BoundingRectangle.union(totalBBox, neighborBBox, totalBBox);\n            ++numPoints;\n            ids.push(neighborItem.id);\n          }\n        }\n        if (numPoints >= minimumClusterSize) {\n          const position = Cartesian3.multiplyByScalar(clusterPosition, 1.0 / numPoints, clusterPosition);\n          addCluster(position, numPoints, ids, entityCluster);\n          newClusters.push({\n            position: position,\n            width: totalBBox.width,\n            height: totalBBox.height,\n            minimumWidth: bbox.width,\n            minimumHeight: bbox.height\n          });\n          for (j = 0; j < neighborLength; ++j) {\n            points[neighbors[j]].clustered = true;\n          }\n        } else {\n          addNonClusteredItem(item, entityCluster);\n        }\n      }\n    }\n    if (clusteredLabelCollection.length === 0) {\n      clusteredLabelCollection.destroy();\n      entityCluster._clusterLabelCollection = undefined;\n    }\n    if (clusteredBillboardCollection.length === 0) {\n      clusteredBillboardCollection.destroy();\n      entityCluster._clusterBillboardCollection = undefined;\n    }\n    if (clusteredPointCollection.length === 0) {\n      clusteredPointCollection.destroy();\n      entityCluster._clusterPointCollection = undefined;\n    }\n    entityCluster._previousClusters = newClusters;\n    entityCluster._previousHeight = currentHeight;\n  };\n}\nEntityCluster.prototype._initialize = function (scene) {\n  this._scene = scene;\n  const cluster = createDeclutterCallback(this);\n  this._cluster = cluster;\n  this._removeEventListener = scene.camera.changed.addEventListener(cluster);\n};\nObject.defineProperties(EntityCluster.prototype, {\n  /**\n   * Gets or sets whether clustering is enabled.\n   * @memberof EntityCluster.prototype\n   * @type {boolean}\n   */\n  enabled: {\n    get: function () {\n      return this._enabled;\n    },\n    set: function (value) {\n      this._enabledDirty = value !== this._enabled;\n      this._enabled = value;\n    }\n  },\n  /**\n   * Gets or sets the pixel range to extend the screen space bounding box.\n   * @memberof EntityCluster.prototype\n   * @type {number}\n   */\n  pixelRange: {\n    get: function () {\n      return this._pixelRange;\n    },\n    set: function (value) {\n      this._clusterDirty = this._clusterDirty || value !== this._pixelRange;\n      this._pixelRange = value;\n    }\n  },\n  /**\n   * Gets or sets the minimum number of screen space objects that can be clustered.\n   * @memberof EntityCluster.prototype\n   * @type {number}\n   */\n  minimumClusterSize: {\n    get: function () {\n      return this._minimumClusterSize;\n    },\n    set: function (value) {\n      this._clusterDirty = this._clusterDirty || value !== this._minimumClusterSize;\n      this._minimumClusterSize = value;\n    }\n  },\n  /**\n   * Gets the event that will be raised when a new cluster will be displayed. The signature of the event listener is {@link EntityCluster.newClusterCallback}.\n   * @memberof EntityCluster.prototype\n   * @type {Event<EntityCluster.newClusterCallback>}\n   */\n  clusterEvent: {\n    get: function () {\n      return this._clusterEvent;\n    }\n  },\n  /**\n   * Gets or sets whether clustering billboard entities is enabled.\n   * @memberof EntityCluster.prototype\n   * @type {boolean}\n   */\n  clusterBillboards: {\n    get: function () {\n      return this._clusterBillboards;\n    },\n    set: function (value) {\n      this._clusterDirty = this._clusterDirty || value !== this._clusterBillboards;\n      this._clusterBillboards = value;\n    }\n  },\n  /**\n   * Gets or sets whether clustering labels entities is enabled.\n   * @memberof EntityCluster.prototype\n   * @type {boolean}\n   */\n  clusterLabels: {\n    get: function () {\n      return this._clusterLabels;\n    },\n    set: function (value) {\n      this._clusterDirty = this._clusterDirty || value !== this._clusterLabels;\n      this._clusterLabels = value;\n    }\n  },\n  /**\n   * Gets or sets whether clustering point entities is enabled.\n   * @memberof EntityCluster.prototype\n   * @type {boolean}\n   */\n  clusterPoints: {\n    get: function () {\n      return this._clusterPoints;\n    },\n    set: function (value) {\n      this._clusterDirty = this._clusterDirty || value !== this._clusterPoints;\n      this._clusterPoints = value;\n    }\n  },\n  /**\n   * Returns true when all clustered data has been rendered.\n   * @memberof EntityCluster.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  ready: {\n    get: function () {\n      return !this._enabledDirty && !this._clusterDirty && (!defined(this._billboardCollection) || this._billboardCollection.ready) && (!defined(this._labelCollection) || this._labelCollection.ready);\n    }\n  }\n});\nfunction createGetEntity(collectionProperty, CollectionConstructor, unusedIndicesProperty, entityIndexProperty) {\n  return function (entity) {\n    let collection = this[collectionProperty];\n    if (!defined(this._collectionIndicesByEntity)) {\n      this._collectionIndicesByEntity = {};\n    }\n    let entityIndices = this._collectionIndicesByEntity[entity.id];\n    if (!defined(entityIndices)) {\n      entityIndices = this._collectionIndicesByEntity[entity.id] = {\n        billboardIndex: undefined,\n        labelIndex: undefined,\n        pointIndex: undefined\n      };\n    }\n    if (defined(collection) && defined(entityIndices[entityIndexProperty])) {\n      return collection.get(entityIndices[entityIndexProperty]);\n    }\n    if (!defined(collection)) {\n      collection = this[collectionProperty] = new CollectionConstructor({\n        scene: this._scene\n      });\n    }\n    let index;\n    let entityItem;\n    const unusedIndices = this[unusedIndicesProperty];\n    if (unusedIndices.length > 0) {\n      index = unusedIndices.shift();\n      entityItem = collection.get(index);\n    } else {\n      entityItem = collection.add();\n      index = collection.length - 1;\n    }\n    entityIndices[entityIndexProperty] = index;\n    const that = this;\n    Promise.resolve().then(function () {\n      that._clusterDirty = true;\n    });\n    return entityItem;\n  };\n}\nfunction removeEntityIndicesIfUnused(entityCluster, entityId) {\n  const indices = entityCluster._collectionIndicesByEntity[entityId];\n  if (!defined(indices.billboardIndex) && !defined(indices.labelIndex) && !defined(indices.pointIndex)) {\n    delete entityCluster._collectionIndicesByEntity[entityId];\n  }\n}\n\n/**\n * Returns a new {@link Label}.\n * @param {Entity} entity The entity that will use the returned {@link Label} for visualization.\n * @returns {Label} The label that will be used to visualize an entity.\n *\n * @private\n */\nEntityCluster.prototype.getLabel = createGetEntity(\"_labelCollection\", LabelCollection, \"_unusedLabelIndices\", \"labelIndex\");\n\n/**\n * Removes the {@link Label} associated with an entity so it can be reused by another entity.\n * @param {Entity} entity The entity that will uses the returned {@link Label} for visualization.\n *\n * @private\n */\nEntityCluster.prototype.removeLabel = function (entity) {\n  const entityIndices = this._collectionIndicesByEntity && this._collectionIndicesByEntity[entity.id];\n  if (!defined(this._labelCollection) || !defined(entityIndices) || !defined(entityIndices.labelIndex)) {\n    return;\n  }\n  const index = entityIndices.labelIndex;\n  entityIndices.labelIndex = undefined;\n  removeEntityIndicesIfUnused(this, entity.id);\n  const label = this._labelCollection.get(index);\n  label.show = false;\n  label.text = \"\";\n  label.id = undefined;\n  this._unusedLabelIndices.push(index);\n  this._clusterDirty = true;\n};\n\n/**\n * Returns a new {@link Billboard}.\n * @param {Entity} entity The entity that will use the returned {@link Billboard} for visualization.\n * @returns {Billboard} The label that will be used to visualize an entity.\n *\n * @private\n */\nEntityCluster.prototype.getBillboard = createGetEntity(\"_billboardCollection\", BillboardCollection, \"_unusedBillboardIndices\", \"billboardIndex\");\n\n/**\n * Removes the {@link Billboard} associated with an entity so it can be reused by another entity.\n * @param {Entity} entity The entity that will uses the returned {@link Billboard} for visualization.\n *\n * @private\n */\nEntityCluster.prototype.removeBillboard = function (entity) {\n  const entityIndices = this._collectionIndicesByEntity && this._collectionIndicesByEntity[entity.id];\n  if (!defined(this._billboardCollection) || !defined(entityIndices) || !defined(entityIndices.billboardIndex)) {\n    return;\n  }\n  const index = entityIndices.billboardIndex;\n  entityIndices.billboardIndex = undefined;\n  removeEntityIndicesIfUnused(this, entity.id);\n  const billboard = this._billboardCollection.get(index);\n  billboard.id = undefined;\n  billboard.show = false;\n  billboard.image = undefined;\n  this._unusedBillboardIndices.push(index);\n  this._clusterDirty = true;\n};\n\n/**\n * Returns a new {@link Point}.\n * @param {Entity} entity The entity that will use the returned {@link Point} for visualization.\n * @returns {Point} The label that will be used to visualize an entity.\n *\n * @private\n */\nEntityCluster.prototype.getPoint = createGetEntity(\"_pointCollection\", PointPrimitiveCollection, \"_unusedPointIndices\", \"pointIndex\");\n\n/**\n * Removes the {@link Point} associated with an entity so it can be reused by another entity.\n * @param {Entity} entity The entity that will uses the returned {@link Point} for visualization.\n *\n * @private\n */\nEntityCluster.prototype.removePoint = function (entity) {\n  const entityIndices = this._collectionIndicesByEntity && this._collectionIndicesByEntity[entity.id];\n  if (!defined(this._pointCollection) || !defined(entityIndices) || !defined(entityIndices.pointIndex)) {\n    return;\n  }\n  const index = entityIndices.pointIndex;\n  entityIndices.pointIndex = undefined;\n  removeEntityIndicesIfUnused(this, entity.id);\n  const point = this._pointCollection.get(index);\n  point.show = false;\n  point.id = undefined;\n  this._unusedPointIndices.push(index);\n  this._clusterDirty = true;\n};\nfunction disableCollectionClustering(collection) {\n  if (!defined(collection)) {\n    return;\n  }\n  const length = collection.length;\n  for (let i = 0; i < length; ++i) {\n    collection.get(i).clusterShow = true;\n  }\n}\nfunction updateEnable(entityCluster) {\n  if (entityCluster.enabled) {\n    return;\n  }\n  if (defined(entityCluster._clusterLabelCollection)) {\n    entityCluster._clusterLabelCollection.destroy();\n  }\n  if (defined(entityCluster._clusterBillboardCollection)) {\n    entityCluster._clusterBillboardCollection.destroy();\n  }\n  if (defined(entityCluster._clusterPointCollection)) {\n    entityCluster._clusterPointCollection.destroy();\n  }\n  entityCluster._clusterLabelCollection = undefined;\n  entityCluster._clusterBillboardCollection = undefined;\n  entityCluster._clusterPointCollection = undefined;\n  disableCollectionClustering(entityCluster._labelCollection);\n  disableCollectionClustering(entityCluster._billboardCollection);\n  disableCollectionClustering(entityCluster._pointCollection);\n}\n\n/**\n * Gets the draw commands for the clustered billboards/points/labels if enabled, otherwise,\n * queues the draw commands for billboards/points/labels created for entities.\n * @private\n */\nEntityCluster.prototype.update = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  // If clustering is enabled before the label collection is updated,\n  // the glyphs haven't been created so the screen space bounding boxes\n  // are incorrect.\n  let commandList;\n  const labelCollection = this._labelCollection;\n  if (defined(labelCollection) && labelCollection.length > 0 && !labelCollection.ready) {\n    commandList = frameState.commandList;\n    frameState.commandList = [];\n    labelCollection.update(frameState);\n    frameState.commandList = commandList;\n  }\n\n  // If clustering is enabled before the billboard collections are updated,\n  // the images haven't been added to the image atlas so the screen space bounding boxes\n  // are incorrect.\n  const billboardCollection = this._billboardCollection;\n  if (defined(billboardCollection) && billboardCollection.length > 0 && !billboardCollection.ready) {\n    commandList = frameState.commandList;\n    frameState.commandList = [];\n    billboardCollection.update(frameState);\n    frameState.commandList = commandList;\n  }\n  if (this._enabledDirty) {\n    this._enabledDirty = false;\n    updateEnable(this);\n    this._clusterDirty = true;\n  }\n  if (this._clusterDirty) {\n    this._cluster();\n\n    // Unless all existing billboards and labels were clustered, clustering will need to execute again next frame\n    this._clusterDirty = defined(labelCollection) && !labelCollection.ready || defined(billboardCollection) && !billboardCollection.ready;\n  }\n  if (defined(this._clusterLabelCollection)) {\n    this._clusterLabelCollection.update(frameState);\n  }\n  if (defined(this._clusterBillboardCollection)) {\n    this._clusterBillboardCollection.update(frameState);\n  }\n  if (defined(this._clusterPointCollection)) {\n    this._clusterPointCollection.update(frameState);\n  }\n  if (defined(labelCollection)) {\n    labelCollection.update(frameState);\n  }\n  if (defined(billboardCollection)) {\n    billboardCollection.update(frameState);\n  }\n  if (defined(this._pointCollection)) {\n    this._pointCollection.update(frameState);\n  }\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Unlike other objects that use WebGL resources, this object can be reused. For example, if a data source is removed\n * from a data source collection and added to another.\n * </p>\n */\nEntityCluster.prototype.destroy = function () {\n  if (defined(this._removeEventListener)) {\n    this._removeEventListener();\n    this._removeEventListener = undefined;\n  }\n  this._labelCollection = this._labelCollection && this._labelCollection.destroy();\n  this._billboardCollection = this._billboardCollection && this._billboardCollection.destroy();\n  this._pointCollection = this._pointCollection && this._pointCollection.destroy();\n  this._clusterLabelCollection = this._clusterLabelCollection && this._clusterLabelCollection.destroy();\n  this._clusterBillboardCollection = this._clusterBillboardCollection && this._clusterBillboardCollection.destroy();\n  this._clusterPointCollection = this._clusterPointCollection && this._clusterPointCollection.destroy();\n  this._labelCollection = undefined;\n  this._billboardCollection = undefined;\n  this._pointCollection = undefined;\n  this._clusterBillboardCollection = undefined;\n  this._clusterLabelCollection = undefined;\n  this._clusterPointCollection = undefined;\n  this._collectionIndicesByEntity = undefined;\n  this._unusedLabelIndices = [];\n  this._unusedBillboardIndices = [];\n  this._unusedPointIndices = [];\n  this._previousClusters = [];\n  this._previousHeight = undefined;\n  this._enabledDirty = false;\n  this._pixelRangeDirty = false;\n  this._minimumClusterSizeDirty = false;\n  return undefined;\n};\n\n/**\n * A event listener function used to style clusters.\n * @callback EntityCluster.newClusterCallback\n *\n * @param {Entity[]} clusteredEntities An array of the entities contained in the cluster.\n * @param {object} cluster An object containing the Billboard, Label, and Point\n * primitives that represent this cluster of entities.\n * @param {Billboard} cluster.billboard\n * @param {Label} cluster.label\n * @param {PointPrimitive} cluster.point\n *\n * @example\n * // The default cluster values.\n * dataSource.clustering.clusterEvent.addEventListener(function(entities, cluster) {\n *     cluster.label.show = true;\n *     cluster.label.text = entities.length.toLocaleString();\n * });\n */\nexport default EntityCluster;","map":{"version":3,"names":["BoundingRectangle","Cartesian2","Cartesian3","Frozen","defined","EllipsoidalOccluder","Event","Matrix4","Billboard","BillboardCollection","Label","LabelCollection","PointPrimitive","PointPrimitiveCollection","SceneMode","KDBush","EntityCluster","options","EMPTY_OBJECT","_enabled","enabled","_pixelRange","pixelRange","_minimumClusterSize","minimumClusterSize","_clusterBillboards","clusterBillboards","_clusterLabels","clusterLabels","_clusterPoints","clusterPoints","_labelCollection","undefined","_billboardCollection","_pointCollection","_clusterBillboardCollection","_clusterLabelCollection","_clusterPointCollection","_collectionIndicesByEntity","_unusedLabelIndices","_unusedBillboardIndices","_unusedPointIndices","_previousClusters","_previousHeight","_enabledDirty","_clusterDirty","_cluster","_removeEventListener","_clusterEvent","show","expandBoundingBox","bbox","x","y","width","height","labelBoundingBoxScratch","getBoundingBox","item","coord","entityCluster","result","getScreenSpaceBoundingBox","_pointPrimitiveCollection","id","hasLabelIndex","_label","labelIndex","label","get","labelBBox","union","addNonClusteredItem","clusterShow","addCluster","position","numPoints","ids","cluster","billboard","add","point","text","toLocaleString","raiseEvent","entityId","getScreenSpacePositions","collection","points","scene","occluder","length","i","_scene","mode","SCENE3D","isPointVisible","canClusterLabels","canClusterBillboards","_billboard","canClusterPoints","_point","computeScreenSpacePosition","push","index","clustered","pointBoundinRectangleScratch","totalBoundingRectangleScratch","neighborBoundingRectangleScratch","createDeclutterCallback","amount","labelCollection","billboardCollection","pointCollection","clusteredLabelCollection","clusteredBillboardCollection","clusteredPointCollection","removeAll","clusters","newClusters","previousHeight","currentHeight","camera","positionCartographic","ellipsoid","cameraPosition","positionWC","j","neighbors","neighborLength","neighborIndex","neighborPoint","collectionIndex","Uint32Array","p","finish","_computeScreenSpacePosition","IDENTITY","ZERO","factor","Math","max","minimumWidth","minimumHeight","minX","minY","maxX","maxY","range","totalBBox","clone","clusterPosition","neighborItem","neighborBBox","multiplyByScalar","destroy","prototype","_initialize","changed","addEventListener","Object","defineProperties","set","value","clusterEvent","ready","createGetEntity","collectionProperty","CollectionConstructor","unusedIndicesProperty","entityIndexProperty","entity","entityIndices","billboardIndex","pointIndex","entityItem","unusedIndices","shift","that","Promise","resolve","then","removeEntityIndicesIfUnused","indices","getLabel","removeLabel","getBillboard","removeBillboard","image","getPoint","removePoint","disableCollectionClustering","updateEnable","update","frameState","commandList","_pixelRangeDirty","_minimumClusterSizeDirty"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/DataSources/EntityCluster.js"],"sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport EllipsoidalOccluder from \"../Core/EllipsoidalOccluder.js\";\nimport Event from \"../Core/Event.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Billboard from \"../Scene/Billboard.js\";\nimport BillboardCollection from \"../Scene/BillboardCollection.js\";\nimport Label from \"../Scene/Label.js\";\nimport LabelCollection from \"../Scene/LabelCollection.js\";\nimport PointPrimitive from \"../Scene/PointPrimitive.js\";\nimport PointPrimitiveCollection from \"../Scene/PointPrimitiveCollection.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport KDBush from \"kdbush\";\n\n/**\n * Defines how screen space objects (billboards, points, labels) are clustered.\n *\n * @param {object} [options] An object with the following properties:\n * @param {boolean} [options.enabled=false] Whether or not to enable clustering.\n * @param {number} [options.pixelRange=80] The pixel range to extend the screen space bounding box.\n * @param {number} [options.minimumClusterSize=2] The minimum number of screen space objects that can be clustered.\n * @param {boolean} [options.clusterBillboards=true] Whether or not to cluster the billboards of an entity.\n * @param {boolean} [options.clusterLabels=true] Whether or not to cluster the labels of an entity.\n * @param {boolean} [options.clusterPoints=true] Whether or not to cluster the points of an entity.\n * @param {boolean} [options.show=true] Determines if the entities in the cluster will be shown.\n *\n * @alias EntityCluster\n * @constructor\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Clustering.html|Cesium Sandcastle Clustering Demo}\n */\nfunction EntityCluster(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  this._enabled = options.enabled ?? false;\n  this._pixelRange = options.pixelRange ?? 80;\n  this._minimumClusterSize = options.minimumClusterSize ?? 2;\n  this._clusterBillboards = options.clusterBillboards ?? true;\n  this._clusterLabels = options.clusterLabels ?? true;\n  this._clusterPoints = options.clusterPoints ?? true;\n\n  this._labelCollection = undefined;\n  this._billboardCollection = undefined;\n  this._pointCollection = undefined;\n\n  this._clusterBillboardCollection = undefined;\n  this._clusterLabelCollection = undefined;\n  this._clusterPointCollection = undefined;\n\n  this._collectionIndicesByEntity = {};\n\n  this._unusedLabelIndices = [];\n  this._unusedBillboardIndices = [];\n  this._unusedPointIndices = [];\n\n  this._previousClusters = [];\n  this._previousHeight = undefined;\n\n  this._enabledDirty = false;\n  this._clusterDirty = false;\n\n  this._cluster = undefined;\n  this._removeEventListener = undefined;\n\n  this._clusterEvent = new Event();\n\n  /**\n   * Determines if entities in this collection will be shown.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.show = options.show ?? true;\n}\n\nfunction expandBoundingBox(bbox, pixelRange) {\n  bbox.x -= pixelRange;\n  bbox.y -= pixelRange;\n  bbox.width += pixelRange * 2.0;\n  bbox.height += pixelRange * 2.0;\n}\n\nconst labelBoundingBoxScratch = new BoundingRectangle();\n\nfunction getBoundingBox(item, coord, pixelRange, entityCluster, result) {\n  if (defined(item._labelCollection) && entityCluster._clusterLabels) {\n    result = Label.getScreenSpaceBoundingBox(item, coord, result);\n  } else if (\n    defined(item._billboardCollection) &&\n    entityCluster._clusterBillboards\n  ) {\n    result = Billboard.getScreenSpaceBoundingBox(item, coord, result);\n  } else if (\n    defined(item._pointPrimitiveCollection) &&\n    entityCluster._clusterPoints\n  ) {\n    result = PointPrimitive.getScreenSpaceBoundingBox(item, coord, result);\n  }\n\n  expandBoundingBox(result, pixelRange);\n\n  if (\n    entityCluster._clusterLabels &&\n    !defined(item._labelCollection) &&\n    defined(item.id) &&\n    hasLabelIndex(entityCluster, item.id.id) &&\n    defined(item.id._label)\n  ) {\n    const labelIndex =\n      entityCluster._collectionIndicesByEntity[item.id.id].labelIndex;\n    const label = entityCluster._labelCollection.get(labelIndex);\n    const labelBBox = Label.getScreenSpaceBoundingBox(\n      label,\n      coord,\n      labelBoundingBoxScratch,\n    );\n    expandBoundingBox(labelBBox, pixelRange);\n    result = BoundingRectangle.union(result, labelBBox, result);\n  }\n\n  return result;\n}\n\nfunction addNonClusteredItem(item, entityCluster) {\n  item.clusterShow = true;\n\n  if (\n    !defined(item._labelCollection) &&\n    defined(item.id) &&\n    hasLabelIndex(entityCluster, item.id.id) &&\n    defined(item.id._label)\n  ) {\n    const labelIndex =\n      entityCluster._collectionIndicesByEntity[item.id.id].labelIndex;\n    const label = entityCluster._labelCollection.get(labelIndex);\n    label.clusterShow = true;\n  }\n}\n\nfunction addCluster(position, numPoints, ids, entityCluster) {\n  const cluster = {\n    billboard: entityCluster._clusterBillboardCollection.add(),\n    label: entityCluster._clusterLabelCollection.add(),\n    point: entityCluster._clusterPointCollection.add(),\n  };\n\n  cluster.billboard.show = false;\n  cluster.point.show = false;\n  cluster.label.show = true;\n  cluster.label.text = numPoints.toLocaleString();\n  cluster.label.id = ids;\n  cluster.billboard.position =\n    cluster.label.position =\n    cluster.point.position =\n      position;\n\n  entityCluster._clusterEvent.raiseEvent(ids, cluster);\n}\n\nfunction hasLabelIndex(entityCluster, entityId) {\n  return (\n    defined(entityCluster) &&\n    defined(entityCluster._collectionIndicesByEntity[entityId]) &&\n    defined(entityCluster._collectionIndicesByEntity[entityId].labelIndex)\n  );\n}\n\nfunction getScreenSpacePositions(\n  collection,\n  points,\n  scene,\n  occluder,\n  entityCluster,\n) {\n  if (!defined(collection)) {\n    return;\n  }\n\n  const length = collection.length;\n  for (let i = 0; i < length; ++i) {\n    const item = collection.get(i);\n    item.clusterShow = false;\n\n    if (\n      !item.show ||\n      (entityCluster._scene.mode === SceneMode.SCENE3D &&\n        !occluder.isPointVisible(item.position))\n    ) {\n      continue;\n    }\n\n    const canClusterLabels =\n      entityCluster._clusterLabels && defined(item._labelCollection);\n    const canClusterBillboards =\n      entityCluster._clusterBillboards && defined(item.id._billboard);\n    const canClusterPoints =\n      entityCluster._clusterPoints && defined(item.id._point);\n    if (canClusterLabels && (canClusterPoints || canClusterBillboards)) {\n      continue;\n    }\n\n    const coord = item.computeScreenSpacePosition(scene);\n    if (!defined(coord)) {\n      continue;\n    }\n\n    points.push({\n      index: i,\n      collection: collection,\n      clustered: false,\n      coord: coord,\n    });\n  }\n}\n\nconst pointBoundinRectangleScratch = new BoundingRectangle();\nconst totalBoundingRectangleScratch = new BoundingRectangle();\nconst neighborBoundingRectangleScratch = new BoundingRectangle();\n\nfunction createDeclutterCallback(entityCluster) {\n  return function (amount) {\n    if ((defined(amount) && amount < 0.05) || !entityCluster.enabled) {\n      return;\n    }\n\n    const scene = entityCluster._scene;\n\n    const labelCollection = entityCluster._labelCollection;\n    const billboardCollection = entityCluster._billboardCollection;\n    const pointCollection = entityCluster._pointCollection;\n\n    if (\n      (!defined(labelCollection) &&\n        !defined(billboardCollection) &&\n        !defined(pointCollection)) ||\n      (!entityCluster._clusterBillboards &&\n        !entityCluster._clusterLabels &&\n        !entityCluster._clusterPoints)\n    ) {\n      return;\n    }\n\n    let clusteredLabelCollection = entityCluster._clusterLabelCollection;\n    let clusteredBillboardCollection =\n      entityCluster._clusterBillboardCollection;\n    let clusteredPointCollection = entityCluster._clusterPointCollection;\n\n    if (defined(clusteredLabelCollection)) {\n      clusteredLabelCollection.removeAll();\n    } else {\n      clusteredLabelCollection = entityCluster._clusterLabelCollection =\n        new LabelCollection({\n          scene: scene,\n        });\n    }\n\n    if (defined(clusteredBillboardCollection)) {\n      clusteredBillboardCollection.removeAll();\n    } else {\n      clusteredBillboardCollection = entityCluster._clusterBillboardCollection =\n        new BillboardCollection({\n          scene: scene,\n        });\n    }\n\n    if (defined(clusteredPointCollection)) {\n      clusteredPointCollection.removeAll();\n    } else {\n      clusteredPointCollection = entityCluster._clusterPointCollection =\n        new PointPrimitiveCollection();\n    }\n\n    const pixelRange = entityCluster._pixelRange;\n    const minimumClusterSize = entityCluster._minimumClusterSize;\n\n    const clusters = entityCluster._previousClusters;\n    const newClusters = [];\n\n    const previousHeight = entityCluster._previousHeight;\n    const currentHeight = scene.camera.positionCartographic.height;\n\n    const ellipsoid = scene.ellipsoid;\n    const cameraPosition = scene.camera.positionWC;\n    const occluder = new EllipsoidalOccluder(ellipsoid, cameraPosition);\n\n    const points = [];\n    if (entityCluster._clusterLabels) {\n      getScreenSpacePositions(\n        labelCollection,\n        points,\n        scene,\n        occluder,\n        entityCluster,\n      );\n    }\n    if (entityCluster._clusterBillboards) {\n      getScreenSpacePositions(\n        billboardCollection,\n        points,\n        scene,\n        occluder,\n        entityCluster,\n      );\n    }\n    if (entityCluster._clusterPoints) {\n      getScreenSpacePositions(\n        pointCollection,\n        points,\n        scene,\n        occluder,\n        entityCluster,\n      );\n    }\n\n    let i;\n    let j;\n    let length;\n    let bbox;\n    let neighbors;\n    let neighborLength;\n    let neighborIndex;\n    let neighborPoint;\n    let ids;\n    let numPoints;\n\n    let collection;\n    let collectionIndex;\n\n    if (points.length > 0) {\n      const index = new KDBush(points.length, 64, Uint32Array);\n      for (let p = 0; p < points.length; ++p) {\n        index.add(points[p].coord.x, points[p].coord.y);\n      }\n      index.finish();\n\n      if (currentHeight < previousHeight) {\n        length = clusters.length;\n        for (i = 0; i < length; ++i) {\n          const cluster = clusters[i];\n\n          if (!occluder.isPointVisible(cluster.position)) {\n            continue;\n          }\n\n          const coord = Billboard._computeScreenSpacePosition(\n            Matrix4.IDENTITY,\n            cluster.position,\n            Cartesian3.ZERO,\n            Cartesian2.ZERO,\n            scene,\n          );\n          if (!defined(coord)) {\n            continue;\n          }\n\n          const factor = 1.0 - currentHeight / previousHeight;\n          let width = (cluster.width = cluster.width * factor);\n          let height = (cluster.height = cluster.height * factor);\n\n          width = Math.max(width, cluster.minimumWidth);\n          height = Math.max(height, cluster.minimumHeight);\n\n          const minX = coord.x - width * 0.5;\n          const minY = coord.y - height * 0.5;\n          const maxX = coord.x + width;\n          const maxY = coord.y + height;\n\n          neighbors = index.range(minX, minY, maxX, maxY);\n          neighborLength = neighbors.length;\n          numPoints = 0;\n          ids = [];\n\n          for (j = 0; j < neighborLength; ++j) {\n            neighborIndex = neighbors[j];\n            neighborPoint = points[neighborIndex];\n            if (!neighborPoint.clustered) {\n              ++numPoints;\n\n              collection = neighborPoint.collection;\n              collectionIndex = neighborPoint.index;\n              ids.push(collection.get(collectionIndex).id);\n            }\n          }\n\n          if (numPoints >= minimumClusterSize) {\n            addCluster(cluster.position, numPoints, ids, entityCluster);\n            newClusters.push(cluster);\n\n            for (j = 0; j < neighborLength; ++j) {\n              points[neighbors[j]].clustered = true;\n            }\n          }\n        }\n      }\n\n      length = points.length;\n      for (i = 0; i < length; ++i) {\n        const point = points[i];\n        if (point.clustered) {\n          continue;\n        }\n\n        point.clustered = true;\n\n        collection = point.collection;\n        collectionIndex = point.index;\n\n        const item = collection.get(collectionIndex);\n        bbox = getBoundingBox(\n          item,\n          point.coord,\n          pixelRange,\n          entityCluster,\n          pointBoundinRectangleScratch,\n        );\n        const totalBBox = BoundingRectangle.clone(\n          bbox,\n          totalBoundingRectangleScratch,\n        );\n\n        neighbors = index.range(\n          bbox.x,\n          bbox.y,\n          bbox.x + bbox.width,\n          bbox.y + bbox.height,\n        );\n        neighborLength = neighbors.length;\n\n        const clusterPosition = Cartesian3.clone(item.position);\n        numPoints = 1;\n        ids = [item.id];\n\n        for (j = 0; j < neighborLength; ++j) {\n          neighborIndex = neighbors[j];\n          neighborPoint = points[neighborIndex];\n          if (!neighborPoint.clustered) {\n            const neighborItem = neighborPoint.collection.get(\n              neighborPoint.index,\n            );\n            const neighborBBox = getBoundingBox(\n              neighborItem,\n              neighborPoint.coord,\n              pixelRange,\n              entityCluster,\n              neighborBoundingRectangleScratch,\n            );\n\n            Cartesian3.add(\n              neighborItem.position,\n              clusterPosition,\n              clusterPosition,\n            );\n\n            BoundingRectangle.union(totalBBox, neighborBBox, totalBBox);\n            ++numPoints;\n\n            ids.push(neighborItem.id);\n          }\n        }\n\n        if (numPoints >= minimumClusterSize) {\n          const position = Cartesian3.multiplyByScalar(\n            clusterPosition,\n            1.0 / numPoints,\n            clusterPosition,\n          );\n          addCluster(position, numPoints, ids, entityCluster);\n          newClusters.push({\n            position: position,\n            width: totalBBox.width,\n            height: totalBBox.height,\n            minimumWidth: bbox.width,\n            minimumHeight: bbox.height,\n          });\n\n          for (j = 0; j < neighborLength; ++j) {\n            points[neighbors[j]].clustered = true;\n          }\n        } else {\n          addNonClusteredItem(item, entityCluster);\n        }\n      }\n    }\n\n    if (clusteredLabelCollection.length === 0) {\n      clusteredLabelCollection.destroy();\n      entityCluster._clusterLabelCollection = undefined;\n    }\n\n    if (clusteredBillboardCollection.length === 0) {\n      clusteredBillboardCollection.destroy();\n      entityCluster._clusterBillboardCollection = undefined;\n    }\n\n    if (clusteredPointCollection.length === 0) {\n      clusteredPointCollection.destroy();\n      entityCluster._clusterPointCollection = undefined;\n    }\n\n    entityCluster._previousClusters = newClusters;\n    entityCluster._previousHeight = currentHeight;\n  };\n}\n\nEntityCluster.prototype._initialize = function (scene) {\n  this._scene = scene;\n\n  const cluster = createDeclutterCallback(this);\n  this._cluster = cluster;\n  this._removeEventListener = scene.camera.changed.addEventListener(cluster);\n};\n\nObject.defineProperties(EntityCluster.prototype, {\n  /**\n   * Gets or sets whether clustering is enabled.\n   * @memberof EntityCluster.prototype\n   * @type {boolean}\n   */\n  enabled: {\n    get: function () {\n      return this._enabled;\n    },\n    set: function (value) {\n      this._enabledDirty = value !== this._enabled;\n      this._enabled = value;\n    },\n  },\n  /**\n   * Gets or sets the pixel range to extend the screen space bounding box.\n   * @memberof EntityCluster.prototype\n   * @type {number}\n   */\n  pixelRange: {\n    get: function () {\n      return this._pixelRange;\n    },\n    set: function (value) {\n      this._clusterDirty = this._clusterDirty || value !== this._pixelRange;\n      this._pixelRange = value;\n    },\n  },\n  /**\n   * Gets or sets the minimum number of screen space objects that can be clustered.\n   * @memberof EntityCluster.prototype\n   * @type {number}\n   */\n  minimumClusterSize: {\n    get: function () {\n      return this._minimumClusterSize;\n    },\n    set: function (value) {\n      this._clusterDirty =\n        this._clusterDirty || value !== this._minimumClusterSize;\n      this._minimumClusterSize = value;\n    },\n  },\n  /**\n   * Gets the event that will be raised when a new cluster will be displayed. The signature of the event listener is {@link EntityCluster.newClusterCallback}.\n   * @memberof EntityCluster.prototype\n   * @type {Event<EntityCluster.newClusterCallback>}\n   */\n  clusterEvent: {\n    get: function () {\n      return this._clusterEvent;\n    },\n  },\n  /**\n   * Gets or sets whether clustering billboard entities is enabled.\n   * @memberof EntityCluster.prototype\n   * @type {boolean}\n   */\n  clusterBillboards: {\n    get: function () {\n      return this._clusterBillboards;\n    },\n    set: function (value) {\n      this._clusterDirty =\n        this._clusterDirty || value !== this._clusterBillboards;\n      this._clusterBillboards = value;\n    },\n  },\n  /**\n   * Gets or sets whether clustering labels entities is enabled.\n   * @memberof EntityCluster.prototype\n   * @type {boolean}\n   */\n  clusterLabels: {\n    get: function () {\n      return this._clusterLabels;\n    },\n    set: function (value) {\n      this._clusterDirty = this._clusterDirty || value !== this._clusterLabels;\n      this._clusterLabels = value;\n    },\n  },\n  /**\n   * Gets or sets whether clustering point entities is enabled.\n   * @memberof EntityCluster.prototype\n   * @type {boolean}\n   */\n  clusterPoints: {\n    get: function () {\n      return this._clusterPoints;\n    },\n    set: function (value) {\n      this._clusterDirty = this._clusterDirty || value !== this._clusterPoints;\n      this._clusterPoints = value;\n    },\n  },\n\n  /**\n   * Returns true when all clustered data has been rendered.\n   * @memberof EntityCluster.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  ready: {\n    get: function () {\n      return (\n        !this._enabledDirty &&\n        !this._clusterDirty &&\n        (!defined(this._billboardCollection) ||\n          this._billboardCollection.ready) &&\n        (!defined(this._labelCollection) || this._labelCollection.ready)\n      );\n    },\n  },\n});\n\nfunction createGetEntity(\n  collectionProperty,\n  CollectionConstructor,\n  unusedIndicesProperty,\n  entityIndexProperty,\n) {\n  return function (entity) {\n    let collection = this[collectionProperty];\n\n    if (!defined(this._collectionIndicesByEntity)) {\n      this._collectionIndicesByEntity = {};\n    }\n\n    let entityIndices = this._collectionIndicesByEntity[entity.id];\n\n    if (!defined(entityIndices)) {\n      entityIndices = this._collectionIndicesByEntity[entity.id] = {\n        billboardIndex: undefined,\n        labelIndex: undefined,\n        pointIndex: undefined,\n      };\n    }\n\n    if (defined(collection) && defined(entityIndices[entityIndexProperty])) {\n      return collection.get(entityIndices[entityIndexProperty]);\n    }\n\n    if (!defined(collection)) {\n      collection = this[collectionProperty] = new CollectionConstructor({\n        scene: this._scene,\n      });\n    }\n\n    let index;\n    let entityItem;\n\n    const unusedIndices = this[unusedIndicesProperty];\n    if (unusedIndices.length > 0) {\n      index = unusedIndices.shift();\n      entityItem = collection.get(index);\n    } else {\n      entityItem = collection.add();\n      index = collection.length - 1;\n    }\n\n    entityIndices[entityIndexProperty] = index;\n\n    const that = this;\n    Promise.resolve().then(function () {\n      that._clusterDirty = true;\n    });\n\n    return entityItem;\n  };\n}\n\nfunction removeEntityIndicesIfUnused(entityCluster, entityId) {\n  const indices = entityCluster._collectionIndicesByEntity[entityId];\n\n  if (\n    !defined(indices.billboardIndex) &&\n    !defined(indices.labelIndex) &&\n    !defined(indices.pointIndex)\n  ) {\n    delete entityCluster._collectionIndicesByEntity[entityId];\n  }\n}\n\n/**\n * Returns a new {@link Label}.\n * @param {Entity} entity The entity that will use the returned {@link Label} for visualization.\n * @returns {Label} The label that will be used to visualize an entity.\n *\n * @private\n */\nEntityCluster.prototype.getLabel = createGetEntity(\n  \"_labelCollection\",\n  LabelCollection,\n  \"_unusedLabelIndices\",\n  \"labelIndex\",\n);\n\n/**\n * Removes the {@link Label} associated with an entity so it can be reused by another entity.\n * @param {Entity} entity The entity that will uses the returned {@link Label} for visualization.\n *\n * @private\n */\nEntityCluster.prototype.removeLabel = function (entity) {\n  const entityIndices =\n    this._collectionIndicesByEntity &&\n    this._collectionIndicesByEntity[entity.id];\n  if (\n    !defined(this._labelCollection) ||\n    !defined(entityIndices) ||\n    !defined(entityIndices.labelIndex)\n  ) {\n    return;\n  }\n\n  const index = entityIndices.labelIndex;\n  entityIndices.labelIndex = undefined;\n  removeEntityIndicesIfUnused(this, entity.id);\n\n  const label = this._labelCollection.get(index);\n  label.show = false;\n  label.text = \"\";\n  label.id = undefined;\n\n  this._unusedLabelIndices.push(index);\n\n  this._clusterDirty = true;\n};\n\n/**\n * Returns a new {@link Billboard}.\n * @param {Entity} entity The entity that will use the returned {@link Billboard} for visualization.\n * @returns {Billboard} The label that will be used to visualize an entity.\n *\n * @private\n */\nEntityCluster.prototype.getBillboard = createGetEntity(\n  \"_billboardCollection\",\n  BillboardCollection,\n  \"_unusedBillboardIndices\",\n  \"billboardIndex\",\n);\n\n/**\n * Removes the {@link Billboard} associated with an entity so it can be reused by another entity.\n * @param {Entity} entity The entity that will uses the returned {@link Billboard} for visualization.\n *\n * @private\n */\nEntityCluster.prototype.removeBillboard = function (entity) {\n  const entityIndices =\n    this._collectionIndicesByEntity &&\n    this._collectionIndicesByEntity[entity.id];\n  if (\n    !defined(this._billboardCollection) ||\n    !defined(entityIndices) ||\n    !defined(entityIndices.billboardIndex)\n  ) {\n    return;\n  }\n\n  const index = entityIndices.billboardIndex;\n  entityIndices.billboardIndex = undefined;\n  removeEntityIndicesIfUnused(this, entity.id);\n\n  const billboard = this._billboardCollection.get(index);\n  billboard.id = undefined;\n  billboard.show = false;\n  billboard.image = undefined;\n\n  this._unusedBillboardIndices.push(index);\n\n  this._clusterDirty = true;\n};\n\n/**\n * Returns a new {@link Point}.\n * @param {Entity} entity The entity that will use the returned {@link Point} for visualization.\n * @returns {Point} The label that will be used to visualize an entity.\n *\n * @private\n */\nEntityCluster.prototype.getPoint = createGetEntity(\n  \"_pointCollection\",\n  PointPrimitiveCollection,\n  \"_unusedPointIndices\",\n  \"pointIndex\",\n);\n\n/**\n * Removes the {@link Point} associated with an entity so it can be reused by another entity.\n * @param {Entity} entity The entity that will uses the returned {@link Point} for visualization.\n *\n * @private\n */\nEntityCluster.prototype.removePoint = function (entity) {\n  const entityIndices =\n    this._collectionIndicesByEntity &&\n    this._collectionIndicesByEntity[entity.id];\n  if (\n    !defined(this._pointCollection) ||\n    !defined(entityIndices) ||\n    !defined(entityIndices.pointIndex)\n  ) {\n    return;\n  }\n\n  const index = entityIndices.pointIndex;\n  entityIndices.pointIndex = undefined;\n  removeEntityIndicesIfUnused(this, entity.id);\n\n  const point = this._pointCollection.get(index);\n  point.show = false;\n  point.id = undefined;\n\n  this._unusedPointIndices.push(index);\n\n  this._clusterDirty = true;\n};\n\nfunction disableCollectionClustering(collection) {\n  if (!defined(collection)) {\n    return;\n  }\n\n  const length = collection.length;\n  for (let i = 0; i < length; ++i) {\n    collection.get(i).clusterShow = true;\n  }\n}\n\nfunction updateEnable(entityCluster) {\n  if (entityCluster.enabled) {\n    return;\n  }\n\n  if (defined(entityCluster._clusterLabelCollection)) {\n    entityCluster._clusterLabelCollection.destroy();\n  }\n  if (defined(entityCluster._clusterBillboardCollection)) {\n    entityCluster._clusterBillboardCollection.destroy();\n  }\n  if (defined(entityCluster._clusterPointCollection)) {\n    entityCluster._clusterPointCollection.destroy();\n  }\n\n  entityCluster._clusterLabelCollection = undefined;\n  entityCluster._clusterBillboardCollection = undefined;\n  entityCluster._clusterPointCollection = undefined;\n\n  disableCollectionClustering(entityCluster._labelCollection);\n  disableCollectionClustering(entityCluster._billboardCollection);\n  disableCollectionClustering(entityCluster._pointCollection);\n}\n\n/**\n * Gets the draw commands for the clustered billboards/points/labels if enabled, otherwise,\n * queues the draw commands for billboards/points/labels created for entities.\n * @private\n */\nEntityCluster.prototype.update = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  // If clustering is enabled before the label collection is updated,\n  // the glyphs haven't been created so the screen space bounding boxes\n  // are incorrect.\n  let commandList;\n  const labelCollection = this._labelCollection;\n  if (\n    defined(labelCollection) &&\n    labelCollection.length > 0 &&\n    !labelCollection.ready\n  ) {\n    commandList = frameState.commandList;\n    frameState.commandList = [];\n    labelCollection.update(frameState);\n    frameState.commandList = commandList;\n  }\n\n  // If clustering is enabled before the billboard collections are updated,\n  // the images haven't been added to the image atlas so the screen space bounding boxes\n  // are incorrect.\n  const billboardCollection = this._billboardCollection;\n  if (\n    defined(billboardCollection) &&\n    billboardCollection.length > 0 &&\n    !billboardCollection.ready\n  ) {\n    commandList = frameState.commandList;\n    frameState.commandList = [];\n    billboardCollection.update(frameState);\n    frameState.commandList = commandList;\n  }\n\n  if (this._enabledDirty) {\n    this._enabledDirty = false;\n    updateEnable(this);\n    this._clusterDirty = true;\n  }\n\n  if (this._clusterDirty) {\n    this._cluster();\n\n    // Unless all existing billboards and labels were clustered, clustering will need to execute again next frame\n    this._clusterDirty =\n      (defined(labelCollection) && !labelCollection.ready) ||\n      (defined(billboardCollection) && !billboardCollection.ready);\n  }\n\n  if (defined(this._clusterLabelCollection)) {\n    this._clusterLabelCollection.update(frameState);\n  }\n  if (defined(this._clusterBillboardCollection)) {\n    this._clusterBillboardCollection.update(frameState);\n  }\n  if (defined(this._clusterPointCollection)) {\n    this._clusterPointCollection.update(frameState);\n  }\n\n  if (defined(labelCollection)) {\n    labelCollection.update(frameState);\n  }\n  if (defined(billboardCollection)) {\n    billboardCollection.update(frameState);\n  }\n  if (defined(this._pointCollection)) {\n    this._pointCollection.update(frameState);\n  }\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Unlike other objects that use WebGL resources, this object can be reused. For example, if a data source is removed\n * from a data source collection and added to another.\n * </p>\n */\nEntityCluster.prototype.destroy = function () {\n  if (defined(this._removeEventListener)) {\n    this._removeEventListener();\n    this._removeEventListener = undefined;\n  }\n\n  this._labelCollection =\n    this._labelCollection && this._labelCollection.destroy();\n  this._billboardCollection =\n    this._billboardCollection && this._billboardCollection.destroy();\n  this._pointCollection =\n    this._pointCollection && this._pointCollection.destroy();\n\n  this._clusterLabelCollection =\n    this._clusterLabelCollection && this._clusterLabelCollection.destroy();\n  this._clusterBillboardCollection =\n    this._clusterBillboardCollection &&\n    this._clusterBillboardCollection.destroy();\n  this._clusterPointCollection =\n    this._clusterPointCollection && this._clusterPointCollection.destroy();\n\n  this._labelCollection = undefined;\n  this._billboardCollection = undefined;\n  this._pointCollection = undefined;\n\n  this._clusterBillboardCollection = undefined;\n  this._clusterLabelCollection = undefined;\n  this._clusterPointCollection = undefined;\n\n  this._collectionIndicesByEntity = undefined;\n\n  this._unusedLabelIndices = [];\n  this._unusedBillboardIndices = [];\n  this._unusedPointIndices = [];\n\n  this._previousClusters = [];\n  this._previousHeight = undefined;\n\n  this._enabledDirty = false;\n  this._pixelRangeDirty = false;\n  this._minimumClusterSizeDirty = false;\n\n  return undefined;\n};\n\n/**\n * A event listener function used to style clusters.\n * @callback EntityCluster.newClusterCallback\n *\n * @param {Entity[]} clusteredEntities An array of the entities contained in the cluster.\n * @param {object} cluster An object containing the Billboard, Label, and Point\n * primitives that represent this cluster of entities.\n * @param {Billboard} cluster.billboard\n * @param {Label} cluster.label\n * @param {PointPrimitive} cluster.point\n *\n * @example\n * // The default cluster values.\n * dataSource.clustering.clusterEvent.addEventListener(function(entities, cluster) {\n *     cluster.label.show = true;\n *     cluster.label.text = entities.length.toLocaleString();\n * });\n */\nexport default EntityCluster;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}