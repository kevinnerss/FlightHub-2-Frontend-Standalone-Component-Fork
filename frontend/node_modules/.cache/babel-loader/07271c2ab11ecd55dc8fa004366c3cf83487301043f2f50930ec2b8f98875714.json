{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Check from \"../Core/Check.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport ContextLimits from \"./ContextLimits.js\";\nimport MipmapHint from \"./MipmapHint.js\";\nimport PixelDatatype from \"./PixelDatatype.js\";\nimport Sampler from \"./Sampler.js\";\nimport TextureMagnificationFilter from \"./TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"./TextureMinificationFilter.js\";\n\n/**\n * @typedef {object} Texture.ConstructorOptions\n *\n * @property {Context} context\n * @property {object} [source] The source for texel values to be loaded into the texture. A {@link ImageData}, {@link HTMLImageElement}, {@link HTMLCanvasElement},\n *                        {@link HTMLVideoElement}, {@link OffscreenCanvas}, or {@link ImageBitmap},\n *                        or an object with width, height, and arrayBufferView properties.\n * @property {PixelFormat} [pixelFormat=PixelFormat.RGBA] The format of each pixel, i.e., the number of components it has and what they represent.\n * @property {PixelDatatype} [pixelDatatype=PixelDatatype.UNSIGNED_BYTE] The data type of each pixel.\n * @property {boolean} [flipY=true] If true, the source values will be read as if the y-axis is inverted (y=0 at the top).\n * @property {boolean} [skipColorSpaceConversion=false] If true, color space conversions will be skipped when reading the texel values.\n * @property {Sampler} [sampler] Information about how to sample the texture.\n * @property {number} [width] The pixel width of the texture. If not supplied, must be available from the source.\n * @property {number} [height] The pixel height of the texture. If not supplied, must be available from the source.\n * @property {boolean} [preMultiplyAlpha] If true, the alpha channel will be multiplied into the other channels.\n * @property {string} [id] A unique identifier for the texture. If this is not given, then a GUID will be created.\n *\n * @private\n */\n\n/**\n * A wrapper for a {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLTexture|WebGLTexture}\n * to abstract away the verbose GL calls associated with setting up a texture.\n *\n * @alias Texture\n * @constructor\n *\n * @param {Texture.ConstructorOptions} options\n * @private\n */\nfunction Texture(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  //>>includeEnd('debug');\n\n  const {\n    context,\n    source,\n    pixelFormat = PixelFormat.RGBA,\n    pixelDatatype = PixelDatatype.UNSIGNED_BYTE,\n    flipY = true,\n    skipColorSpaceConversion = false,\n    sampler = new Sampler()\n  } = options;\n  let {\n    width,\n    height\n  } = options;\n  if (defined(source)) {\n    // Make sure we are using the element's intrinsic width and height where available\n    if (!defined(width)) {\n      width = source.videoWidth ?? source.naturalWidth ?? source.width;\n    }\n    if (!defined(height)) {\n      height = source.videoHeight ?? source.naturalHeight ?? source.height;\n    }\n  }\n\n  // Use premultiplied alpha for opaque textures should perform better on Chrome:\n  // http://media.tojicode.com/webglCamp4/#20\n  const preMultiplyAlpha = options.preMultiplyAlpha || pixelFormat === PixelFormat.RGB || pixelFormat === PixelFormat.LUMINANCE;\n  const internalFormat = PixelFormat.toInternalFormat(pixelFormat, pixelDatatype, context);\n  const isCompressed = PixelFormat.isCompressedFormat(internalFormat);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(width) || !defined(height)) {\n    throw new DeveloperError(\"options requires a source field to create an initialized texture or width and height fields to create a blank texture.\");\n  }\n  Check.typeOf.number.greaterThan(\"width\", width, 0);\n  if (width > ContextLimits.maximumTextureSize) {\n    throw new DeveloperError(`Width must be less than or equal to the maximum texture size (${ContextLimits.maximumTextureSize}).  Check maximumTextureSize.`);\n  }\n  Check.typeOf.number.greaterThan(\"height\", height, 0);\n  if (height > ContextLimits.maximumTextureSize) {\n    throw new DeveloperError(`Height must be less than or equal to the maximum texture size (${ContextLimits.maximumTextureSize}).  Check maximumTextureSize.`);\n  }\n  if (!PixelFormat.validate(pixelFormat)) {\n    throw new DeveloperError(\"Invalid options.pixelFormat.\");\n  }\n  if (!isCompressed && !PixelDatatype.validate(pixelDatatype)) {\n    throw new DeveloperError(\"Invalid options.pixelDatatype.\");\n  }\n  if (pixelFormat === PixelFormat.DEPTH_COMPONENT && pixelDatatype !== PixelDatatype.UNSIGNED_SHORT && pixelDatatype !== PixelDatatype.UNSIGNED_INT) {\n    throw new DeveloperError(\"When options.pixelFormat is DEPTH_COMPONENT, options.pixelDatatype must be UNSIGNED_SHORT or UNSIGNED_INT.\");\n  }\n  if (pixelFormat === PixelFormat.DEPTH_STENCIL && pixelDatatype !== PixelDatatype.UNSIGNED_INT_24_8) {\n    throw new DeveloperError(\"When options.pixelFormat is DEPTH_STENCIL, options.pixelDatatype must be UNSIGNED_INT_24_8.\");\n  }\n  if (pixelDatatype === PixelDatatype.FLOAT && !context.floatingPointTexture) {\n    throw new DeveloperError(\"When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension.  Check context.floatingPointTexture.\");\n  }\n  if (pixelDatatype === PixelDatatype.HALF_FLOAT && !context.halfFloatingPointTexture) {\n    throw new DeveloperError(\"When options.pixelDatatype is HALF_FLOAT, this WebGL implementation must support the OES_texture_half_float extension. Check context.halfFloatingPointTexture.\");\n  }\n  if (PixelFormat.isDepthFormat(pixelFormat)) {\n    if (defined(source)) {\n      throw new DeveloperError(\"When options.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, source cannot be provided.\");\n    }\n    if (!context.depthTexture) {\n      throw new DeveloperError(\"When options.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, this WebGL implementation must support WEBGL_depth_texture.  Check context.depthTexture.\");\n    }\n  }\n  if (isCompressed) {\n    if (!defined(source) || !defined(source.arrayBufferView)) {\n      throw new DeveloperError(\"When options.pixelFormat is compressed, options.source.arrayBufferView must be defined.\");\n    }\n    if (PixelFormat.isDXTFormat(internalFormat) && !context.s3tc) {\n      throw new DeveloperError(\"When options.pixelFormat is S3TC compressed, this WebGL implementation must support the WEBGL_compressed_texture_s3tc extension. Check context.s3tc.\");\n    } else if (PixelFormat.isPVRTCFormat(internalFormat) && !context.pvrtc) {\n      throw new DeveloperError(\"When options.pixelFormat is PVRTC compressed, this WebGL implementation must support the WEBGL_compressed_texture_pvrtc extension. Check context.pvrtc.\");\n    } else if (PixelFormat.isASTCFormat(internalFormat) && !context.astc) {\n      throw new DeveloperError(\"When options.pixelFormat is ASTC compressed, this WebGL implementation must support the WEBGL_compressed_texture_astc extension. Check context.astc.\");\n    } else if (PixelFormat.isETC2Format(internalFormat) && !context.etc) {\n      throw new DeveloperError(\"When options.pixelFormat is ETC2 compressed, this WebGL implementation must support the WEBGL_compressed_texture_etc extension. Check context.etc.\");\n    } else if (PixelFormat.isETC1Format(internalFormat) && !context.etc1) {\n      throw new DeveloperError(\"When options.pixelFormat is ETC1 compressed, this WebGL implementation must support the WEBGL_compressed_texture_etc1 extension. Check context.etc1.\");\n    } else if (PixelFormat.isBC7Format(internalFormat) && !context.bc7) {\n      throw new DeveloperError(\"When options.pixelFormat is BC7 compressed, this WebGL implementation must support the EXT_texture_compression_bptc extension. Check context.bc7.\");\n    }\n    if (PixelFormat.compressedTextureSizeInBytes(internalFormat, width, height) !== source.arrayBufferView.byteLength) {\n      throw new DeveloperError(\"The byte length of the array buffer is invalid for the compressed texture with the given width and height.\");\n    }\n  }\n  //>>includeEnd('debug');\n\n  const gl = context._gl;\n  const sizeInBytes = isCompressed ? PixelFormat.compressedTextureSizeInBytes(pixelFormat, width, height) : PixelFormat.textureSizeInBytes(pixelFormat, pixelDatatype, width, height);\n  this._id = options.id ?? createGuid();\n  this._context = context;\n  this._textureFilterAnisotropic = context._textureFilterAnisotropic;\n  this._textureTarget = gl.TEXTURE_2D;\n  this._texture = gl.createTexture();\n  this._internalFormat = internalFormat;\n  this._pixelFormat = pixelFormat;\n  this._pixelDatatype = pixelDatatype;\n  this._width = width;\n  this._height = height;\n  this._dimensions = new Cartesian2(width, height);\n  this._hasMipmap = false;\n  this._sizeInBytes = sizeInBytes;\n  this._preMultiplyAlpha = preMultiplyAlpha;\n  this._flipY = flipY;\n  this._initialized = false;\n  this._sampler = undefined;\n  this._sampler = sampler;\n  setupSampler(this, sampler);\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(this._textureTarget, this._texture);\n  if (defined(source)) {\n    if (skipColorSpaceConversion) {\n      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n    } else {\n      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.BROWSER_DEFAULT_WEBGL);\n    }\n    if (defined(source.arrayBufferView)) {\n      const isCompressed = PixelFormat.isCompressedFormat(internalFormat);\n      if (isCompressed) {\n        loadCompressedBufferSource(this, source);\n      } else {\n        loadBufferSource(this, source);\n      }\n    } else if (defined(source.framebuffer)) {\n      loadFramebufferSource(this, source);\n    } else {\n      loadImageSource(this, source);\n    }\n    this._initialized = true;\n  } else {\n    loadNull(this);\n  }\n  gl.bindTexture(this._textureTarget, null);\n}\n\n/**\n * Load compressed texel data from a buffer into a texture.\n *\n * @param {Texture} texture The texture to which texel values will be loaded.\n * @param {object} source The source for texel values to be loaded into the texture.\n *\n * @private\n */\nfunction loadCompressedBufferSource(texture, source) {\n  const context = texture._context;\n  const gl = context._gl;\n  const textureTarget = texture._textureTarget;\n  const internalFormat = texture._internalFormat;\n  const {\n    width,\n    height\n  } = texture;\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);\n  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n  gl.compressedTexImage2D(textureTarget, 0, internalFormat, width, height, 0, source.arrayBufferView);\n  if (defined(source.mipLevels)) {\n    let mipWidth = width;\n    let mipHeight = height;\n    for (let i = 0; i < source.mipLevels.length; ++i) {\n      mipWidth = nextMipSize(mipWidth);\n      mipHeight = nextMipSize(mipHeight);\n      gl.compressedTexImage2D(textureTarget, i + 1, internalFormat, mipWidth, mipHeight, 0, source.mipLevels[i]);\n    }\n  }\n}\n\n/**\n * Load texel data from a buffer into a texture.\n *\n * @param {Texture} texture The texture to which texel values will be loaded.\n * @param {object} source The source for texel values to be loaded into the texture.\n *\n * @private\n */\nfunction loadBufferSource(texture, source) {\n  const context = texture._context;\n  const gl = context._gl;\n  const textureTarget = texture._textureTarget;\n  const internalFormat = texture._internalFormat;\n  const {\n    width,\n    height,\n    pixelFormat,\n    pixelDatatype,\n    flipY\n  } = texture;\n  const unpackAlignment = PixelFormat.alignmentInBytes(pixelFormat, pixelDatatype, width);\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);\n  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n  let {\n    arrayBufferView\n  } = source;\n  if (flipY) {\n    arrayBufferView = PixelFormat.flipY(arrayBufferView, pixelFormat, pixelDatatype, width, height);\n  }\n  gl.texImage2D(textureTarget, 0, internalFormat, width, height, 0, pixelFormat, PixelDatatype.toWebGLConstant(pixelDatatype, context), arrayBufferView);\n  if (defined(source.mipLevels)) {\n    let mipWidth = width;\n    let mipHeight = height;\n    for (let i = 0; i < source.mipLevels.length; ++i) {\n      mipWidth = nextMipSize(mipWidth);\n      mipHeight = nextMipSize(mipHeight);\n      gl.texImage2D(textureTarget, i + 1, internalFormat, mipWidth, mipHeight, 0, pixelFormat, PixelDatatype.toWebGLConstant(pixelDatatype, context), source.mipLevels[i]);\n    }\n  }\n}\n\n/**\n * Load texel data from a buffer into part of a texture\n *\n * @param {Texture} texture The texture to which texel values will be loaded.\n * @param {TypedArray} arrayBufferView The texel values to be loaded into the texture.\n * @param {number} xOffset The texel x coordinate of the lower left corner of the subregion of the texture to be updated.\n * @param {number} yOffset The texel y coordinate of the lower left corner of the subregion of the texture to be updated.\n * @param {number} width The width of the source data, in pixels.\n * @param {number} width The height of the source data, in pixels.\n *\n * @private\n */\nfunction loadPartialBufferSource(texture, arrayBufferView, xOffset, yOffset, width, height) {\n  const context = texture._context;\n  const gl = context._gl;\n  const {\n    pixelFormat,\n    pixelDatatype\n  } = texture;\n  const unpackAlignment = PixelFormat.alignmentInBytes(pixelFormat, pixelDatatype, width);\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);\n  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n  if (texture.flipY) {\n    arrayBufferView = PixelFormat.flipY(arrayBufferView, pixelFormat, pixelDatatype, width, height);\n  }\n  gl.texSubImage2D(texture._textureTarget, 0, xOffset, yOffset, width, height, pixelFormat, PixelDatatype.toWebGLConstant(pixelDatatype, context), arrayBufferView);\n}\n\n/**\n * Load texel data from a framebuffer into a texture.\n *\n * @param {Texture} texture The texture to which texel values will be loaded.\n * @param {object} source The source for texel values to be loaded into the texture.\n *\n * @private\n */\nfunction loadFramebufferSource(texture, source) {\n  const context = texture._context;\n  const gl = context._gl;\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);\n  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n  if (source.framebuffer !== context.defaultFramebuffer) {\n    source.framebuffer._bind();\n  }\n  gl.copyTexImage2D(texture._textureTarget, 0, texture._internalFormat, source.xOffset, source.yOffset, texture.width, texture.height, 0);\n  if (source.framebuffer !== context.defaultFramebuffer) {\n    source.framebuffer._unBind();\n  }\n}\n\n/**\n * Load texel data from an Image into a texture.\n *\n * @param {Texture} texture The texture to which texel values will be loaded.\n * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|OffscreenCanvas|ImageBitmap} source The source for texel values to be loaded into the texture.\n *\n * @private\n */\nfunction loadImageSource(texture, source) {\n  const context = texture._context;\n  const gl = context._gl;\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);\n  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.preMultiplyAlpha);\n  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n  gl.texImage2D(texture._textureTarget, 0, texture._internalFormat, texture.pixelFormat, PixelDatatype.toWebGLConstant(texture.pixelDatatype, context), source);\n}\n\n/**\n * Load texel data from an Image into part of a texture\n *\n * @param {Texture} texture The texture to which texel values will be loaded.\n * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} source The source for texel values to be loaded into the texture.\n * @param {number} xOffset The texel x coordinate of the lower left corner of the subregion of the texture to be updated.\n * @param {number} yOffset The texel y coordinate of the lower left corner of the subregion of the texture to be updated.\n *\n * @private\n */\nfunction loadPartialImageSource(texture, source, xOffset, yOffset) {\n  const context = texture._context;\n  const gl = context._gl;\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);\n  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.preMultiplyAlpha);\n  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n  gl.texSubImage2D(texture._textureTarget, 0, xOffset, yOffset, texture.pixelFormat, PixelDatatype.toWebGLConstant(texture.pixelDatatype, context), source);\n}\n\n/**\n * Compute a dimension of the image for the next mip level.\n *\n * @param {number} currentSize The size of the current mip level.\n * @returns {number} The size of the next mip level.\n *\n * @private\n */\nfunction nextMipSize(currentSize) {\n  const nextSize = Math.floor(currentSize / 2) | 0;\n  return Math.max(nextSize, 1);\n}\n\n/**\n * Allocate a texture in GPU memory, without providing any image data.\n *\n * @param {Texture} texture The texture to be initialized with null values.\n *\n * @private\n */\nfunction loadNull(texture) {\n  const context = texture._context;\n  context._gl.texImage2D(texture._textureTarget, 0, texture._internalFormat, texture._width, texture._height, 0, texture._pixelFormat, PixelDatatype.toWebGLConstant(texture._pixelDatatype, context), null);\n}\n\n/**\n * This function is identical to using the Texture constructor except that it can be\n * replaced with a mock/spy in tests.\n * @private\n */\nTexture.create = function (options) {\n  return new Texture(options);\n};\n\n/**\n * Creates a texture, and copies a subimage of the framebuffer to it.  When called without arguments,\n * the texture is the same width and height as the framebuffer and contains its contents.\n *\n * @param {object} options Object with the following properties:\n * @param {Context} options.context The context in which the Texture gets created.\n * @param {PixelFormat} [options.pixelFormat=PixelFormat.RGB] The texture's internal pixel format.\n * @param {number} [options.framebufferXOffset=0] An offset in the x direction in the framebuffer where copying begins from.\n * @param {number} [options.framebufferYOffset=0] An offset in the y direction in the framebuffer where copying begins from.\n * @param {number} [options.width=canvas.clientWidth] The width of the texture in texels.\n * @param {number} [options.height=canvas.clientHeight] The height of the texture in texels.\n * @param {Framebuffer} [options.framebuffer=defaultFramebuffer] The framebuffer from which to create the texture.  If this\n *        parameter is not specified, the default framebuffer is used.\n * @returns {Texture} A texture with contents from the framebuffer.\n *\n * @exception {DeveloperError} Invalid pixelFormat.\n * @exception {DeveloperError} pixelFormat cannot be DEPTH_COMPONENT, DEPTH_STENCIL or a compressed format.\n * @exception {DeveloperError} framebufferXOffset must be greater than or equal to zero.\n * @exception {DeveloperError} framebufferYOffset must be greater than or equal to zero.\n * @exception {DeveloperError} framebufferXOffset + width must be less than or equal to canvas.clientWidth.\n * @exception {DeveloperError} framebufferYOffset + height must be less than or equal to canvas.clientHeight.\n *\n *\n * @example\n * // Create a texture with the contents of the framebuffer.\n * const t = Texture.fromFramebuffer({\n *     context : context\n * });\n *\n * @see Sampler\n *\n * @private\n */\nTexture.fromFramebuffer = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  //>>includeEnd('debug');\n\n  const context = options.context;\n  const {\n    pixelFormat = PixelFormat.RGB,\n    framebufferXOffset = 0,\n    framebufferYOffset = 0,\n    width = context.drawingBufferWidth,\n    height = context.drawingBufferHeight,\n    framebuffer\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!PixelFormat.validate(pixelFormat)) {\n    throw new DeveloperError(\"Invalid pixelFormat.\");\n  }\n  if (PixelFormat.isDepthFormat(pixelFormat) || PixelFormat.isCompressedFormat(pixelFormat)) {\n    throw new DeveloperError(\"pixelFormat cannot be DEPTH_COMPONENT, DEPTH_STENCIL or a compressed format.\");\n  }\n  Check.defined(\"options.context\", context);\n  Check.typeOf.number.greaterThanOrEquals(\"framebufferXOffset\", framebufferXOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"framebufferYOffset\", framebufferYOffset, 0);\n  if (framebufferXOffset + width > context.drawingBufferWidth) {\n    throw new DeveloperError(\"framebufferXOffset + width must be less than or equal to drawingBufferWidth\");\n  }\n  if (framebufferYOffset + height > context.drawingBufferHeight) {\n    throw new DeveloperError(\"framebufferYOffset + height must be less than or equal to drawingBufferHeight.\");\n  }\n  //>>includeEnd('debug');\n\n  const texture = new Texture({\n    context: context,\n    width: width,\n    height: height,\n    pixelFormat: pixelFormat,\n    source: {\n      framebuffer: defined(framebuffer) ? framebuffer : context.defaultFramebuffer,\n      xOffset: framebufferXOffset,\n      yOffset: framebufferYOffset,\n      width: width,\n      height: height\n    }\n  });\n  return texture;\n};\nObject.defineProperties(Texture.prototype, {\n  /**\n   * A unique id for the texture\n   * @memberof Texture.prototype\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  id: {\n    get: function () {\n      return this._id;\n    }\n  },\n  /**\n   * The sampler to use when sampling this texture.\n   * Create a sampler by calling {@link Sampler}.  If this\n   * parameter is not specified, a default sampler is used.  The default sampler clamps texture\n   * coordinates in both directions, uses linear filtering for both magnification and minification,\n   * and uses a maximum anisotropy of 1.0.\n   * @memberof Texture.prototype\n   * @type {Sampler}\n   * @private\n   */\n  sampler: {\n    get: function () {\n      return this._sampler;\n    },\n    set: function (sampler) {\n      setupSampler(this, sampler);\n      this._sampler = sampler;\n    }\n  },\n  pixelFormat: {\n    get: function () {\n      return this._pixelFormat;\n    }\n  },\n  pixelDatatype: {\n    get: function () {\n      return this._pixelDatatype;\n    }\n  },\n  dimensions: {\n    get: function () {\n      return this._dimensions;\n    }\n  },\n  preMultiplyAlpha: {\n    get: function () {\n      return this._preMultiplyAlpha;\n    }\n  },\n  flipY: {\n    get: function () {\n      return this._flipY;\n    }\n  },\n  width: {\n    get: function () {\n      return this._width;\n    }\n  },\n  height: {\n    get: function () {\n      return this._height;\n    }\n  },\n  sizeInBytes: {\n    get: function () {\n      if (this._hasMipmap) {\n        return Math.floor(this._sizeInBytes * 4 / 3);\n      }\n      return this._sizeInBytes;\n    }\n  },\n  _target: {\n    get: function () {\n      return this._textureTarget;\n    }\n  }\n});\n\n/**\n * Set up a sampler for use with a texture\n * @param {Texture} texture The texture to be sampled by this sampler\n * @param {Sampler} sampler Information about how to sample the texture\n * @private\n */\nfunction setupSampler(texture, sampler) {\n  let {\n    minificationFilter,\n    magnificationFilter\n  } = sampler;\n  const mipmap = [TextureMinificationFilter.NEAREST_MIPMAP_NEAREST, TextureMinificationFilter.NEAREST_MIPMAP_LINEAR, TextureMinificationFilter.LINEAR_MIPMAP_NEAREST, TextureMinificationFilter.LINEAR_MIPMAP_LINEAR].includes(minificationFilter);\n  const context = texture._context;\n  const pixelFormat = texture._pixelFormat;\n  const pixelDatatype = texture._pixelDatatype;\n\n  // float textures only support nearest filtering unless the linear extensions are supported\n  if (pixelDatatype === PixelDatatype.FLOAT && !context.textureFloatLinear || pixelDatatype === PixelDatatype.HALF_FLOAT && !context.textureHalfFloatLinear) {\n    // override the sampler's settings\n    minificationFilter = mipmap ? TextureMinificationFilter.NEAREST_MIPMAP_NEAREST : TextureMinificationFilter.NEAREST;\n    magnificationFilter = TextureMagnificationFilter.NEAREST;\n  }\n\n  // WebGL 2 depth texture only support nearest filtering. See section 3.8.13 OpenGL ES 3 spec\n  if (context.webgl2) {\n    if (PixelFormat.isDepthFormat(pixelFormat)) {\n      minificationFilter = TextureMinificationFilter.NEAREST;\n      magnificationFilter = TextureMagnificationFilter.NEAREST;\n    }\n  }\n  const gl = context._gl;\n  const target = texture._textureTarget;\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, texture._texture);\n  gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, minificationFilter);\n  gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, magnificationFilter);\n  gl.texParameteri(target, gl.TEXTURE_WRAP_S, sampler.wrapS);\n  gl.texParameteri(target, gl.TEXTURE_WRAP_T, sampler.wrapT);\n  if (defined(texture._textureFilterAnisotropic)) {\n    gl.texParameteri(target, texture._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, sampler.maximumAnisotropy);\n  }\n  gl.bindTexture(target, null);\n}\n\n/**\n * Copy new image data into this texture, from a source {@link ImageData}, {@link HTMLImageElement}, {@link HTMLCanvasElement}, or {@link HTMLVideoElement}.\n * or an object with width, height, and arrayBufferView properties.\n * @param {object} options Object with the following properties:\n * @param {object} options.source The source {@link ImageData}, {@link HTMLImageElement}, {@link HTMLCanvasElement}, {@link HTMLVideoElement},\n *                        {@link OffscreenCanvas}, or {@link ImageBitmap},\n *                        or an object with width, height, and arrayBufferView properties.\n * @param {number} [options.xOffset=0] The offset in the x direction within the texture to copy into.\n * @param {number} [options.yOffset=0] The offset in the y direction within the texture to copy into.\n * @param {boolean} [options.skipColorSpaceConversion=false] If true, any custom gamma or color profiles in the texture will be ignored.\n *\n * @exception {DeveloperError} Cannot call copyFrom when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.\n * @exception {DeveloperError} Cannot call copyFrom with a compressed texture pixel format.\n * @exception {DeveloperError} xOffset must be greater than or equal to zero.\n * @exception {DeveloperError} yOffset must be greater than or equal to zero.\n * @exception {DeveloperError} xOffset + source.width must be less than or equal to width.\n * @exception {DeveloperError} yOffset + source.height must be less than or equal to height.\n * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.\n * @private\n * @example\n * texture.copyFrom({\n *  source: {\n *   width : 1,\n *   height : 1,\n *   arrayBufferView : new Uint8Array([255, 0, 0, 255])\n *  }\n * });\n */\nTexture.prototype.copyFrom = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options\", options);\n  //>>includeEnd('debug');\n\n  const {\n    xOffset = 0,\n    yOffset = 0,\n    source,\n    skipColorSpaceConversion = false\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.source\", source);\n  if (PixelFormat.isDepthFormat(this._pixelFormat)) {\n    throw new DeveloperError(\"Cannot call copyFrom when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.\");\n  }\n  if (PixelFormat.isCompressedFormat(this._pixelFormat)) {\n    throw new DeveloperError(\"Cannot call copyFrom with a compressed texture pixel format.\");\n  }\n  Check.typeOf.number.greaterThanOrEquals(\"xOffset\", xOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"yOffset\", yOffset, 0);\n  Check.typeOf.number.lessThanOrEquals(\"xOffset + options.source.width\", xOffset + source.width, this._width);\n  Check.typeOf.number.lessThanOrEquals(\"yOffset + options.source.height\", yOffset + source.height, this._height);\n  //>>includeEnd('debug');\n\n  const context = this._context;\n  const gl = context._gl;\n  const target = this._textureTarget;\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, this._texture);\n  let {\n    width,\n    height\n  } = source;\n\n  // Make sure we are using the element's intrinsic width and height where available\n  if (defined(source.videoWidth) && defined(source.videoHeight)) {\n    width = source.videoWidth;\n    height = source.videoHeight;\n  } else if (defined(source.naturalWidth) && defined(source.naturalHeight)) {\n    width = source.naturalWidth;\n    height = source.naturalHeight;\n  }\n  if (skipColorSpaceConversion) {\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n  } else {\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.BROWSER_DEFAULT_WEBGL);\n  }\n  let uploaded = false;\n  if (!this._initialized) {\n    if (xOffset === 0 && yOffset === 0 && width === this._width && height === this._height) {\n      // initialize the entire texture\n      if (defined(source.arrayBufferView)) {\n        loadBufferSource(this, source);\n      } else {\n        loadImageSource(this, source);\n      }\n      uploaded = true;\n    } else {\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n      loadNull(this);\n    }\n    this._initialized = true;\n  }\n  if (!uploaded) {\n    if (defined(source.arrayBufferView)) {\n      loadPartialBufferSource(this, source.arrayBufferView, xOffset, yOffset, width, height);\n    } else {\n      loadPartialImageSource(this, source, xOffset, yOffset);\n    }\n  }\n  gl.bindTexture(target, null);\n};\n\n/**\n * @param {number} [xOffset=0] The offset in the x direction within the texture to copy into.\n * @param {number} [yOffset=0] The offset in the y direction within the texture to copy into.\n * @param {number} [framebufferXOffset=0] optional\n * @param {number} [framebufferYOffset=0] optional\n * @param {number} [width=width] optional\n * @param {number} [height=height] optional\n * @private\n * @exception {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.\n * @exception {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.\n * @exception {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.\n * @exception {DeveloperError} Cannot call copyFrom with a compressed texture pixel format.\n * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.\n * @exception {DeveloperError} xOffset must be greater than or equal to zero.\n * @exception {DeveloperError} yOffset must be greater than or equal to zero.\n * @exception {DeveloperError} framebufferXOffset must be greater than or equal to zero.\n * @exception {DeveloperError} framebufferYOffset must be greater than or equal to zero.\n * @exception {DeveloperError} xOffset + width must be less than or equal to width.\n * @exception {DeveloperError} yOffset + height must be less than or equal to height.\n */\nTexture.prototype.copyFromFramebuffer = function (xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {\n  xOffset = xOffset ?? 0;\n  yOffset = yOffset ?? 0;\n  framebufferXOffset = framebufferXOffset ?? 0;\n  framebufferYOffset = framebufferYOffset ?? 0;\n  width = width ?? this._width;\n  height = height ?? this._height;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (PixelFormat.isDepthFormat(this._pixelFormat)) {\n    throw new DeveloperError(\"Cannot call copyFromFramebuffer when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.\");\n  }\n  if (this._pixelDatatype === PixelDatatype.FLOAT) {\n    throw new DeveloperError(\"Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.\");\n  }\n  if (this._pixelDatatype === PixelDatatype.HALF_FLOAT) {\n    throw new DeveloperError(\"Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.\");\n  }\n  if (PixelFormat.isCompressedFormat(this._pixelFormat)) {\n    throw new DeveloperError(\"Cannot call copyFrom with a compressed texture pixel format.\");\n  }\n  Check.typeOf.number.greaterThanOrEquals(\"xOffset\", xOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"yOffset\", yOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"framebufferXOffset\", framebufferXOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"framebufferYOffset\", framebufferYOffset, 0);\n  Check.typeOf.number.lessThanOrEquals(\"xOffset + width\", xOffset + width, this._width);\n  Check.typeOf.number.lessThanOrEquals(\"yOffset + height\", yOffset + height, this._height);\n  //>>includeEnd('debug');\n\n  const gl = this._context._gl;\n  const target = this._textureTarget;\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, this._texture);\n  gl.copyTexSubImage2D(target, 0, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);\n  gl.bindTexture(target, null);\n  this._initialized = true;\n};\n\n/**\n * @param {MipmapHint} [hint=MipmapHint.DONT_CARE] optional.\n * @private\n * @exception {DeveloperError} Cannot call generateMipmap when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.\n * @exception {DeveloperError} Cannot call generateMipmap when the texture pixel format is a compressed format.\n * @exception {DeveloperError} hint is invalid.\n * @exception {DeveloperError} This texture's width must be a power of two to call generateMipmap() in a WebGL1 context.\n * @exception {DeveloperError} This texture's height must be a power of two to call generateMipmap() in a WebGL1 context.\n * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.\n */\nTexture.prototype.generateMipmap = function (hint) {\n  hint = hint ?? MipmapHint.DONT_CARE;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (PixelFormat.isDepthFormat(this._pixelFormat)) {\n    throw new DeveloperError(\"Cannot call generateMipmap when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.\");\n  }\n  if (PixelFormat.isCompressedFormat(this._pixelFormat)) {\n    throw new DeveloperError(\"Cannot call generateMipmap with a compressed pixel format.\");\n  }\n  if (!this._context.webgl2) {\n    if (this._width > 1 && !CesiumMath.isPowerOfTwo(this._width)) {\n      throw new DeveloperError(\"width must be a power of two to call generateMipmap() in a WebGL1 context.\");\n    }\n    if (this._height > 1 && !CesiumMath.isPowerOfTwo(this._height)) {\n      throw new DeveloperError(\"height must be a power of two to call generateMipmap() in a WebGL1 context.\");\n    }\n  }\n  if (!MipmapHint.validate(hint)) {\n    throw new DeveloperError(\"hint is invalid.\");\n  }\n  //>>includeEnd('debug');\n\n  this._hasMipmap = true;\n  const gl = this._context._gl;\n  const target = this._textureTarget;\n  gl.hint(gl.GENERATE_MIPMAP_HINT, hint);\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, this._texture);\n  gl.generateMipmap(target);\n  gl.bindTexture(target, null);\n};\nTexture.prototype.isDestroyed = function () {\n  return false;\n};\nTexture.prototype.destroy = function () {\n  this._context._gl.deleteTexture(this._texture);\n  return destroyObject(this);\n};\nexport default Texture;","map":{"version":3,"names":["Cartesian2","Check","createGuid","Frozen","defined","destroyObject","DeveloperError","CesiumMath","PixelFormat","ContextLimits","MipmapHint","PixelDatatype","Sampler","TextureMagnificationFilter","TextureMinificationFilter","Texture","options","EMPTY_OBJECT","context","source","pixelFormat","RGBA","pixelDatatype","UNSIGNED_BYTE","flipY","skipColorSpaceConversion","sampler","width","height","videoWidth","naturalWidth","videoHeight","naturalHeight","preMultiplyAlpha","RGB","LUMINANCE","internalFormat","toInternalFormat","isCompressed","isCompressedFormat","typeOf","number","greaterThan","maximumTextureSize","validate","DEPTH_COMPONENT","UNSIGNED_SHORT","UNSIGNED_INT","DEPTH_STENCIL","UNSIGNED_INT_24_8","FLOAT","floatingPointTexture","HALF_FLOAT","halfFloatingPointTexture","isDepthFormat","depthTexture","arrayBufferView","isDXTFormat","s3tc","isPVRTCFormat","pvrtc","isASTCFormat","astc","isETC2Format","etc","isETC1Format","etc1","isBC7Format","bc7","compressedTextureSizeInBytes","byteLength","gl","_gl","sizeInBytes","textureSizeInBytes","_id","id","_context","_textureFilterAnisotropic","_textureTarget","TEXTURE_2D","_texture","createTexture","_internalFormat","_pixelFormat","_pixelDatatype","_width","_height","_dimensions","_hasMipmap","_sizeInBytes","_preMultiplyAlpha","_flipY","_initialized","_sampler","undefined","setupSampler","activeTexture","TEXTURE0","bindTexture","pixelStorei","UNPACK_COLORSPACE_CONVERSION_WEBGL","NONE","BROWSER_DEFAULT_WEBGL","loadCompressedBufferSource","loadBufferSource","framebuffer","loadFramebufferSource","loadImageSource","loadNull","texture","textureTarget","UNPACK_ALIGNMENT","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_FLIP_Y_WEBGL","compressedTexImage2D","mipLevels","mipWidth","mipHeight","i","length","nextMipSize","unpackAlignment","alignmentInBytes","texImage2D","toWebGLConstant","loadPartialBufferSource","xOffset","yOffset","texSubImage2D","defaultFramebuffer","_bind","copyTexImage2D","_unBind","loadPartialImageSource","currentSize","nextSize","Math","floor","max","create","fromFramebuffer","framebufferXOffset","framebufferYOffset","drawingBufferWidth","drawingBufferHeight","greaterThanOrEquals","Object","defineProperties","prototype","get","set","dimensions","_target","minificationFilter","magnificationFilter","mipmap","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","includes","textureFloatLinear","textureHalfFloatLinear","NEAREST","webgl2","target","texParameteri","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","wrapS","TEXTURE_WRAP_T","wrapT","TEXTURE_MAX_ANISOTROPY_EXT","maximumAnisotropy","copyFrom","lessThanOrEquals","uploaded","copyFromFramebuffer","copyTexSubImage2D","generateMipmap","hint","DONT_CARE","isPowerOfTwo","GENERATE_MIPMAP_HINT","isDestroyed","destroy","deleteTexture"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Renderer/Texture.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Check from \"../Core/Check.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport ContextLimits from \"./ContextLimits.js\";\nimport MipmapHint from \"./MipmapHint.js\";\nimport PixelDatatype from \"./PixelDatatype.js\";\nimport Sampler from \"./Sampler.js\";\nimport TextureMagnificationFilter from \"./TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"./TextureMinificationFilter.js\";\n\n/**\n * @typedef {object} Texture.ConstructorOptions\n *\n * @property {Context} context\n * @property {object} [source] The source for texel values to be loaded into the texture. A {@link ImageData}, {@link HTMLImageElement}, {@link HTMLCanvasElement},\n *                        {@link HTMLVideoElement}, {@link OffscreenCanvas}, or {@link ImageBitmap},\n *                        or an object with width, height, and arrayBufferView properties.\n * @property {PixelFormat} [pixelFormat=PixelFormat.RGBA] The format of each pixel, i.e., the number of components it has and what they represent.\n * @property {PixelDatatype} [pixelDatatype=PixelDatatype.UNSIGNED_BYTE] The data type of each pixel.\n * @property {boolean} [flipY=true] If true, the source values will be read as if the y-axis is inverted (y=0 at the top).\n * @property {boolean} [skipColorSpaceConversion=false] If true, color space conversions will be skipped when reading the texel values.\n * @property {Sampler} [sampler] Information about how to sample the texture.\n * @property {number} [width] The pixel width of the texture. If not supplied, must be available from the source.\n * @property {number} [height] The pixel height of the texture. If not supplied, must be available from the source.\n * @property {boolean} [preMultiplyAlpha] If true, the alpha channel will be multiplied into the other channels.\n * @property {string} [id] A unique identifier for the texture. If this is not given, then a GUID will be created.\n *\n * @private\n */\n\n/**\n * A wrapper for a {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLTexture|WebGLTexture}\n * to abstract away the verbose GL calls associated with setting up a texture.\n *\n * @alias Texture\n * @constructor\n *\n * @param {Texture.ConstructorOptions} options\n * @private\n */\nfunction Texture(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  //>>includeEnd('debug');\n\n  const {\n    context,\n    source,\n    pixelFormat = PixelFormat.RGBA,\n    pixelDatatype = PixelDatatype.UNSIGNED_BYTE,\n    flipY = true,\n    skipColorSpaceConversion = false,\n    sampler = new Sampler(),\n  } = options;\n\n  let { width, height } = options;\n  if (defined(source)) {\n    // Make sure we are using the element's intrinsic width and height where available\n    if (!defined(width)) {\n      width = source.videoWidth ?? source.naturalWidth ?? source.width;\n    }\n    if (!defined(height)) {\n      height = source.videoHeight ?? source.naturalHeight ?? source.height;\n    }\n  }\n\n  // Use premultiplied alpha for opaque textures should perform better on Chrome:\n  // http://media.tojicode.com/webglCamp4/#20\n  const preMultiplyAlpha =\n    options.preMultiplyAlpha ||\n    pixelFormat === PixelFormat.RGB ||\n    pixelFormat === PixelFormat.LUMINANCE;\n\n  const internalFormat = PixelFormat.toInternalFormat(\n    pixelFormat,\n    pixelDatatype,\n    context,\n  );\n\n  const isCompressed = PixelFormat.isCompressedFormat(internalFormat);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(width) || !defined(height)) {\n    throw new DeveloperError(\n      \"options requires a source field to create an initialized texture or width and height fields to create a blank texture.\",\n    );\n  }\n\n  Check.typeOf.number.greaterThan(\"width\", width, 0);\n\n  if (width > ContextLimits.maximumTextureSize) {\n    throw new DeveloperError(\n      `Width must be less than or equal to the maximum texture size (${ContextLimits.maximumTextureSize}).  Check maximumTextureSize.`,\n    );\n  }\n\n  Check.typeOf.number.greaterThan(\"height\", height, 0);\n\n  if (height > ContextLimits.maximumTextureSize) {\n    throw new DeveloperError(\n      `Height must be less than or equal to the maximum texture size (${ContextLimits.maximumTextureSize}).  Check maximumTextureSize.`,\n    );\n  }\n\n  if (!PixelFormat.validate(pixelFormat)) {\n    throw new DeveloperError(\"Invalid options.pixelFormat.\");\n  }\n\n  if (!isCompressed && !PixelDatatype.validate(pixelDatatype)) {\n    throw new DeveloperError(\"Invalid options.pixelDatatype.\");\n  }\n\n  if (\n    pixelFormat === PixelFormat.DEPTH_COMPONENT &&\n    pixelDatatype !== PixelDatatype.UNSIGNED_SHORT &&\n    pixelDatatype !== PixelDatatype.UNSIGNED_INT\n  ) {\n    throw new DeveloperError(\n      \"When options.pixelFormat is DEPTH_COMPONENT, options.pixelDatatype must be UNSIGNED_SHORT or UNSIGNED_INT.\",\n    );\n  }\n\n  if (\n    pixelFormat === PixelFormat.DEPTH_STENCIL &&\n    pixelDatatype !== PixelDatatype.UNSIGNED_INT_24_8\n  ) {\n    throw new DeveloperError(\n      \"When options.pixelFormat is DEPTH_STENCIL, options.pixelDatatype must be UNSIGNED_INT_24_8.\",\n    );\n  }\n\n  if (pixelDatatype === PixelDatatype.FLOAT && !context.floatingPointTexture) {\n    throw new DeveloperError(\n      \"When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension.  Check context.floatingPointTexture.\",\n    );\n  }\n\n  if (\n    pixelDatatype === PixelDatatype.HALF_FLOAT &&\n    !context.halfFloatingPointTexture\n  ) {\n    throw new DeveloperError(\n      \"When options.pixelDatatype is HALF_FLOAT, this WebGL implementation must support the OES_texture_half_float extension. Check context.halfFloatingPointTexture.\",\n    );\n  }\n\n  if (PixelFormat.isDepthFormat(pixelFormat)) {\n    if (defined(source)) {\n      throw new DeveloperError(\n        \"When options.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, source cannot be provided.\",\n      );\n    }\n\n    if (!context.depthTexture) {\n      throw new DeveloperError(\n        \"When options.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, this WebGL implementation must support WEBGL_depth_texture.  Check context.depthTexture.\",\n      );\n    }\n  }\n\n  if (isCompressed) {\n    if (!defined(source) || !defined(source.arrayBufferView)) {\n      throw new DeveloperError(\n        \"When options.pixelFormat is compressed, options.source.arrayBufferView must be defined.\",\n      );\n    }\n\n    if (PixelFormat.isDXTFormat(internalFormat) && !context.s3tc) {\n      throw new DeveloperError(\n        \"When options.pixelFormat is S3TC compressed, this WebGL implementation must support the WEBGL_compressed_texture_s3tc extension. Check context.s3tc.\",\n      );\n    } else if (PixelFormat.isPVRTCFormat(internalFormat) && !context.pvrtc) {\n      throw new DeveloperError(\n        \"When options.pixelFormat is PVRTC compressed, this WebGL implementation must support the WEBGL_compressed_texture_pvrtc extension. Check context.pvrtc.\",\n      );\n    } else if (PixelFormat.isASTCFormat(internalFormat) && !context.astc) {\n      throw new DeveloperError(\n        \"When options.pixelFormat is ASTC compressed, this WebGL implementation must support the WEBGL_compressed_texture_astc extension. Check context.astc.\",\n      );\n    } else if (PixelFormat.isETC2Format(internalFormat) && !context.etc) {\n      throw new DeveloperError(\n        \"When options.pixelFormat is ETC2 compressed, this WebGL implementation must support the WEBGL_compressed_texture_etc extension. Check context.etc.\",\n      );\n    } else if (PixelFormat.isETC1Format(internalFormat) && !context.etc1) {\n      throw new DeveloperError(\n        \"When options.pixelFormat is ETC1 compressed, this WebGL implementation must support the WEBGL_compressed_texture_etc1 extension. Check context.etc1.\",\n      );\n    } else if (PixelFormat.isBC7Format(internalFormat) && !context.bc7) {\n      throw new DeveloperError(\n        \"When options.pixelFormat is BC7 compressed, this WebGL implementation must support the EXT_texture_compression_bptc extension. Check context.bc7.\",\n      );\n    }\n\n    if (\n      PixelFormat.compressedTextureSizeInBytes(\n        internalFormat,\n        width,\n        height,\n      ) !== source.arrayBufferView.byteLength\n    ) {\n      throw new DeveloperError(\n        \"The byte length of the array buffer is invalid for the compressed texture with the given width and height.\",\n      );\n    }\n  }\n  //>>includeEnd('debug');\n\n  const gl = context._gl;\n\n  const sizeInBytes = isCompressed\n    ? PixelFormat.compressedTextureSizeInBytes(pixelFormat, width, height)\n    : PixelFormat.textureSizeInBytes(pixelFormat, pixelDatatype, width, height);\n\n  this._id = options.id ?? createGuid();\n  this._context = context;\n  this._textureFilterAnisotropic = context._textureFilterAnisotropic;\n  this._textureTarget = gl.TEXTURE_2D;\n  this._texture = gl.createTexture();\n  this._internalFormat = internalFormat;\n  this._pixelFormat = pixelFormat;\n  this._pixelDatatype = pixelDatatype;\n  this._width = width;\n  this._height = height;\n  this._dimensions = new Cartesian2(width, height);\n  this._hasMipmap = false;\n  this._sizeInBytes = sizeInBytes;\n  this._preMultiplyAlpha = preMultiplyAlpha;\n  this._flipY = flipY;\n  this._initialized = false;\n  this._sampler = undefined;\n\n  this._sampler = sampler;\n  setupSampler(this, sampler);\n\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(this._textureTarget, this._texture);\n\n  if (defined(source)) {\n    if (skipColorSpaceConversion) {\n      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n    } else {\n      gl.pixelStorei(\n        gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,\n        gl.BROWSER_DEFAULT_WEBGL,\n      );\n    }\n    if (defined(source.arrayBufferView)) {\n      const isCompressed = PixelFormat.isCompressedFormat(internalFormat);\n      if (isCompressed) {\n        loadCompressedBufferSource(this, source);\n      } else {\n        loadBufferSource(this, source);\n      }\n    } else if (defined(source.framebuffer)) {\n      loadFramebufferSource(this, source);\n    } else {\n      loadImageSource(this, source);\n    }\n    this._initialized = true;\n  } else {\n    loadNull(this);\n  }\n\n  gl.bindTexture(this._textureTarget, null);\n}\n\n/**\n * Load compressed texel data from a buffer into a texture.\n *\n * @param {Texture} texture The texture to which texel values will be loaded.\n * @param {object} source The source for texel values to be loaded into the texture.\n *\n * @private\n */\nfunction loadCompressedBufferSource(texture, source) {\n  const context = texture._context;\n  const gl = context._gl;\n  const textureTarget = texture._textureTarget;\n  const internalFormat = texture._internalFormat;\n\n  const { width, height } = texture;\n\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);\n  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n\n  gl.compressedTexImage2D(\n    textureTarget,\n    0,\n    internalFormat,\n    width,\n    height,\n    0,\n    source.arrayBufferView,\n  );\n\n  if (defined(source.mipLevels)) {\n    let mipWidth = width;\n    let mipHeight = height;\n    for (let i = 0; i < source.mipLevels.length; ++i) {\n      mipWidth = nextMipSize(mipWidth);\n      mipHeight = nextMipSize(mipHeight);\n      gl.compressedTexImage2D(\n        textureTarget,\n        i + 1,\n        internalFormat,\n        mipWidth,\n        mipHeight,\n        0,\n        source.mipLevels[i],\n      );\n    }\n  }\n}\n\n/**\n * Load texel data from a buffer into a texture.\n *\n * @param {Texture} texture The texture to which texel values will be loaded.\n * @param {object} source The source for texel values to be loaded into the texture.\n *\n * @private\n */\nfunction loadBufferSource(texture, source) {\n  const context = texture._context;\n  const gl = context._gl;\n  const textureTarget = texture._textureTarget;\n  const internalFormat = texture._internalFormat;\n\n  const { width, height, pixelFormat, pixelDatatype, flipY } = texture;\n\n  const unpackAlignment = PixelFormat.alignmentInBytes(\n    pixelFormat,\n    pixelDatatype,\n    width,\n  );\n\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);\n  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n\n  let { arrayBufferView } = source;\n  if (flipY) {\n    arrayBufferView = PixelFormat.flipY(\n      arrayBufferView,\n      pixelFormat,\n      pixelDatatype,\n      width,\n      height,\n    );\n  }\n  gl.texImage2D(\n    textureTarget,\n    0,\n    internalFormat,\n    width,\n    height,\n    0,\n    pixelFormat,\n    PixelDatatype.toWebGLConstant(pixelDatatype, context),\n    arrayBufferView,\n  );\n\n  if (defined(source.mipLevels)) {\n    let mipWidth = width;\n    let mipHeight = height;\n    for (let i = 0; i < source.mipLevels.length; ++i) {\n      mipWidth = nextMipSize(mipWidth);\n      mipHeight = nextMipSize(mipHeight);\n      gl.texImage2D(\n        textureTarget,\n        i + 1,\n        internalFormat,\n        mipWidth,\n        mipHeight,\n        0,\n        pixelFormat,\n        PixelDatatype.toWebGLConstant(pixelDatatype, context),\n        source.mipLevels[i],\n      );\n    }\n  }\n}\n\n/**\n * Load texel data from a buffer into part of a texture\n *\n * @param {Texture} texture The texture to which texel values will be loaded.\n * @param {TypedArray} arrayBufferView The texel values to be loaded into the texture.\n * @param {number} xOffset The texel x coordinate of the lower left corner of the subregion of the texture to be updated.\n * @param {number} yOffset The texel y coordinate of the lower left corner of the subregion of the texture to be updated.\n * @param {number} width The width of the source data, in pixels.\n * @param {number} width The height of the source data, in pixels.\n *\n * @private\n */\nfunction loadPartialBufferSource(\n  texture,\n  arrayBufferView,\n  xOffset,\n  yOffset,\n  width,\n  height,\n) {\n  const context = texture._context;\n  const gl = context._gl;\n\n  const { pixelFormat, pixelDatatype } = texture;\n\n  const unpackAlignment = PixelFormat.alignmentInBytes(\n    pixelFormat,\n    pixelDatatype,\n    width,\n  );\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);\n  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n\n  if (texture.flipY) {\n    arrayBufferView = PixelFormat.flipY(\n      arrayBufferView,\n      pixelFormat,\n      pixelDatatype,\n      width,\n      height,\n    );\n  }\n  gl.texSubImage2D(\n    texture._textureTarget,\n    0,\n    xOffset,\n    yOffset,\n    width,\n    height,\n    pixelFormat,\n    PixelDatatype.toWebGLConstant(pixelDatatype, context),\n    arrayBufferView,\n  );\n}\n\n/**\n * Load texel data from a framebuffer into a texture.\n *\n * @param {Texture} texture The texture to which texel values will be loaded.\n * @param {object} source The source for texel values to be loaded into the texture.\n *\n * @private\n */\nfunction loadFramebufferSource(texture, source) {\n  const context = texture._context;\n  const gl = context._gl;\n\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);\n  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n\n  if (source.framebuffer !== context.defaultFramebuffer) {\n    source.framebuffer._bind();\n  }\n\n  gl.copyTexImage2D(\n    texture._textureTarget,\n    0,\n    texture._internalFormat,\n    source.xOffset,\n    source.yOffset,\n    texture.width,\n    texture.height,\n    0,\n  );\n\n  if (source.framebuffer !== context.defaultFramebuffer) {\n    source.framebuffer._unBind();\n  }\n}\n\n/**\n * Load texel data from an Image into a texture.\n *\n * @param {Texture} texture The texture to which texel values will be loaded.\n * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|OffscreenCanvas|ImageBitmap} source The source for texel values to be loaded into the texture.\n *\n * @private\n */\nfunction loadImageSource(texture, source) {\n  const context = texture._context;\n  const gl = context._gl;\n\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);\n  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.preMultiplyAlpha);\n  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n\n  gl.texImage2D(\n    texture._textureTarget,\n    0,\n    texture._internalFormat,\n    texture.pixelFormat,\n    PixelDatatype.toWebGLConstant(texture.pixelDatatype, context),\n    source,\n  );\n}\n\n/**\n * Load texel data from an Image into part of a texture\n *\n * @param {Texture} texture The texture to which texel values will be loaded.\n * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} source The source for texel values to be loaded into the texture.\n * @param {number} xOffset The texel x coordinate of the lower left corner of the subregion of the texture to be updated.\n * @param {number} yOffset The texel y coordinate of the lower left corner of the subregion of the texture to be updated.\n *\n * @private\n */\nfunction loadPartialImageSource(texture, source, xOffset, yOffset) {\n  const context = texture._context;\n  const gl = context._gl;\n\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);\n  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.preMultiplyAlpha);\n  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n\n  gl.texSubImage2D(\n    texture._textureTarget,\n    0,\n    xOffset,\n    yOffset,\n    texture.pixelFormat,\n    PixelDatatype.toWebGLConstant(texture.pixelDatatype, context),\n    source,\n  );\n}\n\n/**\n * Compute a dimension of the image for the next mip level.\n *\n * @param {number} currentSize The size of the current mip level.\n * @returns {number} The size of the next mip level.\n *\n * @private\n */\nfunction nextMipSize(currentSize) {\n  const nextSize = Math.floor(currentSize / 2) | 0;\n  return Math.max(nextSize, 1);\n}\n\n/**\n * Allocate a texture in GPU memory, without providing any image data.\n *\n * @param {Texture} texture The texture to be initialized with null values.\n *\n * @private\n */\nfunction loadNull(texture) {\n  const context = texture._context;\n\n  context._gl.texImage2D(\n    texture._textureTarget,\n    0,\n    texture._internalFormat,\n    texture._width,\n    texture._height,\n    0,\n    texture._pixelFormat,\n    PixelDatatype.toWebGLConstant(texture._pixelDatatype, context),\n    null,\n  );\n}\n\n/**\n * This function is identical to using the Texture constructor except that it can be\n * replaced with a mock/spy in tests.\n * @private\n */\nTexture.create = function (options) {\n  return new Texture(options);\n};\n\n/**\n * Creates a texture, and copies a subimage of the framebuffer to it.  When called without arguments,\n * the texture is the same width and height as the framebuffer and contains its contents.\n *\n * @param {object} options Object with the following properties:\n * @param {Context} options.context The context in which the Texture gets created.\n * @param {PixelFormat} [options.pixelFormat=PixelFormat.RGB] The texture's internal pixel format.\n * @param {number} [options.framebufferXOffset=0] An offset in the x direction in the framebuffer where copying begins from.\n * @param {number} [options.framebufferYOffset=0] An offset in the y direction in the framebuffer where copying begins from.\n * @param {number} [options.width=canvas.clientWidth] The width of the texture in texels.\n * @param {number} [options.height=canvas.clientHeight] The height of the texture in texels.\n * @param {Framebuffer} [options.framebuffer=defaultFramebuffer] The framebuffer from which to create the texture.  If this\n *        parameter is not specified, the default framebuffer is used.\n * @returns {Texture} A texture with contents from the framebuffer.\n *\n * @exception {DeveloperError} Invalid pixelFormat.\n * @exception {DeveloperError} pixelFormat cannot be DEPTH_COMPONENT, DEPTH_STENCIL or a compressed format.\n * @exception {DeveloperError} framebufferXOffset must be greater than or equal to zero.\n * @exception {DeveloperError} framebufferYOffset must be greater than or equal to zero.\n * @exception {DeveloperError} framebufferXOffset + width must be less than or equal to canvas.clientWidth.\n * @exception {DeveloperError} framebufferYOffset + height must be less than or equal to canvas.clientHeight.\n *\n *\n * @example\n * // Create a texture with the contents of the framebuffer.\n * const t = Texture.fromFramebuffer({\n *     context : context\n * });\n *\n * @see Sampler\n *\n * @private\n */\nTexture.fromFramebuffer = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  //>>includeEnd('debug');\n\n  const context = options.context;\n  const {\n    pixelFormat = PixelFormat.RGB,\n    framebufferXOffset = 0,\n    framebufferYOffset = 0,\n    width = context.drawingBufferWidth,\n    height = context.drawingBufferHeight,\n    framebuffer,\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!PixelFormat.validate(pixelFormat)) {\n    throw new DeveloperError(\"Invalid pixelFormat.\");\n  }\n  if (\n    PixelFormat.isDepthFormat(pixelFormat) ||\n    PixelFormat.isCompressedFormat(pixelFormat)\n  ) {\n    throw new DeveloperError(\n      \"pixelFormat cannot be DEPTH_COMPONENT, DEPTH_STENCIL or a compressed format.\",\n    );\n  }\n  Check.defined(\"options.context\", context);\n  Check.typeOf.number.greaterThanOrEquals(\n    \"framebufferXOffset\",\n    framebufferXOffset,\n    0,\n  );\n  Check.typeOf.number.greaterThanOrEquals(\n    \"framebufferYOffset\",\n    framebufferYOffset,\n    0,\n  );\n  if (framebufferXOffset + width > context.drawingBufferWidth) {\n    throw new DeveloperError(\n      \"framebufferXOffset + width must be less than or equal to drawingBufferWidth\",\n    );\n  }\n  if (framebufferYOffset + height > context.drawingBufferHeight) {\n    throw new DeveloperError(\n      \"framebufferYOffset + height must be less than or equal to drawingBufferHeight.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const texture = new Texture({\n    context: context,\n    width: width,\n    height: height,\n    pixelFormat: pixelFormat,\n    source: {\n      framebuffer: defined(framebuffer)\n        ? framebuffer\n        : context.defaultFramebuffer,\n      xOffset: framebufferXOffset,\n      yOffset: framebufferYOffset,\n      width: width,\n      height: height,\n    },\n  });\n\n  return texture;\n};\n\nObject.defineProperties(Texture.prototype, {\n  /**\n   * A unique id for the texture\n   * @memberof Texture.prototype\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n  /**\n   * The sampler to use when sampling this texture.\n   * Create a sampler by calling {@link Sampler}.  If this\n   * parameter is not specified, a default sampler is used.  The default sampler clamps texture\n   * coordinates in both directions, uses linear filtering for both magnification and minification,\n   * and uses a maximum anisotropy of 1.0.\n   * @memberof Texture.prototype\n   * @type {Sampler}\n   * @private\n   */\n  sampler: {\n    get: function () {\n      return this._sampler;\n    },\n    set: function (sampler) {\n      setupSampler(this, sampler);\n      this._sampler = sampler;\n    },\n  },\n  pixelFormat: {\n    get: function () {\n      return this._pixelFormat;\n    },\n  },\n  pixelDatatype: {\n    get: function () {\n      return this._pixelDatatype;\n    },\n  },\n  dimensions: {\n    get: function () {\n      return this._dimensions;\n    },\n  },\n  preMultiplyAlpha: {\n    get: function () {\n      return this._preMultiplyAlpha;\n    },\n  },\n  flipY: {\n    get: function () {\n      return this._flipY;\n    },\n  },\n  width: {\n    get: function () {\n      return this._width;\n    },\n  },\n  height: {\n    get: function () {\n      return this._height;\n    },\n  },\n  sizeInBytes: {\n    get: function () {\n      if (this._hasMipmap) {\n        return Math.floor((this._sizeInBytes * 4) / 3);\n      }\n      return this._sizeInBytes;\n    },\n  },\n  _target: {\n    get: function () {\n      return this._textureTarget;\n    },\n  },\n});\n\n/**\n * Set up a sampler for use with a texture\n * @param {Texture} texture The texture to be sampled by this sampler\n * @param {Sampler} sampler Information about how to sample the texture\n * @private\n */\nfunction setupSampler(texture, sampler) {\n  let { minificationFilter, magnificationFilter } = sampler;\n\n  const mipmap = [\n    TextureMinificationFilter.NEAREST_MIPMAP_NEAREST,\n    TextureMinificationFilter.NEAREST_MIPMAP_LINEAR,\n    TextureMinificationFilter.LINEAR_MIPMAP_NEAREST,\n    TextureMinificationFilter.LINEAR_MIPMAP_LINEAR,\n  ].includes(minificationFilter);\n\n  const context = texture._context;\n  const pixelFormat = texture._pixelFormat;\n  const pixelDatatype = texture._pixelDatatype;\n\n  // float textures only support nearest filtering unless the linear extensions are supported\n  if (\n    (pixelDatatype === PixelDatatype.FLOAT && !context.textureFloatLinear) ||\n    (pixelDatatype === PixelDatatype.HALF_FLOAT &&\n      !context.textureHalfFloatLinear)\n  ) {\n    // override the sampler's settings\n    minificationFilter = mipmap\n      ? TextureMinificationFilter.NEAREST_MIPMAP_NEAREST\n      : TextureMinificationFilter.NEAREST;\n    magnificationFilter = TextureMagnificationFilter.NEAREST;\n  }\n\n  // WebGL 2 depth texture only support nearest filtering. See section 3.8.13 OpenGL ES 3 spec\n  if (context.webgl2) {\n    if (PixelFormat.isDepthFormat(pixelFormat)) {\n      minificationFilter = TextureMinificationFilter.NEAREST;\n      magnificationFilter = TextureMagnificationFilter.NEAREST;\n    }\n  }\n\n  const gl = context._gl;\n  const target = texture._textureTarget;\n\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, texture._texture);\n  gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, minificationFilter);\n  gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, magnificationFilter);\n  gl.texParameteri(target, gl.TEXTURE_WRAP_S, sampler.wrapS);\n  gl.texParameteri(target, gl.TEXTURE_WRAP_T, sampler.wrapT);\n  if (defined(texture._textureFilterAnisotropic)) {\n    gl.texParameteri(\n      target,\n      texture._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,\n      sampler.maximumAnisotropy,\n    );\n  }\n  gl.bindTexture(target, null);\n}\n\n/**\n * Copy new image data into this texture, from a source {@link ImageData}, {@link HTMLImageElement}, {@link HTMLCanvasElement}, or {@link HTMLVideoElement}.\n * or an object with width, height, and arrayBufferView properties.\n * @param {object} options Object with the following properties:\n * @param {object} options.source The source {@link ImageData}, {@link HTMLImageElement}, {@link HTMLCanvasElement}, {@link HTMLVideoElement},\n *                        {@link OffscreenCanvas}, or {@link ImageBitmap},\n *                        or an object with width, height, and arrayBufferView properties.\n * @param {number} [options.xOffset=0] The offset in the x direction within the texture to copy into.\n * @param {number} [options.yOffset=0] The offset in the y direction within the texture to copy into.\n * @param {boolean} [options.skipColorSpaceConversion=false] If true, any custom gamma or color profiles in the texture will be ignored.\n *\n * @exception {DeveloperError} Cannot call copyFrom when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.\n * @exception {DeveloperError} Cannot call copyFrom with a compressed texture pixel format.\n * @exception {DeveloperError} xOffset must be greater than or equal to zero.\n * @exception {DeveloperError} yOffset must be greater than or equal to zero.\n * @exception {DeveloperError} xOffset + source.width must be less than or equal to width.\n * @exception {DeveloperError} yOffset + source.height must be less than or equal to height.\n * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.\n * @private\n * @example\n * texture.copyFrom({\n *  source: {\n *   width : 1,\n *   height : 1,\n *   arrayBufferView : new Uint8Array([255, 0, 0, 255])\n *  }\n * });\n */\nTexture.prototype.copyFrom = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options\", options);\n  //>>includeEnd('debug');\n\n  const {\n    xOffset = 0,\n    yOffset = 0,\n    source,\n    skipColorSpaceConversion = false,\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.source\", source);\n  if (PixelFormat.isDepthFormat(this._pixelFormat)) {\n    throw new DeveloperError(\n      \"Cannot call copyFrom when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.\",\n    );\n  }\n  if (PixelFormat.isCompressedFormat(this._pixelFormat)) {\n    throw new DeveloperError(\n      \"Cannot call copyFrom with a compressed texture pixel format.\",\n    );\n  }\n  Check.typeOf.number.greaterThanOrEquals(\"xOffset\", xOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"yOffset\", yOffset, 0);\n  Check.typeOf.number.lessThanOrEquals(\n    \"xOffset + options.source.width\",\n    xOffset + source.width,\n    this._width,\n  );\n  Check.typeOf.number.lessThanOrEquals(\n    \"yOffset + options.source.height\",\n    yOffset + source.height,\n    this._height,\n  );\n  //>>includeEnd('debug');\n\n  const context = this._context;\n  const gl = context._gl;\n  const target = this._textureTarget;\n\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, this._texture);\n\n  let { width, height } = source;\n\n  // Make sure we are using the element's intrinsic width and height where available\n  if (defined(source.videoWidth) && defined(source.videoHeight)) {\n    width = source.videoWidth;\n    height = source.videoHeight;\n  } else if (defined(source.naturalWidth) && defined(source.naturalHeight)) {\n    width = source.naturalWidth;\n    height = source.naturalHeight;\n  }\n\n  if (skipColorSpaceConversion) {\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n  } else {\n    gl.pixelStorei(\n      gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,\n      gl.BROWSER_DEFAULT_WEBGL,\n    );\n  }\n\n  let uploaded = false;\n  if (!this._initialized) {\n    if (\n      xOffset === 0 &&\n      yOffset === 0 &&\n      width === this._width &&\n      height === this._height\n    ) {\n      // initialize the entire texture\n      if (defined(source.arrayBufferView)) {\n        loadBufferSource(this, source);\n      } else {\n        loadImageSource(this, source);\n      }\n      uploaded = true;\n    } else {\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n      loadNull(this);\n    }\n    this._initialized = true;\n  }\n\n  if (!uploaded) {\n    if (defined(source.arrayBufferView)) {\n      loadPartialBufferSource(\n        this,\n        source.arrayBufferView,\n        xOffset,\n        yOffset,\n        width,\n        height,\n      );\n    } else {\n      loadPartialImageSource(this, source, xOffset, yOffset);\n    }\n  }\n\n  gl.bindTexture(target, null);\n};\n\n/**\n * @param {number} [xOffset=0] The offset in the x direction within the texture to copy into.\n * @param {number} [yOffset=0] The offset in the y direction within the texture to copy into.\n * @param {number} [framebufferXOffset=0] optional\n * @param {number} [framebufferYOffset=0] optional\n * @param {number} [width=width] optional\n * @param {number} [height=height] optional\n * @private\n * @exception {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.\n * @exception {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.\n * @exception {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.\n * @exception {DeveloperError} Cannot call copyFrom with a compressed texture pixel format.\n * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.\n * @exception {DeveloperError} xOffset must be greater than or equal to zero.\n * @exception {DeveloperError} yOffset must be greater than or equal to zero.\n * @exception {DeveloperError} framebufferXOffset must be greater than or equal to zero.\n * @exception {DeveloperError} framebufferYOffset must be greater than or equal to zero.\n * @exception {DeveloperError} xOffset + width must be less than or equal to width.\n * @exception {DeveloperError} yOffset + height must be less than or equal to height.\n */\nTexture.prototype.copyFromFramebuffer = function (\n  xOffset,\n  yOffset,\n  framebufferXOffset,\n  framebufferYOffset,\n  width,\n  height,\n) {\n  xOffset = xOffset ?? 0;\n  yOffset = yOffset ?? 0;\n  framebufferXOffset = framebufferXOffset ?? 0;\n  framebufferYOffset = framebufferYOffset ?? 0;\n  width = width ?? this._width;\n  height = height ?? this._height;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (PixelFormat.isDepthFormat(this._pixelFormat)) {\n    throw new DeveloperError(\n      \"Cannot call copyFromFramebuffer when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.\",\n    );\n  }\n  if (this._pixelDatatype === PixelDatatype.FLOAT) {\n    throw new DeveloperError(\n      \"Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.\",\n    );\n  }\n  if (this._pixelDatatype === PixelDatatype.HALF_FLOAT) {\n    throw new DeveloperError(\n      \"Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.\",\n    );\n  }\n  if (PixelFormat.isCompressedFormat(this._pixelFormat)) {\n    throw new DeveloperError(\n      \"Cannot call copyFrom with a compressed texture pixel format.\",\n    );\n  }\n\n  Check.typeOf.number.greaterThanOrEquals(\"xOffset\", xOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"yOffset\", yOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\n    \"framebufferXOffset\",\n    framebufferXOffset,\n    0,\n  );\n  Check.typeOf.number.greaterThanOrEquals(\n    \"framebufferYOffset\",\n    framebufferYOffset,\n    0,\n  );\n  Check.typeOf.number.lessThanOrEquals(\n    \"xOffset + width\",\n    xOffset + width,\n    this._width,\n  );\n  Check.typeOf.number.lessThanOrEquals(\n    \"yOffset + height\",\n    yOffset + height,\n    this._height,\n  );\n  //>>includeEnd('debug');\n\n  const gl = this._context._gl;\n  const target = this._textureTarget;\n\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, this._texture);\n  gl.copyTexSubImage2D(\n    target,\n    0,\n    xOffset,\n    yOffset,\n    framebufferXOffset,\n    framebufferYOffset,\n    width,\n    height,\n  );\n  gl.bindTexture(target, null);\n  this._initialized = true;\n};\n\n/**\n * @param {MipmapHint} [hint=MipmapHint.DONT_CARE] optional.\n * @private\n * @exception {DeveloperError} Cannot call generateMipmap when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.\n * @exception {DeveloperError} Cannot call generateMipmap when the texture pixel format is a compressed format.\n * @exception {DeveloperError} hint is invalid.\n * @exception {DeveloperError} This texture's width must be a power of two to call generateMipmap() in a WebGL1 context.\n * @exception {DeveloperError} This texture's height must be a power of two to call generateMipmap() in a WebGL1 context.\n * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.\n */\nTexture.prototype.generateMipmap = function (hint) {\n  hint = hint ?? MipmapHint.DONT_CARE;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (PixelFormat.isDepthFormat(this._pixelFormat)) {\n    throw new DeveloperError(\n      \"Cannot call generateMipmap when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.\",\n    );\n  }\n  if (PixelFormat.isCompressedFormat(this._pixelFormat)) {\n    throw new DeveloperError(\n      \"Cannot call generateMipmap with a compressed pixel format.\",\n    );\n  }\n  if (!this._context.webgl2) {\n    if (this._width > 1 && !CesiumMath.isPowerOfTwo(this._width)) {\n      throw new DeveloperError(\n        \"width must be a power of two to call generateMipmap() in a WebGL1 context.\",\n      );\n    }\n    if (this._height > 1 && !CesiumMath.isPowerOfTwo(this._height)) {\n      throw new DeveloperError(\n        \"height must be a power of two to call generateMipmap() in a WebGL1 context.\",\n      );\n    }\n  }\n  if (!MipmapHint.validate(hint)) {\n    throw new DeveloperError(\"hint is invalid.\");\n  }\n  //>>includeEnd('debug');\n\n  this._hasMipmap = true;\n\n  const gl = this._context._gl;\n  const target = this._textureTarget;\n\n  gl.hint(gl.GENERATE_MIPMAP_HINT, hint);\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, this._texture);\n  gl.generateMipmap(target);\n  gl.bindTexture(target, null);\n};\n\nTexture.prototype.isDestroyed = function () {\n  return false;\n};\n\nTexture.prototype.destroy = function () {\n  this._context._gl.deleteTexture(this._texture);\n  return destroyObject(this);\n};\nexport default Texture;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}