{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport BufferUsage from \"./BufferUsage.js\";\n\n/**\n * @private\n */\nfunction Buffer(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  if (!defined(options.typedArray) && !defined(options.sizeInBytes)) {\n    throw new DeveloperError(\"Either options.sizeInBytes or options.typedArray is required.\");\n  }\n  if (defined(options.typedArray) && defined(options.sizeInBytes)) {\n    throw new DeveloperError(\"Cannot pass in both options.sizeInBytes and options.typedArray.\");\n  }\n  if (defined(options.typedArray)) {\n    Check.typeOf.object(\"options.typedArray\", options.typedArray);\n    Check.typeOf.number(\"options.typedArray.byteLength\", options.typedArray.byteLength);\n  }\n  if (!BufferUsage.validate(options.usage)) {\n    throw new DeveloperError(\"usage is invalid.\");\n  }\n  //>>includeEnd('debug');\n\n  const gl = options.context._gl;\n  const bufferTarget = options.bufferTarget;\n  const typedArray = options.typedArray;\n  let sizeInBytes = options.sizeInBytes;\n  const usage = options.usage;\n  const hasArray = defined(typedArray);\n  if (hasArray) {\n    sizeInBytes = typedArray.byteLength;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThan(\"sizeInBytes\", sizeInBytes, 0);\n  //>>includeEnd('debug');\n\n  const buffer = gl.createBuffer();\n  gl.bindBuffer(bufferTarget, buffer);\n  gl.bufferData(bufferTarget, hasArray ? typedArray : sizeInBytes, usage);\n  gl.bindBuffer(bufferTarget, null);\n  this._id = createGuid();\n  this._gl = gl;\n  this._webgl2 = options.context._webgl2;\n  this._bufferTarget = bufferTarget;\n  this._sizeInBytes = sizeInBytes;\n  this._usage = usage;\n  this._buffer = buffer;\n  this.vertexArrayDestroyable = true;\n}\n\n/**\n * Creates a vertex buffer, which contains untyped vertex data in GPU-controlled memory.\n * <br /><br />\n * A vertex array defines the actual makeup of a vertex, e.g., positions, normals, texture coordinates,\n * etc., by interpreting the raw data in one or more vertex buffers.\n *\n * @param {object} options An object containing the following properties:\n * @param {Context} options.context The context in which to create the buffer\n * @param {ArrayBufferView} [options.typedArray] A typed array containing the data to copy to the buffer.\n * @param {number} [options.sizeInBytes] A <code>Number</code> defining the size of the buffer in bytes. Required if options.typedArray is not given.\n * @param {BufferUsage} options.usage Specifies the expected usage pattern of the buffer. On some GL implementations, this can significantly affect performance. See {@link BufferUsage}.\n * @returns {VertexBuffer} The vertex buffer, ready to be attached to a vertex array.\n *\n * @exception {DeveloperError} Must specify either <options.typedArray> or <options.sizeInBytes>, but not both.\n * @exception {DeveloperError} The buffer size must be greater than zero.\n * @exception {DeveloperError} Invalid <code>usage</code>.\n *\n *\n * @example\n * // Example 1. Create a dynamic vertex buffer 16 bytes in size.\n * const buffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 16,\n *     usage : BufferUsage.DYNAMIC_DRAW\n * });\n *\n * @example\n * // Example 2. Create a dynamic vertex buffer from three floating-point values.\n * // The data copied to the vertex buffer is considered raw bytes until it is\n * // interpreted as vertices using a vertex array.\n * const positionBuffer = buffer.createVertexBuffer({\n *     context : context,\n *     typedArray : new Float32Array([0, 0, 0]),\n *     usage : BufferUsage.STATIC_DRAW\n * });\n *\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGenBuffer.xml|glGenBuffer}\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBindBuffer.xml|glBindBuffer} with <code>ARRAY_BUFFER</code>\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBufferData.xml|glBufferData} with <code>ARRAY_BUFFER</code>\n */\nBuffer.createVertexBuffer = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  //>>includeEnd('debug');\n\n  return new Buffer({\n    context: options.context,\n    bufferTarget: WebGLConstants.ARRAY_BUFFER,\n    typedArray: options.typedArray,\n    sizeInBytes: options.sizeInBytes,\n    usage: options.usage\n  });\n};\n\n/**\n * Creates an index buffer, which contains typed indices in GPU-controlled memory.\n * <br /><br />\n * An index buffer can be attached to a vertex array to select vertices for rendering.\n * <code>Context.draw</code> can render using the entire index buffer or a subset\n * of the index buffer defined by an offset and count.\n *\n * @param {object} options An object containing the following properties:\n * @param {Context} options.context The context in which to create the buffer\n * @param {ArrayBufferView} [options.typedArray] A typed array containing the data to copy to the buffer.\n * @param {number} [options.sizeInBytes] A <code>Number</code> defining the size of the buffer in bytes. Required if options.typedArray is not given.\n * @param {BufferUsage} options.usage Specifies the expected usage pattern of the buffer. On some GL implementations, this can significantly affect performance. See {@link BufferUsage}.\n * @param {IndexDatatype} options.indexDatatype The datatype of indices in the buffer.\n * @returns {IndexBuffer} The index buffer, ready to be attached to a vertex array.\n *\n * @exception {DeveloperError} Must specify either <options.typedArray> or <options.sizeInBytes>, but not both.\n * @exception {DeveloperError} IndexDatatype.UNSIGNED_INT requires OES_element_index_uint, which is not supported on this system. Check context.elementIndexUint.\n * @exception {DeveloperError} The size in bytes must be greater than zero.\n * @exception {DeveloperError} Invalid <code>usage</code>.\n * @exception {DeveloperError} Invalid <code>indexDatatype</code>.\n *\n *\n * @example\n * // Example 1. Create a stream index buffer of unsigned shorts that is\n * // 16 bytes in size.\n * const buffer = Buffer.createIndexBuffer({\n *     context : context,\n *     sizeInBytes : 16,\n *     usage : BufferUsage.STREAM_DRAW,\n *     indexDatatype : IndexDatatype.UNSIGNED_SHORT\n * });\n *\n * @example\n * // Example 2. Create a static index buffer containing three unsigned shorts.\n * const buffer = Buffer.createIndexBuffer({\n *     context : context,\n *     typedArray : new Uint16Array([0, 1, 2]),\n *     usage : BufferUsage.STATIC_DRAW,\n *     indexDatatype : IndexDatatype.UNSIGNED_SHORT\n * });\n *\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGenBuffer.xml|glGenBuffer}\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBindBuffer.xml|glBindBuffer} with <code>ELEMENT_ARRAY_BUFFER</code>\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBufferData.xml|glBufferData} with <code>ELEMENT_ARRAY_BUFFER</code>\n */\nBuffer.createIndexBuffer = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  if (!IndexDatatype.validate(options.indexDatatype)) {\n    throw new DeveloperError(\"Invalid indexDatatype.\");\n  }\n  if (options.indexDatatype === IndexDatatype.UNSIGNED_INT && !options.context.elementIndexUint) {\n    throw new DeveloperError(\"IndexDatatype.UNSIGNED_INT requires OES_element_index_uint, which is not supported on this system.  Check context.elementIndexUint.\");\n  }\n  //>>includeEnd('debug');\n\n  const context = options.context;\n  const indexDatatype = options.indexDatatype;\n  const bytesPerIndex = IndexDatatype.getSizeInBytes(indexDatatype);\n  const buffer = new Buffer({\n    context: context,\n    bufferTarget: WebGLConstants.ELEMENT_ARRAY_BUFFER,\n    typedArray: options.typedArray,\n    sizeInBytes: options.sizeInBytes,\n    usage: options.usage\n  });\n  const numberOfIndices = buffer.sizeInBytes / bytesPerIndex;\n  Object.defineProperties(buffer, {\n    indexDatatype: {\n      get: function () {\n        return indexDatatype;\n      }\n    },\n    bytesPerIndex: {\n      get: function () {\n        return bytesPerIndex;\n      }\n    },\n    numberOfIndices: {\n      get: function () {\n        return numberOfIndices;\n      }\n    }\n  });\n  return buffer;\n};\nObject.defineProperties(Buffer.prototype, {\n  sizeInBytes: {\n    get: function () {\n      return this._sizeInBytes;\n    }\n  },\n  usage: {\n    get: function () {\n      return this._usage;\n    }\n  }\n});\nBuffer.prototype._getBuffer = function () {\n  return this._buffer;\n};\nBuffer.prototype.copyFromArrayView = function (arrayView, offsetInBytes) {\n  offsetInBytes = offsetInBytes ?? 0;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"arrayView\", arrayView);\n  Check.typeOf.number.lessThanOrEquals(\"offsetInBytes + arrayView.byteLength\", offsetInBytes + arrayView.byteLength, this._sizeInBytes);\n  //>>includeEnd('debug');\n\n  const gl = this._gl;\n  const target = this._bufferTarget;\n  gl.bindBuffer(target, this._buffer);\n  gl.bufferSubData(target, offsetInBytes, arrayView);\n  gl.bindBuffer(target, null);\n};\nBuffer.prototype.copyFromBuffer = function (readBuffer, readOffset, writeOffset, sizeInBytes) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._webgl2) {\n    throw new DeveloperError(\"A WebGL 2 context is required.\");\n  }\n  if (!defined(readBuffer)) {\n    throw new DeveloperError(\"readBuffer must be defined.\");\n  }\n  if (!defined(sizeInBytes) || sizeInBytes <= 0) {\n    throw new DeveloperError(\"sizeInBytes must be defined and be greater than zero.\");\n  }\n  if (!defined(readOffset) || readOffset < 0 || readOffset + sizeInBytes > readBuffer._sizeInBytes) {\n    throw new DeveloperError(\"readOffset must be greater than or equal to zero and readOffset + sizeInBytes must be less than of equal to readBuffer.sizeInBytes.\");\n  }\n  if (!defined(writeOffset) || writeOffset < 0 || writeOffset + sizeInBytes > this._sizeInBytes) {\n    throw new DeveloperError(\"writeOffset must be greater than or equal to zero and writeOffset + sizeInBytes must be less than of equal to this.sizeInBytes.\");\n  }\n  if (this._buffer === readBuffer._buffer && (writeOffset >= readOffset && writeOffset < readOffset + sizeInBytes || readOffset > writeOffset && readOffset < writeOffset + sizeInBytes)) {\n    throw new DeveloperError(\"When readBuffer is equal to this, the ranges [readOffset + sizeInBytes) and [writeOffset, writeOffset + sizeInBytes) must not overlap.\");\n  }\n  if (this._bufferTarget === WebGLConstants.ELEMENT_ARRAY_BUFFER && readBuffer._bufferTarget !== WebGLConstants.ELEMENT_ARRAY_BUFFER || this._bufferTarget !== WebGLConstants.ELEMENT_ARRAY_BUFFER && readBuffer._bufferTarget === WebGLConstants.ELEMENT_ARRAY_BUFFER) {\n    throw new DeveloperError(\"Can not copy an index buffer into another buffer type.\");\n  }\n  //>>includeEnd('debug');\n\n  const readTarget = WebGLConstants.COPY_READ_BUFFER;\n  const writeTarget = WebGLConstants.COPY_WRITE_BUFFER;\n  const gl = this._gl;\n  gl.bindBuffer(writeTarget, this._buffer);\n  gl.bindBuffer(readTarget, readBuffer._buffer);\n  gl.copyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, sizeInBytes);\n  gl.bindBuffer(writeTarget, null);\n  gl.bindBuffer(readTarget, null);\n};\nBuffer.prototype.getBufferData = function (arrayView, sourceOffset, destinationOffset, length) {\n  sourceOffset = sourceOffset ?? 0;\n  destinationOffset = destinationOffset ?? 0;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._webgl2) {\n    throw new DeveloperError(\"A WebGL 2 context is required.\");\n  }\n  if (!defined(arrayView)) {\n    throw new DeveloperError(\"arrayView is required.\");\n  }\n  let copyLength;\n  let elementSize;\n  let arrayLength = arrayView.byteLength;\n  if (!defined(length)) {\n    if (defined(arrayLength)) {\n      copyLength = arrayLength - destinationOffset;\n      elementSize = 1;\n    } else {\n      arrayLength = arrayView.length;\n      copyLength = arrayLength - destinationOffset;\n      elementSize = arrayView.BYTES_PER_ELEMENT;\n    }\n  } else {\n    copyLength = length;\n    if (defined(arrayLength)) {\n      elementSize = 1;\n    } else {\n      arrayLength = arrayView.length;\n      elementSize = arrayView.BYTES_PER_ELEMENT;\n    }\n  }\n  if (destinationOffset < 0 || destinationOffset > arrayLength) {\n    throw new DeveloperError(\"destinationOffset must be greater than zero and less than the arrayView length.\");\n  }\n  if (destinationOffset + copyLength > arrayLength) {\n    throw new DeveloperError(\"destinationOffset + length must be less than or equal to the arrayViewLength.\");\n  }\n  if (sourceOffset < 0 || sourceOffset > this._sizeInBytes) {\n    throw new DeveloperError(\"sourceOffset must be greater than zero and less than the buffers size.\");\n  }\n  if (sourceOffset + copyLength * elementSize > this._sizeInBytes) {\n    throw new DeveloperError(\"sourceOffset + length must be less than the buffers size.\");\n  }\n  //>>includeEnd('debug');\n\n  const gl = this._gl;\n  const target = WebGLConstants.COPY_READ_BUFFER;\n  gl.bindBuffer(target, this._buffer);\n  gl.getBufferSubData(target, sourceOffset, arrayView, destinationOffset, length);\n  gl.bindBuffer(target, null);\n};\nBuffer.prototype.isDestroyed = function () {\n  return false;\n};\nBuffer.prototype.destroy = function () {\n  this._gl.deleteBuffer(this._buffer);\n  return destroyObject(this);\n};\nexport default Buffer;","map":{"version":3,"names":["Check","createGuid","Frozen","defined","destroyObject","DeveloperError","IndexDatatype","WebGLConstants","BufferUsage","Buffer","options","EMPTY_OBJECT","context","typedArray","sizeInBytes","typeOf","object","number","byteLength","validate","usage","gl","_gl","bufferTarget","hasArray","greaterThan","buffer","createBuffer","bindBuffer","bufferData","_id","_webgl2","_bufferTarget","_sizeInBytes","_usage","_buffer","vertexArrayDestroyable","createVertexBuffer","ARRAY_BUFFER","createIndexBuffer","indexDatatype","UNSIGNED_INT","elementIndexUint","bytesPerIndex","getSizeInBytes","ELEMENT_ARRAY_BUFFER","numberOfIndices","Object","defineProperties","get","prototype","_getBuffer","copyFromArrayView","arrayView","offsetInBytes","lessThanOrEquals","target","bufferSubData","copyFromBuffer","readBuffer","readOffset","writeOffset","readTarget","COPY_READ_BUFFER","writeTarget","COPY_WRITE_BUFFER","copyBufferSubData","getBufferData","sourceOffset","destinationOffset","length","copyLength","elementSize","arrayLength","BYTES_PER_ELEMENT","getBufferSubData","isDestroyed","destroy","deleteBuffer"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Renderer/Buffer.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport BufferUsage from \"./BufferUsage.js\";\n\n/**\n * @private\n */\nfunction Buffer(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n\n  if (!defined(options.typedArray) && !defined(options.sizeInBytes)) {\n    throw new DeveloperError(\n      \"Either options.sizeInBytes or options.typedArray is required.\",\n    );\n  }\n\n  if (defined(options.typedArray) && defined(options.sizeInBytes)) {\n    throw new DeveloperError(\n      \"Cannot pass in both options.sizeInBytes and options.typedArray.\",\n    );\n  }\n\n  if (defined(options.typedArray)) {\n    Check.typeOf.object(\"options.typedArray\", options.typedArray);\n    Check.typeOf.number(\n      \"options.typedArray.byteLength\",\n      options.typedArray.byteLength,\n    );\n  }\n\n  if (!BufferUsage.validate(options.usage)) {\n    throw new DeveloperError(\"usage is invalid.\");\n  }\n  //>>includeEnd('debug');\n\n  const gl = options.context._gl;\n  const bufferTarget = options.bufferTarget;\n  const typedArray = options.typedArray;\n  let sizeInBytes = options.sizeInBytes;\n  const usage = options.usage;\n  const hasArray = defined(typedArray);\n\n  if (hasArray) {\n    sizeInBytes = typedArray.byteLength;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThan(\"sizeInBytes\", sizeInBytes, 0);\n  //>>includeEnd('debug');\n\n  const buffer = gl.createBuffer();\n  gl.bindBuffer(bufferTarget, buffer);\n  gl.bufferData(bufferTarget, hasArray ? typedArray : sizeInBytes, usage);\n  gl.bindBuffer(bufferTarget, null);\n\n  this._id = createGuid();\n  this._gl = gl;\n  this._webgl2 = options.context._webgl2;\n  this._bufferTarget = bufferTarget;\n  this._sizeInBytes = sizeInBytes;\n  this._usage = usage;\n  this._buffer = buffer;\n  this.vertexArrayDestroyable = true;\n}\n\n/**\n * Creates a vertex buffer, which contains untyped vertex data in GPU-controlled memory.\n * <br /><br />\n * A vertex array defines the actual makeup of a vertex, e.g., positions, normals, texture coordinates,\n * etc., by interpreting the raw data in one or more vertex buffers.\n *\n * @param {object} options An object containing the following properties:\n * @param {Context} options.context The context in which to create the buffer\n * @param {ArrayBufferView} [options.typedArray] A typed array containing the data to copy to the buffer.\n * @param {number} [options.sizeInBytes] A <code>Number</code> defining the size of the buffer in bytes. Required if options.typedArray is not given.\n * @param {BufferUsage} options.usage Specifies the expected usage pattern of the buffer. On some GL implementations, this can significantly affect performance. See {@link BufferUsage}.\n * @returns {VertexBuffer} The vertex buffer, ready to be attached to a vertex array.\n *\n * @exception {DeveloperError} Must specify either <options.typedArray> or <options.sizeInBytes>, but not both.\n * @exception {DeveloperError} The buffer size must be greater than zero.\n * @exception {DeveloperError} Invalid <code>usage</code>.\n *\n *\n * @example\n * // Example 1. Create a dynamic vertex buffer 16 bytes in size.\n * const buffer = Buffer.createVertexBuffer({\n *     context : context,\n *     sizeInBytes : 16,\n *     usage : BufferUsage.DYNAMIC_DRAW\n * });\n *\n * @example\n * // Example 2. Create a dynamic vertex buffer from three floating-point values.\n * // The data copied to the vertex buffer is considered raw bytes until it is\n * // interpreted as vertices using a vertex array.\n * const positionBuffer = buffer.createVertexBuffer({\n *     context : context,\n *     typedArray : new Float32Array([0, 0, 0]),\n *     usage : BufferUsage.STATIC_DRAW\n * });\n *\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGenBuffer.xml|glGenBuffer}\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBindBuffer.xml|glBindBuffer} with <code>ARRAY_BUFFER</code>\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBufferData.xml|glBufferData} with <code>ARRAY_BUFFER</code>\n */\nBuffer.createVertexBuffer = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  //>>includeEnd('debug');\n\n  return new Buffer({\n    context: options.context,\n    bufferTarget: WebGLConstants.ARRAY_BUFFER,\n    typedArray: options.typedArray,\n    sizeInBytes: options.sizeInBytes,\n    usage: options.usage,\n  });\n};\n\n/**\n * Creates an index buffer, which contains typed indices in GPU-controlled memory.\n * <br /><br />\n * An index buffer can be attached to a vertex array to select vertices for rendering.\n * <code>Context.draw</code> can render using the entire index buffer or a subset\n * of the index buffer defined by an offset and count.\n *\n * @param {object} options An object containing the following properties:\n * @param {Context} options.context The context in which to create the buffer\n * @param {ArrayBufferView} [options.typedArray] A typed array containing the data to copy to the buffer.\n * @param {number} [options.sizeInBytes] A <code>Number</code> defining the size of the buffer in bytes. Required if options.typedArray is not given.\n * @param {BufferUsage} options.usage Specifies the expected usage pattern of the buffer. On some GL implementations, this can significantly affect performance. See {@link BufferUsage}.\n * @param {IndexDatatype} options.indexDatatype The datatype of indices in the buffer.\n * @returns {IndexBuffer} The index buffer, ready to be attached to a vertex array.\n *\n * @exception {DeveloperError} Must specify either <options.typedArray> or <options.sizeInBytes>, but not both.\n * @exception {DeveloperError} IndexDatatype.UNSIGNED_INT requires OES_element_index_uint, which is not supported on this system. Check context.elementIndexUint.\n * @exception {DeveloperError} The size in bytes must be greater than zero.\n * @exception {DeveloperError} Invalid <code>usage</code>.\n * @exception {DeveloperError} Invalid <code>indexDatatype</code>.\n *\n *\n * @example\n * // Example 1. Create a stream index buffer of unsigned shorts that is\n * // 16 bytes in size.\n * const buffer = Buffer.createIndexBuffer({\n *     context : context,\n *     sizeInBytes : 16,\n *     usage : BufferUsage.STREAM_DRAW,\n *     indexDatatype : IndexDatatype.UNSIGNED_SHORT\n * });\n *\n * @example\n * // Example 2. Create a static index buffer containing three unsigned shorts.\n * const buffer = Buffer.createIndexBuffer({\n *     context : context,\n *     typedArray : new Uint16Array([0, 1, 2]),\n *     usage : BufferUsage.STATIC_DRAW,\n *     indexDatatype : IndexDatatype.UNSIGNED_SHORT\n * });\n *\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGenBuffer.xml|glGenBuffer}\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBindBuffer.xml|glBindBuffer} with <code>ELEMENT_ARRAY_BUFFER</code>\n * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glBufferData.xml|glBufferData} with <code>ELEMENT_ARRAY_BUFFER</code>\n */\nBuffer.createIndexBuffer = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n\n  if (!IndexDatatype.validate(options.indexDatatype)) {\n    throw new DeveloperError(\"Invalid indexDatatype.\");\n  }\n\n  if (\n    options.indexDatatype === IndexDatatype.UNSIGNED_INT &&\n    !options.context.elementIndexUint\n  ) {\n    throw new DeveloperError(\n      \"IndexDatatype.UNSIGNED_INT requires OES_element_index_uint, which is not supported on this system.  Check context.elementIndexUint.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const context = options.context;\n  const indexDatatype = options.indexDatatype;\n\n  const bytesPerIndex = IndexDatatype.getSizeInBytes(indexDatatype);\n  const buffer = new Buffer({\n    context: context,\n    bufferTarget: WebGLConstants.ELEMENT_ARRAY_BUFFER,\n    typedArray: options.typedArray,\n    sizeInBytes: options.sizeInBytes,\n    usage: options.usage,\n  });\n\n  const numberOfIndices = buffer.sizeInBytes / bytesPerIndex;\n\n  Object.defineProperties(buffer, {\n    indexDatatype: {\n      get: function () {\n        return indexDatatype;\n      },\n    },\n    bytesPerIndex: {\n      get: function () {\n        return bytesPerIndex;\n      },\n    },\n    numberOfIndices: {\n      get: function () {\n        return numberOfIndices;\n      },\n    },\n  });\n\n  return buffer;\n};\n\nObject.defineProperties(Buffer.prototype, {\n  sizeInBytes: {\n    get: function () {\n      return this._sizeInBytes;\n    },\n  },\n\n  usage: {\n    get: function () {\n      return this._usage;\n    },\n  },\n});\n\nBuffer.prototype._getBuffer = function () {\n  return this._buffer;\n};\n\nBuffer.prototype.copyFromArrayView = function (arrayView, offsetInBytes) {\n  offsetInBytes = offsetInBytes ?? 0;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"arrayView\", arrayView);\n  Check.typeOf.number.lessThanOrEquals(\n    \"offsetInBytes + arrayView.byteLength\",\n    offsetInBytes + arrayView.byteLength,\n    this._sizeInBytes,\n  );\n  //>>includeEnd('debug');\n\n  const gl = this._gl;\n  const target = this._bufferTarget;\n  gl.bindBuffer(target, this._buffer);\n  gl.bufferSubData(target, offsetInBytes, arrayView);\n  gl.bindBuffer(target, null);\n};\n\nBuffer.prototype.copyFromBuffer = function (\n  readBuffer,\n  readOffset,\n  writeOffset,\n  sizeInBytes,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._webgl2) {\n    throw new DeveloperError(\"A WebGL 2 context is required.\");\n  }\n  if (!defined(readBuffer)) {\n    throw new DeveloperError(\"readBuffer must be defined.\");\n  }\n  if (!defined(sizeInBytes) || sizeInBytes <= 0) {\n    throw new DeveloperError(\n      \"sizeInBytes must be defined and be greater than zero.\",\n    );\n  }\n  if (\n    !defined(readOffset) ||\n    readOffset < 0 ||\n    readOffset + sizeInBytes > readBuffer._sizeInBytes\n  ) {\n    throw new DeveloperError(\n      \"readOffset must be greater than or equal to zero and readOffset + sizeInBytes must be less than of equal to readBuffer.sizeInBytes.\",\n    );\n  }\n  if (\n    !defined(writeOffset) ||\n    writeOffset < 0 ||\n    writeOffset + sizeInBytes > this._sizeInBytes\n  ) {\n    throw new DeveloperError(\n      \"writeOffset must be greater than or equal to zero and writeOffset + sizeInBytes must be less than of equal to this.sizeInBytes.\",\n    );\n  }\n  if (\n    this._buffer === readBuffer._buffer &&\n    ((writeOffset >= readOffset && writeOffset < readOffset + sizeInBytes) ||\n      (readOffset > writeOffset && readOffset < writeOffset + sizeInBytes))\n  ) {\n    throw new DeveloperError(\n      \"When readBuffer is equal to this, the ranges [readOffset + sizeInBytes) and [writeOffset, writeOffset + sizeInBytes) must not overlap.\",\n    );\n  }\n  if (\n    (this._bufferTarget === WebGLConstants.ELEMENT_ARRAY_BUFFER &&\n      readBuffer._bufferTarget !== WebGLConstants.ELEMENT_ARRAY_BUFFER) ||\n    (this._bufferTarget !== WebGLConstants.ELEMENT_ARRAY_BUFFER &&\n      readBuffer._bufferTarget === WebGLConstants.ELEMENT_ARRAY_BUFFER)\n  ) {\n    throw new DeveloperError(\n      \"Can not copy an index buffer into another buffer type.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const readTarget = WebGLConstants.COPY_READ_BUFFER;\n  const writeTarget = WebGLConstants.COPY_WRITE_BUFFER;\n\n  const gl = this._gl;\n  gl.bindBuffer(writeTarget, this._buffer);\n  gl.bindBuffer(readTarget, readBuffer._buffer);\n  gl.copyBufferSubData(\n    readTarget,\n    writeTarget,\n    readOffset,\n    writeOffset,\n    sizeInBytes,\n  );\n  gl.bindBuffer(writeTarget, null);\n  gl.bindBuffer(readTarget, null);\n};\n\nBuffer.prototype.getBufferData = function (\n  arrayView,\n  sourceOffset,\n  destinationOffset,\n  length,\n) {\n  sourceOffset = sourceOffset ?? 0;\n  destinationOffset = destinationOffset ?? 0;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._webgl2) {\n    throw new DeveloperError(\"A WebGL 2 context is required.\");\n  }\n  if (!defined(arrayView)) {\n    throw new DeveloperError(\"arrayView is required.\");\n  }\n\n  let copyLength;\n  let elementSize;\n  let arrayLength = arrayView.byteLength;\n  if (!defined(length)) {\n    if (defined(arrayLength)) {\n      copyLength = arrayLength - destinationOffset;\n      elementSize = 1;\n    } else {\n      arrayLength = arrayView.length;\n      copyLength = arrayLength - destinationOffset;\n      elementSize = arrayView.BYTES_PER_ELEMENT;\n    }\n  } else {\n    copyLength = length;\n    if (defined(arrayLength)) {\n      elementSize = 1;\n    } else {\n      arrayLength = arrayView.length;\n      elementSize = arrayView.BYTES_PER_ELEMENT;\n    }\n  }\n\n  if (destinationOffset < 0 || destinationOffset > arrayLength) {\n    throw new DeveloperError(\n      \"destinationOffset must be greater than zero and less than the arrayView length.\",\n    );\n  }\n  if (destinationOffset + copyLength > arrayLength) {\n    throw new DeveloperError(\n      \"destinationOffset + length must be less than or equal to the arrayViewLength.\",\n    );\n  }\n  if (sourceOffset < 0 || sourceOffset > this._sizeInBytes) {\n    throw new DeveloperError(\n      \"sourceOffset must be greater than zero and less than the buffers size.\",\n    );\n  }\n  if (sourceOffset + copyLength * elementSize > this._sizeInBytes) {\n    throw new DeveloperError(\n      \"sourceOffset + length must be less than the buffers size.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const gl = this._gl;\n  const target = WebGLConstants.COPY_READ_BUFFER;\n  gl.bindBuffer(target, this._buffer);\n  gl.getBufferSubData(\n    target,\n    sourceOffset,\n    arrayView,\n    destinationOffset,\n    length,\n  );\n  gl.bindBuffer(target, null);\n};\n\nBuffer.prototype.isDestroyed = function () {\n  return false;\n};\n\nBuffer.prototype.destroy = function () {\n  this._gl.deleteBuffer(this._buffer);\n  return destroyObject(this);\n};\nexport default Buffer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}