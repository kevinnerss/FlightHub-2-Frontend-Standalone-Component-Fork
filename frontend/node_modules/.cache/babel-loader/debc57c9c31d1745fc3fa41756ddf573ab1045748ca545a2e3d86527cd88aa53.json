{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport AttributeCompression from \"../Core/AttributeCompression.js\";\nimport BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArrayFacade from \"../Renderer/VertexArrayFacade.js\";\nimport BillboardCollectionFS from \"../Shaders/BillboardCollectionFS.js\";\nimport BillboardCollectionVS from \"../Shaders/BillboardCollectionVS.js\";\nimport Billboard from \"./Billboard.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport BlendOption from \"./BlendOption.js\";\nimport HeightReference, { isHeightReferenceClamp } from \"./HeightReference.js\";\nimport HorizontalOrigin from \"./HorizontalOrigin.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SDFSettings from \"./SDFSettings.js\";\nimport TextureAtlas from \"../Renderer/TextureAtlas.js\";\nimport VerticalOrigin from \"./VerticalOrigin.js\";\nconst SHOW_INDEX = Billboard.SHOW_INDEX;\nconst POSITION_INDEX = Billboard.POSITION_INDEX;\nconst PIXEL_OFFSET_INDEX = Billboard.PIXEL_OFFSET_INDEX;\nconst EYE_OFFSET_INDEX = Billboard.EYE_OFFSET_INDEX;\nconst HORIZONTAL_ORIGIN_INDEX = Billboard.HORIZONTAL_ORIGIN_INDEX;\nconst VERTICAL_ORIGIN_INDEX = Billboard.VERTICAL_ORIGIN_INDEX;\nconst SCALE_INDEX = Billboard.SCALE_INDEX;\nconst IMAGE_INDEX_INDEX = Billboard.IMAGE_INDEX_INDEX;\nconst COLOR_INDEX = Billboard.COLOR_INDEX;\nconst ROTATION_INDEX = Billboard.ROTATION_INDEX;\nconst ALIGNED_AXIS_INDEX = Billboard.ALIGNED_AXIS_INDEX;\nconst SCALE_BY_DISTANCE_INDEX = Billboard.SCALE_BY_DISTANCE_INDEX;\nconst TRANSLUCENCY_BY_DISTANCE_INDEX = Billboard.TRANSLUCENCY_BY_DISTANCE_INDEX;\nconst PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX = Billboard.PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX;\nconst DISTANCE_DISPLAY_CONDITION_INDEX = Billboard.DISTANCE_DISPLAY_CONDITION;\nconst DISABLE_DEPTH_DISTANCE = Billboard.DISABLE_DEPTH_DISTANCE;\nconst TEXTURE_COORDINATE_BOUNDS = Billboard.TEXTURE_COORDINATE_BOUNDS;\nconst SDF_INDEX = Billboard.SDF_INDEX;\nconst SPLIT_DIRECTION_INDEX = Billboard.SPLIT_DIRECTION_INDEX;\nconst NUMBER_OF_PROPERTIES = Billboard.NUMBER_OF_PROPERTIES;\nlet attributeLocations;\nconst attributeLocationsBatched = {\n  positionHighAndScale: 0,\n  positionLowAndRotation: 1,\n  compressedAttribute0: 2,\n  // pixel offset, translate, horizontal origin, vertical origin, show, direction, texture coordinates\n  compressedAttribute1: 3,\n  // aligned axis, translucency by distance, image width\n  compressedAttribute2: 4,\n  // image height, color, pick color, size in meters, valid aligned axis, 13 bits free\n  eyeOffset: 5,\n  // 4 bytes free\n  scaleByDistance: 6,\n  pixelOffsetScaleByDistance: 7,\n  compressedAttribute3: 8,\n  textureCoordinateBoundsOrLabelTranslate: 9,\n  a_batchId: 10,\n  sdf: 11,\n  splitDirection: 12\n};\nconst attributeLocationsInstanced = {\n  direction: 0,\n  positionHighAndScale: 1,\n  positionLowAndRotation: 2,\n  // texture offset in w\n  compressedAttribute0: 3,\n  compressedAttribute1: 4,\n  compressedAttribute2: 5,\n  eyeOffset: 6,\n  // texture range in w\n  scaleByDistance: 7,\n  pixelOffsetScaleByDistance: 8,\n  compressedAttribute3: 9,\n  textureCoordinateBoundsOrLabelTranslate: 10,\n  a_batchId: 11,\n  sdf: 12,\n  splitDirection: 13\n};\n\n/**\n * A renderable collection of billboards.  Billboards are viewport-aligned\n * images positioned in the 3D scene.\n * <br /><br />\n * <div align='center'>\n * <img src='Images/Billboard.png' width='400' height='300' /><br />\n * Example billboards\n * </div>\n * <br /><br />\n * Billboards are added and removed from the collection using {@link BillboardCollection#add}\n * and {@link BillboardCollection#remove}.  Billboards in a collection automatically share textures\n * for images with the same identifier.\n *\n * @alias BillboardCollection\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each billboard from model to world coordinates.\n * @param {boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {Scene} [options.scene] Must be passed in for billboards that use the height reference property or will be depth tested against the globe.\n * @param {BlendOption} [options.blendOption=BlendOption.OPAQUE_AND_TRANSLUCENT] The billboard blending option. The default\n * is used for rendering both opaque and translucent billboards. However, if either all of the billboards are completely opaque or all are completely translucent,\n * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.\n * @param {boolean} [options.show=true] Determines if the billboards in the collection will be shown.\n *\n * @performance For best performance, prefer a few collections, each with many billboards, to\n * many collections with only a few billboards each.  Organize collections so that billboards\n * with the same update frequency are in the same collection, i.e., billboards that do not\n * change should be in one collection; billboards that change every frame should be in another\n * collection; and so on.\n *\n * @see BillboardCollection#add\n * @see BillboardCollection#remove\n * @see Billboard\n * @see LabelCollection\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Billboards.html|Cesium Sandcastle Billboard Demo}\n *\n * @example\n * // Create a billboard collection with two billboards\n * const billboards = scene.primitives.add(new Cesium.BillboardCollection());\n * billboards.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   image : 'url/to/image'\n * });\n * billboards.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   image : 'url/to/another/image'\n * });\n */\nfunction BillboardCollection(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  this._scene = options.scene;\n  this._batchTable = options.batchTable;\n  let textureAtlas = options.textureAtlas; // Hidden option for internal use\n  if (!defined(textureAtlas)) {\n    textureAtlas = new TextureAtlas();\n  }\n  this._textureAtlas = textureAtlas;\n  this._textureAtlasGUID = textureAtlas.guid;\n  this._destroyTextureAtlas = true;\n  this._billboardTextureCache = new Map();\n  this._sp = undefined;\n  this._spTranslucent = undefined;\n  this._rsOpaque = undefined;\n  this._rsTranslucent = undefined;\n  this._vaf = undefined;\n  this._billboards = [];\n  this._billboardsToUpdate = [];\n  this._billboardsToUpdateIndex = 0;\n  this._billboardsRemoved = false;\n  this._createVertexArray = false;\n  this._shaderRotation = false;\n  this._compiledShaderRotation = false;\n  this._shaderAlignedAxis = false;\n  this._compiledShaderAlignedAxis = false;\n  this._shaderScaleByDistance = false;\n  this._compiledShaderScaleByDistance = false;\n  this._shaderTranslucencyByDistance = false;\n  this._compiledShaderTranslucencyByDistance = false;\n  this._shaderPixelOffsetScaleByDistance = false;\n  this._compiledShaderPixelOffsetScaleByDistance = false;\n  this._shaderDistanceDisplayCondition = false;\n  this._compiledShaderDistanceDisplayCondition = false;\n  this._shaderDisableDepthDistance = false;\n  this._compiledShaderDisableDepthDistance = false;\n  this._shaderClampToGround = false;\n  this._compiledShaderClampToGround = false;\n  this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);\n  this._maxSize = 0.0;\n  this._maxEyeOffset = 0.0;\n  this._maxScale = 1.0;\n  this._maxPixelOffset = 0.0;\n  this._allHorizontalCenter = true;\n  this._allVerticalCenter = true;\n  this._allSizedInMeters = true;\n  this._baseVolume = new BoundingSphere();\n  this._baseVolumeWC = new BoundingSphere();\n  this._baseVolume2D = new BoundingSphere();\n  this._boundingVolume = new BoundingSphere();\n  this._boundingVolumeDirty = false;\n  this._colorCommands = [];\n  this._allBillboardsReady = false;\n\n  /**\n   * Determines if billboards in this collection will be shown.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.show = options.show ?? true;\n\n  /**\n   * The 4x4 transformation matrix that transforms each billboard in this collection from model to world coordinates.\n   * When this is the identity matrix, the billboards are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   * @default {@link Matrix4.IDENTITY}\n   *\n   *\n   * @example\n   * const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * billboards.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0) // center\n   * });\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0) // east\n   * });\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0) // north\n   * });\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0) // up\n   * });\n   *\n   * @see Transforms.eastNorthUpToFixedFrame\n   */\n  this.modelMatrix = Matrix4.clone(options.modelMatrix ?? Matrix4.IDENTITY);\n  this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = options.debugShowBoundingVolume ?? false;\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the texture atlas for this BillboardCollection as a fullscreen quad.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowTextureAtlas = options.debugShowTextureAtlas ?? false;\n\n  /**\n   * The billboard blending option. The default is used for rendering both opaque and translucent billboards.\n   * However, if either all of the billboards are completely opaque or all are completely translucent,\n   * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve\n   * performance by up to 2x.\n   * @type {BlendOption}\n   * @default BlendOption.OPAQUE_AND_TRANSLUCENT\n   */\n  this.blendOption = options.blendOption ?? BlendOption.OPAQUE_AND_TRANSLUCENT;\n  this._blendOption = undefined;\n  this._mode = SceneMode.SCENE3D;\n\n  // The buffer usage for each attribute is determined based on the usage of the attribute over time.\n  this._buffersUsage = [BufferUsage.STATIC_DRAW,\n  // SHOW_INDEX\n  BufferUsage.STATIC_DRAW,\n  // POSITION_INDEX\n  BufferUsage.STATIC_DRAW,\n  // PIXEL_OFFSET_INDEX\n  BufferUsage.STATIC_DRAW,\n  // EYE_OFFSET_INDEX\n  BufferUsage.STATIC_DRAW,\n  // HORIZONTAL_ORIGIN_INDEX\n  BufferUsage.STATIC_DRAW,\n  // VERTICAL_ORIGIN_INDEX\n  BufferUsage.STATIC_DRAW,\n  // SCALE_INDEX\n  BufferUsage.STATIC_DRAW,\n  // IMAGE_INDEX_INDEX\n  BufferUsage.STATIC_DRAW,\n  // COLOR_INDEX\n  BufferUsage.STATIC_DRAW,\n  // ROTATION_INDEX\n  BufferUsage.STATIC_DRAW,\n  // ALIGNED_AXIS_INDEX\n  BufferUsage.STATIC_DRAW,\n  // SCALE_BY_DISTANCE_INDEX\n  BufferUsage.STATIC_DRAW,\n  // TRANSLUCENCY_BY_DISTANCE_INDEX\n  BufferUsage.STATIC_DRAW,\n  // PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX\n  BufferUsage.STATIC_DRAW,\n  // DISTANCE_DISPLAY_CONDITION_INDEX\n  BufferUsage.STATIC_DRAW,\n  // TEXTURE_COORDINATE_BOUNDS\n  BufferUsage.STATIC_DRAW // SPLIT_DIRECTION_INDEX\n  ];\n  this._highlightColor = Color.clone(Color.WHITE); // Only used by Vector3DTilePoints\n\n  this._uniforms = {\n    u_atlas: () => {\n      return this.textureAtlas.texture;\n    },\n    u_highlightColor: () => {\n      return this._highlightColor;\n    }\n  };\n  const scene = this._scene;\n  if (defined(scene) && defined(scene.terrainProviderChanged)) {\n    this._removeCallbackFunc = scene.terrainProviderChanged.addEventListener(function () {\n      const billboards = this._billboards;\n      const length = billboards.length;\n      for (let i = 0; i < length; ++i) {\n        if (defined(billboards[i])) {\n          billboards[i]._updateClamping();\n        }\n      }\n    }, this);\n  }\n}\nObject.defineProperties(BillboardCollection.prototype, {\n  /**\n   * Returns the number of billboards in this collection.  This is commonly used with\n   * {@link BillboardCollection#get} to iterate over all the billboards\n   * in the collection.\n   * @memberof BillboardCollection.prototype\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      removeBillboards(this);\n      return this._billboards.length;\n    }\n  },\n  /**\n   * Gets or sets the textureAtlas.\n   * @memberof BillboardCollection.prototype\n   * @type {TextureAtlas}\n   * @private\n   */\n  textureAtlas: {\n    get: function () {\n      return this._textureAtlas;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"textureAtlas\", value);\n      //>>includeEnd('debug');\n\n      if (this._textureAtlas !== value) {\n        this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy();\n        this._textureAtlas = value;\n      }\n    }\n  },\n  /**\n   * Gets or sets a value which determines if the texture atlas is\n   * destroyed when the collection is destroyed.\n   *\n   * If the texture atlas is used by more than one collection, set this to <code>false</code>,\n   * and explicitly destroy the atlas to avoid attempting to destroy it multiple times.\n   *\n   * @memberof BillboardCollection.prototype\n   * @type {boolean}\n   * @private\n   *\n   * @example\n   * // Set destroyTextureAtlas\n   * // Destroy a billboard collection but not its texture atlas.\n   *\n   * const atlas = new TextureAtlas();\n   * billboards.textureAtlas = atlas;\n   * billboards.destroyTextureAtlas = false;\n   *\n   * billboards = billboards.destroy();\n   * console.log(atlas.isDestroyed()); // False\n   */\n  destroyTextureAtlas: {\n    get: function () {\n      return this._destroyTextureAtlas;\n    },\n    set: function (value) {\n      this._destroyTextureAtlas = value;\n    }\n  },\n  /**\n   * Returns the size in bytes of the WebGL texture resources.\n   * @private\n   * @memberof BillboardCollection.prototype\n   * @type {number}\n   * @readonly\n   */\n  sizeInBytes: {\n    get: function () {\n      return this._textureAtlas.sizeInBytes;\n    }\n  },\n  /**\n   * True when all billboards currently in the collection are ready for rendering.\n   * @private\n   * @memberof BillboardCollection.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._allBillboardsReady;\n    }\n  },\n  /**\n   * Cache of loaded billboard images.\n   * @private\n   * @memberof BillboardCollection.prototype\n   * @type {Map<string, BillboardTexture>}\n   * @readonly\n   */\n  billboardTextureCache: {\n    get: function () {\n      return this._billboardTextureCache;\n    }\n  }\n});\nfunction destroyBillboards(billboards) {\n  const length = billboards.length;\n  for (let i = 0; i < length; ++i) {\n    if (billboards[i]) {\n      billboards[i]._destroy();\n    }\n  }\n}\n\n/**\n * Creates and adds a billboard with the specified initial properties to the collection.\n * The added billboard is returned so it can be modified or removed from the collection later.\n *\n * @param {Billboard.ConstructorOptions}[options] A template describing the billboard's properties as shown in Example 1.\n * @returns {Billboard} The billboard that was added to the collection.\n *\n * @performance Calling <code>add</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, add as many billboards as possible before calling <code>update</code>.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Example 1:  Add a billboard, specifying all the default values.\n * const b = billboards.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   pixelOffset : Cesium.Cartesian2.ZERO,\n *   eyeOffset : Cesium.Cartesian3.ZERO,\n *   heightReference : Cesium.HeightReference.NONE,\n *   horizontalOrigin : Cesium.HorizontalOrigin.CENTER,\n *   verticalOrigin : Cesium.VerticalOrigin.CENTER,\n *   scale : 1.0,\n *   image : 'url/to/image',\n *   imageSubRegion : undefined,\n *   color : Cesium.Color.WHITE,\n *   id : undefined,\n *   rotation : 0.0,\n *   alignedAxis : Cesium.Cartesian3.ZERO,\n *   width : undefined,\n *   height : undefined,\n *   scaleByDistance : undefined,\n *   translucencyByDistance : undefined,\n *   pixelOffsetScaleByDistance : undefined,\n *   sizeInMeters : false,\n *   distanceDisplayCondition : undefined\n * });\n *\n * @example\n * // Example 2:  Specify only the billboard's cartographic position.\n * const b = billboards.add({\n *   position : Cesium.Cartesian3.fromDegrees(longitude, latitude, height)\n * });\n *\n * @see BillboardCollection#remove\n * @see BillboardCollection#removeAll\n */\nBillboardCollection.prototype.add = function (options) {\n  const billboard = new Billboard(options, this);\n  billboard._index = this._billboards.length;\n  this._billboards.push(billboard);\n  this._createVertexArray = true;\n  return billboard;\n};\n\n/**\n * Removes a billboard from the collection.\n *\n * @param {Billboard} billboard The billboard to remove.\n * @returns {boolean} <code>true</code> if the billboard was removed; <code>false</code> if the billboard was not found in the collection.\n *\n * @performance Calling <code>remove</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, remove as many billboards as possible before calling <code>update</code>.\n * If you intend to temporarily hide a billboard, it is usually more efficient to call\n * {@link Billboard#show} instead of removing and re-adding the billboard.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * const b = billboards.add(...);\n * billboards.remove(b);  // Returns true\n *\n * @see BillboardCollection#add\n * @see BillboardCollection#removeAll\n * @see Billboard#show\n */\nBillboardCollection.prototype.remove = function (billboard) {\n  if (this.contains(billboard)) {\n    this._billboards[billboard._index] = undefined; // Removed later\n    this._billboardsRemoved = true;\n    this._createVertexArray = true;\n    billboard._destroy();\n    return true;\n  }\n  return false;\n};\n\n/**\n * Removes all billboards from the collection.\n *\n * @performance <code>O(n)</code>.  It is more efficient to remove all the billboards\n * from a collection and then add new ones than to create a new collection entirely.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * billboards.add(...);\n * billboards.add(...);\n * billboards.removeAll();\n *\n * @see BillboardCollection#add\n * @see BillboardCollection#remove\n */\nBillboardCollection.prototype.removeAll = function () {\n  destroyBillboards(this._billboards);\n  this._billboards = [];\n  this._billboardsToUpdate = [];\n  this._billboardsToUpdateIndex = 0;\n  this._billboardsRemoved = false;\n  this._createVertexArray = true;\n};\nfunction removeBillboards(billboardCollection) {\n  if (billboardCollection._billboardsRemoved) {\n    billboardCollection._billboardsRemoved = false;\n    const newBillboards = [];\n    const billboards = billboardCollection._billboards;\n    const length = billboards.length;\n    for (let i = 0, j = 0; i < length; ++i) {\n      const billboard = billboards[i];\n      if (defined(billboard)) {\n        billboard._index = j++;\n        newBillboards.push(billboard);\n      }\n    }\n    billboardCollection._billboards = newBillboards;\n  }\n}\nBillboardCollection.prototype._updateBillboard = function (billboard, propertyChanged) {\n  if (!billboard._dirty) {\n    this._billboardsToUpdate[this._billboardsToUpdateIndex++] = billboard;\n  }\n  ++this._propertiesChanged[propertyChanged];\n};\n\n/**\n * Check whether this collection contains a given billboard.\n *\n * @param {Billboard} [billboard] The billboard to check for.\n * @returns {boolean} true if this collection contains the billboard, false otherwise.\n *\n * @see BillboardCollection#get\n */\nBillboardCollection.prototype.contains = function (billboard) {\n  return defined(billboard) && billboard._billboardCollection === this;\n};\n\n/**\n * Returns the billboard in the collection at the specified index.  Indices are zero-based\n * and increase as billboards are added.  Removing a billboard shifts all billboards after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link BillboardCollection#length} to iterate over all the billboards\n * in the collection.\n *\n * @param {number} index The zero-based index of the billboard.\n * @returns {Billboard} The billboard at the specified index.\n *\n * @performance Expected constant time.  If billboards were removed from the collection and\n * {@link BillboardCollection#update} was not called, an implicit <code>O(n)</code>\n * operation is performed.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Toggle the show property of every billboard in the collection\n * const len = billboards.length;\n * for (let i = 0; i < len; ++i) {\n *   const b = billboards.get(i);\n *   b.show = !b.show;\n * }\n *\n * @see BillboardCollection#length\n */\nBillboardCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  //>>includeEnd('debug');\n\n  removeBillboards(this);\n  return this._billboards[index];\n};\nlet getIndexBuffer;\nfunction getIndexBufferBatched(context) {\n  const sixteenK = 16 * 1024;\n  let indexBuffer = context.cache.billboardCollection_indexBufferBatched;\n  if (defined(indexBuffer)) {\n    return indexBuffer;\n  }\n\n  // Subtract 6 because the last index is reserverd for primitive restart.\n  // https://www.khronos.org/registry/webgl/specs/latest/2.0/#5.18\n  const length = sixteenK * 6 - 6;\n  const indices = new Uint16Array(length);\n  for (let i = 0, j = 0; i < length; i += 6, j += 4) {\n    indices[i] = j;\n    indices[i + 1] = j + 1;\n    indices[i + 2] = j + 2;\n    indices[i + 3] = j + 0;\n    indices[i + 4] = j + 2;\n    indices[i + 5] = j + 3;\n  }\n\n  // PERFORMANCE_IDEA:  Should we reference count billboard collections, and eventually delete this?\n  // Is this too much memory to allocate up front?  Should we dynamically grow it?\n  indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: indices,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: IndexDatatype.UNSIGNED_SHORT\n  });\n  indexBuffer.vertexArrayDestroyable = false;\n  context.cache.billboardCollection_indexBufferBatched = indexBuffer;\n  return indexBuffer;\n}\nfunction getIndexBufferInstanced(context) {\n  let indexBuffer = context.cache.billboardCollection_indexBufferInstanced;\n  if (defined(indexBuffer)) {\n    return indexBuffer;\n  }\n  indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: new Uint16Array([0, 1, 2, 0, 2, 3]),\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: IndexDatatype.UNSIGNED_SHORT\n  });\n  indexBuffer.vertexArrayDestroyable = false;\n  context.cache.billboardCollection_indexBufferInstanced = indexBuffer;\n  return indexBuffer;\n}\nfunction getVertexBufferInstanced(context) {\n  let vertexBuffer = context.cache.billboardCollection_vertexBufferInstanced;\n  if (defined(vertexBuffer)) {\n    return vertexBuffer;\n  }\n  vertexBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: new Float32Array([0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0]),\n    usage: BufferUsage.STATIC_DRAW\n  });\n  vertexBuffer.vertexArrayDestroyable = false;\n  context.cache.billboardCollection_vertexBufferInstanced = vertexBuffer;\n  return vertexBuffer;\n}\nBillboardCollection.prototype.computeNewBuffersUsage = function () {\n  const buffersUsage = this._buffersUsage;\n  let usageChanged = false;\n  const properties = this._propertiesChanged;\n  for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n    const newUsage = properties[k] === 0 ? BufferUsage.STATIC_DRAW : BufferUsage.STREAM_DRAW;\n    usageChanged = usageChanged || buffersUsage[k] !== newUsage;\n    buffersUsage[k] = newUsage;\n  }\n  return usageChanged;\n};\nfunction createVAF(context, numberOfBillboards, buffersUsage, instanced, batchTable, sdf) {\n  const attributes = [{\n    index: attributeLocations.positionHighAndScale,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[POSITION_INDEX]\n  }, {\n    index: attributeLocations.positionLowAndRotation,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[POSITION_INDEX]\n  }, {\n    index: attributeLocations.compressedAttribute0,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[PIXEL_OFFSET_INDEX]\n  }, {\n    index: attributeLocations.compressedAttribute1,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[TRANSLUCENCY_BY_DISTANCE_INDEX]\n  }, {\n    index: attributeLocations.compressedAttribute2,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[COLOR_INDEX]\n  }, {\n    index: attributeLocations.eyeOffset,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[EYE_OFFSET_INDEX]\n  }, {\n    index: attributeLocations.scaleByDistance,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[SCALE_BY_DISTANCE_INDEX]\n  }, {\n    index: attributeLocations.pixelOffsetScaleByDistance,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX]\n  }, {\n    index: attributeLocations.compressedAttribute3,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[DISTANCE_DISPLAY_CONDITION_INDEX]\n  }, {\n    index: attributeLocations.textureCoordinateBoundsOrLabelTranslate,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[TEXTURE_COORDINATE_BOUNDS]\n  }, {\n    index: attributeLocations.splitDirection,\n    componentsPerAttribute: 1,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[SPLIT_DIRECTION_INDEX]\n  }];\n\n  // Instancing requires one non-instanced attribute.\n  if (instanced) {\n    attributes.push({\n      index: attributeLocations.direction,\n      componentsPerAttribute: 2,\n      componentDatatype: ComponentDatatype.FLOAT,\n      vertexBuffer: getVertexBufferInstanced(context)\n    });\n  }\n  if (defined(batchTable)) {\n    attributes.push({\n      index: attributeLocations.a_batchId,\n      componentsPerAttribute: 1,\n      componentDatatype: ComponentDatatype.FLOAT,\n      bufferUsage: BufferUsage.STATIC_DRAW\n    });\n  }\n  if (sdf) {\n    attributes.push({\n      index: attributeLocations.sdf,\n      componentsPerAttribute: 2,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[SDF_INDEX]\n    });\n  }\n\n  // When instancing is enabled, only one vertex is needed for each billboard.\n  const sizeInVertices = instanced ? numberOfBillboards : 4 * numberOfBillboards;\n  return new VertexArrayFacade(context, attributes, sizeInVertices, instanced);\n}\n\n///////////////////////////////////////////////////////////////////////////\n\n// Four vertices per billboard.  Each has the same position, etc., but a different screen-space direction vector.\n\n// PERFORMANCE_IDEA:  Save memory if a property is the same for all billboards, use a latched attribute state,\n// instead of storing it in a vertex buffer.\n\nconst writePositionScratch = new EncodedCartesian3();\nfunction writePositionScaleAndRotation(billboardCollection, frameState, vafWriters, billboard) {\n  let i;\n  const positionHighWriter = vafWriters[attributeLocations.positionHighAndScale];\n  const positionLowWriter = vafWriters[attributeLocations.positionLowAndRotation];\n  const position = billboard._getActualPosition();\n  if (billboardCollection._mode === SceneMode.SCENE3D) {\n    BoundingSphere.expand(billboardCollection._baseVolume, position, billboardCollection._baseVolume);\n    billboardCollection._boundingVolumeDirty = true;\n  }\n  EncodedCartesian3.fromCartesian(position, writePositionScratch);\n  const scale = billboard.scale;\n  const rotation = billboard.rotation;\n  if (rotation !== 0.0) {\n    billboardCollection._shaderRotation = true;\n  }\n  billboardCollection._maxScale = Math.max(billboardCollection._maxScale, scale);\n  const high = writePositionScratch.high;\n  const low = writePositionScratch.low;\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    positionHighWriter(i, high.x, high.y, high.z, scale);\n    positionLowWriter(i, low.x, low.y, low.z, rotation);\n  } else {\n    i = billboard._index * 4;\n    positionHighWriter(i + 0, high.x, high.y, high.z, scale);\n    positionHighWriter(i + 1, high.x, high.y, high.z, scale);\n    positionHighWriter(i + 2, high.x, high.y, high.z, scale);\n    positionHighWriter(i + 3, high.x, high.y, high.z, scale);\n    positionLowWriter(i + 0, low.x, low.y, low.z, rotation);\n    positionLowWriter(i + 1, low.x, low.y, low.z, rotation);\n    positionLowWriter(i + 2, low.x, low.y, low.z, rotation);\n    positionLowWriter(i + 3, low.x, low.y, low.z, rotation);\n  }\n}\nconst scratchCartesian2 = new Cartesian2();\nconst UPPER_BOUND = 32768.0; // 2^15\n\nconst LEFT_SHIFT16 = 65536.0; // 2^16\nconst LEFT_SHIFT12 = 4096.0; // 2^12\nconst LEFT_SHIFT8 = 256.0; // 2^8\nconst LEFT_SHIFT7 = 128.0;\nconst LEFT_SHIFT5 = 32.0;\nconst LEFT_SHIFT3 = 8.0;\nconst LEFT_SHIFT2 = 4.0;\nconst RIGHT_SHIFT8 = 1.0 / 256.0;\nconst LOWER_LEFT = 0.0;\nconst LOWER_RIGHT = 2.0;\nconst UPPER_RIGHT = 3.0;\nconst UPPER_LEFT = 1.0;\nconst scratchBoundingRectangle = new BoundingRectangle();\nfunction writeCompressedAttrib0(billboardCollection, frameState, vafWriters, billboard) {\n  let i;\n  const writer = vafWriters[attributeLocations.compressedAttribute0];\n  const pixelOffset = billboard.pixelOffset;\n  const pixelOffsetX = pixelOffset.x;\n  const pixelOffsetY = pixelOffset.y;\n  const translate = billboard._translate;\n  const translateX = translate.x;\n  const translateY = translate.y;\n  billboardCollection._maxPixelOffset = Math.max(billboardCollection._maxPixelOffset, Math.abs(pixelOffsetX + translateX), Math.abs(-pixelOffsetY + translateY));\n  const horizontalOrigin = billboard.horizontalOrigin;\n  let verticalOrigin = billboard._verticalOrigin;\n  let show = billboard.show && billboard.clusterShow;\n\n  // If the color alpha is zero, do not show this billboard.  This lets us avoid providing\n  // color during the pick pass and also eliminates a discard in the fragment shader.\n  if (billboard.color.alpha === 0.0) {\n    show = false;\n  }\n\n  // Raw billboards don't distinguish between BASELINE and BOTTOM, only LabelCollection does that.\n  if (verticalOrigin === VerticalOrigin.BASELINE) {\n    verticalOrigin = VerticalOrigin.BOTTOM;\n  }\n  billboardCollection._allHorizontalCenter = billboardCollection._allHorizontalCenter && horizontalOrigin === HorizontalOrigin.CENTER;\n  billboardCollection._allVerticalCenter = billboardCollection._allVerticalCenter && verticalOrigin === VerticalOrigin.CENTER;\n  let bottomLeftX = 0;\n  let bottomLeftY = 0;\n  let width = 0;\n  let height = 0;\n  if (billboard.ready) {\n    const imageRectangle = billboard.computeTextureCoordinates(scratchBoundingRectangle);\n    bottomLeftX = imageRectangle.x;\n    bottomLeftY = imageRectangle.y;\n    width = imageRectangle.width;\n    height = imageRectangle.height;\n  }\n  const topRightX = bottomLeftX + width;\n  const topRightY = bottomLeftY + height;\n  let compressed0 = Math.floor(CesiumMath.clamp(pixelOffsetX, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND) * LEFT_SHIFT7;\n  compressed0 += (horizontalOrigin + 1.0) * LEFT_SHIFT5;\n  compressed0 += (verticalOrigin + 1.0) * LEFT_SHIFT3;\n  compressed0 += (show ? 1.0 : 0.0) * LEFT_SHIFT2;\n  let compressed1 = Math.floor(CesiumMath.clamp(pixelOffsetY, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND) * LEFT_SHIFT8;\n\n  // We scale `translate` by LEFT_SHIFT2 before encoding it (and unscale after decoding in the shader)\n  // to preserve some subpixel precision (1 / 4 = 0.25 pixels). This mitigates rounding errors in aligning glyphs.\n  // The cost of increasing this scaling factor is that it decreases the range of representable `translate` values\n  // by the same scaling factor. Value must be kept in sync with the shader.\n  let compressed2 = Math.floor(CesiumMath.clamp(translateX * LEFT_SHIFT2, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND) * LEFT_SHIFT8;\n  const tempTanslateY = (CesiumMath.clamp(translateY * LEFT_SHIFT2, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND) * RIGHT_SHIFT8;\n  const upperTranslateY = Math.floor(tempTanslateY);\n  const lowerTranslateY = Math.floor((tempTanslateY - upperTranslateY) * LEFT_SHIFT8);\n  compressed1 += upperTranslateY;\n  compressed2 += lowerTranslateY;\n  scratchCartesian2.x = bottomLeftX;\n  scratchCartesian2.y = bottomLeftY;\n  const compressedTexCoordsLL = AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n  scratchCartesian2.x = topRightX;\n  const compressedTexCoordsLR = AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n  scratchCartesian2.y = topRightY;\n  const compressedTexCoordsUR = AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n  scratchCartesian2.x = bottomLeftX;\n  const compressedTexCoordsUL = AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, compressed0, compressed1, compressed2, compressedTexCoordsLL);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, compressed0 + LOWER_LEFT, compressed1, compressed2, compressedTexCoordsLL);\n    writer(i + 1, compressed0 + LOWER_RIGHT, compressed1, compressed2, compressedTexCoordsLR);\n    writer(i + 2, compressed0 + UPPER_RIGHT, compressed1, compressed2, compressedTexCoordsUR);\n    writer(i + 3, compressed0 + UPPER_LEFT, compressed1, compressed2, compressedTexCoordsUL);\n  }\n}\nfunction writeCompressedAttrib1(billboardCollection, frameState, vafWriters, billboard) {\n  let i;\n  const writer = vafWriters[attributeLocations.compressedAttribute1];\n  const alignedAxis = billboard.alignedAxis;\n  if (!Cartesian3.equals(alignedAxis, Cartesian3.ZERO)) {\n    billboardCollection._shaderAlignedAxis = true;\n  }\n  let near = 0.0;\n  let nearValue = 1.0;\n  let far = 1.0;\n  let farValue = 1.0;\n  const translucency = billboard.translucencyByDistance;\n  if (defined(translucency)) {\n    near = translucency.near;\n    nearValue = translucency.nearValue;\n    far = translucency.far;\n    farValue = translucency.farValue;\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // translucency by distance calculation in shader need not be enabled\n      // until a billboard with near and far !== 1.0 is found\n      billboardCollection._shaderTranslucencyByDistance = true;\n    }\n  }\n  const imageWidth = Math.round(billboard.width ?? 0);\n  billboardCollection._maxSize = Math.max(billboardCollection._maxSize, imageWidth);\n  let compressed0 = CesiumMath.clamp(imageWidth, 0.0, LEFT_SHIFT16);\n  let compressed1 = 0.0;\n  if (Math.abs(Cartesian3.magnitudeSquared(alignedAxis) - 1.0) < CesiumMath.EPSILON6) {\n    compressed1 = AttributeCompression.octEncodeFloat(alignedAxis);\n  }\n  nearValue = CesiumMath.clamp(nearValue, 0.0, 1.0);\n  nearValue = nearValue === 1.0 ? 255.0 : nearValue * 255.0 | 0;\n  compressed0 = compressed0 * LEFT_SHIFT8 + nearValue;\n  farValue = CesiumMath.clamp(farValue, 0.0, 1.0);\n  farValue = farValue === 1.0 ? 255.0 : farValue * 255.0 | 0;\n  compressed1 = compressed1 * LEFT_SHIFT8 + farValue;\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, compressed0, compressed1, near, far);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, compressed0, compressed1, near, far);\n    writer(i + 1, compressed0, compressed1, near, far);\n    writer(i + 2, compressed0, compressed1, near, far);\n    writer(i + 3, compressed0, compressed1, near, far);\n  }\n}\nfunction writeCompressedAttrib2(billboardCollection, frameState, vafWriters, billboard) {\n  let i;\n  const writer = vafWriters[attributeLocations.compressedAttribute2];\n  const color = billboard.color;\n  const pickColor = !defined(billboardCollection._batchTable) ? billboard.getPickId(frameState.context).color : Color.WHITE;\n  const sizeInMeters = billboard.sizeInMeters ? 1.0 : 0.0;\n  const validAlignedAxis = Math.abs(Cartesian3.magnitudeSquared(billboard.alignedAxis) - 1.0) < CesiumMath.EPSILON6 ? 1.0 : 0.0;\n  billboardCollection._allSizedInMeters = billboardCollection._allSizedInMeters && sizeInMeters === 1.0;\n  const imageHeight = billboard.height ?? 0;\n  billboardCollection._maxSize = Math.max(billboardCollection._maxSize, imageHeight);\n  let labelHorizontalOrigin = billboard._labelHorizontalOrigin ?? -2;\n  labelHorizontalOrigin += 2;\n  const compressed3 = imageHeight * LEFT_SHIFT2 + labelHorizontalOrigin;\n  let red = Color.floatToByte(color.red);\n  let green = Color.floatToByte(color.green);\n  let blue = Color.floatToByte(color.blue);\n  const compressed0 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n  red = Color.floatToByte(pickColor.red);\n  green = Color.floatToByte(pickColor.green);\n  blue = Color.floatToByte(pickColor.blue);\n  const compressed1 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n  let compressed2 = Color.floatToByte(color.alpha) * LEFT_SHIFT16 + Color.floatToByte(pickColor.alpha) * LEFT_SHIFT8;\n  compressed2 += sizeInMeters * 2.0 + validAlignedAxis;\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, compressed0, compressed1, compressed2, compressed3);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, compressed0, compressed1, compressed2, compressed3);\n    writer(i + 1, compressed0, compressed1, compressed2, compressed3);\n    writer(i + 2, compressed0, compressed1, compressed2, compressed3);\n    writer(i + 3, compressed0, compressed1, compressed2, compressed3);\n  }\n}\nfunction writeEyeOffset(billboardCollection, frameState, vafWriters, billboard) {\n  let i;\n  const writer = vafWriters[attributeLocations.eyeOffset];\n  const eyeOffset = billboard.eyeOffset;\n\n  // For billboards that are clamped to ground, move it slightly closer to the camera\n  let eyeOffsetZ = eyeOffset.z;\n  if (billboard._heightReference !== HeightReference.NONE) {\n    eyeOffsetZ *= 1.005;\n  }\n  billboardCollection._maxEyeOffset = Math.max(billboardCollection._maxEyeOffset, Math.abs(eyeOffset.x), Math.abs(eyeOffset.y), Math.abs(eyeOffsetZ));\n  if (billboardCollection._instanced) {\n    scratchCartesian2.x = 0;\n    scratchCartesian2.y = 0;\n    if (billboard.ready) {\n      const imageRectangle = billboard.computeTextureCoordinates(scratchBoundingRectangle);\n      scratchCartesian2.x = imageRectangle.width;\n      scratchCartesian2.y = imageRectangle.height;\n    }\n    const compressedTexCoordsRange = AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n    i = billboard._index;\n    writer(i, eyeOffset.x, eyeOffset.y, eyeOffsetZ, compressedTexCoordsRange);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0.0);\n    writer(i + 1, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0.0);\n    writer(i + 2, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0.0);\n    writer(i + 3, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0.0);\n  }\n}\nfunction writeScaleByDistance(billboardCollection, frameState, vafWriters, billboard) {\n  let i;\n  const writer = vafWriters[attributeLocations.scaleByDistance];\n  let near = 0.0;\n  let nearValue = 1.0;\n  let far = 1.0;\n  let farValue = 1.0;\n  const scale = billboard.scaleByDistance;\n  if (defined(scale)) {\n    near = scale.near;\n    nearValue = scale.nearValue;\n    far = scale.far;\n    farValue = scale.farValue;\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // scale by distance calculation in shader need not be enabled\n      // until a billboard with near and far !== 1.0 is found\n      billboardCollection._shaderScaleByDistance = true;\n    }\n  }\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, near, nearValue, far, farValue);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, near, nearValue, far, farValue);\n    writer(i + 1, near, nearValue, far, farValue);\n    writer(i + 2, near, nearValue, far, farValue);\n    writer(i + 3, near, nearValue, far, farValue);\n  }\n}\nfunction writePixelOffsetScaleByDistance(billboardCollection, frameState, vafWriters, billboard) {\n  let i;\n  const writer = vafWriters[attributeLocations.pixelOffsetScaleByDistance];\n  let near = 0.0;\n  let nearValue = 1.0;\n  let far = 1.0;\n  let farValue = 1.0;\n  const pixelOffsetScale = billboard.pixelOffsetScaleByDistance;\n  if (defined(pixelOffsetScale)) {\n    near = pixelOffsetScale.near;\n    nearValue = pixelOffsetScale.nearValue;\n    far = pixelOffsetScale.far;\n    farValue = pixelOffsetScale.farValue;\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // pixelOffsetScale by distance calculation in shader need not be enabled\n      // until a billboard with near and far !== 1.0 is found\n      billboardCollection._shaderPixelOffsetScaleByDistance = true;\n    }\n  }\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, near, nearValue, far, farValue);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, near, nearValue, far, farValue);\n    writer(i + 1, near, nearValue, far, farValue);\n    writer(i + 2, near, nearValue, far, farValue);\n    writer(i + 3, near, nearValue, far, farValue);\n  }\n}\nfunction writeCompressedAttribute3(billboardCollection, frameState, vafWriters, billboard) {\n  let i;\n  const writer = vafWriters[attributeLocations.compressedAttribute3];\n  let near = 0.0;\n  let far = Number.MAX_VALUE;\n  const distanceDisplayCondition = billboard.distanceDisplayCondition;\n  if (defined(distanceDisplayCondition)) {\n    near = distanceDisplayCondition.near;\n    far = distanceDisplayCondition.far;\n    near *= near;\n    far *= far;\n    billboardCollection._shaderDistanceDisplayCondition = true;\n  }\n  let disableDepthTestDistance = billboard.disableDepthTestDistance;\n  const clampToGround = isHeightReferenceClamp(billboard.heightReference) && frameState.context.depthTexture;\n  if (!defined(disableDepthTestDistance)) {\n    disableDepthTestDistance = clampToGround ? 5000.0 : 0.0;\n  }\n  disableDepthTestDistance *= disableDepthTestDistance;\n  if (clampToGround || disableDepthTestDistance > 0.0) {\n    billboardCollection._shaderDisableDepthDistance = true;\n    if (disableDepthTestDistance === Number.POSITIVE_INFINITY) {\n      disableDepthTestDistance = -1.0;\n    }\n  }\n  let imageHeight;\n  let imageWidth;\n  if (!defined(billboard._labelDimensions)) {\n    imageWidth = billboard.width ?? 0;\n    imageHeight = billboard.height ?? 0;\n  } else {\n    imageWidth = billboard._labelDimensions.x;\n    imageHeight = billboard._labelDimensions.y;\n  }\n  const w = Math.floor(CesiumMath.clamp(imageWidth, 0.0, LEFT_SHIFT12));\n  const h = Math.floor(CesiumMath.clamp(imageHeight, 0.0, LEFT_SHIFT12));\n  const dimensions = w * LEFT_SHIFT12 + h;\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, near, far, disableDepthTestDistance, dimensions);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, near, far, disableDepthTestDistance, dimensions);\n    writer(i + 1, near, far, disableDepthTestDistance, dimensions);\n    writer(i + 2, near, far, disableDepthTestDistance, dimensions);\n    writer(i + 3, near, far, disableDepthTestDistance, dimensions);\n  }\n}\nfunction writeTextureCoordinateBoundsOrLabelTranslate(billboardCollection, frameState, vafWriters, billboard) {\n  if (isHeightReferenceClamp(billboard.heightReference)) {\n    const scene = billboardCollection._scene;\n    const context = frameState.context;\n    const globeTranslucent = frameState.globeTranslucencyState.translucent;\n    const depthTestAgainstTerrain = defined(scene.globe) && scene.globe.depthTestAgainstTerrain;\n\n    // Only do manual depth test if the globe is opaque and writes depth\n    billboardCollection._shaderClampToGround = context.depthTexture && !globeTranslucent && depthTestAgainstTerrain;\n  }\n  let i;\n  const writer = vafWriters[attributeLocations.textureCoordinateBoundsOrLabelTranslate];\n  if (ContextLimits.maximumVertexTextureImageUnits > 0) {\n    //write _labelTranslate, used by depth testing in the vertex shader\n    let translateX = 0;\n    let translateY = 0;\n    if (defined(billboard._labelTranslate)) {\n      translateX = billboard._labelTranslate.x;\n      translateY = billboard._labelTranslate.y;\n    }\n    if (billboardCollection._instanced) {\n      i = billboard._index;\n      writer(i, translateX, translateY, 0.0, 0.0);\n    } else {\n      i = billboard._index * 4;\n      writer(i + 0, translateX, translateY, 0.0, 0.0);\n      writer(i + 1, translateX, translateY, 0.0, 0.0);\n      writer(i + 2, translateX, translateY, 0.0, 0.0);\n      writer(i + 3, translateX, translateY, 0.0, 0.0);\n    }\n    return;\n  }\n\n  // Write texture coordinate bounds, used by depth testing in fragment shader\n  let minX = 0;\n  let minY = 0;\n  let width = 0;\n  let height = 0;\n  if (billboard.ready) {\n    const imageRectangle = billboard.computeTextureCoordinates(scratchBoundingRectangle);\n    minX = imageRectangle.x;\n    minY = imageRectangle.y;\n    width = imageRectangle.width;\n    height = imageRectangle.height;\n  }\n  const maxX = minX + width;\n  const maxY = minY + height;\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, minX, minY, maxX, maxY);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, minX, minY, maxX, maxY);\n    writer(i + 1, minX, minY, maxX, maxY);\n    writer(i + 2, minX, minY, maxX, maxY);\n    writer(i + 3, minX, minY, maxX, maxY);\n  }\n}\nfunction writeBatchId(billboardCollection, frameState, vafWriters, billboard) {\n  if (!defined(billboardCollection._batchTable)) {\n    return;\n  }\n  const writer = vafWriters[attributeLocations.a_batchId];\n  const id = billboard._batchIndex;\n  let i;\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, id);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, id);\n    writer(i + 1, id);\n    writer(i + 2, id);\n    writer(i + 3, id);\n  }\n}\nfunction writeSDF(billboardCollection, frameState, vafWriters, billboard) {\n  if (!billboardCollection._sdf) {\n    return;\n  }\n  let i;\n  const writer = vafWriters[attributeLocations.sdf];\n  const outlineColor = billboard.outlineColor;\n  const outlineWidth = billboard.outlineWidth;\n  const red = Color.floatToByte(outlineColor.red);\n  const green = Color.floatToByte(outlineColor.green);\n  const blue = Color.floatToByte(outlineColor.blue);\n  const compressed0 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n\n  // Compute the relative outline distance\n  const outlineDistance = outlineWidth / SDFSettings.RADIUS;\n  const compressed1 = Color.floatToByte(outlineColor.alpha) * LEFT_SHIFT16 + Color.floatToByte(outlineDistance) * LEFT_SHIFT8;\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, compressed0, compressed1);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, compressed0 + LOWER_LEFT, compressed1);\n    writer(i + 1, compressed0 + LOWER_RIGHT, compressed1);\n    writer(i + 2, compressed0 + UPPER_RIGHT, compressed1);\n    writer(i + 3, compressed0 + UPPER_LEFT, compressed1);\n  }\n}\nfunction writeSplitDirection(billboardCollection, frameState, vafWriters, billboard) {\n  const writer = vafWriters[attributeLocations.splitDirection];\n  let direction = 0.0;\n  const split = billboard.splitDirection;\n  if (defined(split)) {\n    direction = split;\n  }\n  let i;\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, direction);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, direction);\n    writer(i + 1, direction);\n    writer(i + 2, direction);\n    writer(i + 3, direction);\n  }\n}\nfunction writeBillboard(billboardCollection, frameState, vafWriters, billboard) {\n  writePositionScaleAndRotation(billboardCollection, frameState, vafWriters, billboard);\n  writeCompressedAttrib0(billboardCollection, frameState, vafWriters, billboard);\n  writeCompressedAttrib1(billboardCollection, frameState, vafWriters, billboard);\n  writeCompressedAttrib2(billboardCollection, frameState, vafWriters, billboard);\n  writeEyeOffset(billboardCollection, frameState, vafWriters, billboard);\n  writeScaleByDistance(billboardCollection, frameState, vafWriters, billboard);\n  writePixelOffsetScaleByDistance(billboardCollection, frameState, vafWriters, billboard);\n  writeCompressedAttribute3(billboardCollection, frameState, vafWriters, billboard);\n  writeTextureCoordinateBoundsOrLabelTranslate(billboardCollection, frameState, vafWriters, billboard);\n  writeBatchId(billboardCollection, frameState, vafWriters, billboard);\n  writeSDF(billboardCollection, frameState, vafWriters, billboard);\n  writeSplitDirection(billboardCollection, frameState, vafWriters, billboard);\n}\nfunction recomputeActualPositions(billboardCollection, billboards, length, frameState, modelMatrix, recomputeBoundingVolume) {\n  let boundingVolume;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingVolume = billboardCollection._baseVolume;\n    billboardCollection._boundingVolumeDirty = true;\n  } else {\n    boundingVolume = billboardCollection._baseVolume2D;\n  }\n  const positions = [];\n  for (let i = 0; i < length; ++i) {\n    const billboard = billboards[i];\n    const position = billboard.position;\n    const actualPosition = Billboard._computeActualPosition(billboard, position, frameState, modelMatrix);\n    if (defined(actualPosition)) {\n      billboard._setActualPosition(actualPosition);\n      if (recomputeBoundingVolume) {\n        positions.push(actualPosition);\n      } else {\n        BoundingSphere.expand(boundingVolume, actualPosition, boundingVolume);\n      }\n    }\n  }\n  if (recomputeBoundingVolume) {\n    BoundingSphere.fromPoints(positions, boundingVolume);\n  }\n}\nfunction updateMode(billboardCollection, frameState) {\n  const mode = frameState.mode;\n  const billboards = billboardCollection._billboards;\n  const billboardsToUpdate = billboardCollection._billboardsToUpdate;\n  const modelMatrix = billboardCollection._modelMatrix;\n  if (billboardCollection._createVertexArray || billboardCollection._mode !== mode || mode !== SceneMode.SCENE3D && !Matrix4.equals(modelMatrix, billboardCollection.modelMatrix)) {\n    billboardCollection._mode = mode;\n    Matrix4.clone(billboardCollection.modelMatrix, modelMatrix);\n    billboardCollection._createVertexArray = true;\n    if (mode === SceneMode.SCENE3D || mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {\n      recomputeActualPositions(billboardCollection, billboards, billboards.length, frameState, modelMatrix, true);\n    }\n  } else if (mode === SceneMode.MORPHING) {\n    recomputeActualPositions(billboardCollection, billboards, billboards.length, frameState, modelMatrix, true);\n  } else if (mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {\n    recomputeActualPositions(billboardCollection, billboardsToUpdate, billboardCollection._billboardsToUpdateIndex, frameState, modelMatrix, false);\n  }\n}\nfunction updateBoundingVolume(collection, frameState, boundingVolume) {\n  let pixelScale = 1.0;\n  if (!collection._allSizedInMeters || collection._maxPixelOffset !== 0.0) {\n    pixelScale = frameState.camera.getPixelSize(boundingVolume, frameState.context.drawingBufferWidth, frameState.context.drawingBufferHeight);\n  }\n  let size = pixelScale * collection._maxScale * collection._maxSize * 2.0;\n  if (collection._allHorizontalCenter && collection._allVerticalCenter) {\n    size *= 0.5;\n  }\n  const offset = pixelScale * collection._maxPixelOffset + collection._maxEyeOffset;\n  boundingVolume.radius += size + offset;\n}\nfunction createDebugCommand(billboardCollection, context) {\n  const fs = \"uniform sampler2D billboard_texture; \\n\" + \"in vec2 v_textureCoordinates; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    out_FragColor = texture(billboard_texture, v_textureCoordinates); \\n\" + \"} \\n\";\n  const drawCommand = context.createViewportQuadCommand(fs, {\n    uniformMap: {\n      billboard_texture: function () {\n        return billboardCollection.textureAtlas.texture;\n      }\n    }\n  });\n  drawCommand.pass = Pass.OVERLAY;\n  return drawCommand;\n}\nconst scratchWriterArray = [];\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {RuntimeError} image with id must be in the atlas.\n */\nBillboardCollection.prototype.update = function (frameState) {\n  removeBillboards(this);\n  if (!this.show) {\n    return;\n  }\n  const context = frameState.context;\n  this._instanced = context.instancedArrays;\n  attributeLocations = this._instanced ? attributeLocationsInstanced : attributeLocationsBatched;\n  getIndexBuffer = this._instanced ? getIndexBufferInstanced : getIndexBufferBatched;\n  let billboards = this._billboards;\n  let billboardsLength = billboards.length;\n  let allBillboardsReady = true;\n  for (let i = 0; i < billboardsLength; ++i) {\n    const billboard = billboards[i];\n    if (defined(billboard.loadError)) {\n      console.error(`Error loading image for billboard: ${billboard.loadError}`);\n      billboard.image = undefined;\n    }\n    if (billboard.textureDirty) {\n      this._updateBillboard(billboard, IMAGE_INDEX_INDEX);\n    }\n    if (billboard.show) {\n      allBillboardsReady = allBillboardsReady && billboard.ready;\n    }\n  }\n\n  // Queue any texture resource updates for after the frame is rendered\n  const textureAtlas = this._textureAtlas;\n  frameState.afterRender.push(() => {\n    if (this.isDestroyed()) {\n      return;\n    }\n    return textureAtlas.update(frameState.context);\n  });\n  if (!defined(textureAtlas.texture)) {\n    // Can't write billboard vertices until the texture atlas\n    // has been updated once\n    return;\n  }\n  updateMode(this, frameState);\n  billboards = this._billboards;\n  billboardsLength = billboards.length;\n  const billboardsToUpdate = this._billboardsToUpdate;\n  const billboardsToUpdateLength = this._billboardsToUpdateIndex;\n  const properties = this._propertiesChanged;\n  const textureAtlasGUID = textureAtlas.guid;\n  const createVertexArray = this._createVertexArray || this._textureAtlasGUID !== textureAtlasGUID;\n  this._textureAtlasGUID = textureAtlasGUID;\n  let vafWriters;\n  const pass = frameState.passes;\n  const picking = pass.pick;\n\n  // PERFORMANCE_IDEA: Round robin multiple buffers.\n  if (createVertexArray || !picking && this.computeNewBuffersUsage()) {\n    this._createVertexArray = false;\n    for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n      properties[k] = 0;\n    }\n    this._vaf = this._vaf && this._vaf.destroy();\n    if (billboardsLength > 0) {\n      // PERFORMANCE_IDEA:  Instead of creating a new one, resize like std::vector.\n      this._vaf = createVAF(context, billboardsLength, this._buffersUsage, this._instanced, this._batchTable, this._sdf);\n      vafWriters = this._vaf.writers;\n\n      // Rewrite entire buffer if billboards were added or removed.\n      for (let i = 0; i < billboardsLength; ++i) {\n        const billboard = this._billboards[i];\n        billboard._dirty = false; // In case it needed an update.\n        billboard.textureDirty = false;\n        writeBillboard(this, frameState, vafWriters, billboard);\n      }\n\n      // Different billboard collections share the same index buffer.\n      this._vaf.commit(getIndexBuffer(context));\n    }\n    this._billboardsToUpdateIndex = 0;\n  } else if (billboardsToUpdateLength > 0) {\n    // Billboards were modified, but none were added or removed.\n    const writers = scratchWriterArray;\n    writers.length = 0;\n    if (properties[POSITION_INDEX] || properties[ROTATION_INDEX] || properties[SCALE_INDEX]) {\n      writers.push(writePositionScaleAndRotation);\n    }\n    if (properties[IMAGE_INDEX_INDEX] || properties[PIXEL_OFFSET_INDEX] || properties[HORIZONTAL_ORIGIN_INDEX] || properties[VERTICAL_ORIGIN_INDEX] || properties[SHOW_INDEX]) {\n      writers.push(writeCompressedAttrib0);\n      if (this._instanced) {\n        writers.push(writeEyeOffset);\n      }\n    }\n    if (properties[IMAGE_INDEX_INDEX] || properties[ALIGNED_AXIS_INDEX] || properties[TRANSLUCENCY_BY_DISTANCE_INDEX]) {\n      writers.push(writeCompressedAttrib1);\n      writers.push(writeCompressedAttrib2);\n    }\n    if (properties[IMAGE_INDEX_INDEX] || properties[COLOR_INDEX]) {\n      writers.push(writeCompressedAttrib2);\n    }\n    if (properties[IMAGE_INDEX_INDEX] || properties[EYE_OFFSET_INDEX]) {\n      writers.push(writeEyeOffset);\n    }\n    if (properties[SCALE_BY_DISTANCE_INDEX]) {\n      writers.push(writeScaleByDistance);\n    }\n    if (properties[PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX]) {\n      writers.push(writePixelOffsetScaleByDistance);\n    }\n    if (properties[DISTANCE_DISPLAY_CONDITION_INDEX] || properties[DISABLE_DEPTH_DISTANCE] || properties[IMAGE_INDEX_INDEX] || properties[POSITION_INDEX]) {\n      writers.push(writeCompressedAttribute3);\n    }\n    if (properties[IMAGE_INDEX_INDEX] || properties[POSITION_INDEX]) {\n      writers.push(writeTextureCoordinateBoundsOrLabelTranslate);\n    }\n    if (properties[SDF_INDEX]) {\n      writers.push(writeSDF);\n    }\n    if (properties[SPLIT_DIRECTION_INDEX]) {\n      writers.push(writeSplitDirection);\n    }\n    const numWriters = writers.length;\n    vafWriters = this._vaf.writers;\n    if (billboardsToUpdateLength / billboardsLength > 0.1) {\n      // If more than 10% of billboard change, rewrite the entire buffer.\n\n      // PERFORMANCE_IDEA:  I totally made up 10% :).\n\n      for (let m = 0; m < billboardsToUpdateLength; ++m) {\n        const b = billboardsToUpdate[m];\n        b._dirty = false;\n        b.textureDirty = false;\n        for (let n = 0; n < numWriters; ++n) {\n          writers[n](this, frameState, vafWriters, b);\n        }\n      }\n      this._vaf.commit(getIndexBuffer(context));\n    } else {\n      for (let h = 0; h < billboardsToUpdateLength; ++h) {\n        const bb = billboardsToUpdate[h];\n        bb._dirty = false;\n        bb.textureDirty = false;\n        for (let o = 0; o < numWriters; ++o) {\n          writers[o](this, frameState, vafWriters, bb);\n        }\n        if (this._instanced) {\n          this._vaf.subCommit(bb._index, 1);\n        } else {\n          this._vaf.subCommit(bb._index * 4, 4);\n        }\n      }\n      this._vaf.endSubCommits();\n    }\n    this._billboardsToUpdateIndex = 0;\n  }\n\n  // If the number of total billboards ever shrinks considerably\n  // Truncate billboardsToUpdate so that we free memory that we're\n  // not going to be using.\n  if (billboardsToUpdateLength > billboardsLength * 1.5) {\n    billboardsToUpdate.length = billboardsLength;\n  }\n  if (!defined(this._vaf) || !defined(this._vaf.va)) {\n    return;\n  }\n  if (this._boundingVolumeDirty) {\n    this._boundingVolumeDirty = false;\n    BoundingSphere.transform(this._baseVolume, this.modelMatrix, this._baseVolumeWC);\n  }\n  let boundingVolume;\n  let modelMatrix = Matrix4.IDENTITY;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    modelMatrix = this.modelMatrix;\n    boundingVolume = BoundingSphere.clone(this._baseVolumeWC, this._boundingVolume);\n  } else {\n    boundingVolume = BoundingSphere.clone(this._baseVolume2D, this._boundingVolume);\n  }\n  updateBoundingVolume(this, frameState, boundingVolume);\n  const blendOptionChanged = this._blendOption !== this.blendOption;\n  this._blendOption = this.blendOption;\n  if (blendOptionChanged) {\n    if (this._blendOption === BlendOption.OPAQUE || this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT) {\n      this._rsOpaque = RenderState.fromCache({\n        depthTest: {\n          enabled: true,\n          func: WebGLConstants.LESS\n        },\n        depthMask: true\n      });\n    } else {\n      this._rsOpaque = undefined;\n    }\n\n    // If OPAQUE_AND_TRANSLUCENT is in use, only the opaque pass gets the benefit of the depth buffer,\n    // not the translucent pass.  Otherwise, if the TRANSLUCENT pass is on its own, it turns on\n    // a depthMask in lieu of full depth sorting (because it has opaque-ish fragments that look bad in OIT).\n    // When the TRANSLUCENT depth mask is in use, label backgrounds require the depth func to be LEQUAL.\n    const useTranslucentDepthMask = this._blendOption === BlendOption.TRANSLUCENT;\n    if (this._blendOption === BlendOption.TRANSLUCENT || this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT) {\n      this._rsTranslucent = RenderState.fromCache({\n        depthTest: {\n          enabled: true,\n          func: useTranslucentDepthMask ? WebGLConstants.LEQUAL : WebGLConstants.LESS\n        },\n        depthMask: useTranslucentDepthMask,\n        blending: BlendingState.ALPHA_BLEND\n      });\n    } else {\n      this._rsTranslucent = undefined;\n    }\n  }\n  this._shaderDisableDepthDistance = this._shaderDisableDepthDistance || frameState.minimumDisableDepthTestDistance !== 0.0;\n  let vsSource;\n  let fsSource;\n  let vs;\n  let fs;\n  let vertDefines;\n  const supportVSTextureReads = ContextLimits.maximumVertexTextureImageUnits > 0;\n  if (blendOptionChanged || this._shaderRotation !== this._compiledShaderRotation || this._shaderAlignedAxis !== this._compiledShaderAlignedAxis || this._shaderScaleByDistance !== this._compiledShaderScaleByDistance || this._shaderTranslucencyByDistance !== this._compiledShaderTranslucencyByDistance || this._shaderPixelOffsetScaleByDistance !== this._compiledShaderPixelOffsetScaleByDistance || this._shaderDistanceDisplayCondition !== this._compiledShaderDistanceDisplayCondition || this._shaderDisableDepthDistance !== this._compiledShaderDisableDepthDistance || this._shaderClampToGround !== this._compiledShaderClampToGround || this._sdf !== this._compiledSDF) {\n    vsSource = BillboardCollectionVS;\n    fsSource = BillboardCollectionFS;\n    vertDefines = [];\n    if (defined(this._batchTable)) {\n      vertDefines.push(\"VECTOR_TILE\");\n      vsSource = this._batchTable.getVertexShaderCallback(false, \"a_batchId\", undefined)(vsSource);\n      fsSource = this._batchTable.getFragmentShaderCallback(false, undefined)(fsSource);\n    }\n    vs = new ShaderSource({\n      defines: vertDefines,\n      sources: [vsSource]\n    });\n    if (this._instanced) {\n      vs.defines.push(\"INSTANCED\");\n    }\n    if (this._shaderRotation) {\n      vs.defines.push(\"ROTATION\");\n    }\n    if (this._shaderAlignedAxis) {\n      vs.defines.push(\"ALIGNED_AXIS\");\n    }\n    if (this._shaderScaleByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_SCALING\");\n    }\n    if (this._shaderTranslucencyByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_TRANSLUCENCY\");\n    }\n    if (this._shaderPixelOffsetScaleByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_PIXEL_OFFSET\");\n    }\n    if (this._shaderDistanceDisplayCondition) {\n      vs.defines.push(\"DISTANCE_DISPLAY_CONDITION\");\n    }\n    if (this._shaderDisableDepthDistance) {\n      vs.defines.push(\"DISABLE_DEPTH_DISTANCE\");\n    }\n    if (this._shaderClampToGround) {\n      if (supportVSTextureReads) {\n        vs.defines.push(\"VERTEX_DEPTH_CHECK\");\n      } else {\n        vs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n      }\n    }\n    const sdfEdge = 1.0 - SDFSettings.CUTOFF;\n    if (this._sdf) {\n      vs.defines.push(\"SDF\");\n    }\n    const vectorFragDefine = defined(this._batchTable) ? \"VECTOR_TILE\" : \"\";\n    if (this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT) {\n      fs = new ShaderSource({\n        defines: [\"OPAQUE\", vectorFragDefine],\n        sources: [fsSource]\n      });\n      if (this._shaderClampToGround) {\n        if (supportVSTextureReads) {\n          fs.defines.push(\"VERTEX_DEPTH_CHECK\");\n        } else {\n          fs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n        }\n      }\n      if (this._sdf) {\n        fs.defines.push(\"SDF\");\n        fs.defines.push(`SDF_EDGE ${sdfEdge}`);\n      }\n      this._sp = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._sp,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations\n      });\n      fs = new ShaderSource({\n        defines: [\"TRANSLUCENT\", vectorFragDefine],\n        sources: [fsSource]\n      });\n      if (this._shaderClampToGround) {\n        if (supportVSTextureReads) {\n          fs.defines.push(\"VERTEX_DEPTH_CHECK\");\n        } else {\n          fs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n        }\n      }\n      if (this._sdf) {\n        fs.defines.push(\"SDF\");\n        fs.defines.push(`SDF_EDGE ${sdfEdge}`);\n      }\n      this._spTranslucent = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._spTranslucent,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations\n      });\n    }\n    if (this._blendOption === BlendOption.OPAQUE) {\n      fs = new ShaderSource({\n        defines: [vectorFragDefine],\n        sources: [fsSource]\n      });\n      if (this._shaderClampToGround) {\n        if (supportVSTextureReads) {\n          fs.defines.push(\"VERTEX_DEPTH_CHECK\");\n        } else {\n          fs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n        }\n      }\n      if (this._sdf) {\n        fs.defines.push(\"SDF\");\n        fs.defines.push(`SDF_EDGE ${sdfEdge}`);\n      }\n      this._sp = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._sp,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations\n      });\n    }\n    if (this._blendOption === BlendOption.TRANSLUCENT) {\n      fs = new ShaderSource({\n        defines: [vectorFragDefine],\n        sources: [fsSource]\n      });\n      if (this._shaderClampToGround) {\n        if (supportVSTextureReads) {\n          fs.defines.push(\"VERTEX_DEPTH_CHECK\");\n        } else {\n          fs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n        }\n      }\n      if (this._sdf) {\n        fs.defines.push(\"SDF\");\n        fs.defines.push(`SDF_EDGE ${sdfEdge}`);\n      }\n      this._spTranslucent = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._spTranslucent,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations\n      });\n    }\n    this._compiledShaderRotation = this._shaderRotation;\n    this._compiledShaderAlignedAxis = this._shaderAlignedAxis;\n    this._compiledShaderScaleByDistance = this._shaderScaleByDistance;\n    this._compiledShaderTranslucencyByDistance = this._shaderTranslucencyByDistance;\n    this._compiledShaderPixelOffsetScaleByDistance = this._shaderPixelOffsetScaleByDistance;\n    this._compiledShaderDistanceDisplayCondition = this._shaderDistanceDisplayCondition;\n    this._compiledShaderDisableDepthDistance = this._shaderDisableDepthDistance;\n    this._compiledShaderClampToGround = this._shaderClampToGround;\n    this._compiledSDF = this._sdf;\n  }\n  const commandList = frameState.commandList;\n  if (pass.render || pass.pick) {\n    const colorList = this._colorCommands;\n    const opaque = this._blendOption === BlendOption.OPAQUE;\n    const opaqueAndTranslucent = this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT;\n    const va = this._vaf.va;\n    const vaLength = va.length;\n    let uniforms = this._uniforms;\n    let pickId;\n    if (defined(this._batchTable)) {\n      uniforms = this._batchTable.getUniformMapCallback()(uniforms);\n      pickId = this._batchTable.getPickId();\n    } else {\n      pickId = \"v_pickColor\";\n    }\n    colorList.length = vaLength;\n    const totalLength = opaqueAndTranslucent ? vaLength * 2 : vaLength;\n    for (let j = 0; j < totalLength; ++j) {\n      let command = colorList[j];\n      if (!defined(command)) {\n        command = colorList[j] = new DrawCommand();\n      }\n      const opaqueCommand = opaque || opaqueAndTranslucent && j % 2 === 0;\n      command.pass = opaqueCommand || !opaqueAndTranslucent ? Pass.OPAQUE : Pass.TRANSLUCENT;\n      command.owner = this;\n      const index = opaqueAndTranslucent ? Math.floor(j / 2.0) : j;\n      command.boundingVolume = boundingVolume;\n      command.modelMatrix = modelMatrix;\n      command.count = va[index].indicesCount;\n      command.shaderProgram = opaqueCommand ? this._sp : this._spTranslucent;\n      command.uniformMap = uniforms;\n      command.vertexArray = va[index].va;\n      command.renderState = opaqueCommand ? this._rsOpaque : this._rsTranslucent;\n      command.debugShowBoundingVolume = this.debugShowBoundingVolume;\n      command.pickId = pickId;\n      if (this._instanced) {\n        command.count = 6;\n        command.instanceCount = billboardsLength;\n      }\n      commandList.push(command);\n    }\n    if (this.debugShowTextureAtlas) {\n      if (!defined(this.debugCommand)) {\n        this.debugCommand = createDebugCommand(this, frameState.context);\n      }\n      commandList.push(this.debugCommand);\n    }\n  }\n  this._allBillboardsReady = allBillboardsReady;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see BillboardCollection#destroy\n */\nBillboardCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * billboards = billboards && billboards.destroy();\n *\n * @see BillboardCollection#isDestroyed\n */\nBillboardCollection.prototype.destroy = function () {\n  if (defined(this._removeCallbackFunc)) {\n    this._removeCallbackFunc();\n    this._removeCallbackFunc = undefined;\n  }\n  this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy();\n  this._sp = this._sp && this._sp.destroy();\n  this._spTranslucent = this._spTranslucent && this._spTranslucent.destroy();\n  this._vaf = this._vaf && this._vaf.destroy();\n  destroyBillboards(this._billboards);\n  return destroyObject(this);\n};\nexport default BillboardCollection;","map":{"version":3,"names":["AttributeCompression","BoundingRectangle","BoundingSphere","Cartesian2","Cartesian3","Check","Color","ComponentDatatype","Frozen","defined","destroyObject","EncodedCartesian3","IndexDatatype","CesiumMath","Matrix4","WebGLConstants","Buffer","BufferUsage","ContextLimits","DrawCommand","Pass","RenderState","ShaderProgram","ShaderSource","VertexArrayFacade","BillboardCollectionFS","BillboardCollectionVS","Billboard","BlendingState","BlendOption","HeightReference","isHeightReferenceClamp","HorizontalOrigin","SceneMode","SDFSettings","TextureAtlas","VerticalOrigin","SHOW_INDEX","POSITION_INDEX","PIXEL_OFFSET_INDEX","EYE_OFFSET_INDEX","HORIZONTAL_ORIGIN_INDEX","VERTICAL_ORIGIN_INDEX","SCALE_INDEX","IMAGE_INDEX_INDEX","COLOR_INDEX","ROTATION_INDEX","ALIGNED_AXIS_INDEX","SCALE_BY_DISTANCE_INDEX","TRANSLUCENCY_BY_DISTANCE_INDEX","PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX","DISTANCE_DISPLAY_CONDITION_INDEX","DISTANCE_DISPLAY_CONDITION","DISABLE_DEPTH_DISTANCE","TEXTURE_COORDINATE_BOUNDS","SDF_INDEX","SPLIT_DIRECTION_INDEX","NUMBER_OF_PROPERTIES","attributeLocations","attributeLocationsBatched","positionHighAndScale","positionLowAndRotation","compressedAttribute0","compressedAttribute1","compressedAttribute2","eyeOffset","scaleByDistance","pixelOffsetScaleByDistance","compressedAttribute3","textureCoordinateBoundsOrLabelTranslate","a_batchId","sdf","splitDirection","attributeLocationsInstanced","direction","BillboardCollection","options","EMPTY_OBJECT","_scene","scene","_batchTable","batchTable","textureAtlas","_textureAtlas","_textureAtlasGUID","guid","_destroyTextureAtlas","_billboardTextureCache","Map","_sp","undefined","_spTranslucent","_rsOpaque","_rsTranslucent","_vaf","_billboards","_billboardsToUpdate","_billboardsToUpdateIndex","_billboardsRemoved","_createVertexArray","_shaderRotation","_compiledShaderRotation","_shaderAlignedAxis","_compiledShaderAlignedAxis","_shaderScaleByDistance","_compiledShaderScaleByDistance","_shaderTranslucencyByDistance","_compiledShaderTranslucencyByDistance","_shaderPixelOffsetScaleByDistance","_compiledShaderPixelOffsetScaleByDistance","_shaderDistanceDisplayCondition","_compiledShaderDistanceDisplayCondition","_shaderDisableDepthDistance","_compiledShaderDisableDepthDistance","_shaderClampToGround","_compiledShaderClampToGround","_propertiesChanged","Uint32Array","_maxSize","_maxEyeOffset","_maxScale","_maxPixelOffset","_allHorizontalCenter","_allVerticalCenter","_allSizedInMeters","_baseVolume","_baseVolumeWC","_baseVolume2D","_boundingVolume","_boundingVolumeDirty","_colorCommands","_allBillboardsReady","show","modelMatrix","clone","IDENTITY","_modelMatrix","debugShowBoundingVolume","debugShowTextureAtlas","blendOption","OPAQUE_AND_TRANSLUCENT","_blendOption","_mode","SCENE3D","_buffersUsage","STATIC_DRAW","_highlightColor","WHITE","_uniforms","u_atlas","texture","u_highlightColor","terrainProviderChanged","_removeCallbackFunc","addEventListener","billboards","length","i","_updateClamping","Object","defineProperties","prototype","get","removeBillboards","set","value","destroy","destroyTextureAtlas","sizeInBytes","ready","billboardTextureCache","destroyBillboards","_destroy","add","billboard","_index","push","remove","contains","removeAll","billboardCollection","newBillboards","j","_updateBillboard","propertyChanged","_dirty","_billboardCollection","index","typeOf","number","getIndexBuffer","getIndexBufferBatched","context","sixteenK","indexBuffer","cache","billboardCollection_indexBufferBatched","indices","Uint16Array","createIndexBuffer","typedArray","usage","indexDatatype","UNSIGNED_SHORT","vertexArrayDestroyable","getIndexBufferInstanced","billboardCollection_indexBufferInstanced","getVertexBufferInstanced","vertexBuffer","billboardCollection_vertexBufferInstanced","createVertexBuffer","Float32Array","computeNewBuffersUsage","buffersUsage","usageChanged","properties","k","newUsage","STREAM_DRAW","createVAF","numberOfBillboards","instanced","attributes","componentsPerAttribute","componentDatatype","FLOAT","bufferUsage","sizeInVertices","writePositionScratch","writePositionScaleAndRotation","frameState","vafWriters","positionHighWriter","positionLowWriter","position","_getActualPosition","expand","fromCartesian","scale","rotation","Math","max","high","low","_instanced","x","y","z","scratchCartesian2","UPPER_BOUND","LEFT_SHIFT16","LEFT_SHIFT12","LEFT_SHIFT8","LEFT_SHIFT7","LEFT_SHIFT5","LEFT_SHIFT3","LEFT_SHIFT2","RIGHT_SHIFT8","LOWER_LEFT","LOWER_RIGHT","UPPER_RIGHT","UPPER_LEFT","scratchBoundingRectangle","writeCompressedAttrib0","writer","pixelOffset","pixelOffsetX","pixelOffsetY","translate","_translate","translateX","translateY","abs","horizontalOrigin","verticalOrigin","_verticalOrigin","clusterShow","color","alpha","BASELINE","BOTTOM","CENTER","bottomLeftX","bottomLeftY","width","height","imageRectangle","computeTextureCoordinates","topRightX","topRightY","compressed0","floor","clamp","compressed1","compressed2","tempTanslateY","upperTranslateY","lowerTranslateY","compressedTexCoordsLL","compressTextureCoordinates","compressedTexCoordsLR","compressedTexCoordsUR","compressedTexCoordsUL","writeCompressedAttrib1","alignedAxis","equals","ZERO","near","nearValue","far","farValue","translucency","translucencyByDistance","imageWidth","round","magnitudeSquared","EPSILON6","octEncodeFloat","writeCompressedAttrib2","pickColor","getPickId","sizeInMeters","validAlignedAxis","imageHeight","labelHorizontalOrigin","_labelHorizontalOrigin","compressed3","red","floatToByte","green","blue","writeEyeOffset","eyeOffsetZ","_heightReference","NONE","compressedTexCoordsRange","writeScaleByDistance","writePixelOffsetScaleByDistance","pixelOffsetScale","writeCompressedAttribute3","Number","MAX_VALUE","distanceDisplayCondition","disableDepthTestDistance","clampToGround","heightReference","depthTexture","POSITIVE_INFINITY","_labelDimensions","w","h","dimensions","writeTextureCoordinateBoundsOrLabelTranslate","globeTranslucent","globeTranslucencyState","translucent","depthTestAgainstTerrain","globe","maximumVertexTextureImageUnits","_labelTranslate","minX","minY","maxX","maxY","writeBatchId","id","_batchIndex","writeSDF","_sdf","outlineColor","outlineWidth","outlineDistance","RADIUS","writeSplitDirection","split","writeBillboard","recomputeActualPositions","recomputeBoundingVolume","boundingVolume","mode","positions","actualPosition","_computeActualPosition","_setActualPosition","fromPoints","updateMode","billboardsToUpdate","SCENE2D","COLUMBUS_VIEW","MORPHING","updateBoundingVolume","collection","pixelScale","camera","getPixelSize","drawingBufferWidth","drawingBufferHeight","size","offset","radius","createDebugCommand","fs","drawCommand","createViewportQuadCommand","uniformMap","billboard_texture","pass","OVERLAY","scratchWriterArray","update","instancedArrays","billboardsLength","allBillboardsReady","loadError","console","error","image","textureDirty","afterRender","isDestroyed","billboardsToUpdateLength","textureAtlasGUID","createVertexArray","passes","picking","pick","writers","commit","numWriters","m","b","n","bb","o","subCommit","endSubCommits","va","transform","blendOptionChanged","OPAQUE","fromCache","depthTest","enabled","func","LESS","depthMask","useTranslucentDepthMask","TRANSLUCENT","LEQUAL","blending","ALPHA_BLEND","minimumDisableDepthTestDistance","vsSource","fsSource","vs","vertDefines","supportVSTextureReads","_compiledSDF","getVertexShaderCallback","getFragmentShaderCallback","defines","sources","sdfEdge","CUTOFF","vectorFragDefine","replaceCache","shaderProgram","vertexShaderSource","fragmentShaderSource","commandList","render","colorList","opaque","opaqueAndTranslucent","vaLength","uniforms","pickId","getUniformMapCallback","totalLength","command","opaqueCommand","owner","count","indicesCount","vertexArray","renderState","instanceCount","debugCommand"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/BillboardCollection.js"],"sourcesContent":["import AttributeCompression from \"../Core/AttributeCompression.js\";\nimport BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArrayFacade from \"../Renderer/VertexArrayFacade.js\";\nimport BillboardCollectionFS from \"../Shaders/BillboardCollectionFS.js\";\nimport BillboardCollectionVS from \"../Shaders/BillboardCollectionVS.js\";\nimport Billboard from \"./Billboard.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport BlendOption from \"./BlendOption.js\";\nimport HeightReference, { isHeightReferenceClamp } from \"./HeightReference.js\";\nimport HorizontalOrigin from \"./HorizontalOrigin.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SDFSettings from \"./SDFSettings.js\";\nimport TextureAtlas from \"../Renderer/TextureAtlas.js\";\nimport VerticalOrigin from \"./VerticalOrigin.js\";\n\nconst SHOW_INDEX = Billboard.SHOW_INDEX;\nconst POSITION_INDEX = Billboard.POSITION_INDEX;\nconst PIXEL_OFFSET_INDEX = Billboard.PIXEL_OFFSET_INDEX;\nconst EYE_OFFSET_INDEX = Billboard.EYE_OFFSET_INDEX;\nconst HORIZONTAL_ORIGIN_INDEX = Billboard.HORIZONTAL_ORIGIN_INDEX;\nconst VERTICAL_ORIGIN_INDEX = Billboard.VERTICAL_ORIGIN_INDEX;\nconst SCALE_INDEX = Billboard.SCALE_INDEX;\nconst IMAGE_INDEX_INDEX = Billboard.IMAGE_INDEX_INDEX;\nconst COLOR_INDEX = Billboard.COLOR_INDEX;\nconst ROTATION_INDEX = Billboard.ROTATION_INDEX;\nconst ALIGNED_AXIS_INDEX = Billboard.ALIGNED_AXIS_INDEX;\nconst SCALE_BY_DISTANCE_INDEX = Billboard.SCALE_BY_DISTANCE_INDEX;\nconst TRANSLUCENCY_BY_DISTANCE_INDEX = Billboard.TRANSLUCENCY_BY_DISTANCE_INDEX;\nconst PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX =\n  Billboard.PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX;\nconst DISTANCE_DISPLAY_CONDITION_INDEX = Billboard.DISTANCE_DISPLAY_CONDITION;\nconst DISABLE_DEPTH_DISTANCE = Billboard.DISABLE_DEPTH_DISTANCE;\nconst TEXTURE_COORDINATE_BOUNDS = Billboard.TEXTURE_COORDINATE_BOUNDS;\nconst SDF_INDEX = Billboard.SDF_INDEX;\nconst SPLIT_DIRECTION_INDEX = Billboard.SPLIT_DIRECTION_INDEX;\nconst NUMBER_OF_PROPERTIES = Billboard.NUMBER_OF_PROPERTIES;\n\nlet attributeLocations;\n\nconst attributeLocationsBatched = {\n  positionHighAndScale: 0,\n  positionLowAndRotation: 1,\n  compressedAttribute0: 2, // pixel offset, translate, horizontal origin, vertical origin, show, direction, texture coordinates\n  compressedAttribute1: 3, // aligned axis, translucency by distance, image width\n  compressedAttribute2: 4, // image height, color, pick color, size in meters, valid aligned axis, 13 bits free\n  eyeOffset: 5, // 4 bytes free\n  scaleByDistance: 6,\n  pixelOffsetScaleByDistance: 7,\n  compressedAttribute3: 8,\n  textureCoordinateBoundsOrLabelTranslate: 9,\n  a_batchId: 10,\n  sdf: 11,\n  splitDirection: 12,\n};\n\nconst attributeLocationsInstanced = {\n  direction: 0,\n  positionHighAndScale: 1,\n  positionLowAndRotation: 2, // texture offset in w\n  compressedAttribute0: 3,\n  compressedAttribute1: 4,\n  compressedAttribute2: 5,\n  eyeOffset: 6, // texture range in w\n  scaleByDistance: 7,\n  pixelOffsetScaleByDistance: 8,\n  compressedAttribute3: 9,\n  textureCoordinateBoundsOrLabelTranslate: 10,\n  a_batchId: 11,\n  sdf: 12,\n  splitDirection: 13,\n};\n\n/**\n * A renderable collection of billboards.  Billboards are viewport-aligned\n * images positioned in the 3D scene.\n * <br /><br />\n * <div align='center'>\n * <img src='Images/Billboard.png' width='400' height='300' /><br />\n * Example billboards\n * </div>\n * <br /><br />\n * Billboards are added and removed from the collection using {@link BillboardCollection#add}\n * and {@link BillboardCollection#remove}.  Billboards in a collection automatically share textures\n * for images with the same identifier.\n *\n * @alias BillboardCollection\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each billboard from model to world coordinates.\n * @param {boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {Scene} [options.scene] Must be passed in for billboards that use the height reference property or will be depth tested against the globe.\n * @param {BlendOption} [options.blendOption=BlendOption.OPAQUE_AND_TRANSLUCENT] The billboard blending option. The default\n * is used for rendering both opaque and translucent billboards. However, if either all of the billboards are completely opaque or all are completely translucent,\n * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.\n * @param {boolean} [options.show=true] Determines if the billboards in the collection will be shown.\n *\n * @performance For best performance, prefer a few collections, each with many billboards, to\n * many collections with only a few billboards each.  Organize collections so that billboards\n * with the same update frequency are in the same collection, i.e., billboards that do not\n * change should be in one collection; billboards that change every frame should be in another\n * collection; and so on.\n *\n * @see BillboardCollection#add\n * @see BillboardCollection#remove\n * @see Billboard\n * @see LabelCollection\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Billboards.html|Cesium Sandcastle Billboard Demo}\n *\n * @example\n * // Create a billboard collection with two billboards\n * const billboards = scene.primitives.add(new Cesium.BillboardCollection());\n * billboards.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   image : 'url/to/image'\n * });\n * billboards.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   image : 'url/to/another/image'\n * });\n */\nfunction BillboardCollection(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  this._scene = options.scene;\n  this._batchTable = options.batchTable;\n\n  let textureAtlas = options.textureAtlas; // Hidden option for internal use\n  if (!defined(textureAtlas)) {\n    textureAtlas = new TextureAtlas();\n  }\n  this._textureAtlas = textureAtlas;\n  this._textureAtlasGUID = textureAtlas.guid;\n  this._destroyTextureAtlas = true;\n  this._billboardTextureCache = new Map();\n\n  this._sp = undefined;\n  this._spTranslucent = undefined;\n  this._rsOpaque = undefined;\n  this._rsTranslucent = undefined;\n  this._vaf = undefined;\n\n  this._billboards = [];\n  this._billboardsToUpdate = [];\n  this._billboardsToUpdateIndex = 0;\n  this._billboardsRemoved = false;\n  this._createVertexArray = false;\n\n  this._shaderRotation = false;\n  this._compiledShaderRotation = false;\n\n  this._shaderAlignedAxis = false;\n  this._compiledShaderAlignedAxis = false;\n\n  this._shaderScaleByDistance = false;\n  this._compiledShaderScaleByDistance = false;\n\n  this._shaderTranslucencyByDistance = false;\n  this._compiledShaderTranslucencyByDistance = false;\n\n  this._shaderPixelOffsetScaleByDistance = false;\n  this._compiledShaderPixelOffsetScaleByDistance = false;\n\n  this._shaderDistanceDisplayCondition = false;\n  this._compiledShaderDistanceDisplayCondition = false;\n\n  this._shaderDisableDepthDistance = false;\n  this._compiledShaderDisableDepthDistance = false;\n\n  this._shaderClampToGround = false;\n  this._compiledShaderClampToGround = false;\n\n  this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);\n\n  this._maxSize = 0.0;\n  this._maxEyeOffset = 0.0;\n  this._maxScale = 1.0;\n  this._maxPixelOffset = 0.0;\n  this._allHorizontalCenter = true;\n  this._allVerticalCenter = true;\n  this._allSizedInMeters = true;\n\n  this._baseVolume = new BoundingSphere();\n  this._baseVolumeWC = new BoundingSphere();\n  this._baseVolume2D = new BoundingSphere();\n  this._boundingVolume = new BoundingSphere();\n  this._boundingVolumeDirty = false;\n\n  this._colorCommands = [];\n\n  this._allBillboardsReady = false;\n\n  /**\n   * Determines if billboards in this collection will be shown.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.show = options.show ?? true;\n\n  /**\n   * The 4x4 transformation matrix that transforms each billboard in this collection from model to world coordinates.\n   * When this is the identity matrix, the billboards are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   * @default {@link Matrix4.IDENTITY}\n   *\n   *\n   * @example\n   * const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * billboards.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0) // center\n   * });\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0) // east\n   * });\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0) // north\n   * });\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0) // up\n   * });\n   *\n   * @see Transforms.eastNorthUpToFixedFrame\n   */\n  this.modelMatrix = Matrix4.clone(options.modelMatrix ?? Matrix4.IDENTITY);\n  this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = options.debugShowBoundingVolume ?? false;\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the texture atlas for this BillboardCollection as a fullscreen quad.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowTextureAtlas = options.debugShowTextureAtlas ?? false;\n\n  /**\n   * The billboard blending option. The default is used for rendering both opaque and translucent billboards.\n   * However, if either all of the billboards are completely opaque or all are completely translucent,\n   * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve\n   * performance by up to 2x.\n   * @type {BlendOption}\n   * @default BlendOption.OPAQUE_AND_TRANSLUCENT\n   */\n  this.blendOption = options.blendOption ?? BlendOption.OPAQUE_AND_TRANSLUCENT;\n  this._blendOption = undefined;\n\n  this._mode = SceneMode.SCENE3D;\n\n  // The buffer usage for each attribute is determined based on the usage of the attribute over time.\n  this._buffersUsage = [\n    BufferUsage.STATIC_DRAW, // SHOW_INDEX\n    BufferUsage.STATIC_DRAW, // POSITION_INDEX\n    BufferUsage.STATIC_DRAW, // PIXEL_OFFSET_INDEX\n    BufferUsage.STATIC_DRAW, // EYE_OFFSET_INDEX\n    BufferUsage.STATIC_DRAW, // HORIZONTAL_ORIGIN_INDEX\n    BufferUsage.STATIC_DRAW, // VERTICAL_ORIGIN_INDEX\n    BufferUsage.STATIC_DRAW, // SCALE_INDEX\n    BufferUsage.STATIC_DRAW, // IMAGE_INDEX_INDEX\n    BufferUsage.STATIC_DRAW, // COLOR_INDEX\n    BufferUsage.STATIC_DRAW, // ROTATION_INDEX\n    BufferUsage.STATIC_DRAW, // ALIGNED_AXIS_INDEX\n    BufferUsage.STATIC_DRAW, // SCALE_BY_DISTANCE_INDEX\n    BufferUsage.STATIC_DRAW, // TRANSLUCENCY_BY_DISTANCE_INDEX\n    BufferUsage.STATIC_DRAW, // PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX\n    BufferUsage.STATIC_DRAW, // DISTANCE_DISPLAY_CONDITION_INDEX\n    BufferUsage.STATIC_DRAW, // TEXTURE_COORDINATE_BOUNDS\n    BufferUsage.STATIC_DRAW, // SPLIT_DIRECTION_INDEX\n  ];\n\n  this._highlightColor = Color.clone(Color.WHITE); // Only used by Vector3DTilePoints\n\n  this._uniforms = {\n    u_atlas: () => {\n      return this.textureAtlas.texture;\n    },\n    u_highlightColor: () => {\n      return this._highlightColor;\n    },\n  };\n\n  const scene = this._scene;\n  if (defined(scene) && defined(scene.terrainProviderChanged)) {\n    this._removeCallbackFunc = scene.terrainProviderChanged.addEventListener(\n      function () {\n        const billboards = this._billboards;\n        const length = billboards.length;\n        for (let i = 0; i < length; ++i) {\n          if (defined(billboards[i])) {\n            billboards[i]._updateClamping();\n          }\n        }\n      },\n      this,\n    );\n  }\n}\n\nObject.defineProperties(BillboardCollection.prototype, {\n  /**\n   * Returns the number of billboards in this collection.  This is commonly used with\n   * {@link BillboardCollection#get} to iterate over all the billboards\n   * in the collection.\n   * @memberof BillboardCollection.prototype\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      removeBillboards(this);\n      return this._billboards.length;\n    },\n  },\n\n  /**\n   * Gets or sets the textureAtlas.\n   * @memberof BillboardCollection.prototype\n   * @type {TextureAtlas}\n   * @private\n   */\n  textureAtlas: {\n    get: function () {\n      return this._textureAtlas;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"textureAtlas\", value);\n      //>>includeEnd('debug');\n\n      if (this._textureAtlas !== value) {\n        this._textureAtlas =\n          this._destroyTextureAtlas &&\n          this._textureAtlas &&\n          this._textureAtlas.destroy();\n        this._textureAtlas = value;\n      }\n    },\n  },\n\n  /**\n   * Gets or sets a value which determines if the texture atlas is\n   * destroyed when the collection is destroyed.\n   *\n   * If the texture atlas is used by more than one collection, set this to <code>false</code>,\n   * and explicitly destroy the atlas to avoid attempting to destroy it multiple times.\n   *\n   * @memberof BillboardCollection.prototype\n   * @type {boolean}\n   * @private\n   *\n   * @example\n   * // Set destroyTextureAtlas\n   * // Destroy a billboard collection but not its texture atlas.\n   *\n   * const atlas = new TextureAtlas();\n   * billboards.textureAtlas = atlas;\n   * billboards.destroyTextureAtlas = false;\n   *\n   * billboards = billboards.destroy();\n   * console.log(atlas.isDestroyed()); // False\n   */\n  destroyTextureAtlas: {\n    get: function () {\n      return this._destroyTextureAtlas;\n    },\n    set: function (value) {\n      this._destroyTextureAtlas = value;\n    },\n  },\n\n  /**\n   * Returns the size in bytes of the WebGL texture resources.\n   * @private\n   * @memberof BillboardCollection.prototype\n   * @type {number}\n   * @readonly\n   */\n  sizeInBytes: {\n    get: function () {\n      return this._textureAtlas.sizeInBytes;\n    },\n  },\n\n  /**\n   * True when all billboards currently in the collection are ready for rendering.\n   * @private\n   * @memberof BillboardCollection.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._allBillboardsReady;\n    },\n  },\n\n  /**\n   * Cache of loaded billboard images.\n   * @private\n   * @memberof BillboardCollection.prototype\n   * @type {Map<string, BillboardTexture>}\n   * @readonly\n   */\n  billboardTextureCache: {\n    get: function () {\n      return this._billboardTextureCache;\n    },\n  },\n});\n\nfunction destroyBillboards(billboards) {\n  const length = billboards.length;\n  for (let i = 0; i < length; ++i) {\n    if (billboards[i]) {\n      billboards[i]._destroy();\n    }\n  }\n}\n\n/**\n * Creates and adds a billboard with the specified initial properties to the collection.\n * The added billboard is returned so it can be modified or removed from the collection later.\n *\n * @param {Billboard.ConstructorOptions}[options] A template describing the billboard's properties as shown in Example 1.\n * @returns {Billboard} The billboard that was added to the collection.\n *\n * @performance Calling <code>add</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, add as many billboards as possible before calling <code>update</code>.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Example 1:  Add a billboard, specifying all the default values.\n * const b = billboards.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   pixelOffset : Cesium.Cartesian2.ZERO,\n *   eyeOffset : Cesium.Cartesian3.ZERO,\n *   heightReference : Cesium.HeightReference.NONE,\n *   horizontalOrigin : Cesium.HorizontalOrigin.CENTER,\n *   verticalOrigin : Cesium.VerticalOrigin.CENTER,\n *   scale : 1.0,\n *   image : 'url/to/image',\n *   imageSubRegion : undefined,\n *   color : Cesium.Color.WHITE,\n *   id : undefined,\n *   rotation : 0.0,\n *   alignedAxis : Cesium.Cartesian3.ZERO,\n *   width : undefined,\n *   height : undefined,\n *   scaleByDistance : undefined,\n *   translucencyByDistance : undefined,\n *   pixelOffsetScaleByDistance : undefined,\n *   sizeInMeters : false,\n *   distanceDisplayCondition : undefined\n * });\n *\n * @example\n * // Example 2:  Specify only the billboard's cartographic position.\n * const b = billboards.add({\n *   position : Cesium.Cartesian3.fromDegrees(longitude, latitude, height)\n * });\n *\n * @see BillboardCollection#remove\n * @see BillboardCollection#removeAll\n */\nBillboardCollection.prototype.add = function (options) {\n  const billboard = new Billboard(options, this);\n  billboard._index = this._billboards.length;\n\n  this._billboards.push(billboard);\n  this._createVertexArray = true;\n\n  return billboard;\n};\n\n/**\n * Removes a billboard from the collection.\n *\n * @param {Billboard} billboard The billboard to remove.\n * @returns {boolean} <code>true</code> if the billboard was removed; <code>false</code> if the billboard was not found in the collection.\n *\n * @performance Calling <code>remove</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, remove as many billboards as possible before calling <code>update</code>.\n * If you intend to temporarily hide a billboard, it is usually more efficient to call\n * {@link Billboard#show} instead of removing and re-adding the billboard.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * const b = billboards.add(...);\n * billboards.remove(b);  // Returns true\n *\n * @see BillboardCollection#add\n * @see BillboardCollection#removeAll\n * @see Billboard#show\n */\nBillboardCollection.prototype.remove = function (billboard) {\n  if (this.contains(billboard)) {\n    this._billboards[billboard._index] = undefined; // Removed later\n    this._billboardsRemoved = true;\n    this._createVertexArray = true;\n    billboard._destroy();\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Removes all billboards from the collection.\n *\n * @performance <code>O(n)</code>.  It is more efficient to remove all the billboards\n * from a collection and then add new ones than to create a new collection entirely.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * billboards.add(...);\n * billboards.add(...);\n * billboards.removeAll();\n *\n * @see BillboardCollection#add\n * @see BillboardCollection#remove\n */\nBillboardCollection.prototype.removeAll = function () {\n  destroyBillboards(this._billboards);\n  this._billboards = [];\n  this._billboardsToUpdate = [];\n  this._billboardsToUpdateIndex = 0;\n  this._billboardsRemoved = false;\n\n  this._createVertexArray = true;\n};\n\nfunction removeBillboards(billboardCollection) {\n  if (billboardCollection._billboardsRemoved) {\n    billboardCollection._billboardsRemoved = false;\n\n    const newBillboards = [];\n    const billboards = billboardCollection._billboards;\n    const length = billboards.length;\n    for (let i = 0, j = 0; i < length; ++i) {\n      const billboard = billboards[i];\n      if (defined(billboard)) {\n        billboard._index = j++;\n        newBillboards.push(billboard);\n      }\n    }\n\n    billboardCollection._billboards = newBillboards;\n  }\n}\n\nBillboardCollection.prototype._updateBillboard = function (\n  billboard,\n  propertyChanged,\n) {\n  if (!billboard._dirty) {\n    this._billboardsToUpdate[this._billboardsToUpdateIndex++] = billboard;\n  }\n\n  ++this._propertiesChanged[propertyChanged];\n};\n\n/**\n * Check whether this collection contains a given billboard.\n *\n * @param {Billboard} [billboard] The billboard to check for.\n * @returns {boolean} true if this collection contains the billboard, false otherwise.\n *\n * @see BillboardCollection#get\n */\nBillboardCollection.prototype.contains = function (billboard) {\n  return defined(billboard) && billboard._billboardCollection === this;\n};\n\n/**\n * Returns the billboard in the collection at the specified index.  Indices are zero-based\n * and increase as billboards are added.  Removing a billboard shifts all billboards after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link BillboardCollection#length} to iterate over all the billboards\n * in the collection.\n *\n * @param {number} index The zero-based index of the billboard.\n * @returns {Billboard} The billboard at the specified index.\n *\n * @performance Expected constant time.  If billboards were removed from the collection and\n * {@link BillboardCollection#update} was not called, an implicit <code>O(n)</code>\n * operation is performed.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Toggle the show property of every billboard in the collection\n * const len = billboards.length;\n * for (let i = 0; i < len; ++i) {\n *   const b = billboards.get(i);\n *   b.show = !b.show;\n * }\n *\n * @see BillboardCollection#length\n */\nBillboardCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  //>>includeEnd('debug');\n\n  removeBillboards(this);\n  return this._billboards[index];\n};\n\nlet getIndexBuffer;\n\nfunction getIndexBufferBatched(context) {\n  const sixteenK = 16 * 1024;\n\n  let indexBuffer = context.cache.billboardCollection_indexBufferBatched;\n  if (defined(indexBuffer)) {\n    return indexBuffer;\n  }\n\n  // Subtract 6 because the last index is reserverd for primitive restart.\n  // https://www.khronos.org/registry/webgl/specs/latest/2.0/#5.18\n  const length = sixteenK * 6 - 6;\n  const indices = new Uint16Array(length);\n  for (let i = 0, j = 0; i < length; i += 6, j += 4) {\n    indices[i] = j;\n    indices[i + 1] = j + 1;\n    indices[i + 2] = j + 2;\n\n    indices[i + 3] = j + 0;\n    indices[i + 4] = j + 2;\n    indices[i + 5] = j + 3;\n  }\n\n  // PERFORMANCE_IDEA:  Should we reference count billboard collections, and eventually delete this?\n  // Is this too much memory to allocate up front?  Should we dynamically grow it?\n  indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: indices,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: IndexDatatype.UNSIGNED_SHORT,\n  });\n  indexBuffer.vertexArrayDestroyable = false;\n  context.cache.billboardCollection_indexBufferBatched = indexBuffer;\n  return indexBuffer;\n}\n\nfunction getIndexBufferInstanced(context) {\n  let indexBuffer = context.cache.billboardCollection_indexBufferInstanced;\n  if (defined(indexBuffer)) {\n    return indexBuffer;\n  }\n\n  indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: new Uint16Array([0, 1, 2, 0, 2, 3]),\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: IndexDatatype.UNSIGNED_SHORT,\n  });\n\n  indexBuffer.vertexArrayDestroyable = false;\n  context.cache.billboardCollection_indexBufferInstanced = indexBuffer;\n  return indexBuffer;\n}\n\nfunction getVertexBufferInstanced(context) {\n  let vertexBuffer = context.cache.billboardCollection_vertexBufferInstanced;\n  if (defined(vertexBuffer)) {\n    return vertexBuffer;\n  }\n\n  vertexBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: new Float32Array([0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0]),\n    usage: BufferUsage.STATIC_DRAW,\n  });\n\n  vertexBuffer.vertexArrayDestroyable = false;\n  context.cache.billboardCollection_vertexBufferInstanced = vertexBuffer;\n  return vertexBuffer;\n}\n\nBillboardCollection.prototype.computeNewBuffersUsage = function () {\n  const buffersUsage = this._buffersUsage;\n  let usageChanged = false;\n\n  const properties = this._propertiesChanged;\n  for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n    const newUsage =\n      properties[k] === 0 ? BufferUsage.STATIC_DRAW : BufferUsage.STREAM_DRAW;\n    usageChanged = usageChanged || buffersUsage[k] !== newUsage;\n    buffersUsage[k] = newUsage;\n  }\n\n  return usageChanged;\n};\n\nfunction createVAF(\n  context,\n  numberOfBillboards,\n  buffersUsage,\n  instanced,\n  batchTable,\n  sdf,\n) {\n  const attributes = [\n    {\n      index: attributeLocations.positionHighAndScale,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[POSITION_INDEX],\n    },\n    {\n      index: attributeLocations.positionLowAndRotation,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[POSITION_INDEX],\n    },\n    {\n      index: attributeLocations.compressedAttribute0,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[PIXEL_OFFSET_INDEX],\n    },\n    {\n      index: attributeLocations.compressedAttribute1,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[TRANSLUCENCY_BY_DISTANCE_INDEX],\n    },\n    {\n      index: attributeLocations.compressedAttribute2,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[COLOR_INDEX],\n    },\n    {\n      index: attributeLocations.eyeOffset,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[EYE_OFFSET_INDEX],\n    },\n    {\n      index: attributeLocations.scaleByDistance,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[SCALE_BY_DISTANCE_INDEX],\n    },\n    {\n      index: attributeLocations.pixelOffsetScaleByDistance,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX],\n    },\n    {\n      index: attributeLocations.compressedAttribute3,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[DISTANCE_DISPLAY_CONDITION_INDEX],\n    },\n    {\n      index: attributeLocations.textureCoordinateBoundsOrLabelTranslate,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[TEXTURE_COORDINATE_BOUNDS],\n    },\n    {\n      index: attributeLocations.splitDirection,\n      componentsPerAttribute: 1,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[SPLIT_DIRECTION_INDEX],\n    },\n  ];\n\n  // Instancing requires one non-instanced attribute.\n  if (instanced) {\n    attributes.push({\n      index: attributeLocations.direction,\n      componentsPerAttribute: 2,\n      componentDatatype: ComponentDatatype.FLOAT,\n      vertexBuffer: getVertexBufferInstanced(context),\n    });\n  }\n\n  if (defined(batchTable)) {\n    attributes.push({\n      index: attributeLocations.a_batchId,\n      componentsPerAttribute: 1,\n      componentDatatype: ComponentDatatype.FLOAT,\n      bufferUsage: BufferUsage.STATIC_DRAW,\n    });\n  }\n\n  if (sdf) {\n    attributes.push({\n      index: attributeLocations.sdf,\n      componentsPerAttribute: 2,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[SDF_INDEX],\n    });\n  }\n\n  // When instancing is enabled, only one vertex is needed for each billboard.\n  const sizeInVertices = instanced\n    ? numberOfBillboards\n    : 4 * numberOfBillboards;\n  return new VertexArrayFacade(context, attributes, sizeInVertices, instanced);\n}\n\n///////////////////////////////////////////////////////////////////////////\n\n// Four vertices per billboard.  Each has the same position, etc., but a different screen-space direction vector.\n\n// PERFORMANCE_IDEA:  Save memory if a property is the same for all billboards, use a latched attribute state,\n// instead of storing it in a vertex buffer.\n\nconst writePositionScratch = new EncodedCartesian3();\n\nfunction writePositionScaleAndRotation(\n  billboardCollection,\n  frameState,\n  vafWriters,\n  billboard,\n) {\n  let i;\n  const positionHighWriter =\n    vafWriters[attributeLocations.positionHighAndScale];\n  const positionLowWriter =\n    vafWriters[attributeLocations.positionLowAndRotation];\n  const position = billboard._getActualPosition();\n\n  if (billboardCollection._mode === SceneMode.SCENE3D) {\n    BoundingSphere.expand(\n      billboardCollection._baseVolume,\n      position,\n      billboardCollection._baseVolume,\n    );\n    billboardCollection._boundingVolumeDirty = true;\n  }\n\n  EncodedCartesian3.fromCartesian(position, writePositionScratch);\n  const scale = billboard.scale;\n  const rotation = billboard.rotation;\n\n  if (rotation !== 0.0) {\n    billboardCollection._shaderRotation = true;\n  }\n\n  billboardCollection._maxScale = Math.max(\n    billboardCollection._maxScale,\n    scale,\n  );\n\n  const high = writePositionScratch.high;\n  const low = writePositionScratch.low;\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    positionHighWriter(i, high.x, high.y, high.z, scale);\n    positionLowWriter(i, low.x, low.y, low.z, rotation);\n  } else {\n    i = billboard._index * 4;\n    positionHighWriter(i + 0, high.x, high.y, high.z, scale);\n    positionHighWriter(i + 1, high.x, high.y, high.z, scale);\n    positionHighWriter(i + 2, high.x, high.y, high.z, scale);\n    positionHighWriter(i + 3, high.x, high.y, high.z, scale);\n\n    positionLowWriter(i + 0, low.x, low.y, low.z, rotation);\n    positionLowWriter(i + 1, low.x, low.y, low.z, rotation);\n    positionLowWriter(i + 2, low.x, low.y, low.z, rotation);\n    positionLowWriter(i + 3, low.x, low.y, low.z, rotation);\n  }\n}\n\nconst scratchCartesian2 = new Cartesian2();\n\nconst UPPER_BOUND = 32768.0; // 2^15\n\nconst LEFT_SHIFT16 = 65536.0; // 2^16\nconst LEFT_SHIFT12 = 4096.0; // 2^12\nconst LEFT_SHIFT8 = 256.0; // 2^8\nconst LEFT_SHIFT7 = 128.0;\nconst LEFT_SHIFT5 = 32.0;\nconst LEFT_SHIFT3 = 8.0;\nconst LEFT_SHIFT2 = 4.0;\n\nconst RIGHT_SHIFT8 = 1.0 / 256.0;\n\nconst LOWER_LEFT = 0.0;\nconst LOWER_RIGHT = 2.0;\nconst UPPER_RIGHT = 3.0;\nconst UPPER_LEFT = 1.0;\n\nconst scratchBoundingRectangle = new BoundingRectangle();\n\nfunction writeCompressedAttrib0(\n  billboardCollection,\n  frameState,\n  vafWriters,\n  billboard,\n) {\n  let i;\n  const writer = vafWriters[attributeLocations.compressedAttribute0];\n  const pixelOffset = billboard.pixelOffset;\n  const pixelOffsetX = pixelOffset.x;\n  const pixelOffsetY = pixelOffset.y;\n\n  const translate = billboard._translate;\n  const translateX = translate.x;\n  const translateY = translate.y;\n\n  billboardCollection._maxPixelOffset = Math.max(\n    billboardCollection._maxPixelOffset,\n    Math.abs(pixelOffsetX + translateX),\n    Math.abs(-pixelOffsetY + translateY),\n  );\n\n  const horizontalOrigin = billboard.horizontalOrigin;\n  let verticalOrigin = billboard._verticalOrigin;\n  let show = billboard.show && billboard.clusterShow;\n\n  // If the color alpha is zero, do not show this billboard.  This lets us avoid providing\n  // color during the pick pass and also eliminates a discard in the fragment shader.\n  if (billboard.color.alpha === 0.0) {\n    show = false;\n  }\n\n  // Raw billboards don't distinguish between BASELINE and BOTTOM, only LabelCollection does that.\n  if (verticalOrigin === VerticalOrigin.BASELINE) {\n    verticalOrigin = VerticalOrigin.BOTTOM;\n  }\n\n  billboardCollection._allHorizontalCenter =\n    billboardCollection._allHorizontalCenter &&\n    horizontalOrigin === HorizontalOrigin.CENTER;\n  billboardCollection._allVerticalCenter =\n    billboardCollection._allVerticalCenter &&\n    verticalOrigin === VerticalOrigin.CENTER;\n\n  let bottomLeftX = 0;\n  let bottomLeftY = 0;\n  let width = 0;\n  let height = 0;\n  if (billboard.ready) {\n    const imageRectangle = billboard.computeTextureCoordinates(\n      scratchBoundingRectangle,\n    );\n\n    bottomLeftX = imageRectangle.x;\n    bottomLeftY = imageRectangle.y;\n    width = imageRectangle.width;\n    height = imageRectangle.height;\n  }\n  const topRightX = bottomLeftX + width;\n  const topRightY = bottomLeftY + height;\n\n  let compressed0 =\n    Math.floor(\n      CesiumMath.clamp(pixelOffsetX, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND,\n    ) * LEFT_SHIFT7;\n  compressed0 += (horizontalOrigin + 1.0) * LEFT_SHIFT5;\n  compressed0 += (verticalOrigin + 1.0) * LEFT_SHIFT3;\n  compressed0 += (show ? 1.0 : 0.0) * LEFT_SHIFT2;\n\n  let compressed1 =\n    Math.floor(\n      CesiumMath.clamp(pixelOffsetY, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND,\n    ) * LEFT_SHIFT8;\n\n  // We scale `translate` by LEFT_SHIFT2 before encoding it (and unscale after decoding in the shader)\n  // to preserve some subpixel precision (1 / 4 = 0.25 pixels). This mitigates rounding errors in aligning glyphs.\n  // The cost of increasing this scaling factor is that it decreases the range of representable `translate` values\n  // by the same scaling factor. Value must be kept in sync with the shader.\n  let compressed2 =\n    Math.floor(\n      CesiumMath.clamp(translateX * LEFT_SHIFT2, -UPPER_BOUND, UPPER_BOUND) +\n        UPPER_BOUND,\n    ) * LEFT_SHIFT8;\n\n  const tempTanslateY =\n    (CesiumMath.clamp(translateY * LEFT_SHIFT2, -UPPER_BOUND, UPPER_BOUND) +\n      UPPER_BOUND) *\n    RIGHT_SHIFT8;\n  const upperTranslateY = Math.floor(tempTanslateY);\n  const lowerTranslateY = Math.floor(\n    (tempTanslateY - upperTranslateY) * LEFT_SHIFT8,\n  );\n\n  compressed1 += upperTranslateY;\n  compressed2 += lowerTranslateY;\n\n  scratchCartesian2.x = bottomLeftX;\n  scratchCartesian2.y = bottomLeftY;\n  const compressedTexCoordsLL =\n    AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n  scratchCartesian2.x = topRightX;\n  const compressedTexCoordsLR =\n    AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n  scratchCartesian2.y = topRightY;\n  const compressedTexCoordsUR =\n    AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n  scratchCartesian2.x = bottomLeftX;\n  const compressedTexCoordsUL =\n    AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, compressed0, compressed1, compressed2, compressedTexCoordsLL);\n  } else {\n    i = billboard._index * 4;\n    writer(\n      i + 0,\n      compressed0 + LOWER_LEFT,\n      compressed1,\n      compressed2,\n      compressedTexCoordsLL,\n    );\n    writer(\n      i + 1,\n      compressed0 + LOWER_RIGHT,\n      compressed1,\n      compressed2,\n      compressedTexCoordsLR,\n    );\n    writer(\n      i + 2,\n      compressed0 + UPPER_RIGHT,\n      compressed1,\n      compressed2,\n      compressedTexCoordsUR,\n    );\n    writer(\n      i + 3,\n      compressed0 + UPPER_LEFT,\n      compressed1,\n      compressed2,\n      compressedTexCoordsUL,\n    );\n  }\n}\n\nfunction writeCompressedAttrib1(\n  billboardCollection,\n  frameState,\n  vafWriters,\n  billboard,\n) {\n  let i;\n  const writer = vafWriters[attributeLocations.compressedAttribute1];\n  const alignedAxis = billboard.alignedAxis;\n  if (!Cartesian3.equals(alignedAxis, Cartesian3.ZERO)) {\n    billboardCollection._shaderAlignedAxis = true;\n  }\n\n  let near = 0.0;\n  let nearValue = 1.0;\n  let far = 1.0;\n  let farValue = 1.0;\n\n  const translucency = billboard.translucencyByDistance;\n  if (defined(translucency)) {\n    near = translucency.near;\n    nearValue = translucency.nearValue;\n    far = translucency.far;\n    farValue = translucency.farValue;\n\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // translucency by distance calculation in shader need not be enabled\n      // until a billboard with near and far !== 1.0 is found\n      billboardCollection._shaderTranslucencyByDistance = true;\n    }\n  }\n\n  const imageWidth = Math.round(billboard.width ?? 0);\n  billboardCollection._maxSize = Math.max(\n    billboardCollection._maxSize,\n    imageWidth,\n  );\n\n  let compressed0 = CesiumMath.clamp(imageWidth, 0.0, LEFT_SHIFT16);\n  let compressed1 = 0.0;\n\n  if (\n    Math.abs(Cartesian3.magnitudeSquared(alignedAxis) - 1.0) <\n    CesiumMath.EPSILON6\n  ) {\n    compressed1 = AttributeCompression.octEncodeFloat(alignedAxis);\n  }\n\n  nearValue = CesiumMath.clamp(nearValue, 0.0, 1.0);\n  nearValue = nearValue === 1.0 ? 255.0 : (nearValue * 255.0) | 0;\n  compressed0 = compressed0 * LEFT_SHIFT8 + nearValue;\n\n  farValue = CesiumMath.clamp(farValue, 0.0, 1.0);\n  farValue = farValue === 1.0 ? 255.0 : (farValue * 255.0) | 0;\n  compressed1 = compressed1 * LEFT_SHIFT8 + farValue;\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, compressed0, compressed1, near, far);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, compressed0, compressed1, near, far);\n    writer(i + 1, compressed0, compressed1, near, far);\n    writer(i + 2, compressed0, compressed1, near, far);\n    writer(i + 3, compressed0, compressed1, near, far);\n  }\n}\n\nfunction writeCompressedAttrib2(\n  billboardCollection,\n  frameState,\n  vafWriters,\n  billboard,\n) {\n  let i;\n  const writer = vafWriters[attributeLocations.compressedAttribute2];\n  const color = billboard.color;\n  const pickColor = !defined(billboardCollection._batchTable)\n    ? billboard.getPickId(frameState.context).color\n    : Color.WHITE;\n  const sizeInMeters = billboard.sizeInMeters ? 1.0 : 0.0;\n  const validAlignedAxis =\n    Math.abs(Cartesian3.magnitudeSquared(billboard.alignedAxis) - 1.0) <\n    CesiumMath.EPSILON6\n      ? 1.0\n      : 0.0;\n\n  billboardCollection._allSizedInMeters =\n    billboardCollection._allSizedInMeters && sizeInMeters === 1.0;\n\n  const imageHeight = billboard.height ?? 0;\n  billboardCollection._maxSize = Math.max(\n    billboardCollection._maxSize,\n    imageHeight,\n  );\n  let labelHorizontalOrigin = billboard._labelHorizontalOrigin ?? -2;\n  labelHorizontalOrigin += 2;\n  const compressed3 = imageHeight * LEFT_SHIFT2 + labelHorizontalOrigin;\n\n  let red = Color.floatToByte(color.red);\n  let green = Color.floatToByte(color.green);\n  let blue = Color.floatToByte(color.blue);\n  const compressed0 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n\n  red = Color.floatToByte(pickColor.red);\n  green = Color.floatToByte(pickColor.green);\n  blue = Color.floatToByte(pickColor.blue);\n  const compressed1 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n\n  let compressed2 =\n    Color.floatToByte(color.alpha) * LEFT_SHIFT16 +\n    Color.floatToByte(pickColor.alpha) * LEFT_SHIFT8;\n  compressed2 += sizeInMeters * 2.0 + validAlignedAxis;\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, compressed0, compressed1, compressed2, compressed3);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, compressed0, compressed1, compressed2, compressed3);\n    writer(i + 1, compressed0, compressed1, compressed2, compressed3);\n    writer(i + 2, compressed0, compressed1, compressed2, compressed3);\n    writer(i + 3, compressed0, compressed1, compressed2, compressed3);\n  }\n}\n\nfunction writeEyeOffset(\n  billboardCollection,\n  frameState,\n  vafWriters,\n  billboard,\n) {\n  let i;\n  const writer = vafWriters[attributeLocations.eyeOffset];\n  const eyeOffset = billboard.eyeOffset;\n\n  // For billboards that are clamped to ground, move it slightly closer to the camera\n  let eyeOffsetZ = eyeOffset.z;\n  if (billboard._heightReference !== HeightReference.NONE) {\n    eyeOffsetZ *= 1.005;\n  }\n  billboardCollection._maxEyeOffset = Math.max(\n    billboardCollection._maxEyeOffset,\n    Math.abs(eyeOffset.x),\n    Math.abs(eyeOffset.y),\n    Math.abs(eyeOffsetZ),\n  );\n\n  if (billboardCollection._instanced) {\n    scratchCartesian2.x = 0;\n    scratchCartesian2.y = 0;\n\n    if (billboard.ready) {\n      const imageRectangle = billboard.computeTextureCoordinates(\n        scratchBoundingRectangle,\n      );\n\n      scratchCartesian2.x = imageRectangle.width;\n      scratchCartesian2.y = imageRectangle.height;\n    }\n\n    const compressedTexCoordsRange =\n      AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n\n    i = billboard._index;\n    writer(i, eyeOffset.x, eyeOffset.y, eyeOffsetZ, compressedTexCoordsRange);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0.0);\n    writer(i + 1, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0.0);\n    writer(i + 2, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0.0);\n    writer(i + 3, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0.0);\n  }\n}\n\nfunction writeScaleByDistance(\n  billboardCollection,\n  frameState,\n  vafWriters,\n  billboard,\n) {\n  let i;\n  const writer = vafWriters[attributeLocations.scaleByDistance];\n  let near = 0.0;\n  let nearValue = 1.0;\n  let far = 1.0;\n  let farValue = 1.0;\n\n  const scale = billboard.scaleByDistance;\n  if (defined(scale)) {\n    near = scale.near;\n    nearValue = scale.nearValue;\n    far = scale.far;\n    farValue = scale.farValue;\n\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // scale by distance calculation in shader need not be enabled\n      // until a billboard with near and far !== 1.0 is found\n      billboardCollection._shaderScaleByDistance = true;\n    }\n  }\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, near, nearValue, far, farValue);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, near, nearValue, far, farValue);\n    writer(i + 1, near, nearValue, far, farValue);\n    writer(i + 2, near, nearValue, far, farValue);\n    writer(i + 3, near, nearValue, far, farValue);\n  }\n}\n\nfunction writePixelOffsetScaleByDistance(\n  billboardCollection,\n  frameState,\n  vafWriters,\n  billboard,\n) {\n  let i;\n  const writer = vafWriters[attributeLocations.pixelOffsetScaleByDistance];\n  let near = 0.0;\n  let nearValue = 1.0;\n  let far = 1.0;\n  let farValue = 1.0;\n\n  const pixelOffsetScale = billboard.pixelOffsetScaleByDistance;\n  if (defined(pixelOffsetScale)) {\n    near = pixelOffsetScale.near;\n    nearValue = pixelOffsetScale.nearValue;\n    far = pixelOffsetScale.far;\n    farValue = pixelOffsetScale.farValue;\n\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // pixelOffsetScale by distance calculation in shader need not be enabled\n      // until a billboard with near and far !== 1.0 is found\n      billboardCollection._shaderPixelOffsetScaleByDistance = true;\n    }\n  }\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, near, nearValue, far, farValue);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, near, nearValue, far, farValue);\n    writer(i + 1, near, nearValue, far, farValue);\n    writer(i + 2, near, nearValue, far, farValue);\n    writer(i + 3, near, nearValue, far, farValue);\n  }\n}\n\nfunction writeCompressedAttribute3(\n  billboardCollection,\n  frameState,\n  vafWriters,\n  billboard,\n) {\n  let i;\n  const writer = vafWriters[attributeLocations.compressedAttribute3];\n  let near = 0.0;\n  let far = Number.MAX_VALUE;\n\n  const distanceDisplayCondition = billboard.distanceDisplayCondition;\n  if (defined(distanceDisplayCondition)) {\n    near = distanceDisplayCondition.near;\n    far = distanceDisplayCondition.far;\n\n    near *= near;\n    far *= far;\n\n    billboardCollection._shaderDistanceDisplayCondition = true;\n  }\n\n  let disableDepthTestDistance = billboard.disableDepthTestDistance;\n  const clampToGround =\n    isHeightReferenceClamp(billboard.heightReference) &&\n    frameState.context.depthTexture;\n  if (!defined(disableDepthTestDistance)) {\n    disableDepthTestDistance = clampToGround ? 5000.0 : 0.0;\n  }\n\n  disableDepthTestDistance *= disableDepthTestDistance;\n  if (clampToGround || disableDepthTestDistance > 0.0) {\n    billboardCollection._shaderDisableDepthDistance = true;\n    if (disableDepthTestDistance === Number.POSITIVE_INFINITY) {\n      disableDepthTestDistance = -1.0;\n    }\n  }\n\n  let imageHeight;\n  let imageWidth;\n\n  if (!defined(billboard._labelDimensions)) {\n    imageWidth = billboard.width ?? 0;\n    imageHeight = billboard.height ?? 0;\n  } else {\n    imageWidth = billboard._labelDimensions.x;\n    imageHeight = billboard._labelDimensions.y;\n  }\n\n  const w = Math.floor(CesiumMath.clamp(imageWidth, 0.0, LEFT_SHIFT12));\n  const h = Math.floor(CesiumMath.clamp(imageHeight, 0.0, LEFT_SHIFT12));\n  const dimensions = w * LEFT_SHIFT12 + h;\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, near, far, disableDepthTestDistance, dimensions);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, near, far, disableDepthTestDistance, dimensions);\n    writer(i + 1, near, far, disableDepthTestDistance, dimensions);\n    writer(i + 2, near, far, disableDepthTestDistance, dimensions);\n    writer(i + 3, near, far, disableDepthTestDistance, dimensions);\n  }\n}\n\nfunction writeTextureCoordinateBoundsOrLabelTranslate(\n  billboardCollection,\n  frameState,\n  vafWriters,\n  billboard,\n) {\n  if (isHeightReferenceClamp(billboard.heightReference)) {\n    const scene = billboardCollection._scene;\n    const context = frameState.context;\n    const globeTranslucent = frameState.globeTranslucencyState.translucent;\n    const depthTestAgainstTerrain =\n      defined(scene.globe) && scene.globe.depthTestAgainstTerrain;\n\n    // Only do manual depth test if the globe is opaque and writes depth\n    billboardCollection._shaderClampToGround =\n      context.depthTexture && !globeTranslucent && depthTestAgainstTerrain;\n  }\n  let i;\n  const writer =\n    vafWriters[attributeLocations.textureCoordinateBoundsOrLabelTranslate];\n\n  if (ContextLimits.maximumVertexTextureImageUnits > 0) {\n    //write _labelTranslate, used by depth testing in the vertex shader\n    let translateX = 0;\n    let translateY = 0;\n    if (defined(billboard._labelTranslate)) {\n      translateX = billboard._labelTranslate.x;\n      translateY = billboard._labelTranslate.y;\n    }\n    if (billboardCollection._instanced) {\n      i = billboard._index;\n      writer(i, translateX, translateY, 0.0, 0.0);\n    } else {\n      i = billboard._index * 4;\n      writer(i + 0, translateX, translateY, 0.0, 0.0);\n      writer(i + 1, translateX, translateY, 0.0, 0.0);\n      writer(i + 2, translateX, translateY, 0.0, 0.0);\n      writer(i + 3, translateX, translateY, 0.0, 0.0);\n    }\n    return;\n  }\n\n  // Write texture coordinate bounds, used by depth testing in fragment shader\n  let minX = 0;\n  let minY = 0;\n  let width = 0;\n  let height = 0;\n  if (billboard.ready) {\n    const imageRectangle = billboard.computeTextureCoordinates(\n      scratchBoundingRectangle,\n    );\n\n    minX = imageRectangle.x;\n    minY = imageRectangle.y;\n    width = imageRectangle.width;\n    height = imageRectangle.height;\n  }\n  const maxX = minX + width;\n  const maxY = minY + height;\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, minX, minY, maxX, maxY);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, minX, minY, maxX, maxY);\n    writer(i + 1, minX, minY, maxX, maxY);\n    writer(i + 2, minX, minY, maxX, maxY);\n    writer(i + 3, minX, minY, maxX, maxY);\n  }\n}\n\nfunction writeBatchId(billboardCollection, frameState, vafWriters, billboard) {\n  if (!defined(billboardCollection._batchTable)) {\n    return;\n  }\n\n  const writer = vafWriters[attributeLocations.a_batchId];\n  const id = billboard._batchIndex;\n\n  let i;\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, id);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, id);\n    writer(i + 1, id);\n    writer(i + 2, id);\n    writer(i + 3, id);\n  }\n}\n\nfunction writeSDF(billboardCollection, frameState, vafWriters, billboard) {\n  if (!billboardCollection._sdf) {\n    return;\n  }\n\n  let i;\n  const writer = vafWriters[attributeLocations.sdf];\n\n  const outlineColor = billboard.outlineColor;\n  const outlineWidth = billboard.outlineWidth;\n\n  const red = Color.floatToByte(outlineColor.red);\n  const green = Color.floatToByte(outlineColor.green);\n  const blue = Color.floatToByte(outlineColor.blue);\n  const compressed0 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n\n  // Compute the relative outline distance\n  const outlineDistance = outlineWidth / SDFSettings.RADIUS;\n  const compressed1 =\n    Color.floatToByte(outlineColor.alpha) * LEFT_SHIFT16 +\n    Color.floatToByte(outlineDistance) * LEFT_SHIFT8;\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, compressed0, compressed1);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, compressed0 + LOWER_LEFT, compressed1);\n    writer(i + 1, compressed0 + LOWER_RIGHT, compressed1);\n    writer(i + 2, compressed0 + UPPER_RIGHT, compressed1);\n    writer(i + 3, compressed0 + UPPER_LEFT, compressed1);\n  }\n}\n\nfunction writeSplitDirection(\n  billboardCollection,\n  frameState,\n  vafWriters,\n  billboard,\n) {\n  const writer = vafWriters[attributeLocations.splitDirection];\n  let direction = 0.0;\n\n  const split = billboard.splitDirection;\n  if (defined(split)) {\n    direction = split;\n  }\n\n  let i;\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, direction);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, direction);\n    writer(i + 1, direction);\n    writer(i + 2, direction);\n    writer(i + 3, direction);\n  }\n}\n\nfunction writeBillboard(\n  billboardCollection,\n  frameState,\n  vafWriters,\n  billboard,\n) {\n  writePositionScaleAndRotation(\n    billboardCollection,\n    frameState,\n    vafWriters,\n    billboard,\n  );\n  writeCompressedAttrib0(\n    billboardCollection,\n    frameState,\n    vafWriters,\n    billboard,\n  );\n  writeCompressedAttrib1(\n    billboardCollection,\n    frameState,\n    vafWriters,\n    billboard,\n  );\n  writeCompressedAttrib2(\n    billboardCollection,\n    frameState,\n    vafWriters,\n    billboard,\n  );\n  writeEyeOffset(billboardCollection, frameState, vafWriters, billboard);\n  writeScaleByDistance(billboardCollection, frameState, vafWriters, billboard);\n  writePixelOffsetScaleByDistance(\n    billboardCollection,\n    frameState,\n    vafWriters,\n    billboard,\n  );\n  writeCompressedAttribute3(\n    billboardCollection,\n    frameState,\n    vafWriters,\n    billboard,\n  );\n  writeTextureCoordinateBoundsOrLabelTranslate(\n    billboardCollection,\n    frameState,\n    vafWriters,\n    billboard,\n  );\n  writeBatchId(billboardCollection, frameState, vafWriters, billboard);\n  writeSDF(billboardCollection, frameState, vafWriters, billboard);\n  writeSplitDirection(billboardCollection, frameState, vafWriters, billboard);\n}\n\nfunction recomputeActualPositions(\n  billboardCollection,\n  billboards,\n  length,\n  frameState,\n  modelMatrix,\n  recomputeBoundingVolume,\n) {\n  let boundingVolume;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingVolume = billboardCollection._baseVolume;\n    billboardCollection._boundingVolumeDirty = true;\n  } else {\n    boundingVolume = billboardCollection._baseVolume2D;\n  }\n\n  const positions = [];\n  for (let i = 0; i < length; ++i) {\n    const billboard = billboards[i];\n    const position = billboard.position;\n    const actualPosition = Billboard._computeActualPosition(\n      billboard,\n      position,\n      frameState,\n      modelMatrix,\n    );\n    if (defined(actualPosition)) {\n      billboard._setActualPosition(actualPosition);\n\n      if (recomputeBoundingVolume) {\n        positions.push(actualPosition);\n      } else {\n        BoundingSphere.expand(boundingVolume, actualPosition, boundingVolume);\n      }\n    }\n  }\n\n  if (recomputeBoundingVolume) {\n    BoundingSphere.fromPoints(positions, boundingVolume);\n  }\n}\n\nfunction updateMode(billboardCollection, frameState) {\n  const mode = frameState.mode;\n\n  const billboards = billboardCollection._billboards;\n  const billboardsToUpdate = billboardCollection._billboardsToUpdate;\n  const modelMatrix = billboardCollection._modelMatrix;\n\n  if (\n    billboardCollection._createVertexArray ||\n    billboardCollection._mode !== mode ||\n    (mode !== SceneMode.SCENE3D &&\n      !Matrix4.equals(modelMatrix, billboardCollection.modelMatrix))\n  ) {\n    billboardCollection._mode = mode;\n    Matrix4.clone(billboardCollection.modelMatrix, modelMatrix);\n    billboardCollection._createVertexArray = true;\n\n    if (\n      mode === SceneMode.SCENE3D ||\n      mode === SceneMode.SCENE2D ||\n      mode === SceneMode.COLUMBUS_VIEW\n    ) {\n      recomputeActualPositions(\n        billboardCollection,\n        billboards,\n        billboards.length,\n        frameState,\n        modelMatrix,\n        true,\n      );\n    }\n  } else if (mode === SceneMode.MORPHING) {\n    recomputeActualPositions(\n      billboardCollection,\n      billboards,\n      billboards.length,\n      frameState,\n      modelMatrix,\n      true,\n    );\n  } else if (mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {\n    recomputeActualPositions(\n      billboardCollection,\n      billboardsToUpdate,\n      billboardCollection._billboardsToUpdateIndex,\n      frameState,\n      modelMatrix,\n      false,\n    );\n  }\n}\n\nfunction updateBoundingVolume(collection, frameState, boundingVolume) {\n  let pixelScale = 1.0;\n  if (!collection._allSizedInMeters || collection._maxPixelOffset !== 0.0) {\n    pixelScale = frameState.camera.getPixelSize(\n      boundingVolume,\n      frameState.context.drawingBufferWidth,\n      frameState.context.drawingBufferHeight,\n    );\n  }\n\n  let size = pixelScale * collection._maxScale * collection._maxSize * 2.0;\n  if (collection._allHorizontalCenter && collection._allVerticalCenter) {\n    size *= 0.5;\n  }\n\n  const offset =\n    pixelScale * collection._maxPixelOffset + collection._maxEyeOffset;\n  boundingVolume.radius += size + offset;\n}\n\nfunction createDebugCommand(billboardCollection, context) {\n  const fs =\n    \"uniform sampler2D billboard_texture; \\n\" +\n    \"in vec2 v_textureCoordinates; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    out_FragColor = texture(billboard_texture, v_textureCoordinates); \\n\" +\n    \"} \\n\";\n\n  const drawCommand = context.createViewportQuadCommand(fs, {\n    uniformMap: {\n      billboard_texture: function () {\n        return billboardCollection.textureAtlas.texture;\n      },\n    },\n  });\n  drawCommand.pass = Pass.OVERLAY;\n  return drawCommand;\n}\n\nconst scratchWriterArray = [];\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {RuntimeError} image with id must be in the atlas.\n */\nBillboardCollection.prototype.update = function (frameState) {\n  removeBillboards(this);\n\n  if (!this.show) {\n    return;\n  }\n\n  const context = frameState.context;\n  this._instanced = context.instancedArrays;\n  attributeLocations = this._instanced\n    ? attributeLocationsInstanced\n    : attributeLocationsBatched;\n  getIndexBuffer = this._instanced\n    ? getIndexBufferInstanced\n    : getIndexBufferBatched;\n\n  let billboards = this._billboards;\n  let billboardsLength = billboards.length;\n  let allBillboardsReady = true;\n  for (let i = 0; i < billboardsLength; ++i) {\n    const billboard = billboards[i];\n    if (defined(billboard.loadError)) {\n      console.error(\n        `Error loading image for billboard: ${billboard.loadError}`,\n      );\n      billboard.image = undefined;\n    }\n\n    if (billboard.textureDirty) {\n      this._updateBillboard(billboard, IMAGE_INDEX_INDEX);\n    }\n\n    if (billboard.show) {\n      allBillboardsReady = allBillboardsReady && billboard.ready;\n    }\n  }\n\n  // Queue any texture resource updates for after the frame is rendered\n  const textureAtlas = this._textureAtlas;\n  frameState.afterRender.push(() => {\n    if (this.isDestroyed()) {\n      return;\n    }\n\n    return textureAtlas.update(frameState.context);\n  });\n\n  if (!defined(textureAtlas.texture)) {\n    // Can't write billboard vertices until the texture atlas\n    // has been updated once\n    return;\n  }\n\n  updateMode(this, frameState);\n\n  billboards = this._billboards;\n  billboardsLength = billboards.length;\n  const billboardsToUpdate = this._billboardsToUpdate;\n  const billboardsToUpdateLength = this._billboardsToUpdateIndex;\n\n  const properties = this._propertiesChanged;\n\n  const textureAtlasGUID = textureAtlas.guid;\n  const createVertexArray =\n    this._createVertexArray || this._textureAtlasGUID !== textureAtlasGUID;\n  this._textureAtlasGUID = textureAtlasGUID;\n\n  let vafWriters;\n  const pass = frameState.passes;\n  const picking = pass.pick;\n\n  // PERFORMANCE_IDEA: Round robin multiple buffers.\n  if (createVertexArray || (!picking && this.computeNewBuffersUsage())) {\n    this._createVertexArray = false;\n\n    for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n      properties[k] = 0;\n    }\n\n    this._vaf = this._vaf && this._vaf.destroy();\n\n    if (billboardsLength > 0) {\n      // PERFORMANCE_IDEA:  Instead of creating a new one, resize like std::vector.\n      this._vaf = createVAF(\n        context,\n        billboardsLength,\n        this._buffersUsage,\n        this._instanced,\n        this._batchTable,\n        this._sdf,\n      );\n      vafWriters = this._vaf.writers;\n\n      // Rewrite entire buffer if billboards were added or removed.\n      for (let i = 0; i < billboardsLength; ++i) {\n        const billboard = this._billboards[i];\n        billboard._dirty = false; // In case it needed an update.\n        billboard.textureDirty = false;\n        writeBillboard(this, frameState, vafWriters, billboard);\n      }\n\n      // Different billboard collections share the same index buffer.\n      this._vaf.commit(getIndexBuffer(context));\n    }\n\n    this._billboardsToUpdateIndex = 0;\n  } else if (billboardsToUpdateLength > 0) {\n    // Billboards were modified, but none were added or removed.\n    const writers = scratchWriterArray;\n    writers.length = 0;\n\n    if (\n      properties[POSITION_INDEX] ||\n      properties[ROTATION_INDEX] ||\n      properties[SCALE_INDEX]\n    ) {\n      writers.push(writePositionScaleAndRotation);\n    }\n\n    if (\n      properties[IMAGE_INDEX_INDEX] ||\n      properties[PIXEL_OFFSET_INDEX] ||\n      properties[HORIZONTAL_ORIGIN_INDEX] ||\n      properties[VERTICAL_ORIGIN_INDEX] ||\n      properties[SHOW_INDEX]\n    ) {\n      writers.push(writeCompressedAttrib0);\n      if (this._instanced) {\n        writers.push(writeEyeOffset);\n      }\n    }\n\n    if (\n      properties[IMAGE_INDEX_INDEX] ||\n      properties[ALIGNED_AXIS_INDEX] ||\n      properties[TRANSLUCENCY_BY_DISTANCE_INDEX]\n    ) {\n      writers.push(writeCompressedAttrib1);\n      writers.push(writeCompressedAttrib2);\n    }\n\n    if (properties[IMAGE_INDEX_INDEX] || properties[COLOR_INDEX]) {\n      writers.push(writeCompressedAttrib2);\n    }\n\n    if (properties[IMAGE_INDEX_INDEX] || properties[EYE_OFFSET_INDEX]) {\n      writers.push(writeEyeOffset);\n    }\n\n    if (properties[SCALE_BY_DISTANCE_INDEX]) {\n      writers.push(writeScaleByDistance);\n    }\n\n    if (properties[PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX]) {\n      writers.push(writePixelOffsetScaleByDistance);\n    }\n\n    if (\n      properties[DISTANCE_DISPLAY_CONDITION_INDEX] ||\n      properties[DISABLE_DEPTH_DISTANCE] ||\n      properties[IMAGE_INDEX_INDEX] ||\n      properties[POSITION_INDEX]\n    ) {\n      writers.push(writeCompressedAttribute3);\n    }\n\n    if (properties[IMAGE_INDEX_INDEX] || properties[POSITION_INDEX]) {\n      writers.push(writeTextureCoordinateBoundsOrLabelTranslate);\n    }\n\n    if (properties[SDF_INDEX]) {\n      writers.push(writeSDF);\n    }\n\n    if (properties[SPLIT_DIRECTION_INDEX]) {\n      writers.push(writeSplitDirection);\n    }\n\n    const numWriters = writers.length;\n    vafWriters = this._vaf.writers;\n\n    if (billboardsToUpdateLength / billboardsLength > 0.1) {\n      // If more than 10% of billboard change, rewrite the entire buffer.\n\n      // PERFORMANCE_IDEA:  I totally made up 10% :).\n\n      for (let m = 0; m < billboardsToUpdateLength; ++m) {\n        const b = billboardsToUpdate[m];\n        b._dirty = false;\n        b.textureDirty = false;\n\n        for (let n = 0; n < numWriters; ++n) {\n          writers[n](this, frameState, vafWriters, b);\n        }\n      }\n      this._vaf.commit(getIndexBuffer(context));\n    } else {\n      for (let h = 0; h < billboardsToUpdateLength; ++h) {\n        const bb = billboardsToUpdate[h];\n        bb._dirty = false;\n        bb.textureDirty = false;\n\n        for (let o = 0; o < numWriters; ++o) {\n          writers[o](this, frameState, vafWriters, bb);\n        }\n\n        if (this._instanced) {\n          this._vaf.subCommit(bb._index, 1);\n        } else {\n          this._vaf.subCommit(bb._index * 4, 4);\n        }\n      }\n      this._vaf.endSubCommits();\n    }\n\n    this._billboardsToUpdateIndex = 0;\n  }\n\n  // If the number of total billboards ever shrinks considerably\n  // Truncate billboardsToUpdate so that we free memory that we're\n  // not going to be using.\n  if (billboardsToUpdateLength > billboardsLength * 1.5) {\n    billboardsToUpdate.length = billboardsLength;\n  }\n\n  if (!defined(this._vaf) || !defined(this._vaf.va)) {\n    return;\n  }\n\n  if (this._boundingVolumeDirty) {\n    this._boundingVolumeDirty = false;\n    BoundingSphere.transform(\n      this._baseVolume,\n      this.modelMatrix,\n      this._baseVolumeWC,\n    );\n  }\n\n  let boundingVolume;\n  let modelMatrix = Matrix4.IDENTITY;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    modelMatrix = this.modelMatrix;\n    boundingVolume = BoundingSphere.clone(\n      this._baseVolumeWC,\n      this._boundingVolume,\n    );\n  } else {\n    boundingVolume = BoundingSphere.clone(\n      this._baseVolume2D,\n      this._boundingVolume,\n    );\n  }\n  updateBoundingVolume(this, frameState, boundingVolume);\n\n  const blendOptionChanged = this._blendOption !== this.blendOption;\n  this._blendOption = this.blendOption;\n\n  if (blendOptionChanged) {\n    if (\n      this._blendOption === BlendOption.OPAQUE ||\n      this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT\n    ) {\n      this._rsOpaque = RenderState.fromCache({\n        depthTest: {\n          enabled: true,\n          func: WebGLConstants.LESS,\n        },\n        depthMask: true,\n      });\n    } else {\n      this._rsOpaque = undefined;\n    }\n\n    // If OPAQUE_AND_TRANSLUCENT is in use, only the opaque pass gets the benefit of the depth buffer,\n    // not the translucent pass.  Otherwise, if the TRANSLUCENT pass is on its own, it turns on\n    // a depthMask in lieu of full depth sorting (because it has opaque-ish fragments that look bad in OIT).\n    // When the TRANSLUCENT depth mask is in use, label backgrounds require the depth func to be LEQUAL.\n    const useTranslucentDepthMask =\n      this._blendOption === BlendOption.TRANSLUCENT;\n\n    if (\n      this._blendOption === BlendOption.TRANSLUCENT ||\n      this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT\n    ) {\n      this._rsTranslucent = RenderState.fromCache({\n        depthTest: {\n          enabled: true,\n          func: useTranslucentDepthMask\n            ? WebGLConstants.LEQUAL\n            : WebGLConstants.LESS,\n        },\n        depthMask: useTranslucentDepthMask,\n        blending: BlendingState.ALPHA_BLEND,\n      });\n    } else {\n      this._rsTranslucent = undefined;\n    }\n  }\n\n  this._shaderDisableDepthDistance =\n    this._shaderDisableDepthDistance ||\n    frameState.minimumDisableDepthTestDistance !== 0.0;\n\n  let vsSource;\n  let fsSource;\n  let vs;\n  let fs;\n  let vertDefines;\n\n  const supportVSTextureReads =\n    ContextLimits.maximumVertexTextureImageUnits > 0;\n\n  if (\n    blendOptionChanged ||\n    this._shaderRotation !== this._compiledShaderRotation ||\n    this._shaderAlignedAxis !== this._compiledShaderAlignedAxis ||\n    this._shaderScaleByDistance !== this._compiledShaderScaleByDistance ||\n    this._shaderTranslucencyByDistance !==\n      this._compiledShaderTranslucencyByDistance ||\n    this._shaderPixelOffsetScaleByDistance !==\n      this._compiledShaderPixelOffsetScaleByDistance ||\n    this._shaderDistanceDisplayCondition !==\n      this._compiledShaderDistanceDisplayCondition ||\n    this._shaderDisableDepthDistance !==\n      this._compiledShaderDisableDepthDistance ||\n    this._shaderClampToGround !== this._compiledShaderClampToGround ||\n    this._sdf !== this._compiledSDF\n  ) {\n    vsSource = BillboardCollectionVS;\n    fsSource = BillboardCollectionFS;\n\n    vertDefines = [];\n    if (defined(this._batchTable)) {\n      vertDefines.push(\"VECTOR_TILE\");\n      vsSource = this._batchTable.getVertexShaderCallback(\n        false,\n        \"a_batchId\",\n        undefined,\n      )(vsSource);\n      fsSource = this._batchTable.getFragmentShaderCallback(\n        false,\n        undefined,\n      )(fsSource);\n    }\n\n    vs = new ShaderSource({\n      defines: vertDefines,\n      sources: [vsSource],\n    });\n    if (this._instanced) {\n      vs.defines.push(\"INSTANCED\");\n    }\n    if (this._shaderRotation) {\n      vs.defines.push(\"ROTATION\");\n    }\n    if (this._shaderAlignedAxis) {\n      vs.defines.push(\"ALIGNED_AXIS\");\n    }\n    if (this._shaderScaleByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_SCALING\");\n    }\n    if (this._shaderTranslucencyByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_TRANSLUCENCY\");\n    }\n    if (this._shaderPixelOffsetScaleByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_PIXEL_OFFSET\");\n    }\n    if (this._shaderDistanceDisplayCondition) {\n      vs.defines.push(\"DISTANCE_DISPLAY_CONDITION\");\n    }\n    if (this._shaderDisableDepthDistance) {\n      vs.defines.push(\"DISABLE_DEPTH_DISTANCE\");\n    }\n    if (this._shaderClampToGround) {\n      if (supportVSTextureReads) {\n        vs.defines.push(\"VERTEX_DEPTH_CHECK\");\n      } else {\n        vs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n      }\n    }\n\n    const sdfEdge = 1.0 - SDFSettings.CUTOFF;\n\n    if (this._sdf) {\n      vs.defines.push(\"SDF\");\n    }\n\n    const vectorFragDefine = defined(this._batchTable) ? \"VECTOR_TILE\" : \"\";\n\n    if (this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT) {\n      fs = new ShaderSource({\n        defines: [\"OPAQUE\", vectorFragDefine],\n        sources: [fsSource],\n      });\n      if (this._shaderClampToGround) {\n        if (supportVSTextureReads) {\n          fs.defines.push(\"VERTEX_DEPTH_CHECK\");\n        } else {\n          fs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n        }\n      }\n\n      if (this._sdf) {\n        fs.defines.push(\"SDF\");\n        fs.defines.push(`SDF_EDGE ${sdfEdge}`);\n      }\n\n      this._sp = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._sp,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n\n      fs = new ShaderSource({\n        defines: [\"TRANSLUCENT\", vectorFragDefine],\n        sources: [fsSource],\n      });\n      if (this._shaderClampToGround) {\n        if (supportVSTextureReads) {\n          fs.defines.push(\"VERTEX_DEPTH_CHECK\");\n        } else {\n          fs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n        }\n      }\n      if (this._sdf) {\n        fs.defines.push(\"SDF\");\n        fs.defines.push(`SDF_EDGE ${sdfEdge}`);\n      }\n      this._spTranslucent = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._spTranslucent,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n    }\n\n    if (this._blendOption === BlendOption.OPAQUE) {\n      fs = new ShaderSource({\n        defines: [vectorFragDefine],\n        sources: [fsSource],\n      });\n      if (this._shaderClampToGround) {\n        if (supportVSTextureReads) {\n          fs.defines.push(\"VERTEX_DEPTH_CHECK\");\n        } else {\n          fs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n        }\n      }\n      if (this._sdf) {\n        fs.defines.push(\"SDF\");\n        fs.defines.push(`SDF_EDGE ${sdfEdge}`);\n      }\n      this._sp = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._sp,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n    }\n\n    if (this._blendOption === BlendOption.TRANSLUCENT) {\n      fs = new ShaderSource({\n        defines: [vectorFragDefine],\n        sources: [fsSource],\n      });\n      if (this._shaderClampToGround) {\n        if (supportVSTextureReads) {\n          fs.defines.push(\"VERTEX_DEPTH_CHECK\");\n        } else {\n          fs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n        }\n      }\n      if (this._sdf) {\n        fs.defines.push(\"SDF\");\n        fs.defines.push(`SDF_EDGE ${sdfEdge}`);\n      }\n      this._spTranslucent = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._spTranslucent,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n    }\n\n    this._compiledShaderRotation = this._shaderRotation;\n    this._compiledShaderAlignedAxis = this._shaderAlignedAxis;\n    this._compiledShaderScaleByDistance = this._shaderScaleByDistance;\n    this._compiledShaderTranslucencyByDistance =\n      this._shaderTranslucencyByDistance;\n    this._compiledShaderPixelOffsetScaleByDistance =\n      this._shaderPixelOffsetScaleByDistance;\n    this._compiledShaderDistanceDisplayCondition =\n      this._shaderDistanceDisplayCondition;\n    this._compiledShaderDisableDepthDistance = this._shaderDisableDepthDistance;\n    this._compiledShaderClampToGround = this._shaderClampToGround;\n    this._compiledSDF = this._sdf;\n  }\n\n  const commandList = frameState.commandList;\n\n  if (pass.render || pass.pick) {\n    const colorList = this._colorCommands;\n\n    const opaque = this._blendOption === BlendOption.OPAQUE;\n    const opaqueAndTranslucent =\n      this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT;\n\n    const va = this._vaf.va;\n    const vaLength = va.length;\n\n    let uniforms = this._uniforms;\n    let pickId;\n    if (defined(this._batchTable)) {\n      uniforms = this._batchTable.getUniformMapCallback()(uniforms);\n      pickId = this._batchTable.getPickId();\n    } else {\n      pickId = \"v_pickColor\";\n    }\n\n    colorList.length = vaLength;\n    const totalLength = opaqueAndTranslucent ? vaLength * 2 : vaLength;\n    for (let j = 0; j < totalLength; ++j) {\n      let command = colorList[j];\n      if (!defined(command)) {\n        command = colorList[j] = new DrawCommand();\n      }\n\n      const opaqueCommand = opaque || (opaqueAndTranslucent && j % 2 === 0);\n\n      command.pass =\n        opaqueCommand || !opaqueAndTranslucent ? Pass.OPAQUE : Pass.TRANSLUCENT;\n      command.owner = this;\n\n      const index = opaqueAndTranslucent ? Math.floor(j / 2.0) : j;\n      command.boundingVolume = boundingVolume;\n      command.modelMatrix = modelMatrix;\n      command.count = va[index].indicesCount;\n      command.shaderProgram = opaqueCommand ? this._sp : this._spTranslucent;\n      command.uniformMap = uniforms;\n      command.vertexArray = va[index].va;\n      command.renderState = opaqueCommand\n        ? this._rsOpaque\n        : this._rsTranslucent;\n      command.debugShowBoundingVolume = this.debugShowBoundingVolume;\n      command.pickId = pickId;\n\n      if (this._instanced) {\n        command.count = 6;\n        command.instanceCount = billboardsLength;\n      }\n\n      commandList.push(command);\n    }\n\n    if (this.debugShowTextureAtlas) {\n      if (!defined(this.debugCommand)) {\n        this.debugCommand = createDebugCommand(this, frameState.context);\n      }\n\n      commandList.push(this.debugCommand);\n    }\n  }\n\n  this._allBillboardsReady = allBillboardsReady;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see BillboardCollection#destroy\n */\nBillboardCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * billboards = billboards && billboards.destroy();\n *\n * @see BillboardCollection#isDestroyed\n */\nBillboardCollection.prototype.destroy = function () {\n  if (defined(this._removeCallbackFunc)) {\n    this._removeCallbackFunc();\n    this._removeCallbackFunc = undefined;\n  }\n\n  this._textureAtlas =\n    this._destroyTextureAtlas &&\n    this._textureAtlas &&\n    this._textureAtlas.destroy();\n  this._sp = this._sp && this._sp.destroy();\n  this._spTranslucent = this._spTranslucent && this._spTranslucent.destroy();\n  this._vaf = this._vaf && this._vaf.destroy();\n  destroyBillboards(this._billboards);\n\n  return destroyObject(this);\n};\nexport default BillboardCollection;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}