{"ast":null,"code":"import BoundingRectangle from \"./BoundingRectangle.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\n\n/**\n * @typedef {object} TexturePacker.PackableObject\n * Any object, such as an <code>Image</code> with the following properties:\n * @private\n * @property {number} width The width of the image, or other object, usually in pixels\n * @property {number} height The height of the image, or other object, usually in pixels\n */\n\n/**\n * A texture atlas is recursively broken down into regions of space called nodes.\n * Nodes contain either an image reference or child nodes.\n * @private\n * @constructor\n * @param {object} options An options object with the following properties:\n * @param {number} options.x The x-offset of the texture node\n * @param {number} options.y The y-offset of the texture node\n * @param {number} options.width The width of the texture node\n * @param {number} options.height The width of the texture node\n */\nfunction TextureNode({\n  x,\n  y,\n  width,\n  height\n}) {\n  /**\n   * @type {BoundingRectangle}\n   */\n  this.rectangle = new BoundingRectangle(x, y, width, height);\n\n  /**\n   * @type {TextureNode|undefined}\n   */\n  this.childNode1 = undefined;\n  /**\n   * @type {TextureNode|undefined}\n   */\n  this.childNode2 = undefined;\n\n  /**\n   * Identifier referencing an image or packed data\n   * @type {number|undefined}\n   */\n  this.index = undefined;\n}\n\n/**\n * Typically used with {@link TextureAtlas} to calculate efficient regions of the larger areas to store images or other data. Typically, all units are specified in pixels.\n * @alias TexturePacker\n * @constructor\n * @private\n * @param {options} options Object with the following properties:\n * @param {number} options.width Width of the atlas, in pixels\n * @param {number} options.height Height of atlas, in pixels\n * @param {number} options.borderPadding Amount of border padding, in pixels\n */\nfunction TexturePacker({\n  width,\n  height,\n  borderPadding\n}) {\n  this._width = width;\n  this._height = height;\n  this._borderPadding = borderPadding;\n  this._root = new TextureNode({\n    x: borderPadding,\n    y: borderPadding,\n    width: width - 2 * borderPadding,\n    height: height - 2 * borderPadding\n  });\n}\n\n/**\n * Inserts the given object into the next available region based on it's dimensions. Where convenient, it's most efficient to pack items largest to smallest.\n * @private\n * @param {number} index An identifier referencing the image or other stored data\n * @param {TexturePacker.PackableObject} packableObject An object, such as an <code>Image</code>, with <code>width</code> and <code>height</code> properties in pixels.\n * @returns {TextureNode|undefined} The created region, or <code>undefined</code> if there is no region large enough to accommodate the object's dimensions.\n */\nTexturePacker.prototype.pack = function (index, {\n  width,\n  height\n}) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"image.width\", width, 1);\n  Check.typeOf.number.greaterThanOrEquals(\"image.height\", height, 1);\n  //>>includeEnd('debug');\n\n  const node = this._findNode(this._root, {\n    width,\n    height\n  });\n  if (!defined(node)) {\n    return;\n  }\n  node.index = index;\n  return node;\n};\n\n// A recursive function that finds the best place to insert\n// a new image based on existing image 'nodes'.\n// Inspired by: http://blackpawn.com/texts/lightmaps/default.html\nTexturePacker.prototype._findNode = function (node, {\n  width,\n  height\n}) {\n  if (!defined(node)) {\n    return undefined;\n  }\n\n  // Leaf node\n  if (!defined(node.childNode1) && !defined(node.childNode2)) {\n    if (defined(node.index)) {\n      // Node already contains an image: Skip it.\n      return undefined;\n    }\n    const {\n      rectangle\n    } = node;\n    const nodeWidth = rectangle.width;\n    const nodeHeight = rectangle.height;\n    const widthDifference = nodeWidth - width;\n    const heightDifference = nodeHeight - height;\n\n    // Node is smaller than the image.\n    if (widthDifference < 0 || heightDifference < 0) {\n      return undefined;\n    }\n\n    // If the node is the same size as the image, return the node\n    if (widthDifference === 0 && heightDifference === 0) {\n      return node;\n    }\n\n    // Vertical split (childNode1 = left half, childNode2 = right half).\n    if (widthDifference > heightDifference) {\n      node.childNode1 = new TextureNode({\n        x: rectangle.x,\n        y: rectangle.y,\n        width,\n        height: nodeHeight\n      });\n      node.childNode2 = new TextureNode({\n        x: rectangle.x + width,\n        y: rectangle.y,\n        width: widthDifference,\n        height: nodeHeight\n      });\n      return this._findNode(node.childNode1, {\n        width,\n        height\n      });\n    }\n\n    // Horizontal split (childNode1 = bottom half, childNode2 = top half).\n    node.childNode1 = new TextureNode({\n      x: rectangle.x,\n      y: rectangle.y,\n      width: nodeWidth,\n      height\n    });\n    node.childNode2 = new TextureNode({\n      x: rectangle.x,\n      y: rectangle.y + height,\n      width: nodeWidth,\n      height: heightDifference\n    });\n    return this._findNode(node.childNode1, {\n      width,\n      height\n    });\n  }\n\n  // If not a leaf node\n  return this._findNode(node.childNode1, {\n    width,\n    height\n  }) || this._findNode(node.childNode2, {\n    width,\n    height\n  });\n};\nexport default TexturePacker;","map":{"version":3,"names":["BoundingRectangle","Check","defined","TextureNode","x","y","width","height","rectangle","childNode1","undefined","childNode2","index","TexturePacker","borderPadding","_width","_height","_borderPadding","_root","prototype","pack","typeOf","number","greaterThanOrEquals","node","_findNode","nodeWidth","nodeHeight","widthDifference","heightDifference"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/TexturePacker.js"],"sourcesContent":["import BoundingRectangle from \"./BoundingRectangle.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\n\n/**\n * @typedef {object} TexturePacker.PackableObject\n * Any object, such as an <code>Image</code> with the following properties:\n * @private\n * @property {number} width The width of the image, or other object, usually in pixels\n * @property {number} height The height of the image, or other object, usually in pixels\n */\n\n/**\n * A texture atlas is recursively broken down into regions of space called nodes.\n * Nodes contain either an image reference or child nodes.\n * @private\n * @constructor\n * @param {object} options An options object with the following properties:\n * @param {number} options.x The x-offset of the texture node\n * @param {number} options.y The y-offset of the texture node\n * @param {number} options.width The width of the texture node\n * @param {number} options.height The width of the texture node\n */\nfunction TextureNode({ x, y, width, height }) {\n  /**\n   * @type {BoundingRectangle}\n   */\n  this.rectangle = new BoundingRectangle(x, y, width, height);\n\n  /**\n   * @type {TextureNode|undefined}\n   */\n  this.childNode1 = undefined;\n  /**\n   * @type {TextureNode|undefined}\n   */\n  this.childNode2 = undefined;\n\n  /**\n   * Identifier referencing an image or packed data\n   * @type {number|undefined}\n   */\n  this.index = undefined;\n}\n\n/**\n * Typically used with {@link TextureAtlas} to calculate efficient regions of the larger areas to store images or other data. Typically, all units are specified in pixels.\n * @alias TexturePacker\n * @constructor\n * @private\n * @param {options} options Object with the following properties:\n * @param {number} options.width Width of the atlas, in pixels\n * @param {number} options.height Height of atlas, in pixels\n * @param {number} options.borderPadding Amount of border padding, in pixels\n */\nfunction TexturePacker({ width, height, borderPadding }) {\n  this._width = width;\n  this._height = height;\n\n  this._borderPadding = borderPadding;\n\n  this._root = new TextureNode({\n    x: borderPadding,\n    y: borderPadding,\n    width: width - 2 * borderPadding,\n    height: height - 2 * borderPadding,\n  });\n}\n\n/**\n * Inserts the given object into the next available region based on it's dimensions. Where convenient, it's most efficient to pack items largest to smallest.\n * @private\n * @param {number} index An identifier referencing the image or other stored data\n * @param {TexturePacker.PackableObject} packableObject An object, such as an <code>Image</code>, with <code>width</code> and <code>height</code> properties in pixels.\n * @returns {TextureNode|undefined} The created region, or <code>undefined</code> if there is no region large enough to accommodate the object's dimensions.\n */\nTexturePacker.prototype.pack = function (index, { width, height }) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"image.width\", width, 1);\n  Check.typeOf.number.greaterThanOrEquals(\"image.height\", height, 1);\n  //>>includeEnd('debug');\n\n  const node = this._findNode(this._root, { width, height });\n  if (!defined(node)) {\n    return;\n  }\n\n  node.index = index;\n  return node;\n};\n\n// A recursive function that finds the best place to insert\n// a new image based on existing image 'nodes'.\n// Inspired by: http://blackpawn.com/texts/lightmaps/default.html\nTexturePacker.prototype._findNode = function (node, { width, height }) {\n  if (!defined(node)) {\n    return undefined;\n  }\n\n  // Leaf node\n  if (!defined(node.childNode1) && !defined(node.childNode2)) {\n    if (defined(node.index)) {\n      // Node already contains an image: Skip it.\n      return undefined;\n    }\n\n    const { rectangle } = node;\n\n    const nodeWidth = rectangle.width;\n    const nodeHeight = rectangle.height;\n    const widthDifference = nodeWidth - width;\n    const heightDifference = nodeHeight - height;\n\n    // Node is smaller than the image.\n    if (widthDifference < 0 || heightDifference < 0) {\n      return undefined;\n    }\n\n    // If the node is the same size as the image, return the node\n    if (widthDifference === 0 && heightDifference === 0) {\n      return node;\n    }\n\n    // Vertical split (childNode1 = left half, childNode2 = right half).\n    if (widthDifference > heightDifference) {\n      node.childNode1 = new TextureNode({\n        x: rectangle.x,\n        y: rectangle.y,\n        width,\n        height: nodeHeight,\n      });\n      node.childNode2 = new TextureNode({\n        x: rectangle.x + width,\n        y: rectangle.y,\n        width: widthDifference,\n        height: nodeHeight,\n      });\n\n      return this._findNode(node.childNode1, { width, height });\n    }\n\n    // Horizontal split (childNode1 = bottom half, childNode2 = top half).\n    node.childNode1 = new TextureNode({\n      x: rectangle.x,\n      y: rectangle.y,\n      width: nodeWidth,\n      height,\n    });\n    node.childNode2 = new TextureNode({\n      x: rectangle.x,\n      y: rectangle.y + height,\n      width: nodeWidth,\n      height: heightDifference,\n    });\n    return this._findNode(node.childNode1, { width, height });\n  }\n\n  // If not a leaf node\n  return (\n    this._findNode(node.childNode1, { width, height }) ||\n    this._findNode(node.childNode2, { width, height })\n  );\n};\n\nexport default TexturePacker;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}