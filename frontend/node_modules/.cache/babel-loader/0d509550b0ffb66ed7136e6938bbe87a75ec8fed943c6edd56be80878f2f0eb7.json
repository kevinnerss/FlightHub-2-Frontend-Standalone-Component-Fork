{"ast":null,"code":"/**\n * Date: 2015-10-05\n * Author: Kasper Søfren <soefritz@gmail.com> (https://github.com/kafoso)\n *\n * A truncation feature, where the ellipsis will be placed at a section within\n * the URL making it still somewhat human readable.\n *\n * @param {String} url\t\t\t\t\t\t A URL.\n * @param {Number} truncateLen\t\t The maximum length of the truncated output URL string.\n * @param {String} ellipsisChars\t The characters to place within the url, e.g. \"...\".\n * @return {String} The truncated URL.\n */\nexport function truncateSmart(url, truncateLen, ellipsisChars) {\n  var ellipsisLengthBeforeParsing;\n  var ellipsisLength;\n  if (ellipsisChars == null) {\n    ellipsisChars = '&hellip;';\n    ellipsisLength = 3;\n    ellipsisLengthBeforeParsing = 8;\n  } else {\n    ellipsisLength = ellipsisChars.length;\n    ellipsisLengthBeforeParsing = ellipsisChars.length;\n  }\n  // If the URL is shorter than the truncate length, return it as is\n  if (url.length <= truncateLen) {\n    return url;\n  }\n  var availableLength = truncateLen - ellipsisLength;\n  var urlObj = parseUrl(url);\n  // Clean up the URL by removing any malformed query string\n  // (e.g. \"?foo=bar?ignorethis\")\n  if (urlObj.query) {\n    var matchQuery = urlObj.query.match(/^(.*?)(?=(\\?|#))(.*?)$/i);\n    if (matchQuery) {\n      // Malformed URL; two or more \"?\". Removed any content behind the 2nd.\n      urlObj.query = urlObj.query.substr(0, matchQuery[1].length);\n      url = buildUrl(urlObj);\n    }\n  }\n  if (url.length <= truncateLen) {\n    return url; // removing a malformed query string brought the URL under the truncateLength\n  }\n  // Clean up the URL by removing 'www.' from the host if it exists\n  if (urlObj.host) {\n    urlObj.host = urlObj.host.replace(/^www\\./, '');\n    url = buildUrl(urlObj);\n  }\n  if (url.length <= truncateLen) {\n    return url; // removing 'www.' brought the URL under the truncateLength\n  }\n  // Process and build the truncated URL, starting with the hostname\n  var truncatedUrl = '';\n  if (urlObj.host) {\n    truncatedUrl += urlObj.host;\n  }\n  if (truncatedUrl.length >= availableLength) {\n    if (urlObj.host.length === truncateLen) {\n      return (urlObj.host.substr(0, truncateLen - ellipsisLength) + ellipsisChars).substr(0, availableLength + ellipsisLengthBeforeParsing);\n    }\n    return buildSegment(truncatedUrl, availableLength, ellipsisChars).substr(0, availableLength + ellipsisLengthBeforeParsing);\n  }\n  // If we still have available chars left, add the path and query string\n  var pathAndQuery = '';\n  if (urlObj.path) {\n    pathAndQuery += '/' + urlObj.path;\n  }\n  if (urlObj.query) {\n    pathAndQuery += '?' + urlObj.query;\n  }\n  if (pathAndQuery) {\n    if ((truncatedUrl + pathAndQuery).length >= availableLength) {\n      if ((truncatedUrl + pathAndQuery).length == truncateLen) {\n        return (truncatedUrl + pathAndQuery).substr(0, truncateLen);\n      }\n      var remainingAvailableLength = availableLength - truncatedUrl.length;\n      return (truncatedUrl + buildSegment(pathAndQuery, remainingAvailableLength, ellipsisChars)).substr(0, availableLength + ellipsisLengthBeforeParsing);\n    } else {\n      truncatedUrl += pathAndQuery;\n    }\n  }\n  // If we still have available chars left, add the fragment\n  if (urlObj.fragment) {\n    var fragment = '#' + urlObj.fragment;\n    if ((truncatedUrl + fragment).length >= availableLength) {\n      if ((truncatedUrl + fragment).length == truncateLen) {\n        return (truncatedUrl + fragment).substr(0, truncateLen);\n      }\n      var remainingAvailableLength2 = availableLength - truncatedUrl.length;\n      return (truncatedUrl + buildSegment(fragment, remainingAvailableLength2, ellipsisChars)).substr(0, availableLength + ellipsisLengthBeforeParsing);\n    } else {\n      truncatedUrl += fragment;\n    }\n  }\n  // If we still have available chars left, add the scheme\n  if (urlObj.scheme && urlObj.host) {\n    var scheme = urlObj.scheme + '://';\n    if ((truncatedUrl + scheme).length < availableLength) {\n      return (scheme + truncatedUrl).substr(0, truncateLen);\n    }\n  }\n  if (truncatedUrl.length <= truncateLen) {\n    return truncatedUrl;\n  }\n  var end = '';\n  if (availableLength > 0) {\n    end = truncatedUrl.substr(-1 * Math.floor(availableLength / 2));\n  }\n  return (truncatedUrl.substr(0, Math.ceil(availableLength / 2)) + ellipsisChars + end).substr(0, availableLength + ellipsisLengthBeforeParsing);\n}\n/**\n * Parses a URL into its components: scheme, host, path, query, and fragment.\n */\nfunction parseUrl(url) {\n  // Functionality inspired by PHP function of same name\n  var urlObj = {};\n  var urlSub = url;\n  // Parse scheme\n  var match = urlSub.match(/^([a-z]+):\\/\\//i);\n  if (match) {\n    urlObj.scheme = match[1];\n    urlSub = urlSub.slice(match[0].length);\n  }\n  // Parse host\n  match = urlSub.match(/^(.*?)(?=(\\?|#|\\/|$))/i);\n  if (match) {\n    urlObj.host = match[1];\n    urlSub = urlSub.slice(match[0].length);\n  }\n  // Parse path\n  match = urlSub.match(/^\\/(.*?)(?=(\\?|#|$))/i);\n  if (match) {\n    urlObj.path = match[1];\n    urlSub = urlSub.slice(match[0].length);\n  }\n  // Parse query\n  match = urlSub.match(/^\\?(.*?)(?=(#|$))/i);\n  if (match) {\n    urlObj.query = match[1];\n    urlSub = urlSub.slice(match[0].length);\n  }\n  // Parse fragment\n  match = urlSub.match(/^#(.*?)$/i);\n  if (match) {\n    urlObj.fragment = match[1];\n    //urlSub = urlSub.slice(match[0].length);  -- not used. Uncomment if adding another block.\n  }\n  return urlObj;\n}\nfunction buildUrl(urlObj) {\n  var url = '';\n  if (urlObj.scheme && urlObj.host) {\n    url += urlObj.scheme + '://';\n  }\n  if (urlObj.host) {\n    url += urlObj.host;\n  }\n  if (urlObj.path) {\n    url += '/' + urlObj.path;\n  }\n  if (urlObj.query) {\n    url += '?' + urlObj.query;\n  }\n  if (urlObj.fragment) {\n    url += '#' + urlObj.fragment;\n  }\n  return url;\n}\nfunction buildSegment(segment, remainingAvailableLength, ellipsisChars) {\n  var remainingAvailableLengthHalf = remainingAvailableLength / 2;\n  var startOffset = Math.ceil(remainingAvailableLengthHalf);\n  var endOffset = -1 * Math.floor(remainingAvailableLengthHalf);\n  var end = '';\n  if (endOffset < 0) {\n    end = segment.substr(endOffset);\n  }\n  return segment.substr(0, startOffset) + ellipsisChars + end;\n}","map":{"version":3,"names":["truncateSmart","url","truncateLen","ellipsisChars","ellipsisLengthBeforeParsing","ellipsisLength","length","availableLength","urlObj","parseUrl","query","matchQuery","match","substr","buildUrl","host","replace","truncatedUrl","buildSegment","pathAndQuery","path","remainingAvailableLength","fragment","remainingAvailableLength2","scheme","end","Math","floor","ceil","urlSub","slice","segment","remainingAvailableLengthHalf","startOffset","endOffset"],"sources":["../../../src/truncate/truncate-smart.ts"],"sourcesContent":["/**\n * Date: 2015-10-05\n * Author: Kasper Søfren <soefritz@gmail.com> (https://github.com/kafoso)\n *\n * A truncation feature, where the ellipsis will be placed at a section within\n * the URL making it still somewhat human readable.\n *\n * @param {String} url\t\t\t\t\t\t A URL.\n * @param {Number} truncateLen\t\t The maximum length of the truncated output URL string.\n * @param {String} ellipsisChars\t The characters to place within the url, e.g. \"...\".\n * @return {String} The truncated URL.\n */\nexport function truncateSmart(url: string, truncateLen: number, ellipsisChars?: string) {\n    let ellipsisLengthBeforeParsing: number;\n    let ellipsisLength: number;\n\n    if (ellipsisChars == null) {\n        ellipsisChars = '&hellip;';\n        ellipsisLength = 3;\n        ellipsisLengthBeforeParsing = 8;\n    } else {\n        ellipsisLength = ellipsisChars.length;\n        ellipsisLengthBeforeParsing = ellipsisChars.length;\n    }\n\n    // If the URL is shorter than the truncate length, return it as is\n    if (url.length <= truncateLen) {\n        return url;\n    }\n\n    const availableLength = truncateLen - ellipsisLength;\n    const urlObj = parseUrl(url);\n\n    // Clean up the URL by removing any malformed query string\n    // (e.g. \"?foo=bar?ignorethis\")\n    if (urlObj.query) {\n        const matchQuery = urlObj.query.match(/^(.*?)(?=(\\?|#))(.*?)$/i);\n        if (matchQuery) {\n            // Malformed URL; two or more \"?\". Removed any content behind the 2nd.\n            urlObj.query = urlObj.query.substr(0, matchQuery[1].length);\n            url = buildUrl(urlObj);\n        }\n    }\n    if (url.length <= truncateLen) {\n        return url; // removing a malformed query string brought the URL under the truncateLength\n    }\n\n    // Clean up the URL by removing 'www.' from the host if it exists\n    if (urlObj.host) {\n        urlObj.host = urlObj.host.replace(/^www\\./, '');\n        url = buildUrl(urlObj);\n    }\n    if (url.length <= truncateLen) {\n        return url; // removing 'www.' brought the URL under the truncateLength\n    }\n\n    // Process and build the truncated URL, starting with the hostname\n    let truncatedUrl = '';\n    if (urlObj.host) {\n        truncatedUrl += urlObj.host;\n    }\n    if (truncatedUrl.length >= availableLength) {\n        if (urlObj.host!.length === truncateLen) {\n            return (urlObj.host!.substr(0, truncateLen - ellipsisLength) + ellipsisChars).substr(\n                0,\n                availableLength + ellipsisLengthBeforeParsing\n            );\n        }\n        return buildSegment(truncatedUrl, availableLength, ellipsisChars).substr(\n            0,\n            availableLength + ellipsisLengthBeforeParsing\n        );\n    }\n\n    // If we still have available chars left, add the path and query string\n    let pathAndQuery = '';\n    if (urlObj.path) {\n        pathAndQuery += '/' + urlObj.path;\n    }\n    if (urlObj.query) {\n        pathAndQuery += '?' + urlObj.query;\n    }\n    if (pathAndQuery) {\n        if ((truncatedUrl + pathAndQuery).length >= availableLength) {\n            if ((truncatedUrl + pathAndQuery).length == truncateLen) {\n                return (truncatedUrl + pathAndQuery).substr(0, truncateLen);\n            }\n            const remainingAvailableLength = availableLength - truncatedUrl.length;\n            return (\n                truncatedUrl + buildSegment(pathAndQuery, remainingAvailableLength, ellipsisChars)\n            ).substr(0, availableLength + ellipsisLengthBeforeParsing);\n        } else {\n            truncatedUrl += pathAndQuery;\n        }\n    }\n\n    // If we still have available chars left, add the fragment\n    if (urlObj.fragment) {\n        const fragment = '#' + urlObj.fragment;\n        if ((truncatedUrl + fragment).length >= availableLength) {\n            if ((truncatedUrl + fragment).length == truncateLen) {\n                return (truncatedUrl + fragment).substr(0, truncateLen);\n            }\n            const remainingAvailableLength2 = availableLength - truncatedUrl.length;\n            return (\n                truncatedUrl + buildSegment(fragment, remainingAvailableLength2, ellipsisChars)\n            ).substr(0, availableLength + ellipsisLengthBeforeParsing);\n        } else {\n            truncatedUrl += fragment;\n        }\n    }\n\n    // If we still have available chars left, add the scheme\n    if (urlObj.scheme && urlObj.host) {\n        const scheme = urlObj.scheme + '://';\n        if ((truncatedUrl + scheme).length < availableLength) {\n            return (scheme + truncatedUrl).substr(0, truncateLen);\n        }\n    }\n    if (truncatedUrl.length <= truncateLen) {\n        return truncatedUrl;\n    }\n\n    let end = '';\n    if (availableLength > 0) {\n        end = truncatedUrl.substr(-1 * Math.floor(availableLength / 2));\n    }\n    return (truncatedUrl.substr(0, Math.ceil(availableLength / 2)) + ellipsisChars + end).substr(\n        0,\n        availableLength + ellipsisLengthBeforeParsing\n    );\n}\n\n/**\n * Parses a URL into its components: scheme, host, path, query, and fragment.\n */\nfunction parseUrl(url: string): UrlObject {\n    // Functionality inspired by PHP function of same name\n    const urlObj: UrlObject = {};\n    let urlSub = url;\n\n    // Parse scheme\n    let match = urlSub.match(/^([a-z]+):\\/\\//i);\n    if (match) {\n        urlObj.scheme = match[1];\n        urlSub = urlSub.slice(match[0].length);\n    }\n\n    // Parse host\n    match = urlSub.match(/^(.*?)(?=(\\?|#|\\/|$))/i);\n    if (match) {\n        urlObj.host = match[1];\n        urlSub = urlSub.slice(match[0].length);\n    }\n\n    // Parse path\n    match = urlSub.match(/^\\/(.*?)(?=(\\?|#|$))/i);\n    if (match) {\n        urlObj.path = match[1];\n        urlSub = urlSub.slice(match[0].length);\n    }\n\n    // Parse query\n    match = urlSub.match(/^\\?(.*?)(?=(#|$))/i);\n    if (match) {\n        urlObj.query = match[1];\n        urlSub = urlSub.slice(match[0].length);\n    }\n\n    // Parse fragment\n    match = urlSub.match(/^#(.*?)$/i);\n    if (match) {\n        urlObj.fragment = match[1];\n        //urlSub = urlSub.slice(match[0].length);  -- not used. Uncomment if adding another block.\n    }\n\n    return urlObj;\n}\n\nfunction buildUrl(urlObj: UrlObject): string {\n    let url = '';\n    if (urlObj.scheme && urlObj.host) {\n        url += urlObj.scheme + '://';\n    }\n    if (urlObj.host) {\n        url += urlObj.host;\n    }\n    if (urlObj.path) {\n        url += '/' + urlObj.path;\n    }\n    if (urlObj.query) {\n        url += '?' + urlObj.query;\n    }\n    if (urlObj.fragment) {\n        url += '#' + urlObj.fragment;\n    }\n    return url;\n}\n\nfunction buildSegment(segment: string, remainingAvailableLength: number, ellipsisChars: string) {\n    const remainingAvailableLengthHalf = remainingAvailableLength / 2;\n    const startOffset = Math.ceil(remainingAvailableLengthHalf);\n    const endOffset = -1 * Math.floor(remainingAvailableLengthHalf);\n\n    let end = '';\n    if (endOffset < 0) {\n        end = segment.substr(endOffset);\n    }\n    return segment.substr(0, startOffset) + ellipsisChars + end;\n}\n\ninterface UrlObject {\n    scheme?: string;\n    host?: string;\n    path?: string;\n    query?: string;\n    fragment?: string;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}