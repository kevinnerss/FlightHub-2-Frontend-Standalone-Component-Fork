{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport { ref, computed, watch } from 'vue';\nimport { isPct, getPct, isPx, getPx } from './useSize.mjs';\nimport { NOOP } from '@vue/shared';\nfunction useResize(panels, containerSize, pxSizes, lazy) {\n  const ptg2px = ptg => ptg * containerSize.value || 0;\n  function getLimitSize(str, defaultLimit) {\n    if (isPct(str)) {\n      return ptg2px(getPct(str));\n    } else if (isPx(str)) {\n      return getPx(str);\n    }\n    return str != null ? str : defaultLimit;\n  }\n  const lazyOffset = ref(0);\n  const movingIndex = ref(null);\n  let cachePxSizes = [];\n  let updatePanelSizes = NOOP;\n  const limitSizes = computed(() => panels.value.map(item => [item.min, item.max]));\n  watch(lazy, () => {\n    if (lazyOffset.value) {\n      const mouseup = new MouseEvent(\"mouseup\", {\n        bubbles: true\n      });\n      window.dispatchEvent(mouseup);\n    }\n  });\n  const onMoveStart = index => {\n    lazyOffset.value = 0;\n    movingIndex.value = {\n      index,\n      confirmed: false\n    };\n    cachePxSizes = pxSizes.value;\n  };\n  const onMoving = (index, offset) => {\n    var _a, _b;\n    let confirmedIndex = null;\n    if ((!movingIndex.value || !movingIndex.value.confirmed) && offset !== 0) {\n      if (offset > 0) {\n        confirmedIndex = index;\n        movingIndex.value = {\n          index,\n          confirmed: true\n        };\n      } else {\n        for (let i = index; i >= 0; i -= 1) {\n          if (cachePxSizes[i] > 0) {\n            confirmedIndex = i;\n            movingIndex.value = {\n              index: i,\n              confirmed: true\n            };\n            break;\n          }\n        }\n      }\n    }\n    const mergedIndex = (_b = confirmedIndex != null ? confirmedIndex : (_a = movingIndex.value) == null ? void 0 : _a.index) != null ? _b : index;\n    const numSizes = [...cachePxSizes];\n    const nextIndex = mergedIndex + 1;\n    const startMinSize = getLimitSize(limitSizes.value[mergedIndex][0], 0);\n    const endMinSize = getLimitSize(limitSizes.value[nextIndex][0], 0);\n    const startMaxSize = getLimitSize(limitSizes.value[mergedIndex][1], containerSize.value || 0);\n    const endMaxSize = getLimitSize(limitSizes.value[nextIndex][1], containerSize.value || 0);\n    let mergedOffset = offset;\n    if (numSizes[mergedIndex] + mergedOffset < startMinSize) {\n      mergedOffset = startMinSize - numSizes[mergedIndex];\n    }\n    if (numSizes[nextIndex] - mergedOffset < endMinSize) {\n      mergedOffset = numSizes[nextIndex] - endMinSize;\n    }\n    if (numSizes[mergedIndex] + mergedOffset > startMaxSize) {\n      mergedOffset = startMaxSize - numSizes[mergedIndex];\n    }\n    if (numSizes[nextIndex] - mergedOffset > endMaxSize) {\n      mergedOffset = numSizes[nextIndex] - endMaxSize;\n    }\n    numSizes[mergedIndex] += mergedOffset;\n    numSizes[nextIndex] -= mergedOffset;\n    lazyOffset.value = mergedOffset;\n    updatePanelSizes = () => {\n      panels.value.forEach((panel, index2) => {\n        panel.size = numSizes[index2];\n      });\n      updatePanelSizes = NOOP;\n    };\n    if (!lazy.value) {\n      updatePanelSizes();\n    }\n  };\n  const onMoveEnd = () => {\n    if (lazy.value) {\n      updatePanelSizes();\n    }\n    lazyOffset.value = 0;\n    movingIndex.value = null;\n    cachePxSizes = [];\n  };\n  const cacheCollapsedSize = [];\n  const onCollapse = (index, type) => {\n    if (!cacheCollapsedSize.length) {\n      cacheCollapsedSize.push(...pxSizes.value);\n    }\n    const currentSizes = pxSizes.value;\n    const currentIndex = type === \"start\" ? index : index + 1;\n    const targetIndex = type === \"start\" ? index + 1 : index;\n    const currentSize = currentSizes[currentIndex];\n    const targetSize = currentSizes[targetIndex];\n    if (currentSize !== 0 && targetSize !== 0) {\n      currentSizes[currentIndex] = 0;\n      currentSizes[targetIndex] += currentSize;\n      cacheCollapsedSize[index] = currentSize;\n    } else {\n      const totalSize = currentSize + targetSize;\n      const targetCacheCollapsedSize = cacheCollapsedSize[index];\n      const currentCacheCollapsedSize = totalSize - targetCacheCollapsedSize;\n      currentSizes[targetIndex] = targetCacheCollapsedSize;\n      currentSizes[currentIndex] = currentCacheCollapsedSize;\n    }\n    panels.value.forEach((panel, index2) => {\n      panel.size = currentSizes[index2];\n    });\n  };\n  return {\n    lazyOffset,\n    onMoveStart,\n    onMoving,\n    onMoveEnd,\n    movingIndex,\n    onCollapse\n  };\n}\nexport { useResize };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}