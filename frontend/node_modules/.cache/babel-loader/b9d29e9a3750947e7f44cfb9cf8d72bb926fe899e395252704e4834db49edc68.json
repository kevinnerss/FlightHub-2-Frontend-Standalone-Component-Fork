{"ast":null,"code":"import defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport SelectedFeatureIdStageCommon from \"../../Shaders/Model/SelectedFeatureIdStageCommon.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\n/**\n * The selected feature ID pipeline stage is responsible for handling the\n * set of feature IDs selected for styling/picking.\n *\n * @namespace SelectedFeatureIdPipelineStage\n * @private\n */\nconst SelectedFeatureIdPipelineStage = {\n  name: \"SelectedFeatureIdPipelineStage\",\n  // Helps with debugging\n\n  STRUCT_ID_SELECTED_FEATURE: \"SelectedFeature\",\n  STRUCT_NAME_SELECTED_FEATURE: \"SelectedFeature\"\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render resources:\n * <ul>\n *  <li>sets the defines for the feature ID attribute to use for styling/picking</li>\n *  <li>adds fields to the SelectedFeature struct in the shader</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n */\nSelectedFeatureIdPipelineStage.process = function (renderResources, primitive, frameState) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  renderResources.hasPropertyTable = true;\n  const model = renderResources.model;\n  const node = renderResources.runtimeNode.node;\n  const selectedFeatureIds = getSelectedFeatureIds(model, node, primitive);\n  const shaderDestination = selectedFeatureIds.shaderDestination;\n  shaderBuilder.addDefine(\"HAS_SELECTED_FEATURE_ID\", undefined, shaderDestination);\n\n  // Add a define to insert the variable to use.\n  // Example: #define SELECTED_FEATURE_ID featureId_1\n  // This corresponds to featureIds.featureId_1\n  shaderBuilder.addDefine(\"SELECTED_FEATURE_ID\", selectedFeatureIds.variableName, shaderDestination);\n\n  // Add a define to the shader to distinguish feature ID attributes from\n  // textures. This is needed for determining where to filter features\n  // by pass type.\n  shaderBuilder.addDefine(selectedFeatureIds.featureIdDefine, undefined, shaderDestination);\n  updateFeatureStruct(shaderBuilder);\n  const nullFeatureId = selectedFeatureIds.featureIds.nullFeatureId;\n  const uniformMap = renderResources.uniformMap;\n  if (defined(nullFeatureId)) {\n    shaderBuilder.addDefine(\"HAS_NULL_FEATURE_ID\", undefined, shaderDestination);\n    shaderBuilder.addUniform(\"int\", \"model_nullFeatureId\", shaderDestination);\n    uniformMap.model_nullFeatureId = function () {\n      return nullFeatureId;\n    };\n  }\n  if (selectedFeatureIds.shaderDestination === ShaderDestination.BOTH) {\n    shaderBuilder.addVertexLines(SelectedFeatureIdStageCommon);\n  }\n  shaderBuilder.addFragmentLines(SelectedFeatureIdStageCommon);\n};\nfunction getFeatureIdDefine(featureIds) {\n  if (featureIds instanceof ModelComponents.FeatureIdTexture) {\n    return \"HAS_SELECTED_FEATURE_ID_TEXTURE\";\n  }\n  return \"HAS_SELECTED_FEATURE_ID_ATTRIBUTE\";\n}\nfunction getShaderDestination(featureIds) {\n  // Feature ID textures are only supported in the fragment shader.\n  if (featureIds instanceof ModelComponents.FeatureIdTexture) {\n    return ShaderDestination.FRAGMENT;\n  }\n  return ShaderDestination.BOTH;\n}\nfunction getSelectedFeatureIds(model, node, primitive) {\n  let variableName;\n  let featureIds;\n  // Check instances first, as this is the most specific type of\n  // feature ID\n  if (defined(node.instances)) {\n    featureIds = ModelUtility.getFeatureIdsByLabel(node.instances.featureIds, model.instanceFeatureIdLabel);\n    if (defined(featureIds)) {\n      // Either label could be used here, but prefer label as it may be more\n      // meaningful when debugging\n      variableName = featureIds.label ?? featureIds.positionalLabel;\n      return {\n        featureIds: featureIds,\n        variableName: variableName,\n        shaderDestination: getShaderDestination(featureIds),\n        featureIdDefine: getFeatureIdDefine(featureIds)\n      };\n    }\n  }\n  featureIds = ModelUtility.getFeatureIdsByLabel(primitive.featureIds, model.featureIdLabel);\n  // again, prefer label for being more descriptive\n  variableName = featureIds.label ?? featureIds.positionalLabel;\n  return {\n    featureIds: featureIds,\n    variableName: variableName,\n    shaderDestination: getShaderDestination(featureIds),\n    featureIdDefine: getFeatureIdDefine(featureIds)\n  };\n}\n\n/**\n * Populate the \"SelectedFeature\" struct in the shaders that holds information about the \"active\" (used for picking/styling) feature.\n * The struct is always added to the shader by the GeometryPipelineStage (required for compilation). The SelectedFeature struct looks\n * as follows:\n *\n * struct SelectedFeature {\n *   int id;\n *   vec2 st;\n *   vec4 color;\n * }\n *\n * @private\n */\nfunction updateFeatureStruct(shaderBuilder) {\n  shaderBuilder.addStructField(SelectedFeatureIdPipelineStage.STRUCT_ID_SELECTED_FEATURE, \"int\", \"id\");\n  shaderBuilder.addStructField(SelectedFeatureIdPipelineStage.STRUCT_ID_SELECTED_FEATURE, \"vec2\", \"st\");\n  shaderBuilder.addStructField(SelectedFeatureIdPipelineStage.STRUCT_ID_SELECTED_FEATURE, \"vec4\", \"color\");\n}\nexport default SelectedFeatureIdPipelineStage;","map":{"version":3,"names":["defined","ShaderDestination","SelectedFeatureIdStageCommon","ModelComponents","ModelUtility","SelectedFeatureIdPipelineStage","name","STRUCT_ID_SELECTED_FEATURE","STRUCT_NAME_SELECTED_FEATURE","process","renderResources","primitive","frameState","shaderBuilder","hasPropertyTable","model","node","runtimeNode","selectedFeatureIds","getSelectedFeatureIds","shaderDestination","addDefine","undefined","variableName","featureIdDefine","updateFeatureStruct","nullFeatureId","featureIds","uniformMap","addUniform","model_nullFeatureId","BOTH","addVertexLines","addFragmentLines","getFeatureIdDefine","FeatureIdTexture","getShaderDestination","FRAGMENT","instances","getFeatureIdsByLabel","instanceFeatureIdLabel","label","positionalLabel","featureIdLabel","addStructField"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Model/SelectedFeatureIdPipelineStage.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport SelectedFeatureIdStageCommon from \"../../Shaders/Model/SelectedFeatureIdStageCommon.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\n/**\n * The selected feature ID pipeline stage is responsible for handling the\n * set of feature IDs selected for styling/picking.\n *\n * @namespace SelectedFeatureIdPipelineStage\n * @private\n */\nconst SelectedFeatureIdPipelineStage = {\n  name: \"SelectedFeatureIdPipelineStage\", // Helps with debugging\n\n  STRUCT_ID_SELECTED_FEATURE: \"SelectedFeature\",\n  STRUCT_NAME_SELECTED_FEATURE: \"SelectedFeature\",\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render resources:\n * <ul>\n *  <li>sets the defines for the feature ID attribute to use for styling/picking</li>\n *  <li>adds fields to the SelectedFeature struct in the shader</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n */\nSelectedFeatureIdPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  renderResources.hasPropertyTable = true;\n\n  const model = renderResources.model;\n  const node = renderResources.runtimeNode.node;\n  const selectedFeatureIds = getSelectedFeatureIds(model, node, primitive);\n  const shaderDestination = selectedFeatureIds.shaderDestination;\n\n  shaderBuilder.addDefine(\n    \"HAS_SELECTED_FEATURE_ID\",\n    undefined,\n    shaderDestination,\n  );\n\n  // Add a define to insert the variable to use.\n  // Example: #define SELECTED_FEATURE_ID featureId_1\n  // This corresponds to featureIds.featureId_1\n  shaderBuilder.addDefine(\n    \"SELECTED_FEATURE_ID\",\n    selectedFeatureIds.variableName,\n    shaderDestination,\n  );\n\n  // Add a define to the shader to distinguish feature ID attributes from\n  // textures. This is needed for determining where to filter features\n  // by pass type.\n  shaderBuilder.addDefine(\n    selectedFeatureIds.featureIdDefine,\n    undefined,\n    shaderDestination,\n  );\n\n  updateFeatureStruct(shaderBuilder);\n\n  const nullFeatureId = selectedFeatureIds.featureIds.nullFeatureId;\n  const uniformMap = renderResources.uniformMap;\n  if (defined(nullFeatureId)) {\n    shaderBuilder.addDefine(\n      \"HAS_NULL_FEATURE_ID\",\n      undefined,\n      shaderDestination,\n    );\n    shaderBuilder.addUniform(\"int\", \"model_nullFeatureId\", shaderDestination);\n    uniformMap.model_nullFeatureId = function () {\n      return nullFeatureId;\n    };\n  }\n\n  if (selectedFeatureIds.shaderDestination === ShaderDestination.BOTH) {\n    shaderBuilder.addVertexLines(SelectedFeatureIdStageCommon);\n  }\n  shaderBuilder.addFragmentLines(SelectedFeatureIdStageCommon);\n};\n\nfunction getFeatureIdDefine(featureIds) {\n  if (featureIds instanceof ModelComponents.FeatureIdTexture) {\n    return \"HAS_SELECTED_FEATURE_ID_TEXTURE\";\n  }\n\n  return \"HAS_SELECTED_FEATURE_ID_ATTRIBUTE\";\n}\n\nfunction getShaderDestination(featureIds) {\n  // Feature ID textures are only supported in the fragment shader.\n  if (featureIds instanceof ModelComponents.FeatureIdTexture) {\n    return ShaderDestination.FRAGMENT;\n  }\n\n  return ShaderDestination.BOTH;\n}\n\nfunction getSelectedFeatureIds(model, node, primitive) {\n  let variableName;\n  let featureIds;\n  // Check instances first, as this is the most specific type of\n  // feature ID\n  if (defined(node.instances)) {\n    featureIds = ModelUtility.getFeatureIdsByLabel(\n      node.instances.featureIds,\n      model.instanceFeatureIdLabel,\n    );\n\n    if (defined(featureIds)) {\n      // Either label could be used here, but prefer label as it may be more\n      // meaningful when debugging\n      variableName = featureIds.label ?? featureIds.positionalLabel;\n      return {\n        featureIds: featureIds,\n        variableName: variableName,\n        shaderDestination: getShaderDestination(featureIds),\n        featureIdDefine: getFeatureIdDefine(featureIds),\n      };\n    }\n  }\n\n  featureIds = ModelUtility.getFeatureIdsByLabel(\n    primitive.featureIds,\n    model.featureIdLabel,\n  );\n  // again, prefer label for being more descriptive\n  variableName = featureIds.label ?? featureIds.positionalLabel;\n  return {\n    featureIds: featureIds,\n    variableName: variableName,\n    shaderDestination: getShaderDestination(featureIds),\n    featureIdDefine: getFeatureIdDefine(featureIds),\n  };\n}\n\n/**\n * Populate the \"SelectedFeature\" struct in the shaders that holds information about the \"active\" (used for picking/styling) feature.\n * The struct is always added to the shader by the GeometryPipelineStage (required for compilation). The SelectedFeature struct looks\n * as follows:\n *\n * struct SelectedFeature {\n *   int id;\n *   vec2 st;\n *   vec4 color;\n * }\n *\n * @private\n */\nfunction updateFeatureStruct(shaderBuilder) {\n  shaderBuilder.addStructField(\n    SelectedFeatureIdPipelineStage.STRUCT_ID_SELECTED_FEATURE,\n    \"int\",\n    \"id\",\n  );\n\n  shaderBuilder.addStructField(\n    SelectedFeatureIdPipelineStage.STRUCT_ID_SELECTED_FEATURE,\n    \"vec2\",\n    \"st\",\n  );\n\n  shaderBuilder.addStructField(\n    SelectedFeatureIdPipelineStage.STRUCT_ID_SELECTED_FEATURE,\n    \"vec4\",\n    \"color\",\n  );\n}\n\nexport default SelectedFeatureIdPipelineStage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}