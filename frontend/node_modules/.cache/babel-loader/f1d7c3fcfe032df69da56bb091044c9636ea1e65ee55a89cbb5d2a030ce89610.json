{"ast":null,"code":"import { defineComponent, inject, toRefs, ref, getCurrentInstance, computed, watch, nextTick, reactive, onBeforeUnmount, openBlock, createElementBlock, Fragment, createElementVNode, mergeProps, unref, renderSlot, createBlock, withCtx, createCommentVNode } from 'vue';\nimport { isCollapsible, getCollapsible } from './hooks/usePanel.mjs';\nimport SplitBar from './split-bar.mjs';\nimport { splitterPanelProps } from './split-panel.mjs';\nimport { splitterRootContextKey } from './type.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { isPct, getPct, isPx, getPx } from './hooks/useSize.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { throwError } from '../../../utils/error.mjs';\nconst COMPONENT_NAME = \"ElSplitterPanel\";\nconst __default__ = defineComponent({\n  name: COMPONENT_NAME\n});\nconst _sfc_main = /* @__PURE__ */defineComponent({\n  ...__default__,\n  props: splitterPanelProps,\n  emits: [\"update:size\"],\n  setup(__props, {\n    emit: emits\n  }) {\n    const props = __props;\n    const ns = useNamespace(\"splitter-panel\");\n    const splitterContext = inject(splitterRootContextKey);\n    if (!splitterContext) throwError(COMPONENT_NAME, \"usage: <el-splitter><el-splitter-panel /></el-splitter/>\");\n    const {\n      panels,\n      layout,\n      lazy,\n      containerSize,\n      pxSizes\n    } = toRefs(splitterContext);\n    const {\n      registerPanel,\n      unregisterPanel,\n      onCollapse,\n      onMoveEnd,\n      onMoveStart,\n      onMoving\n    } = splitterContext;\n    const panelEl = ref();\n    const instance = getCurrentInstance();\n    const uid = instance.uid;\n    const index = ref(0);\n    const panel = computed(() => panels.value[index.value]);\n    const setIndex = val => {\n      index.value = val;\n    };\n    const panelSize = computed(() => {\n      var _a;\n      if (!panel.value) return 0;\n      return (_a = pxSizes.value[index.value]) != null ? _a : 0;\n    });\n    const nextSize = computed(() => {\n      var _a;\n      if (!panel.value) return 0;\n      return (_a = pxSizes.value[index.value + 1]) != null ? _a : 0;\n    });\n    const nextPanel = computed(() => {\n      if (panel.value) {\n        return panels.value[index.value + 1];\n      }\n      return null;\n    });\n    const isResizable = computed(() => {\n      var _a;\n      if (!nextPanel.value) return false;\n      return props.resizable && ((_a = nextPanel.value) == null ? void 0 : _a.resizable) && (panelSize.value !== 0 || !props.min) && (nextSize.value !== 0 || !nextPanel.value.min);\n    });\n    const isShowBar = computed(() => {\n      if (!panel.value) return false;\n      return index.value !== panels.value.length - 1;\n    });\n    const startCollapsible = computed(() => isCollapsible(panel.value, panelSize.value, nextPanel.value, nextSize.value));\n    const endCollapsible = computed(() => isCollapsible(nextPanel.value, nextSize.value, panel.value, panelSize.value));\n    function sizeToPx(str) {\n      if (isPct(str)) {\n        return getPct(str) * containerSize.value || 0;\n      } else if (isPx(str)) {\n        return getPx(str);\n      }\n      return str != null ? str : 0;\n    }\n    let isSizeUpdating = false;\n    watch(() => props.size, () => {\n      if (!isSizeUpdating && panel.value) {\n        if (!containerSize.value) {\n          panel.value.size = props.size;\n          return;\n        }\n        const size = sizeToPx(props.size);\n        const maxSize = sizeToPx(props.max);\n        const minSize = sizeToPx(props.min);\n        const finalSize = Math.min(Math.max(size, minSize || 0), maxSize || size);\n        if (finalSize !== size) {\n          emits(\"update:size\", finalSize);\n        }\n        panel.value.size = finalSize;\n      }\n    });\n    watch(() => {\n      var _a;\n      return (_a = panel.value) == null ? void 0 : _a.size;\n    }, val => {\n      if (val !== props.size) {\n        isSizeUpdating = true;\n        emits(\"update:size\", val);\n        nextTick(() => isSizeUpdating = false);\n      }\n    });\n    watch(() => props.resizable, val => {\n      if (panel.value) {\n        panel.value.resizable = val;\n      }\n    });\n    const _panel = reactive({\n      el: panelEl.value,\n      uid,\n      getVnode: () => instance.vnode,\n      setIndex,\n      ...props,\n      collapsible: computed(() => getCollapsible(props.collapsible))\n    });\n    registerPanel(_panel);\n    onBeforeUnmount(() => unregisterPanel(_panel));\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(Fragment, null, [createElementVNode(\"div\", mergeProps({\n        ref_key: \"panelEl\",\n        ref: panelEl,\n        class: [unref(ns).b()],\n        style: {\n          flexBasis: `${unref(panelSize)}px`\n        }\n      }, _ctx.$attrs), [renderSlot(_ctx.$slots, \"default\")], 16), unref(isShowBar) ? (openBlock(), createBlock(SplitBar, {\n        key: 0,\n        index: index.value,\n        layout: unref(layout),\n        lazy: unref(lazy),\n        resizable: unref(isResizable),\n        \"start-collapsible\": unref(startCollapsible),\n        \"end-collapsible\": unref(endCollapsible),\n        onMoveStart: unref(onMoveStart),\n        onMoving: unref(onMoving),\n        onMoveEnd: unref(onMoveEnd),\n        onCollapse: unref(onCollapse)\n      }, {\n        \"start-collapsible\": withCtx(() => [renderSlot(_ctx.$slots, \"start-collapsible\")]),\n        \"end-collapsible\": withCtx(() => [renderSlot(_ctx.$slots, \"end-collapsible\")]),\n        _: 3\n      }, 8, [\"index\", \"layout\", \"lazy\", \"resizable\", \"start-collapsible\", \"end-collapsible\", \"onMoveStart\", \"onMoving\", \"onMoveEnd\", \"onCollapse\"])) : createCommentVNode(\"v-if\", true)], 64);\n    };\n  }\n});\nvar SplitPanel = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"split-panel.vue\"]]);\nexport { SplitPanel as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}