{"ast":null,"code":"import Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport getImagePixels from \"../Core/getImagePixels.js\";\nimport Resource from \"../Core/Resource.js\";\n\n/**\n * A policy for discarding tile images that match a known image containing a\n * \"missing\" image.\n *\n * @alias DiscardMissingTileImagePolicy\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Resource|string} options.missingImageUrl The URL of the known missing image.\n * @param {Cartesian2[]} options.pixelsToCheck An array of {@link Cartesian2} pixel positions to\n *        compare against the missing image.\n * @param {boolean} [options.disableCheckIfAllPixelsAreTransparent=false] If true, the discard check will be disabled\n *                  if all of the pixelsToCheck in the missingImageUrl have an alpha value of 0.  If false, the\n *                  discard check will proceed no matter the values of the pixelsToCheck.\n */\nfunction DiscardMissingTileImagePolicy(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.missingImageUrl)) {\n    throw new DeveloperError(\"options.missingImageUrl is required.\");\n  }\n  if (!defined(options.pixelsToCheck)) {\n    throw new DeveloperError(\"options.pixelsToCheck is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._pixelsToCheck = options.pixelsToCheck;\n  this._missingImagePixels = undefined;\n  this._missingImageByteLength = undefined;\n  this._isReady = false;\n  const resource = Resource.createIfNeeded(options.missingImageUrl);\n  const that = this;\n  function success(image) {\n    if (defined(image.blob)) {\n      that._missingImageByteLength = image.blob.size;\n    }\n    let pixels = getImagePixels(image);\n    if (options.disableCheckIfAllPixelsAreTransparent) {\n      let allAreTransparent = true;\n      const width = image.width;\n      const pixelsToCheck = options.pixelsToCheck;\n      for (let i = 0, len = pixelsToCheck.length; allAreTransparent && i < len; ++i) {\n        const pos = pixelsToCheck[i];\n        const index = pos.x * 4 + pos.y * width;\n        const alpha = pixels[index + 3];\n        if (alpha > 0) {\n          allAreTransparent = false;\n        }\n      }\n      if (allAreTransparent) {\n        pixels = undefined;\n      }\n    }\n    that._missingImagePixels = pixels;\n    that._isReady = true;\n  }\n  function failure() {\n    // Failed to download \"missing\" image, so assume that any truly missing tiles\n    // will also fail to download and disable the discard check.\n    that._missingImagePixels = undefined;\n    that._isReady = true;\n  }\n  resource.fetchImage({\n    preferBlob: true,\n    preferImageBitmap: true,\n    flipY: true\n  }).then(success).catch(failure);\n}\n\n/**\n * Determines if the discard policy is ready to process images.\n * @returns {boolean} True if the discard policy is ready to process images; otherwise, false.\n */\nDiscardMissingTileImagePolicy.prototype.isReady = function () {\n  return this._isReady;\n};\n\n/**\n * Given a tile image, decide whether to discard that image.\n *\n * @param {HTMLImageElement} image An image to test.\n * @returns {boolean} True if the image should be discarded; otherwise, false.\n *\n * @exception {DeveloperError} <code>shouldDiscardImage</code> must not be called before the discard policy is ready.\n */\nDiscardMissingTileImagePolicy.prototype.shouldDiscardImage = function (image) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._isReady) {\n    throw new DeveloperError(\"shouldDiscardImage must not be called before the discard policy is ready.\");\n  }\n  //>>includeEnd('debug');\n\n  const pixelsToCheck = this._pixelsToCheck;\n  const missingImagePixels = this._missingImagePixels;\n\n  // If missingImagePixels is undefined, it indicates that the discard check has been disabled.\n  if (!defined(missingImagePixels)) {\n    return false;\n  }\n  if (defined(image.blob) && image.blob.size !== this._missingImageByteLength) {\n    return false;\n  }\n  const pixels = getImagePixels(image);\n  const width = image.width;\n  for (let i = 0, len = pixelsToCheck.length; i < len; ++i) {\n    const pos = pixelsToCheck[i];\n    const index = pos.x * 4 + pos.y * width;\n    for (let offset = 0; offset < 4; ++offset) {\n      const pixel = index + offset;\n      if (pixels[pixel] !== missingImagePixels[pixel]) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\nexport default DiscardMissingTileImagePolicy;","map":{"version":3,"names":["Frozen","defined","DeveloperError","getImagePixels","Resource","DiscardMissingTileImagePolicy","options","EMPTY_OBJECT","missingImageUrl","pixelsToCheck","_pixelsToCheck","_missingImagePixels","undefined","_missingImageByteLength","_isReady","resource","createIfNeeded","that","success","image","blob","size","pixels","disableCheckIfAllPixelsAreTransparent","allAreTransparent","width","i","len","length","pos","index","x","y","alpha","failure","fetchImage","preferBlob","preferImageBitmap","flipY","then","catch","prototype","isReady","shouldDiscardImage","missingImagePixels","offset","pixel"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/DiscardMissingTileImagePolicy.js"],"sourcesContent":["import Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport getImagePixels from \"../Core/getImagePixels.js\";\nimport Resource from \"../Core/Resource.js\";\n\n/**\n * A policy for discarding tile images that match a known image containing a\n * \"missing\" image.\n *\n * @alias DiscardMissingTileImagePolicy\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Resource|string} options.missingImageUrl The URL of the known missing image.\n * @param {Cartesian2[]} options.pixelsToCheck An array of {@link Cartesian2} pixel positions to\n *        compare against the missing image.\n * @param {boolean} [options.disableCheckIfAllPixelsAreTransparent=false] If true, the discard check will be disabled\n *                  if all of the pixelsToCheck in the missingImageUrl have an alpha value of 0.  If false, the\n *                  discard check will proceed no matter the values of the pixelsToCheck.\n */\nfunction DiscardMissingTileImagePolicy(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.missingImageUrl)) {\n    throw new DeveloperError(\"options.missingImageUrl is required.\");\n  }\n\n  if (!defined(options.pixelsToCheck)) {\n    throw new DeveloperError(\"options.pixelsToCheck is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._pixelsToCheck = options.pixelsToCheck;\n  this._missingImagePixels = undefined;\n  this._missingImageByteLength = undefined;\n  this._isReady = false;\n\n  const resource = Resource.createIfNeeded(options.missingImageUrl);\n\n  const that = this;\n\n  function success(image) {\n    if (defined(image.blob)) {\n      that._missingImageByteLength = image.blob.size;\n    }\n\n    let pixels = getImagePixels(image);\n\n    if (options.disableCheckIfAllPixelsAreTransparent) {\n      let allAreTransparent = true;\n      const width = image.width;\n\n      const pixelsToCheck = options.pixelsToCheck;\n      for (\n        let i = 0, len = pixelsToCheck.length;\n        allAreTransparent && i < len;\n        ++i\n      ) {\n        const pos = pixelsToCheck[i];\n        const index = pos.x * 4 + pos.y * width;\n        const alpha = pixels[index + 3];\n\n        if (alpha > 0) {\n          allAreTransparent = false;\n        }\n      }\n\n      if (allAreTransparent) {\n        pixels = undefined;\n      }\n    }\n\n    that._missingImagePixels = pixels;\n    that._isReady = true;\n  }\n\n  function failure() {\n    // Failed to download \"missing\" image, so assume that any truly missing tiles\n    // will also fail to download and disable the discard check.\n    that._missingImagePixels = undefined;\n    that._isReady = true;\n  }\n\n  resource\n    .fetchImage({\n      preferBlob: true,\n      preferImageBitmap: true,\n      flipY: true,\n    })\n    .then(success)\n    .catch(failure);\n}\n\n/**\n * Determines if the discard policy is ready to process images.\n * @returns {boolean} True if the discard policy is ready to process images; otherwise, false.\n */\nDiscardMissingTileImagePolicy.prototype.isReady = function () {\n  return this._isReady;\n};\n\n/**\n * Given a tile image, decide whether to discard that image.\n *\n * @param {HTMLImageElement} image An image to test.\n * @returns {boolean} True if the image should be discarded; otherwise, false.\n *\n * @exception {DeveloperError} <code>shouldDiscardImage</code> must not be called before the discard policy is ready.\n */\nDiscardMissingTileImagePolicy.prototype.shouldDiscardImage = function (image) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._isReady) {\n    throw new DeveloperError(\n      \"shouldDiscardImage must not be called before the discard policy is ready.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const pixelsToCheck = this._pixelsToCheck;\n  const missingImagePixels = this._missingImagePixels;\n\n  // If missingImagePixels is undefined, it indicates that the discard check has been disabled.\n  if (!defined(missingImagePixels)) {\n    return false;\n  }\n\n  if (defined(image.blob) && image.blob.size !== this._missingImageByteLength) {\n    return false;\n  }\n\n  const pixels = getImagePixels(image);\n  const width = image.width;\n\n  for (let i = 0, len = pixelsToCheck.length; i < len; ++i) {\n    const pos = pixelsToCheck[i];\n    const index = pos.x * 4 + pos.y * width;\n    for (let offset = 0; offset < 4; ++offset) {\n      const pixel = index + offset;\n      if (pixels[pixel] !== missingImagePixels[pixel]) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\nexport default DiscardMissingTileImagePolicy;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}