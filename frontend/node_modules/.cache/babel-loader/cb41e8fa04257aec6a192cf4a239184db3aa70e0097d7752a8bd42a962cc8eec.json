{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"// If the style color is white, it implies the feature has not been styled.\\n\\\nbool isDefaultStyleColor(vec3 color)\\n\\\n{\\n\\\n    return all(greaterThan(color, vec3(1.0 - czm_epsilon3)));\\n\\\n}\\n\\\n\\n\\\nvec3 blend(vec3 sourceColor, vec3 styleColor, float styleColorBlend)\\n\\\n{\\n\\\n    vec3 blendColor = mix(sourceColor, styleColor, styleColorBlend);\\n\\\n    vec3 color = isDefaultStyleColor(styleColor.rgb) ? sourceColor : blendColor;\\n\\\n    return color;\\n\\\n}\\n\\\n\\n\\\nvec2 computeTextureTransform(vec2 texCoord, mat3 textureTransform)\\n\\\n{\\n\\\n    return vec2(textureTransform * vec3(texCoord, 1.0));\\n\\\n}\\n\\\n\\n\\\n#ifdef HAS_NORMAL_TEXTURE\\n\\\nvec2 getNormalTexCoords()\\n\\\n{\\n\\\n    vec2 texCoord = TEXCOORD_NORMAL;\\n\\\n    #ifdef HAS_NORMAL_TEXTURE_TRANSFORM\\n\\\n        texCoord = vec2(u_normalTextureTransform * vec3(texCoord, 1.0));\\n\\\n    #endif\\n\\\n    return texCoord;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#if defined(HAS_NORMAL_TEXTURE) || defined(HAS_CLEARCOAT_NORMAL_TEXTURE)\\n\\\nvec3 computeTangent(in vec3 position, in vec2 normalTexCoords)\\n\\\n{\\n\\\n    vec2 tex_dx = dFdx(normalTexCoords);\\n\\\n    vec2 tex_dy = dFdy(normalTexCoords);\\n\\\n    float determinant = tex_dx.x * tex_dy.y - tex_dy.x * tex_dx.y;\\n\\\n    vec3 tangent = tex_dy.t * dFdx(position) - tex_dx.t * dFdy(position);\\n\\\n    return tangent / determinant;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#ifdef USE_ANISOTROPY\\n\\\nstruct NormalInfo {\\n\\\n    vec3 tangent;\\n\\\n    vec3 bitangent;\\n\\\n    vec3 normal;\\n\\\n    vec3 geometryNormal;\\n\\\n};\\n\\\n\\n\\\nNormalInfo getNormalInfo(ProcessedAttributes attributes)\\n\\\n{\\n\\\n    vec3 geometryNormal = attributes.normalEC;\\n\\\n    #ifdef HAS_NORMAL_TEXTURE\\n\\\n        vec2 normalTexCoords = getNormalTexCoords();\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_BITANGENTS\\n\\\n        vec3 tangent = attributes.tangentEC;\\n\\\n        vec3 bitangent = attributes.bitangentEC;\\n\\\n    #else // Assume HAS_NORMAL_TEXTURE\\n\\\n        vec3 tangent = computeTangent(attributes.positionEC, normalTexCoords);\\n\\\n        tangent = normalize(tangent - geometryNormal * dot(geometryNormal, tangent));\\n\\\n        vec3 bitangent = normalize(cross(geometryNormal, tangent));\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_NORMAL_TEXTURE\\n\\\n        mat3 tbn = mat3(tangent, bitangent, geometryNormal);\\n\\\n        vec3 normalSample = texture(u_normalTexture, normalTexCoords).rgb;\\n\\\n        normalSample = 2.0 * normalSample - 1.0;\\n\\\n        #ifdef HAS_NORMAL_TEXTURE_SCALE\\n\\\n            normalSample.xy *= u_normalTextureScale;\\n\\\n        #endif\\n\\\n        vec3 normal = normalize(tbn * normalSample);\\n\\\n    #else\\n\\\n        vec3 normal = geometryNormal;\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_DOUBLE_SIDED_MATERIAL\\n\\\n        if (czm_backFacing()) {\\n\\\n            tangent *= -1.0;\\n\\\n            bitangent *= -1.0;\\n\\\n            normal *= -1.0;\\n\\\n            geometryNormal *= -1.0;\\n\\\n        }\\n\\\n    #endif\\n\\\n\\n\\\n    NormalInfo normalInfo;\\n\\\n    normalInfo.tangent = tangent;\\n\\\n    normalInfo.bitangent = bitangent;\\n\\\n    normalInfo.normal = normal;\\n\\\n    normalInfo.geometryNormal = geometryNormal;\\n\\\n\\n\\\n    return normalInfo;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#if defined(HAS_NORMAL_TEXTURE) && !defined(HAS_WIREFRAME)\\n\\\nvec3 getNormalFromTexture(ProcessedAttributes attributes, vec3 geometryNormal)\\n\\\n{\\n\\\n    vec2 normalTexCoords = getNormalTexCoords();\\n\\\n\\n\\\n    // If HAS_BITANGENTS is set, then HAS_TANGENTS is also set\\n\\\n    #ifdef HAS_BITANGENTS\\n\\\n        vec3 t = attributes.tangentEC;\\n\\\n        vec3 b = attributes.bitangentEC;\\n\\\n    #else\\n\\\n        vec3 t = computeTangent(attributes.positionEC, normalTexCoords);\\n\\\n        t = normalize(t - geometryNormal * dot(geometryNormal, t));\\n\\\n        vec3 b = normalize(cross(geometryNormal, t));\\n\\\n    #endif\\n\\\n\\n\\\n    mat3 tbn = mat3(t, b, geometryNormal);\\n\\\n    vec3 normalSample = texture(u_normalTexture, normalTexCoords).rgb;\\n\\\n    normalSample = 2.0 * normalSample - 1.0;\\n\\\n    #ifdef HAS_NORMAL_TEXTURE_SCALE\\n\\\n        normalSample.xy *= u_normalTextureScale;\\n\\\n    #endif\\n\\\n    return normalize(tbn * normalSample);\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#ifdef HAS_CLEARCOAT_NORMAL_TEXTURE\\n\\\nvec3 getClearcoatNormalFromTexture(ProcessedAttributes attributes, vec3 geometryNormal)\\n\\\n{\\n\\\n    vec2 normalTexCoords = TEXCOORD_CLEARCOAT_NORMAL;\\n\\\n    #ifdef HAS_CLEARCOAT_NORMAL_TEXTURE_TRANSFORM\\n\\\n        normalTexCoords = vec2(u_clearcoatNormalTextureTransform * vec3(normalTexCoords, 1.0));\\n\\\n    #endif\\n\\\n\\n\\\n    // If HAS_BITANGENTS is set, then HAS_TANGENTS is also set\\n\\\n    #ifdef HAS_BITANGENTS\\n\\\n        vec3 t = attributes.tangentEC;\\n\\\n        vec3 b = attributes.bitangentEC;\\n\\\n    #else\\n\\\n        vec3 t = computeTangent(attributes.positionEC, normalTexCoords);\\n\\\n        t = normalize(t - geometryNormal * dot(geometryNormal, t));\\n\\\n        vec3 b = normalize(cross(geometryNormal, t));\\n\\\n    #endif\\n\\\n\\n\\\n    mat3 tbn = mat3(t, b, geometryNormal);\\n\\\n    vec3 normalSample = texture(u_clearcoatNormalTexture, normalTexCoords).rgb;\\n\\\n    normalSample = 2.0 * normalSample - 1.0;\\n\\\n    #ifdef HAS_CLEARCOAT_NORMAL_TEXTURE_SCALE\\n\\\n        normalSample.xy *= u_clearcoatNormalTextureScale;\\n\\\n    #endif\\n\\\n    return normalize(tbn * normalSample);\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#ifdef HAS_NORMALS\\n\\\nvec3 computeNormal(ProcessedAttributes attributes)\\n\\\n{\\n\\\n    // Geometry normal. This is already normalized \\n\\\n    vec3 normal = attributes.normalEC;\\n\\\n\\n\\\n    #if defined(HAS_NORMAL_TEXTURE) && !defined(HAS_WIREFRAME)\\n\\\n        normal = getNormalFromTexture(attributes, normal);\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_DOUBLE_SIDED_MATERIAL\\n\\\n        if (czm_backFacing()) {\\n\\\n            normal = -normal;\\n\\\n        }\\n\\\n    #endif\\n\\\n\\n\\\n    return normal;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#ifdef HAS_BASE_COLOR_TEXTURE\\n\\\nvec4 getBaseColorFromTexture()\\n\\\n{\\n\\\n    vec2 baseColorTexCoords = TEXCOORD_BASE_COLOR;\\n\\\n    #ifdef HAS_BASE_COLOR_TEXTURE_TRANSFORM\\n\\\n        baseColorTexCoords = computeTextureTransform(baseColorTexCoords, u_baseColorTextureTransform);\\n\\\n    #endif\\n\\\n\\n\\\n    vec4 baseColorWithAlpha = czm_srgbToLinear(texture(u_baseColorTexture, baseColorTexCoords));\\n\\\n\\n\\\n    #ifdef HAS_BASE_COLOR_FACTOR\\n\\\n        baseColorWithAlpha *= u_baseColorFactor;\\n\\\n    #endif\\n\\\n\\n\\\n    return baseColorWithAlpha;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#ifdef HAS_EMISSIVE_TEXTURE\\n\\\nvec3 getEmissiveFromTexture()\\n\\\n{\\n\\\n    vec2 emissiveTexCoords = TEXCOORD_EMISSIVE;\\n\\\n    #ifdef HAS_EMISSIVE_TEXTURE_TRANSFORM\\n\\\n        emissiveTexCoords = computeTextureTransform(emissiveTexCoords, u_emissiveTextureTransform);\\n\\\n    #endif\\n\\\n\\n\\\n    vec3 emissive = czm_srgbToLinear(texture(u_emissiveTexture, emissiveTexCoords).rgb);\\n\\\n    #ifdef HAS_EMISSIVE_FACTOR\\n\\\n        emissive *= u_emissiveFactor;\\n\\\n    #endif\\n\\\n\\n\\\n    return emissive;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#if defined(LIGHTING_PBR) && defined(USE_SPECULAR_GLOSSINESS)\\n\\\nvoid setSpecularGlossiness(inout czm_modelMaterial material)\\n\\\n{\\n\\\n    #ifdef HAS_SPECULAR_GLOSSINESS_TEXTURE\\n\\\n        vec2 specularGlossinessTexCoords = TEXCOORD_SPECULAR_GLOSSINESS;\\n\\\n        #ifdef HAS_SPECULAR_GLOSSINESS_TEXTURE_TRANSFORM\\n\\\n            specularGlossinessTexCoords = computeTextureTransform(specularGlossinessTexCoords, u_specularGlossinessTextureTransform);\\n\\\n        #endif\\n\\\n\\n\\\n        vec4 specularGlossiness = czm_srgbToLinear(texture(u_specularGlossinessTexture, specularGlossinessTexCoords));\\n\\\n        vec3 specular = specularGlossiness.rgb;\\n\\\n        float glossiness = specularGlossiness.a;\\n\\\n        #ifdef HAS_LEGACY_SPECULAR_FACTOR\\n\\\n            specular *= u_legacySpecularFactor;\\n\\\n        #endif\\n\\\n\\n\\\n        #ifdef HAS_GLOSSINESS_FACTOR\\n\\\n            glossiness *= u_glossinessFactor;\\n\\\n        #endif\\n\\\n    #else\\n\\\n        #ifdef HAS_LEGACY_SPECULAR_FACTOR\\n\\\n            vec3 specular = clamp(u_legacySpecularFactor, vec3(0.0), vec3(1.0));\\n\\\n        #else\\n\\\n            vec3 specular = vec3(1.0);\\n\\\n        #endif\\n\\\n\\n\\\n        #ifdef HAS_GLOSSINESS_FACTOR\\n\\\n            float glossiness = clamp(u_glossinessFactor, 0.0, 1.0);\\n\\\n        #else\\n\\\n            float glossiness = 1.0;\\n\\\n        #endif\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_DIFFUSE_TEXTURE\\n\\\n        vec2 diffuseTexCoords = TEXCOORD_DIFFUSE;\\n\\\n        #ifdef HAS_DIFFUSE_TEXTURE_TRANSFORM\\n\\\n            diffuseTexCoords = computeTextureTransform(diffuseTexCoords, u_diffuseTextureTransform);\\n\\\n        #endif\\n\\\n\\n\\\n        vec4 diffuse = czm_srgbToLinear(texture(u_diffuseTexture, diffuseTexCoords));\\n\\\n        #ifdef HAS_DIFFUSE_FACTOR\\n\\\n            diffuse *= u_diffuseFactor;\\n\\\n        #endif\\n\\\n    #elif defined(HAS_DIFFUSE_FACTOR)\\n\\\n        vec4 diffuse = clamp(u_diffuseFactor, vec4(0.0), vec4(1.0));\\n\\\n    #else\\n\\\n        vec4 diffuse = vec4(1.0);\\n\\\n    #endif\\n\\\n\\n\\\n    material.diffuse = diffuse.rgb * (1.0 - czm_maximumComponent(specular));\\n\\\n    // the specular glossiness extension's alpha overrides anything set\\n\\\n    // by the base material.\\n\\\n    material.alpha = diffuse.a;\\n\\\n\\n\\\n    material.specular = specular;\\n\\\n\\n\\\n    // glossiness is the opposite of roughness, but easier for artists to use.\\n\\\n    material.roughness = 1.0 - glossiness;\\n\\\n}\\n\\\n#elif defined(LIGHTING_PBR)\\n\\\nfloat setMetallicRoughness(inout czm_modelMaterial material)\\n\\\n{\\n\\\n    #ifdef HAS_METALLIC_ROUGHNESS_TEXTURE\\n\\\n        vec2 metallicRoughnessTexCoords = TEXCOORD_METALLIC_ROUGHNESS;\\n\\\n        #ifdef HAS_METALLIC_ROUGHNESS_TEXTURE_TRANSFORM\\n\\\n            metallicRoughnessTexCoords = computeTextureTransform(metallicRoughnessTexCoords, u_metallicRoughnessTextureTransform);\\n\\\n        #endif\\n\\\n\\n\\\n        vec3 metallicRoughness = texture(u_metallicRoughnessTexture, metallicRoughnessTexCoords).rgb;\\n\\\n        float metalness = clamp(metallicRoughness.b, 0.0, 1.0);\\n\\\n        float roughness = clamp(metallicRoughness.g, 0.0, 1.0);\\n\\\n        #ifdef HAS_METALLIC_FACTOR\\n\\\n            metalness = clamp(metalness * u_metallicFactor, 0.0, 1.0);\\n\\\n        #endif\\n\\\n\\n\\\n        #ifdef HAS_ROUGHNESS_FACTOR\\n\\\n            roughness = clamp(roughness * u_roughnessFactor, 0.0, 1.0);\\n\\\n        #endif\\n\\\n    #else\\n\\\n        #ifdef HAS_METALLIC_FACTOR\\n\\\n            float metalness = clamp(u_metallicFactor, 0.0, 1.0);\\n\\\n        #else\\n\\\n            float metalness = 1.0;\\n\\\n        #endif\\n\\\n\\n\\\n        #ifdef HAS_ROUGHNESS_FACTOR\\n\\\n            float roughness = clamp(u_roughnessFactor, 0.0, 1.0);\\n\\\n        #else\\n\\\n            float roughness = 1.0;\\n\\\n        #endif\\n\\\n    #endif\\n\\\n\\n\\\n    // dielectrics use f0 = 0.04, metals use albedo as f0\\n\\\n    const vec3 REFLECTANCE_DIELECTRIC = vec3(0.04);\\n\\\n    vec3 f0 = mix(REFLECTANCE_DIELECTRIC, material.baseColor.rgb, metalness);\\n\\\n\\n\\\n    material.specular = f0;\\n\\\n\\n\\\n    // diffuse only applies to dielectrics.\\n\\\n    material.diffuse = mix(material.baseColor.rgb, vec3(0.0), metalness);\\n\\\n\\n\\\n    // This is perceptual roughness. The square of this value is used for direct lighting\\n\\\n    material.roughness = roughness;\\n\\\n\\n\\\n    return metalness;\\n\\\n}\\n\\\n#ifdef USE_SPECULAR\\n\\\nvoid setSpecular(inout czm_modelMaterial material, in float metalness)\\n\\\n{\\n\\\n    #ifdef HAS_SPECULAR_TEXTURE\\n\\\n        vec2 specularTexCoords = TEXCOORD_SPECULAR;\\n\\\n        #ifdef HAS_SPECULAR_TEXTURE_TRANSFORM\\n\\\n            specularTexCoords = computeTextureTransform(specularTexCoords, u_specularTextureTransform);\\n\\\n        #endif\\n\\\n        float specularWeight = texture(u_specularTexture, specularTexCoords).a;\\n\\\n        #ifdef HAS_SPECULAR_FACTOR\\n\\\n            specularWeight *= u_specularFactor;\\n\\\n        #endif\\n\\\n    #else\\n\\\n        #ifdef HAS_SPECULAR_FACTOR\\n\\\n            float specularWeight = u_specularFactor;\\n\\\n        #else\\n\\\n            float specularWeight = 1.0;\\n\\\n        #endif\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_SPECULAR_COLOR_TEXTURE\\n\\\n        vec2 specularColorTexCoords = TEXCOORD_SPECULAR_COLOR;\\n\\\n        #ifdef HAS_SPECULAR_COLOR_TEXTURE_TRANSFORM\\n\\\n            specularColorTexCoords = computeTextureTransform(specularColorTexCoords, u_specularColorTextureTransform);\\n\\\n        #endif\\n\\\n        vec3 specularColorSample = texture(u_specularColorTexture, specularColorTexCoords).rgb;\\n\\\n        vec3 specularColorFactor = czm_srgbToLinear(specularColorSample);\\n\\\n        #ifdef HAS_SPECULAR_COLOR_FACTOR\\n\\\n            specularColorFactor *= u_specularColorFactor;\\n\\\n        #endif\\n\\\n    #else\\n\\\n        #ifdef HAS_SPECULAR_COLOR_FACTOR\\n\\\n            vec3 specularColorFactor = u_specularColorFactor;\\n\\\n        #else\\n\\\n            vec3 specularColorFactor = vec3(1.0);\\n\\\n        #endif\\n\\\n    #endif\\n\\\n    material.specularWeight = specularWeight;\\n\\\n    vec3 f0 = material.specular;\\n\\\n    vec3 dielectricSpecularF0 = min(f0 * specularColorFactor, vec3(1.0));\\n\\\n    material.specular = mix(dielectricSpecularF0, material.baseColor.rgb, metalness);\\n\\\n}\\n\\\n#endif\\n\\\n#ifdef USE_ANISOTROPY\\n\\\nvoid setAnisotropy(inout czm_modelMaterial material, in NormalInfo normalInfo)\\n\\\n{\\n\\\n    mat2 rotation = mat2(u_anisotropy.xy, -u_anisotropy.y, u_anisotropy.x);\\n\\\n    float anisotropyStrength = u_anisotropy.z;\\n\\\n\\n\\\n    vec2 direction = vec2(1.0, 0.0);\\n\\\n    #ifdef HAS_ANISOTROPY_TEXTURE\\n\\\n        vec2 anisotropyTexCoords = TEXCOORD_ANISOTROPY;\\n\\\n        #ifdef HAS_ANISOTROPY_TEXTURE_TRANSFORM\\n\\\n            anisotropyTexCoords = computeTextureTransform(anisotropyTexCoords, u_anisotropyTextureTransform);\\n\\\n        #endif\\n\\\n        vec3 anisotropySample = texture(u_anisotropyTexture, anisotropyTexCoords).rgb;\\n\\\n        direction = anisotropySample.rg * 2.0 - vec2(1.0);\\n\\\n        anisotropyStrength *= anisotropySample.b;\\n\\\n    #endif\\n\\\n\\n\\\n    direction = rotation * direction;\\n\\\n    mat3 tbn = mat3(normalInfo.tangent, normalInfo.bitangent, normalInfo.normal);\\n\\\n    vec3 anisotropicT = tbn * normalize(vec3(direction, 0.0));\\n\\\n    vec3 anisotropicB = cross(normalInfo.geometryNormal, anisotropicT);\\n\\\n\\n\\\n    material.anisotropicT = anisotropicT;\\n\\\n    material.anisotropicB = anisotropicB;\\n\\\n    material.anisotropyStrength = anisotropyStrength;\\n\\\n}\\n\\\n#endif\\n\\\n#ifdef USE_CLEARCOAT\\n\\\nvoid setClearcoat(inout czm_modelMaterial material, in ProcessedAttributes attributes)\\n\\\n{\\n\\\n    #ifdef HAS_CLEARCOAT_TEXTURE\\n\\\n        vec2 clearcoatTexCoords = TEXCOORD_CLEARCOAT;\\n\\\n        #ifdef HAS_CLEARCOAT_TEXTURE_TRANSFORM\\n\\\n            clearcoatTexCoords = computeTextureTransform(clearcoatTexCoords, u_clearcoatTextureTransform);\\n\\\n        #endif\\n\\\n        float clearcoatFactor = texture(u_clearcoatTexture, clearcoatTexCoords).r;\\n\\\n        #ifdef HAS_CLEARCOAT_FACTOR\\n\\\n            clearcoatFactor *= u_clearcoatFactor;\\n\\\n        #endif\\n\\\n    #else\\n\\\n        #ifdef HAS_CLEARCOAT_FACTOR\\n\\\n            float clearcoatFactor = u_clearcoatFactor;\\n\\\n        #else\\n\\\n            // PERFORMANCE_IDEA: this case should turn the whole extension off\\n\\\n            float clearcoatFactor = 0.0;\\n\\\n        #endif\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_CLEARCOAT_ROUGHNESS_TEXTURE\\n\\\n        vec2 clearcoatRoughnessTexCoords = TEXCOORD_CLEARCOAT_ROUGHNESS;\\n\\\n        #ifdef HAS_CLEARCOAT_ROUGHNESS_TEXTURE_TRANSFORM\\n\\\n            clearcoatRoughnessTexCoords = computeTextureTransform(clearcoatRoughnessTexCoords, u_clearcoatRoughnessTextureTransform);\\n\\\n        #endif\\n\\\n        float clearcoatRoughness = texture(u_clearcoatRoughnessTexture, clearcoatRoughnessTexCoords).g;\\n\\\n        #ifdef HAS_CLEARCOAT_ROUGHNESS_FACTOR\\n\\\n            clearcoatRoughness *= u_clearcoatRoughnessFactor;\\n\\\n        #endif\\n\\\n    #else\\n\\\n        #ifdef HAS_CLEARCOAT_ROUGHNESS_FACTOR\\n\\\n            float clearcoatRoughness = u_clearcoatRoughnessFactor;\\n\\\n        #else\\n\\\n            float clearcoatRoughness = 0.0;\\n\\\n        #endif\\n\\\n    #endif\\n\\\n\\n\\\n    material.clearcoatFactor = clearcoatFactor;\\n\\\n    // This is perceptual roughness. The square of this value is used for direct lighting\\n\\\n    material.clearcoatRoughness = clearcoatRoughness;\\n\\\n    #ifdef HAS_CLEARCOAT_NORMAL_TEXTURE\\n\\\n        material.clearcoatNormal = getClearcoatNormalFromTexture(attributes, attributes.normalEC);\\n\\\n    #else\\n\\\n        material.clearcoatNormal = attributes.normalEC;\\n\\\n    #endif\\n\\\n}\\n\\\n#endif\\n\\\n#endif\\n\\\n\\n\\\nvoid materialStage(inout czm_modelMaterial material, ProcessedAttributes attributes, SelectedFeature feature)\\n\\\n{\\n\\\n    #ifdef USE_ANISOTROPY\\n\\\n        NormalInfo normalInfo = getNormalInfo(attributes);\\n\\\n        material.normalEC = normalInfo.normal;\\n\\\n    #elif defined(HAS_NORMALS)\\n\\\n        material.normalEC = computeNormal(attributes);\\n\\\n    #endif\\n\\\n\\n\\\n    vec4 baseColorWithAlpha = vec4(1.0);\\n\\\n    // Regardless of whether we use PBR, set a base color\\n\\\n    #ifdef HAS_BASE_COLOR_TEXTURE\\n\\\n        baseColorWithAlpha = getBaseColorFromTexture();\\n\\\n    #elif defined(HAS_BASE_COLOR_FACTOR)\\n\\\n        baseColorWithAlpha = u_baseColorFactor;\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_IMAGERY\\n\\\n    baseColorWithAlpha = blendBaseColorWithImagery(baseColorWithAlpha);\\n\\\n    #endif // HAS_IMAGERY\\n\\\n\\n\\\n    #ifdef HAS_POINT_CLOUD_COLOR_STYLE\\n\\\n        baseColorWithAlpha = v_pointCloudColor;\\n\\\n    #elif defined(HAS_COLOR_0)\\n\\\n        vec4 color = attributes.color_0;\\n\\\n        // .pnts files store colors in the sRGB color space\\n\\\n        #ifdef HAS_SRGB_COLOR\\n\\\n            color = czm_srgbToLinear(color);\\n\\\n        #endif\\n\\\n        baseColorWithAlpha *= color;\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef USE_CPU_STYLING\\n\\\n        baseColorWithAlpha.rgb = blend(baseColorWithAlpha.rgb, feature.color.rgb, model_colorBlend);\\n\\\n    #endif\\n\\\n    material.baseColor = baseColorWithAlpha;\\n\\\n    material.diffuse = baseColorWithAlpha.rgb;\\n\\\n    material.alpha = baseColorWithAlpha.a;\\n\\\n\\n\\\n    #ifdef HAS_OCCLUSION_TEXTURE\\n\\\n        vec2 occlusionTexCoords = TEXCOORD_OCCLUSION;\\n\\\n        #ifdef HAS_OCCLUSION_TEXTURE_TRANSFORM\\n\\\n            occlusionTexCoords = computeTextureTransform(occlusionTexCoords, u_occlusionTextureTransform);\\n\\\n        #endif\\n\\\n        material.occlusion = texture(u_occlusionTexture, occlusionTexCoords).r;\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_EMISSIVE_TEXTURE\\n\\\n        material.emissive = getEmissiveFromTexture();\\n\\\n    #elif defined(HAS_EMISSIVE_FACTOR)\\n\\\n        material.emissive = u_emissiveFactor;\\n\\\n    #endif\\n\\\n\\n\\\n    #if defined(LIGHTING_PBR) && defined(USE_SPECULAR_GLOSSINESS)\\n\\\n        setSpecularGlossiness(material);\\n\\\n    #elif defined(LIGHTING_PBR)\\n\\\n        float metalness = setMetallicRoughness(material);\\n\\\n        #ifdef USE_SPECULAR\\n\\\n            setSpecular(material, metalness);\\n\\\n        #endif\\n\\\n        #ifdef USE_ANISOTROPY\\n\\\n            setAnisotropy(material, normalInfo);\\n\\\n        #endif\\n\\\n        #ifdef USE_CLEARCOAT\\n\\\n            setClearcoat(material, attributes);\\n\\\n        #endif\\n\\\n    #endif\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Shaders/Model/MaterialStageFS.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"// If the style color is white, it implies the feature has not been styled.\\n\\\nbool isDefaultStyleColor(vec3 color)\\n\\\n{\\n\\\n    return all(greaterThan(color, vec3(1.0 - czm_epsilon3)));\\n\\\n}\\n\\\n\\n\\\nvec3 blend(vec3 sourceColor, vec3 styleColor, float styleColorBlend)\\n\\\n{\\n\\\n    vec3 blendColor = mix(sourceColor, styleColor, styleColorBlend);\\n\\\n    vec3 color = isDefaultStyleColor(styleColor.rgb) ? sourceColor : blendColor;\\n\\\n    return color;\\n\\\n}\\n\\\n\\n\\\nvec2 computeTextureTransform(vec2 texCoord, mat3 textureTransform)\\n\\\n{\\n\\\n    return vec2(textureTransform * vec3(texCoord, 1.0));\\n\\\n}\\n\\\n\\n\\\n#ifdef HAS_NORMAL_TEXTURE\\n\\\nvec2 getNormalTexCoords()\\n\\\n{\\n\\\n    vec2 texCoord = TEXCOORD_NORMAL;\\n\\\n    #ifdef HAS_NORMAL_TEXTURE_TRANSFORM\\n\\\n        texCoord = vec2(u_normalTextureTransform * vec3(texCoord, 1.0));\\n\\\n    #endif\\n\\\n    return texCoord;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#if defined(HAS_NORMAL_TEXTURE) || defined(HAS_CLEARCOAT_NORMAL_TEXTURE)\\n\\\nvec3 computeTangent(in vec3 position, in vec2 normalTexCoords)\\n\\\n{\\n\\\n    vec2 tex_dx = dFdx(normalTexCoords);\\n\\\n    vec2 tex_dy = dFdy(normalTexCoords);\\n\\\n    float determinant = tex_dx.x * tex_dy.y - tex_dy.x * tex_dx.y;\\n\\\n    vec3 tangent = tex_dy.t * dFdx(position) - tex_dx.t * dFdy(position);\\n\\\n    return tangent / determinant;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#ifdef USE_ANISOTROPY\\n\\\nstruct NormalInfo {\\n\\\n    vec3 tangent;\\n\\\n    vec3 bitangent;\\n\\\n    vec3 normal;\\n\\\n    vec3 geometryNormal;\\n\\\n};\\n\\\n\\n\\\nNormalInfo getNormalInfo(ProcessedAttributes attributes)\\n\\\n{\\n\\\n    vec3 geometryNormal = attributes.normalEC;\\n\\\n    #ifdef HAS_NORMAL_TEXTURE\\n\\\n        vec2 normalTexCoords = getNormalTexCoords();\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_BITANGENTS\\n\\\n        vec3 tangent = attributes.tangentEC;\\n\\\n        vec3 bitangent = attributes.bitangentEC;\\n\\\n    #else // Assume HAS_NORMAL_TEXTURE\\n\\\n        vec3 tangent = computeTangent(attributes.positionEC, normalTexCoords);\\n\\\n        tangent = normalize(tangent - geometryNormal * dot(geometryNormal, tangent));\\n\\\n        vec3 bitangent = normalize(cross(geometryNormal, tangent));\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_NORMAL_TEXTURE\\n\\\n        mat3 tbn = mat3(tangent, bitangent, geometryNormal);\\n\\\n        vec3 normalSample = texture(u_normalTexture, normalTexCoords).rgb;\\n\\\n        normalSample = 2.0 * normalSample - 1.0;\\n\\\n        #ifdef HAS_NORMAL_TEXTURE_SCALE\\n\\\n            normalSample.xy *= u_normalTextureScale;\\n\\\n        #endif\\n\\\n        vec3 normal = normalize(tbn * normalSample);\\n\\\n    #else\\n\\\n        vec3 normal = geometryNormal;\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_DOUBLE_SIDED_MATERIAL\\n\\\n        if (czm_backFacing()) {\\n\\\n            tangent *= -1.0;\\n\\\n            bitangent *= -1.0;\\n\\\n            normal *= -1.0;\\n\\\n            geometryNormal *= -1.0;\\n\\\n        }\\n\\\n    #endif\\n\\\n\\n\\\n    NormalInfo normalInfo;\\n\\\n    normalInfo.tangent = tangent;\\n\\\n    normalInfo.bitangent = bitangent;\\n\\\n    normalInfo.normal = normal;\\n\\\n    normalInfo.geometryNormal = geometryNormal;\\n\\\n\\n\\\n    return normalInfo;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#if defined(HAS_NORMAL_TEXTURE) && !defined(HAS_WIREFRAME)\\n\\\nvec3 getNormalFromTexture(ProcessedAttributes attributes, vec3 geometryNormal)\\n\\\n{\\n\\\n    vec2 normalTexCoords = getNormalTexCoords();\\n\\\n\\n\\\n    // If HAS_BITANGENTS is set, then HAS_TANGENTS is also set\\n\\\n    #ifdef HAS_BITANGENTS\\n\\\n        vec3 t = attributes.tangentEC;\\n\\\n        vec3 b = attributes.bitangentEC;\\n\\\n    #else\\n\\\n        vec3 t = computeTangent(attributes.positionEC, normalTexCoords);\\n\\\n        t = normalize(t - geometryNormal * dot(geometryNormal, t));\\n\\\n        vec3 b = normalize(cross(geometryNormal, t));\\n\\\n    #endif\\n\\\n\\n\\\n    mat3 tbn = mat3(t, b, geometryNormal);\\n\\\n    vec3 normalSample = texture(u_normalTexture, normalTexCoords).rgb;\\n\\\n    normalSample = 2.0 * normalSample - 1.0;\\n\\\n    #ifdef HAS_NORMAL_TEXTURE_SCALE\\n\\\n        normalSample.xy *= u_normalTextureScale;\\n\\\n    #endif\\n\\\n    return normalize(tbn * normalSample);\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#ifdef HAS_CLEARCOAT_NORMAL_TEXTURE\\n\\\nvec3 getClearcoatNormalFromTexture(ProcessedAttributes attributes, vec3 geometryNormal)\\n\\\n{\\n\\\n    vec2 normalTexCoords = TEXCOORD_CLEARCOAT_NORMAL;\\n\\\n    #ifdef HAS_CLEARCOAT_NORMAL_TEXTURE_TRANSFORM\\n\\\n        normalTexCoords = vec2(u_clearcoatNormalTextureTransform * vec3(normalTexCoords, 1.0));\\n\\\n    #endif\\n\\\n\\n\\\n    // If HAS_BITANGENTS is set, then HAS_TANGENTS is also set\\n\\\n    #ifdef HAS_BITANGENTS\\n\\\n        vec3 t = attributes.tangentEC;\\n\\\n        vec3 b = attributes.bitangentEC;\\n\\\n    #else\\n\\\n        vec3 t = computeTangent(attributes.positionEC, normalTexCoords);\\n\\\n        t = normalize(t - geometryNormal * dot(geometryNormal, t));\\n\\\n        vec3 b = normalize(cross(geometryNormal, t));\\n\\\n    #endif\\n\\\n\\n\\\n    mat3 tbn = mat3(t, b, geometryNormal);\\n\\\n    vec3 normalSample = texture(u_clearcoatNormalTexture, normalTexCoords).rgb;\\n\\\n    normalSample = 2.0 * normalSample - 1.0;\\n\\\n    #ifdef HAS_CLEARCOAT_NORMAL_TEXTURE_SCALE\\n\\\n        normalSample.xy *= u_clearcoatNormalTextureScale;\\n\\\n    #endif\\n\\\n    return normalize(tbn * normalSample);\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#ifdef HAS_NORMALS\\n\\\nvec3 computeNormal(ProcessedAttributes attributes)\\n\\\n{\\n\\\n    // Geometry normal. This is already normalized \\n\\\n    vec3 normal = attributes.normalEC;\\n\\\n\\n\\\n    #if defined(HAS_NORMAL_TEXTURE) && !defined(HAS_WIREFRAME)\\n\\\n        normal = getNormalFromTexture(attributes, normal);\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_DOUBLE_SIDED_MATERIAL\\n\\\n        if (czm_backFacing()) {\\n\\\n            normal = -normal;\\n\\\n        }\\n\\\n    #endif\\n\\\n\\n\\\n    return normal;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#ifdef HAS_BASE_COLOR_TEXTURE\\n\\\nvec4 getBaseColorFromTexture()\\n\\\n{\\n\\\n    vec2 baseColorTexCoords = TEXCOORD_BASE_COLOR;\\n\\\n    #ifdef HAS_BASE_COLOR_TEXTURE_TRANSFORM\\n\\\n        baseColorTexCoords = computeTextureTransform(baseColorTexCoords, u_baseColorTextureTransform);\\n\\\n    #endif\\n\\\n\\n\\\n    vec4 baseColorWithAlpha = czm_srgbToLinear(texture(u_baseColorTexture, baseColorTexCoords));\\n\\\n\\n\\\n    #ifdef HAS_BASE_COLOR_FACTOR\\n\\\n        baseColorWithAlpha *= u_baseColorFactor;\\n\\\n    #endif\\n\\\n\\n\\\n    return baseColorWithAlpha;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#ifdef HAS_EMISSIVE_TEXTURE\\n\\\nvec3 getEmissiveFromTexture()\\n\\\n{\\n\\\n    vec2 emissiveTexCoords = TEXCOORD_EMISSIVE;\\n\\\n    #ifdef HAS_EMISSIVE_TEXTURE_TRANSFORM\\n\\\n        emissiveTexCoords = computeTextureTransform(emissiveTexCoords, u_emissiveTextureTransform);\\n\\\n    #endif\\n\\\n\\n\\\n    vec3 emissive = czm_srgbToLinear(texture(u_emissiveTexture, emissiveTexCoords).rgb);\\n\\\n    #ifdef HAS_EMISSIVE_FACTOR\\n\\\n        emissive *= u_emissiveFactor;\\n\\\n    #endif\\n\\\n\\n\\\n    return emissive;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#if defined(LIGHTING_PBR) && defined(USE_SPECULAR_GLOSSINESS)\\n\\\nvoid setSpecularGlossiness(inout czm_modelMaterial material)\\n\\\n{\\n\\\n    #ifdef HAS_SPECULAR_GLOSSINESS_TEXTURE\\n\\\n        vec2 specularGlossinessTexCoords = TEXCOORD_SPECULAR_GLOSSINESS;\\n\\\n        #ifdef HAS_SPECULAR_GLOSSINESS_TEXTURE_TRANSFORM\\n\\\n            specularGlossinessTexCoords = computeTextureTransform(specularGlossinessTexCoords, u_specularGlossinessTextureTransform);\\n\\\n        #endif\\n\\\n\\n\\\n        vec4 specularGlossiness = czm_srgbToLinear(texture(u_specularGlossinessTexture, specularGlossinessTexCoords));\\n\\\n        vec3 specular = specularGlossiness.rgb;\\n\\\n        float glossiness = specularGlossiness.a;\\n\\\n        #ifdef HAS_LEGACY_SPECULAR_FACTOR\\n\\\n            specular *= u_legacySpecularFactor;\\n\\\n        #endif\\n\\\n\\n\\\n        #ifdef HAS_GLOSSINESS_FACTOR\\n\\\n            glossiness *= u_glossinessFactor;\\n\\\n        #endif\\n\\\n    #else\\n\\\n        #ifdef HAS_LEGACY_SPECULAR_FACTOR\\n\\\n            vec3 specular = clamp(u_legacySpecularFactor, vec3(0.0), vec3(1.0));\\n\\\n        #else\\n\\\n            vec3 specular = vec3(1.0);\\n\\\n        #endif\\n\\\n\\n\\\n        #ifdef HAS_GLOSSINESS_FACTOR\\n\\\n            float glossiness = clamp(u_glossinessFactor, 0.0, 1.0);\\n\\\n        #else\\n\\\n            float glossiness = 1.0;\\n\\\n        #endif\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_DIFFUSE_TEXTURE\\n\\\n        vec2 diffuseTexCoords = TEXCOORD_DIFFUSE;\\n\\\n        #ifdef HAS_DIFFUSE_TEXTURE_TRANSFORM\\n\\\n            diffuseTexCoords = computeTextureTransform(diffuseTexCoords, u_diffuseTextureTransform);\\n\\\n        #endif\\n\\\n\\n\\\n        vec4 diffuse = czm_srgbToLinear(texture(u_diffuseTexture, diffuseTexCoords));\\n\\\n        #ifdef HAS_DIFFUSE_FACTOR\\n\\\n            diffuse *= u_diffuseFactor;\\n\\\n        #endif\\n\\\n    #elif defined(HAS_DIFFUSE_FACTOR)\\n\\\n        vec4 diffuse = clamp(u_diffuseFactor, vec4(0.0), vec4(1.0));\\n\\\n    #else\\n\\\n        vec4 diffuse = vec4(1.0);\\n\\\n    #endif\\n\\\n\\n\\\n    material.diffuse = diffuse.rgb * (1.0 - czm_maximumComponent(specular));\\n\\\n    // the specular glossiness extension's alpha overrides anything set\\n\\\n    // by the base material.\\n\\\n    material.alpha = diffuse.a;\\n\\\n\\n\\\n    material.specular = specular;\\n\\\n\\n\\\n    // glossiness is the opposite of roughness, but easier for artists to use.\\n\\\n    material.roughness = 1.0 - glossiness;\\n\\\n}\\n\\\n#elif defined(LIGHTING_PBR)\\n\\\nfloat setMetallicRoughness(inout czm_modelMaterial material)\\n\\\n{\\n\\\n    #ifdef HAS_METALLIC_ROUGHNESS_TEXTURE\\n\\\n        vec2 metallicRoughnessTexCoords = TEXCOORD_METALLIC_ROUGHNESS;\\n\\\n        #ifdef HAS_METALLIC_ROUGHNESS_TEXTURE_TRANSFORM\\n\\\n            metallicRoughnessTexCoords = computeTextureTransform(metallicRoughnessTexCoords, u_metallicRoughnessTextureTransform);\\n\\\n        #endif\\n\\\n\\n\\\n        vec3 metallicRoughness = texture(u_metallicRoughnessTexture, metallicRoughnessTexCoords).rgb;\\n\\\n        float metalness = clamp(metallicRoughness.b, 0.0, 1.0);\\n\\\n        float roughness = clamp(metallicRoughness.g, 0.0, 1.0);\\n\\\n        #ifdef HAS_METALLIC_FACTOR\\n\\\n            metalness = clamp(metalness * u_metallicFactor, 0.0, 1.0);\\n\\\n        #endif\\n\\\n\\n\\\n        #ifdef HAS_ROUGHNESS_FACTOR\\n\\\n            roughness = clamp(roughness * u_roughnessFactor, 0.0, 1.0);\\n\\\n        #endif\\n\\\n    #else\\n\\\n        #ifdef HAS_METALLIC_FACTOR\\n\\\n            float metalness = clamp(u_metallicFactor, 0.0, 1.0);\\n\\\n        #else\\n\\\n            float metalness = 1.0;\\n\\\n        #endif\\n\\\n\\n\\\n        #ifdef HAS_ROUGHNESS_FACTOR\\n\\\n            float roughness = clamp(u_roughnessFactor, 0.0, 1.0);\\n\\\n        #else\\n\\\n            float roughness = 1.0;\\n\\\n        #endif\\n\\\n    #endif\\n\\\n\\n\\\n    // dielectrics use f0 = 0.04, metals use albedo as f0\\n\\\n    const vec3 REFLECTANCE_DIELECTRIC = vec3(0.04);\\n\\\n    vec3 f0 = mix(REFLECTANCE_DIELECTRIC, material.baseColor.rgb, metalness);\\n\\\n\\n\\\n    material.specular = f0;\\n\\\n\\n\\\n    // diffuse only applies to dielectrics.\\n\\\n    material.diffuse = mix(material.baseColor.rgb, vec3(0.0), metalness);\\n\\\n\\n\\\n    // This is perceptual roughness. The square of this value is used for direct lighting\\n\\\n    material.roughness = roughness;\\n\\\n\\n\\\n    return metalness;\\n\\\n}\\n\\\n#ifdef USE_SPECULAR\\n\\\nvoid setSpecular(inout czm_modelMaterial material, in float metalness)\\n\\\n{\\n\\\n    #ifdef HAS_SPECULAR_TEXTURE\\n\\\n        vec2 specularTexCoords = TEXCOORD_SPECULAR;\\n\\\n        #ifdef HAS_SPECULAR_TEXTURE_TRANSFORM\\n\\\n            specularTexCoords = computeTextureTransform(specularTexCoords, u_specularTextureTransform);\\n\\\n        #endif\\n\\\n        float specularWeight = texture(u_specularTexture, specularTexCoords).a;\\n\\\n        #ifdef HAS_SPECULAR_FACTOR\\n\\\n            specularWeight *= u_specularFactor;\\n\\\n        #endif\\n\\\n    #else\\n\\\n        #ifdef HAS_SPECULAR_FACTOR\\n\\\n            float specularWeight = u_specularFactor;\\n\\\n        #else\\n\\\n            float specularWeight = 1.0;\\n\\\n        #endif\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_SPECULAR_COLOR_TEXTURE\\n\\\n        vec2 specularColorTexCoords = TEXCOORD_SPECULAR_COLOR;\\n\\\n        #ifdef HAS_SPECULAR_COLOR_TEXTURE_TRANSFORM\\n\\\n            specularColorTexCoords = computeTextureTransform(specularColorTexCoords, u_specularColorTextureTransform);\\n\\\n        #endif\\n\\\n        vec3 specularColorSample = texture(u_specularColorTexture, specularColorTexCoords).rgb;\\n\\\n        vec3 specularColorFactor = czm_srgbToLinear(specularColorSample);\\n\\\n        #ifdef HAS_SPECULAR_COLOR_FACTOR\\n\\\n            specularColorFactor *= u_specularColorFactor;\\n\\\n        #endif\\n\\\n    #else\\n\\\n        #ifdef HAS_SPECULAR_COLOR_FACTOR\\n\\\n            vec3 specularColorFactor = u_specularColorFactor;\\n\\\n        #else\\n\\\n            vec3 specularColorFactor = vec3(1.0);\\n\\\n        #endif\\n\\\n    #endif\\n\\\n    material.specularWeight = specularWeight;\\n\\\n    vec3 f0 = material.specular;\\n\\\n    vec3 dielectricSpecularF0 = min(f0 * specularColorFactor, vec3(1.0));\\n\\\n    material.specular = mix(dielectricSpecularF0, material.baseColor.rgb, metalness);\\n\\\n}\\n\\\n#endif\\n\\\n#ifdef USE_ANISOTROPY\\n\\\nvoid setAnisotropy(inout czm_modelMaterial material, in NormalInfo normalInfo)\\n\\\n{\\n\\\n    mat2 rotation = mat2(u_anisotropy.xy, -u_anisotropy.y, u_anisotropy.x);\\n\\\n    float anisotropyStrength = u_anisotropy.z;\\n\\\n\\n\\\n    vec2 direction = vec2(1.0, 0.0);\\n\\\n    #ifdef HAS_ANISOTROPY_TEXTURE\\n\\\n        vec2 anisotropyTexCoords = TEXCOORD_ANISOTROPY;\\n\\\n        #ifdef HAS_ANISOTROPY_TEXTURE_TRANSFORM\\n\\\n            anisotropyTexCoords = computeTextureTransform(anisotropyTexCoords, u_anisotropyTextureTransform);\\n\\\n        #endif\\n\\\n        vec3 anisotropySample = texture(u_anisotropyTexture, anisotropyTexCoords).rgb;\\n\\\n        direction = anisotropySample.rg * 2.0 - vec2(1.0);\\n\\\n        anisotropyStrength *= anisotropySample.b;\\n\\\n    #endif\\n\\\n\\n\\\n    direction = rotation * direction;\\n\\\n    mat3 tbn = mat3(normalInfo.tangent, normalInfo.bitangent, normalInfo.normal);\\n\\\n    vec3 anisotropicT = tbn * normalize(vec3(direction, 0.0));\\n\\\n    vec3 anisotropicB = cross(normalInfo.geometryNormal, anisotropicT);\\n\\\n\\n\\\n    material.anisotropicT = anisotropicT;\\n\\\n    material.anisotropicB = anisotropicB;\\n\\\n    material.anisotropyStrength = anisotropyStrength;\\n\\\n}\\n\\\n#endif\\n\\\n#ifdef USE_CLEARCOAT\\n\\\nvoid setClearcoat(inout czm_modelMaterial material, in ProcessedAttributes attributes)\\n\\\n{\\n\\\n    #ifdef HAS_CLEARCOAT_TEXTURE\\n\\\n        vec2 clearcoatTexCoords = TEXCOORD_CLEARCOAT;\\n\\\n        #ifdef HAS_CLEARCOAT_TEXTURE_TRANSFORM\\n\\\n            clearcoatTexCoords = computeTextureTransform(clearcoatTexCoords, u_clearcoatTextureTransform);\\n\\\n        #endif\\n\\\n        float clearcoatFactor = texture(u_clearcoatTexture, clearcoatTexCoords).r;\\n\\\n        #ifdef HAS_CLEARCOAT_FACTOR\\n\\\n            clearcoatFactor *= u_clearcoatFactor;\\n\\\n        #endif\\n\\\n    #else\\n\\\n        #ifdef HAS_CLEARCOAT_FACTOR\\n\\\n            float clearcoatFactor = u_clearcoatFactor;\\n\\\n        #else\\n\\\n            // PERFORMANCE_IDEA: this case should turn the whole extension off\\n\\\n            float clearcoatFactor = 0.0;\\n\\\n        #endif\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_CLEARCOAT_ROUGHNESS_TEXTURE\\n\\\n        vec2 clearcoatRoughnessTexCoords = TEXCOORD_CLEARCOAT_ROUGHNESS;\\n\\\n        #ifdef HAS_CLEARCOAT_ROUGHNESS_TEXTURE_TRANSFORM\\n\\\n            clearcoatRoughnessTexCoords = computeTextureTransform(clearcoatRoughnessTexCoords, u_clearcoatRoughnessTextureTransform);\\n\\\n        #endif\\n\\\n        float clearcoatRoughness = texture(u_clearcoatRoughnessTexture, clearcoatRoughnessTexCoords).g;\\n\\\n        #ifdef HAS_CLEARCOAT_ROUGHNESS_FACTOR\\n\\\n            clearcoatRoughness *= u_clearcoatRoughnessFactor;\\n\\\n        #endif\\n\\\n    #else\\n\\\n        #ifdef HAS_CLEARCOAT_ROUGHNESS_FACTOR\\n\\\n            float clearcoatRoughness = u_clearcoatRoughnessFactor;\\n\\\n        #else\\n\\\n            float clearcoatRoughness = 0.0;\\n\\\n        #endif\\n\\\n    #endif\\n\\\n\\n\\\n    material.clearcoatFactor = clearcoatFactor;\\n\\\n    // This is perceptual roughness. The square of this value is used for direct lighting\\n\\\n    material.clearcoatRoughness = clearcoatRoughness;\\n\\\n    #ifdef HAS_CLEARCOAT_NORMAL_TEXTURE\\n\\\n        material.clearcoatNormal = getClearcoatNormalFromTexture(attributes, attributes.normalEC);\\n\\\n    #else\\n\\\n        material.clearcoatNormal = attributes.normalEC;\\n\\\n    #endif\\n\\\n}\\n\\\n#endif\\n\\\n#endif\\n\\\n\\n\\\nvoid materialStage(inout czm_modelMaterial material, ProcessedAttributes attributes, SelectedFeature feature)\\n\\\n{\\n\\\n    #ifdef USE_ANISOTROPY\\n\\\n        NormalInfo normalInfo = getNormalInfo(attributes);\\n\\\n        material.normalEC = normalInfo.normal;\\n\\\n    #elif defined(HAS_NORMALS)\\n\\\n        material.normalEC = computeNormal(attributes);\\n\\\n    #endif\\n\\\n\\n\\\n    vec4 baseColorWithAlpha = vec4(1.0);\\n\\\n    // Regardless of whether we use PBR, set a base color\\n\\\n    #ifdef HAS_BASE_COLOR_TEXTURE\\n\\\n        baseColorWithAlpha = getBaseColorFromTexture();\\n\\\n    #elif defined(HAS_BASE_COLOR_FACTOR)\\n\\\n        baseColorWithAlpha = u_baseColorFactor;\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_IMAGERY\\n\\\n    baseColorWithAlpha = blendBaseColorWithImagery(baseColorWithAlpha);\\n\\\n    #endif // HAS_IMAGERY\\n\\\n\\n\\\n    #ifdef HAS_POINT_CLOUD_COLOR_STYLE\\n\\\n        baseColorWithAlpha = v_pointCloudColor;\\n\\\n    #elif defined(HAS_COLOR_0)\\n\\\n        vec4 color = attributes.color_0;\\n\\\n        // .pnts files store colors in the sRGB color space\\n\\\n        #ifdef HAS_SRGB_COLOR\\n\\\n            color = czm_srgbToLinear(color);\\n\\\n        #endif\\n\\\n        baseColorWithAlpha *= color;\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef USE_CPU_STYLING\\n\\\n        baseColorWithAlpha.rgb = blend(baseColorWithAlpha.rgb, feature.color.rgb, model_colorBlend);\\n\\\n    #endif\\n\\\n    material.baseColor = baseColorWithAlpha;\\n\\\n    material.diffuse = baseColorWithAlpha.rgb;\\n\\\n    material.alpha = baseColorWithAlpha.a;\\n\\\n\\n\\\n    #ifdef HAS_OCCLUSION_TEXTURE\\n\\\n        vec2 occlusionTexCoords = TEXCOORD_OCCLUSION;\\n\\\n        #ifdef HAS_OCCLUSION_TEXTURE_TRANSFORM\\n\\\n            occlusionTexCoords = computeTextureTransform(occlusionTexCoords, u_occlusionTextureTransform);\\n\\\n        #endif\\n\\\n        material.occlusion = texture(u_occlusionTexture, occlusionTexCoords).r;\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_EMISSIVE_TEXTURE\\n\\\n        material.emissive = getEmissiveFromTexture();\\n\\\n    #elif defined(HAS_EMISSIVE_FACTOR)\\n\\\n        material.emissive = u_emissiveFactor;\\n\\\n    #endif\\n\\\n\\n\\\n    #if defined(LIGHTING_PBR) && defined(USE_SPECULAR_GLOSSINESS)\\n\\\n        setSpecularGlossiness(material);\\n\\\n    #elif defined(LIGHTING_PBR)\\n\\\n        float metalness = setMetallicRoughness(material);\\n\\\n        #ifdef USE_SPECULAR\\n\\\n            setSpecular(material, metalness);\\n\\\n        #endif\\n\\\n        #ifdef USE_ANISOTROPY\\n\\\n            setAnisotropy(material, normalInfo);\\n\\\n        #endif\\n\\\n        #ifdef USE_CLEARCOAT\\n\\\n            setClearcoat(material, attributes);\\n\\\n        #endif\\n\\\n    #endif\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}