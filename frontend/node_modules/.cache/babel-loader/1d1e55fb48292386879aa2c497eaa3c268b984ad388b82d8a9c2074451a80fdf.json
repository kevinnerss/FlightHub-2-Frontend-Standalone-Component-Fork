{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\n\n/**\n * An enum describing the built-in vertex attribute semantics.\n *\n * @enum {string}\n *\n * @private\n */\nconst VertexAttributeSemantic = {\n  /**\n   * Per-vertex position.\n   *\n   * @type {string}\n   * @constant\n   */\n  POSITION: \"POSITION\",\n  /**\n   * Per-vertex normal.\n   *\n   * @type {string}\n   * @constant\n   */\n  NORMAL: \"NORMAL\",\n  /**\n   * Per-vertex tangent.\n   *\n   * @type {string}\n   * @constant\n   */\n  TANGENT: \"TANGENT\",\n  /**\n   * Per-vertex texture coordinates.\n   *\n   * @type {string}\n   * @constant\n   */\n  TEXCOORD: \"TEXCOORD\",\n  /**\n   * Per-vertex color.\n   *\n   * @type {string}\n   * @constant\n   */\n  COLOR: \"COLOR\",\n  /**\n   * Per-vertex joint IDs for skinning.\n   *\n   * @type {string}\n   * @constant\n   */\n  JOINTS: \"JOINTS\",\n  /**\n   * Per-vertex joint weights for skinning.\n   *\n   * @type {string}\n   * @constant\n   */\n  WEIGHTS: \"WEIGHTS\",\n  /**\n   * Per-vertex feature ID.\n   *\n   * @type {string}\n   * @constant\n   */\n  FEATURE_ID: \"_FEATURE_ID\",\n  /**\n   * Gaussian Splat Scale\n   *\n   * @type {string}\n   * @constant\n   */\n  SCALE: \"KHR_gaussian_splatting:SCALE\",\n  /**\n   * Gaussian Splat Rotation\n   *\n   * @type {string}\n   * @constant\n   */\n  ROTATION: \"KHR_gaussian_splatting:ROTATION\"\n};\nfunction semanticToVariableName(semantic) {\n  switch (semantic) {\n    case VertexAttributeSemantic.POSITION:\n      return \"positionMC\";\n    case VertexAttributeSemantic.NORMAL:\n      return \"normalMC\";\n    case VertexAttributeSemantic.TANGENT:\n      return \"tangentMC\";\n    case VertexAttributeSemantic.TEXCOORD:\n      return \"texCoord\";\n    case VertexAttributeSemantic.COLOR:\n      return \"color\";\n    case VertexAttributeSemantic.JOINTS:\n      return \"joints\";\n    case VertexAttributeSemantic.WEIGHTS:\n      return \"weights\";\n    case VertexAttributeSemantic.FEATURE_ID:\n      return \"featureId\";\n    case VertexAttributeSemantic.SCALE:\n      return \"scale\";\n    case VertexAttributeSemantic.ROTATION:\n      return \"rotation\";\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"semantic is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n}\n\n/**\n * Returns whether the vertex attribute semantic can have a set index.\n *\n * @param {VertexAttributeSemantic} semantic The semantic.\n *\n * @returns {boolean} Whether the semantic can have a set index.\n *\n * @private\n */\nVertexAttributeSemantic.hasSetIndex = function (semantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  switch (semantic) {\n    case VertexAttributeSemantic.POSITION:\n    case VertexAttributeSemantic.NORMAL:\n    case VertexAttributeSemantic.TANGENT:\n      return false;\n    case VertexAttributeSemantic.TEXCOORD:\n    case VertexAttributeSemantic.COLOR:\n    case VertexAttributeSemantic.JOINTS:\n    case VertexAttributeSemantic.WEIGHTS:\n    case VertexAttributeSemantic.FEATURE_ID:\n    case VertexAttributeSemantic.SCALE:\n    case VertexAttributeSemantic.ROTATION:\n      return true;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"semantic is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Gets the vertex attribute semantic matching the glTF semantic.\n *\n * @param {string} gltfSemantic The glTF semantic.\n *\n * @returns {VertexAttributeSemantic|undefined} The vertex attribute semantic, or undefined if there is no match.\n *\n * @private\n */\nVertexAttributeSemantic.fromGltfSemantic = function (gltfSemantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"gltfSemantic\", gltfSemantic);\n  //>>includeEnd('debug');\n\n  let semantic = gltfSemantic;\n\n  // Strip the set index from the semantic\n  const setIndexRegex = /^(\\w+)_\\d+$/;\n  const setIndexMatch = setIndexRegex.exec(gltfSemantic);\n  if (setIndexMatch !== null) {\n    semantic = setIndexMatch[1];\n  }\n  switch (semantic) {\n    case \"POSITION\":\n      return VertexAttributeSemantic.POSITION;\n    case \"NORMAL\":\n      return VertexAttributeSemantic.NORMAL;\n    case \"TANGENT\":\n      return VertexAttributeSemantic.TANGENT;\n    case \"TEXCOORD\":\n      return VertexAttributeSemantic.TEXCOORD;\n    case \"COLOR\":\n      return VertexAttributeSemantic.COLOR;\n    case \"JOINTS\":\n      return VertexAttributeSemantic.JOINTS;\n    case \"WEIGHTS\":\n      return VertexAttributeSemantic.WEIGHTS;\n    case \"_FEATURE_ID\":\n      return VertexAttributeSemantic.FEATURE_ID;\n    case \"KHR_gaussian_splatting:SCALE\":\n    case \"_SCALE\":\n      return VertexAttributeSemantic.SCALE;\n    case \"KHR_gaussian_splatting:ROTATION\":\n    case \"_ROTATION\":\n      return VertexAttributeSemantic.ROTATION;\n  }\n  return undefined;\n};\n\n/**\n * Gets the vertex attribute semantic matching the pnts semantic.\n *\n * @param {string} pntsSemantic The pnts semantic.\n *\n * @returns {VertexAttributeSemantic|undefined} The vertex attribute semantic, or undefined if there is no match.\n *\n * @private\n */\nVertexAttributeSemantic.fromPntsSemantic = function (pntsSemantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"pntsSemantic\", pntsSemantic);\n  //>>includeEnd('debug');\n\n  switch (pntsSemantic) {\n    case \"POSITION\":\n    case \"POSITION_QUANTIZED\":\n      return VertexAttributeSemantic.POSITION;\n    case \"RGBA\":\n    case \"RGB\":\n    case \"RGB565\":\n      return VertexAttributeSemantic.COLOR;\n    case \"NORMAL\":\n    case \"NORMAL_OCT16P\":\n      return VertexAttributeSemantic.NORMAL;\n    case \"BATCH_ID\":\n      return VertexAttributeSemantic.FEATURE_ID;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"pntsSemantic is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Gets the GLSL type (such as <code>vec3</code> or <code>int</code>) for the\n * given vertex attribute.\n *\n * @param {VertexAttributeSemantic} semantic The semantic.\n *\n * @returns {string} The shader type.\n *\n * @private\n */\nVertexAttributeSemantic.getGlslType = function (semantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  switch (semantic) {\n    case VertexAttributeSemantic.POSITION:\n    case VertexAttributeSemantic.NORMAL:\n    case VertexAttributeSemantic.TANGENT:\n      return \"vec3\";\n    case VertexAttributeSemantic.TEXCOORD:\n      return \"vec2\";\n    case VertexAttributeSemantic.COLOR:\n      return \"vec4\";\n    case VertexAttributeSemantic.JOINTS:\n      return \"ivec4\";\n    case VertexAttributeSemantic.WEIGHTS:\n      return \"vec4\";\n    case VertexAttributeSemantic.FEATURE_ID:\n      return \"int\";\n    case VertexAttributeSemantic.SCALE:\n      return \"vec3\";\n    case VertexAttributeSemantic.ROTATION:\n      return \"vec4\";\n    case VertexAttributeSemantic.OPACITY:\n      return \"float\";\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"semantic is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Gets the variable name for the given semantic and set index.\n *\n * @param {VertexAttributeSemantic} semantic The semantic.\n * @param {number} [setIndex] The set index.\n *\n * @returns {string} The variable name.\n *\n * @private\n */\nVertexAttributeSemantic.getVariableName = function (semantic, setIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  let variableName = semanticToVariableName(semantic);\n  if (defined(setIndex)) {\n    variableName += `_${setIndex}`;\n  }\n  return variableName;\n};\nexport default Object.freeze(VertexAttributeSemantic);","map":{"version":3,"names":["Check","defined","DeveloperError","VertexAttributeSemantic","POSITION","NORMAL","TANGENT","TEXCOORD","COLOR","JOINTS","WEIGHTS","FEATURE_ID","SCALE","ROTATION","semanticToVariableName","semantic","hasSetIndex","typeOf","string","fromGltfSemantic","gltfSemantic","setIndexRegex","setIndexMatch","exec","undefined","fromPntsSemantic","pntsSemantic","getGlslType","OPACITY","getVariableName","setIndex","variableName","Object","freeze"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/VertexAttributeSemantic.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\n\n/**\n * An enum describing the built-in vertex attribute semantics.\n *\n * @enum {string}\n *\n * @private\n */\nconst VertexAttributeSemantic = {\n  /**\n   * Per-vertex position.\n   *\n   * @type {string}\n   * @constant\n   */\n  POSITION: \"POSITION\",\n\n  /**\n   * Per-vertex normal.\n   *\n   * @type {string}\n   * @constant\n   */\n  NORMAL: \"NORMAL\",\n\n  /**\n   * Per-vertex tangent.\n   *\n   * @type {string}\n   * @constant\n   */\n  TANGENT: \"TANGENT\",\n\n  /**\n   * Per-vertex texture coordinates.\n   *\n   * @type {string}\n   * @constant\n   */\n  TEXCOORD: \"TEXCOORD\",\n\n  /**\n   * Per-vertex color.\n   *\n   * @type {string}\n   * @constant\n   */\n  COLOR: \"COLOR\",\n\n  /**\n   * Per-vertex joint IDs for skinning.\n   *\n   * @type {string}\n   * @constant\n   */\n  JOINTS: \"JOINTS\",\n\n  /**\n   * Per-vertex joint weights for skinning.\n   *\n   * @type {string}\n   * @constant\n   */\n  WEIGHTS: \"WEIGHTS\",\n\n  /**\n   * Per-vertex feature ID.\n   *\n   * @type {string}\n   * @constant\n   */\n  FEATURE_ID: \"_FEATURE_ID\",\n  /**\n   * Gaussian Splat Scale\n   *\n   * @type {string}\n   * @constant\n   */\n  SCALE: \"KHR_gaussian_splatting:SCALE\",\n  /**\n   * Gaussian Splat Rotation\n   *\n   * @type {string}\n   * @constant\n   */\n  ROTATION: \"KHR_gaussian_splatting:ROTATION\",\n};\n\nfunction semanticToVariableName(semantic) {\n  switch (semantic) {\n    case VertexAttributeSemantic.POSITION:\n      return \"positionMC\";\n    case VertexAttributeSemantic.NORMAL:\n      return \"normalMC\";\n    case VertexAttributeSemantic.TANGENT:\n      return \"tangentMC\";\n    case VertexAttributeSemantic.TEXCOORD:\n      return \"texCoord\";\n    case VertexAttributeSemantic.COLOR:\n      return \"color\";\n    case VertexAttributeSemantic.JOINTS:\n      return \"joints\";\n    case VertexAttributeSemantic.WEIGHTS:\n      return \"weights\";\n    case VertexAttributeSemantic.FEATURE_ID:\n      return \"featureId\";\n    case VertexAttributeSemantic.SCALE:\n      return \"scale\";\n    case VertexAttributeSemantic.ROTATION:\n      return \"rotation\";\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"semantic is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n}\n\n/**\n * Returns whether the vertex attribute semantic can have a set index.\n *\n * @param {VertexAttributeSemantic} semantic The semantic.\n *\n * @returns {boolean} Whether the semantic can have a set index.\n *\n * @private\n */\nVertexAttributeSemantic.hasSetIndex = function (semantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  switch (semantic) {\n    case VertexAttributeSemantic.POSITION:\n    case VertexAttributeSemantic.NORMAL:\n    case VertexAttributeSemantic.TANGENT:\n      return false;\n    case VertexAttributeSemantic.TEXCOORD:\n    case VertexAttributeSemantic.COLOR:\n    case VertexAttributeSemantic.JOINTS:\n    case VertexAttributeSemantic.WEIGHTS:\n    case VertexAttributeSemantic.FEATURE_ID:\n    case VertexAttributeSemantic.SCALE:\n    case VertexAttributeSemantic.ROTATION:\n      return true;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"semantic is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Gets the vertex attribute semantic matching the glTF semantic.\n *\n * @param {string} gltfSemantic The glTF semantic.\n *\n * @returns {VertexAttributeSemantic|undefined} The vertex attribute semantic, or undefined if there is no match.\n *\n * @private\n */\nVertexAttributeSemantic.fromGltfSemantic = function (gltfSemantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"gltfSemantic\", gltfSemantic);\n  //>>includeEnd('debug');\n\n  let semantic = gltfSemantic;\n\n  // Strip the set index from the semantic\n  const setIndexRegex = /^(\\w+)_\\d+$/;\n  const setIndexMatch = setIndexRegex.exec(gltfSemantic);\n  if (setIndexMatch !== null) {\n    semantic = setIndexMatch[1];\n  }\n\n  switch (semantic) {\n    case \"POSITION\":\n      return VertexAttributeSemantic.POSITION;\n    case \"NORMAL\":\n      return VertexAttributeSemantic.NORMAL;\n    case \"TANGENT\":\n      return VertexAttributeSemantic.TANGENT;\n    case \"TEXCOORD\":\n      return VertexAttributeSemantic.TEXCOORD;\n    case \"COLOR\":\n      return VertexAttributeSemantic.COLOR;\n    case \"JOINTS\":\n      return VertexAttributeSemantic.JOINTS;\n    case \"WEIGHTS\":\n      return VertexAttributeSemantic.WEIGHTS;\n    case \"_FEATURE_ID\":\n      return VertexAttributeSemantic.FEATURE_ID;\n    case \"KHR_gaussian_splatting:SCALE\":\n    case \"_SCALE\":\n      return VertexAttributeSemantic.SCALE;\n    case \"KHR_gaussian_splatting:ROTATION\":\n    case \"_ROTATION\":\n      return VertexAttributeSemantic.ROTATION;\n  }\n\n  return undefined;\n};\n\n/**\n * Gets the vertex attribute semantic matching the pnts semantic.\n *\n * @param {string} pntsSemantic The pnts semantic.\n *\n * @returns {VertexAttributeSemantic|undefined} The vertex attribute semantic, or undefined if there is no match.\n *\n * @private\n */\nVertexAttributeSemantic.fromPntsSemantic = function (pntsSemantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"pntsSemantic\", pntsSemantic);\n  //>>includeEnd('debug');\n\n  switch (pntsSemantic) {\n    case \"POSITION\":\n    case \"POSITION_QUANTIZED\":\n      return VertexAttributeSemantic.POSITION;\n    case \"RGBA\":\n    case \"RGB\":\n    case \"RGB565\":\n      return VertexAttributeSemantic.COLOR;\n    case \"NORMAL\":\n    case \"NORMAL_OCT16P\":\n      return VertexAttributeSemantic.NORMAL;\n    case \"BATCH_ID\":\n      return VertexAttributeSemantic.FEATURE_ID;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"pntsSemantic is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Gets the GLSL type (such as <code>vec3</code> or <code>int</code>) for the\n * given vertex attribute.\n *\n * @param {VertexAttributeSemantic} semantic The semantic.\n *\n * @returns {string} The shader type.\n *\n * @private\n */\nVertexAttributeSemantic.getGlslType = function (semantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  switch (semantic) {\n    case VertexAttributeSemantic.POSITION:\n    case VertexAttributeSemantic.NORMAL:\n    case VertexAttributeSemantic.TANGENT:\n      return \"vec3\";\n    case VertexAttributeSemantic.TEXCOORD:\n      return \"vec2\";\n    case VertexAttributeSemantic.COLOR:\n      return \"vec4\";\n    case VertexAttributeSemantic.JOINTS:\n      return \"ivec4\";\n    case VertexAttributeSemantic.WEIGHTS:\n      return \"vec4\";\n    case VertexAttributeSemantic.FEATURE_ID:\n      return \"int\";\n    case VertexAttributeSemantic.SCALE:\n      return \"vec3\";\n    case VertexAttributeSemantic.ROTATION:\n      return \"vec4\";\n    case VertexAttributeSemantic.OPACITY:\n      return \"float\";\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"semantic is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Gets the variable name for the given semantic and set index.\n *\n * @param {VertexAttributeSemantic} semantic The semantic.\n * @param {number} [setIndex] The set index.\n *\n * @returns {string} The variable name.\n *\n * @private\n */\nVertexAttributeSemantic.getVariableName = function (semantic, setIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  let variableName = semanticToVariableName(semantic);\n  if (defined(setIndex)) {\n    variableName += `_${setIndex}`;\n  }\n  return variableName;\n};\n\nexport default Object.freeze(VertexAttributeSemantic);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}