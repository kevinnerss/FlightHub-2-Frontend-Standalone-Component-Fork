{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * Determine whether or not other objects are visible or hidden behind the visible horizon defined by\n * an {@link Ellipsoid} and a camera position.  The ellipsoid is assumed to be located at the\n * origin of the coordinate system.  This class uses the algorithm described in the\n * {@link https://cesium.com/blog/2013/04/25/Horizon-culling/|Horizon Culling} blog post.\n *\n * @alias EllipsoidalOccluder\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to use as an occluder.\n * @param {Cartesian3} [cameraPosition] The coordinate of the viewer/camera.  If this parameter is not\n *        specified, {@link EllipsoidalOccluder#cameraPosition} must be called before\n *        testing visibility.\n *\n * @constructor\n *\n * @example\n * // Construct an ellipsoidal occluder with radii 1.0, 1.1, and 0.9.\n * const cameraPosition = new Cesium.Cartesian3(5.0, 6.0, 7.0);\n * const occluderEllipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * const occluder = new Cesium.EllipsoidalOccluder(occluderEllipsoid, cameraPosition);\n *\n * @private\n */\nfunction EllipsoidalOccluder(ellipsoid, cameraPosition) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  //>>includeEnd('debug');\n\n  this._ellipsoid = ellipsoid;\n  this._cameraPosition = new Cartesian3();\n  this._cameraPositionInScaledSpace = new Cartesian3();\n  this._distanceToLimbInScaledSpaceSquared = 0.0;\n\n  // cameraPosition fills in the above values\n  if (defined(cameraPosition)) {\n    this.cameraPosition = cameraPosition;\n  }\n}\nObject.defineProperties(EllipsoidalOccluder.prototype, {\n  /**\n   * Gets the occluding ellipsoid.\n   * @memberof EllipsoidalOccluder.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    }\n  },\n  /**\n   * Gets or sets the position of the camera.\n   * @memberof EllipsoidalOccluder.prototype\n   * @type {Cartesian3}\n   */\n  cameraPosition: {\n    get: function () {\n      return this._cameraPosition;\n    },\n    set: function (cameraPosition) {\n      // See https://cesium.com/blog/2013/04/25/Horizon-culling/\n      const ellipsoid = this._ellipsoid;\n      const cv = ellipsoid.transformPositionToScaledSpace(cameraPosition, this._cameraPositionInScaledSpace);\n      const vhMagnitudeSquared = Cartesian3.magnitudeSquared(cv) - 1.0;\n      Cartesian3.clone(cameraPosition, this._cameraPosition);\n      this._cameraPositionInScaledSpace = cv;\n      this._distanceToLimbInScaledSpaceSquared = vhMagnitudeSquared;\n    }\n  }\n});\nconst scratchCartesian = new Cartesian3();\n\n/**\n * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.\n *\n * @param {Cartesian3} occludee The point to test for visibility.\n * @returns {boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n * @example\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n * const ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * const occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n * const point = new Cesium.Cartesian3(0, -3, -3);\n * occluder.isPointVisible(point); //returns true\n */\nEllipsoidalOccluder.prototype.isPointVisible = function (occludee) {\n  const ellipsoid = this._ellipsoid;\n  const occludeeScaledSpacePosition = ellipsoid.transformPositionToScaledSpace(occludee, scratchCartesian);\n  return isScaledSpacePointVisible(occludeeScaledSpacePosition, this._cameraPositionInScaledSpace, this._distanceToLimbInScaledSpaceSquared);\n};\n\n/**\n * Determines whether or not a point expressed in the ellipsoid scaled space, is hidden from view by the\n * occluder.  To transform a Cartesian X, Y, Z position in the coordinate system aligned with the ellipsoid\n * into the scaled space, call {@link Ellipsoid#transformPositionToScaledSpace}.\n *\n * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space.\n * @returns {boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n * @example\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n * const ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * const occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n * const point = new Cesium.Cartesian3(0, -3, -3);\n * const scaledSpacePoint = ellipsoid.transformPositionToScaledSpace(point);\n * occluder.isScaledSpacePointVisible(scaledSpacePoint); //returns true\n */\nEllipsoidalOccluder.prototype.isScaledSpacePointVisible = function (occludeeScaledSpacePosition) {\n  return isScaledSpacePointVisible(occludeeScaledSpacePosition, this._cameraPositionInScaledSpace, this._distanceToLimbInScaledSpaceSquared);\n};\nconst scratchCameraPositionInScaledSpaceShrunk = new Cartesian3();\n\n/**\n * Similar to {@link EllipsoidalOccluder#isScaledSpacePointVisible} except tests against an\n * ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. This is intended to be used with points generated by\n * {@link EllipsoidalOccluder#computeHorizonCullingPointPossiblyUnderEllipsoid} or\n * {@link EllipsoidalOccluder#computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space of the possibly-shrunk ellipsoid.\n * @returns {boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n */\nEllipsoidalOccluder.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid = function (occludeeScaledSpacePosition, minimumHeight) {\n  const ellipsoid = this._ellipsoid;\n  let vhMagnitudeSquared;\n  let cv;\n  if (defined(minimumHeight) && minimumHeight < 0.0 && ellipsoid.minimumRadius > -minimumHeight) {\n    // This code is similar to the cameraPosition setter, but unrolled for performance because it will be called a lot.\n    cv = scratchCameraPositionInScaledSpaceShrunk;\n    cv.x = this._cameraPosition.x / (ellipsoid.radii.x + minimumHeight);\n    cv.y = this._cameraPosition.y / (ellipsoid.radii.y + minimumHeight);\n    cv.z = this._cameraPosition.z / (ellipsoid.radii.z + minimumHeight);\n    vhMagnitudeSquared = cv.x * cv.x + cv.y * cv.y + cv.z * cv.z - 1.0;\n  } else {\n    cv = this._cameraPositionInScaledSpace;\n    vhMagnitudeSquared = this._distanceToLimbInScaledSpaceSquared;\n  }\n  return isScaledSpacePointVisible(occludeeScaledSpacePosition, cv, vhMagnitudeSquared);\n};\n\n/**\n * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\n * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\n * is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\n *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                       ellipsoid's axes.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPoint = function (directionToPoint, positions, result) {\n  return computeHorizonCullingPointFromPositions(this._ellipsoid, directionToPoint, positions, result);\n};\nconst scratchEllipsoidShrunk = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n\n/**\n * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPoint} except computes the culling\n * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\n * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\n *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                       ellipsoid's axes.\n * @param {number} [minimumHeight] The minimum height of all positions. If this value is undefined, all positions are assumed to be above the ellipsoid.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid = function (directionToPoint, positions, minimumHeight, result) {\n  const possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(this._ellipsoid, minimumHeight, scratchEllipsoidShrunk);\n  return computeHorizonCullingPointFromPositions(possiblyShrunkEllipsoid, directionToPoint, positions, result);\n};\n/**\n * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\n * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\n * is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\n *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                   ellipsoid's axes.\n * @param {number} [stride=3]\n * @param {Cartesian3} [center=Cartesian3.ZERO]\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromVertices = function (directionToPoint, vertices, stride, center, result) {\n  return computeHorizonCullingPointFromVertices(this._ellipsoid, directionToPoint, vertices, stride, center, result);\n};\n\n/**\n * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPointFromVertices} except computes the culling\n * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\n * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\n *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                   ellipsoid's axes.\n * @param {number} [stride=3]\n * @param {Cartesian3} [center=Cartesian3.ZERO]\n * @param {number} [minimumHeight] The minimum height of all vertices. If this value is undefined, all vertices are assumed to be above the ellipsoid.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid = function (directionToPoint, vertices, stride, center, minimumHeight, result) {\n  const possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(this._ellipsoid, minimumHeight, scratchEllipsoidShrunk);\n  return computeHorizonCullingPointFromVertices(possiblyShrunkEllipsoid, directionToPoint, vertices, stride, center, result);\n};\nconst subsampleScratch = [];\n\n/**\n * Computes a point that can be used for horizon culling of a rectangle.  If the point is below\n * the horizon, the ellipsoid-conforming rectangle is guaranteed to be below the horizon as well.\n * The returned point is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Rectangle} rectangle The rectangle for which to compute the horizon culling point.\n * @param {Ellipsoid} ellipsoid The ellipsoid on which the rectangle is defined.  This may be different from\n *                    the ellipsoid used by this instance for occlusion testing.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromRectangle = function (rectangle, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  const positions = Rectangle.subsample(rectangle, ellipsoid, 0.0, subsampleScratch);\n  const bs = BoundingSphere.fromPoints(positions);\n\n  // If the bounding sphere center is too close to the center of the occluder, it doesn't make\n  // sense to try to horizon cull it.\n  if (Cartesian3.magnitude(bs.center) < 0.1 * ellipsoid.minimumRadius) {\n    return undefined;\n  }\n  return this.computeHorizonCullingPoint(bs.center, positions, result);\n};\nconst scratchEllipsoidShrunkRadii = new Cartesian3();\nfunction getPossiblyShrunkEllipsoid(ellipsoid, minimumHeight, result) {\n  if (defined(minimumHeight) && minimumHeight < 0.0 && ellipsoid.minimumRadius > -minimumHeight) {\n    const ellipsoidShrunkRadii = Cartesian3.fromElements(ellipsoid.radii.x + minimumHeight, ellipsoid.radii.y + minimumHeight, ellipsoid.radii.z + minimumHeight, scratchEllipsoidShrunkRadii);\n    ellipsoid = Ellipsoid.fromCartesian3(ellipsoidShrunkRadii, result);\n  }\n  return ellipsoid;\n}\nfunction computeHorizonCullingPointFromPositions(ellipsoid, directionToPoint, positions, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"directionToPoint\", directionToPoint);\n  Check.defined(\"positions\", positions);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  const scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint);\n  let resultMagnitude = 0.0;\n  for (let i = 0, len = positions.length; i < len; ++i) {\n    const position = positions[i];\n    const candidateMagnitude = computeMagnitude(ellipsoid, position, scaledSpaceDirectionToPoint);\n    if (candidateMagnitude < 0.0) {\n      // all points should face the same direction, but this one doesn't, so return undefined\n      return undefined;\n    }\n    resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\n  }\n  return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\n}\nconst positionScratch = new Cartesian3();\nfunction computeHorizonCullingPointFromVertices(ellipsoid, directionToPoint, vertices, stride, center, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"directionToPoint\", directionToPoint);\n  Check.defined(\"vertices\", vertices);\n  Check.typeOf.number(\"stride\", stride);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  stride = stride ?? 3;\n  center = center ?? Cartesian3.ZERO;\n  const scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint);\n  let resultMagnitude = 0.0;\n  for (let i = 0, len = vertices.length; i < len; i += stride) {\n    positionScratch.x = vertices[i] + center.x;\n    positionScratch.y = vertices[i + 1] + center.y;\n    positionScratch.z = vertices[i + 2] + center.z;\n    const candidateMagnitude = computeMagnitude(ellipsoid, positionScratch, scaledSpaceDirectionToPoint);\n    if (candidateMagnitude < 0.0) {\n      // all points should face the same direction, but this one doesn't, so return undefined\n      return undefined;\n    }\n    resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\n  }\n  return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\n}\nfunction isScaledSpacePointVisible(occludeeScaledSpacePosition, cameraPositionInScaledSpace, distanceToLimbInScaledSpaceSquared) {\n  // See https://cesium.com/blog/2013/04/25/Horizon-culling/\n  const cv = cameraPositionInScaledSpace;\n  const vhMagnitudeSquared = distanceToLimbInScaledSpaceSquared;\n  const vt = Cartesian3.subtract(occludeeScaledSpacePosition, cv, scratchCartesian);\n  const vtDotVc = -Cartesian3.dot(vt, cv);\n  // If vhMagnitudeSquared < 0 then we are below the surface of the ellipsoid and\n  // in this case, set the culling plane to be on V.\n  const isOccluded = vhMagnitudeSquared < 0 ? vtDotVc > 0 : vtDotVc > vhMagnitudeSquared && vtDotVc * vtDotVc / Cartesian3.magnitudeSquared(vt) > vhMagnitudeSquared;\n  return !isOccluded;\n}\nconst scaledSpaceScratch = new Cartesian3();\nconst directionScratch = new Cartesian3();\nfunction computeMagnitude(ellipsoid, position, scaledSpaceDirectionToPoint) {\n  const scaledSpacePosition = ellipsoid.transformPositionToScaledSpace(position, scaledSpaceScratch);\n  let magnitudeSquared = Cartesian3.magnitudeSquared(scaledSpacePosition);\n  let magnitude = Math.sqrt(magnitudeSquared);\n  const direction = Cartesian3.divideByScalar(scaledSpacePosition, magnitude, directionScratch);\n\n  // For the purpose of this computation, points below the ellipsoid are consider to be on it instead.\n  magnitudeSquared = Math.max(1.0, magnitudeSquared);\n  magnitude = Math.max(1.0, magnitude);\n  const cosAlpha = Cartesian3.dot(direction, scaledSpaceDirectionToPoint);\n  const sinAlpha = Cartesian3.magnitude(Cartesian3.cross(direction, scaledSpaceDirectionToPoint, direction));\n  const cosBeta = 1.0 / magnitude;\n  const sinBeta = Math.sqrt(magnitudeSquared - 1.0) * cosBeta;\n  return 1.0 / (cosAlpha * cosBeta - sinAlpha * sinBeta);\n}\nfunction magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result) {\n  // The horizon culling point is undefined if there were no positions from which to compute it,\n  // the directionToPoint is pointing opposite all of the positions,  or if we computed NaN or infinity.\n  if (resultMagnitude <= 0.0 || resultMagnitude === 1.0 / 0.0 || resultMagnitude !== resultMagnitude) {\n    return undefined;\n  }\n  return Cartesian3.multiplyByScalar(scaledSpaceDirectionToPoint, resultMagnitude, result);\n}\nconst directionToPointScratch = new Cartesian3();\nfunction computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint) {\n  if (Cartesian3.equals(directionToPoint, Cartesian3.ZERO)) {\n    return directionToPoint;\n  }\n  ellipsoid.transformPositionToScaledSpace(directionToPoint, directionToPointScratch);\n  return Cartesian3.normalize(directionToPointScratch, directionToPointScratch);\n}\nexport default EllipsoidalOccluder;","map":{"version":3,"names":["BoundingSphere","Cartesian3","Check","defined","Ellipsoid","Rectangle","EllipsoidalOccluder","ellipsoid","cameraPosition","typeOf","object","_ellipsoid","_cameraPosition","_cameraPositionInScaledSpace","_distanceToLimbInScaledSpaceSquared","Object","defineProperties","prototype","get","set","cv","transformPositionToScaledSpace","vhMagnitudeSquared","magnitudeSquared","clone","scratchCartesian","isPointVisible","occludee","occludeeScaledSpacePosition","isScaledSpacePointVisible","scratchCameraPositionInScaledSpaceShrunk","isScaledSpacePointVisiblePossiblyUnderEllipsoid","minimumHeight","minimumRadius","x","radii","y","z","computeHorizonCullingPoint","directionToPoint","positions","result","computeHorizonCullingPointFromPositions","scratchEllipsoidShrunk","UNIT_SPHERE","computeHorizonCullingPointPossiblyUnderEllipsoid","possiblyShrunkEllipsoid","getPossiblyShrunkEllipsoid","computeHorizonCullingPointFromVertices","vertices","stride","center","computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid","subsampleScratch","computeHorizonCullingPointFromRectangle","rectangle","subsample","bs","fromPoints","magnitude","undefined","scratchEllipsoidShrunkRadii","ellipsoidShrunkRadii","fromElements","fromCartesian3","scaledSpaceDirectionToPoint","computeScaledSpaceDirectionToPoint","resultMagnitude","i","len","length","position","candidateMagnitude","computeMagnitude","Math","max","magnitudeToPoint","positionScratch","number","ZERO","cameraPositionInScaledSpace","distanceToLimbInScaledSpaceSquared","vt","subtract","vtDotVc","dot","isOccluded","scaledSpaceScratch","directionScratch","scaledSpacePosition","sqrt","direction","divideByScalar","cosAlpha","sinAlpha","cross","cosBeta","sinBeta","multiplyByScalar","directionToPointScratch","equals","normalize"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/EllipsoidalOccluder.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * Determine whether or not other objects are visible or hidden behind the visible horizon defined by\n * an {@link Ellipsoid} and a camera position.  The ellipsoid is assumed to be located at the\n * origin of the coordinate system.  This class uses the algorithm described in the\n * {@link https://cesium.com/blog/2013/04/25/Horizon-culling/|Horizon Culling} blog post.\n *\n * @alias EllipsoidalOccluder\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to use as an occluder.\n * @param {Cartesian3} [cameraPosition] The coordinate of the viewer/camera.  If this parameter is not\n *        specified, {@link EllipsoidalOccluder#cameraPosition} must be called before\n *        testing visibility.\n *\n * @constructor\n *\n * @example\n * // Construct an ellipsoidal occluder with radii 1.0, 1.1, and 0.9.\n * const cameraPosition = new Cesium.Cartesian3(5.0, 6.0, 7.0);\n * const occluderEllipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * const occluder = new Cesium.EllipsoidalOccluder(occluderEllipsoid, cameraPosition);\n *\n * @private\n */\nfunction EllipsoidalOccluder(ellipsoid, cameraPosition) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  //>>includeEnd('debug');\n\n  this._ellipsoid = ellipsoid;\n  this._cameraPosition = new Cartesian3();\n  this._cameraPositionInScaledSpace = new Cartesian3();\n  this._distanceToLimbInScaledSpaceSquared = 0.0;\n\n  // cameraPosition fills in the above values\n  if (defined(cameraPosition)) {\n    this.cameraPosition = cameraPosition;\n  }\n}\n\nObject.defineProperties(EllipsoidalOccluder.prototype, {\n  /**\n   * Gets the occluding ellipsoid.\n   * @memberof EllipsoidalOccluder.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n  /**\n   * Gets or sets the position of the camera.\n   * @memberof EllipsoidalOccluder.prototype\n   * @type {Cartesian3}\n   */\n  cameraPosition: {\n    get: function () {\n      return this._cameraPosition;\n    },\n    set: function (cameraPosition) {\n      // See https://cesium.com/blog/2013/04/25/Horizon-culling/\n      const ellipsoid = this._ellipsoid;\n      const cv = ellipsoid.transformPositionToScaledSpace(\n        cameraPosition,\n        this._cameraPositionInScaledSpace,\n      );\n      const vhMagnitudeSquared = Cartesian3.magnitudeSquared(cv) - 1.0;\n\n      Cartesian3.clone(cameraPosition, this._cameraPosition);\n      this._cameraPositionInScaledSpace = cv;\n      this._distanceToLimbInScaledSpaceSquared = vhMagnitudeSquared;\n    },\n  },\n});\n\nconst scratchCartesian = new Cartesian3();\n\n/**\n * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.\n *\n * @param {Cartesian3} occludee The point to test for visibility.\n * @returns {boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n * @example\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n * const ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * const occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n * const point = new Cesium.Cartesian3(0, -3, -3);\n * occluder.isPointVisible(point); //returns true\n */\nEllipsoidalOccluder.prototype.isPointVisible = function (occludee) {\n  const ellipsoid = this._ellipsoid;\n  const occludeeScaledSpacePosition = ellipsoid.transformPositionToScaledSpace(\n    occludee,\n    scratchCartesian,\n  );\n  return isScaledSpacePointVisible(\n    occludeeScaledSpacePosition,\n    this._cameraPositionInScaledSpace,\n    this._distanceToLimbInScaledSpaceSquared,\n  );\n};\n\n/**\n * Determines whether or not a point expressed in the ellipsoid scaled space, is hidden from view by the\n * occluder.  To transform a Cartesian X, Y, Z position in the coordinate system aligned with the ellipsoid\n * into the scaled space, call {@link Ellipsoid#transformPositionToScaledSpace}.\n *\n * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space.\n * @returns {boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n * @example\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n * const ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * const occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n * const point = new Cesium.Cartesian3(0, -3, -3);\n * const scaledSpacePoint = ellipsoid.transformPositionToScaledSpace(point);\n * occluder.isScaledSpacePointVisible(scaledSpacePoint); //returns true\n */\nEllipsoidalOccluder.prototype.isScaledSpacePointVisible = function (\n  occludeeScaledSpacePosition,\n) {\n  return isScaledSpacePointVisible(\n    occludeeScaledSpacePosition,\n    this._cameraPositionInScaledSpace,\n    this._distanceToLimbInScaledSpaceSquared,\n  );\n};\n\nconst scratchCameraPositionInScaledSpaceShrunk = new Cartesian3();\n\n/**\n * Similar to {@link EllipsoidalOccluder#isScaledSpacePointVisible} except tests against an\n * ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. This is intended to be used with points generated by\n * {@link EllipsoidalOccluder#computeHorizonCullingPointPossiblyUnderEllipsoid} or\n * {@link EllipsoidalOccluder#computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space of the possibly-shrunk ellipsoid.\n * @returns {boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n */\nEllipsoidalOccluder.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid =\n  function (occludeeScaledSpacePosition, minimumHeight) {\n    const ellipsoid = this._ellipsoid;\n    let vhMagnitudeSquared;\n    let cv;\n\n    if (\n      defined(minimumHeight) &&\n      minimumHeight < 0.0 &&\n      ellipsoid.minimumRadius > -minimumHeight\n    ) {\n      // This code is similar to the cameraPosition setter, but unrolled for performance because it will be called a lot.\n      cv = scratchCameraPositionInScaledSpaceShrunk;\n      cv.x = this._cameraPosition.x / (ellipsoid.radii.x + minimumHeight);\n      cv.y = this._cameraPosition.y / (ellipsoid.radii.y + minimumHeight);\n      cv.z = this._cameraPosition.z / (ellipsoid.radii.z + minimumHeight);\n      vhMagnitudeSquared = cv.x * cv.x + cv.y * cv.y + cv.z * cv.z - 1.0;\n    } else {\n      cv = this._cameraPositionInScaledSpace;\n      vhMagnitudeSquared = this._distanceToLimbInScaledSpaceSquared;\n    }\n\n    return isScaledSpacePointVisible(\n      occludeeScaledSpacePosition,\n      cv,\n      vhMagnitudeSquared,\n    );\n  };\n\n/**\n * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\n * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\n * is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\n *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                       ellipsoid's axes.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPoint = function (\n  directionToPoint,\n  positions,\n  result,\n) {\n  return computeHorizonCullingPointFromPositions(\n    this._ellipsoid,\n    directionToPoint,\n    positions,\n    result,\n  );\n};\n\nconst scratchEllipsoidShrunk = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n\n/**\n * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPoint} except computes the culling\n * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\n * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\n *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                       ellipsoid's axes.\n * @param {number} [minimumHeight] The minimum height of all positions. If this value is undefined, all positions are assumed to be above the ellipsoid.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid =\n  function (directionToPoint, positions, minimumHeight, result) {\n    const possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(\n      this._ellipsoid,\n      minimumHeight,\n      scratchEllipsoidShrunk,\n    );\n    return computeHorizonCullingPointFromPositions(\n      possiblyShrunkEllipsoid,\n      directionToPoint,\n      positions,\n      result,\n    );\n  };\n/**\n * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\n * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\n * is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\n *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                   ellipsoid's axes.\n * @param {number} [stride=3]\n * @param {Cartesian3} [center=Cartesian3.ZERO]\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromVertices =\n  function (directionToPoint, vertices, stride, center, result) {\n    return computeHorizonCullingPointFromVertices(\n      this._ellipsoid,\n      directionToPoint,\n      vertices,\n      stride,\n      center,\n      result,\n    );\n  };\n\n/**\n * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPointFromVertices} except computes the culling\n * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\n * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\n *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                   ellipsoid's axes.\n * @param {number} [stride=3]\n * @param {Cartesian3} [center=Cartesian3.ZERO]\n * @param {number} [minimumHeight] The minimum height of all vertices. If this value is undefined, all vertices are assumed to be above the ellipsoid.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid =\n  function (directionToPoint, vertices, stride, center, minimumHeight, result) {\n    const possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(\n      this._ellipsoid,\n      minimumHeight,\n      scratchEllipsoidShrunk,\n    );\n    return computeHorizonCullingPointFromVertices(\n      possiblyShrunkEllipsoid,\n      directionToPoint,\n      vertices,\n      stride,\n      center,\n      result,\n    );\n  };\n\nconst subsampleScratch = [];\n\n/**\n * Computes a point that can be used for horizon culling of a rectangle.  If the point is below\n * the horizon, the ellipsoid-conforming rectangle is guaranteed to be below the horizon as well.\n * The returned point is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Rectangle} rectangle The rectangle for which to compute the horizon culling point.\n * @param {Ellipsoid} ellipsoid The ellipsoid on which the rectangle is defined.  This may be different from\n *                    the ellipsoid used by this instance for occlusion testing.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromRectangle =\n  function (rectangle, ellipsoid, result) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.typeOf.object(\"rectangle\", rectangle);\n    //>>includeEnd('debug');\n\n    const positions = Rectangle.subsample(\n      rectangle,\n      ellipsoid,\n      0.0,\n      subsampleScratch,\n    );\n    const bs = BoundingSphere.fromPoints(positions);\n\n    // If the bounding sphere center is too close to the center of the occluder, it doesn't make\n    // sense to try to horizon cull it.\n    if (Cartesian3.magnitude(bs.center) < 0.1 * ellipsoid.minimumRadius) {\n      return undefined;\n    }\n\n    return this.computeHorizonCullingPoint(bs.center, positions, result);\n  };\n\nconst scratchEllipsoidShrunkRadii = new Cartesian3();\n\nfunction getPossiblyShrunkEllipsoid(ellipsoid, minimumHeight, result) {\n  if (\n    defined(minimumHeight) &&\n    minimumHeight < 0.0 &&\n    ellipsoid.minimumRadius > -minimumHeight\n  ) {\n    const ellipsoidShrunkRadii = Cartesian3.fromElements(\n      ellipsoid.radii.x + minimumHeight,\n      ellipsoid.radii.y + minimumHeight,\n      ellipsoid.radii.z + minimumHeight,\n      scratchEllipsoidShrunkRadii,\n    );\n    ellipsoid = Ellipsoid.fromCartesian3(ellipsoidShrunkRadii, result);\n  }\n  return ellipsoid;\n}\n\nfunction computeHorizonCullingPointFromPositions(\n  ellipsoid,\n  directionToPoint,\n  positions,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"directionToPoint\", directionToPoint);\n  Check.defined(\"positions\", positions);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  const scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(\n    ellipsoid,\n    directionToPoint,\n  );\n  let resultMagnitude = 0.0;\n\n  for (let i = 0, len = positions.length; i < len; ++i) {\n    const position = positions[i];\n    const candidateMagnitude = computeMagnitude(\n      ellipsoid,\n      position,\n      scaledSpaceDirectionToPoint,\n    );\n    if (candidateMagnitude < 0.0) {\n      // all points should face the same direction, but this one doesn't, so return undefined\n      return undefined;\n    }\n    resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\n  }\n\n  return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\n}\n\nconst positionScratch = new Cartesian3();\n\nfunction computeHorizonCullingPointFromVertices(\n  ellipsoid,\n  directionToPoint,\n  vertices,\n  stride,\n  center,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"directionToPoint\", directionToPoint);\n  Check.defined(\"vertices\", vertices);\n  Check.typeOf.number(\"stride\", stride);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  stride = stride ?? 3;\n  center = center ?? Cartesian3.ZERO;\n  const scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(\n    ellipsoid,\n    directionToPoint,\n  );\n  let resultMagnitude = 0.0;\n\n  for (let i = 0, len = vertices.length; i < len; i += stride) {\n    positionScratch.x = vertices[i] + center.x;\n    positionScratch.y = vertices[i + 1] + center.y;\n    positionScratch.z = vertices[i + 2] + center.z;\n\n    const candidateMagnitude = computeMagnitude(\n      ellipsoid,\n      positionScratch,\n      scaledSpaceDirectionToPoint,\n    );\n    if (candidateMagnitude < 0.0) {\n      // all points should face the same direction, but this one doesn't, so return undefined\n      return undefined;\n    }\n    resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\n  }\n\n  return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\n}\n\nfunction isScaledSpacePointVisible(\n  occludeeScaledSpacePosition,\n  cameraPositionInScaledSpace,\n  distanceToLimbInScaledSpaceSquared,\n) {\n  // See https://cesium.com/blog/2013/04/25/Horizon-culling/\n  const cv = cameraPositionInScaledSpace;\n  const vhMagnitudeSquared = distanceToLimbInScaledSpaceSquared;\n  const vt = Cartesian3.subtract(\n    occludeeScaledSpacePosition,\n    cv,\n    scratchCartesian,\n  );\n  const vtDotVc = -Cartesian3.dot(vt, cv);\n  // If vhMagnitudeSquared < 0 then we are below the surface of the ellipsoid and\n  // in this case, set the culling plane to be on V.\n  const isOccluded =\n    vhMagnitudeSquared < 0\n      ? vtDotVc > 0\n      : vtDotVc > vhMagnitudeSquared &&\n        (vtDotVc * vtDotVc) / Cartesian3.magnitudeSquared(vt) >\n          vhMagnitudeSquared;\n  return !isOccluded;\n}\n\nconst scaledSpaceScratch = new Cartesian3();\nconst directionScratch = new Cartesian3();\n\nfunction computeMagnitude(ellipsoid, position, scaledSpaceDirectionToPoint) {\n  const scaledSpacePosition = ellipsoid.transformPositionToScaledSpace(\n    position,\n    scaledSpaceScratch,\n  );\n  let magnitudeSquared = Cartesian3.magnitudeSquared(scaledSpacePosition);\n  let magnitude = Math.sqrt(magnitudeSquared);\n  const direction = Cartesian3.divideByScalar(\n    scaledSpacePosition,\n    magnitude,\n    directionScratch,\n  );\n\n  // For the purpose of this computation, points below the ellipsoid are consider to be on it instead.\n  magnitudeSquared = Math.max(1.0, magnitudeSquared);\n  magnitude = Math.max(1.0, magnitude);\n\n  const cosAlpha = Cartesian3.dot(direction, scaledSpaceDirectionToPoint);\n  const sinAlpha = Cartesian3.magnitude(\n    Cartesian3.cross(direction, scaledSpaceDirectionToPoint, direction),\n  );\n  const cosBeta = 1.0 / magnitude;\n  const sinBeta = Math.sqrt(magnitudeSquared - 1.0) * cosBeta;\n\n  return 1.0 / (cosAlpha * cosBeta - sinAlpha * sinBeta);\n}\n\nfunction magnitudeToPoint(\n  scaledSpaceDirectionToPoint,\n  resultMagnitude,\n  result,\n) {\n  // The horizon culling point is undefined if there were no positions from which to compute it,\n  // the directionToPoint is pointing opposite all of the positions,  or if we computed NaN or infinity.\n  if (\n    resultMagnitude <= 0.0 ||\n    resultMagnitude === 1.0 / 0.0 ||\n    resultMagnitude !== resultMagnitude\n  ) {\n    return undefined;\n  }\n\n  return Cartesian3.multiplyByScalar(\n    scaledSpaceDirectionToPoint,\n    resultMagnitude,\n    result,\n  );\n}\n\nconst directionToPointScratch = new Cartesian3();\n\nfunction computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint) {\n  if (Cartesian3.equals(directionToPoint, Cartesian3.ZERO)) {\n    return directionToPoint;\n  }\n\n  ellipsoid.transformPositionToScaledSpace(\n    directionToPoint,\n    directionToPointScratch,\n  );\n  return Cartesian3.normalize(directionToPointScratch, directionToPointScratch);\n}\nexport default EllipsoidalOccluder;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}