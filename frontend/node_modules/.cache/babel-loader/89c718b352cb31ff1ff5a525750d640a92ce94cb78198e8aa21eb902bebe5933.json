{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport AssociativeArray from \"../Core/AssociativeArray.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ClassificationType from \"../Scene/ClassificationType.js\";\nimport PolylineColorAppearance from \"../Scene/PolylineColorAppearance.js\";\nimport PolylineMaterialAppearance from \"../Scene/PolylineMaterialAppearance.js\";\nimport ShadowMode from \"../Scene/ShadowMode.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryBatch from \"./DynamicGeometryBatch.js\";\nimport PolylineGeometryUpdater from \"./PolylineGeometryUpdater.js\";\nimport StaticGeometryColorBatch from \"./StaticGeometryColorBatch.js\";\nimport StaticGeometryPerMaterialBatch from \"./StaticGeometryPerMaterialBatch.js\";\nimport StaticGroundPolylinePerMaterialBatch from \"./StaticGroundPolylinePerMaterialBatch.js\";\nconst emptyArray = [];\nfunction removeUpdater(that, updater) {\n  //We don't keep track of which batch an updater is in, so just remove it from all of them.\n  const batches = that._batches;\n  const length = batches.length;\n  for (let i = 0; i < length; i++) {\n    batches[i].remove(updater);\n  }\n}\nfunction insertUpdaterIntoBatch(that, time, updater) {\n  if (updater.isDynamic) {\n    that._dynamicBatch.add(time, updater);\n    return;\n  }\n  if (updater.clampToGround && updater.fillEnabled) {\n    // Also checks for support\n    const classificationType = updater.classificationTypeProperty.getValue(time);\n    that._groundBatches[classificationType].add(time, updater);\n    return;\n  }\n  let shadows;\n  if (updater.fillEnabled) {\n    shadows = updater.shadowsProperty.getValue(time);\n  }\n  let multiplier = 0;\n  if (defined(updater.depthFailMaterialProperty)) {\n    multiplier = updater.depthFailMaterialProperty instanceof ColorMaterialProperty ? 1 : 2;\n  }\n  let index;\n  if (defined(shadows)) {\n    index = shadows + multiplier * ShadowMode.NUMBER_OF_SHADOW_MODES;\n  }\n  if (updater.fillEnabled) {\n    if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n      that._colorBatches[index].add(time, updater);\n    } else {\n      that._materialBatches[index].add(time, updater);\n    }\n  }\n}\n\n/**\n * A visualizer for polylines represented by {@link Primitive} instances.\n * @alias PolylineVisualizer\n * @constructor\n *\n * @param {Scene} scene The scene the primitives will be rendered in.\n * @param {EntityCollection} entityCollection The entityCollection to visualize.\n * @param {PrimitiveCollection} [primitives=scene.primitives] A collection to add primitives related to the entities\n * @param {PrimitiveCollection} [groundPrimitives=scene.groundPrimitives] A collection to add ground primitives related to the entities\n */\nfunction PolylineVisualizer(scene, entityCollection, primitives, groundPrimitives) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"scene\", scene);\n  Check.defined(\"entityCollection\", entityCollection);\n  //>>includeEnd('debug');\n\n  groundPrimitives = groundPrimitives ?? scene.groundPrimitives;\n  primitives = primitives ?? scene.primitives;\n  this._scene = scene;\n  this._primitives = primitives;\n  this._entityCollection = undefined;\n  this._addedObjects = new AssociativeArray();\n  this._removedObjects = new AssociativeArray();\n  this._changedObjects = new AssociativeArray();\n  let i;\n  const numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n  this._colorBatches = new Array(numberOfShadowModes * 3);\n  this._materialBatches = new Array(numberOfShadowModes * 3);\n  for (i = 0; i < numberOfShadowModes; ++i) {\n    this._colorBatches[i] = new StaticGeometryColorBatch(primitives, PolylineColorAppearance, undefined, false, i); // no depth fail appearance\n    this._materialBatches[i] = new StaticGeometryPerMaterialBatch(primitives, PolylineMaterialAppearance, undefined, false, i);\n    this._colorBatches[i + numberOfShadowModes] = new StaticGeometryColorBatch(primitives, PolylineColorAppearance, PolylineColorAppearance, false, i); //depth fail appearance variations\n    this._materialBatches[i + numberOfShadowModes] = new StaticGeometryPerMaterialBatch(primitives, PolylineMaterialAppearance, PolylineColorAppearance, false, i);\n    this._colorBatches[i + numberOfShadowModes * 2] = new StaticGeometryColorBatch(primitives, PolylineColorAppearance, PolylineMaterialAppearance, false, i);\n    this._materialBatches[i + numberOfShadowModes * 2] = new StaticGeometryPerMaterialBatch(primitives, PolylineMaterialAppearance, PolylineMaterialAppearance, false, i);\n  }\n  this._dynamicBatch = new DynamicGeometryBatch(primitives, groundPrimitives);\n  const numberOfClassificationTypes = ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES;\n  this._groundBatches = new Array(numberOfClassificationTypes);\n  for (i = 0; i < numberOfClassificationTypes; ++i) {\n    this._groundBatches[i] = new StaticGroundPolylinePerMaterialBatch(groundPrimitives, i);\n  }\n  this._batches = this._colorBatches.concat(this._materialBatches, this._dynamicBatch, this._groundBatches);\n  this._subscriptions = new AssociativeArray();\n  this._updaters = new AssociativeArray();\n  this._entityCollection = entityCollection;\n  entityCollection.collectionChanged.addEventListener(PolylineVisualizer.prototype._onCollectionChanged, this);\n  this._onCollectionChanged(entityCollection, entityCollection.values, emptyArray);\n}\n\n/**\n * Updates all of the primitives created by this visualizer to match their\n * Entity counterpart at the given time.\n *\n * @param {JulianDate} time The time to update to.\n * @returns {boolean} True if the visualizer successfully updated to the provided time,\n * false if the visualizer is waiting for asynchronous primitives to be created.\n */\nPolylineVisualizer.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  const addedObjects = this._addedObjects;\n  const added = addedObjects.values;\n  const removedObjects = this._removedObjects;\n  const removed = removedObjects.values;\n  const changedObjects = this._changedObjects;\n  const changed = changedObjects.values;\n  let i;\n  let entity;\n  let id;\n  let updater;\n  for (i = changed.length - 1; i > -1; i--) {\n    entity = changed[i];\n    id = entity.id;\n    updater = this._updaters.get(id);\n\n    //If in a single update, an entity gets removed and a new instance\n    //re-added with the same id, the updater no longer tracks the\n    //correct entity, we need to both remove the old one and\n    //add the new one, which is done by pushing the entity\n    //onto the removed/added lists.\n    if (updater.entity === entity) {\n      removeUpdater(this, updater);\n      insertUpdaterIntoBatch(this, time, updater);\n    } else {\n      removed.push(entity);\n      added.push(entity);\n    }\n  }\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    id = entity.id;\n    updater = this._updaters.get(id);\n    removeUpdater(this, updater);\n    updater.destroy();\n    this._updaters.remove(id);\n    this._subscriptions.get(id)();\n    this._subscriptions.remove(id);\n  }\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    id = entity.id;\n    updater = new PolylineGeometryUpdater(entity, this._scene);\n    this._updaters.set(id, updater);\n    insertUpdaterIntoBatch(this, time, updater);\n    this._subscriptions.set(id, updater.geometryChanged.addEventListener(PolylineVisualizer._onGeometryChanged, this));\n  }\n  addedObjects.removeAll();\n  removedObjects.removeAll();\n  changedObjects.removeAll();\n  let isUpdated = true;\n  const batches = this._batches;\n  const length = batches.length;\n  for (i = 0; i < length; i++) {\n    isUpdated = batches[i].update(time) && isUpdated;\n  }\n  return isUpdated;\n};\nconst getBoundingSphereArrayScratch = [];\nconst getBoundingSphereBoundingSphereScratch = new BoundingSphere();\n\n/**\n * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n * The bounding sphere is in the fixed frame of the scene's globe.\n *\n * @param {Entity} entity The entity whose bounding sphere to compute.\n * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n *                       BoundingSphereState.PENDING if the result is still being computed, or\n *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n * @private\n */\nPolylineVisualizer.prototype.getBoundingSphere = function (entity, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"entity\", entity);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  const boundingSpheres = getBoundingSphereArrayScratch;\n  const tmp = getBoundingSphereBoundingSphereScratch;\n  let count = 0;\n  let state = BoundingSphereState.DONE;\n  const batches = this._batches;\n  const batchesLength = batches.length;\n  const updater = this._updaters.get(entity.id);\n  for (let i = 0; i < batchesLength; i++) {\n    state = batches[i].getBoundingSphere(updater, tmp);\n    if (state === BoundingSphereState.PENDING) {\n      return BoundingSphereState.PENDING;\n    } else if (state === BoundingSphereState.DONE) {\n      boundingSpheres[count] = BoundingSphere.clone(tmp, boundingSpheres[count]);\n      count++;\n    }\n  }\n  if (count === 0) {\n    return BoundingSphereState.FAILED;\n  }\n  boundingSpheres.length = count;\n  BoundingSphere.fromBoundingSpheres(boundingSpheres, result);\n  return BoundingSphereState.DONE;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n */\nPolylineVisualizer.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes and destroys all primitives created by this instance.\n */\nPolylineVisualizer.prototype.destroy = function () {\n  this._entityCollection.collectionChanged.removeEventListener(PolylineVisualizer.prototype._onCollectionChanged, this);\n  this._addedObjects.removeAll();\n  this._removedObjects.removeAll();\n  let i;\n  const batches = this._batches;\n  let length = batches.length;\n  for (i = 0; i < length; i++) {\n    batches[i].removeAllPrimitives();\n  }\n  const subscriptions = this._subscriptions.values;\n  length = subscriptions.length;\n  for (i = 0; i < length; i++) {\n    subscriptions[i]();\n  }\n  this._subscriptions.removeAll();\n  return destroyObject(this);\n};\n\n/**\n * @private\n */\nPolylineVisualizer._onGeometryChanged = function (updater) {\n  const removedObjects = this._removedObjects;\n  const changedObjects = this._changedObjects;\n  const entity = updater.entity;\n  const id = entity.id;\n  if (!defined(removedObjects.get(id)) && !defined(changedObjects.get(id))) {\n    changedObjects.set(id, entity);\n  }\n};\n\n/**\n * @private\n */\nPolylineVisualizer.prototype._onCollectionChanged = function (entityCollection, added, removed) {\n  const addedObjects = this._addedObjects;\n  const removedObjects = this._removedObjects;\n  const changedObjects = this._changedObjects;\n  let i;\n  let id;\n  let entity;\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    id = entity.id;\n    if (!addedObjects.remove(id)) {\n      removedObjects.set(id, entity);\n      changedObjects.remove(id);\n    }\n  }\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    id = entity.id;\n    if (removedObjects.remove(id)) {\n      changedObjects.set(id, entity);\n    } else {\n      addedObjects.set(id, entity);\n    }\n  }\n};\nexport default PolylineVisualizer;","map":{"version":3,"names":["AssociativeArray","BoundingSphere","Check","defined","destroyObject","ClassificationType","PolylineColorAppearance","PolylineMaterialAppearance","ShadowMode","BoundingSphereState","ColorMaterialProperty","DynamicGeometryBatch","PolylineGeometryUpdater","StaticGeometryColorBatch","StaticGeometryPerMaterialBatch","StaticGroundPolylinePerMaterialBatch","emptyArray","removeUpdater","that","updater","batches","_batches","length","i","remove","insertUpdaterIntoBatch","time","isDynamic","_dynamicBatch","add","clampToGround","fillEnabled","classificationType","classificationTypeProperty","getValue","_groundBatches","shadows","shadowsProperty","multiplier","depthFailMaterialProperty","index","NUMBER_OF_SHADOW_MODES","fillMaterialProperty","_colorBatches","_materialBatches","PolylineVisualizer","scene","entityCollection","primitives","groundPrimitives","_scene","_primitives","_entityCollection","undefined","_addedObjects","_removedObjects","_changedObjects","numberOfShadowModes","Array","numberOfClassificationTypes","NUMBER_OF_CLASSIFICATION_TYPES","concat","_subscriptions","_updaters","collectionChanged","addEventListener","prototype","_onCollectionChanged","values","update","addedObjects","added","removedObjects","removed","changedObjects","changed","entity","id","get","push","destroy","set","geometryChanged","_onGeometryChanged","removeAll","isUpdated","getBoundingSphereArrayScratch","getBoundingSphereBoundingSphereScratch","getBoundingSphere","result","boundingSpheres","tmp","count","state","DONE","batchesLength","PENDING","clone","FAILED","fromBoundingSpheres","isDestroyed","removeEventListener","removeAllPrimitives","subscriptions"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/DataSources/PolylineVisualizer.js"],"sourcesContent":["import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ClassificationType from \"../Scene/ClassificationType.js\";\nimport PolylineColorAppearance from \"../Scene/PolylineColorAppearance.js\";\nimport PolylineMaterialAppearance from \"../Scene/PolylineMaterialAppearance.js\";\nimport ShadowMode from \"../Scene/ShadowMode.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryBatch from \"./DynamicGeometryBatch.js\";\nimport PolylineGeometryUpdater from \"./PolylineGeometryUpdater.js\";\nimport StaticGeometryColorBatch from \"./StaticGeometryColorBatch.js\";\nimport StaticGeometryPerMaterialBatch from \"./StaticGeometryPerMaterialBatch.js\";\nimport StaticGroundPolylinePerMaterialBatch from \"./StaticGroundPolylinePerMaterialBatch.js\";\n\nconst emptyArray = [];\n\nfunction removeUpdater(that, updater) {\n  //We don't keep track of which batch an updater is in, so just remove it from all of them.\n  const batches = that._batches;\n  const length = batches.length;\n  for (let i = 0; i < length; i++) {\n    batches[i].remove(updater);\n  }\n}\n\nfunction insertUpdaterIntoBatch(that, time, updater) {\n  if (updater.isDynamic) {\n    that._dynamicBatch.add(time, updater);\n    return;\n  }\n\n  if (updater.clampToGround && updater.fillEnabled) {\n    // Also checks for support\n    const classificationType =\n      updater.classificationTypeProperty.getValue(time);\n    that._groundBatches[classificationType].add(time, updater);\n    return;\n  }\n\n  let shadows;\n  if (updater.fillEnabled) {\n    shadows = updater.shadowsProperty.getValue(time);\n  }\n\n  let multiplier = 0;\n  if (defined(updater.depthFailMaterialProperty)) {\n    multiplier =\n      updater.depthFailMaterialProperty instanceof ColorMaterialProperty\n        ? 1\n        : 2;\n  }\n\n  let index;\n  if (defined(shadows)) {\n    index = shadows + multiplier * ShadowMode.NUMBER_OF_SHADOW_MODES;\n  }\n\n  if (updater.fillEnabled) {\n    if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n      that._colorBatches[index].add(time, updater);\n    } else {\n      that._materialBatches[index].add(time, updater);\n    }\n  }\n}\n\n/**\n * A visualizer for polylines represented by {@link Primitive} instances.\n * @alias PolylineVisualizer\n * @constructor\n *\n * @param {Scene} scene The scene the primitives will be rendered in.\n * @param {EntityCollection} entityCollection The entityCollection to visualize.\n * @param {PrimitiveCollection} [primitives=scene.primitives] A collection to add primitives related to the entities\n * @param {PrimitiveCollection} [groundPrimitives=scene.groundPrimitives] A collection to add ground primitives related to the entities\n */\nfunction PolylineVisualizer(\n  scene,\n  entityCollection,\n  primitives,\n  groundPrimitives,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"scene\", scene);\n  Check.defined(\"entityCollection\", entityCollection);\n  //>>includeEnd('debug');\n\n  groundPrimitives = groundPrimitives ?? scene.groundPrimitives;\n  primitives = primitives ?? scene.primitives;\n\n  this._scene = scene;\n  this._primitives = primitives;\n  this._entityCollection = undefined;\n  this._addedObjects = new AssociativeArray();\n  this._removedObjects = new AssociativeArray();\n  this._changedObjects = new AssociativeArray();\n\n  let i;\n  const numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n  this._colorBatches = new Array(numberOfShadowModes * 3);\n  this._materialBatches = new Array(numberOfShadowModes * 3);\n\n  for (i = 0; i < numberOfShadowModes; ++i) {\n    this._colorBatches[i] = new StaticGeometryColorBatch(\n      primitives,\n      PolylineColorAppearance,\n      undefined,\n      false,\n      i,\n    ); // no depth fail appearance\n    this._materialBatches[i] = new StaticGeometryPerMaterialBatch(\n      primitives,\n      PolylineMaterialAppearance,\n      undefined,\n      false,\n      i,\n    );\n\n    this._colorBatches[i + numberOfShadowModes] = new StaticGeometryColorBatch(\n      primitives,\n      PolylineColorAppearance,\n      PolylineColorAppearance,\n      false,\n      i,\n    ); //depth fail appearance variations\n    this._materialBatches[i + numberOfShadowModes] =\n      new StaticGeometryPerMaterialBatch(\n        primitives,\n        PolylineMaterialAppearance,\n        PolylineColorAppearance,\n        false,\n        i,\n      );\n\n    this._colorBatches[i + numberOfShadowModes * 2] =\n      new StaticGeometryColorBatch(\n        primitives,\n        PolylineColorAppearance,\n        PolylineMaterialAppearance,\n        false,\n        i,\n      );\n    this._materialBatches[i + numberOfShadowModes * 2] =\n      new StaticGeometryPerMaterialBatch(\n        primitives,\n        PolylineMaterialAppearance,\n        PolylineMaterialAppearance,\n        false,\n        i,\n      );\n  }\n\n  this._dynamicBatch = new DynamicGeometryBatch(primitives, groundPrimitives);\n\n  const numberOfClassificationTypes =\n    ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES;\n  this._groundBatches = new Array(numberOfClassificationTypes);\n\n  for (i = 0; i < numberOfClassificationTypes; ++i) {\n    this._groundBatches[i] = new StaticGroundPolylinePerMaterialBatch(\n      groundPrimitives,\n      i,\n    );\n  }\n\n  this._batches = this._colorBatches.concat(\n    this._materialBatches,\n    this._dynamicBatch,\n    this._groundBatches,\n  );\n\n  this._subscriptions = new AssociativeArray();\n  this._updaters = new AssociativeArray();\n\n  this._entityCollection = entityCollection;\n  entityCollection.collectionChanged.addEventListener(\n    PolylineVisualizer.prototype._onCollectionChanged,\n    this,\n  );\n  this._onCollectionChanged(\n    entityCollection,\n    entityCollection.values,\n    emptyArray,\n  );\n}\n\n/**\n * Updates all of the primitives created by this visualizer to match their\n * Entity counterpart at the given time.\n *\n * @param {JulianDate} time The time to update to.\n * @returns {boolean} True if the visualizer successfully updated to the provided time,\n * false if the visualizer is waiting for asynchronous primitives to be created.\n */\nPolylineVisualizer.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  const addedObjects = this._addedObjects;\n  const added = addedObjects.values;\n  const removedObjects = this._removedObjects;\n  const removed = removedObjects.values;\n  const changedObjects = this._changedObjects;\n  const changed = changedObjects.values;\n\n  let i;\n  let entity;\n  let id;\n  let updater;\n\n  for (i = changed.length - 1; i > -1; i--) {\n    entity = changed[i];\n    id = entity.id;\n    updater = this._updaters.get(id);\n\n    //If in a single update, an entity gets removed and a new instance\n    //re-added with the same id, the updater no longer tracks the\n    //correct entity, we need to both remove the old one and\n    //add the new one, which is done by pushing the entity\n    //onto the removed/added lists.\n    if (updater.entity === entity) {\n      removeUpdater(this, updater);\n      insertUpdaterIntoBatch(this, time, updater);\n    } else {\n      removed.push(entity);\n      added.push(entity);\n    }\n  }\n\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    id = entity.id;\n    updater = this._updaters.get(id);\n    removeUpdater(this, updater);\n    updater.destroy();\n    this._updaters.remove(id);\n    this._subscriptions.get(id)();\n    this._subscriptions.remove(id);\n  }\n\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    id = entity.id;\n    updater = new PolylineGeometryUpdater(entity, this._scene);\n    this._updaters.set(id, updater);\n    insertUpdaterIntoBatch(this, time, updater);\n    this._subscriptions.set(\n      id,\n      updater.geometryChanged.addEventListener(\n        PolylineVisualizer._onGeometryChanged,\n        this,\n      ),\n    );\n  }\n\n  addedObjects.removeAll();\n  removedObjects.removeAll();\n  changedObjects.removeAll();\n\n  let isUpdated = true;\n  const batches = this._batches;\n  const length = batches.length;\n  for (i = 0; i < length; i++) {\n    isUpdated = batches[i].update(time) && isUpdated;\n  }\n\n  return isUpdated;\n};\n\nconst getBoundingSphereArrayScratch = [];\nconst getBoundingSphereBoundingSphereScratch = new BoundingSphere();\n\n/**\n * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n * The bounding sphere is in the fixed frame of the scene's globe.\n *\n * @param {Entity} entity The entity whose bounding sphere to compute.\n * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n *                       BoundingSphereState.PENDING if the result is still being computed, or\n *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n * @private\n */\nPolylineVisualizer.prototype.getBoundingSphere = function (entity, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"entity\", entity);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  const boundingSpheres = getBoundingSphereArrayScratch;\n  const tmp = getBoundingSphereBoundingSphereScratch;\n\n  let count = 0;\n  let state = BoundingSphereState.DONE;\n  const batches = this._batches;\n  const batchesLength = batches.length;\n  const updater = this._updaters.get(entity.id);\n  for (let i = 0; i < batchesLength; i++) {\n    state = batches[i].getBoundingSphere(updater, tmp);\n    if (state === BoundingSphereState.PENDING) {\n      return BoundingSphereState.PENDING;\n    } else if (state === BoundingSphereState.DONE) {\n      boundingSpheres[count] = BoundingSphere.clone(\n        tmp,\n        boundingSpheres[count],\n      );\n      count++;\n    }\n  }\n\n  if (count === 0) {\n    return BoundingSphereState.FAILED;\n  }\n\n  boundingSpheres.length = count;\n  BoundingSphere.fromBoundingSpheres(boundingSpheres, result);\n  return BoundingSphereState.DONE;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n */\nPolylineVisualizer.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes and destroys all primitives created by this instance.\n */\nPolylineVisualizer.prototype.destroy = function () {\n  this._entityCollection.collectionChanged.removeEventListener(\n    PolylineVisualizer.prototype._onCollectionChanged,\n    this,\n  );\n  this._addedObjects.removeAll();\n  this._removedObjects.removeAll();\n\n  let i;\n  const batches = this._batches;\n  let length = batches.length;\n  for (i = 0; i < length; i++) {\n    batches[i].removeAllPrimitives();\n  }\n\n  const subscriptions = this._subscriptions.values;\n  length = subscriptions.length;\n  for (i = 0; i < length; i++) {\n    subscriptions[i]();\n  }\n  this._subscriptions.removeAll();\n  return destroyObject(this);\n};\n\n/**\n * @private\n */\nPolylineVisualizer._onGeometryChanged = function (updater) {\n  const removedObjects = this._removedObjects;\n  const changedObjects = this._changedObjects;\n\n  const entity = updater.entity;\n  const id = entity.id;\n\n  if (!defined(removedObjects.get(id)) && !defined(changedObjects.get(id))) {\n    changedObjects.set(id, entity);\n  }\n};\n\n/**\n * @private\n */\nPolylineVisualizer.prototype._onCollectionChanged = function (\n  entityCollection,\n  added,\n  removed,\n) {\n  const addedObjects = this._addedObjects;\n  const removedObjects = this._removedObjects;\n  const changedObjects = this._changedObjects;\n\n  let i;\n  let id;\n  let entity;\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    id = entity.id;\n    if (!addedObjects.remove(id)) {\n      removedObjects.set(id, entity);\n      changedObjects.remove(id);\n    }\n  }\n\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    id = entity.id;\n    if (removedObjects.remove(id)) {\n      changedObjects.set(id, entity);\n    } else {\n      addedObjects.set(id, entity);\n    }\n  }\n};\nexport default PolylineVisualizer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}