{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport CullingVolume from \"./CullingVolume.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias PerspectiveOffCenterFrustum\n * @constructor\n *\n * @param {object} [options] An object with the following properties:\n * @param {number} [options.left] The left clipping plane distance.\n * @param {number} [options.right] The right clipping plane distance.\n * @param {number} [options.top] The top clipping plane distance.\n * @param {number} [options.bottom] The bottom clipping plane distance.\n * @param {number} [options.near=1.0] The near clipping plane distance.\n * @param {number} [options.far=500000000.0] The far clipping plane distance.\n *\n * @example\n * const frustum = new Cesium.PerspectiveOffCenterFrustum({\n *     left : -1.0,\n *     right : 1.0,\n *     top : 1.0,\n *     bottom : -1.0,\n *     near : 1.0,\n *     far : 100.0\n * });\n *\n * @see PerspectiveFrustum\n */\nfunction PerspectiveOffCenterFrustum(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  /**\n   * Defines the left clipping plane.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.left = options.left;\n  this._left = undefined;\n\n  /**\n   * Defines the right clipping plane.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.right = options.right;\n  this._right = undefined;\n\n  /**\n   * Defines the top clipping plane.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.top = options.top;\n  this._top = undefined;\n\n  /**\n   * Defines the bottom clipping plane.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.bottom = options.bottom;\n  this._bottom = undefined;\n\n  /**\n   * The distance of the near plane.\n   * @type {number}\n   * @default 1.0\n   */\n  this.near = options.near ?? 1.0;\n  this._near = this.near;\n\n  /**\n   * The distance of the far plane.\n   * @type {number}\n   * @default 500000000.0\n   */\n  this.far = options.far ?? 500000000.0;\n  this._far = this.far;\n  this._cullingVolume = new CullingVolume();\n  this._perspectiveMatrix = new Matrix4();\n  this._infinitePerspective = new Matrix4();\n}\nfunction update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(frustum.right) || !defined(frustum.left) || !defined(frustum.top) || !defined(frustum.bottom) || !defined(frustum.near) || !defined(frustum.far)) {\n    throw new DeveloperError(\"right, left, top, bottom, near, or far parameters are not set.\");\n  }\n  //>>includeEnd('debug');\n\n  const {\n    top,\n    bottom,\n    right,\n    left,\n    near,\n    far\n  } = frustum;\n  const changed = top !== frustum._top || bottom !== frustum._bottom || left !== frustum._left || right !== frustum._right || near !== frustum._near || far !== frustum._far;\n  if (!changed) {\n    return;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (frustum.near <= 0 || frustum.near > frustum.far) {\n    throw new DeveloperError(\"near must be greater than zero and less than far.\");\n  }\n  //>>includeEnd('debug');\n\n  frustum._left = left;\n  frustum._right = right;\n  frustum._top = top;\n  frustum._bottom = bottom;\n  frustum._near = near;\n  frustum._far = far;\n  frustum._perspectiveMatrix = Matrix4.computePerspectiveOffCenter(left, right, bottom, top, near, far, frustum._perspectiveMatrix);\n  frustum._infinitePerspective = Matrix4.computeInfinitePerspectiveOffCenter(left, right, bottom, top, near, frustum._infinitePerspective);\n}\nObject.defineProperties(PerspectiveOffCenterFrustum.prototype, {\n  /**\n   * Gets the perspective projection matrix computed from the view frustum.\n   * The projection matrix will be recomputed if any frustum parameters have changed.\n   *\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix\n   */\n  projectionMatrix: {\n    get: function () {\n      update(this);\n      return this._perspectiveMatrix;\n    }\n  },\n  /**\n   * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveOffCenterFrustum#projectionMatrix\n   */\n  infiniteProjectionMatrix: {\n    get: function () {\n      update(this);\n      return this._infinitePerspective;\n    }\n  }\n});\nconst getPlanesRight = new Cartesian3();\nconst getPlanesNearCenter = new Cartesian3();\nconst getPlanesFarCenter = new Cartesian3();\nconst getPlanesNormal = new Cartesian3();\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);\n */\nPerspectiveOffCenterFrustum.prototype.computeCullingVolume = function (position, direction, up) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n  if (!defined(up)) {\n    throw new DeveloperError(\"up is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const planes = this._cullingVolume.planes;\n  const t = this.top;\n  const b = this.bottom;\n  const r = this.right;\n  const l = this.left;\n  const n = this.near;\n  const f = this.far;\n  const right = Cartesian3.cross(direction, up, getPlanesRight);\n  const nearCenter = getPlanesNearCenter;\n  Cartesian3.multiplyByScalar(direction, n, nearCenter);\n  Cartesian3.add(position, nearCenter, nearCenter);\n  const farCenter = getPlanesFarCenter;\n  Cartesian3.multiplyByScalar(direction, f, farCenter);\n  Cartesian3.add(position, farCenter, farCenter);\n  const normal = getPlanesNormal;\n\n  //Left plane computation\n  Cartesian3.multiplyByScalar(right, l, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.normalize(normal, normal);\n  Cartesian3.cross(normal, up, normal);\n  Cartesian3.normalize(normal, normal);\n  let plane = planes[0];\n  if (!defined(plane)) {\n    plane = planes[0] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Right plane computation\n  Cartesian3.multiplyByScalar(right, r, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.cross(up, normal, normal);\n  Cartesian3.normalize(normal, normal);\n  plane = planes[1];\n  if (!defined(plane)) {\n    plane = planes[1] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Bottom plane computation\n  Cartesian3.multiplyByScalar(up, b, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.cross(right, normal, normal);\n  Cartesian3.normalize(normal, normal);\n  plane = planes[2];\n  if (!defined(plane)) {\n    plane = planes[2] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Top plane computation\n  Cartesian3.multiplyByScalar(up, t, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.cross(normal, right, normal);\n  Cartesian3.normalize(normal, normal);\n  plane = planes[3];\n  if (!defined(plane)) {\n    plane = planes[3] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Near plane computation\n  plane = planes[4];\n  if (!defined(plane)) {\n    plane = planes[4] = new Cartesian4();\n  }\n  plane.x = direction.x;\n  plane.y = direction.y;\n  plane.z = direction.z;\n  plane.w = -Cartesian3.dot(direction, nearCenter);\n\n  //Far plane computation\n  Cartesian3.negate(direction, normal);\n  plane = planes[5];\n  if (!defined(plane)) {\n    plane = planes[5] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, farCenter);\n  return this._cullingVolume;\n};\n\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {number} drawingBufferWidth The width of the drawing buffer.\n * @param {number} drawingBufferHeight The height of the drawing buffer.\n * @param {number} distance The distance to the near plane in meters.\n * @param {number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\n *\n * @example\n * // Example 2\n * // Get the width and height of a pixel if the near plane was set to 'distance'.\n * // For example, get the size of a pixel of an image on a billboard.\n * const position = camera.position;\n * const direction = camera.direction;\n * const toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive\n * const toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector\n * const distance = Cesium.Cartesian3.magnitude(toCenterProj);\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());\n */\nPerspectiveOffCenterFrustum.prototype.getPixelDimensions = function (drawingBufferWidth, drawingBufferHeight, distance, pixelRatio, result) {\n  update(this);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(drawingBufferWidth) || !defined(drawingBufferHeight)) {\n    throw new DeveloperError(\"Both drawingBufferWidth and drawingBufferHeight are required.\");\n  }\n  if (drawingBufferWidth <= 0) {\n    throw new DeveloperError(\"drawingBufferWidth must be greater than zero.\");\n  }\n  if (drawingBufferHeight <= 0) {\n    throw new DeveloperError(\"drawingBufferHeight must be greater than zero.\");\n  }\n  if (!defined(distance)) {\n    throw new DeveloperError(\"distance is required.\");\n  }\n  if (!defined(pixelRatio)) {\n    throw new DeveloperError(\"pixelRatio is required\");\n  }\n  if (pixelRatio <= 0) {\n    throw new DeveloperError(\"pixelRatio must be greater than zero.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"A result object is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const inverseNear = 1.0 / this.near;\n  let tanTheta = this.top * inverseNear;\n  const pixelHeight = 2.0 * pixelRatio * distance * tanTheta / drawingBufferHeight;\n  tanTheta = this.right * inverseNear;\n  const pixelWidth = 2.0 * pixelRatio * distance * tanTheta / drawingBufferWidth;\n  result.x = pixelWidth;\n  result.y = pixelHeight;\n  return result;\n};\n\n/**\n * Returns a duplicate of a PerspectiveOffCenterFrustum instance.\n *\n * @param {PerspectiveOffCenterFrustum} [result] The object onto which to store the result.\n * @returns {PerspectiveOffCenterFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\n */\nPerspectiveOffCenterFrustum.prototype.clone = function (result) {\n  if (!defined(result)) {\n    result = new PerspectiveOffCenterFrustum();\n  }\n  result.right = this.right;\n  result.left = this.left;\n  result.top = this.top;\n  result.bottom = this.bottom;\n  result.near = this.near;\n  result.far = this.far;\n\n  // force update of clone to compute matrices\n  result._left = undefined;\n  result._right = undefined;\n  result._top = undefined;\n  result._bottom = undefined;\n  result._near = undefined;\n  result._far = undefined;\n  return result;\n};\n\n/**\n * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {PerspectiveOffCenterFrustum} [other] The right hand side PerspectiveOffCenterFrustum.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nPerspectiveOffCenterFrustum.prototype.equals = function (other) {\n  return defined(other) && other instanceof PerspectiveOffCenterFrustum && this.right === other.right && this.left === other.left && this.top === other.top && this.bottom === other.bottom && this.near === other.near && this.far === other.far;\n};\n\n/**\n * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {PerspectiveOffCenterFrustum} other The right hand side PerspectiveOffCenterFrustum.\n * @param {number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\nPerspectiveOffCenterFrustum.prototype.equalsEpsilon = function (other, relativeEpsilon, absoluteEpsilon) {\n  return other === this || defined(other) && other instanceof PerspectiveOffCenterFrustum && CesiumMath.equalsEpsilon(this.right, other.right, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(this.left, other.left, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(this.top, other.top, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(this.bottom, other.bottom, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(this.near, other.near, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(this.far, other.far, relativeEpsilon, absoluteEpsilon);\n};\nexport default PerspectiveOffCenterFrustum;","map":{"version":3,"names":["Cartesian3","Cartesian4","CullingVolume","Frozen","defined","DeveloperError","CesiumMath","Matrix4","PerspectiveOffCenterFrustum","options","EMPTY_OBJECT","left","_left","undefined","right","_right","top","_top","bottom","_bottom","near","_near","far","_far","_cullingVolume","_perspectiveMatrix","_infinitePerspective","update","frustum","changed","computePerspectiveOffCenter","computeInfinitePerspectiveOffCenter","Object","defineProperties","prototype","projectionMatrix","get","infiniteProjectionMatrix","getPlanesRight","getPlanesNearCenter","getPlanesFarCenter","getPlanesNormal","computeCullingVolume","position","direction","up","planes","t","b","r","l","n","f","cross","nearCenter","multiplyByScalar","add","farCenter","normal","subtract","normalize","plane","x","y","z","w","dot","negate","getPixelDimensions","drawingBufferWidth","drawingBufferHeight","distance","pixelRatio","result","inverseNear","tanTheta","pixelHeight","pixelWidth","clone","equals","other","equalsEpsilon","relativeEpsilon","absoluteEpsilon"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/PerspectiveOffCenterFrustum.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport CullingVolume from \"./CullingVolume.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias PerspectiveOffCenterFrustum\n * @constructor\n *\n * @param {object} [options] An object with the following properties:\n * @param {number} [options.left] The left clipping plane distance.\n * @param {number} [options.right] The right clipping plane distance.\n * @param {number} [options.top] The top clipping plane distance.\n * @param {number} [options.bottom] The bottom clipping plane distance.\n * @param {number} [options.near=1.0] The near clipping plane distance.\n * @param {number} [options.far=500000000.0] The far clipping plane distance.\n *\n * @example\n * const frustum = new Cesium.PerspectiveOffCenterFrustum({\n *     left : -1.0,\n *     right : 1.0,\n *     top : 1.0,\n *     bottom : -1.0,\n *     near : 1.0,\n *     far : 100.0\n * });\n *\n * @see PerspectiveFrustum\n */\nfunction PerspectiveOffCenterFrustum(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  /**\n   * Defines the left clipping plane.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.left = options.left;\n  this._left = undefined;\n\n  /**\n   * Defines the right clipping plane.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.right = options.right;\n  this._right = undefined;\n\n  /**\n   * Defines the top clipping plane.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.top = options.top;\n  this._top = undefined;\n\n  /**\n   * Defines the bottom clipping plane.\n   * @type {number|undefined}\n   * @default undefined\n   */\n  this.bottom = options.bottom;\n  this._bottom = undefined;\n\n  /**\n   * The distance of the near plane.\n   * @type {number}\n   * @default 1.0\n   */\n  this.near = options.near ?? 1.0;\n  this._near = this.near;\n\n  /**\n   * The distance of the far plane.\n   * @type {number}\n   * @default 500000000.0\n   */\n  this.far = options.far ?? 500000000.0;\n  this._far = this.far;\n\n  this._cullingVolume = new CullingVolume();\n  this._perspectiveMatrix = new Matrix4();\n  this._infinitePerspective = new Matrix4();\n}\n\nfunction update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(frustum.right) ||\n    !defined(frustum.left) ||\n    !defined(frustum.top) ||\n    !defined(frustum.bottom) ||\n    !defined(frustum.near) ||\n    !defined(frustum.far)\n  ) {\n    throw new DeveloperError(\n      \"right, left, top, bottom, near, or far parameters are not set.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const { top, bottom, right, left, near, far } = frustum;\n\n  const changed =\n    top !== frustum._top ||\n    bottom !== frustum._bottom ||\n    left !== frustum._left ||\n    right !== frustum._right ||\n    near !== frustum._near ||\n    far !== frustum._far;\n  if (!changed) {\n    return;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (frustum.near <= 0 || frustum.near > frustum.far) {\n    throw new DeveloperError(\n      \"near must be greater than zero and less than far.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  frustum._left = left;\n  frustum._right = right;\n  frustum._top = top;\n  frustum._bottom = bottom;\n  frustum._near = near;\n  frustum._far = far;\n  frustum._perspectiveMatrix = Matrix4.computePerspectiveOffCenter(\n    left,\n    right,\n    bottom,\n    top,\n    near,\n    far,\n    frustum._perspectiveMatrix,\n  );\n  frustum._infinitePerspective = Matrix4.computeInfinitePerspectiveOffCenter(\n    left,\n    right,\n    bottom,\n    top,\n    near,\n    frustum._infinitePerspective,\n  );\n}\n\nObject.defineProperties(PerspectiveOffCenterFrustum.prototype, {\n  /**\n   * Gets the perspective projection matrix computed from the view frustum.\n   * The projection matrix will be recomputed if any frustum parameters have changed.\n   *\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix\n   */\n  projectionMatrix: {\n    get: function () {\n      update(this);\n      return this._perspectiveMatrix;\n    },\n  },\n\n  /**\n   * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveOffCenterFrustum#projectionMatrix\n   */\n  infiniteProjectionMatrix: {\n    get: function () {\n      update(this);\n      return this._infinitePerspective;\n    },\n  },\n});\n\nconst getPlanesRight = new Cartesian3();\nconst getPlanesNearCenter = new Cartesian3();\nconst getPlanesFarCenter = new Cartesian3();\nconst getPlanesNormal = new Cartesian3();\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);\n */\nPerspectiveOffCenterFrustum.prototype.computeCullingVolume = function (\n  position,\n  direction,\n  up,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n\n  if (!defined(up)) {\n    throw new DeveloperError(\"up is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const planes = this._cullingVolume.planes;\n\n  const t = this.top;\n  const b = this.bottom;\n  const r = this.right;\n  const l = this.left;\n  const n = this.near;\n  const f = this.far;\n\n  const right = Cartesian3.cross(direction, up, getPlanesRight);\n\n  const nearCenter = getPlanesNearCenter;\n  Cartesian3.multiplyByScalar(direction, n, nearCenter);\n  Cartesian3.add(position, nearCenter, nearCenter);\n\n  const farCenter = getPlanesFarCenter;\n  Cartesian3.multiplyByScalar(direction, f, farCenter);\n  Cartesian3.add(position, farCenter, farCenter);\n\n  const normal = getPlanesNormal;\n\n  //Left plane computation\n  Cartesian3.multiplyByScalar(right, l, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.normalize(normal, normal);\n  Cartesian3.cross(normal, up, normal);\n  Cartesian3.normalize(normal, normal);\n\n  let plane = planes[0];\n  if (!defined(plane)) {\n    plane = planes[0] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Right plane computation\n  Cartesian3.multiplyByScalar(right, r, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.cross(up, normal, normal);\n  Cartesian3.normalize(normal, normal);\n\n  plane = planes[1];\n  if (!defined(plane)) {\n    plane = planes[1] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Bottom plane computation\n  Cartesian3.multiplyByScalar(up, b, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.cross(right, normal, normal);\n  Cartesian3.normalize(normal, normal);\n\n  plane = planes[2];\n  if (!defined(plane)) {\n    plane = planes[2] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Top plane computation\n  Cartesian3.multiplyByScalar(up, t, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.cross(normal, right, normal);\n  Cartesian3.normalize(normal, normal);\n\n  plane = planes[3];\n  if (!defined(plane)) {\n    plane = planes[3] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Near plane computation\n  plane = planes[4];\n  if (!defined(plane)) {\n    plane = planes[4] = new Cartesian4();\n  }\n  plane.x = direction.x;\n  plane.y = direction.y;\n  plane.z = direction.z;\n  plane.w = -Cartesian3.dot(direction, nearCenter);\n\n  //Far plane computation\n  Cartesian3.negate(direction, normal);\n\n  plane = planes[5];\n  if (!defined(plane)) {\n    plane = planes[5] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, farCenter);\n\n  return this._cullingVolume;\n};\n\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {number} drawingBufferWidth The width of the drawing buffer.\n * @param {number} drawingBufferHeight The height of the drawing buffer.\n * @param {number} distance The distance to the near plane in meters.\n * @param {number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\n *\n * @example\n * // Example 2\n * // Get the width and height of a pixel if the near plane was set to 'distance'.\n * // For example, get the size of a pixel of an image on a billboard.\n * const position = camera.position;\n * const direction = camera.direction;\n * const toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive\n * const toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector\n * const distance = Cesium.Cartesian3.magnitude(toCenterProj);\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());\n */\nPerspectiveOffCenterFrustum.prototype.getPixelDimensions = function (\n  drawingBufferWidth,\n  drawingBufferHeight,\n  distance,\n  pixelRatio,\n  result,\n) {\n  update(this);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(drawingBufferWidth) || !defined(drawingBufferHeight)) {\n    throw new DeveloperError(\n      \"Both drawingBufferWidth and drawingBufferHeight are required.\",\n    );\n  }\n  if (drawingBufferWidth <= 0) {\n    throw new DeveloperError(\"drawingBufferWidth must be greater than zero.\");\n  }\n  if (drawingBufferHeight <= 0) {\n    throw new DeveloperError(\"drawingBufferHeight must be greater than zero.\");\n  }\n  if (!defined(distance)) {\n    throw new DeveloperError(\"distance is required.\");\n  }\n  if (!defined(pixelRatio)) {\n    throw new DeveloperError(\"pixelRatio is required\");\n  }\n  if (pixelRatio <= 0) {\n    throw new DeveloperError(\"pixelRatio must be greater than zero.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"A result object is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const inverseNear = 1.0 / this.near;\n  let tanTheta = this.top * inverseNear;\n  const pixelHeight =\n    (2.0 * pixelRatio * distance * tanTheta) / drawingBufferHeight;\n  tanTheta = this.right * inverseNear;\n  const pixelWidth =\n    (2.0 * pixelRatio * distance * tanTheta) / drawingBufferWidth;\n\n  result.x = pixelWidth;\n  result.y = pixelHeight;\n  return result;\n};\n\n/**\n * Returns a duplicate of a PerspectiveOffCenterFrustum instance.\n *\n * @param {PerspectiveOffCenterFrustum} [result] The object onto which to store the result.\n * @returns {PerspectiveOffCenterFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\n */\nPerspectiveOffCenterFrustum.prototype.clone = function (result) {\n  if (!defined(result)) {\n    result = new PerspectiveOffCenterFrustum();\n  }\n\n  result.right = this.right;\n  result.left = this.left;\n  result.top = this.top;\n  result.bottom = this.bottom;\n  result.near = this.near;\n  result.far = this.far;\n\n  // force update of clone to compute matrices\n  result._left = undefined;\n  result._right = undefined;\n  result._top = undefined;\n  result._bottom = undefined;\n  result._near = undefined;\n  result._far = undefined;\n\n  return result;\n};\n\n/**\n * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {PerspectiveOffCenterFrustum} [other] The right hand side PerspectiveOffCenterFrustum.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nPerspectiveOffCenterFrustum.prototype.equals = function (other) {\n  return (\n    defined(other) &&\n    other instanceof PerspectiveOffCenterFrustum &&\n    this.right === other.right &&\n    this.left === other.left &&\n    this.top === other.top &&\n    this.bottom === other.bottom &&\n    this.near === other.near &&\n    this.far === other.far\n  );\n};\n\n/**\n * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {PerspectiveOffCenterFrustum} other The right hand side PerspectiveOffCenterFrustum.\n * @param {number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\nPerspectiveOffCenterFrustum.prototype.equalsEpsilon = function (\n  other,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  return (\n    other === this ||\n    (defined(other) &&\n      other instanceof PerspectiveOffCenterFrustum &&\n      CesiumMath.equalsEpsilon(\n        this.right,\n        other.right,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.left,\n        other.left,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.top,\n        other.top,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.bottom,\n        other.bottom,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.near,\n        other.near,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.far,\n        other.far,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ))\n  );\n};\nexport default PerspectiveOffCenterFrustum;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}