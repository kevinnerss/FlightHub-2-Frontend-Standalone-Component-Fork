{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport TerrainQuantization from \"../Core/TerrainQuantization.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport getClippingFunction from \"./getClippingFunction.js\";\nimport SceneMode from \"./SceneMode.js\";\nfunction GlobeSurfaceShader(numberOfDayTextures, flags, material, shaderProgram, clippingShaderState, clippingPolygonShaderState) {\n  this.numberOfDayTextures = numberOfDayTextures;\n  this.flags = flags;\n  this.material = material;\n  this.shaderProgram = shaderProgram;\n  this.clippingShaderState = clippingShaderState;\n  this.clippingPolygonShaderState = clippingPolygonShaderState;\n}\n\n/**\n * Manages the shaders used to shade the surface of a {@link Globe}.\n *\n * @alias GlobeSurfaceShaderSet\n * @private\n */\nfunction GlobeSurfaceShaderSet() {\n  this.baseVertexShaderSource = undefined;\n  this.baseFragmentShaderSource = undefined;\n  this._shadersByTexturesFlags = [];\n  this.material = undefined;\n}\nfunction getPositionMode(sceneMode) {\n  const getPosition3DMode = \"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPosition3DMode(position, height, textureCoordinates); }\";\n  const getPositionColumbusViewAnd2DMode = \"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPositionColumbusViewMode(position, height, textureCoordinates); }\";\n  const getPositionMorphingMode = \"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPositionMorphingMode(position, height, textureCoordinates); }\";\n  let positionMode;\n  switch (sceneMode) {\n    case SceneMode.SCENE3D:\n      positionMode = getPosition3DMode;\n      break;\n    case SceneMode.SCENE2D:\n    case SceneMode.COLUMBUS_VIEW:\n      positionMode = getPositionColumbusViewAnd2DMode;\n      break;\n    case SceneMode.MORPHING:\n      positionMode = getPositionMorphingMode;\n      break;\n  }\n  return positionMode;\n}\nfunction getPolygonClippingFunction(context) {\n  // return a noop for webgl1\n  if (!context.webgl2) {\n    return `void clipPolygons(highp sampler2D clippingDistance, int regionsLength, vec2 clippingPosition, int regionIndex) {\n    }`;\n  }\n  return `void clipPolygons(highp sampler2D clippingDistance, int regionsLength, vec2 clippingPosition, int regionIndex) {\n    czm_clipPolygons(clippingDistance, regionsLength, clippingPosition, regionIndex);\n  }`;\n}\nfunction getUnpackClippingFunction(context) {\n  // return a noop for webgl1\n  if (!context.webgl2) {\n    return `vec4 unpackClippingExtents(highp sampler2D extentsTexture, int index) {\n      return vec4();\n    }`;\n  }\n  return `vec4 unpackClippingExtents(highp sampler2D extentsTexture, int index) {\n    return czm_unpackClippingExtents(extentsTexture, index);\n  }`;\n}\nfunction get2DYPositionFraction(useWebMercatorProjection) {\n  const get2DYPositionFractionGeographicProjection = \"float get2DYPositionFraction(vec2 textureCoordinates) { return get2DGeographicYPositionFraction(textureCoordinates); }\";\n  const get2DYPositionFractionMercatorProjection = \"float get2DYPositionFraction(vec2 textureCoordinates) { return get2DMercatorYPositionFraction(textureCoordinates); }\";\n  return useWebMercatorProjection ? get2DYPositionFractionMercatorProjection : get2DYPositionFractionGeographicProjection;\n}\nGlobeSurfaceShaderSet.prototype.getShaderProgram = function (options) {\n  const frameState = options.frameState;\n  const surfaceTile = options.surfaceTile;\n  const numberOfDayTextures = options.numberOfDayTextures;\n  const applyBrightness = options.applyBrightness;\n  const applyContrast = options.applyContrast;\n  const applyHue = options.applyHue;\n  const applySaturation = options.applySaturation;\n  const applyGamma = options.applyGamma;\n  const applyAlpha = options.applyAlpha;\n  const applyDayNightAlpha = options.applyDayNightAlpha;\n  const applySplit = options.applySplit;\n  const hasWaterMask = options.hasWaterMask;\n  const showReflectiveOcean = options.showReflectiveOcean;\n  const showOceanWaves = options.showOceanWaves;\n  const enableLighting = options.enableLighting;\n  const dynamicAtmosphereLighting = options.dynamicAtmosphereLighting;\n  const dynamicAtmosphereLightingFromSun = options.dynamicAtmosphereLightingFromSun;\n  const showGroundAtmosphere = options.showGroundAtmosphere;\n  const perFragmentGroundAtmosphere = options.perFragmentGroundAtmosphere;\n  const hasVertexNormals = options.hasVertexNormals;\n  const useWebMercatorProjection = options.useWebMercatorProjection;\n  const enableFog = options.enableFog;\n  const enableClippingPlanes = options.enableClippingPlanes;\n  const clippingPlanes = options.clippingPlanes;\n  const enableClippingPolygons = options.enableClippingPolygons;\n  const clippingPolygons = options.clippingPolygons;\n  const clippedByBoundaries = options.clippedByBoundaries;\n  const hasImageryLayerCutout = options.hasImageryLayerCutout;\n  const colorCorrect = options.colorCorrect;\n  const highlightFillTile = options.highlightFillTile;\n  const colorToAlpha = options.colorToAlpha;\n  const hasGeodeticSurfaceNormals = options.hasGeodeticSurfaceNormals;\n  const hasExaggeration = options.hasExaggeration;\n  const showUndergroundColor = options.showUndergroundColor;\n  const translucent = options.translucent;\n  let quantization = 0;\n  let quantizationDefine = \"\";\n  const mesh = surfaceTile.renderedMesh;\n  const terrainEncoding = mesh.encoding;\n  const quantizationMode = terrainEncoding.quantization;\n  if (quantizationMode === TerrainQuantization.BITS12) {\n    quantization = 1;\n    quantizationDefine = \"QUANTIZATION_BITS12\";\n  }\n  let cartographicLimitRectangleFlag = 0;\n  let cartographicLimitRectangleDefine = \"\";\n  if (clippedByBoundaries) {\n    cartographicLimitRectangleFlag = 1;\n    cartographicLimitRectangleDefine = \"TILE_LIMIT_RECTANGLE\";\n  }\n  let imageryCutoutFlag = 0;\n  let imageryCutoutDefine = \"\";\n  if (hasImageryLayerCutout) {\n    imageryCutoutFlag = 1;\n    imageryCutoutDefine = \"APPLY_IMAGERY_CUTOUT\";\n  }\n  const sceneMode = frameState.mode;\n  const flags = sceneMode | applyBrightness << 2 | applyContrast << 3 | applyHue << 4 | applySaturation << 5 | applyGamma << 6 | applyAlpha << 7 | hasWaterMask << 8 | showReflectiveOcean << 9 | showOceanWaves << 10 | enableLighting << 11 | dynamicAtmosphereLighting << 12 | dynamicAtmosphereLightingFromSun << 13 | showGroundAtmosphere << 14 | perFragmentGroundAtmosphere << 15 | hasVertexNormals << 16 | useWebMercatorProjection << 17 | enableFog << 18 | quantization << 19 | applySplit << 20 | enableClippingPlanes << 21 | enableClippingPolygons << 22 | cartographicLimitRectangleFlag << 23 | imageryCutoutFlag << 24 | colorCorrect << 25 | highlightFillTile << 26 | colorToAlpha << 27 | hasGeodeticSurfaceNormals << 28 | hasExaggeration << 29 | showUndergroundColor << 30 | translucent << 31 | applyDayNightAlpha << 32;\n  let currentClippingShaderState = 0;\n  if (defined(clippingPlanes) && clippingPlanes.length > 0) {\n    currentClippingShaderState = enableClippingPlanes ? clippingPlanes.clippingPlanesState : 0;\n  }\n  let currentClippingPolygonsShaderState = 0;\n  if (defined(clippingPolygons) && clippingPolygons.length > 0) {\n    currentClippingPolygonsShaderState = enableClippingPolygons ? clippingPolygons.clippingPolygonsState : 0;\n  }\n  let surfaceShader = surfaceTile.surfaceShader;\n  if (defined(surfaceShader) && surfaceShader.numberOfDayTextures === numberOfDayTextures && surfaceShader.flags === flags && surfaceShader.material === this.material && surfaceShader.clippingShaderState === currentClippingShaderState && surfaceShader.clippingPolygonShaderState === currentClippingPolygonsShaderState) {\n    return surfaceShader.shaderProgram;\n  }\n\n  // New tile, or tile changed number of textures, flags, or clipping planes\n  let shadersByFlags = this._shadersByTexturesFlags[numberOfDayTextures];\n  if (!defined(shadersByFlags)) {\n    shadersByFlags = this._shadersByTexturesFlags[numberOfDayTextures] = [];\n  }\n  surfaceShader = shadersByFlags[flags];\n  if (!defined(surfaceShader) || surfaceShader.material !== this.material || surfaceShader.clippingShaderState !== currentClippingShaderState || surfaceShader.clippingPolygonShaderState !== currentClippingPolygonsShaderState) {\n    // Cache miss - we've never seen this combination of numberOfDayTextures and flags before.\n    const vs = this.baseVertexShaderSource.clone();\n    const fs = this.baseFragmentShaderSource.clone();\n\n    // Need to go before GlobeFS\n    if (currentClippingShaderState !== 0) {\n      fs.sources.unshift(getClippingFunction(clippingPlanes, frameState.context));\n    }\n\n    // Need to go before GlobeFS\n    if (currentClippingPolygonsShaderState !== 0) {\n      fs.sources.unshift(getPolygonClippingFunction(frameState.context));\n      vs.sources.unshift(getUnpackClippingFunction(frameState.context));\n    }\n    vs.defines.push(quantizationDefine);\n    fs.defines.push(`TEXTURE_UNITS ${numberOfDayTextures}`, cartographicLimitRectangleDefine, imageryCutoutDefine);\n    if (applyBrightness) {\n      fs.defines.push(\"APPLY_BRIGHTNESS\");\n    }\n    if (applyContrast) {\n      fs.defines.push(\"APPLY_CONTRAST\");\n    }\n    if (applyHue) {\n      fs.defines.push(\"APPLY_HUE\");\n    }\n    if (applySaturation) {\n      fs.defines.push(\"APPLY_SATURATION\");\n    }\n    if (applyGamma) {\n      fs.defines.push(\"APPLY_GAMMA\");\n    }\n    if (applyAlpha) {\n      fs.defines.push(\"APPLY_ALPHA\");\n    }\n    if (applyDayNightAlpha) {\n      fs.defines.push(\"APPLY_DAY_NIGHT_ALPHA\");\n    }\n    if (hasWaterMask) {\n      fs.defines.push(\"HAS_WATER_MASK\");\n    }\n    if (showReflectiveOcean) {\n      fs.defines.push(\"SHOW_REFLECTIVE_OCEAN\");\n      vs.defines.push(\"SHOW_REFLECTIVE_OCEAN\");\n    }\n    if (showOceanWaves) {\n      fs.defines.push(\"SHOW_OCEAN_WAVES\");\n    }\n    if (colorToAlpha) {\n      fs.defines.push(\"APPLY_COLOR_TO_ALPHA\");\n    }\n    if (showUndergroundColor) {\n      vs.defines.push(\"UNDERGROUND_COLOR\");\n      fs.defines.push(\"UNDERGROUND_COLOR\");\n    }\n    if (translucent) {\n      vs.defines.push(\"TRANSLUCENT\");\n      fs.defines.push(\"TRANSLUCENT\");\n    }\n    if (enableLighting) {\n      if (hasVertexNormals) {\n        vs.defines.push(\"ENABLE_VERTEX_LIGHTING\");\n        fs.defines.push(\"ENABLE_VERTEX_LIGHTING\");\n      } else {\n        vs.defines.push(\"ENABLE_DAYNIGHT_SHADING\");\n        fs.defines.push(\"ENABLE_DAYNIGHT_SHADING\");\n      }\n    }\n    if (dynamicAtmosphereLighting) {\n      vs.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING\");\n      fs.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING\");\n      if (dynamicAtmosphereLightingFromSun) {\n        vs.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN\");\n        fs.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN\");\n      }\n    }\n    if (showGroundAtmosphere) {\n      vs.defines.push(\"GROUND_ATMOSPHERE\");\n      fs.defines.push(\"GROUND_ATMOSPHERE\");\n      if (perFragmentGroundAtmosphere) {\n        vs.defines.push(\"PER_FRAGMENT_GROUND_ATMOSPHERE\");\n        fs.defines.push(\"PER_FRAGMENT_GROUND_ATMOSPHERE\");\n      }\n    }\n    vs.defines.push(\"INCLUDE_WEB_MERCATOR_Y\");\n    fs.defines.push(\"INCLUDE_WEB_MERCATOR_Y\");\n    if (enableFog) {\n      vs.defines.push(\"FOG\");\n      fs.defines.push(\"FOG\");\n    }\n    if (applySplit) {\n      fs.defines.push(\"APPLY_SPLIT\");\n    }\n    if (enableClippingPlanes) {\n      fs.defines.push(\"ENABLE_CLIPPING_PLANES\");\n    }\n    if (enableClippingPolygons) {\n      fs.defines.push(\"ENABLE_CLIPPING_POLYGONS\");\n      vs.defines.push(\"ENABLE_CLIPPING_POLYGONS\");\n      if (clippingPolygons.inverse) {\n        fs.defines.push(\"CLIPPING_INVERSE\");\n      }\n      fs.defines.push(`CLIPPING_POLYGON_REGIONS_LENGTH ${clippingPolygons.extentsCount}`);\n      vs.defines.push(`CLIPPING_POLYGON_REGIONS_LENGTH ${clippingPolygons.extentsCount}`);\n    }\n    if (colorCorrect) {\n      fs.defines.push(\"COLOR_CORRECT\");\n    }\n    if (highlightFillTile) {\n      fs.defines.push(\"HIGHLIGHT_FILL_TILE\");\n    }\n    if (hasGeodeticSurfaceNormals) {\n      vs.defines.push(\"GEODETIC_SURFACE_NORMALS\");\n    }\n    if (hasExaggeration) {\n      vs.defines.push(\"EXAGGERATION\");\n    }\n    let computeDayColor = \"\\\n    vec4 computeDayColor(vec4 initialColor, vec3 textureCoordinates, float nightBlend)\\n\\\n    {\\n\\\n        vec4 color = initialColor;\\n\";\n    if (hasImageryLayerCutout) {\n      computeDayColor += \"\\\n        vec4 cutoutAndColorResult;\\n\\\n        bool texelUnclipped;\\n\";\n    }\n    for (let i = 0; i < numberOfDayTextures; ++i) {\n      if (hasImageryLayerCutout) {\n        computeDayColor += `\\\n        cutoutAndColorResult = u_dayTextureCutoutRectangles[${i}];\\n\\\n        texelUnclipped = v_textureCoordinates.x < cutoutAndColorResult.x || cutoutAndColorResult.z < v_textureCoordinates.x || v_textureCoordinates.y < cutoutAndColorResult.y || cutoutAndColorResult.w < v_textureCoordinates.y;\\n\\\n        cutoutAndColorResult = sampleAndBlend(\\n`;\n      } else {\n        computeDayColor += \"\\\n        color = sampleAndBlend(\\n\";\n      }\n      computeDayColor += `\\\n            color,\\n\\\n            u_dayTextures[${i}],\\n\\\n            u_dayTextureUseWebMercatorT[${i}] ? textureCoordinates.xz : textureCoordinates.xy,\\n\\\n            u_dayTextureTexCoordsRectangle[${i}],\\n\\\n            u_dayTextureTranslationAndScale[${i}],\\n\\\n            ${applyAlpha ? `u_dayTextureAlpha[${i}]` : \"1.0\"},\\n\\\n            ${applyDayNightAlpha ? `u_dayTextureNightAlpha[${i}]` : \"1.0\"},\\n\\\n            ${applyDayNightAlpha ? `u_dayTextureDayAlpha[${i}]` : \"1.0\"},\\n\\\n            ${applyBrightness ? `u_dayTextureBrightness[${i}]` : \"0.0\"},\\n\\\n            ${applyContrast ? `u_dayTextureContrast[${i}]` : \"0.0\"},\\n\\\n            ${applyHue ? `u_dayTextureHue[${i}]` : \"0.0\"},\\n\\\n            ${applySaturation ? `u_dayTextureSaturation[${i}]` : \"0.0\"},\\n\\\n            ${applyGamma ? `u_dayTextureOneOverGamma[${i}]` : \"0.0\"},\\n\\\n            ${applySplit ? `u_dayTextureSplit[${i}]` : \"0.0\"},\\n\\\n            ${colorToAlpha ? `u_colorsToAlpha[${i}]` : \"vec4(0.0)\"},\\n\\\n            nightBlend\\);\\n`;\n      if (hasImageryLayerCutout) {\n        computeDayColor += \"\\\n        color = czm_branchFreeTernary(texelUnclipped, cutoutAndColorResult, color);\\n\";\n      }\n    }\n    computeDayColor += \"\\\n        return color;\\n\\\n    }\";\n    fs.sources.push(computeDayColor);\n    vs.sources.push(getPositionMode(sceneMode));\n    vs.sources.push(get2DYPositionFraction(useWebMercatorProjection));\n    const shader = ShaderProgram.fromCache({\n      context: frameState.context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: terrainEncoding.getAttributeLocations()\n    });\n    surfaceShader = shadersByFlags[flags] = new GlobeSurfaceShader(numberOfDayTextures, flags, this.material, shader, currentClippingShaderState, currentClippingPolygonsShaderState);\n  }\n  surfaceTile.surfaceShader = surfaceShader;\n  return surfaceShader.shaderProgram;\n};\nGlobeSurfaceShaderSet.prototype.destroy = function () {\n  let flags;\n  let shader;\n  const shadersByTexturesFlags = this._shadersByTexturesFlags;\n  for (const textureCount in shadersByTexturesFlags) {\n    if (shadersByTexturesFlags.hasOwnProperty(textureCount)) {\n      const shadersByFlags = shadersByTexturesFlags[textureCount];\n      if (!defined(shadersByFlags)) {\n        continue;\n      }\n      for (flags in shadersByFlags) {\n        if (shadersByFlags.hasOwnProperty(flags)) {\n          shader = shadersByFlags[flags];\n          if (defined(shader)) {\n            shader.shaderProgram.destroy();\n          }\n        }\n      }\n    }\n  }\n  return destroyObject(this);\n};\nexport default GlobeSurfaceShaderSet;","map":{"version":3,"names":["defined","destroyObject","TerrainQuantization","ShaderProgram","getClippingFunction","SceneMode","GlobeSurfaceShader","numberOfDayTextures","flags","material","shaderProgram","clippingShaderState","clippingPolygonShaderState","GlobeSurfaceShaderSet","baseVertexShaderSource","undefined","baseFragmentShaderSource","_shadersByTexturesFlags","getPositionMode","sceneMode","getPosition3DMode","getPositionColumbusViewAnd2DMode","getPositionMorphingMode","positionMode","SCENE3D","SCENE2D","COLUMBUS_VIEW","MORPHING","getPolygonClippingFunction","context","webgl2","getUnpackClippingFunction","get2DYPositionFraction","useWebMercatorProjection","get2DYPositionFractionGeographicProjection","get2DYPositionFractionMercatorProjection","prototype","getShaderProgram","options","frameState","surfaceTile","applyBrightness","applyContrast","applyHue","applySaturation","applyGamma","applyAlpha","applyDayNightAlpha","applySplit","hasWaterMask","showReflectiveOcean","showOceanWaves","enableLighting","dynamicAtmosphereLighting","dynamicAtmosphereLightingFromSun","showGroundAtmosphere","perFragmentGroundAtmosphere","hasVertexNormals","enableFog","enableClippingPlanes","clippingPlanes","enableClippingPolygons","clippingPolygons","clippedByBoundaries","hasImageryLayerCutout","colorCorrect","highlightFillTile","colorToAlpha","hasGeodeticSurfaceNormals","hasExaggeration","showUndergroundColor","translucent","quantization","quantizationDefine","mesh","renderedMesh","terrainEncoding","encoding","quantizationMode","BITS12","cartographicLimitRectangleFlag","cartographicLimitRectangleDefine","imageryCutoutFlag","imageryCutoutDefine","mode","currentClippingShaderState","length","clippingPlanesState","currentClippingPolygonsShaderState","clippingPolygonsState","surfaceShader","shadersByFlags","vs","clone","fs","sources","unshift","defines","push","inverse","extentsCount","computeDayColor","i","shader","fromCache","vertexShaderSource","fragmentShaderSource","attributeLocations","getAttributeLocations","destroy","shadersByTexturesFlags","textureCount","hasOwnProperty"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/GlobeSurfaceShaderSet.js"],"sourcesContent":["import defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport TerrainQuantization from \"../Core/TerrainQuantization.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport getClippingFunction from \"./getClippingFunction.js\";\nimport SceneMode from \"./SceneMode.js\";\n\nfunction GlobeSurfaceShader(\n  numberOfDayTextures,\n  flags,\n  material,\n  shaderProgram,\n  clippingShaderState,\n  clippingPolygonShaderState,\n) {\n  this.numberOfDayTextures = numberOfDayTextures;\n  this.flags = flags;\n  this.material = material;\n  this.shaderProgram = shaderProgram;\n  this.clippingShaderState = clippingShaderState;\n  this.clippingPolygonShaderState = clippingPolygonShaderState;\n}\n\n/**\n * Manages the shaders used to shade the surface of a {@link Globe}.\n *\n * @alias GlobeSurfaceShaderSet\n * @private\n */\nfunction GlobeSurfaceShaderSet() {\n  this.baseVertexShaderSource = undefined;\n  this.baseFragmentShaderSource = undefined;\n\n  this._shadersByTexturesFlags = [];\n\n  this.material = undefined;\n}\n\nfunction getPositionMode(sceneMode) {\n  const getPosition3DMode =\n    \"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPosition3DMode(position, height, textureCoordinates); }\";\n  const getPositionColumbusViewAnd2DMode =\n    \"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPositionColumbusViewMode(position, height, textureCoordinates); }\";\n  const getPositionMorphingMode =\n    \"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPositionMorphingMode(position, height, textureCoordinates); }\";\n\n  let positionMode;\n\n  switch (sceneMode) {\n    case SceneMode.SCENE3D:\n      positionMode = getPosition3DMode;\n      break;\n    case SceneMode.SCENE2D:\n    case SceneMode.COLUMBUS_VIEW:\n      positionMode = getPositionColumbusViewAnd2DMode;\n      break;\n    case SceneMode.MORPHING:\n      positionMode = getPositionMorphingMode;\n      break;\n  }\n\n  return positionMode;\n}\n\nfunction getPolygonClippingFunction(context) {\n  // return a noop for webgl1\n  if (!context.webgl2) {\n    return `void clipPolygons(highp sampler2D clippingDistance, int regionsLength, vec2 clippingPosition, int regionIndex) {\n    }`;\n  }\n\n  return `void clipPolygons(highp sampler2D clippingDistance, int regionsLength, vec2 clippingPosition, int regionIndex) {\n    czm_clipPolygons(clippingDistance, regionsLength, clippingPosition, regionIndex);\n  }`;\n}\n\nfunction getUnpackClippingFunction(context) {\n  // return a noop for webgl1\n  if (!context.webgl2) {\n    return `vec4 unpackClippingExtents(highp sampler2D extentsTexture, int index) {\n      return vec4();\n    }`;\n  }\n\n  return `vec4 unpackClippingExtents(highp sampler2D extentsTexture, int index) {\n    return czm_unpackClippingExtents(extentsTexture, index);\n  }`;\n}\n\nfunction get2DYPositionFraction(useWebMercatorProjection) {\n  const get2DYPositionFractionGeographicProjection =\n    \"float get2DYPositionFraction(vec2 textureCoordinates) { return get2DGeographicYPositionFraction(textureCoordinates); }\";\n  const get2DYPositionFractionMercatorProjection =\n    \"float get2DYPositionFraction(vec2 textureCoordinates) { return get2DMercatorYPositionFraction(textureCoordinates); }\";\n  return useWebMercatorProjection\n    ? get2DYPositionFractionMercatorProjection\n    : get2DYPositionFractionGeographicProjection;\n}\n\nGlobeSurfaceShaderSet.prototype.getShaderProgram = function (options) {\n  const frameState = options.frameState;\n  const surfaceTile = options.surfaceTile;\n  const numberOfDayTextures = options.numberOfDayTextures;\n  const applyBrightness = options.applyBrightness;\n  const applyContrast = options.applyContrast;\n  const applyHue = options.applyHue;\n  const applySaturation = options.applySaturation;\n  const applyGamma = options.applyGamma;\n  const applyAlpha = options.applyAlpha;\n  const applyDayNightAlpha = options.applyDayNightAlpha;\n  const applySplit = options.applySplit;\n  const hasWaterMask = options.hasWaterMask;\n  const showReflectiveOcean = options.showReflectiveOcean;\n  const showOceanWaves = options.showOceanWaves;\n  const enableLighting = options.enableLighting;\n  const dynamicAtmosphereLighting = options.dynamicAtmosphereLighting;\n  const dynamicAtmosphereLightingFromSun =\n    options.dynamicAtmosphereLightingFromSun;\n  const showGroundAtmosphere = options.showGroundAtmosphere;\n  const perFragmentGroundAtmosphere = options.perFragmentGroundAtmosphere;\n  const hasVertexNormals = options.hasVertexNormals;\n  const useWebMercatorProjection = options.useWebMercatorProjection;\n  const enableFog = options.enableFog;\n  const enableClippingPlanes = options.enableClippingPlanes;\n  const clippingPlanes = options.clippingPlanes;\n  const enableClippingPolygons = options.enableClippingPolygons;\n  const clippingPolygons = options.clippingPolygons;\n  const clippedByBoundaries = options.clippedByBoundaries;\n  const hasImageryLayerCutout = options.hasImageryLayerCutout;\n  const colorCorrect = options.colorCorrect;\n  const highlightFillTile = options.highlightFillTile;\n  const colorToAlpha = options.colorToAlpha;\n  const hasGeodeticSurfaceNormals = options.hasGeodeticSurfaceNormals;\n  const hasExaggeration = options.hasExaggeration;\n  const showUndergroundColor = options.showUndergroundColor;\n  const translucent = options.translucent;\n\n  let quantization = 0;\n  let quantizationDefine = \"\";\n\n  const mesh = surfaceTile.renderedMesh;\n  const terrainEncoding = mesh.encoding;\n  const quantizationMode = terrainEncoding.quantization;\n  if (quantizationMode === TerrainQuantization.BITS12) {\n    quantization = 1;\n    quantizationDefine = \"QUANTIZATION_BITS12\";\n  }\n\n  let cartographicLimitRectangleFlag = 0;\n  let cartographicLimitRectangleDefine = \"\";\n  if (clippedByBoundaries) {\n    cartographicLimitRectangleFlag = 1;\n    cartographicLimitRectangleDefine = \"TILE_LIMIT_RECTANGLE\";\n  }\n\n  let imageryCutoutFlag = 0;\n  let imageryCutoutDefine = \"\";\n  if (hasImageryLayerCutout) {\n    imageryCutoutFlag = 1;\n    imageryCutoutDefine = \"APPLY_IMAGERY_CUTOUT\";\n  }\n\n  const sceneMode = frameState.mode;\n  const flags =\n    sceneMode |\n    (applyBrightness << 2) |\n    (applyContrast << 3) |\n    (applyHue << 4) |\n    (applySaturation << 5) |\n    (applyGamma << 6) |\n    (applyAlpha << 7) |\n    (hasWaterMask << 8) |\n    (showReflectiveOcean << 9) |\n    (showOceanWaves << 10) |\n    (enableLighting << 11) |\n    (dynamicAtmosphereLighting << 12) |\n    (dynamicAtmosphereLightingFromSun << 13) |\n    (showGroundAtmosphere << 14) |\n    (perFragmentGroundAtmosphere << 15) |\n    (hasVertexNormals << 16) |\n    (useWebMercatorProjection << 17) |\n    (enableFog << 18) |\n    (quantization << 19) |\n    (applySplit << 20) |\n    (enableClippingPlanes << 21) |\n    (enableClippingPolygons << 22) |\n    (cartographicLimitRectangleFlag << 23) |\n    (imageryCutoutFlag << 24) |\n    (colorCorrect << 25) |\n    (highlightFillTile << 26) |\n    (colorToAlpha << 27) |\n    (hasGeodeticSurfaceNormals << 28) |\n    (hasExaggeration << 29) |\n    (showUndergroundColor << 30) |\n    (translucent << 31) |\n    (applyDayNightAlpha << 32);\n\n  let currentClippingShaderState = 0;\n  if (defined(clippingPlanes) && clippingPlanes.length > 0) {\n    currentClippingShaderState = enableClippingPlanes\n      ? clippingPlanes.clippingPlanesState\n      : 0;\n  }\n\n  let currentClippingPolygonsShaderState = 0;\n  if (defined(clippingPolygons) && clippingPolygons.length > 0) {\n    currentClippingPolygonsShaderState = enableClippingPolygons\n      ? clippingPolygons.clippingPolygonsState\n      : 0;\n  }\n\n  let surfaceShader = surfaceTile.surfaceShader;\n  if (\n    defined(surfaceShader) &&\n    surfaceShader.numberOfDayTextures === numberOfDayTextures &&\n    surfaceShader.flags === flags &&\n    surfaceShader.material === this.material &&\n    surfaceShader.clippingShaderState === currentClippingShaderState &&\n    surfaceShader.clippingPolygonShaderState ===\n      currentClippingPolygonsShaderState\n  ) {\n    return surfaceShader.shaderProgram;\n  }\n\n  // New tile, or tile changed number of textures, flags, or clipping planes\n  let shadersByFlags = this._shadersByTexturesFlags[numberOfDayTextures];\n  if (!defined(shadersByFlags)) {\n    shadersByFlags = this._shadersByTexturesFlags[numberOfDayTextures] = [];\n  }\n\n  surfaceShader = shadersByFlags[flags];\n  if (\n    !defined(surfaceShader) ||\n    surfaceShader.material !== this.material ||\n    surfaceShader.clippingShaderState !== currentClippingShaderState ||\n    surfaceShader.clippingPolygonShaderState !==\n      currentClippingPolygonsShaderState\n  ) {\n    // Cache miss - we've never seen this combination of numberOfDayTextures and flags before.\n    const vs = this.baseVertexShaderSource.clone();\n    const fs = this.baseFragmentShaderSource.clone();\n\n    // Need to go before GlobeFS\n    if (currentClippingShaderState !== 0) {\n      fs.sources.unshift(\n        getClippingFunction(clippingPlanes, frameState.context),\n      );\n    }\n\n    // Need to go before GlobeFS\n    if (currentClippingPolygonsShaderState !== 0) {\n      fs.sources.unshift(getPolygonClippingFunction(frameState.context));\n      vs.sources.unshift(getUnpackClippingFunction(frameState.context));\n    }\n\n    vs.defines.push(quantizationDefine);\n    fs.defines.push(\n      `TEXTURE_UNITS ${numberOfDayTextures}`,\n      cartographicLimitRectangleDefine,\n      imageryCutoutDefine,\n    );\n\n    if (applyBrightness) {\n      fs.defines.push(\"APPLY_BRIGHTNESS\");\n    }\n    if (applyContrast) {\n      fs.defines.push(\"APPLY_CONTRAST\");\n    }\n    if (applyHue) {\n      fs.defines.push(\"APPLY_HUE\");\n    }\n    if (applySaturation) {\n      fs.defines.push(\"APPLY_SATURATION\");\n    }\n    if (applyGamma) {\n      fs.defines.push(\"APPLY_GAMMA\");\n    }\n    if (applyAlpha) {\n      fs.defines.push(\"APPLY_ALPHA\");\n    }\n    if (applyDayNightAlpha) {\n      fs.defines.push(\"APPLY_DAY_NIGHT_ALPHA\");\n    }\n    if (hasWaterMask) {\n      fs.defines.push(\"HAS_WATER_MASK\");\n    }\n    if (showReflectiveOcean) {\n      fs.defines.push(\"SHOW_REFLECTIVE_OCEAN\");\n      vs.defines.push(\"SHOW_REFLECTIVE_OCEAN\");\n    }\n    if (showOceanWaves) {\n      fs.defines.push(\"SHOW_OCEAN_WAVES\");\n    }\n    if (colorToAlpha) {\n      fs.defines.push(\"APPLY_COLOR_TO_ALPHA\");\n    }\n    if (showUndergroundColor) {\n      vs.defines.push(\"UNDERGROUND_COLOR\");\n      fs.defines.push(\"UNDERGROUND_COLOR\");\n    }\n    if (translucent) {\n      vs.defines.push(\"TRANSLUCENT\");\n      fs.defines.push(\"TRANSLUCENT\");\n    }\n    if (enableLighting) {\n      if (hasVertexNormals) {\n        vs.defines.push(\"ENABLE_VERTEX_LIGHTING\");\n        fs.defines.push(\"ENABLE_VERTEX_LIGHTING\");\n      } else {\n        vs.defines.push(\"ENABLE_DAYNIGHT_SHADING\");\n        fs.defines.push(\"ENABLE_DAYNIGHT_SHADING\");\n      }\n    }\n\n    if (dynamicAtmosphereLighting) {\n      vs.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING\");\n      fs.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING\");\n      if (dynamicAtmosphereLightingFromSun) {\n        vs.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN\");\n        fs.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN\");\n      }\n    }\n\n    if (showGroundAtmosphere) {\n      vs.defines.push(\"GROUND_ATMOSPHERE\");\n      fs.defines.push(\"GROUND_ATMOSPHERE\");\n      if (perFragmentGroundAtmosphere) {\n        vs.defines.push(\"PER_FRAGMENT_GROUND_ATMOSPHERE\");\n        fs.defines.push(\"PER_FRAGMENT_GROUND_ATMOSPHERE\");\n      }\n    }\n\n    vs.defines.push(\"INCLUDE_WEB_MERCATOR_Y\");\n    fs.defines.push(\"INCLUDE_WEB_MERCATOR_Y\");\n\n    if (enableFog) {\n      vs.defines.push(\"FOG\");\n      fs.defines.push(\"FOG\");\n    }\n\n    if (applySplit) {\n      fs.defines.push(\"APPLY_SPLIT\");\n    }\n\n    if (enableClippingPlanes) {\n      fs.defines.push(\"ENABLE_CLIPPING_PLANES\");\n    }\n\n    if (enableClippingPolygons) {\n      fs.defines.push(\"ENABLE_CLIPPING_POLYGONS\");\n      vs.defines.push(\"ENABLE_CLIPPING_POLYGONS\");\n\n      if (clippingPolygons.inverse) {\n        fs.defines.push(\"CLIPPING_INVERSE\");\n      }\n\n      fs.defines.push(\n        `CLIPPING_POLYGON_REGIONS_LENGTH ${clippingPolygons.extentsCount}`,\n      );\n      vs.defines.push(\n        `CLIPPING_POLYGON_REGIONS_LENGTH ${clippingPolygons.extentsCount}`,\n      );\n    }\n\n    if (colorCorrect) {\n      fs.defines.push(\"COLOR_CORRECT\");\n    }\n\n    if (highlightFillTile) {\n      fs.defines.push(\"HIGHLIGHT_FILL_TILE\");\n    }\n\n    if (hasGeodeticSurfaceNormals) {\n      vs.defines.push(\"GEODETIC_SURFACE_NORMALS\");\n    }\n\n    if (hasExaggeration) {\n      vs.defines.push(\"EXAGGERATION\");\n    }\n\n    let computeDayColor =\n      \"\\\n    vec4 computeDayColor(vec4 initialColor, vec3 textureCoordinates, float nightBlend)\\n\\\n    {\\n\\\n        vec4 color = initialColor;\\n\";\n\n    if (hasImageryLayerCutout) {\n      computeDayColor +=\n        \"\\\n        vec4 cutoutAndColorResult;\\n\\\n        bool texelUnclipped;\\n\";\n    }\n\n    for (let i = 0; i < numberOfDayTextures; ++i) {\n      if (hasImageryLayerCutout) {\n        computeDayColor += `\\\n        cutoutAndColorResult = u_dayTextureCutoutRectangles[${i}];\\n\\\n        texelUnclipped = v_textureCoordinates.x < cutoutAndColorResult.x || cutoutAndColorResult.z < v_textureCoordinates.x || v_textureCoordinates.y < cutoutAndColorResult.y || cutoutAndColorResult.w < v_textureCoordinates.y;\\n\\\n        cutoutAndColorResult = sampleAndBlend(\\n`;\n      } else {\n        computeDayColor +=\n          \"\\\n        color = sampleAndBlend(\\n\";\n      }\n      computeDayColor += `\\\n            color,\\n\\\n            u_dayTextures[${i}],\\n\\\n            u_dayTextureUseWebMercatorT[${i}] ? textureCoordinates.xz : textureCoordinates.xy,\\n\\\n            u_dayTextureTexCoordsRectangle[${i}],\\n\\\n            u_dayTextureTranslationAndScale[${i}],\\n\\\n            ${applyAlpha ? `u_dayTextureAlpha[${i}]` : \"1.0\"},\\n\\\n            ${applyDayNightAlpha ? `u_dayTextureNightAlpha[${i}]` : \"1.0\"},\\n\\\n            ${applyDayNightAlpha ? `u_dayTextureDayAlpha[${i}]` : \"1.0\"},\\n\\\n            ${applyBrightness ? `u_dayTextureBrightness[${i}]` : \"0.0\"},\\n\\\n            ${applyContrast ? `u_dayTextureContrast[${i}]` : \"0.0\"},\\n\\\n            ${applyHue ? `u_dayTextureHue[${i}]` : \"0.0\"},\\n\\\n            ${applySaturation ? `u_dayTextureSaturation[${i}]` : \"0.0\"},\\n\\\n            ${applyGamma ? `u_dayTextureOneOverGamma[${i}]` : \"0.0\"},\\n\\\n            ${applySplit ? `u_dayTextureSplit[${i}]` : \"0.0\"},\\n\\\n            ${colorToAlpha ? `u_colorsToAlpha[${i}]` : \"vec4(0.0)\"},\\n\\\n            nightBlend\\);\\n`;\n      if (hasImageryLayerCutout) {\n        computeDayColor +=\n          \"\\\n        color = czm_branchFreeTernary(texelUnclipped, cutoutAndColorResult, color);\\n\";\n      }\n    }\n\n    computeDayColor +=\n      \"\\\n        return color;\\n\\\n    }\";\n\n    fs.sources.push(computeDayColor);\n\n    vs.sources.push(getPositionMode(sceneMode));\n    vs.sources.push(get2DYPositionFraction(useWebMercatorProjection));\n\n    const shader = ShaderProgram.fromCache({\n      context: frameState.context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: terrainEncoding.getAttributeLocations(),\n    });\n\n    surfaceShader = shadersByFlags[flags] = new GlobeSurfaceShader(\n      numberOfDayTextures,\n      flags,\n      this.material,\n      shader,\n      currentClippingShaderState,\n      currentClippingPolygonsShaderState,\n    );\n  }\n\n  surfaceTile.surfaceShader = surfaceShader;\n  return surfaceShader.shaderProgram;\n};\n\nGlobeSurfaceShaderSet.prototype.destroy = function () {\n  let flags;\n  let shader;\n\n  const shadersByTexturesFlags = this._shadersByTexturesFlags;\n  for (const textureCount in shadersByTexturesFlags) {\n    if (shadersByTexturesFlags.hasOwnProperty(textureCount)) {\n      const shadersByFlags = shadersByTexturesFlags[textureCount];\n      if (!defined(shadersByFlags)) {\n        continue;\n      }\n\n      for (flags in shadersByFlags) {\n        if (shadersByFlags.hasOwnProperty(flags)) {\n          shader = shadersByFlags[flags];\n          if (defined(shader)) {\n            shader.shaderProgram.destroy();\n          }\n        }\n      }\n    }\n  }\n\n  return destroyObject(this);\n};\nexport default GlobeSurfaceShaderSet;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}