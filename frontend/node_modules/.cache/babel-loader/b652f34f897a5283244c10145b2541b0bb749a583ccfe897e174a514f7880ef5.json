{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport KeyboardEventModifier from \"../Core/KeyboardEventModifier.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport ScreenSpaceEventHandler from \"../Core/ScreenSpaceEventHandler.js\";\nimport ScreenSpaceEventType from \"../Core/ScreenSpaceEventType.js\";\nimport CameraEventType from \"./CameraEventType.js\";\nfunction getKey(type, modifier) {\n  let key = `${type}`;\n  if (defined(modifier)) {\n    key += `+${modifier}`;\n  }\n  return key;\n}\nfunction clonePinchMovement(pinchMovement, result) {\n  Cartesian2.clone(pinchMovement.distance.startPosition, result.distance.startPosition);\n  Cartesian2.clone(pinchMovement.distance.endPosition, result.distance.endPosition);\n  Cartesian2.clone(pinchMovement.angleAndHeight.startPosition, result.angleAndHeight.startPosition);\n  Cartesian2.clone(pinchMovement.angleAndHeight.endPosition, result.angleAndHeight.endPosition);\n}\nfunction listenToPinch(aggregator, modifier, canvas) {\n  const key = getKey(CameraEventType.PINCH, modifier);\n  const update = aggregator._update;\n  const isDown = aggregator._isDown;\n  const eventStartPosition = aggregator._eventStartPosition;\n  const pressTime = aggregator._pressTime;\n  const releaseTime = aggregator._releaseTime;\n  update[key] = true;\n  isDown[key] = false;\n  eventStartPosition[key] = new Cartesian2();\n  let movement = aggregator._movement[key];\n  if (!defined(movement)) {\n    movement = aggregator._movement[key] = {};\n  }\n  movement.distance = {\n    startPosition: new Cartesian2(),\n    endPosition: new Cartesian2()\n  };\n  movement.angleAndHeight = {\n    startPosition: new Cartesian2(),\n    endPosition: new Cartesian2()\n  };\n  movement.prevAngle = 0.0;\n  aggregator._eventHandler.setInputAction(function (event) {\n    aggregator._buttonsDown++;\n    isDown[key] = true;\n    pressTime[key] = new Date();\n    // Compute center position and store as start point.\n    Cartesian2.lerp(event.position1, event.position2, 0.5, eventStartPosition[key]);\n  }, ScreenSpaceEventType.PINCH_START, modifier);\n  aggregator._eventHandler.setInputAction(function () {\n    aggregator._buttonsDown = Math.max(aggregator._buttonsDown - 1, 0);\n    isDown[key] = false;\n    releaseTime[key] = new Date();\n  }, ScreenSpaceEventType.PINCH_END, modifier);\n  aggregator._eventHandler.setInputAction(function (mouseMovement) {\n    if (isDown[key]) {\n      // Aggregate several input events into a single animation frame.\n      if (!update[key]) {\n        Cartesian2.clone(mouseMovement.distance.endPosition, movement.distance.endPosition);\n        Cartesian2.clone(mouseMovement.angleAndHeight.endPosition, movement.angleAndHeight.endPosition);\n      } else {\n        clonePinchMovement(mouseMovement, movement);\n        update[key] = false;\n        movement.prevAngle = movement.angleAndHeight.startPosition.x;\n      }\n      // Make sure our aggregation of angles does not \"flip\" over 360 degrees.\n      let angle = movement.angleAndHeight.endPosition.x;\n      const prevAngle = movement.prevAngle;\n      const TwoPI = Math.PI * 2;\n      while (angle >= prevAngle + Math.PI) {\n        angle -= TwoPI;\n      }\n      while (angle < prevAngle - Math.PI) {\n        angle += TwoPI;\n      }\n      movement.angleAndHeight.endPosition.x = -angle * canvas.clientWidth / 12;\n      movement.angleAndHeight.startPosition.x = -prevAngle * canvas.clientWidth / 12;\n    }\n  }, ScreenSpaceEventType.PINCH_MOVE, modifier);\n}\nfunction listenToWheel(aggregator, modifier) {\n  const key = getKey(CameraEventType.WHEEL, modifier);\n  const pressTime = aggregator._pressTime;\n  const releaseTime = aggregator._releaseTime;\n  const update = aggregator._update;\n  update[key] = true;\n  let movement = aggregator._movement[key];\n  if (!defined(movement)) {\n    movement = aggregator._movement[key] = {};\n  }\n  let lastMovement = aggregator._lastMovement[key];\n  if (!defined(lastMovement)) {\n    lastMovement = aggregator._lastMovement[key] = {\n      startPosition: new Cartesian2(),\n      endPosition: new Cartesian2(),\n      valid: false\n    };\n  }\n  movement.startPosition = new Cartesian2();\n  Cartesian2.clone(Cartesian2.ZERO, movement.startPosition);\n  movement.endPosition = new Cartesian2();\n  aggregator._eventHandler.setInputAction(function (delta) {\n    const arcLength = 7.5 * CesiumMath.toRadians(delta);\n    pressTime[key] = releaseTime[key] = new Date();\n    movement.endPosition.x = 0.0;\n    movement.endPosition.y = arcLength;\n    Cartesian2.clone(movement.endPosition, lastMovement.endPosition);\n    lastMovement.valid = true;\n    update[key] = false;\n  }, ScreenSpaceEventType.WHEEL, modifier);\n}\nfunction listenMouseButtonDownUp(aggregator, modifier, type) {\n  const key = getKey(type, modifier);\n  const isDown = aggregator._isDown;\n  const eventStartPosition = aggregator._eventStartPosition;\n  const pressTime = aggregator._pressTime;\n  isDown[key] = false;\n  eventStartPosition[key] = new Cartesian2();\n  let lastMovement = aggregator._lastMovement[key];\n  if (!defined(lastMovement)) {\n    lastMovement = aggregator._lastMovement[key] = {\n      startPosition: new Cartesian2(),\n      endPosition: new Cartesian2(),\n      valid: false\n    };\n  }\n  let down;\n  let up;\n  if (type === CameraEventType.LEFT_DRAG) {\n    down = ScreenSpaceEventType.LEFT_DOWN;\n    up = ScreenSpaceEventType.LEFT_UP;\n  } else if (type === CameraEventType.RIGHT_DRAG) {\n    down = ScreenSpaceEventType.RIGHT_DOWN;\n    up = ScreenSpaceEventType.RIGHT_UP;\n  } else if (type === CameraEventType.MIDDLE_DRAG) {\n    down = ScreenSpaceEventType.MIDDLE_DOWN;\n    up = ScreenSpaceEventType.MIDDLE_UP;\n  }\n  aggregator._eventHandler.setInputAction(function (event) {\n    aggregator._buttonsDown++;\n    lastMovement.valid = false;\n    isDown[key] = true;\n    pressTime[key] = new Date();\n    Cartesian2.clone(event.position, eventStartPosition[key]);\n  }, down, modifier);\n  aggregator._eventHandler.setInputAction(function () {\n    cancelMouseDownAction(getKey(type, undefined), aggregator);\n    for (const modifier of Object.values(KeyboardEventModifier)) {\n      const cancelKey = getKey(type, modifier);\n      cancelMouseDownAction(cancelKey, aggregator);\n    }\n  }, up, modifier);\n}\nfunction cancelMouseDownAction(cancelKey, aggregator) {\n  const releaseTime = aggregator._releaseTime;\n  const isDown = aggregator._isDown;\n  if (isDown[cancelKey]) {\n    aggregator._buttonsDown = Math.max(aggregator._buttonsDown - 1, 0);\n  }\n  isDown[cancelKey] = false;\n  releaseTime[cancelKey] = new Date();\n}\nfunction cloneMouseMovement(mouseMovement, result) {\n  Cartesian2.clone(mouseMovement.startPosition, result.startPosition);\n  Cartesian2.clone(mouseMovement.endPosition, result.endPosition);\n}\nfunction refreshMouseDownStatus(type, modifier, aggregator) {\n  // first: Judge if the mouse is pressed\n  const isDown = aggregator._isDown;\n  let anyButtonIsDown = false;\n  const currentKey = getKey(type, modifier);\n  for (const [downKey, downValue] of Object.entries(isDown)) {\n    if (downKey.startsWith(type) && downValue && downKey !== currentKey) {\n      anyButtonIsDown = true;\n      cancelMouseDownAction(downKey, aggregator);\n    }\n  }\n  if (!anyButtonIsDown) {\n    return;\n  }\n\n  // second: If it is pressed, it will be transferred to the current modifier.\n  const pressTime = aggregator._pressTime;\n  let lastMovement = aggregator._lastMovement[currentKey];\n  if (!defined(lastMovement)) {\n    lastMovement = aggregator._lastMovement[currentKey] = {\n      startPosition: new Cartesian2(),\n      endPosition: new Cartesian2(),\n      valid: false\n    };\n  }\n  aggregator._buttonsDown++;\n  lastMovement.valid = false;\n  isDown[currentKey] = true;\n  pressTime[currentKey] = new Date();\n}\nfunction listenMouseMove(aggregator, modifier) {\n  const update = aggregator._update;\n  const movement = aggregator._movement;\n  const lastMovement = aggregator._lastMovement;\n  const isDown = aggregator._isDown;\n  for (const typeName in CameraEventType) {\n    if (CameraEventType.hasOwnProperty(typeName)) {\n      const type = CameraEventType[typeName];\n      if (defined(type)) {\n        const key = getKey(type, modifier);\n        update[key] = true;\n        if (!defined(aggregator._lastMovement[key])) {\n          aggregator._lastMovement[key] = {\n            startPosition: new Cartesian2(),\n            endPosition: new Cartesian2(),\n            valid: false\n          };\n        }\n        if (!defined(aggregator._movement[key])) {\n          aggregator._movement[key] = {\n            startPosition: new Cartesian2(),\n            endPosition: new Cartesian2()\n          };\n        }\n      }\n    }\n  }\n  aggregator._eventHandler.setInputAction(function (mouseMovement) {\n    for (const typeName in CameraEventType) {\n      if (CameraEventType.hasOwnProperty(typeName)) {\n        const type = CameraEventType[typeName];\n        if (defined(type)) {\n          const key = getKey(type, modifier);\n          refreshMouseDownStatus(type, modifier, aggregator);\n          if (isDown[key]) {\n            if (!update[key]) {\n              Cartesian2.clone(mouseMovement.endPosition, movement[key].endPosition);\n            } else {\n              cloneMouseMovement(movement[key], lastMovement[key]);\n              lastMovement[key].valid = true;\n              cloneMouseMovement(mouseMovement, movement[key]);\n              update[key] = false;\n            }\n          }\n        }\n      }\n    }\n    Cartesian2.clone(mouseMovement.endPosition, aggregator._currentMousePosition);\n  }, ScreenSpaceEventType.MOUSE_MOVE, modifier);\n}\n\n/**\n * Aggregates input events. For example, suppose the following inputs are received between frames:\n * left mouse button down, mouse move, mouse move, left mouse button up. These events will be aggregated into\n * one event with a start and end position of the mouse.\n *\n * @alias CameraEventAggregator\n * @constructor\n *\n * @param {HTMLCanvasElement} [canvas=document] The element to handle events for.\n *\n * @see ScreenSpaceEventHandler\n */\nfunction CameraEventAggregator(canvas) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(canvas)) {\n    throw new DeveloperError(\"canvas is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._eventHandler = new ScreenSpaceEventHandler(canvas);\n  this._update = {};\n  this._movement = {};\n  this._lastMovement = {};\n  this._isDown = {};\n  this._eventStartPosition = {};\n  this._pressTime = {};\n  this._releaseTime = {};\n  this._buttonsDown = 0;\n  this._currentMousePosition = new Cartesian2();\n  listenToWheel(this, undefined);\n  listenToPinch(this, undefined, canvas);\n  listenMouseButtonDownUp(this, undefined, CameraEventType.LEFT_DRAG);\n  listenMouseButtonDownUp(this, undefined, CameraEventType.RIGHT_DRAG);\n  listenMouseButtonDownUp(this, undefined, CameraEventType.MIDDLE_DRAG);\n  listenMouseMove(this, undefined);\n  for (const modifierName in KeyboardEventModifier) {\n    if (KeyboardEventModifier.hasOwnProperty(modifierName)) {\n      const modifier = KeyboardEventModifier[modifierName];\n      if (defined(modifier)) {\n        listenToWheel(this, modifier);\n        listenToPinch(this, modifier, canvas);\n        listenMouseButtonDownUp(this, modifier, CameraEventType.LEFT_DRAG);\n        listenMouseButtonDownUp(this, modifier, CameraEventType.RIGHT_DRAG);\n        listenMouseButtonDownUp(this, modifier, CameraEventType.MIDDLE_DRAG);\n        listenMouseMove(this, modifier);\n      }\n    }\n  }\n}\nObject.defineProperties(CameraEventAggregator.prototype, {\n  /**\n   * Gets the current mouse position.\n   * @memberof CameraEventAggregator.prototype\n   * @type {Cartesian2}\n   */\n  currentMousePosition: {\n    get: function () {\n      return this._currentMousePosition;\n    }\n  },\n  /**\n   * Gets whether any mouse button is down, a touch has started, or the wheel has been moved.\n   * @memberof CameraEventAggregator.prototype\n   * @type {boolean}\n   */\n  anyButtonDown: {\n    get: function () {\n      const wheelMoved = !this._update[getKey(CameraEventType.WHEEL)] || !this._update[getKey(CameraEventType.WHEEL, KeyboardEventModifier.SHIFT)] || !this._update[getKey(CameraEventType.WHEEL, KeyboardEventModifier.CTRL)] || !this._update[getKey(CameraEventType.WHEEL, KeyboardEventModifier.ALT)];\n      return this._buttonsDown > 0 || wheelMoved;\n    }\n  }\n});\n\n/**\n * Gets if a mouse button down or touch has started and has been moved.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {boolean} Returns <code>true</code> if a mouse button down or touch has started and has been moved; otherwise, <code>false</code>\n */\nCameraEventAggregator.prototype.isMoving = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getKey(type, modifier);\n  return !this._update[key];\n};\n\n/**\n * Gets the aggregated start and end position of the current event.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {object} An object with two {@link Cartesian2} properties: <code>startPosition</code> and <code>endPosition</code>.\n */\nCameraEventAggregator.prototype.getMovement = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getKey(type, modifier);\n  const movement = this._movement[key];\n  return movement;\n};\n\n/**\n * Gets the start and end position of the last move event (not the aggregated event).\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {object|undefined} An object with two {@link Cartesian2} properties: <code>startPosition</code> and <code>endPosition</code> or <code>undefined</code>.\n */\nCameraEventAggregator.prototype.getLastMovement = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getKey(type, modifier);\n  const lastMovement = this._lastMovement[key];\n  if (lastMovement.valid) {\n    return lastMovement;\n  }\n  return undefined;\n};\n\n/**\n * Gets whether the mouse button is down or a touch has started.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {boolean} Whether the mouse button is down or a touch has started.\n */\nCameraEventAggregator.prototype.isButtonDown = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getKey(type, modifier);\n  return this._isDown[key];\n};\n\n/**\n * Gets the mouse position that started the aggregation.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Cartesian2} The mouse position.\n */\nCameraEventAggregator.prototype.getStartMousePosition = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (type === CameraEventType.WHEEL) {\n    return this._currentMousePosition;\n  }\n  const key = getKey(type, modifier);\n  return this._eventStartPosition[key];\n};\n\n/**\n * Gets the time the button was pressed or the touch was started.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Date} The time the button was pressed or the touch was started.\n */\nCameraEventAggregator.prototype.getButtonPressTime = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getKey(type, modifier);\n  return this._pressTime[key];\n};\n\n/**\n * Gets the time the button was released or the touch was ended.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Date} The time the button was released or the touch was ended.\n */\nCameraEventAggregator.prototype.getButtonReleaseTime = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getKey(type, modifier);\n  return this._releaseTime[key];\n};\n\n/**\n * Signals that all of the events have been handled and the aggregator should be reset to handle new events.\n */\nCameraEventAggregator.prototype.reset = function () {\n  for (const name in this._update) {\n    if (this._update.hasOwnProperty(name)) {\n      this._update[name] = true;\n    }\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see CameraEventAggregator#destroy\n */\nCameraEventAggregator.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes mouse listeners held by this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * handler = handler && handler.destroy();\n *\n * @see CameraEventAggregator#isDestroyed\n */\nCameraEventAggregator.prototype.destroy = function () {\n  this._eventHandler = this._eventHandler && this._eventHandler.destroy();\n  return destroyObject(this);\n};\nexport default CameraEventAggregator;","map":{"version":3,"names":["Cartesian2","defined","destroyObject","DeveloperError","KeyboardEventModifier","CesiumMath","ScreenSpaceEventHandler","ScreenSpaceEventType","CameraEventType","getKey","type","modifier","key","clonePinchMovement","pinchMovement","result","clone","distance","startPosition","endPosition","angleAndHeight","listenToPinch","aggregator","canvas","PINCH","update","_update","isDown","_isDown","eventStartPosition","_eventStartPosition","pressTime","_pressTime","releaseTime","_releaseTime","movement","_movement","prevAngle","_eventHandler","setInputAction","event","_buttonsDown","Date","lerp","position1","position2","PINCH_START","Math","max","PINCH_END","mouseMovement","x","angle","TwoPI","PI","clientWidth","PINCH_MOVE","listenToWheel","WHEEL","lastMovement","_lastMovement","valid","ZERO","delta","arcLength","toRadians","y","listenMouseButtonDownUp","down","up","LEFT_DRAG","LEFT_DOWN","LEFT_UP","RIGHT_DRAG","RIGHT_DOWN","RIGHT_UP","MIDDLE_DRAG","MIDDLE_DOWN","MIDDLE_UP","position","cancelMouseDownAction","undefined","Object","values","cancelKey","cloneMouseMovement","refreshMouseDownStatus","anyButtonIsDown","currentKey","downKey","downValue","entries","startsWith","listenMouseMove","typeName","hasOwnProperty","_currentMousePosition","MOUSE_MOVE","CameraEventAggregator","modifierName","defineProperties","prototype","currentMousePosition","get","anyButtonDown","wheelMoved","SHIFT","CTRL","ALT","isMoving","getMovement","getLastMovement","isButtonDown","getStartMousePosition","getButtonPressTime","getButtonReleaseTime","reset","name","isDestroyed","destroy"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/CameraEventAggregator.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport KeyboardEventModifier from \"../Core/KeyboardEventModifier.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport ScreenSpaceEventHandler from \"../Core/ScreenSpaceEventHandler.js\";\nimport ScreenSpaceEventType from \"../Core/ScreenSpaceEventType.js\";\nimport CameraEventType from \"./CameraEventType.js\";\n\nfunction getKey(type, modifier) {\n  let key = `${type}`;\n  if (defined(modifier)) {\n    key += `+${modifier}`;\n  }\n  return key;\n}\n\nfunction clonePinchMovement(pinchMovement, result) {\n  Cartesian2.clone(\n    pinchMovement.distance.startPosition,\n    result.distance.startPosition,\n  );\n  Cartesian2.clone(\n    pinchMovement.distance.endPosition,\n    result.distance.endPosition,\n  );\n\n  Cartesian2.clone(\n    pinchMovement.angleAndHeight.startPosition,\n    result.angleAndHeight.startPosition,\n  );\n  Cartesian2.clone(\n    pinchMovement.angleAndHeight.endPosition,\n    result.angleAndHeight.endPosition,\n  );\n}\n\nfunction listenToPinch(aggregator, modifier, canvas) {\n  const key = getKey(CameraEventType.PINCH, modifier);\n\n  const update = aggregator._update;\n  const isDown = aggregator._isDown;\n  const eventStartPosition = aggregator._eventStartPosition;\n  const pressTime = aggregator._pressTime;\n  const releaseTime = aggregator._releaseTime;\n\n  update[key] = true;\n  isDown[key] = false;\n  eventStartPosition[key] = new Cartesian2();\n\n  let movement = aggregator._movement[key];\n  if (!defined(movement)) {\n    movement = aggregator._movement[key] = {};\n  }\n\n  movement.distance = {\n    startPosition: new Cartesian2(),\n    endPosition: new Cartesian2(),\n  };\n  movement.angleAndHeight = {\n    startPosition: new Cartesian2(),\n    endPosition: new Cartesian2(),\n  };\n  movement.prevAngle = 0.0;\n\n  aggregator._eventHandler.setInputAction(\n    function (event) {\n      aggregator._buttonsDown++;\n      isDown[key] = true;\n      pressTime[key] = new Date();\n      // Compute center position and store as start point.\n      Cartesian2.lerp(\n        event.position1,\n        event.position2,\n        0.5,\n        eventStartPosition[key],\n      );\n    },\n    ScreenSpaceEventType.PINCH_START,\n    modifier,\n  );\n\n  aggregator._eventHandler.setInputAction(\n    function () {\n      aggregator._buttonsDown = Math.max(aggregator._buttonsDown - 1, 0);\n      isDown[key] = false;\n      releaseTime[key] = new Date();\n    },\n    ScreenSpaceEventType.PINCH_END,\n    modifier,\n  );\n\n  aggregator._eventHandler.setInputAction(\n    function (mouseMovement) {\n      if (isDown[key]) {\n        // Aggregate several input events into a single animation frame.\n        if (!update[key]) {\n          Cartesian2.clone(\n            mouseMovement.distance.endPosition,\n            movement.distance.endPosition,\n          );\n          Cartesian2.clone(\n            mouseMovement.angleAndHeight.endPosition,\n            movement.angleAndHeight.endPosition,\n          );\n        } else {\n          clonePinchMovement(mouseMovement, movement);\n          update[key] = false;\n          movement.prevAngle = movement.angleAndHeight.startPosition.x;\n        }\n        // Make sure our aggregation of angles does not \"flip\" over 360 degrees.\n        let angle = movement.angleAndHeight.endPosition.x;\n        const prevAngle = movement.prevAngle;\n        const TwoPI = Math.PI * 2;\n        while (angle >= prevAngle + Math.PI) {\n          angle -= TwoPI;\n        }\n        while (angle < prevAngle - Math.PI) {\n          angle += TwoPI;\n        }\n        movement.angleAndHeight.endPosition.x =\n          (-angle * canvas.clientWidth) / 12;\n        movement.angleAndHeight.startPosition.x =\n          (-prevAngle * canvas.clientWidth) / 12;\n      }\n    },\n    ScreenSpaceEventType.PINCH_MOVE,\n    modifier,\n  );\n}\n\nfunction listenToWheel(aggregator, modifier) {\n  const key = getKey(CameraEventType.WHEEL, modifier);\n\n  const pressTime = aggregator._pressTime;\n  const releaseTime = aggregator._releaseTime;\n\n  const update = aggregator._update;\n  update[key] = true;\n\n  let movement = aggregator._movement[key];\n  if (!defined(movement)) {\n    movement = aggregator._movement[key] = {};\n  }\n\n  let lastMovement = aggregator._lastMovement[key];\n  if (!defined(lastMovement)) {\n    lastMovement = aggregator._lastMovement[key] = {\n      startPosition: new Cartesian2(),\n      endPosition: new Cartesian2(),\n      valid: false,\n    };\n  }\n\n  movement.startPosition = new Cartesian2();\n  Cartesian2.clone(Cartesian2.ZERO, movement.startPosition);\n  movement.endPosition = new Cartesian2();\n\n  aggregator._eventHandler.setInputAction(\n    function (delta) {\n      const arcLength = 7.5 * CesiumMath.toRadians(delta);\n      pressTime[key] = releaseTime[key] = new Date();\n      movement.endPosition.x = 0.0;\n      movement.endPosition.y = arcLength;\n      Cartesian2.clone(movement.endPosition, lastMovement.endPosition);\n      lastMovement.valid = true;\n      update[key] = false;\n    },\n    ScreenSpaceEventType.WHEEL,\n    modifier,\n  );\n}\n\nfunction listenMouseButtonDownUp(aggregator, modifier, type) {\n  const key = getKey(type, modifier);\n\n  const isDown = aggregator._isDown;\n  const eventStartPosition = aggregator._eventStartPosition;\n  const pressTime = aggregator._pressTime;\n\n  isDown[key] = false;\n  eventStartPosition[key] = new Cartesian2();\n\n  let lastMovement = aggregator._lastMovement[key];\n  if (!defined(lastMovement)) {\n    lastMovement = aggregator._lastMovement[key] = {\n      startPosition: new Cartesian2(),\n      endPosition: new Cartesian2(),\n      valid: false,\n    };\n  }\n\n  let down;\n  let up;\n  if (type === CameraEventType.LEFT_DRAG) {\n    down = ScreenSpaceEventType.LEFT_DOWN;\n    up = ScreenSpaceEventType.LEFT_UP;\n  } else if (type === CameraEventType.RIGHT_DRAG) {\n    down = ScreenSpaceEventType.RIGHT_DOWN;\n    up = ScreenSpaceEventType.RIGHT_UP;\n  } else if (type === CameraEventType.MIDDLE_DRAG) {\n    down = ScreenSpaceEventType.MIDDLE_DOWN;\n    up = ScreenSpaceEventType.MIDDLE_UP;\n  }\n\n  aggregator._eventHandler.setInputAction(\n    function (event) {\n      aggregator._buttonsDown++;\n      lastMovement.valid = false;\n      isDown[key] = true;\n      pressTime[key] = new Date();\n      Cartesian2.clone(event.position, eventStartPosition[key]);\n    },\n    down,\n    modifier,\n  );\n\n  aggregator._eventHandler.setInputAction(\n    function () {\n      cancelMouseDownAction(getKey(type, undefined), aggregator);\n      for (const modifier of Object.values(KeyboardEventModifier)) {\n        const cancelKey = getKey(type, modifier);\n        cancelMouseDownAction(cancelKey, aggregator);\n      }\n    },\n    up,\n    modifier,\n  );\n}\n\nfunction cancelMouseDownAction(cancelKey, aggregator) {\n  const releaseTime = aggregator._releaseTime;\n  const isDown = aggregator._isDown;\n  if (isDown[cancelKey]) {\n    aggregator._buttonsDown = Math.max(aggregator._buttonsDown - 1, 0);\n  }\n  isDown[cancelKey] = false;\n  releaseTime[cancelKey] = new Date();\n}\n\nfunction cloneMouseMovement(mouseMovement, result) {\n  Cartesian2.clone(mouseMovement.startPosition, result.startPosition);\n  Cartesian2.clone(mouseMovement.endPosition, result.endPosition);\n}\n\nfunction refreshMouseDownStatus(type, modifier, aggregator) {\n  // first: Judge if the mouse is pressed\n  const isDown = aggregator._isDown;\n  let anyButtonIsDown = false;\n  const currentKey = getKey(type, modifier);\n  for (const [downKey, downValue] of Object.entries(isDown)) {\n    if (downKey.startsWith(type) && downValue && downKey !== currentKey) {\n      anyButtonIsDown = true;\n      cancelMouseDownAction(downKey, aggregator);\n    }\n  }\n\n  if (!anyButtonIsDown) {\n    return;\n  }\n\n  // second: If it is pressed, it will be transferred to the current modifier.\n  const pressTime = aggregator._pressTime;\n  let lastMovement = aggregator._lastMovement[currentKey];\n  if (!defined(lastMovement)) {\n    lastMovement = aggregator._lastMovement[currentKey] = {\n      startPosition: new Cartesian2(),\n      endPosition: new Cartesian2(),\n      valid: false,\n    };\n  }\n  aggregator._buttonsDown++;\n  lastMovement.valid = false;\n  isDown[currentKey] = true;\n  pressTime[currentKey] = new Date();\n}\n\nfunction listenMouseMove(aggregator, modifier) {\n  const update = aggregator._update;\n  const movement = aggregator._movement;\n  const lastMovement = aggregator._lastMovement;\n  const isDown = aggregator._isDown;\n\n  for (const typeName in CameraEventType) {\n    if (CameraEventType.hasOwnProperty(typeName)) {\n      const type = CameraEventType[typeName];\n      if (defined(type)) {\n        const key = getKey(type, modifier);\n        update[key] = true;\n\n        if (!defined(aggregator._lastMovement[key])) {\n          aggregator._lastMovement[key] = {\n            startPosition: new Cartesian2(),\n            endPosition: new Cartesian2(),\n            valid: false,\n          };\n        }\n\n        if (!defined(aggregator._movement[key])) {\n          aggregator._movement[key] = {\n            startPosition: new Cartesian2(),\n            endPosition: new Cartesian2(),\n          };\n        }\n      }\n    }\n  }\n\n  aggregator._eventHandler.setInputAction(\n    function (mouseMovement) {\n      for (const typeName in CameraEventType) {\n        if (CameraEventType.hasOwnProperty(typeName)) {\n          const type = CameraEventType[typeName];\n          if (defined(type)) {\n            const key = getKey(type, modifier);\n            refreshMouseDownStatus(type, modifier, aggregator);\n            if (isDown[key]) {\n              if (!update[key]) {\n                Cartesian2.clone(\n                  mouseMovement.endPosition,\n                  movement[key].endPosition,\n                );\n              } else {\n                cloneMouseMovement(movement[key], lastMovement[key]);\n                lastMovement[key].valid = true;\n                cloneMouseMovement(mouseMovement, movement[key]);\n                update[key] = false;\n              }\n            }\n          }\n        }\n      }\n\n      Cartesian2.clone(\n        mouseMovement.endPosition,\n        aggregator._currentMousePosition,\n      );\n    },\n    ScreenSpaceEventType.MOUSE_MOVE,\n    modifier,\n  );\n}\n\n/**\n * Aggregates input events. For example, suppose the following inputs are received between frames:\n * left mouse button down, mouse move, mouse move, left mouse button up. These events will be aggregated into\n * one event with a start and end position of the mouse.\n *\n * @alias CameraEventAggregator\n * @constructor\n *\n * @param {HTMLCanvasElement} [canvas=document] The element to handle events for.\n *\n * @see ScreenSpaceEventHandler\n */\nfunction CameraEventAggregator(canvas) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(canvas)) {\n    throw new DeveloperError(\"canvas is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._eventHandler = new ScreenSpaceEventHandler(canvas);\n\n  this._update = {};\n  this._movement = {};\n  this._lastMovement = {};\n  this._isDown = {};\n  this._eventStartPosition = {};\n  this._pressTime = {};\n  this._releaseTime = {};\n\n  this._buttonsDown = 0;\n\n  this._currentMousePosition = new Cartesian2();\n\n  listenToWheel(this, undefined);\n  listenToPinch(this, undefined, canvas);\n  listenMouseButtonDownUp(this, undefined, CameraEventType.LEFT_DRAG);\n  listenMouseButtonDownUp(this, undefined, CameraEventType.RIGHT_DRAG);\n  listenMouseButtonDownUp(this, undefined, CameraEventType.MIDDLE_DRAG);\n  listenMouseMove(this, undefined);\n\n  for (const modifierName in KeyboardEventModifier) {\n    if (KeyboardEventModifier.hasOwnProperty(modifierName)) {\n      const modifier = KeyboardEventModifier[modifierName];\n      if (defined(modifier)) {\n        listenToWheel(this, modifier);\n        listenToPinch(this, modifier, canvas);\n        listenMouseButtonDownUp(this, modifier, CameraEventType.LEFT_DRAG);\n        listenMouseButtonDownUp(this, modifier, CameraEventType.RIGHT_DRAG);\n        listenMouseButtonDownUp(this, modifier, CameraEventType.MIDDLE_DRAG);\n        listenMouseMove(this, modifier);\n      }\n    }\n  }\n}\n\nObject.defineProperties(CameraEventAggregator.prototype, {\n  /**\n   * Gets the current mouse position.\n   * @memberof CameraEventAggregator.prototype\n   * @type {Cartesian2}\n   */\n  currentMousePosition: {\n    get: function () {\n      return this._currentMousePosition;\n    },\n  },\n\n  /**\n   * Gets whether any mouse button is down, a touch has started, or the wheel has been moved.\n   * @memberof CameraEventAggregator.prototype\n   * @type {boolean}\n   */\n  anyButtonDown: {\n    get: function () {\n      const wheelMoved =\n        !this._update[getKey(CameraEventType.WHEEL)] ||\n        !this._update[\n          getKey(CameraEventType.WHEEL, KeyboardEventModifier.SHIFT)\n        ] ||\n        !this._update[\n          getKey(CameraEventType.WHEEL, KeyboardEventModifier.CTRL)\n        ] ||\n        !this._update[getKey(CameraEventType.WHEEL, KeyboardEventModifier.ALT)];\n      return this._buttonsDown > 0 || wheelMoved;\n    },\n  },\n});\n\n/**\n * Gets if a mouse button down or touch has started and has been moved.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {boolean} Returns <code>true</code> if a mouse button down or touch has started and has been moved; otherwise, <code>false</code>\n */\nCameraEventAggregator.prototype.isMoving = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getKey(type, modifier);\n  return !this._update[key];\n};\n\n/**\n * Gets the aggregated start and end position of the current event.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {object} An object with two {@link Cartesian2} properties: <code>startPosition</code> and <code>endPosition</code>.\n */\nCameraEventAggregator.prototype.getMovement = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getKey(type, modifier);\n  const movement = this._movement[key];\n  return movement;\n};\n\n/**\n * Gets the start and end position of the last move event (not the aggregated event).\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {object|undefined} An object with two {@link Cartesian2} properties: <code>startPosition</code> and <code>endPosition</code> or <code>undefined</code>.\n */\nCameraEventAggregator.prototype.getLastMovement = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getKey(type, modifier);\n  const lastMovement = this._lastMovement[key];\n  if (lastMovement.valid) {\n    return lastMovement;\n  }\n\n  return undefined;\n};\n\n/**\n * Gets whether the mouse button is down or a touch has started.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {boolean} Whether the mouse button is down or a touch has started.\n */\nCameraEventAggregator.prototype.isButtonDown = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getKey(type, modifier);\n  return this._isDown[key];\n};\n\n/**\n * Gets the mouse position that started the aggregation.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Cartesian2} The mouse position.\n */\nCameraEventAggregator.prototype.getStartMousePosition = function (\n  type,\n  modifier,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (type === CameraEventType.WHEEL) {\n    return this._currentMousePosition;\n  }\n\n  const key = getKey(type, modifier);\n  return this._eventStartPosition[key];\n};\n\n/**\n * Gets the time the button was pressed or the touch was started.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Date} The time the button was pressed or the touch was started.\n */\nCameraEventAggregator.prototype.getButtonPressTime = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getKey(type, modifier);\n  return this._pressTime[key];\n};\n\n/**\n * Gets the time the button was released or the touch was ended.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Date} The time the button was released or the touch was ended.\n */\nCameraEventAggregator.prototype.getButtonReleaseTime = function (\n  type,\n  modifier,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getKey(type, modifier);\n  return this._releaseTime[key];\n};\n\n/**\n * Signals that all of the events have been handled and the aggregator should be reset to handle new events.\n */\nCameraEventAggregator.prototype.reset = function () {\n  for (const name in this._update) {\n    if (this._update.hasOwnProperty(name)) {\n      this._update[name] = true;\n    }\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see CameraEventAggregator#destroy\n */\nCameraEventAggregator.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes mouse listeners held by this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * handler = handler && handler.destroy();\n *\n * @see CameraEventAggregator#isDestroyed\n */\nCameraEventAggregator.prototype.destroy = function () {\n  this._eventHandler = this._eventHandler && this._eventHandler.destroy();\n  return destroyObject(this);\n};\nexport default CameraEventAggregator;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}