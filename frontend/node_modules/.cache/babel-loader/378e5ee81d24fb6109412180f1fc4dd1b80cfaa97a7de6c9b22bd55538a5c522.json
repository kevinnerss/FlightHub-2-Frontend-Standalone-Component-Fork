{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport buildVoxelDrawCommands from \"./buildVoxelDrawCommands.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Cesium3DTilesetStatistics from \"./Cesium3DTilesetStatistics.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport clone from \"../Core/clone.js\";\nimport CustomShader from \"./Model/CustomShader.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Event from \"../Core/Event.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport Material from \"./Material.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport MetadataComponentType from \"./MetadataComponentType.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport PolylineCollection from \"./PolylineCollection.js\";\nimport VerticalExaggeration from \"../Core/VerticalExaggeration.js\";\nimport VoxelContent from \"./VoxelContent.js\";\nimport VoxelShapeType from \"./VoxelShapeType.js\";\nimport VoxelTraversal from \"./VoxelTraversal.js\";\nimport VoxelMetadataOrder from \"./VoxelMetadataOrder.js\";\n\n/**\n * A primitive that renders voxel data from a {@link VoxelProvider}.\n *\n * @alias VoxelPrimitive\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {VoxelProvider} [options.provider] The voxel provider that supplies the primitive with tile data.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The model matrix used to transform the primitive.\n * @param {CustomShader} [options.customShader] The custom shader used to style the primitive.\n * @param {Clock} [options.clock] The clock used to control time dynamic behavior.\n * @param {Boolean} [options.calculateStatistics] Generate statistics for performance profile.\n *\n * @see VoxelProvider\n * @see Cesium3DTilesVoxelProvider\n * @see VoxelShapeType\n * @see {@link https://github.com/CesiumGS/cesium/tree/main/Documentation/CustomShaderGuide|Custom Shader Guide}\n *\n * @experimental This feature is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction VoxelPrimitive(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._ready = false;\n\n  /**\n   * @type {VoxelProvider}\n   * @private\n   */\n  this._provider = options.provider ?? VoxelPrimitive.DefaultProvider;\n\n  /**\n   * This member is not created until the provider and shape are ready.\n   *\n   * @type {VoxelTraversal}\n   * @private\n   */\n  this._traversal = undefined;\n\n  /**\n   * @type {Cesium3DTilesetStatistics}\n   * @private\n   */\n  this._statistics = new Cesium3DTilesetStatistics();\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._calculateStatistics = options.calculateStatistics ?? false;\n\n  /**\n   * This member is not created until the provider is ready.\n   *\n   * @type {VoxelShape}\n   * @private\n   */\n  this._shape = undefined;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._shapeVisible = false;\n\n  /**\n   * This member is not created until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._dimensions = new Cartesian3();\n\n  /**\n   * This member is not created until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._inputDimensions = new Cartesian3();\n\n  /**\n   * This member is not created until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._paddingBefore = new Cartesian3();\n\n  /**\n   * This member is not created until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._paddingAfter = new Cartesian3();\n\n  /**\n   * This member is not known until the provider is ready.\n   *\n   * @type {number}\n   * @private\n   */\n  this._availableLevels = 1;\n\n  /**\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._minBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the shape is dirty.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._minBoundsOld = new Cartesian3();\n\n  /**\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._maxBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the shape is dirty.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._maxBoundsOld = new Cartesian3();\n\n  /**\n   * Minimum bounds with vertical exaggeration applied\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._exaggeratedMinBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the shape is dirty.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._exaggeratedMinBoundsOld = new Cartesian3();\n\n  /**\n   * Maximum bounds with vertical exaggeration applied\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._exaggeratedMaxBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the shape is dirty.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._exaggeratedMaxBoundsOld = new Cartesian3();\n\n  /**\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._minClippingBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the clipping is dirty.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._minClippingBoundsOld = new Cartesian3();\n\n  /**\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._maxClippingBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the clipping is dirty.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._maxClippingBoundsOld = new Cartesian3();\n\n  /**\n   * Clipping planes on the primitive\n   *\n   * @type {ClippingPlaneCollection}\n   * @private\n   */\n  this._clippingPlanes = undefined;\n\n  /**\n   * Keeps track of when the clipping planes change\n   *\n   * @type {number}\n   * @private\n   */\n  this._clippingPlanesState = 0;\n\n  /**\n   * Keeps track of when the clipping planes are enabled / disabled\n   *\n   * @type {boolean}\n   * @private\n   */\n  this._clippingPlanesEnabled = false;\n\n  /**\n   * The primitive's model matrix.\n   *\n   * @type {Matrix4}\n   * @private\n   */\n  this._modelMatrix = Matrix4.clone(options.modelMatrix ?? Matrix4.IDENTITY);\n\n  /**\n   * Model matrix with vertical exaggeration applied. Only used for BOX shape type.\n   *\n   * @type {Matrix4}\n   * @private\n   */\n  this._exaggeratedModelMatrix = Matrix4.clone(this._modelMatrix);\n\n  /**\n   * The primitive's model matrix multiplied by the provider's model matrix.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Matrix4}\n   * @private\n   */\n  this._compoundModelMatrix = new Matrix4();\n\n  /**\n   * Used to detect if the shape is dirty.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Matrix4}\n   * @private\n   */\n  this._compoundModelMatrixOld = new Matrix4();\n\n  /**\n   * @type {CustomShader}\n   * @private\n   */\n  this._customShader = options.customShader ?? VoxelPrimitive.DefaultCustomShader;\n\n  /**\n   * @type {Event}\n   * @private\n   */\n  this._customShaderCompilationEvent = new Event();\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._shaderDirty = true;\n\n  /**\n   * @type {DrawCommand}\n   * @private\n   */\n  this._drawCommand = undefined;\n\n  /**\n   * @type {DrawCommand}\n   * @private\n   */\n  this._drawCommandPick = undefined;\n\n  /**\n   * @type {object}\n   * @private\n   */\n  this._pickId = undefined;\n\n  /**\n   * @type {Clock}\n   * @private\n   */\n  this._clock = options.clock;\n\n  // Transforms and other values that are computed when the shape changes\n  /**\n   * @type {Matrix4}\n   * @private\n   */\n  this._transformPositionLocalToWorld = new Matrix4();\n\n  /**\n   * @type {Matrix4}\n   * @private\n   */\n  this._transformPositionWorldToLocal = new Matrix4();\n\n  /**\n   * Transforms a plane in Hessian normal form from local space to view space.\n   * @type {Matrix4}\n   * @private\n   */\n  this._transformPlaneLocalToView = new Matrix4();\n\n  /**\n   * @type {Matrix3}\n   * @private\n   */\n  this._transformDirectionWorldToLocal = new Matrix3();\n\n  // Rendering\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._nearestSampling = false;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._levelBlendFactor = 0.0;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._stepSizeMultiplier = 1.0;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._depthTest = true;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._useLogDepth = undefined;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._screenSpaceError = 4.0; // in pixels\n\n  // Debug / statistics\n  /**\n   * @type {PolylineCollection}\n   * @private\n   */\n  this._debugPolylines = new PolylineCollection();\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._debugDraw = false;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._disableRender = false;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._disableUpdate = false;\n\n  /**\n   * @type {Object<string, any>}\n   * @private\n   */\n  this._uniforms = {\n    octreeInternalNodeTexture: undefined,\n    octreeInternalNodeTilesPerRow: 0,\n    octreeInternalNodeTexelSizeUv: new Cartesian2(),\n    octreeLeafNodeTexture: undefined,\n    octreeLeafNodeTilesPerRow: 0,\n    octreeLeafNodeTexelSizeUv: new Cartesian2(),\n    megatextureTextures: [],\n    megatextureSliceDimensions: new Cartesian2(),\n    megatextureTileDimensions: new Cartesian2(),\n    megatextureVoxelSizeUv: new Cartesian2(),\n    megatextureSliceSizeUv: new Cartesian2(),\n    megatextureTileSizeUv: new Cartesian2(),\n    dimensions: new Cartesian3(),\n    inputDimensions: new Cartesian3(),\n    paddingBefore: new Cartesian3(),\n    paddingAfter: new Cartesian3(),\n    transformPositionViewToLocal: new Matrix4(),\n    transformDirectionViewToLocal: new Matrix3(),\n    cameraPositionLocal: new Cartesian3(),\n    cameraDirectionLocal: new Cartesian3(),\n    cameraTileCoordinates: new Cartesian4(),\n    cameraTileUv: new Cartesian3(),\n    ndcSpaceAxisAlignedBoundingBox: new Cartesian4(),\n    clippingPlanesTexture: undefined,\n    clippingPlanesMatrix: new Matrix4(),\n    renderBoundPlanesTexture: undefined,\n    stepSize: 0,\n    pickColor: new Color()\n  };\n\n  /**\n   * Shape specific shader defines from the previous shape update. Used to detect if the shader needs to be rebuilt.\n   * @type {Object<string, any>}\n   * @private\n   */\n  this._shapeDefinesOld = {};\n\n  /**\n   * Map uniform names to functions that return the uniform values.\n   * @type {Object<string, function():any>}\n   * @private\n   */\n  this._uniformMap = {};\n  const uniforms = this._uniforms;\n  const uniformMap = this._uniformMap;\n  for (const key in uniforms) {\n    if (uniforms.hasOwnProperty(key)) {\n      const name = `u_${key}`;\n      uniformMap[name] = function () {\n        return uniforms[key];\n      };\n    }\n  }\n\n  /**\n   * The event fired to indicate that a tile's content was loaded.\n   * <p>\n   * This event is fired during the tileset traversal while the frame is being rendered\n   * so that updates to the tile take effect in the same frame.  Do not create or modify\n   * Cesium entities or primitives during the event listener.\n   * </p>\n   *\n   * @type {Event}\n   *\n   * @example\n   * voxelPrimitive.tileLoad.addEventListener(function() {\n   *     console.log('A tile was loaded.');\n   * });\n   */\n  this.tileLoad = new Event();\n\n  /**\n   * This event fires once for each visible tile in a frame.\n   * <p>\n   * This event is fired during the traversal while the frame is being rendered.\n   *\n   * @type {Event}\n   *\n   * @example\n   * voxelPrimitive.tileVisible.addEventListener(function() {\n   *     console.log('A tile is visible.');\n   * });\n   *\n   */\n  this.tileVisible = new Event();\n\n  /**\n   * The event fired to indicate that a tile's content failed to load.\n   *\n   * @type {Event}\n   *\n   * @example\n   * voxelPrimitive.tileFailed.addEventListener(function() {\n   *     console.log('An error occurred loading tile.');\n   * });\n   */\n  this.tileFailed = new Event();\n\n  /**\n   * The event fired to indicate that a tile's content was unloaded.\n   *\n   * @type {Event}\n   *\n   * @example\n   * voxelPrimitive.tileUnload.addEventListener(function() {\n   *     console.log('A tile was unloaded from the cache.');\n   * });\n   *\n   */\n  this.tileUnload = new Event();\n\n  /**\n   * The event fired to indicate progress of loading new tiles. This event is fired when a new tile\n   * is requested, when a requested tile is finished downloading, and when a downloaded tile has been\n   * processed and is ready to render.\n   * <p>\n   * The number of pending tile requests, <code>numberOfPendingRequests</code>, and number of tiles\n   * processing, <code>numberOfTilesProcessing</code> are passed to the event listener.\n   * </p>\n   * <p>\n   * This event is fired at the end of the frame after the scene is rendered.\n   * </p>\n   *\n   * @type {Event}\n   *\n   * @example\n   * voxelPrimitive.loadProgress.addEventListener(function(numberOfPendingRequests, numberOfTilesProcessing) {\n   *     if ((numberOfPendingRequests === 0) && (numberOfTilesProcessing === 0)) {\n   *         console.log('Finished loading');\n   *         return;\n   *     }\n   *\n   *     console.log(`Loading: requests: ${numberOfPendingRequests}, processing: ${numberOfTilesProcessing}`);\n   * });\n   */\n  this.loadProgress = new Event();\n\n  /**\n   * The event fired to indicate that all tiles that meet the screen space error this frame are loaded. The voxel\n   * primitive is completely loaded for this view.\n   * <p>\n   * This event is fired at the end of the frame after the scene is rendered.\n   * </p>\n   *\n   * @type {Event}\n   *\n   * @example\n   * voxelPrimitive.allTilesLoaded.addEventListener(function() {\n   *     console.log('All tiles are loaded');\n   * });\n   */\n  this.allTilesLoaded = new Event();\n\n  /**\n   * The event fired to indicate that all tiles that meet the screen space error this frame are loaded. This event\n   * is fired once when all tiles in the initial view are loaded.\n   * <p>\n   * This event is fired at the end of the frame after the scene is rendered.\n   * </p>\n   *\n   * @type {Event}\n   *\n   * @example\n   * voxelPrimitive.initialTilesLoaded.addEventListener(function() {\n   *     console.log('Initial tiles are loaded');\n   * });\n   *\n   * @see Cesium3DTileset#allTilesLoaded\n   */\n  this.initialTilesLoaded = new Event();\n\n  // If the provider fails to initialize the primitive will fail too.\n  const provider = this._provider;\n  initialize(this, provider);\n}\nfunction initialize(primitive, provider) {\n  // Set the bounds\n  const {\n    shape: shapeType,\n    minBounds = VoxelShapeType.getMinBounds(shapeType),\n    maxBounds = VoxelShapeType.getMaxBounds(shapeType)\n  } = provider;\n  primitive.minBounds = minBounds;\n  primitive.maxBounds = maxBounds;\n  primitive.minClippingBounds = minBounds.clone();\n  primitive.maxClippingBounds = maxBounds.clone();\n\n  // Initialize the exaggerated versions of bounds and model matrix\n  primitive._exaggeratedMinBounds = Cartesian3.clone(primitive._minBounds, primitive._exaggeratedMinBounds);\n  primitive._exaggeratedMaxBounds = Cartesian3.clone(primitive._maxBounds, primitive._exaggeratedMaxBounds);\n  primitive._exaggeratedModelMatrix = Matrix4.clone(primitive._modelMatrix, primitive._exaggeratedModelMatrix);\n  checkTransformAndBounds(primitive, provider);\n\n  // Create the shape object, and update it so it is valid for VoxelTraversal\n  const ShapeConstructor = VoxelShapeType.getShapeConstructor(shapeType);\n  primitive._shape = new ShapeConstructor();\n  primitive._shapeVisible = updateShapeAndTransforms(primitive);\n}\nObject.defineProperties(VoxelPrimitive.prototype, {\n  /**\n   * Gets a value indicating whether or not the primitive is ready for use.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n  /**\n   * Gets the {@link VoxelProvider} associated with this primitive.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {VoxelProvider}\n   * @readonly\n   */\n  provider: {\n    get: function () {\n      return this._provider;\n    }\n  },\n  /**\n   * Gets the bounding sphere.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      return this._shape.boundingSphere;\n    }\n  },\n  /**\n   * Gets the oriented bounding box.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {OrientedBoundingBox}\n   * @readonly\n   */\n  orientedBoundingBox: {\n    get: function () {\n      return this._shape.orientedBoundingBox;\n    }\n  },\n  /**\n   * Gets the model matrix.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Matrix4}\n   * @readonly\n   */\n  modelMatrix: {\n    get: function () {\n      return this._modelMatrix;\n    },\n    set: function (modelMatrix) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"modelMatrix\", modelMatrix);\n      //>>includeEnd('debug');\n\n      this._modelMatrix = Matrix4.clone(modelMatrix, this._modelMatrix);\n    }\n  },\n  /**\n   * Gets the shape type.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {VoxelShapeType}\n   * @readonly\n   */\n  shape: {\n    get: function () {\n      return this._provider.shape;\n    }\n  },\n  /**\n   * Gets the dimensions of each voxel tile, in z-up orientation.\n   * Does not include padding.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  dimensions: {\n    get: function () {\n      return this._dimensions;\n    }\n  },\n  /**\n   * Gets the dimensions of one tile of the input voxel data, in the input orientation.\n   * Includes padding.\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  inputDimensions: {\n    get: function () {\n      return this._inputDimensions;\n    }\n  },\n  /**\n   * Gets the padding before the voxel data.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  paddingBefore: {\n    get: function () {\n      return this._paddingBefore;\n    }\n  },\n  /**\n   * Gets the padding after the voxel data.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  paddingAfter: {\n    get: function () {\n      return this._paddingAfter;\n    }\n  },\n  /**\n   * Gets the minimum value per channel of the voxel data.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {number[][]}\n   * @readonly\n   */\n  minimumValues: {\n    get: function () {\n      return this._provider.minimumValues;\n    }\n  },\n  /**\n   * Gets the maximum value per channel of the voxel data.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {number[][]}\n   * @readonly\n   */\n  maximumValues: {\n    get: function () {\n      return this._provider.maximumValues;\n    }\n  },\n  /**\n   * Gets or sets whether or not this primitive should be displayed.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   */\n  show: {\n    get: function () {\n      return !this._disableRender;\n    },\n    set: function (show) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"show\", show);\n      //>>includeEnd('debug');\n\n      this._disableRender = !show;\n    }\n  },\n  /**\n   * Gets or sets whether or not the primitive should update when the view changes.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   */\n  disableUpdate: {\n    get: function () {\n      return this._disableUpdate;\n    },\n    set: function (disableUpdate) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"disableUpdate\", disableUpdate);\n      //>>includeEnd('debug');\n\n      this._disableUpdate = disableUpdate;\n    }\n  },\n  /**\n   * Gets or sets whether or not to render debug visualizations.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   */\n  debugDraw: {\n    get: function () {\n      return this._debugDraw;\n    },\n    set: function (debugDraw) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"debugDraw\", debugDraw);\n      //>>includeEnd('debug');\n\n      this._debugDraw = debugDraw;\n    }\n  },\n  /**\n   * Gets or sets whether or not to test against depth when rendering.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   */\n  depthTest: {\n    get: function () {\n      return this._depthTest;\n    },\n    set: function (depthTest) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"depthTest\", depthTest);\n      //>>includeEnd('debug');\n\n      if (this._depthTest !== depthTest) {\n        this._depthTest = depthTest;\n        this._shaderDirty = true;\n      }\n    }\n  },\n  /**\n   * Gets or sets the nearest sampling.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   */\n  nearestSampling: {\n    get: function () {\n      return this._nearestSampling;\n    },\n    set: function (nearestSampling) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"nearestSampling\", nearestSampling);\n      //>>includeEnd('debug');\n\n      if (this._nearestSampling !== nearestSampling) {\n        this._nearestSampling = nearestSampling;\n        this._shaderDirty = true;\n      }\n    }\n  },\n  /**\n   * Controls how quickly to blend between different levels of the tree.\n   * 0.0 means an instantaneous pop.\n   * 1.0 means a full linear blend.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {number}\n   * @private\n   */\n  levelBlendFactor: {\n    get: function () {\n      return this._levelBlendFactor;\n    },\n    set: function (levelBlendFactor) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"levelBlendFactor\", levelBlendFactor);\n      //>>includeEnd('debug');\n\n      this._levelBlendFactor = CesiumMath.clamp(levelBlendFactor, 0.0, 1.0);\n    }\n  },\n  /**\n   * Gets or sets the screen space error in pixels. If the screen space size\n   * of a voxel is greater than the screen space error, the tile is subdivided.\n   * Lower screen space error corresponds with higher detail rendering, but could\n   * result in worse performance and higher memory consumption.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {number}\n   */\n  screenSpaceError: {\n    get: function () {\n      return this._screenSpaceError;\n    },\n    set: function (screenSpaceError) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"screenSpaceError\", screenSpaceError);\n      //>>includeEnd('debug');\n\n      this._screenSpaceError = screenSpaceError;\n    }\n  },\n  /**\n   * Gets or sets the step size multiplier used during raymarching.\n   * The lower the value, the higher the rendering quality, but\n   * also the worse the performance.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {number}\n   */\n  stepSize: {\n    get: function () {\n      return this._stepSizeMultiplier;\n    },\n    set: function (stepSize) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"stepSize\", stepSize);\n      //>>includeEnd('debug');\n\n      this._stepSizeMultiplier = stepSize;\n    }\n  },\n  /**\n   * Gets or sets the minimum bounds in the shape's local coordinate system.\n   * Voxel data is stretched or squashed to fit the bounds.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   */\n  minBounds: {\n    get: function () {\n      return this._minBounds;\n    },\n    set: function (minBounds) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"minBounds\", minBounds);\n      //>>includeEnd('debug');\n\n      this._minBounds = Cartesian3.clone(minBounds, this._minBounds);\n    }\n  },\n  /**\n   * Gets or sets the maximum bounds in the shape's local coordinate system.\n   * Voxel data is stretched or squashed to fit the bounds.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   */\n  maxBounds: {\n    get: function () {\n      return this._maxBounds;\n    },\n    set: function (maxBounds) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"maxBounds\", maxBounds);\n      //>>includeEnd('debug');\n\n      this._maxBounds = Cartesian3.clone(maxBounds, this._maxBounds);\n    }\n  },\n  /**\n   * Gets or sets the minimum clipping location in the shape's local coordinate system.\n   * Any voxel content outside the range is clipped.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   */\n  minClippingBounds: {\n    get: function () {\n      return this._minClippingBounds;\n    },\n    set: function (minClippingBounds) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"minClippingBounds\", minClippingBounds);\n      //>>includeEnd('debug');\n\n      this._minClippingBounds = Cartesian3.clone(minClippingBounds, this._minClippingBounds);\n    }\n  },\n  /**\n   * Gets or sets the maximum clipping location in the shape's local coordinate system.\n   * Any voxel content outside the range is clipped.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   */\n  maxClippingBounds: {\n    get: function () {\n      return this._maxClippingBounds;\n    },\n    set: function (maxClippingBounds) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"maxClippingBounds\", maxClippingBounds);\n      //>>includeEnd('debug');\n\n      this._maxClippingBounds = Cartesian3.clone(maxClippingBounds, this._maxClippingBounds);\n    }\n  },\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering the primitive.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {ClippingPlaneCollection}\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._clippingPlanes;\n    },\n    set: function (clippingPlanes) {\n      // Don't need to check if undefined, it's handled in the setOwner function\n      ClippingPlaneCollection.setOwner(clippingPlanes, this, \"_clippingPlanes\");\n    }\n  },\n  /**\n   * Gets or sets the custom shader. If undefined, {@link VoxelPrimitive.DefaultCustomShader} is set.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {CustomShader}\n   * @see {@link https://github.com/CesiumGS/cesium/tree/main/Documentation/CustomShaderGuide|Custom Shader Guide}\n   */\n  customShader: {\n    get: function () {\n      return this._customShader;\n    },\n    set: function (customShader) {\n      if (this._customShader !== customShader) {\n        // Delete old custom shader entries from the uniform map\n        const uniformMap = this._uniformMap;\n        const oldCustomShader = this._customShader;\n        const oldCustomShaderUniformMap = oldCustomShader.uniformMap;\n        for (const uniformName in oldCustomShaderUniformMap) {\n          if (oldCustomShaderUniformMap.hasOwnProperty(uniformName)) {\n            // If the custom shader was set but the voxel shader was never\n            // built, the custom shader uniforms wouldn't have been added to\n            // the uniform map. But it doesn't matter because the delete\n            // operator ignores if the key doesn't exist.\n            delete uniformMap[uniformName];\n          }\n        }\n        if (!defined(customShader)) {\n          this._customShader = VoxelPrimitive.DefaultCustomShader;\n        } else {\n          this._customShader = customShader;\n        }\n        this._shaderDirty = true;\n      }\n    }\n  },\n  /**\n   * Gets an event that is raised whenever a custom shader is compiled.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Event}\n   * @readonly\n   */\n  customShaderCompilationEvent: {\n    get: function () {\n      return this._customShaderCompilationEvent;\n    }\n  },\n  /**\n   *  Loading and rendering information for requested content\n   * To use `visited` and `numberOfTilesWithContentReady` statistics, set options._calculateStatistics` to `true` in the constructor.\n   * @type {Cesium3DTilesetStatistics}\n   * @readonly\n   * @private\n   */\n  statistics: {\n    get: function () {\n      return this._statistics;\n    }\n  }\n});\nconst scratchIntersect = new Cartesian4();\nconst scratchNdcAabb = new Cartesian4();\nconst scratchTransformPositionLocalToWorld = new Matrix4();\nconst scratchTransformPositionLocalToProjection = new Matrix4();\nconst scratchCameraPositionShapeUv = new Cartesian3();\nconst scratchCameraTileCoordinates = new Cartesian4();\n\n/**\n * Updates the voxel primitive.\n *\n * @param {FrameState} frameState\n * @private\n */\nVoxelPrimitive.prototype.update = function (frameState) {\n  const provider = this._provider;\n  const uniforms = this._uniforms;\n\n  // Update the custom shader in case it has texture uniforms.\n  this._customShader.update(frameState);\n\n  // Initialize from the ready provider. This only happens once.\n  const context = frameState.context;\n  if (!this._ready) {\n    initFromProvider(this, provider, context);\n    // Set the primitive as ready after the first frame render since the user might set up events subscribed to\n    // the post render event, and the primitive may not be ready for those past the first frame.\n    frameState.afterRender.push(() => {\n      this._ready = true;\n      return true;\n    });\n\n    // Don't render until the next frame after ready is set to true\n    return;\n  }\n  updateVerticalExaggeration(this, frameState);\n\n  // Check if the shape is dirty before updating it. This needs to happen every\n  // frame because the member variables can be modified externally via the\n  // getters.\n  const shapeDirty = checkTransformAndBounds(this, provider);\n  if (shapeDirty) {\n    this._shapeVisible = updateShapeAndTransforms(this);\n    if (checkShapeDefines(this)) {\n      this._shaderDirty = true;\n    }\n  }\n  if (!this._shapeVisible) {\n    return;\n  }\n  this._shape.updateViewTransforms(frameState);\n\n  // Update the traversal and prepare for rendering.\n  const keyframeLocation = getKeyframeLocation(provider.timeIntervalCollection, this._clock);\n  const traversal = this._traversal;\n  const sampleCountOld = traversal._sampleCount;\n  traversal.update(frameState, keyframeLocation, shapeDirty,\n  // recomputeBoundingVolumes\n  this._disableUpdate // pauseUpdate\n  );\n  if (sampleCountOld !== traversal._sampleCount) {\n    this._shaderDirty = true;\n  }\n  if (!traversal.isRenderable(traversal.rootNode)) {\n    return;\n  }\n  if (this._debugDraw) {\n    // Debug draw bounding boxes and other things. Must go after traversal update\n    // because that's what updates the tile bounding boxes.\n    debugDraw(this, frameState);\n  }\n  if (this._disableRender) {\n    return;\n  }\n\n  // Check if log depth changed\n  if (this._useLogDepth !== frameState.useLogDepth) {\n    this._useLogDepth = frameState.useLogDepth;\n    this._shaderDirty = true;\n  }\n\n  // Check if clipping planes changed\n  const clippingPlanesChanged = updateClippingPlanes(this, frameState);\n  if (clippingPlanesChanged) {\n    this._shaderDirty = true;\n  }\n  const leafNodeTexture = traversal.leafNodeTexture;\n  if (defined(leafNodeTexture)) {\n    uniforms.octreeLeafNodeTexture = traversal.leafNodeTexture;\n    uniforms.octreeLeafNodeTexelSizeUv = Cartesian2.clone(traversal.leafNodeTexelSizeUv, uniforms.octreeLeafNodeTexelSizeUv);\n    uniforms.octreeLeafNodeTilesPerRow = traversal.leafNodeTilesPerRow;\n  }\n\n  // Rebuild shaders\n  if (this._shaderDirty) {\n    buildVoxelDrawCommands(this, context);\n    this._shaderDirty = false;\n  }\n\n  // Calculate the NDC-space AABB to \"scissor\" the fullscreen quad\n  const transformPositionWorldToProjection = context.uniformState.viewProjection;\n  const {\n    orientedBoundingBox\n  } = this._shape;\n  const ndcAabb = orientedBoundingBoxToNdcAabb(orientedBoundingBox, transformPositionWorldToProjection, scratchNdcAabb);\n\n  // If the object is offscreen, don't render it.\n  const offscreen = ndcAabb.x === +1.0 || ndcAabb.y === +1.0 || ndcAabb.z === -1.0 || ndcAabb.w === -1.0;\n  if (offscreen) {\n    return;\n  }\n\n  // Prepare to render: update uniforms that can change every frame\n  // Using a uniform instead of going through RenderState's scissor because the viewport is not accessible here, and the scissor command needs pixel coordinates.\n  uniforms.ndcSpaceAxisAlignedBoundingBox = Cartesian4.clone(ndcAabb, uniforms.ndcSpaceAxisAlignedBoundingBox);\n  const transformPositionViewToWorld = context.uniformState.inverseView;\n  const transformPositionViewToLocal = Matrix4.multiplyTransformation(this._transformPositionWorldToLocal, transformPositionViewToWorld, uniforms.transformPositionViewToLocal);\n  this._transformPlaneLocalToView = Matrix4.transpose(transformPositionViewToLocal, this._transformPlaneLocalToView);\n  const transformDirectionViewToWorld = context.uniformState.inverseViewRotation;\n  uniforms.transformDirectionViewToLocal = Matrix3.multiply(this._transformDirectionWorldToLocal, transformDirectionViewToWorld, uniforms.transformDirectionViewToLocal);\n  uniforms.cameraPositionLocal = Matrix4.multiplyByPoint(this._transformPositionWorldToLocal, frameState.camera.positionWC, uniforms.cameraPositionLocal);\n  uniforms.cameraDirectionLocal = Matrix3.multiplyByVector(this._transformDirectionWorldToLocal, frameState.camera.directionWC, uniforms.cameraDirectionLocal);\n  const cameraTileCoordinates = getTileCoordinates(this, uniforms.cameraPositionLocal, scratchCameraTileCoordinates);\n  uniforms.cameraTileCoordinates = Cartesian4.fromElements(Math.floor(cameraTileCoordinates.x), Math.floor(cameraTileCoordinates.y), Math.floor(cameraTileCoordinates.z), cameraTileCoordinates.w, uniforms.cameraTileCoordinates);\n  uniforms.cameraTileUv = Cartesian3.fromElements(cameraTileCoordinates.x - Math.floor(cameraTileCoordinates.x), cameraTileCoordinates.y - Math.floor(cameraTileCoordinates.y), cameraTileCoordinates.z - Math.floor(cameraTileCoordinates.z), uniforms.cameraTileUv);\n  uniforms.stepSize = this._stepSizeMultiplier;\n  updateRenderBoundPlanes(this, frameState);\n\n  // Render the primitive\n  const command = frameState.passes.pick ? this._drawCommandPick : frameState.passes.pickVoxel ? this._drawCommandPickVoxel : this._drawCommand;\n  command.boundingVolume = this._shape.boundingSphere;\n  frameState.commandList.push(command);\n};\nfunction updateRenderBoundPlanes(primitive, frameState) {\n  const uniforms = primitive._uniforms;\n  const {\n    renderBoundPlanes\n  } = primitive._shape;\n  if (!defined(renderBoundPlanes)) {\n    return;\n  }\n  renderBoundPlanes.update(frameState, primitive._transformPlaneLocalToView);\n  uniforms.renderBoundPlanesTexture = renderBoundPlanes.texture;\n}\n\n/**\n * Converts a position in local space to tile coordinates.\n *\n * @param {VoxelPrimitive} primitive The primitive to get the tile coordinates for.\n * @param {Cartesian3} positionLocal The position in local space to convert to tile coordinates.\n * @param {Cartesian4} result The result object to store the tile coordinates.\n * @returns {Cartesian4} The tile coordinates of the supplied position.\n * @private\n */\nfunction getTileCoordinates(primitive, positionLocal, result) {\n  const shapeUv = primitive._shape.convertLocalToShapeUvSpace(positionLocal, scratchCameraPositionShapeUv);\n  const availableLevels = primitive._availableLevels;\n  const numTiles = 2 ** (availableLevels - 1);\n  return Cartesian4.fromElements(shapeUv.x * numTiles, shapeUv.y * numTiles, shapeUv.z * numTiles, availableLevels - 1, result);\n}\nconst scratchExaggerationScale = new Cartesian3();\nconst scratchExaggerationCenter = new Cartesian3();\nconst scratchCartographicCenter = new Cartographic();\nconst scratchExaggerationTranslation = new Cartesian3();\n\n/**\n * Update the exaggerated bounds of a primitive to account for vertical exaggeration\n * @param {VoxelPrimitive} primitive\n * @param {FrameState} frameState\n * @private\n */\nfunction updateVerticalExaggeration(primitive, frameState) {\n  primitive._exaggeratedMinBounds = Cartesian3.clone(primitive._minBounds, primitive._exaggeratedMinBounds);\n  primitive._exaggeratedMaxBounds = Cartesian3.clone(primitive._maxBounds, primitive._exaggeratedMaxBounds);\n  if (primitive.shape === VoxelShapeType.ELLIPSOID) {\n    // Apply the exaggeration by stretching the height bounds\n    const relativeHeight = frameState.verticalExaggerationRelativeHeight;\n    const exaggeration = frameState.verticalExaggeration;\n    primitive._exaggeratedMinBounds.z = (primitive._minBounds.z - relativeHeight) * exaggeration + relativeHeight;\n    primitive._exaggeratedMaxBounds.z = (primitive._maxBounds.z - relativeHeight) * exaggeration + relativeHeight;\n  } else {\n    // Apply the exaggeration via the model matrix\n    const exaggerationScale = Cartesian3.fromElements(1.0, 1.0, frameState.verticalExaggeration, scratchExaggerationScale);\n    primitive._exaggeratedModelMatrix = Matrix4.multiplyByScale(primitive._modelMatrix, exaggerationScale, primitive._exaggeratedModelMatrix);\n    primitive._exaggeratedModelMatrix = Matrix4.multiplyByTranslation(primitive._exaggeratedModelMatrix, computeBoxExaggerationTranslation(primitive, frameState), primitive._exaggeratedModelMatrix);\n  }\n}\nfunction computeBoxExaggerationTranslation(primitive, frameState) {\n  // Compute translation based on box center, relative height, and exaggeration\n  const {\n    shapeTransform = Matrix4.IDENTITY,\n    globalTransform = Matrix4.IDENTITY\n  } = primitive._provider;\n\n  // Find the Cartesian position of the center of the OBB\n  const initialCenter = Matrix4.getTranslation(shapeTransform, scratchExaggerationCenter);\n  const intermediateCenter = Matrix4.multiplyByPoint(primitive._modelMatrix, initialCenter, scratchExaggerationCenter);\n  const transformedCenter = Matrix4.multiplyByPoint(globalTransform, intermediateCenter, scratchExaggerationCenter);\n\n  // Find the cartographic height\n  const ellipsoid = Ellipsoid.WGS84;\n  const centerCartographic = ellipsoid.cartesianToCartographic(transformedCenter, scratchCartographicCenter);\n  let centerHeight = 0.0;\n  if (defined(centerCartographic)) {\n    centerHeight = centerCartographic.height;\n  }\n\n  // Find the shift that will put the center in the right position relative\n  // to relativeHeight, after it is scaled by verticalExaggeration\n  const exaggeratedHeight = VerticalExaggeration.getHeight(centerHeight, frameState.verticalExaggeration, frameState.verticalExaggerationRelativeHeight);\n  return Cartesian3.fromElements(0.0, 0.0, (exaggeratedHeight - centerHeight) / frameState.verticalExaggeration, scratchExaggerationTranslation);\n}\n\n/**\n * Initialize primitive properties that are derived from the voxel provider\n * @param {VoxelPrimitive} primitive\n * @param {VoxelProvider} provider\n * @param {Context} context\n * @private\n */\nfunction initFromProvider(primitive, provider, context) {\n  const uniforms = primitive._uniforms;\n  primitive._pickId = context.createPickId({\n    primitive\n  });\n  uniforms.pickColor = Color.clone(primitive._pickId.color, uniforms.pickColor);\n  const {\n    shaderDefines,\n    shaderUniforms: shapeUniforms\n  } = primitive._shape;\n  primitive._shapeDefinesOld = clone(shaderDefines, true);\n\n  // Add shape uniforms to the uniform map\n  const uniformMap = primitive._uniformMap;\n  for (const key in shapeUniforms) {\n    if (shapeUniforms.hasOwnProperty(key)) {\n      const name = `u_${key}`;\n\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(uniformMap[name])) {\n        oneTimeWarning(`VoxelPrimitive: Uniform name \"${name}\" is already defined`);\n      }\n      //>>includeEnd('debug');\n\n      uniformMap[name] = function () {\n        return shapeUniforms[key];\n      };\n    }\n  }\n\n  // Set uniforms that come from the provider.\n  // Note that minBounds and maxBounds can be set dynamically, so their uniforms aren't set here.\n  primitive._dimensions = Cartesian3.clone(provider.dimensions, primitive._dimensions);\n  uniforms.dimensions = Cartesian3.clone(primitive._dimensions, uniforms.dimensions);\n  primitive._paddingBefore = Cartesian3.clone(provider.paddingBefore ?? Cartesian3.ZERO, primitive._paddingBefore);\n  uniforms.paddingBefore = Cartesian3.clone(primitive._paddingBefore, uniforms.paddingBefore);\n  primitive._paddingAfter = Cartesian3.clone(provider.paddingAfter ?? Cartesian3.ZERO, primitive._paddingAfter);\n  uniforms.paddingAfter = Cartesian3.clone(primitive._paddingAfter, uniforms.paddingAfter);\n  primitive._inputDimensions = Cartesian3.add(primitive._dimensions, primitive._paddingBefore, primitive._inputDimensions);\n  primitive._inputDimensions = Cartesian3.add(primitive._inputDimensions, primitive._paddingAfter, primitive._inputDimensions);\n  if (provider.metadataOrder === VoxelMetadataOrder.Y_UP) {\n    const inputDimensionsY = primitive._inputDimensions.y;\n    primitive._inputDimensions.y = primitive._inputDimensions.z;\n    primitive._inputDimensions.z = inputDimensionsY;\n  }\n  uniforms.inputDimensions = Cartesian3.clone(primitive._inputDimensions, uniforms.inputDimensions);\n  primitive._availableLevels = provider.availableLevels ?? 1;\n\n  // Create the VoxelTraversal, and set related uniforms\n  const keyframeCount = provider.keyframeCount ?? 1;\n  primitive._traversal = new VoxelTraversal(primitive, context, keyframeCount);\n  primitive.statistics.texturesByteLength = primitive._traversal.textureMemoryByteLength;\n  setTraversalUniforms(primitive._traversal, uniforms);\n}\n\n/**\n * Track changes in provider transform and primitive bounds\n * @param {VoxelPrimitive} primitive\n * @param {VoxelProvider} provider\n * @returns {boolean} Whether any of the transform or bounds changed\n * @private\n */\nfunction checkTransformAndBounds(primitive, provider) {\n  const shapeTransform = provider.shapeTransform ?? Matrix4.IDENTITY;\n  const globalTransform = provider.globalTransform ?? Matrix4.IDENTITY;\n\n  // Compound model matrix = global transform * model matrix * shape transform\n  Matrix4.multiplyTransformation(globalTransform, primitive._exaggeratedModelMatrix, primitive._compoundModelMatrix);\n  Matrix4.multiplyTransformation(primitive._compoundModelMatrix, shapeTransform, primitive._compoundModelMatrix);\n  const numChanges = updateBound(primitive, \"_compoundModelMatrix\", \"_compoundModelMatrixOld\") + updateBound(primitive, \"_minBounds\", \"_minBoundsOld\") + updateBound(primitive, \"_maxBounds\", \"_maxBoundsOld\") + updateBound(primitive, \"_exaggeratedMinBounds\", \"_exaggeratedMinBoundsOld\") + updateBound(primitive, \"_exaggeratedMaxBounds\", \"_exaggeratedMaxBoundsOld\") + updateBound(primitive, \"_minClippingBounds\", \"_minClippingBoundsOld\") + updateBound(primitive, \"_maxClippingBounds\", \"_maxClippingBoundsOld\");\n  return numChanges > 0;\n}\n\n/**\n * Compare old and new values of a bound and update the old if it is different.\n * @param {VoxelPrimitive} primitive The primitive with bounds properties\n * @param {string} newBoundKey A key pointing to a bounds property of type Cartesian3 or Matrix4\n * @param {string} oldBoundKey A key pointing to a bounds property of the same type as the property at newBoundKey\n * @returns {number} 1 if the bound value changed, 0 otherwise\n *\n * @private\n */\nfunction updateBound(primitive, newBoundKey, oldBoundKey) {\n  const newBound = primitive[newBoundKey];\n  const oldBound = primitive[oldBoundKey];\n  const changed = !newBound.equals(oldBound);\n  if (changed) {\n    newBound.clone(oldBound);\n  }\n  return changed ? 1 : 0;\n}\n\n/**\n * Update the shape and related transforms\n * @param {VoxelPrimitive} primitive\n * @returns {boolean} True if the shape is visible\n * @private\n */\nfunction updateShapeAndTransforms(primitive) {\n  const shape = primitive._shape;\n  const visible = shape.update(primitive._compoundModelMatrix, primitive._exaggeratedMinBounds, primitive._exaggeratedMaxBounds, primitive.minClippingBounds, primitive.maxClippingBounds);\n  if (!visible) {\n    return false;\n  }\n  primitive._transformPositionLocalToWorld = Matrix4.clone(shape.shapeTransform, primitive._transformPositionLocalToWorld);\n  primitive._transformPositionWorldToLocal = Matrix4.inverse(primitive._transformPositionLocalToWorld, primitive._transformPositionWorldToLocal);\n  primitive._transformDirectionWorldToLocal = Matrix4.getMatrix3(primitive._transformPositionWorldToLocal, primitive._transformDirectionWorldToLocal);\n  return true;\n}\n\n/**\n * Set uniforms that come from the traversal.\n * @param {VoxelTraversal} traversal\n * @param {object} uniforms\n * @private\n */\nfunction setTraversalUniforms(traversal, uniforms) {\n  uniforms.octreeInternalNodeTexture = traversal.internalNodeTexture;\n  uniforms.octreeInternalNodeTexelSizeUv = Cartesian2.clone(traversal.internalNodeTexelSizeUv, uniforms.octreeInternalNodeTexelSizeUv);\n  uniforms.octreeInternalNodeTilesPerRow = traversal.internalNodeTilesPerRow;\n  const megatextures = traversal.megatextures;\n  const megatexture = megatextures[0];\n  const megatextureLength = megatextures.length;\n  uniforms.megatextureTextures = new Array(megatextureLength);\n  for (let i = 0; i < megatextureLength; i++) {\n    uniforms.megatextureTextures[i] = megatextures[i].texture;\n  }\n  uniforms.megatextureSliceDimensions = Cartesian2.clone(megatexture.sliceCountPerRegion, uniforms.megatextureSliceDimensions);\n  uniforms.megatextureTileDimensions = Cartesian2.clone(megatexture.regionCountPerMegatexture, uniforms.megatextureTileDimensions);\n  uniforms.megatextureVoxelSizeUv = Cartesian2.clone(megatexture.voxelSizeUv, uniforms.megatextureVoxelSizeUv);\n  uniforms.megatextureSliceSizeUv = Cartesian2.clone(megatexture.sliceSizeUv, uniforms.megatextureSliceSizeUv);\n  uniforms.megatextureTileSizeUv = Cartesian2.clone(megatexture.regionSizeUv, uniforms.megatextureTileSizeUv);\n}\n\n/**\n * Track changes in shape-related shader defines\n * @param {VoxelPrimitive} primitive\n * @returns {boolean} True if any of the shape defines changed, requiring a shader rebuild\n * @private\n */\nfunction checkShapeDefines(primitive) {\n  const {\n    shaderDefines\n  } = primitive._shape;\n  const shapeDefinesChanged = Object.keys(shaderDefines).some(key => shaderDefines[key] !== primitive._shapeDefinesOld[key]);\n  if (shapeDefinesChanged) {\n    primitive._shapeDefinesOld = clone(shaderDefines, true);\n  }\n  return shapeDefinesChanged;\n}\n\n/**\n * Find the keyframe location to render at. Doesn't need to be a whole number.\n * @param {TimeIntervalCollection} timeIntervalCollection\n * @param {Clock} clock\n * @returns {number}\n *\n * @private\n */\nfunction getKeyframeLocation(timeIntervalCollection, clock) {\n  if (!defined(timeIntervalCollection) || !defined(clock)) {\n    return 0.0;\n  }\n  let date = clock.currentTime;\n  let timeInterval;\n  let timeIntervalIndex = timeIntervalCollection.indexOf(date);\n  if (timeIntervalIndex >= 0) {\n    timeInterval = timeIntervalCollection.get(timeIntervalIndex);\n  } else {\n    // Date fell outside the range\n    timeIntervalIndex = ~timeIntervalIndex;\n    if (timeIntervalIndex === timeIntervalCollection.length) {\n      // Date past range\n      timeIntervalIndex = timeIntervalCollection.length - 1;\n      timeInterval = timeIntervalCollection.get(timeIntervalIndex);\n      date = timeInterval.stop;\n    } else {\n      // Date before range\n      timeInterval = timeIntervalCollection.get(timeIntervalIndex);\n      date = timeInterval.start;\n    }\n  }\n  // De-lerp between the start and end of the interval\n  const totalSeconds = JulianDate.secondsDifference(timeInterval.stop, timeInterval.start);\n  const secondsDifferenceStart = JulianDate.secondsDifference(date, timeInterval.start);\n  const t = secondsDifferenceStart / totalSeconds;\n  return timeIntervalIndex + t;\n}\n\n/**\n * Update the clipping planes state and associated uniforms\n *\n * @param {VoxelPrimitive} primitive\n * @param {FrameState} frameState\n * @returns {boolean} Whether the clipping planes changed, requiring a shader rebuild\n * @private\n */\nfunction updateClippingPlanes(primitive, frameState) {\n  const clippingPlanes = primitive.clippingPlanes;\n  if (!defined(clippingPlanes)) {\n    return false;\n  }\n  clippingPlanes.update(frameState);\n  const {\n    clippingPlanesState,\n    enabled\n  } = clippingPlanes;\n  if (enabled) {\n    const uniforms = primitive._uniforms;\n    uniforms.clippingPlanesTexture = clippingPlanes.texture;\n\n    // Compute the clipping plane's transformation to local space and then take the inverse\n    // transpose to properly transform the hessian normal form of the plane.\n\n    // transpose(inverse(worldToLocal * clippingPlaneLocalToWorld))\n    // transpose(inverse(clippingPlaneLocalToWorld) * inverse(worldToLocal))\n    // transpose(inverse(clippingPlaneLocalToWorld) * localToWorld)\n\n    uniforms.clippingPlanesMatrix = Matrix4.transpose(Matrix4.multiplyTransformation(Matrix4.inverse(clippingPlanes.modelMatrix, uniforms.clippingPlanesMatrix), primitive._transformPositionLocalToWorld, uniforms.clippingPlanesMatrix), uniforms.clippingPlanesMatrix);\n  }\n  if (primitive._clippingPlanesState === clippingPlanesState && primitive._clippingPlanesEnabled === enabled) {\n    return false;\n  }\n  primitive._clippingPlanesState = clippingPlanesState;\n  primitive._clippingPlanesEnabled = enabled;\n  return true;\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see VoxelPrimitive#destroy\n */\nVoxelPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see VoxelPrimitive#isDestroyed\n *\n * @example\n * voxelPrimitive = voxelPrimitive && voxelPrimitive.destroy();\n */\nVoxelPrimitive.prototype.destroy = function () {\n  const drawCommand = this._drawCommand;\n  if (defined(drawCommand)) {\n    drawCommand.shaderProgram = drawCommand.shaderProgram && drawCommand.shaderProgram.destroy();\n  }\n  const drawCommandPick = this._drawCommandPick;\n  if (defined(drawCommandPick)) {\n    drawCommandPick.shaderProgram = drawCommandPick.shaderProgram && drawCommandPick.shaderProgram.destroy();\n  }\n  this._pickId = this._pickId && this._pickId.destroy();\n  this._traversal = this._traversal && this._traversal.destroy();\n  this.statistics.texturesByteLength = 0;\n  this._clippingPlanes = this._clippingPlanes && this._clippingPlanes.destroy();\n  return destroyObject(this);\n};\nconst corners = new Array(new Cartesian4(-1.0, -1.0, -1.0, 1.0), new Cartesian4(+1.0, -1.0, -1.0, 1.0), new Cartesian4(-1.0, +1.0, -1.0, 1.0), new Cartesian4(+1.0, +1.0, -1.0, 1.0), new Cartesian4(-1.0, -1.0, +1.0, 1.0), new Cartesian4(+1.0, -1.0, +1.0, 1.0), new Cartesian4(-1.0, +1.0, +1.0, 1.0), new Cartesian4(+1.0, +1.0, +1.0, 1.0));\nconst vertexNeighborIndices = new Array(1, 2, 4, 0, 3, 5, 0, 3, 6, 1, 2, 7, 0, 5, 6, 1, 4, 7, 2, 4, 7, 3, 5, 6);\nconst scratchCornersClipSpace = new Array(new Cartesian4(), new Cartesian4(), new Cartesian4(), new Cartesian4(), new Cartesian4(), new Cartesian4(), new Cartesian4(), new Cartesian4());\n\n/**\n * Projects all 8 corners of the oriented bounding box to NDC space and finds the\n * resulting NDC axis aligned bounding box. To avoid projecting a vertex that is\n * behind the near plane, it uses the intersection point of each of the vertex's\n * edges against the near plane as part of the AABB calculation. This is done in\n * clip space prior to perspective division.\n *\n * @function\n *\n * @param {OrientedBoundingBox} orientedBoundingBox\n * @param {Matrix4} worldToProjection\n * @param {Cartesian4} result\n * @returns {Cartesian4}\n *\n * @private\n */\nfunction orientedBoundingBoxToNdcAabb(orientedBoundingBox, worldToProjection, result) {\n  const transformPositionLocalToWorld = Matrix4.fromRotationTranslation(orientedBoundingBox.halfAxes, orientedBoundingBox.center, scratchTransformPositionLocalToWorld);\n  const transformPositionLocalToProjection = Matrix4.multiply(worldToProjection, transformPositionLocalToWorld, scratchTransformPositionLocalToProjection);\n  let ndcMinX = +Number.MAX_VALUE;\n  let ndcMaxX = -Number.MAX_VALUE;\n  let ndcMinY = +Number.MAX_VALUE;\n  let ndcMaxY = -Number.MAX_VALUE;\n  let cornerIndex;\n\n  // Convert all points to clip space\n  const cornersClipSpace = scratchCornersClipSpace;\n  const cornersLength = corners.length;\n  for (cornerIndex = 0; cornerIndex < cornersLength; cornerIndex++) {\n    Matrix4.multiplyByVector(transformPositionLocalToProjection, corners[cornerIndex], cornersClipSpace[cornerIndex]);\n  }\n  for (cornerIndex = 0; cornerIndex < cornersLength; cornerIndex++) {\n    const position = cornersClipSpace[cornerIndex];\n    if (position.z >= -position.w) {\n      // Position is past near plane, so there's no need to clip.\n      const ndcX = position.x / position.w;\n      const ndcY = position.y / position.w;\n      ndcMinX = Math.min(ndcMinX, ndcX);\n      ndcMaxX = Math.max(ndcMaxX, ndcX);\n      ndcMinY = Math.min(ndcMinY, ndcY);\n      ndcMaxY = Math.max(ndcMaxY, ndcY);\n    } else {\n      for (let neighborIndex = 0; neighborIndex < 3; neighborIndex++) {\n        const neighborVertexIndex = vertexNeighborIndices[cornerIndex * 3 + neighborIndex];\n        const neighborPosition = cornersClipSpace[neighborVertexIndex];\n        if (neighborPosition.z >= -neighborPosition.w) {\n          // Position is behind the near plane and neighbor is after, so get intersection point on the near plane.\n          const distanceToPlaneFromPosition = position.z + position.w;\n          const distanceToPlaneFromNeighbor = neighborPosition.z + neighborPosition.w;\n          const t = distanceToPlaneFromPosition / (distanceToPlaneFromPosition - distanceToPlaneFromNeighbor);\n          const intersect = Cartesian4.lerp(position, neighborPosition, t, scratchIntersect);\n          const intersectNdcX = intersect.x / intersect.w;\n          const intersectNdcY = intersect.y / intersect.w;\n          ndcMinX = Math.min(ndcMinX, intersectNdcX);\n          ndcMaxX = Math.max(ndcMaxX, intersectNdcX);\n          ndcMinY = Math.min(ndcMinY, intersectNdcY);\n          ndcMaxY = Math.max(ndcMaxY, intersectNdcY);\n        }\n      }\n    }\n  }\n\n  // Clamp the NDC values to -1 to +1 range even if they extend much further.\n  ndcMinX = CesiumMath.clamp(ndcMinX, -1.0, +1.0);\n  ndcMinY = CesiumMath.clamp(ndcMinY, -1.0, +1.0);\n  ndcMaxX = CesiumMath.clamp(ndcMaxX, -1.0, +1.0);\n  ndcMaxY = CesiumMath.clamp(ndcMaxY, -1.0, +1.0);\n  result = Cartesian4.fromElements(ndcMinX, ndcMinY, ndcMaxX, ndcMaxY, result);\n  return result;\n}\nconst polylineAxisDistance = 30000000.0;\nconst polylineXAxis = new Cartesian3(polylineAxisDistance, 0.0, 0.0);\nconst polylineYAxis = new Cartesian3(0.0, polylineAxisDistance, 0.0);\nconst polylineZAxis = new Cartesian3(0.0, 0.0, polylineAxisDistance);\n\n/**\n * Draws the tile bounding boxes and axes.\n *\n * @function\n *\n * @param {VoxelPrimitive} that\n * @param {FrameState} frameState\n *\n * @private\n */\nfunction debugDraw(that, frameState) {\n  const traversal = that._traversal;\n  const polylines = that._debugPolylines;\n  polylines.removeAll();\n  function makePolylineLineSegment(startPos, endPos, color, thickness) {\n    polylines.add({\n      positions: [startPos, endPos],\n      width: thickness,\n      material: Material.fromType(\"Color\", {\n        color: color\n      })\n    });\n  }\n  function makePolylineBox(orientedBoundingBox, color, thickness) {\n    // Normally would want to use a scratch variable to store the corners, but\n    // polylines don't clone the positions.\n    const corners = orientedBoundingBox.computeCorners();\n    makePolylineLineSegment(corners[0], corners[1], color, thickness);\n    makePolylineLineSegment(corners[2], corners[3], color, thickness);\n    makePolylineLineSegment(corners[4], corners[5], color, thickness);\n    makePolylineLineSegment(corners[6], corners[7], color, thickness);\n    makePolylineLineSegment(corners[0], corners[2], color, thickness);\n    makePolylineLineSegment(corners[4], corners[6], color, thickness);\n    makePolylineLineSegment(corners[1], corners[3], color, thickness);\n    makePolylineLineSegment(corners[5], corners[7], color, thickness);\n    makePolylineLineSegment(corners[0], corners[4], color, thickness);\n    makePolylineLineSegment(corners[2], corners[6], color, thickness);\n    makePolylineLineSegment(corners[1], corners[5], color, thickness);\n    makePolylineLineSegment(corners[3], corners[7], color, thickness);\n  }\n  function drawTile(tile) {\n    if (!traversal.isRenderable(tile)) {\n      return;\n    }\n    const level = tile.level;\n    const startThickness = 5.0;\n    const thickness = Math.max(1.0, startThickness / Math.pow(2.0, level));\n    const colors = [Color.RED, Color.LIME, Color.BLUE];\n    const color = colors[level % 3];\n    makePolylineBox(tile.orientedBoundingBox, color, thickness);\n    if (defined(tile.children)) {\n      for (let i = 0; i < 8; i++) {\n        drawTile(tile.children[i]);\n      }\n    }\n  }\n  makePolylineBox(that._shape.orientedBoundingBox, Color.WHITE, 5.0);\n  drawTile(traversal.rootNode);\n  const axisThickness = 10.0;\n  makePolylineLineSegment(Cartesian3.ZERO, polylineXAxis, Color.RED, axisThickness);\n  makePolylineLineSegment(Cartesian3.ZERO, polylineYAxis, Color.LIME, axisThickness);\n  makePolylineLineSegment(Cartesian3.ZERO, polylineZAxis, Color.BLUE, axisThickness);\n  polylines.update(frameState);\n}\n\n/**\n * The default custom shader used by the primitive.\n *\n * @type {CustomShader}\n * @constant\n * @readonly\n *\n * @private\n */\nVoxelPrimitive.DefaultCustomShader = new CustomShader({\n  fragmentShaderText: `void fragmentMain(FragmentInput fsInput, inout czm_modelMaterial material)\n{\n    material.diffuse = vec3(1.0);\n    material.alpha = 1.0;\n}`\n});\nfunction DefaultVoxelProvider() {\n  this.ready = true;\n  this.shape = VoxelShapeType.BOX;\n  this.dimensions = new Cartesian3(1, 1, 1);\n  this.names = [\"data\"];\n  this.types = [MetadataType.SCALAR];\n  this.componentTypes = [MetadataComponentType.FLOAT32];\n  this.maximumTileCount = 1;\n}\nDefaultVoxelProvider.prototype.requestData = function (options) {\n  const tileLevel = defined(options) ? options.tileLevel ?? 0 : 0;\n  if (tileLevel >= 1) {\n    return undefined;\n  }\n  const content = new VoxelContent({\n    metadata: [new Float32Array(1)]\n  });\n  return Promise.resolve(content);\n};\nVoxelPrimitive.DefaultProvider = new DefaultVoxelProvider();\nexport default VoxelPrimitive;","map":{"version":3,"names":["buildVoxelDrawCommands","Cartesian2","Cartesian3","Cartesian4","Cartographic","Cesium3DTilesetStatistics","CesiumMath","Check","Color","ClippingPlaneCollection","clone","CustomShader","Frozen","defined","destroyObject","Ellipsoid","Event","JulianDate","Material","Matrix3","Matrix4","MetadataComponentType","MetadataType","oneTimeWarning","PolylineCollection","VerticalExaggeration","VoxelContent","VoxelShapeType","VoxelTraversal","VoxelMetadataOrder","VoxelPrimitive","options","EMPTY_OBJECT","_ready","_provider","provider","DefaultProvider","_traversal","undefined","_statistics","_calculateStatistics","calculateStatistics","_shape","_shapeVisible","_dimensions","_inputDimensions","_paddingBefore","_paddingAfter","_availableLevels","_minBounds","_minBoundsOld","_maxBounds","_maxBoundsOld","_exaggeratedMinBounds","_exaggeratedMinBoundsOld","_exaggeratedMaxBounds","_exaggeratedMaxBoundsOld","_minClippingBounds","_minClippingBoundsOld","_maxClippingBounds","_maxClippingBoundsOld","_clippingPlanes","_clippingPlanesState","_clippingPlanesEnabled","_modelMatrix","modelMatrix","IDENTITY","_exaggeratedModelMatrix","_compoundModelMatrix","_compoundModelMatrixOld","_customShader","customShader","DefaultCustomShader","_customShaderCompilationEvent","_shaderDirty","_drawCommand","_drawCommandPick","_pickId","_clock","clock","_transformPositionLocalToWorld","_transformPositionWorldToLocal","_transformPlaneLocalToView","_transformDirectionWorldToLocal","_nearestSampling","_levelBlendFactor","_stepSizeMultiplier","_depthTest","_useLogDepth","_screenSpaceError","_debugPolylines","_debugDraw","_disableRender","_disableUpdate","_uniforms","octreeInternalNodeTexture","octreeInternalNodeTilesPerRow","octreeInternalNodeTexelSizeUv","octreeLeafNodeTexture","octreeLeafNodeTilesPerRow","octreeLeafNodeTexelSizeUv","megatextureTextures","megatextureSliceDimensions","megatextureTileDimensions","megatextureVoxelSizeUv","megatextureSliceSizeUv","megatextureTileSizeUv","dimensions","inputDimensions","paddingBefore","paddingAfter","transformPositionViewToLocal","transformDirectionViewToLocal","cameraPositionLocal","cameraDirectionLocal","cameraTileCoordinates","cameraTileUv","ndcSpaceAxisAlignedBoundingBox","clippingPlanesTexture","clippingPlanesMatrix","renderBoundPlanesTexture","stepSize","pickColor","_shapeDefinesOld","_uniformMap","uniforms","uniformMap","key","hasOwnProperty","name","tileLoad","tileVisible","tileFailed","tileUnload","loadProgress","allTilesLoaded","initialTilesLoaded","initialize","primitive","shape","shapeType","minBounds","getMinBounds","maxBounds","getMaxBounds","minClippingBounds","maxClippingBounds","checkTransformAndBounds","ShapeConstructor","getShapeConstructor","updateShapeAndTransforms","Object","defineProperties","prototype","ready","get","boundingSphere","orientedBoundingBox","set","typeOf","object","minimumValues","maximumValues","show","bool","disableUpdate","debugDraw","depthTest","nearestSampling","levelBlendFactor","number","clamp","screenSpaceError","clippingPlanes","setOwner","oldCustomShader","oldCustomShaderUniformMap","uniformName","customShaderCompilationEvent","statistics","scratchIntersect","scratchNdcAabb","scratchTransformPositionLocalToWorld","scratchTransformPositionLocalToProjection","scratchCameraPositionShapeUv","scratchCameraTileCoordinates","update","frameState","context","initFromProvider","afterRender","push","updateVerticalExaggeration","shapeDirty","checkShapeDefines","updateViewTransforms","keyframeLocation","getKeyframeLocation","timeIntervalCollection","traversal","sampleCountOld","_sampleCount","isRenderable","rootNode","useLogDepth","clippingPlanesChanged","updateClippingPlanes","leafNodeTexture","leafNodeTexelSizeUv","leafNodeTilesPerRow","transformPositionWorldToProjection","uniformState","viewProjection","ndcAabb","orientedBoundingBoxToNdcAabb","offscreen","x","y","z","w","transformPositionViewToWorld","inverseView","multiplyTransformation","transpose","transformDirectionViewToWorld","inverseViewRotation","multiply","multiplyByPoint","camera","positionWC","multiplyByVector","directionWC","getTileCoordinates","fromElements","Math","floor","updateRenderBoundPlanes","command","passes","pick","pickVoxel","_drawCommandPickVoxel","boundingVolume","commandList","renderBoundPlanes","texture","positionLocal","result","shapeUv","convertLocalToShapeUvSpace","availableLevels","numTiles","scratchExaggerationScale","scratchExaggerationCenter","scratchCartographicCenter","scratchExaggerationTranslation","ELLIPSOID","relativeHeight","verticalExaggerationRelativeHeight","exaggeration","verticalExaggeration","exaggerationScale","multiplyByScale","multiplyByTranslation","computeBoxExaggerationTranslation","shapeTransform","globalTransform","initialCenter","getTranslation","intermediateCenter","transformedCenter","ellipsoid","WGS84","centerCartographic","cartesianToCartographic","centerHeight","height","exaggeratedHeight","getHeight","createPickId","color","shaderDefines","shaderUniforms","shapeUniforms","ZERO","add","metadataOrder","Y_UP","inputDimensionsY","keyframeCount","texturesByteLength","textureMemoryByteLength","setTraversalUniforms","numChanges","updateBound","newBoundKey","oldBoundKey","newBound","oldBound","changed","equals","visible","inverse","getMatrix3","internalNodeTexture","internalNodeTexelSizeUv","internalNodeTilesPerRow","megatextures","megatexture","megatextureLength","length","Array","i","sliceCountPerRegion","regionCountPerMegatexture","voxelSizeUv","sliceSizeUv","regionSizeUv","shapeDefinesChanged","keys","some","date","currentTime","timeInterval","timeIntervalIndex","indexOf","stop","start","totalSeconds","secondsDifference","secondsDifferenceStart","t","clippingPlanesState","enabled","isDestroyed","destroy","drawCommand","shaderProgram","drawCommandPick","corners","vertexNeighborIndices","scratchCornersClipSpace","worldToProjection","transformPositionLocalToWorld","fromRotationTranslation","halfAxes","center","transformPositionLocalToProjection","ndcMinX","Number","MAX_VALUE","ndcMaxX","ndcMinY","ndcMaxY","cornerIndex","cornersClipSpace","cornersLength","position","ndcX","ndcY","min","max","neighborIndex","neighborVertexIndex","neighborPosition","distanceToPlaneFromPosition","distanceToPlaneFromNeighbor","intersect","lerp","intersectNdcX","intersectNdcY","polylineAxisDistance","polylineXAxis","polylineYAxis","polylineZAxis","that","polylines","removeAll","makePolylineLineSegment","startPos","endPos","thickness","positions","width","material","fromType","makePolylineBox","computeCorners","drawTile","tile","level","startThickness","pow","colors","RED","LIME","BLUE","children","WHITE","axisThickness","fragmentShaderText","DefaultVoxelProvider","BOX","names","types","SCALAR","componentTypes","FLOAT32","maximumTileCount","requestData","tileLevel","content","metadata","Float32Array","Promise","resolve"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/VoxelPrimitive.js"],"sourcesContent":["import buildVoxelDrawCommands from \"./buildVoxelDrawCommands.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Cesium3DTilesetStatistics from \"./Cesium3DTilesetStatistics.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport clone from \"../Core/clone.js\";\nimport CustomShader from \"./Model/CustomShader.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Event from \"../Core/Event.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport Material from \"./Material.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport MetadataComponentType from \"./MetadataComponentType.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport PolylineCollection from \"./PolylineCollection.js\";\nimport VerticalExaggeration from \"../Core/VerticalExaggeration.js\";\nimport VoxelContent from \"./VoxelContent.js\";\nimport VoxelShapeType from \"./VoxelShapeType.js\";\nimport VoxelTraversal from \"./VoxelTraversal.js\";\nimport VoxelMetadataOrder from \"./VoxelMetadataOrder.js\";\n\n/**\n * A primitive that renders voxel data from a {@link VoxelProvider}.\n *\n * @alias VoxelPrimitive\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {VoxelProvider} [options.provider] The voxel provider that supplies the primitive with tile data.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The model matrix used to transform the primitive.\n * @param {CustomShader} [options.customShader] The custom shader used to style the primitive.\n * @param {Clock} [options.clock] The clock used to control time dynamic behavior.\n * @param {Boolean} [options.calculateStatistics] Generate statistics for performance profile.\n *\n * @see VoxelProvider\n * @see Cesium3DTilesVoxelProvider\n * @see VoxelShapeType\n * @see {@link https://github.com/CesiumGS/cesium/tree/main/Documentation/CustomShaderGuide|Custom Shader Guide}\n *\n * @experimental This feature is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction VoxelPrimitive(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._ready = false;\n\n  /**\n   * @type {VoxelProvider}\n   * @private\n   */\n  this._provider = options.provider ?? VoxelPrimitive.DefaultProvider;\n\n  /**\n   * This member is not created until the provider and shape are ready.\n   *\n   * @type {VoxelTraversal}\n   * @private\n   */\n  this._traversal = undefined;\n\n  /**\n   * @type {Cesium3DTilesetStatistics}\n   * @private\n   */\n  this._statistics = new Cesium3DTilesetStatistics();\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._calculateStatistics = options.calculateStatistics ?? false;\n\n  /**\n   * This member is not created until the provider is ready.\n   *\n   * @type {VoxelShape}\n   * @private\n   */\n  this._shape = undefined;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._shapeVisible = false;\n\n  /**\n   * This member is not created until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._dimensions = new Cartesian3();\n\n  /**\n   * This member is not created until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._inputDimensions = new Cartesian3();\n\n  /**\n   * This member is not created until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._paddingBefore = new Cartesian3();\n\n  /**\n   * This member is not created until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._paddingAfter = new Cartesian3();\n\n  /**\n   * This member is not known until the provider is ready.\n   *\n   * @type {number}\n   * @private\n   */\n  this._availableLevels = 1;\n\n  /**\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._minBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the shape is dirty.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._minBoundsOld = new Cartesian3();\n\n  /**\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._maxBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the shape is dirty.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._maxBoundsOld = new Cartesian3();\n\n  /**\n   * Minimum bounds with vertical exaggeration applied\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._exaggeratedMinBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the shape is dirty.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._exaggeratedMinBoundsOld = new Cartesian3();\n\n  /**\n   * Maximum bounds with vertical exaggeration applied\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._exaggeratedMaxBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the shape is dirty.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._exaggeratedMaxBoundsOld = new Cartesian3();\n\n  /**\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._minClippingBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the clipping is dirty.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._minClippingBoundsOld = new Cartesian3();\n\n  /**\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._maxClippingBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the clipping is dirty.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._maxClippingBoundsOld = new Cartesian3();\n\n  /**\n   * Clipping planes on the primitive\n   *\n   * @type {ClippingPlaneCollection}\n   * @private\n   */\n  this._clippingPlanes = undefined;\n\n  /**\n   * Keeps track of when the clipping planes change\n   *\n   * @type {number}\n   * @private\n   */\n  this._clippingPlanesState = 0;\n\n  /**\n   * Keeps track of when the clipping planes are enabled / disabled\n   *\n   * @type {boolean}\n   * @private\n   */\n  this._clippingPlanesEnabled = false;\n\n  /**\n   * The primitive's model matrix.\n   *\n   * @type {Matrix4}\n   * @private\n   */\n  this._modelMatrix = Matrix4.clone(options.modelMatrix ?? Matrix4.IDENTITY);\n\n  /**\n   * Model matrix with vertical exaggeration applied. Only used for BOX shape type.\n   *\n   * @type {Matrix4}\n   * @private\n   */\n  this._exaggeratedModelMatrix = Matrix4.clone(this._modelMatrix);\n\n  /**\n   * The primitive's model matrix multiplied by the provider's model matrix.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Matrix4}\n   * @private\n   */\n  this._compoundModelMatrix = new Matrix4();\n\n  /**\n   * Used to detect if the shape is dirty.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Matrix4}\n   * @private\n   */\n  this._compoundModelMatrixOld = new Matrix4();\n\n  /**\n   * @type {CustomShader}\n   * @private\n   */\n  this._customShader =\n    options.customShader ?? VoxelPrimitive.DefaultCustomShader;\n\n  /**\n   * @type {Event}\n   * @private\n   */\n  this._customShaderCompilationEvent = new Event();\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._shaderDirty = true;\n\n  /**\n   * @type {DrawCommand}\n   * @private\n   */\n  this._drawCommand = undefined;\n\n  /**\n   * @type {DrawCommand}\n   * @private\n   */\n  this._drawCommandPick = undefined;\n\n  /**\n   * @type {object}\n   * @private\n   */\n  this._pickId = undefined;\n\n  /**\n   * @type {Clock}\n   * @private\n   */\n  this._clock = options.clock;\n\n  // Transforms and other values that are computed when the shape changes\n  /**\n   * @type {Matrix4}\n   * @private\n   */\n  this._transformPositionLocalToWorld = new Matrix4();\n\n  /**\n   * @type {Matrix4}\n   * @private\n   */\n  this._transformPositionWorldToLocal = new Matrix4();\n\n  /**\n   * Transforms a plane in Hessian normal form from local space to view space.\n   * @type {Matrix4}\n   * @private\n   */\n  this._transformPlaneLocalToView = new Matrix4();\n\n  /**\n   * @type {Matrix3}\n   * @private\n   */\n  this._transformDirectionWorldToLocal = new Matrix3();\n\n  // Rendering\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._nearestSampling = false;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._levelBlendFactor = 0.0;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._stepSizeMultiplier = 1.0;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._depthTest = true;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._useLogDepth = undefined;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._screenSpaceError = 4.0; // in pixels\n\n  // Debug / statistics\n  /**\n   * @type {PolylineCollection}\n   * @private\n   */\n  this._debugPolylines = new PolylineCollection();\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._debugDraw = false;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._disableRender = false;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._disableUpdate = false;\n\n  /**\n   * @type {Object<string, any>}\n   * @private\n   */\n  this._uniforms = {\n    octreeInternalNodeTexture: undefined,\n    octreeInternalNodeTilesPerRow: 0,\n    octreeInternalNodeTexelSizeUv: new Cartesian2(),\n    octreeLeafNodeTexture: undefined,\n    octreeLeafNodeTilesPerRow: 0,\n    octreeLeafNodeTexelSizeUv: new Cartesian2(),\n    megatextureTextures: [],\n    megatextureSliceDimensions: new Cartesian2(),\n    megatextureTileDimensions: new Cartesian2(),\n    megatextureVoxelSizeUv: new Cartesian2(),\n    megatextureSliceSizeUv: new Cartesian2(),\n    megatextureTileSizeUv: new Cartesian2(),\n    dimensions: new Cartesian3(),\n    inputDimensions: new Cartesian3(),\n    paddingBefore: new Cartesian3(),\n    paddingAfter: new Cartesian3(),\n    transformPositionViewToLocal: new Matrix4(),\n    transformDirectionViewToLocal: new Matrix3(),\n    cameraPositionLocal: new Cartesian3(),\n    cameraDirectionLocal: new Cartesian3(),\n    cameraTileCoordinates: new Cartesian4(),\n    cameraTileUv: new Cartesian3(),\n    ndcSpaceAxisAlignedBoundingBox: new Cartesian4(),\n    clippingPlanesTexture: undefined,\n    clippingPlanesMatrix: new Matrix4(),\n    renderBoundPlanesTexture: undefined,\n    stepSize: 0,\n    pickColor: new Color(),\n  };\n\n  /**\n   * Shape specific shader defines from the previous shape update. Used to detect if the shader needs to be rebuilt.\n   * @type {Object<string, any>}\n   * @private\n   */\n  this._shapeDefinesOld = {};\n\n  /**\n   * Map uniform names to functions that return the uniform values.\n   * @type {Object<string, function():any>}\n   * @private\n   */\n  this._uniformMap = {};\n\n  const uniforms = this._uniforms;\n  const uniformMap = this._uniformMap;\n  for (const key in uniforms) {\n    if (uniforms.hasOwnProperty(key)) {\n      const name = `u_${key}`;\n      uniformMap[name] = function () {\n        return uniforms[key];\n      };\n    }\n  }\n\n  /**\n   * The event fired to indicate that a tile's content was loaded.\n   * <p>\n   * This event is fired during the tileset traversal while the frame is being rendered\n   * so that updates to the tile take effect in the same frame.  Do not create or modify\n   * Cesium entities or primitives during the event listener.\n   * </p>\n   *\n   * @type {Event}\n   *\n   * @example\n   * voxelPrimitive.tileLoad.addEventListener(function() {\n   *     console.log('A tile was loaded.');\n   * });\n   */\n  this.tileLoad = new Event();\n\n  /**\n   * This event fires once for each visible tile in a frame.\n   * <p>\n   * This event is fired during the traversal while the frame is being rendered.\n   *\n   * @type {Event}\n   *\n   * @example\n   * voxelPrimitive.tileVisible.addEventListener(function() {\n   *     console.log('A tile is visible.');\n   * });\n   *\n   */\n  this.tileVisible = new Event();\n\n  /**\n   * The event fired to indicate that a tile's content failed to load.\n   *\n   * @type {Event}\n   *\n   * @example\n   * voxelPrimitive.tileFailed.addEventListener(function() {\n   *     console.log('An error occurred loading tile.');\n   * });\n   */\n  this.tileFailed = new Event();\n\n  /**\n   * The event fired to indicate that a tile's content was unloaded.\n   *\n   * @type {Event}\n   *\n   * @example\n   * voxelPrimitive.tileUnload.addEventListener(function() {\n   *     console.log('A tile was unloaded from the cache.');\n   * });\n   *\n   */\n  this.tileUnload = new Event();\n\n  /**\n   * The event fired to indicate progress of loading new tiles. This event is fired when a new tile\n   * is requested, when a requested tile is finished downloading, and when a downloaded tile has been\n   * processed and is ready to render.\n   * <p>\n   * The number of pending tile requests, <code>numberOfPendingRequests</code>, and number of tiles\n   * processing, <code>numberOfTilesProcessing</code> are passed to the event listener.\n   * </p>\n   * <p>\n   * This event is fired at the end of the frame after the scene is rendered.\n   * </p>\n   *\n   * @type {Event}\n   *\n   * @example\n   * voxelPrimitive.loadProgress.addEventListener(function(numberOfPendingRequests, numberOfTilesProcessing) {\n   *     if ((numberOfPendingRequests === 0) && (numberOfTilesProcessing === 0)) {\n   *         console.log('Finished loading');\n   *         return;\n   *     }\n   *\n   *     console.log(`Loading: requests: ${numberOfPendingRequests}, processing: ${numberOfTilesProcessing}`);\n   * });\n   */\n  this.loadProgress = new Event();\n\n  /**\n   * The event fired to indicate that all tiles that meet the screen space error this frame are loaded. The voxel\n   * primitive is completely loaded for this view.\n   * <p>\n   * This event is fired at the end of the frame after the scene is rendered.\n   * </p>\n   *\n   * @type {Event}\n   *\n   * @example\n   * voxelPrimitive.allTilesLoaded.addEventListener(function() {\n   *     console.log('All tiles are loaded');\n   * });\n   */\n  this.allTilesLoaded = new Event();\n\n  /**\n   * The event fired to indicate that all tiles that meet the screen space error this frame are loaded. This event\n   * is fired once when all tiles in the initial view are loaded.\n   * <p>\n   * This event is fired at the end of the frame after the scene is rendered.\n   * </p>\n   *\n   * @type {Event}\n   *\n   * @example\n   * voxelPrimitive.initialTilesLoaded.addEventListener(function() {\n   *     console.log('Initial tiles are loaded');\n   * });\n   *\n   * @see Cesium3DTileset#allTilesLoaded\n   */\n  this.initialTilesLoaded = new Event();\n\n  // If the provider fails to initialize the primitive will fail too.\n  const provider = this._provider;\n  initialize(this, provider);\n}\n\nfunction initialize(primitive, provider) {\n  // Set the bounds\n  const {\n    shape: shapeType,\n    minBounds = VoxelShapeType.getMinBounds(shapeType),\n    maxBounds = VoxelShapeType.getMaxBounds(shapeType),\n  } = provider;\n\n  primitive.minBounds = minBounds;\n  primitive.maxBounds = maxBounds;\n  primitive.minClippingBounds = minBounds.clone();\n  primitive.maxClippingBounds = maxBounds.clone();\n\n  // Initialize the exaggerated versions of bounds and model matrix\n  primitive._exaggeratedMinBounds = Cartesian3.clone(\n    primitive._minBounds,\n    primitive._exaggeratedMinBounds,\n  );\n  primitive._exaggeratedMaxBounds = Cartesian3.clone(\n    primitive._maxBounds,\n    primitive._exaggeratedMaxBounds,\n  );\n  primitive._exaggeratedModelMatrix = Matrix4.clone(\n    primitive._modelMatrix,\n    primitive._exaggeratedModelMatrix,\n  );\n\n  checkTransformAndBounds(primitive, provider);\n\n  // Create the shape object, and update it so it is valid for VoxelTraversal\n  const ShapeConstructor = VoxelShapeType.getShapeConstructor(shapeType);\n  primitive._shape = new ShapeConstructor();\n  primitive._shapeVisible = updateShapeAndTransforms(primitive);\n}\n\nObject.defineProperties(VoxelPrimitive.prototype, {\n  /**\n   * Gets a value indicating whether or not the primitive is ready for use.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets the {@link VoxelProvider} associated with this primitive.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {VoxelProvider}\n   * @readonly\n   */\n  provider: {\n    get: function () {\n      return this._provider;\n    },\n  },\n\n  /**\n   * Gets the bounding sphere.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      return this._shape.boundingSphere;\n    },\n  },\n\n  /**\n   * Gets the oriented bounding box.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {OrientedBoundingBox}\n   * @readonly\n   */\n  orientedBoundingBox: {\n    get: function () {\n      return this._shape.orientedBoundingBox;\n    },\n  },\n\n  /**\n   * Gets the model matrix.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Matrix4}\n   * @readonly\n   */\n  modelMatrix: {\n    get: function () {\n      return this._modelMatrix;\n    },\n    set: function (modelMatrix) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"modelMatrix\", modelMatrix);\n      //>>includeEnd('debug');\n\n      this._modelMatrix = Matrix4.clone(modelMatrix, this._modelMatrix);\n    },\n  },\n\n  /**\n   * Gets the shape type.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {VoxelShapeType}\n   * @readonly\n   */\n  shape: {\n    get: function () {\n      return this._provider.shape;\n    },\n  },\n\n  /**\n   * Gets the dimensions of each voxel tile, in z-up orientation.\n   * Does not include padding.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  dimensions: {\n    get: function () {\n      return this._dimensions;\n    },\n  },\n\n  /**\n   * Gets the dimensions of one tile of the input voxel data, in the input orientation.\n   * Includes padding.\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  inputDimensions: {\n    get: function () {\n      return this._inputDimensions;\n    },\n  },\n\n  /**\n   * Gets the padding before the voxel data.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  paddingBefore: {\n    get: function () {\n      return this._paddingBefore;\n    },\n  },\n\n  /**\n   * Gets the padding after the voxel data.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  paddingAfter: {\n    get: function () {\n      return this._paddingAfter;\n    },\n  },\n\n  /**\n   * Gets the minimum value per channel of the voxel data.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {number[][]}\n   * @readonly\n   */\n  minimumValues: {\n    get: function () {\n      return this._provider.minimumValues;\n    },\n  },\n\n  /**\n   * Gets the maximum value per channel of the voxel data.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {number[][]}\n   * @readonly\n   */\n  maximumValues: {\n    get: function () {\n      return this._provider.maximumValues;\n    },\n  },\n\n  /**\n   * Gets or sets whether or not this primitive should be displayed.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   */\n  show: {\n    get: function () {\n      return !this._disableRender;\n    },\n    set: function (show) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"show\", show);\n      //>>includeEnd('debug');\n\n      this._disableRender = !show;\n    },\n  },\n\n  /**\n   * Gets or sets whether or not the primitive should update when the view changes.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   */\n  disableUpdate: {\n    get: function () {\n      return this._disableUpdate;\n    },\n    set: function (disableUpdate) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"disableUpdate\", disableUpdate);\n      //>>includeEnd('debug');\n\n      this._disableUpdate = disableUpdate;\n    },\n  },\n\n  /**\n   * Gets or sets whether or not to render debug visualizations.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   */\n  debugDraw: {\n    get: function () {\n      return this._debugDraw;\n    },\n    set: function (debugDraw) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"debugDraw\", debugDraw);\n      //>>includeEnd('debug');\n\n      this._debugDraw = debugDraw;\n    },\n  },\n\n  /**\n   * Gets or sets whether or not to test against depth when rendering.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   */\n  depthTest: {\n    get: function () {\n      return this._depthTest;\n    },\n    set: function (depthTest) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"depthTest\", depthTest);\n      //>>includeEnd('debug');\n\n      if (this._depthTest !== depthTest) {\n        this._depthTest = depthTest;\n        this._shaderDirty = true;\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the nearest sampling.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   */\n  nearestSampling: {\n    get: function () {\n      return this._nearestSampling;\n    },\n    set: function (nearestSampling) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"nearestSampling\", nearestSampling);\n      //>>includeEnd('debug');\n\n      if (this._nearestSampling !== nearestSampling) {\n        this._nearestSampling = nearestSampling;\n        this._shaderDirty = true;\n      }\n    },\n  },\n\n  /**\n   * Controls how quickly to blend between different levels of the tree.\n   * 0.0 means an instantaneous pop.\n   * 1.0 means a full linear blend.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {number}\n   * @private\n   */\n  levelBlendFactor: {\n    get: function () {\n      return this._levelBlendFactor;\n    },\n    set: function (levelBlendFactor) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"levelBlendFactor\", levelBlendFactor);\n      //>>includeEnd('debug');\n\n      this._levelBlendFactor = CesiumMath.clamp(levelBlendFactor, 0.0, 1.0);\n    },\n  },\n\n  /**\n   * Gets or sets the screen space error in pixels. If the screen space size\n   * of a voxel is greater than the screen space error, the tile is subdivided.\n   * Lower screen space error corresponds with higher detail rendering, but could\n   * result in worse performance and higher memory consumption.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {number}\n   */\n  screenSpaceError: {\n    get: function () {\n      return this._screenSpaceError;\n    },\n    set: function (screenSpaceError) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"screenSpaceError\", screenSpaceError);\n      //>>includeEnd('debug');\n\n      this._screenSpaceError = screenSpaceError;\n    },\n  },\n\n  /**\n   * Gets or sets the step size multiplier used during raymarching.\n   * The lower the value, the higher the rendering quality, but\n   * also the worse the performance.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {number}\n   */\n  stepSize: {\n    get: function () {\n      return this._stepSizeMultiplier;\n    },\n    set: function (stepSize) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"stepSize\", stepSize);\n      //>>includeEnd('debug');\n\n      this._stepSizeMultiplier = stepSize;\n    },\n  },\n\n  /**\n   * Gets or sets the minimum bounds in the shape's local coordinate system.\n   * Voxel data is stretched or squashed to fit the bounds.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   */\n  minBounds: {\n    get: function () {\n      return this._minBounds;\n    },\n    set: function (minBounds) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"minBounds\", minBounds);\n      //>>includeEnd('debug');\n\n      this._minBounds = Cartesian3.clone(minBounds, this._minBounds);\n    },\n  },\n\n  /**\n   * Gets or sets the maximum bounds in the shape's local coordinate system.\n   * Voxel data is stretched or squashed to fit the bounds.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   */\n  maxBounds: {\n    get: function () {\n      return this._maxBounds;\n    },\n    set: function (maxBounds) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"maxBounds\", maxBounds);\n      //>>includeEnd('debug');\n\n      this._maxBounds = Cartesian3.clone(maxBounds, this._maxBounds);\n    },\n  },\n\n  /**\n   * Gets or sets the minimum clipping location in the shape's local coordinate system.\n   * Any voxel content outside the range is clipped.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   */\n  minClippingBounds: {\n    get: function () {\n      return this._minClippingBounds;\n    },\n    set: function (minClippingBounds) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"minClippingBounds\", minClippingBounds);\n      //>>includeEnd('debug');\n\n      this._minClippingBounds = Cartesian3.clone(\n        minClippingBounds,\n        this._minClippingBounds,\n      );\n    },\n  },\n\n  /**\n   * Gets or sets the maximum clipping location in the shape's local coordinate system.\n   * Any voxel content outside the range is clipped.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   */\n  maxClippingBounds: {\n    get: function () {\n      return this._maxClippingBounds;\n    },\n    set: function (maxClippingBounds) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"maxClippingBounds\", maxClippingBounds);\n      //>>includeEnd('debug');\n\n      this._maxClippingBounds = Cartesian3.clone(\n        maxClippingBounds,\n        this._maxClippingBounds,\n      );\n    },\n  },\n\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering the primitive.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {ClippingPlaneCollection}\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._clippingPlanes;\n    },\n    set: function (clippingPlanes) {\n      // Don't need to check if undefined, it's handled in the setOwner function\n      ClippingPlaneCollection.setOwner(clippingPlanes, this, \"_clippingPlanes\");\n    },\n  },\n\n  /**\n   * Gets or sets the custom shader. If undefined, {@link VoxelPrimitive.DefaultCustomShader} is set.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {CustomShader}\n   * @see {@link https://github.com/CesiumGS/cesium/tree/main/Documentation/CustomShaderGuide|Custom Shader Guide}\n   */\n  customShader: {\n    get: function () {\n      return this._customShader;\n    },\n    set: function (customShader) {\n      if (this._customShader !== customShader) {\n        // Delete old custom shader entries from the uniform map\n        const uniformMap = this._uniformMap;\n        const oldCustomShader = this._customShader;\n        const oldCustomShaderUniformMap = oldCustomShader.uniformMap;\n        for (const uniformName in oldCustomShaderUniformMap) {\n          if (oldCustomShaderUniformMap.hasOwnProperty(uniformName)) {\n            // If the custom shader was set but the voxel shader was never\n            // built, the custom shader uniforms wouldn't have been added to\n            // the uniform map. But it doesn't matter because the delete\n            // operator ignores if the key doesn't exist.\n            delete uniformMap[uniformName];\n          }\n        }\n\n        if (!defined(customShader)) {\n          this._customShader = VoxelPrimitive.DefaultCustomShader;\n        } else {\n          this._customShader = customShader;\n        }\n        this._shaderDirty = true;\n      }\n    },\n  },\n\n  /**\n   * Gets an event that is raised whenever a custom shader is compiled.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Event}\n   * @readonly\n   */\n  customShaderCompilationEvent: {\n    get: function () {\n      return this._customShaderCompilationEvent;\n    },\n  },\n\n  /**\n   *  Loading and rendering information for requested content\n   * To use `visited` and `numberOfTilesWithContentReady` statistics, set options._calculateStatistics` to `true` in the constructor.\n   * @type {Cesium3DTilesetStatistics}\n   * @readonly\n   * @private\n   */\n  statistics: {\n    get: function () {\n      return this._statistics;\n    },\n  },\n});\n\nconst scratchIntersect = new Cartesian4();\nconst scratchNdcAabb = new Cartesian4();\nconst scratchTransformPositionLocalToWorld = new Matrix4();\nconst scratchTransformPositionLocalToProjection = new Matrix4();\nconst scratchCameraPositionShapeUv = new Cartesian3();\nconst scratchCameraTileCoordinates = new Cartesian4();\n\n/**\n * Updates the voxel primitive.\n *\n * @param {FrameState} frameState\n * @private\n */\nVoxelPrimitive.prototype.update = function (frameState) {\n  const provider = this._provider;\n  const uniforms = this._uniforms;\n\n  // Update the custom shader in case it has texture uniforms.\n  this._customShader.update(frameState);\n\n  // Initialize from the ready provider. This only happens once.\n  const context = frameState.context;\n  if (!this._ready) {\n    initFromProvider(this, provider, context);\n    // Set the primitive as ready after the first frame render since the user might set up events subscribed to\n    // the post render event, and the primitive may not be ready for those past the first frame.\n    frameState.afterRender.push(() => {\n      this._ready = true;\n      return true;\n    });\n\n    // Don't render until the next frame after ready is set to true\n    return;\n  }\n\n  updateVerticalExaggeration(this, frameState);\n\n  // Check if the shape is dirty before updating it. This needs to happen every\n  // frame because the member variables can be modified externally via the\n  // getters.\n  const shapeDirty = checkTransformAndBounds(this, provider);\n  if (shapeDirty) {\n    this._shapeVisible = updateShapeAndTransforms(this);\n    if (checkShapeDefines(this)) {\n      this._shaderDirty = true;\n    }\n  }\n  if (!this._shapeVisible) {\n    return;\n  }\n\n  this._shape.updateViewTransforms(frameState);\n\n  // Update the traversal and prepare for rendering.\n  const keyframeLocation = getKeyframeLocation(\n    provider.timeIntervalCollection,\n    this._clock,\n  );\n\n  const traversal = this._traversal;\n  const sampleCountOld = traversal._sampleCount;\n\n  traversal.update(\n    frameState,\n    keyframeLocation,\n    shapeDirty, // recomputeBoundingVolumes\n    this._disableUpdate, // pauseUpdate\n  );\n\n  if (sampleCountOld !== traversal._sampleCount) {\n    this._shaderDirty = true;\n  }\n\n  if (!traversal.isRenderable(traversal.rootNode)) {\n    return;\n  }\n\n  if (this._debugDraw) {\n    // Debug draw bounding boxes and other things. Must go after traversal update\n    // because that's what updates the tile bounding boxes.\n    debugDraw(this, frameState);\n  }\n\n  if (this._disableRender) {\n    return;\n  }\n\n  // Check if log depth changed\n  if (this._useLogDepth !== frameState.useLogDepth) {\n    this._useLogDepth = frameState.useLogDepth;\n    this._shaderDirty = true;\n  }\n\n  // Check if clipping planes changed\n  const clippingPlanesChanged = updateClippingPlanes(this, frameState);\n  if (clippingPlanesChanged) {\n    this._shaderDirty = true;\n  }\n\n  const leafNodeTexture = traversal.leafNodeTexture;\n  if (defined(leafNodeTexture)) {\n    uniforms.octreeLeafNodeTexture = traversal.leafNodeTexture;\n    uniforms.octreeLeafNodeTexelSizeUv = Cartesian2.clone(\n      traversal.leafNodeTexelSizeUv,\n      uniforms.octreeLeafNodeTexelSizeUv,\n    );\n    uniforms.octreeLeafNodeTilesPerRow = traversal.leafNodeTilesPerRow;\n  }\n\n  // Rebuild shaders\n  if (this._shaderDirty) {\n    buildVoxelDrawCommands(this, context);\n    this._shaderDirty = false;\n  }\n\n  // Calculate the NDC-space AABB to \"scissor\" the fullscreen quad\n  const transformPositionWorldToProjection =\n    context.uniformState.viewProjection;\n  const { orientedBoundingBox } = this._shape;\n  const ndcAabb = orientedBoundingBoxToNdcAabb(\n    orientedBoundingBox,\n    transformPositionWorldToProjection,\n    scratchNdcAabb,\n  );\n\n  // If the object is offscreen, don't render it.\n  const offscreen =\n    ndcAabb.x === +1.0 ||\n    ndcAabb.y === +1.0 ||\n    ndcAabb.z === -1.0 ||\n    ndcAabb.w === -1.0;\n  if (offscreen) {\n    return;\n  }\n\n  // Prepare to render: update uniforms that can change every frame\n  // Using a uniform instead of going through RenderState's scissor because the viewport is not accessible here, and the scissor command needs pixel coordinates.\n  uniforms.ndcSpaceAxisAlignedBoundingBox = Cartesian4.clone(\n    ndcAabb,\n    uniforms.ndcSpaceAxisAlignedBoundingBox,\n  );\n  const transformPositionViewToWorld = context.uniformState.inverseView;\n  const transformPositionViewToLocal = Matrix4.multiplyTransformation(\n    this._transformPositionWorldToLocal,\n    transformPositionViewToWorld,\n    uniforms.transformPositionViewToLocal,\n  );\n\n  this._transformPlaneLocalToView = Matrix4.transpose(\n    transformPositionViewToLocal,\n    this._transformPlaneLocalToView,\n  );\n\n  const transformDirectionViewToWorld =\n    context.uniformState.inverseViewRotation;\n  uniforms.transformDirectionViewToLocal = Matrix3.multiply(\n    this._transformDirectionWorldToLocal,\n    transformDirectionViewToWorld,\n    uniforms.transformDirectionViewToLocal,\n  );\n  uniforms.cameraPositionLocal = Matrix4.multiplyByPoint(\n    this._transformPositionWorldToLocal,\n    frameState.camera.positionWC,\n    uniforms.cameraPositionLocal,\n  );\n  uniforms.cameraDirectionLocal = Matrix3.multiplyByVector(\n    this._transformDirectionWorldToLocal,\n    frameState.camera.directionWC,\n    uniforms.cameraDirectionLocal,\n  );\n  const cameraTileCoordinates = getTileCoordinates(\n    this,\n    uniforms.cameraPositionLocal,\n    scratchCameraTileCoordinates,\n  );\n  uniforms.cameraTileCoordinates = Cartesian4.fromElements(\n    Math.floor(cameraTileCoordinates.x),\n    Math.floor(cameraTileCoordinates.y),\n    Math.floor(cameraTileCoordinates.z),\n    cameraTileCoordinates.w,\n    uniforms.cameraTileCoordinates,\n  );\n  uniforms.cameraTileUv = Cartesian3.fromElements(\n    cameraTileCoordinates.x - Math.floor(cameraTileCoordinates.x),\n    cameraTileCoordinates.y - Math.floor(cameraTileCoordinates.y),\n    cameraTileCoordinates.z - Math.floor(cameraTileCoordinates.z),\n    uniforms.cameraTileUv,\n  );\n  uniforms.stepSize = this._stepSizeMultiplier;\n\n  updateRenderBoundPlanes(this, frameState);\n\n  // Render the primitive\n  const command = frameState.passes.pick\n    ? this._drawCommandPick\n    : frameState.passes.pickVoxel\n      ? this._drawCommandPickVoxel\n      : this._drawCommand;\n  command.boundingVolume = this._shape.boundingSphere;\n  frameState.commandList.push(command);\n};\n\nfunction updateRenderBoundPlanes(primitive, frameState) {\n  const uniforms = primitive._uniforms;\n  const { renderBoundPlanes } = primitive._shape;\n  if (!defined(renderBoundPlanes)) {\n    return;\n  }\n  renderBoundPlanes.update(frameState, primitive._transformPlaneLocalToView);\n  uniforms.renderBoundPlanesTexture = renderBoundPlanes.texture;\n}\n\n/**\n * Converts a position in local space to tile coordinates.\n *\n * @param {VoxelPrimitive} primitive The primitive to get the tile coordinates for.\n * @param {Cartesian3} positionLocal The position in local space to convert to tile coordinates.\n * @param {Cartesian4} result The result object to store the tile coordinates.\n * @returns {Cartesian4} The tile coordinates of the supplied position.\n * @private\n */\nfunction getTileCoordinates(primitive, positionLocal, result) {\n  const shapeUv = primitive._shape.convertLocalToShapeUvSpace(\n    positionLocal,\n    scratchCameraPositionShapeUv,\n  );\n\n  const availableLevels = primitive._availableLevels;\n  const numTiles = 2 ** (availableLevels - 1);\n\n  return Cartesian4.fromElements(\n    shapeUv.x * numTiles,\n    shapeUv.y * numTiles,\n    shapeUv.z * numTiles,\n    availableLevels - 1,\n    result,\n  );\n}\n\nconst scratchExaggerationScale = new Cartesian3();\nconst scratchExaggerationCenter = new Cartesian3();\nconst scratchCartographicCenter = new Cartographic();\nconst scratchExaggerationTranslation = new Cartesian3();\n\n/**\n * Update the exaggerated bounds of a primitive to account for vertical exaggeration\n * @param {VoxelPrimitive} primitive\n * @param {FrameState} frameState\n * @private\n */\nfunction updateVerticalExaggeration(primitive, frameState) {\n  primitive._exaggeratedMinBounds = Cartesian3.clone(\n    primitive._minBounds,\n    primitive._exaggeratedMinBounds,\n  );\n  primitive._exaggeratedMaxBounds = Cartesian3.clone(\n    primitive._maxBounds,\n    primitive._exaggeratedMaxBounds,\n  );\n\n  if (primitive.shape === VoxelShapeType.ELLIPSOID) {\n    // Apply the exaggeration by stretching the height bounds\n    const relativeHeight = frameState.verticalExaggerationRelativeHeight;\n    const exaggeration = frameState.verticalExaggeration;\n    primitive._exaggeratedMinBounds.z =\n      (primitive._minBounds.z - relativeHeight) * exaggeration + relativeHeight;\n    primitive._exaggeratedMaxBounds.z =\n      (primitive._maxBounds.z - relativeHeight) * exaggeration + relativeHeight;\n  } else {\n    // Apply the exaggeration via the model matrix\n    const exaggerationScale = Cartesian3.fromElements(\n      1.0,\n      1.0,\n      frameState.verticalExaggeration,\n      scratchExaggerationScale,\n    );\n    primitive._exaggeratedModelMatrix = Matrix4.multiplyByScale(\n      primitive._modelMatrix,\n      exaggerationScale,\n      primitive._exaggeratedModelMatrix,\n    );\n    primitive._exaggeratedModelMatrix = Matrix4.multiplyByTranslation(\n      primitive._exaggeratedModelMatrix,\n      computeBoxExaggerationTranslation(primitive, frameState),\n      primitive._exaggeratedModelMatrix,\n    );\n  }\n}\n\nfunction computeBoxExaggerationTranslation(primitive, frameState) {\n  // Compute translation based on box center, relative height, and exaggeration\n  const {\n    shapeTransform = Matrix4.IDENTITY,\n    globalTransform = Matrix4.IDENTITY,\n  } = primitive._provider;\n\n  // Find the Cartesian position of the center of the OBB\n  const initialCenter = Matrix4.getTranslation(\n    shapeTransform,\n    scratchExaggerationCenter,\n  );\n  const intermediateCenter = Matrix4.multiplyByPoint(\n    primitive._modelMatrix,\n    initialCenter,\n    scratchExaggerationCenter,\n  );\n  const transformedCenter = Matrix4.multiplyByPoint(\n    globalTransform,\n    intermediateCenter,\n    scratchExaggerationCenter,\n  );\n\n  // Find the cartographic height\n  const ellipsoid = Ellipsoid.WGS84;\n  const centerCartographic = ellipsoid.cartesianToCartographic(\n    transformedCenter,\n    scratchCartographicCenter,\n  );\n\n  let centerHeight = 0.0;\n  if (defined(centerCartographic)) {\n    centerHeight = centerCartographic.height;\n  }\n\n  // Find the shift that will put the center in the right position relative\n  // to relativeHeight, after it is scaled by verticalExaggeration\n  const exaggeratedHeight = VerticalExaggeration.getHeight(\n    centerHeight,\n    frameState.verticalExaggeration,\n    frameState.verticalExaggerationRelativeHeight,\n  );\n\n  return Cartesian3.fromElements(\n    0.0,\n    0.0,\n    (exaggeratedHeight - centerHeight) / frameState.verticalExaggeration,\n    scratchExaggerationTranslation,\n  );\n}\n\n/**\n * Initialize primitive properties that are derived from the voxel provider\n * @param {VoxelPrimitive} primitive\n * @param {VoxelProvider} provider\n * @param {Context} context\n * @private\n */\nfunction initFromProvider(primitive, provider, context) {\n  const uniforms = primitive._uniforms;\n\n  primitive._pickId = context.createPickId({ primitive });\n  uniforms.pickColor = Color.clone(primitive._pickId.color, uniforms.pickColor);\n\n  const { shaderDefines, shaderUniforms: shapeUniforms } = primitive._shape;\n  primitive._shapeDefinesOld = clone(shaderDefines, true);\n\n  // Add shape uniforms to the uniform map\n  const uniformMap = primitive._uniformMap;\n  for (const key in shapeUniforms) {\n    if (shapeUniforms.hasOwnProperty(key)) {\n      const name = `u_${key}`;\n\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(uniformMap[name])) {\n        oneTimeWarning(\n          `VoxelPrimitive: Uniform name \"${name}\" is already defined`,\n        );\n      }\n      //>>includeEnd('debug');\n\n      uniformMap[name] = function () {\n        return shapeUniforms[key];\n      };\n    }\n  }\n\n  // Set uniforms that come from the provider.\n  // Note that minBounds and maxBounds can be set dynamically, so their uniforms aren't set here.\n  primitive._dimensions = Cartesian3.clone(\n    provider.dimensions,\n    primitive._dimensions,\n  );\n  uniforms.dimensions = Cartesian3.clone(\n    primitive._dimensions,\n    uniforms.dimensions,\n  );\n  primitive._paddingBefore = Cartesian3.clone(\n    provider.paddingBefore ?? Cartesian3.ZERO,\n    primitive._paddingBefore,\n  );\n  uniforms.paddingBefore = Cartesian3.clone(\n    primitive._paddingBefore,\n    uniforms.paddingBefore,\n  );\n  primitive._paddingAfter = Cartesian3.clone(\n    provider.paddingAfter ?? Cartesian3.ZERO,\n    primitive._paddingAfter,\n  );\n  uniforms.paddingAfter = Cartesian3.clone(\n    primitive._paddingAfter,\n    uniforms.paddingAfter,\n  );\n  primitive._inputDimensions = Cartesian3.add(\n    primitive._dimensions,\n    primitive._paddingBefore,\n    primitive._inputDimensions,\n  );\n  primitive._inputDimensions = Cartesian3.add(\n    primitive._inputDimensions,\n    primitive._paddingAfter,\n    primitive._inputDimensions,\n  );\n  if (provider.metadataOrder === VoxelMetadataOrder.Y_UP) {\n    const inputDimensionsY = primitive._inputDimensions.y;\n    primitive._inputDimensions.y = primitive._inputDimensions.z;\n    primitive._inputDimensions.z = inputDimensionsY;\n  }\n  uniforms.inputDimensions = Cartesian3.clone(\n    primitive._inputDimensions,\n    uniforms.inputDimensions,\n  );\n  primitive._availableLevels = provider.availableLevels ?? 1;\n\n  // Create the VoxelTraversal, and set related uniforms\n  const keyframeCount = provider.keyframeCount ?? 1;\n  primitive._traversal = new VoxelTraversal(primitive, context, keyframeCount);\n  primitive.statistics.texturesByteLength =\n    primitive._traversal.textureMemoryByteLength;\n  setTraversalUniforms(primitive._traversal, uniforms);\n}\n\n/**\n * Track changes in provider transform and primitive bounds\n * @param {VoxelPrimitive} primitive\n * @param {VoxelProvider} provider\n * @returns {boolean} Whether any of the transform or bounds changed\n * @private\n */\nfunction checkTransformAndBounds(primitive, provider) {\n  const shapeTransform = provider.shapeTransform ?? Matrix4.IDENTITY;\n  const globalTransform = provider.globalTransform ?? Matrix4.IDENTITY;\n\n  // Compound model matrix = global transform * model matrix * shape transform\n  Matrix4.multiplyTransformation(\n    globalTransform,\n    primitive._exaggeratedModelMatrix,\n    primitive._compoundModelMatrix,\n  );\n  Matrix4.multiplyTransformation(\n    primitive._compoundModelMatrix,\n    shapeTransform,\n    primitive._compoundModelMatrix,\n  );\n  const numChanges =\n    updateBound(primitive, \"_compoundModelMatrix\", \"_compoundModelMatrixOld\") +\n    updateBound(primitive, \"_minBounds\", \"_minBoundsOld\") +\n    updateBound(primitive, \"_maxBounds\", \"_maxBoundsOld\") +\n    updateBound(\n      primitive,\n      \"_exaggeratedMinBounds\",\n      \"_exaggeratedMinBoundsOld\",\n    ) +\n    updateBound(\n      primitive,\n      \"_exaggeratedMaxBounds\",\n      \"_exaggeratedMaxBoundsOld\",\n    ) +\n    updateBound(primitive, \"_minClippingBounds\", \"_minClippingBoundsOld\") +\n    updateBound(primitive, \"_maxClippingBounds\", \"_maxClippingBoundsOld\");\n  return numChanges > 0;\n}\n\n/**\n * Compare old and new values of a bound and update the old if it is different.\n * @param {VoxelPrimitive} primitive The primitive with bounds properties\n * @param {string} newBoundKey A key pointing to a bounds property of type Cartesian3 or Matrix4\n * @param {string} oldBoundKey A key pointing to a bounds property of the same type as the property at newBoundKey\n * @returns {number} 1 if the bound value changed, 0 otherwise\n *\n * @private\n */\nfunction updateBound(primitive, newBoundKey, oldBoundKey) {\n  const newBound = primitive[newBoundKey];\n  const oldBound = primitive[oldBoundKey];\n\n  const changed = !newBound.equals(oldBound);\n  if (changed) {\n    newBound.clone(oldBound);\n  }\n  return changed ? 1 : 0;\n}\n\n/**\n * Update the shape and related transforms\n * @param {VoxelPrimitive} primitive\n * @returns {boolean} True if the shape is visible\n * @private\n */\nfunction updateShapeAndTransforms(primitive) {\n  const shape = primitive._shape;\n  const visible = shape.update(\n    primitive._compoundModelMatrix,\n    primitive._exaggeratedMinBounds,\n    primitive._exaggeratedMaxBounds,\n    primitive.minClippingBounds,\n    primitive.maxClippingBounds,\n  );\n  if (!visible) {\n    return false;\n  }\n\n  primitive._transformPositionLocalToWorld = Matrix4.clone(\n    shape.shapeTransform,\n    primitive._transformPositionLocalToWorld,\n  );\n  primitive._transformPositionWorldToLocal = Matrix4.inverse(\n    primitive._transformPositionLocalToWorld,\n    primitive._transformPositionWorldToLocal,\n  );\n  primitive._transformDirectionWorldToLocal = Matrix4.getMatrix3(\n    primitive._transformPositionWorldToLocal,\n    primitive._transformDirectionWorldToLocal,\n  );\n\n  return true;\n}\n\n/**\n * Set uniforms that come from the traversal.\n * @param {VoxelTraversal} traversal\n * @param {object} uniforms\n * @private\n */\nfunction setTraversalUniforms(traversal, uniforms) {\n  uniforms.octreeInternalNodeTexture = traversal.internalNodeTexture;\n  uniforms.octreeInternalNodeTexelSizeUv = Cartesian2.clone(\n    traversal.internalNodeTexelSizeUv,\n    uniforms.octreeInternalNodeTexelSizeUv,\n  );\n  uniforms.octreeInternalNodeTilesPerRow = traversal.internalNodeTilesPerRow;\n\n  const megatextures = traversal.megatextures;\n  const megatexture = megatextures[0];\n  const megatextureLength = megatextures.length;\n  uniforms.megatextureTextures = new Array(megatextureLength);\n  for (let i = 0; i < megatextureLength; i++) {\n    uniforms.megatextureTextures[i] = megatextures[i].texture;\n  }\n\n  uniforms.megatextureSliceDimensions = Cartesian2.clone(\n    megatexture.sliceCountPerRegion,\n    uniforms.megatextureSliceDimensions,\n  );\n  uniforms.megatextureTileDimensions = Cartesian2.clone(\n    megatexture.regionCountPerMegatexture,\n    uniforms.megatextureTileDimensions,\n  );\n  uniforms.megatextureVoxelSizeUv = Cartesian2.clone(\n    megatexture.voxelSizeUv,\n    uniforms.megatextureVoxelSizeUv,\n  );\n  uniforms.megatextureSliceSizeUv = Cartesian2.clone(\n    megatexture.sliceSizeUv,\n    uniforms.megatextureSliceSizeUv,\n  );\n  uniforms.megatextureTileSizeUv = Cartesian2.clone(\n    megatexture.regionSizeUv,\n    uniforms.megatextureTileSizeUv,\n  );\n}\n\n/**\n * Track changes in shape-related shader defines\n * @param {VoxelPrimitive} primitive\n * @returns {boolean} True if any of the shape defines changed, requiring a shader rebuild\n * @private\n */\nfunction checkShapeDefines(primitive) {\n  const { shaderDefines } = primitive._shape;\n  const shapeDefinesChanged = Object.keys(shaderDefines).some(\n    (key) => shaderDefines[key] !== primitive._shapeDefinesOld[key],\n  );\n  if (shapeDefinesChanged) {\n    primitive._shapeDefinesOld = clone(shaderDefines, true);\n  }\n  return shapeDefinesChanged;\n}\n\n/**\n * Find the keyframe location to render at. Doesn't need to be a whole number.\n * @param {TimeIntervalCollection} timeIntervalCollection\n * @param {Clock} clock\n * @returns {number}\n *\n * @private\n */\nfunction getKeyframeLocation(timeIntervalCollection, clock) {\n  if (!defined(timeIntervalCollection) || !defined(clock)) {\n    return 0.0;\n  }\n  let date = clock.currentTime;\n  let timeInterval;\n  let timeIntervalIndex = timeIntervalCollection.indexOf(date);\n  if (timeIntervalIndex >= 0) {\n    timeInterval = timeIntervalCollection.get(timeIntervalIndex);\n  } else {\n    // Date fell outside the range\n    timeIntervalIndex = ~timeIntervalIndex;\n    if (timeIntervalIndex === timeIntervalCollection.length) {\n      // Date past range\n      timeIntervalIndex = timeIntervalCollection.length - 1;\n      timeInterval = timeIntervalCollection.get(timeIntervalIndex);\n      date = timeInterval.stop;\n    } else {\n      // Date before range\n      timeInterval = timeIntervalCollection.get(timeIntervalIndex);\n      date = timeInterval.start;\n    }\n  }\n  // De-lerp between the start and end of the interval\n  const totalSeconds = JulianDate.secondsDifference(\n    timeInterval.stop,\n    timeInterval.start,\n  );\n  const secondsDifferenceStart = JulianDate.secondsDifference(\n    date,\n    timeInterval.start,\n  );\n  const t = secondsDifferenceStart / totalSeconds;\n\n  return timeIntervalIndex + t;\n}\n\n/**\n * Update the clipping planes state and associated uniforms\n *\n * @param {VoxelPrimitive} primitive\n * @param {FrameState} frameState\n * @returns {boolean} Whether the clipping planes changed, requiring a shader rebuild\n * @private\n */\nfunction updateClippingPlanes(primitive, frameState) {\n  const clippingPlanes = primitive.clippingPlanes;\n  if (!defined(clippingPlanes)) {\n    return false;\n  }\n\n  clippingPlanes.update(frameState);\n\n  const { clippingPlanesState, enabled } = clippingPlanes;\n\n  if (enabled) {\n    const uniforms = primitive._uniforms;\n    uniforms.clippingPlanesTexture = clippingPlanes.texture;\n\n    // Compute the clipping plane's transformation to local space and then take the inverse\n    // transpose to properly transform the hessian normal form of the plane.\n\n    // transpose(inverse(worldToLocal * clippingPlaneLocalToWorld))\n    // transpose(inverse(clippingPlaneLocalToWorld) * inverse(worldToLocal))\n    // transpose(inverse(clippingPlaneLocalToWorld) * localToWorld)\n\n    uniforms.clippingPlanesMatrix = Matrix4.transpose(\n      Matrix4.multiplyTransformation(\n        Matrix4.inverse(\n          clippingPlanes.modelMatrix,\n          uniforms.clippingPlanesMatrix,\n        ),\n        primitive._transformPositionLocalToWorld,\n        uniforms.clippingPlanesMatrix,\n      ),\n      uniforms.clippingPlanesMatrix,\n    );\n  }\n\n  if (\n    primitive._clippingPlanesState === clippingPlanesState &&\n    primitive._clippingPlanesEnabled === enabled\n  ) {\n    return false;\n  }\n  primitive._clippingPlanesState = clippingPlanesState;\n  primitive._clippingPlanesEnabled = enabled;\n\n  return true;\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see VoxelPrimitive#destroy\n */\nVoxelPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see VoxelPrimitive#isDestroyed\n *\n * @example\n * voxelPrimitive = voxelPrimitive && voxelPrimitive.destroy();\n */\nVoxelPrimitive.prototype.destroy = function () {\n  const drawCommand = this._drawCommand;\n  if (defined(drawCommand)) {\n    drawCommand.shaderProgram =\n      drawCommand.shaderProgram && drawCommand.shaderProgram.destroy();\n  }\n  const drawCommandPick = this._drawCommandPick;\n  if (defined(drawCommandPick)) {\n    drawCommandPick.shaderProgram =\n      drawCommandPick.shaderProgram && drawCommandPick.shaderProgram.destroy();\n  }\n\n  this._pickId = this._pickId && this._pickId.destroy();\n  this._traversal = this._traversal && this._traversal.destroy();\n  this.statistics.texturesByteLength = 0;\n  this._clippingPlanes = this._clippingPlanes && this._clippingPlanes.destroy();\n\n  return destroyObject(this);\n};\n\nconst corners = new Array(\n  new Cartesian4(-1.0, -1.0, -1.0, 1.0),\n  new Cartesian4(+1.0, -1.0, -1.0, 1.0),\n  new Cartesian4(-1.0, +1.0, -1.0, 1.0),\n  new Cartesian4(+1.0, +1.0, -1.0, 1.0),\n  new Cartesian4(-1.0, -1.0, +1.0, 1.0),\n  new Cartesian4(+1.0, -1.0, +1.0, 1.0),\n  new Cartesian4(-1.0, +1.0, +1.0, 1.0),\n  new Cartesian4(+1.0, +1.0, +1.0, 1.0),\n);\nconst vertexNeighborIndices = new Array(\n  1,\n  2,\n  4,\n  0,\n  3,\n  5,\n  0,\n  3,\n  6,\n  1,\n  2,\n  7,\n  0,\n  5,\n  6,\n  1,\n  4,\n  7,\n  2,\n  4,\n  7,\n  3,\n  5,\n  6,\n);\n\nconst scratchCornersClipSpace = new Array(\n  new Cartesian4(),\n  new Cartesian4(),\n  new Cartesian4(),\n  new Cartesian4(),\n  new Cartesian4(),\n  new Cartesian4(),\n  new Cartesian4(),\n  new Cartesian4(),\n);\n\n/**\n * Projects all 8 corners of the oriented bounding box to NDC space and finds the\n * resulting NDC axis aligned bounding box. To avoid projecting a vertex that is\n * behind the near plane, it uses the intersection point of each of the vertex's\n * edges against the near plane as part of the AABB calculation. This is done in\n * clip space prior to perspective division.\n *\n * @function\n *\n * @param {OrientedBoundingBox} orientedBoundingBox\n * @param {Matrix4} worldToProjection\n * @param {Cartesian4} result\n * @returns {Cartesian4}\n *\n * @private\n */\nfunction orientedBoundingBoxToNdcAabb(\n  orientedBoundingBox,\n  worldToProjection,\n  result,\n) {\n  const transformPositionLocalToWorld = Matrix4.fromRotationTranslation(\n    orientedBoundingBox.halfAxes,\n    orientedBoundingBox.center,\n    scratchTransformPositionLocalToWorld,\n  );\n  const transformPositionLocalToProjection = Matrix4.multiply(\n    worldToProjection,\n    transformPositionLocalToWorld,\n    scratchTransformPositionLocalToProjection,\n  );\n\n  let ndcMinX = +Number.MAX_VALUE;\n  let ndcMaxX = -Number.MAX_VALUE;\n  let ndcMinY = +Number.MAX_VALUE;\n  let ndcMaxY = -Number.MAX_VALUE;\n  let cornerIndex;\n\n  // Convert all points to clip space\n  const cornersClipSpace = scratchCornersClipSpace;\n  const cornersLength = corners.length;\n  for (cornerIndex = 0; cornerIndex < cornersLength; cornerIndex++) {\n    Matrix4.multiplyByVector(\n      transformPositionLocalToProjection,\n      corners[cornerIndex],\n      cornersClipSpace[cornerIndex],\n    );\n  }\n\n  for (cornerIndex = 0; cornerIndex < cornersLength; cornerIndex++) {\n    const position = cornersClipSpace[cornerIndex];\n    if (position.z >= -position.w) {\n      // Position is past near plane, so there's no need to clip.\n      const ndcX = position.x / position.w;\n      const ndcY = position.y / position.w;\n      ndcMinX = Math.min(ndcMinX, ndcX);\n      ndcMaxX = Math.max(ndcMaxX, ndcX);\n      ndcMinY = Math.min(ndcMinY, ndcY);\n      ndcMaxY = Math.max(ndcMaxY, ndcY);\n    } else {\n      for (let neighborIndex = 0; neighborIndex < 3; neighborIndex++) {\n        const neighborVertexIndex =\n          vertexNeighborIndices[cornerIndex * 3 + neighborIndex];\n        const neighborPosition = cornersClipSpace[neighborVertexIndex];\n        if (neighborPosition.z >= -neighborPosition.w) {\n          // Position is behind the near plane and neighbor is after, so get intersection point on the near plane.\n          const distanceToPlaneFromPosition = position.z + position.w;\n          const distanceToPlaneFromNeighbor =\n            neighborPosition.z + neighborPosition.w;\n          const t =\n            distanceToPlaneFromPosition /\n            (distanceToPlaneFromPosition - distanceToPlaneFromNeighbor);\n\n          const intersect = Cartesian4.lerp(\n            position,\n            neighborPosition,\n            t,\n            scratchIntersect,\n          );\n          const intersectNdcX = intersect.x / intersect.w;\n          const intersectNdcY = intersect.y / intersect.w;\n          ndcMinX = Math.min(ndcMinX, intersectNdcX);\n          ndcMaxX = Math.max(ndcMaxX, intersectNdcX);\n          ndcMinY = Math.min(ndcMinY, intersectNdcY);\n          ndcMaxY = Math.max(ndcMaxY, intersectNdcY);\n        }\n      }\n    }\n  }\n\n  // Clamp the NDC values to -1 to +1 range even if they extend much further.\n  ndcMinX = CesiumMath.clamp(ndcMinX, -1.0, +1.0);\n  ndcMinY = CesiumMath.clamp(ndcMinY, -1.0, +1.0);\n  ndcMaxX = CesiumMath.clamp(ndcMaxX, -1.0, +1.0);\n  ndcMaxY = CesiumMath.clamp(ndcMaxY, -1.0, +1.0);\n  result = Cartesian4.fromElements(ndcMinX, ndcMinY, ndcMaxX, ndcMaxY, result);\n\n  return result;\n}\n\nconst polylineAxisDistance = 30000000.0;\nconst polylineXAxis = new Cartesian3(polylineAxisDistance, 0.0, 0.0);\nconst polylineYAxis = new Cartesian3(0.0, polylineAxisDistance, 0.0);\nconst polylineZAxis = new Cartesian3(0.0, 0.0, polylineAxisDistance);\n\n/**\n * Draws the tile bounding boxes and axes.\n *\n * @function\n *\n * @param {VoxelPrimitive} that\n * @param {FrameState} frameState\n *\n * @private\n */\nfunction debugDraw(that, frameState) {\n  const traversal = that._traversal;\n  const polylines = that._debugPolylines;\n  polylines.removeAll();\n\n  function makePolylineLineSegment(startPos, endPos, color, thickness) {\n    polylines.add({\n      positions: [startPos, endPos],\n      width: thickness,\n      material: Material.fromType(\"Color\", {\n        color: color,\n      }),\n    });\n  }\n\n  function makePolylineBox(orientedBoundingBox, color, thickness) {\n    // Normally would want to use a scratch variable to store the corners, but\n    // polylines don't clone the positions.\n    const corners = orientedBoundingBox.computeCorners();\n    makePolylineLineSegment(corners[0], corners[1], color, thickness);\n    makePolylineLineSegment(corners[2], corners[3], color, thickness);\n    makePolylineLineSegment(corners[4], corners[5], color, thickness);\n    makePolylineLineSegment(corners[6], corners[7], color, thickness);\n    makePolylineLineSegment(corners[0], corners[2], color, thickness);\n    makePolylineLineSegment(corners[4], corners[6], color, thickness);\n    makePolylineLineSegment(corners[1], corners[3], color, thickness);\n    makePolylineLineSegment(corners[5], corners[7], color, thickness);\n    makePolylineLineSegment(corners[0], corners[4], color, thickness);\n    makePolylineLineSegment(corners[2], corners[6], color, thickness);\n    makePolylineLineSegment(corners[1], corners[5], color, thickness);\n    makePolylineLineSegment(corners[3], corners[7], color, thickness);\n  }\n\n  function drawTile(tile) {\n    if (!traversal.isRenderable(tile)) {\n      return;\n    }\n\n    const level = tile.level;\n    const startThickness = 5.0;\n    const thickness = Math.max(1.0, startThickness / Math.pow(2.0, level));\n    const colors = [Color.RED, Color.LIME, Color.BLUE];\n    const color = colors[level % 3];\n\n    makePolylineBox(tile.orientedBoundingBox, color, thickness);\n\n    if (defined(tile.children)) {\n      for (let i = 0; i < 8; i++) {\n        drawTile(tile.children[i]);\n      }\n    }\n  }\n\n  makePolylineBox(that._shape.orientedBoundingBox, Color.WHITE, 5.0);\n\n  drawTile(traversal.rootNode);\n\n  const axisThickness = 10.0;\n  makePolylineLineSegment(\n    Cartesian3.ZERO,\n    polylineXAxis,\n    Color.RED,\n    axisThickness,\n  );\n  makePolylineLineSegment(\n    Cartesian3.ZERO,\n    polylineYAxis,\n    Color.LIME,\n    axisThickness,\n  );\n  makePolylineLineSegment(\n    Cartesian3.ZERO,\n    polylineZAxis,\n    Color.BLUE,\n    axisThickness,\n  );\n\n  polylines.update(frameState);\n}\n\n/**\n * The default custom shader used by the primitive.\n *\n * @type {CustomShader}\n * @constant\n * @readonly\n *\n * @private\n */\nVoxelPrimitive.DefaultCustomShader = new CustomShader({\n  fragmentShaderText: `void fragmentMain(FragmentInput fsInput, inout czm_modelMaterial material)\n{\n    material.diffuse = vec3(1.0);\n    material.alpha = 1.0;\n}`,\n});\n\nfunction DefaultVoxelProvider() {\n  this.ready = true;\n  this.shape = VoxelShapeType.BOX;\n  this.dimensions = new Cartesian3(1, 1, 1);\n  this.names = [\"data\"];\n  this.types = [MetadataType.SCALAR];\n  this.componentTypes = [MetadataComponentType.FLOAT32];\n  this.maximumTileCount = 1;\n}\n\nDefaultVoxelProvider.prototype.requestData = function (options) {\n  const tileLevel = defined(options) ? (options.tileLevel ?? 0) : 0;\n  if (tileLevel >= 1) {\n    return undefined;\n  }\n\n  const content = new VoxelContent({ metadata: [new Float32Array(1)] });\n  return Promise.resolve(content);\n};\n\nVoxelPrimitive.DefaultProvider = new DefaultVoxelProvider();\n\nexport default VoxelPrimitive;\n"],"mappings":";;;;;;;AAAA,OAAOA,sBAAsB,MAAM,6BAA6B;AAChE,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,yBAAyB,MAAM,gCAAgC;AACtE,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,uBAAuB,MAAM,8BAA8B;AAClE,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,MAAM,MAAM,mBAAmB;AACtC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,aAAa,MAAM,0BAA0B;AACpD,OAAOC,SAAS,MAAM,sBAAsB;AAC5C,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,QAAQ,MAAM,eAAe;AACpC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,qBAAqB,MAAM,4BAA4B;AAC9D,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,kBAAkB,MAAM,yBAAyB;AACxD,OAAOC,oBAAoB,MAAM,iCAAiC;AAClE,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,cAAc,MAAM,qBAAqB;AAChD,OAAOC,cAAc,MAAM,qBAAqB;AAChD,OAAOC,kBAAkB,MAAM,yBAAyB;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,cAAcA,CAACC,OAAO,EAAE;EAC/BA,OAAO,GAAGA,OAAO,IAAInB,MAAM,CAACoB,YAAY;;EAExC;AACF;AACA;AACA;EACE,IAAI,CAACC,MAAM,GAAG,KAAK;;EAEnB;AACF;AACA;AACA;EACE,IAAI,CAACC,SAAS,GAAGH,OAAO,CAACI,QAAQ,IAAIL,cAAc,CAACM,eAAe;;EAEnE;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAGC,SAAS;;EAE3B;AACF;AACA;AACA;EACE,IAAI,CAACC,WAAW,GAAG,IAAIlC,yBAAyB,CAAC,CAAC;;EAElD;AACF;AACA;AACA;EACE,IAAI,CAACmC,oBAAoB,GAAGT,OAAO,CAACU,mBAAmB,IAAI,KAAK;;EAEhE;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,MAAM,GAAGJ,SAAS;;EAEvB;AACF;AACA;AACA;EACE,IAAI,CAACK,aAAa,GAAG,KAAK;;EAE1B;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,WAAW,GAAG,IAAI1C,UAAU,CAAC,CAAC;;EAEnC;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAAC2C,gBAAgB,GAAG,IAAI3C,UAAU,CAAC,CAAC;;EAExC;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAAC4C,cAAc,GAAG,IAAI5C,UAAU,CAAC,CAAC;;EAEtC;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAAC6C,aAAa,GAAG,IAAI7C,UAAU,CAAC,CAAC;;EAErC;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAAC8C,gBAAgB,GAAG,CAAC;;EAEzB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAG,IAAI/C,UAAU,CAAC,CAAC;;EAElC;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACgD,aAAa,GAAG,IAAIhD,UAAU,CAAC,CAAC;;EAErC;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACiD,UAAU,GAAG,IAAIjD,UAAU,CAAC,CAAC;;EAElC;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACkD,aAAa,GAAG,IAAIlD,UAAU,CAAC,CAAC;;EAErC;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACmD,qBAAqB,GAAG,IAAInD,UAAU,CAAC,CAAC;;EAE7C;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACoD,w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IAAI,CAACmH,gBAAgB,GAAG,CAAC,CAAC;;EAE1B;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,WAAW,GAAG,CAAC,CAAC;EAErB,MAAMC,QAAQ,GAAG,IAAI,CAAC/B,SAAS;EAC/B,MAAMgC,UAAU,GAAG,IAAI,CAACF,WAAW;EACnC,KAAK,MAAMG,GAAG,IAAIF,QAAQ,EAAE;IAC1B,IAAIA,QAAQ,CAACG,cAAc,CAACD,GAAG,CAAC,EAAE;MAChC,MAAME,IAAI,GAAG,KAAKF,GAAG,EAAE;MACvBD,UAAU,CAACG,IAAI,CAAC,GAAG,YAAY;QAC7B,OAAOJ,QAAQ,CAACE,GAAG,CAAC;MACtB,CAAC;IACH;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACG,QAAQ,GAAG,IAAIlH,KAAK,CAAC,CAAC;;EAE3B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACmH,WAAW,GAAG,IAAInH,KAAK,CAAC,CAAC;;EAE9B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACoH,UAAU,GAAG,IAAIpH,KAAK,CAAC,CAAC;;EAE7B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACqH,UAAU,GAAG,IAAIrH,KAAK,CAAC,CAAC;;EAE7B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACsH,YAAY,GAAG,IAAItH,KAAK,CAAC,CAAC;;EAE/B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACuH,cAAc,GAAG,IAAIvH,KAAK,CAAC,CAAC;;EAEjC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}