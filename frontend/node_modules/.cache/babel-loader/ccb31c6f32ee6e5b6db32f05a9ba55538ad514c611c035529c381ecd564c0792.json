{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport defined from \"../../Core/defined.js\";\nimport Rectangle from \"../../Core/Rectangle.js\";\nimport CartesianRectangle from \"./CartesianRectangle.js\";\nconst imageryBoundsScratch = new Rectangle();\nconst overlappedRectangleScratch = new Rectangle();\nconst clippedRectangleScratch = new Rectangle();\nconst nativeInputRectangleScratch = new Rectangle();\nconst nativeImageryBoundsScratch = new Rectangle();\nconst nativeClippedImageryBoundsScratch = new Rectangle();\n\n/**\n * A class containing information about a piece of imagery.\n *\n * This represents the result of computing the imagery tiles that\n * are covered by a given <code>Rectangle</code> (and which part\n * of that imagery is covered, in terms of texture coordinates).\n *\n * This class represents a plain structure, without member functions.\n * Instances are created with the <code>createImageryCoverages</code>\n * function.\n *\n * The instances are used by the <code>ModelPrimitiveImagery</code>, to\n * represent the imagery tiles that are covered by the cartographic\n * bounding rectangle of the primitive positions.\n *\n * Implementation note for ImageryCoverage:\n *\n * Some of the static functions in this class have been extracted from\n * <code>ImageryLayer.prototype._createTileImagerySkeletons</code>\n * See https://github.com/CesiumGS/cesium/blob/5eaa2280f495d8f300d9e1f0497118c97aec54c8/packages/engine/Source/Scene/ImageryLayer.js#L700\n * An instance of this class roughly corresponds to the <code>TileImagery</code>\n * that is created there.\n *\n * @private\n */\nclass ImageryCoverage {\n  /**\n   * Creates a new instance.\n   *\n   * @param {number} x x-coordinate of the imagery tile\n   * @param {number} y y-coordinate of the imagery tile\n   * @param {number} level level of the imagery tile\n   * @param {CartesianRectangle} textureCoordinateRectangle The texture coordinate\n   * rectangle from the imagery tile that is covered\n   * @param {Imagery} imagery The imagery\n   */\n  constructor(x, y, level, textureCoordinateRectangle, imagery) {\n    this._x = x;\n    this._y = y;\n    this._level = level;\n    this._textureCoordinateRectangle = textureCoordinateRectangle;\n    this._imagery = imagery;\n  }\n\n  /**\n   * The x-coordinate of the imagery tile, typically correlated with longitude\n   *\n   * @type {number}\n   * @readonly\n   */\n  get x() {\n    return this._x;\n  }\n\n  /**\n   * The y-coordinate of the imagery tile, typically correlated with latitude\n   *\n   * @type {number}\n   * @readonly\n   */\n  get y() {\n    return this._y;\n  }\n\n  /**\n   * The level of the imagery tile\n   *\n   * @type {number}\n   * @readonly\n   */\n  get level() {\n    return this._level;\n  }\n\n  /**\n   * The texture coordinate range that is covered from the\n   * imagery tile.\n   *\n   * This is a <code>CartesianRectangle</code> that contains the\n   * (minU, minV, maxU, maxV) coordinate range.\n   *\n   * Clients may not modify the returned instance.\n   *\n   * @type {CartesianRectangle}\n   * @readonly\n   */\n  get textureCoordinateRectangle() {\n    return this._textureCoordinateRectangle;\n  }\n\n  /**\n   * Returns the imagery\n   *\n   * @type {Imagery}\n   * @readonly\n   */\n  get imagery() {\n    return this._imagery;\n  }\n\n  /**\n   * Computes the <code>ImageryCoverage</code> objects that describe the imagery\n   * tiles and the respective texture coordinates that are covered by the given\n   * input rectangle in the given imagery data.\n   *\n   * The given imagery level will be clamped if necessary, to be in the valid\n   * range for the imagery provider of the given imagery layer.\n   *\n   * @param {Rectangle} inputRectangle The input rectangle (e.g. tile bounds)\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @param {number} inputImageryLevel The level for which the imagery coverage\n   * should be computed.\n   * @returns {ImageryCoverage[]} The objects describing the covered imagery\n   * and the respective texture coordinates\n   */\n  static createImageryCoverages(inputRectangle, imageryLayer, inputImageryLevel) {\n    if (!imageryLayer.show) {\n      return [];\n    }\n    const imageryProvider = imageryLayer.imageryProvider;\n    const imageryLevel = ImageryCoverage._clampImageryLevel(imageryProvider, inputImageryLevel);\n\n    // Compute the range, in integer coordinates, of imagery\n    // tiles that are covered by the input rectangle\n    const imageryBounds = Rectangle.intersection(imageryProvider.rectangle, imageryLayer.rectangle, imageryBoundsScratch);\n    const imageryTilingScheme = imageryProvider.tilingScheme;\n    const imageryRange = ImageryCoverage._computeImageryRange(inputRectangle, imageryBounds, imageryTilingScheme, imageryLevel);\n\n    // Convert the input rectangle and the imagery bounds into\n    // the native coordinate system of the tiling scheme\n    const nativeInputRectangle = nativeInputRectangleScratch;\n    imageryTilingScheme.rectangleToNativeRectangle(inputRectangle, nativeInputRectangle);\n    const nativeImageryBounds = nativeImageryBoundsScratch;\n    imageryTilingScheme.rectangleToNativeRectangle(imageryBounds, nativeImageryBounds);\n\n    // A function that returns an imagery rectangle, based on (x, y, level),\n    // clipped to the imagery bounds (or undefined if there is no intersection\n    // between the imagery rectangle and the bounds)\n    const computeClippedImageryRectangle = (x, y, level) => {\n      const localImageryRectangle = imageryTilingScheme.tileXYToRectangle(x, y, level);\n      const localClippedImageryRectangle = Rectangle.intersection(localImageryRectangle, imageryBounds, clippedRectangleScratch);\n      if (!defined(localClippedImageryRectangle)) {\n        return undefined;\n      }\n      const nativeClippedImageryBounds = nativeClippedImageryBoundsScratch;\n      imageryTilingScheme.rectangleToNativeRectangle(localClippedImageryRectangle, nativeClippedImageryBounds);\n      return nativeClippedImageryBounds;\n    };\n    const imageryCoverages = ImageryCoverage._computeImageryCoverages(imageryLayer, imageryRange, imageryLevel, nativeInputRectangle, computeClippedImageryRectangle);\n    return imageryCoverages;\n  }\n\n  /**\n   * Validate the given imagery level against the constraints of the\n   * given imagery provider.\n   *\n   * This will clamp the given level to be in the range\n   * <code>[minimumLevel, maximumLevel)</code> that is\n   * defined by the given imagery provider (and cut off\n   * any fractional part that the input may have)\n   *\n   * @param {ImageryProvider} imageryProvider The imagery provider\n   * @param {number} imageryLevel The imagery level\n   * @returns {number} The validated level\n   */\n  static _clampImageryLevel(imageryProvider, imageryLevel) {\n    const minimumLevel = imageryProvider.minimumLevel ?? 0;\n    const maximumLevel = imageryProvider.maximumLevel ?? Number.POSITIVE_INFINITY;\n    const clampedImageryLevel = Math.min(maximumLevel - 1, Math.max(minimumLevel, imageryLevel));\n    const validImageryLevel = Math.floor(clampedImageryLevel);\n    return validImageryLevel;\n  }\n\n  /**\n   * Compute the rectangle describing the range of imagery that is covered\n   * with the given rectangle.\n   *\n   * This will compute a rectangle with integer coordinates that describe\n   * the X/Y coordinates of the imagery that is overlapped by the given\n   * input rectangle, based on the given imagery rectangle.\n   *\n   * Extracted from _createTileImagerySkeletons.\n   *\n   * @param {Rectangle} inputRectangle The input rectangle\n   * @param {Rectangle} imageryBounds The imagery bounds\n   * @param {TilingScheme} imageryTilingScheme The tiling scheme\n   * @param {number} imageryLevel The imagery level\n   * @returns {CartesianRectangle} The rectangle\n   */\n  static _computeImageryRange(inputRectangle, imageryBounds, imageryTilingScheme, imageryLevel) {\n    const overlappedRectangle = ImageryCoverage._computeOverlappedRectangle(inputRectangle, imageryBounds);\n    const northwestTileCoordinates = imageryTilingScheme.positionToTileXY(Rectangle.northwest(overlappedRectangle), imageryLevel);\n    const southeastTileCoordinates = imageryTilingScheme.positionToTileXY(Rectangle.southeast(overlappedRectangle), imageryLevel);\n    const result = new CartesianRectangle();\n    result.minX = northwestTileCoordinates.x;\n    result.minY = northwestTileCoordinates.y;\n    result.maxX = southeastTileCoordinates.x;\n    result.maxY = southeastTileCoordinates.y;\n\n    // As extracted from _createTileImagerySkeletons:\n    // If the southeast corner of the rectangle lies very close to the north or west side\n    // of the southeast tile, we don't actually need the southernmost or easternmost\n    // tiles.\n    // Similarly, if the northwest corner of the rectangle lies very close to the south or east side\n    // of the northwest tile, we don't actually need the northernmost or westernmost tiles.\n    // We define \"very close\" as being within 1/512 of the width of the tile.\n    const veryCloseX = inputRectangle.width / 512.0;\n    const veryCloseY = inputRectangle.height / 512.0;\n    const northwestTileRectangle = imageryTilingScheme.tileXYToRectangle(result.minX, result.minY, imageryLevel);\n    const deltaNorth = Math.abs(northwestTileRectangle.south - inputRectangle.north);\n    if (deltaNorth < veryCloseY && result.minY < result.maxY) {\n      ++result.minY;\n    }\n    const deltaWest = Math.abs(northwestTileRectangle.east - inputRectangle.west);\n    if (deltaWest < veryCloseX && result.minX < result.maxX) {\n      ++result.minX;\n    }\n    const southeastTileRectangle = imageryTilingScheme.tileXYToRectangle(result.maxX, result.maxY, imageryLevel);\n    const deltaSouth = Math.abs(southeastTileRectangle.north - inputRectangle.south);\n    if (deltaSouth < veryCloseY && result.maxY > result.minY) {\n      --result.maxY;\n    }\n    const deltaEast = Math.abs(southeastTileRectangle.west - inputRectangle.east);\n    if (deltaEast < veryCloseX && result.maxX > result.minX) {\n      --result.maxX;\n    }\n    return result;\n  }\n\n  /**\n   * Clamp the given input rectangle to the given clamp rectangle.\n   *\n   * If the input rectangle is completely above/below or left/right\n   * of the clamp rectangle, then the north/south or east/east\n   * if the clamp rectangle will be used in the result.\n   *\n   * @param {Rectangle} input The input rectangle\n   * @param {Rectangle} clamp The clamping rectangle\n   * @param {Rectangle} [result] The result\n   * @returns {Rectangle} The result\n   */\n  static _clampRectangle(input, clamp, result) {\n    if (!defined(result)) {\n      result = new Rectangle();\n    }\n    if (input.south >= clamp.north) {\n      result.north = result.south = clamp.north;\n    } else if (input.north <= clamp.south) {\n      result.north = result.south = clamp.south;\n    } else {\n      result.south = Math.max(input.south, clamp.south);\n      result.north = Math.min(input.north, clamp.north);\n    }\n    if (input.west >= clamp.east) {\n      result.west = result.east = clamp.east;\n    } else if (input.east <= clamp.west) {\n      result.west = result.east = clamp.west;\n    } else {\n      result.west = Math.max(input.west, clamp.west);\n      result.east = Math.min(input.east, clamp.east);\n    }\n    return result;\n  }\n\n  /**\n   * Compute overlap between the given input rectangle, and the given\n   * bounds that have been obtained from the imagery provider.\n   *\n   * @param {Rectangle} inputRectangle The input\n   * @param {Rectangle} imageryBounds The imagery bounds\n   * @returns {Rectangle} The rectangle\n   */\n  static _computeOverlappedRectangle(inputRectangle, imageryBounds) {\n    const overlappedRectangle = Rectangle.intersection(inputRectangle, imageryBounds, overlappedRectangleScratch);\n    if (defined(overlappedRectangle)) {\n      return overlappedRectangle;\n    }\n    return ImageryCoverage._clampRectangle(inputRectangle, imageryBounds, overlappedRectangleScratch);\n  }\n\n  /**\n   * Computes the <code>ImageryCoverage</code> objects that describe the imagery and\n   * the texture coordinates that are contained in the given range of\n   * imagery tile coordinates, referring to the given input rectangle.\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @param {CartesianRectangle} imageryRange The range of imagery tile coordinates\n   * @param {number} imageryLevel The imagery level\n   * @param {Rectangle} nativeInputRectangle The input rectangle, in coordinates\n   * that are native for the tiling scheme\n   * @param {Function} computeClippedImageryRectangle A function that returns\n   * an imagery rectangle, based on (x, y, level), clipped to the imagery bounds\n   * (or undefined if there is no intersection between the imagery rectangle\n   * and the bounds)\n   * @returns {ImageryCoverage[]} The objects describing the covered imagery\n   * and the respective texture coordinates\n   */\n  static _computeImageryCoverages(imageryLayer, imageryRange, imageryLevel, nativeInputRectangle, computeClippedImageryRectangle) {\n    const imageryCoverages = [];\n    for (let i = imageryRange.minX; i <= imageryRange.maxX; i++) {\n      const clippedImageryRectangleU = computeClippedImageryRectangle(i, imageryRange.maxY, imageryLevel);\n      if (!defined(clippedImageryRectangleU)) {\n        continue;\n      }\n      for (let j = imageryRange.minY; j <= imageryRange.maxY; j++) {\n        const clippedImageryRectangleV = computeClippedImageryRectangle(i, j, imageryLevel);\n        if (!defined(clippedImageryRectangleV)) {\n          continue;\n        }\n        const textureCoordinateRectangle = ImageryCoverage._localizeToCartesianRectangle(clippedImageryRectangleV, nativeInputRectangle, undefined);\n\n        // Note: The getImageryFromCache function will create the whole \"chain\"\n        // of ancestor imageries, up to the root, and increases the reference\n        // counter for each of them, even though it is not called\n        // getImageryFromCacheAndCreateAllAncestorsAndAddReferences.\n        // There is currently no way to have a single imagery, because\n        // somewhere in TileImagery, the parent is assumed to be present.\n        const imagery = imageryLayer.getImageryFromCache(i, j, imageryLevel);\n        const imageryCoverage = new ImageryCoverage(i, j, imageryLevel, textureCoordinateRectangle, imagery);\n        imageryCoverages.push(imageryCoverage);\n      }\n    }\n    return imageryCoverages;\n  }\n\n  /**\n   * Compute the coordinates of the first rectangle relative to the\n   * second rectangle.\n   *\n   * The result will describe the bounds of the first rectangle\n   * in coordinates that are relative to the (south,west) and\n   * (width, height) of the second rectangle. This is suitable\n   * for describing the texture coordinates of the first\n   * rectangle within the second one.\n   *\n   * The result will be stored in the given result parameter, or\n   * in a new rectangle if the result was undefined.\n   *\n   * @param {Rectangle} rectangleA The first rectangle\n   * @param {Rectangle} rectangleB The second rectangle\n   * @param {CartesianRectangle} [result] The result\n   * @returns {CartesianRectangle} The result\n   */\n  static _localizeToCartesianRectangle(rectangleA, rectangleB, result) {\n    if (!defined(result)) {\n      result = new CartesianRectangle();\n    }\n    const invX = 1.0 / rectangleB.width;\n    const invY = 1.0 / rectangleB.height;\n    result.minX = (rectangleA.west - rectangleB.west) * invX;\n    result.minY = (rectangleA.south - rectangleB.south) * invY;\n    result.maxX = (rectangleA.east - rectangleB.west) * invX;\n    result.maxY = (rectangleA.north - rectangleB.south) * invY;\n    return result;\n  }\n}\nexport default ImageryCoverage;","map":{"version":3,"names":["defined","Rectangle","CartesianRectangle","imageryBoundsScratch","overlappedRectangleScratch","clippedRectangleScratch","nativeInputRectangleScratch","nativeImageryBoundsScratch","nativeClippedImageryBoundsScratch","ImageryCoverage","constructor","x","y","level","textureCoordinateRectangle","imagery","_x","_y","_level","_textureCoordinateRectangle","_imagery","createImageryCoverages","inputRectangle","imageryLayer","inputImageryLevel","show","imageryProvider","imageryLevel","_clampImageryLevel","imageryBounds","intersection","rectangle","imageryTilingScheme","tilingScheme","imageryRange","_computeImageryRange","nativeInputRectangle","rectangleToNativeRectangle","nativeImageryBounds","computeClippedImageryRectangle","localImageryRectangle","tileXYToRectangle","localClippedImageryRectangle","undefined","nativeClippedImageryBounds","imageryCoverages","_computeImageryCoverages","minimumLevel","maximumLevel","Number","POSITIVE_INFINITY","clampedImageryLevel","Math","min","max","validImageryLevel","floor","overlappedRectangle","_computeOverlappedRectangle","northwestTileCoordinates","positionToTileXY","northwest","southeastTileCoordinates","southeast","result","minX","minY","maxX","maxY","veryCloseX","width","veryCloseY","height","northwestTileRectangle","deltaNorth","abs","south","north","deltaWest","east","west","southeastTileRectangle","deltaSouth","deltaEast","_clampRectangle","input","clamp","i","clippedImageryRectangleU","j","clippedImageryRectangleV","_localizeToCartesianRectangle","getImageryFromCache","imageryCoverage","push","rectangleA","rectangleB","invX","invY"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Model/ImageryCoverage.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport Rectangle from \"../../Core/Rectangle.js\";\n\nimport CartesianRectangle from \"./CartesianRectangle.js\";\n\nconst imageryBoundsScratch = new Rectangle();\nconst overlappedRectangleScratch = new Rectangle();\nconst clippedRectangleScratch = new Rectangle();\nconst nativeInputRectangleScratch = new Rectangle();\nconst nativeImageryBoundsScratch = new Rectangle();\nconst nativeClippedImageryBoundsScratch = new Rectangle();\n\n/**\n * A class containing information about a piece of imagery.\n *\n * This represents the result of computing the imagery tiles that\n * are covered by a given <code>Rectangle</code> (and which part\n * of that imagery is covered, in terms of texture coordinates).\n *\n * This class represents a plain structure, without member functions.\n * Instances are created with the <code>createImageryCoverages</code>\n * function.\n *\n * The instances are used by the <code>ModelPrimitiveImagery</code>, to\n * represent the imagery tiles that are covered by the cartographic\n * bounding rectangle of the primitive positions.\n *\n * Implementation note for ImageryCoverage:\n *\n * Some of the static functions in this class have been extracted from\n * <code>ImageryLayer.prototype._createTileImagerySkeletons</code>\n * See https://github.com/CesiumGS/cesium/blob/5eaa2280f495d8f300d9e1f0497118c97aec54c8/packages/engine/Source/Scene/ImageryLayer.js#L700\n * An instance of this class roughly corresponds to the <code>TileImagery</code>\n * that is created there.\n *\n * @private\n */\nclass ImageryCoverage {\n  /**\n   * Creates a new instance.\n   *\n   * @param {number} x x-coordinate of the imagery tile\n   * @param {number} y y-coordinate of the imagery tile\n   * @param {number} level level of the imagery tile\n   * @param {CartesianRectangle} textureCoordinateRectangle The texture coordinate\n   * rectangle from the imagery tile that is covered\n   * @param {Imagery} imagery The imagery\n   */\n  constructor(x, y, level, textureCoordinateRectangle, imagery) {\n    this._x = x;\n    this._y = y;\n    this._level = level;\n    this._textureCoordinateRectangle = textureCoordinateRectangle;\n    this._imagery = imagery;\n  }\n\n  /**\n   * The x-coordinate of the imagery tile, typically correlated with longitude\n   *\n   * @type {number}\n   * @readonly\n   */\n  get x() {\n    return this._x;\n  }\n\n  /**\n   * The y-coordinate of the imagery tile, typically correlated with latitude\n   *\n   * @type {number}\n   * @readonly\n   */\n  get y() {\n    return this._y;\n  }\n\n  /**\n   * The level of the imagery tile\n   *\n   * @type {number}\n   * @readonly\n   */\n  get level() {\n    return this._level;\n  }\n\n  /**\n   * The texture coordinate range that is covered from the\n   * imagery tile.\n   *\n   * This is a <code>CartesianRectangle</code> that contains the\n   * (minU, minV, maxU, maxV) coordinate range.\n   *\n   * Clients may not modify the returned instance.\n   *\n   * @type {CartesianRectangle}\n   * @readonly\n   */\n  get textureCoordinateRectangle() {\n    return this._textureCoordinateRectangle;\n  }\n\n  /**\n   * Returns the imagery\n   *\n   * @type {Imagery}\n   * @readonly\n   */\n  get imagery() {\n    return this._imagery;\n  }\n\n  /**\n   * Computes the <code>ImageryCoverage</code> objects that describe the imagery\n   * tiles and the respective texture coordinates that are covered by the given\n   * input rectangle in the given imagery data.\n   *\n   * The given imagery level will be clamped if necessary, to be in the valid\n   * range for the imagery provider of the given imagery layer.\n   *\n   * @param {Rectangle} inputRectangle The input rectangle (e.g. tile bounds)\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @param {number} inputImageryLevel The level for which the imagery coverage\n   * should be computed.\n   * @returns {ImageryCoverage[]} The objects describing the covered imagery\n   * and the respective texture coordinates\n   */\n  static createImageryCoverages(\n    inputRectangle,\n    imageryLayer,\n    inputImageryLevel,\n  ) {\n    if (!imageryLayer.show) {\n      return [];\n    }\n\n    const imageryProvider = imageryLayer.imageryProvider;\n    const imageryLevel = ImageryCoverage._clampImageryLevel(\n      imageryProvider,\n      inputImageryLevel,\n    );\n\n    // Compute the range, in integer coordinates, of imagery\n    // tiles that are covered by the input rectangle\n    const imageryBounds = Rectangle.intersection(\n      imageryProvider.rectangle,\n      imageryLayer.rectangle,\n      imageryBoundsScratch,\n    );\n    const imageryTilingScheme = imageryProvider.tilingScheme;\n    const imageryRange = ImageryCoverage._computeImageryRange(\n      inputRectangle,\n      imageryBounds,\n      imageryTilingScheme,\n      imageryLevel,\n    );\n\n    // Convert the input rectangle and the imagery bounds into\n    // the native coordinate system of the tiling scheme\n    const nativeInputRectangle = nativeInputRectangleScratch;\n    imageryTilingScheme.rectangleToNativeRectangle(\n      inputRectangle,\n      nativeInputRectangle,\n    );\n    const nativeImageryBounds = nativeImageryBoundsScratch;\n    imageryTilingScheme.rectangleToNativeRectangle(\n      imageryBounds,\n      nativeImageryBounds,\n    );\n\n    // A function that returns an imagery rectangle, based on (x, y, level),\n    // clipped to the imagery bounds (or undefined if there is no intersection\n    // between the imagery rectangle and the bounds)\n    const computeClippedImageryRectangle = (x, y, level) => {\n      const localImageryRectangle = imageryTilingScheme.tileXYToRectangle(\n        x,\n        y,\n        level,\n      );\n      const localClippedImageryRectangle = Rectangle.intersection(\n        localImageryRectangle,\n        imageryBounds,\n        clippedRectangleScratch,\n      );\n      if (!defined(localClippedImageryRectangle)) {\n        return undefined;\n      }\n      const nativeClippedImageryBounds = nativeClippedImageryBoundsScratch;\n      imageryTilingScheme.rectangleToNativeRectangle(\n        localClippedImageryRectangle,\n        nativeClippedImageryBounds,\n      );\n      return nativeClippedImageryBounds;\n    };\n\n    const imageryCoverages = ImageryCoverage._computeImageryCoverages(\n      imageryLayer,\n      imageryRange,\n      imageryLevel,\n      nativeInputRectangle,\n      computeClippedImageryRectangle,\n    );\n    return imageryCoverages;\n  }\n\n  /**\n   * Validate the given imagery level against the constraints of the\n   * given imagery provider.\n   *\n   * This will clamp the given level to be in the range\n   * <code>[minimumLevel, maximumLevel)</code> that is\n   * defined by the given imagery provider (and cut off\n   * any fractional part that the input may have)\n   *\n   * @param {ImageryProvider} imageryProvider The imagery provider\n   * @param {number} imageryLevel The imagery level\n   * @returns {number} The validated level\n   */\n  static _clampImageryLevel(imageryProvider, imageryLevel) {\n    const minimumLevel = imageryProvider.minimumLevel ?? 0;\n    const maximumLevel =\n      imageryProvider.maximumLevel ?? Number.POSITIVE_INFINITY;\n    const clampedImageryLevel = Math.min(\n      maximumLevel - 1,\n      Math.max(minimumLevel, imageryLevel),\n    );\n    const validImageryLevel = Math.floor(clampedImageryLevel);\n    return validImageryLevel;\n  }\n\n  /**\n   * Compute the rectangle describing the range of imagery that is covered\n   * with the given rectangle.\n   *\n   * This will compute a rectangle with integer coordinates that describe\n   * the X/Y coordinates of the imagery that is overlapped by the given\n   * input rectangle, based on the given imagery rectangle.\n   *\n   * Extracted from _createTileImagerySkeletons.\n   *\n   * @param {Rectangle} inputRectangle The input rectangle\n   * @param {Rectangle} imageryBounds The imagery bounds\n   * @param {TilingScheme} imageryTilingScheme The tiling scheme\n   * @param {number} imageryLevel The imagery level\n   * @returns {CartesianRectangle} The rectangle\n   */\n  static _computeImageryRange(\n    inputRectangle,\n    imageryBounds,\n    imageryTilingScheme,\n    imageryLevel,\n  ) {\n    const overlappedRectangle = ImageryCoverage._computeOverlappedRectangle(\n      inputRectangle,\n      imageryBounds,\n    );\n    const northwestTileCoordinates = imageryTilingScheme.positionToTileXY(\n      Rectangle.northwest(overlappedRectangle),\n      imageryLevel,\n    );\n    const southeastTileCoordinates = imageryTilingScheme.positionToTileXY(\n      Rectangle.southeast(overlappedRectangle),\n      imageryLevel,\n    );\n\n    const result = new CartesianRectangle();\n    result.minX = northwestTileCoordinates.x;\n    result.minY = northwestTileCoordinates.y;\n    result.maxX = southeastTileCoordinates.x;\n    result.maxY = southeastTileCoordinates.y;\n\n    // As extracted from _createTileImagerySkeletons:\n    // If the southeast corner of the rectangle lies very close to the north or west side\n    // of the southeast tile, we don't actually need the southernmost or easternmost\n    // tiles.\n    // Similarly, if the northwest corner of the rectangle lies very close to the south or east side\n    // of the northwest tile, we don't actually need the northernmost or westernmost tiles.\n    // We define \"very close\" as being within 1/512 of the width of the tile.\n    const veryCloseX = inputRectangle.width / 512.0;\n    const veryCloseY = inputRectangle.height / 512.0;\n\n    const northwestTileRectangle = imageryTilingScheme.tileXYToRectangle(\n      result.minX,\n      result.minY,\n      imageryLevel,\n    );\n    const deltaNorth = Math.abs(\n      northwestTileRectangle.south - inputRectangle.north,\n    );\n    if (deltaNorth < veryCloseY && result.minY < result.maxY) {\n      ++result.minY;\n    }\n    const deltaWest = Math.abs(\n      northwestTileRectangle.east - inputRectangle.west,\n    );\n    if (deltaWest < veryCloseX && result.minX < result.maxX) {\n      ++result.minX;\n    }\n\n    const southeastTileRectangle = imageryTilingScheme.tileXYToRectangle(\n      result.maxX,\n      result.maxY,\n      imageryLevel,\n    );\n    const deltaSouth = Math.abs(\n      southeastTileRectangle.north - inputRectangle.south,\n    );\n    if (deltaSouth < veryCloseY && result.maxY > result.minY) {\n      --result.maxY;\n    }\n    const deltaEast = Math.abs(\n      southeastTileRectangle.west - inputRectangle.east,\n    );\n    if (deltaEast < veryCloseX && result.maxX > result.minX) {\n      --result.maxX;\n    }\n\n    return result;\n  }\n\n  /**\n   * Clamp the given input rectangle to the given clamp rectangle.\n   *\n   * If the input rectangle is completely above/below or left/right\n   * of the clamp rectangle, then the north/south or east/east\n   * if the clamp rectangle will be used in the result.\n   *\n   * @param {Rectangle} input The input rectangle\n   * @param {Rectangle} clamp The clamping rectangle\n   * @param {Rectangle} [result] The result\n   * @returns {Rectangle} The result\n   */\n  static _clampRectangle(input, clamp, result) {\n    if (!defined(result)) {\n      result = new Rectangle();\n    }\n    if (input.south >= clamp.north) {\n      result.north = result.south = clamp.north;\n    } else if (input.north <= clamp.south) {\n      result.north = result.south = clamp.south;\n    } else {\n      result.south = Math.max(input.south, clamp.south);\n      result.north = Math.min(input.north, clamp.north);\n    }\n\n    if (input.west >= clamp.east) {\n      result.west = result.east = clamp.east;\n    } else if (input.east <= clamp.west) {\n      result.west = result.east = clamp.west;\n    } else {\n      result.west = Math.max(input.west, clamp.west);\n      result.east = Math.min(input.east, clamp.east);\n    }\n    return result;\n  }\n\n  /**\n   * Compute overlap between the given input rectangle, and the given\n   * bounds that have been obtained from the imagery provider.\n   *\n   * @param {Rectangle} inputRectangle The input\n   * @param {Rectangle} imageryBounds The imagery bounds\n   * @returns {Rectangle} The rectangle\n   */\n  static _computeOverlappedRectangle(inputRectangle, imageryBounds) {\n    const overlappedRectangle = Rectangle.intersection(\n      inputRectangle,\n      imageryBounds,\n      overlappedRectangleScratch,\n    );\n    if (defined(overlappedRectangle)) {\n      return overlappedRectangle;\n    }\n    return ImageryCoverage._clampRectangle(\n      inputRectangle,\n      imageryBounds,\n      overlappedRectangleScratch,\n    );\n  }\n\n  /**\n   * Computes the <code>ImageryCoverage</code> objects that describe the imagery and\n   * the texture coordinates that are contained in the given range of\n   * imagery tile coordinates, referring to the given input rectangle.\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @param {CartesianRectangle} imageryRange The range of imagery tile coordinates\n   * @param {number} imageryLevel The imagery level\n   * @param {Rectangle} nativeInputRectangle The input rectangle, in coordinates\n   * that are native for the tiling scheme\n   * @param {Function} computeClippedImageryRectangle A function that returns\n   * an imagery rectangle, based on (x, y, level), clipped to the imagery bounds\n   * (or undefined if there is no intersection between the imagery rectangle\n   * and the bounds)\n   * @returns {ImageryCoverage[]} The objects describing the covered imagery\n   * and the respective texture coordinates\n   */\n  static _computeImageryCoverages(\n    imageryLayer,\n    imageryRange,\n    imageryLevel,\n    nativeInputRectangle,\n    computeClippedImageryRectangle,\n  ) {\n    const imageryCoverages = [];\n\n    for (let i = imageryRange.minX; i <= imageryRange.maxX; i++) {\n      const clippedImageryRectangleU = computeClippedImageryRectangle(\n        i,\n        imageryRange.maxY,\n        imageryLevel,\n      );\n\n      if (!defined(clippedImageryRectangleU)) {\n        continue;\n      }\n\n      for (let j = imageryRange.minY; j <= imageryRange.maxY; j++) {\n        const clippedImageryRectangleV = computeClippedImageryRectangle(\n          i,\n          j,\n          imageryLevel,\n        );\n\n        if (!defined(clippedImageryRectangleV)) {\n          continue;\n        }\n\n        const textureCoordinateRectangle =\n          ImageryCoverage._localizeToCartesianRectangle(\n            clippedImageryRectangleV,\n            nativeInputRectangle,\n            undefined,\n          );\n\n        // Note: The getImageryFromCache function will create the whole \"chain\"\n        // of ancestor imageries, up to the root, and increases the reference\n        // counter for each of them, even though it is not called\n        // getImageryFromCacheAndCreateAllAncestorsAndAddReferences.\n        // There is currently no way to have a single imagery, because\n        // somewhere in TileImagery, the parent is assumed to be present.\n        const imagery = imageryLayer.getImageryFromCache(i, j, imageryLevel);\n        const imageryCoverage = new ImageryCoverage(\n          i,\n          j,\n          imageryLevel,\n          textureCoordinateRectangle,\n          imagery,\n        );\n        imageryCoverages.push(imageryCoverage);\n      }\n    }\n    return imageryCoverages;\n  }\n\n  /**\n   * Compute the coordinates of the first rectangle relative to the\n   * second rectangle.\n   *\n   * The result will describe the bounds of the first rectangle\n   * in coordinates that are relative to the (south,west) and\n   * (width, height) of the second rectangle. This is suitable\n   * for describing the texture coordinates of the first\n   * rectangle within the second one.\n   *\n   * The result will be stored in the given result parameter, or\n   * in a new rectangle if the result was undefined.\n   *\n   * @param {Rectangle} rectangleA The first rectangle\n   * @param {Rectangle} rectangleB The second rectangle\n   * @param {CartesianRectangle} [result] The result\n   * @returns {CartesianRectangle} The result\n   */\n  static _localizeToCartesianRectangle(rectangleA, rectangleB, result) {\n    if (!defined(result)) {\n      result = new CartesianRectangle();\n    }\n    const invX = 1.0 / rectangleB.width;\n    const invY = 1.0 / rectangleB.height;\n    result.minX = (rectangleA.west - rectangleB.west) * invX;\n    result.minY = (rectangleA.south - rectangleB.south) * invY;\n    result.maxX = (rectangleA.east - rectangleB.west) * invX;\n    result.maxY = (rectangleA.north - rectangleB.south) * invY;\n    return result;\n  }\n}\n\nexport default ImageryCoverage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}