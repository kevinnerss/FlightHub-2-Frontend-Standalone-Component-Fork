{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cesium3DTilesetMetadata from \"./Cesium3DTilesetMetadata.js\";\nimport Check from \"../Core/Check.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport hasExtension from \"./hasExtension.js\";\nimport ImplicitSubtree from \"./ImplicitSubtree.js\";\nimport ImplicitSubtreeCache from \"./ImplicitSubtreeCache.js\";\nimport ImplicitTileCoordinates from \"./ImplicitTileCoordinates.js\";\nimport ImplicitTileset from \"./ImplicitTileset.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport MetadataSemantic from \"./MetadataSemantic.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport preprocess3DTileContent from \"./preprocess3DTileContent.js\";\nimport Resource from \"../Core/Resource.js\";\nimport ResourceCache from \"./ResourceCache.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport VoxelContent from \"./VoxelContent.js\";\nimport VoxelMetadataOrder from \"./VoxelMetadataOrder.js\";\nimport VoxelShapeType from \"./VoxelShapeType.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\n\n/**\n * @typedef {Object} Cesium3DTilesVoxelProvider.ConstructorOptions\n *\n * Initialization options for the Cesium3DTilesVoxelProvider constructor\n *\n * @property {string} className The class in the tileset schema describing voxel metadata.\n * @property {string[]} names The metadata names.\n * @property {MetadataType[]} types The metadata types.\n * @property {MetadataComponentType[]} componentTypes The metadata component types.\n * @property {VoxelShapeType} shape The {@link VoxelShapeType}.\n * @property {Cartesian3} dimensions The number of voxels per dimension of a tile. This is the same for all tiles in the dataset.\n * @property {Cartesian3} [paddingBefore=Cartesian3.ZERO] The number of padding voxels before the tile. This improves rendering quality when sampling the edge of a tile, but it increases memory usage.\n * @property {Cartesian3} [paddingAfter=Cartesian3.ZERO] The number of padding voxels after the tile. This improves rendering quality when sampling the edge of a tile, but it increases memory usage.\n * @property {Matrix4} [globalTransform=Matrix4.IDENTITY] A transform from local space to global space.\n * @property {Matrix4} [shapeTransform=Matrix4.IDENTITY] A transform from shape space to local space.\n * @property {Cartesian3} [minBounds] The minimum bounds.\n * @property {Cartesian3} [maxBounds] The maximum bounds.\n * @property {number[][]} [minimumValues] The metadata minimum values.\n * @property {number[][]} [maximumValues] The metadata maximum values.\n * @property {number} [maximumTileCount] The maximum number of tiles that exist for this provider. This value is used as a hint to the voxel renderer to allocate an appropriate amount of GPU memory. If this value is not known it can be undefined.\n */\n\n/**\n * A {@link VoxelProvider} that fetches voxel data from a 3D Tiles tileset.\n * <p>\n * Implements the {@link VoxelProvider} interface.\n * </p>\n * <div class=\"notice\">\n * This object is normally not instantiated directly, use {@link Cesium3DTilesVoxelProvider.fromUrl}.\n * </div>\n *\n * @alias Cesium3DTilesVoxelProvider\n * @constructor\n * @augments VoxelProvider\n *\n * @param {Cesium3DTilesVoxelProvider.ConstructorOptions} options An object describing initialization options\n *\n * @see Cesium3DTilesVoxelProvider.fromUrl\n * @see VoxelProvider\n * @see VoxelPrimitive\n * @see VoxelShapeType\n *\n * @experimental This feature is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction Cesium3DTilesVoxelProvider(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const {\n    className,\n    names,\n    types,\n    componentTypes,\n    shape,\n    dimensions,\n    paddingBefore = Cartesian3.ZERO.clone(),\n    paddingAfter = Cartesian3.ZERO.clone(),\n    globalTransform = Matrix4.IDENTITY.clone(),\n    shapeTransform = Matrix4.IDENTITY.clone(),\n    minBounds,\n    maxBounds,\n    minimumValues,\n    maximumValues,\n    maximumTileCount\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"className\", className);\n  Check.typeOf.object(\"names\", names);\n  Check.typeOf.object(\"types\", types);\n  Check.typeOf.object(\"componentTypes\", componentTypes);\n  Check.typeOf.string(\"shape\", shape);\n  Check.typeOf.object(\"dimensions\", dimensions);\n  //>>includeEnd('debug');\n\n  this._shapeTransform = shapeTransform;\n  this._globalTransform = globalTransform;\n  this._shape = shape;\n  this._minBounds = minBounds;\n  this._maxBounds = maxBounds;\n  this._dimensions = dimensions;\n  this._paddingBefore = paddingBefore;\n  this._paddingAfter = paddingAfter;\n  this._className = className;\n  this._names = names;\n  this._types = types;\n  this._componentTypes = componentTypes;\n  this._metadataOrder = shape === VoxelShapeType.ELLIPSOID ? VoxelMetadataOrder.Z_UP : VoxelMetadataOrder.Y_UP;\n  this._minimumValues = minimumValues;\n  this._maximumValues = maximumValues;\n  this._maximumTileCount = maximumTileCount;\n  this._availableLevels = undefined;\n  this._implicitTileset = undefined;\n  this._subtreeCache = new ImplicitSubtreeCache();\n}\nObject.defineProperties(Cesium3DTilesVoxelProvider.prototype, {\n  /**\n   * A transform from local space to global space.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {Matrix4}\n   * @default Matrix4.IDENTITY\n   * @readonly\n   */\n  globalTransform: {\n    get: function () {\n      return this._globalTransform;\n    }\n  },\n  /**\n   * A transform from shape space to local space.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {Matrix4}\n   * @default Matrix4.IDENTITY\n   * @readonly\n   */\n  shapeTransform: {\n    get: function () {\n      return this._shapeTransform;\n    }\n  },\n  /**\n   * Gets the {@link VoxelShapeType}\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {VoxelShapeType}\n   * @readonly\n   */\n  shape: {\n    get: function () {\n      return this._shape;\n    }\n  },\n  /**\n   * Gets the minimum bounds.\n   * If undefined, the shape's default minimum bounds will be used instead.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {Cartesian3|undefined}\n   * @readonly\n   */\n  minBounds: {\n    get: function () {\n      return this._minBounds;\n    }\n  },\n  /**\n   * Gets the maximum bounds.\n   * If undefined, the shape's default maximum bounds will be used instead.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {Cartesian3|undefined}\n   * @readonly\n   */\n  maxBounds: {\n    get: function () {\n      return this._maxBounds;\n    }\n  },\n  /**\n   * Gets the number of voxels per dimension of a tile. This is the same for all tiles in the dataset.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  dimensions: {\n    get: function () {\n      return this._dimensions;\n    }\n  },\n  /**\n   * Gets the number of padding voxels before the tile. This improves rendering quality when sampling the edge of a tile, but it increases memory usage.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {Cartesian3}\n   * @default Cartesian3.ZERO\n   * @readonly\n   */\n  paddingBefore: {\n    get: function () {\n      return this._paddingBefore;\n    }\n  },\n  /**\n   * Gets the number of padding voxels after the tile. This improves rendering quality when sampling the edge of a tile, but it increases memory usage.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {Cartesian3}\n   * @default Cartesian3.ZERO\n   * @readonly\n   */\n  paddingAfter: {\n    get: function () {\n      return this._paddingAfter;\n    }\n  },\n  /**\n   * The metadata class for this tileset.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {string}\n   * @readonly\n   */\n  className: {\n    get: function () {\n      return this._className;\n    }\n  },\n  /**\n   * Gets the metadata names.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {string[]}\n   * @readonly\n   */\n  names: {\n    get: function () {\n      return this._names;\n    }\n  },\n  /**\n   * Gets the metadata types.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {MetadataType[]}\n   * @readonly\n   */\n  types: {\n    get: function () {\n      return this._types;\n    }\n  },\n  /**\n   * Gets the metadata component types.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {MetadataComponentType[]}\n   * @readonly\n   */\n  componentTypes: {\n    get: function () {\n      return this._componentTypes;\n    }\n  },\n  /**\n   * Gets the ordering of the metadata in the buffers.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {VoxelMetadataOrder}\n   * @readonly\n   * @private\n   */\n  metadataOrder: {\n    get: function () {\n      return this._metadataOrder;\n    }\n  },\n  /**\n   * Gets the metadata minimum values.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {number[][]|undefined}\n   * @readonly\n   */\n  minimumValues: {\n    get: function () {\n      return this._minimumValues;\n    }\n  },\n  /**\n   * Gets the metadata maximum values.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {number[][]|undefined}\n   * @readonly\n   */\n  maximumValues: {\n    get: function () {\n      return this._maximumValues;\n    }\n  },\n  /**\n   * The maximum number of tiles that exist for this provider.\n   * This value is used as a hint to the voxel renderer to allocate an appropriate amount of GPU memory.\n   * If this value is not known it can be undefined.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {number|undefined}\n   * @readonly\n   */\n  maximumTileCount: {\n    get: function () {\n      return this._maximumTileCount;\n    }\n  },\n  /**\n   * The number of levels of detail containing available tiles in the tileset.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {number|undefined}\n   * @readonly\n   */\n  availableLevels: {\n    get: function () {\n      return this._availableLevels;\n    }\n  }\n});\n\n/**\n * Creates a {@link Cesium3DTilesVoxelProvider} that fetches voxel data from a 3D Tiles tileset.\n *\n * @param {Resource|string} url The URL to a tileset JSON file\n * @returns {Promise<Cesium3DTilesVoxelProvider>} The created provider\n *\n * @exception {RuntimeException} Root must have content\n * @exception {RuntimeException} Root tile content must have 3DTILES_content_voxels extension\n * @exception {RuntimeException} Root tile must have implicit tiling\n * @exception {RuntimeException} Tileset must have a metadata schema\n * @exception {RuntimeException} Only box, region and 3DTILES_bounding_volume_cylinder are supported in Cesium3DTilesVoxelProvider\n *\n * @example\n * try {\n *   const voxelProvider = await Cesium3DTilesVoxelProvider.fromUrl(\n *     \"http://localhost:8002/tilesets/voxel/tileset.json\"\n *   );\n *   const voxelPrimitive = new VoxelPrimitive({\n *     provider: voxelProvider,\n *     customShader: customShader,\n *   });\n *   scene.primitives.add(voxelPrimitive);\n * } catch (error) {\n *   console.error(`Error creating voxel primitive: ${error}`);\n * }\n *\n * @see {@link VoxelPrimitive}\n */\nCesium3DTilesVoxelProvider.fromUrl = async function (url) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  const resource = Resource.createIfNeeded(url);\n  const tilesetJson = await resource.fetchJson();\n  validate(tilesetJson);\n  const schemaLoader = getMetadataSchemaLoader(tilesetJson, resource);\n  await schemaLoader.load();\n  const {\n    root\n  } = tilesetJson;\n  const metadataJson = hasExtension(tilesetJson, \"3DTILES_metadata\") ? tilesetJson.extensions[\"3DTILES_metadata\"] : tilesetJson;\n  const tilesetMetadata = new Cesium3DTilesetMetadata({\n    metadataJson: metadataJson,\n    schema: schemaLoader.schema\n  });\n  const voxel = root.content.extensions[\"3DTILES_content_voxels\"];\n  const className = voxel.class;\n  const providerOptions = getAttributeInfo(tilesetMetadata, className);\n  Object.assign(providerOptions, getShape(root));\n  if (defined(root.transform)) {\n    providerOptions.globalTransform = Matrix4.unpack(root.transform);\n  } else {\n    providerOptions.globalTransform = Matrix4.clone(Matrix4.IDENTITY);\n  }\n  providerOptions.dimensions = Cartesian3.unpack(voxel.dimensions);\n  providerOptions.maximumTileCount = getTileCount(tilesetMetadata);\n  if (defined(voxel.padding)) {\n    providerOptions.paddingBefore = Cartesian3.unpack(voxel.padding.before);\n    providerOptions.paddingAfter = Cartesian3.unpack(voxel.padding.after);\n  }\n  const provider = new Cesium3DTilesVoxelProvider(providerOptions);\n  const implicitTileset = new ImplicitTileset(resource, root, schemaLoader.schema);\n  provider._implicitTileset = implicitTileset;\n  provider._availableLevels = implicitTileset.availableLevels;\n  ResourceCache.unload(schemaLoader);\n  return provider;\n};\nfunction getTileCount(metadata) {\n  if (!defined(metadata.tileset)) {\n    return undefined;\n  }\n  return metadata.tileset.getPropertyBySemantic(MetadataSemantic.TILESET_TILE_COUNT);\n}\nfunction validate(tileset) {\n  const root = tileset.root;\n  if (!defined(root.content)) {\n    throw new RuntimeError(\"Root must have content\");\n  }\n  if (!hasExtension(root.content, \"3DTILES_content_voxels\")) {\n    throw new RuntimeError(\"Root tile content must have 3DTILES_content_voxels extension\");\n  }\n  if (!hasExtension(root, \"3DTILES_implicit_tiling\") && !defined(root.implicitTiling)) {\n    throw new RuntimeError(\"Root tile must have implicit tiling\");\n  }\n  if (!defined(tileset.schema) && !defined(tileset.schemaUri) && !hasExtension(tileset, \"3DTILES_metadata\")) {\n    throw new RuntimeError(\"Tileset must have a metadata schema\");\n  }\n}\nfunction getShape(tile) {\n  const boundingVolume = tile.boundingVolume;\n  if (defined(boundingVolume.box)) {\n    return getBoxShape(boundingVolume.box);\n  } else if (defined(boundingVolume.region)) {\n    return getEllipsoidShape(boundingVolume.region);\n  } else if (hasExtension(boundingVolume, \"3DTILES_bounding_volume_cylinder\")) {\n    return getCylinderShape(boundingVolume.extensions[\"3DTILES_bounding_volume_cylinder\"]);\n  }\n  throw new RuntimeError(\"Only box, region and 3DTILES_bounding_volume_cylinder are supported in Cesium3DTilesVoxelProvider\");\n}\nfunction getEllipsoidShape(region) {\n  const west = region[0];\n  const south = region[1];\n  const east = region[2];\n  const north = region[3];\n  const minHeight = region[4];\n  const maxHeight = region[5];\n  const shapeTransform = Matrix4.fromScale(Ellipsoid.WGS84.radii);\n  const minBounds = new Cartesian3(west, south, minHeight);\n  const maxBounds = new Cartesian3(east, north, maxHeight);\n  return {\n    shape: VoxelShapeType.ELLIPSOID,\n    minBounds: minBounds,\n    maxBounds: maxBounds,\n    shapeTransform: shapeTransform\n  };\n}\nconst scratchScale = new Cartesian3();\nconst scratchRotation = new Matrix3();\nfunction getBoxShape(box) {\n  const obb = OrientedBoundingBox.unpack(box);\n  const scale = Matrix3.getScale(obb.halfAxes, scratchScale);\n  const rotation = Matrix3.getRotation(obb.halfAxes, scratchRotation);\n  return {\n    shape: VoxelShapeType.BOX,\n    minBounds: Cartesian3.negate(scale, new Cartesian3()),\n    maxBounds: Cartesian3.clone(scale),\n    shapeTransform: Matrix4.fromRotationTranslation(rotation, obb.center)\n  };\n}\nfunction getCylinderShape(cylinder) {\n  const {\n    minRadius,\n    maxRadius,\n    height,\n    minAngle = -CesiumMath.PI,\n    maxAngle = CesiumMath.PI,\n    translation = [0, 0, 0],\n    rotation = [0, 0, 0, 1]\n  } = cylinder;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"minRadius\", minRadius);\n  Check.typeOf.number(\"maxRadius\", maxRadius);\n  Check.typeOf.number(\"height\", height);\n  Check.typeOf.number(\"minAngle\", minAngle);\n  Check.typeOf.number(\"maxAngle\", maxAngle);\n  Check.typeOf.object(\"translation\", translation);\n  Check.typeOf.object(\"rotation\", rotation);\n  //>>includeEnd('debug');\n\n  const minHeight = -0.5 * height + translation[2];\n  const maxHeight = 0.5 * height + translation[2];\n  const shapeTransform = Matrix4.fromTranslationQuaternionRotationScale(Cartesian3.unpack(translation), Quaternion.unpack(rotation), Cartesian3.ONE);\n  return {\n    shape: VoxelShapeType.CYLINDER,\n    minBounds: Cartesian3.fromElements(minRadius, minAngle, minHeight),\n    maxBounds: Cartesian3.fromElements(maxRadius, maxAngle, maxHeight),\n    shapeTransform: shapeTransform\n  };\n}\nfunction getMetadataSchemaLoader(tilesetJson, resource) {\n  const {\n    schemaUri,\n    schema\n  } = tilesetJson;\n  if (!defined(schemaUri)) {\n    return ResourceCache.getSchemaLoader({\n      schema\n    });\n  }\n  return ResourceCache.getSchemaLoader({\n    resource: resource.getDerivedResource({\n      url: schemaUri\n    })\n  });\n}\nfunction getAttributeInfo(metadata, className) {\n  const {\n    schema,\n    statistics\n  } = metadata;\n  const classStatistics = statistics?.classes[className];\n  const properties = schema.classes[className].properties;\n  const propertyInfo = Object.entries(properties).map(([id, property]) => {\n    const {\n      type,\n      componentType\n    } = property;\n    const min = classStatistics?.properties[id].min;\n    const max = classStatistics?.properties[id].max;\n    const componentCount = MetadataType.getComponentCount(type);\n    const minValue = copyArray(min, componentCount);\n    const maxValue = copyArray(max, componentCount);\n    return {\n      id,\n      type,\n      componentType,\n      minValue,\n      maxValue\n    };\n  });\n  const names = propertyInfo.map(info => info.id);\n  const types = propertyInfo.map(info => info.type);\n  const componentTypes = propertyInfo.map(info => info.componentType);\n  const minimumValues = propertyInfo.map(info => info.minValue);\n  const maximumValues = propertyInfo.map(info => info.maxValue);\n  const hasMinimumValues = minimumValues.some(defined);\n  return {\n    className,\n    names,\n    types,\n    componentTypes,\n    minimumValues: hasMinimumValues ? minimumValues : undefined,\n    maximumValues: hasMinimumValues ? maximumValues : undefined\n  };\n}\nfunction copyArray(values, length) {\n  // Copy input values into a new array of a specified length.\n  // If the input is not an array, its value will be copied into the first element\n  // of the returned array. If the input is an array shorter than the returned\n  // array, the extra elements in the returned array will be undefined. If the\n  // input is undefined, the return will be undefined.\n  if (!defined(values)) {\n    return;\n  }\n  const valuesArray = Array.isArray(values) ? values : [values];\n  return Array.from({\n    length\n  }, (v, i) => valuesArray[i]);\n}\n\n/**\n * Get the subtree at a given subtree coordinate\n * @param {VoxelProvider} provider The voxel provider\n * @param {ImplicitTileCoordinates} subtreeCoord The coordinate at which to retrieve the subtree\n * @returns {Promise<ImplicitSubtree>} The subtree at the given coordinate\n * @private\n */\nasync function getSubtree(provider, subtreeCoord) {\n  const implicitTileset = provider._implicitTileset;\n  const subtreeCache = provider._subtreeCache;\n\n  // First load the subtree to check if the tile is available.\n  // If the subtree has been requested previously it might still be in the cache\n  let subtree = subtreeCache.find(subtreeCoord);\n  if (defined(subtree)) {\n    return subtree;\n  }\n  const subtreeRelative = implicitTileset.subtreeUriTemplate.getDerivedResource({\n    templateValues: subtreeCoord.getTemplateValues()\n  });\n  const subtreeResource = implicitTileset.baseResource.getDerivedResource({\n    url: subtreeRelative.url\n  });\n  const arrayBuffer = await subtreeResource.fetchArrayBuffer();\n  // Check one more time if the subtree is in the cache.\n  // This could happen if there are two in-flight tile requests from the same\n  // subtree and one finishes before the other.\n  subtree = subtreeCache.find(subtreeCoord);\n  if (defined(subtree)) {\n    return subtree;\n  }\n  const preprocessed = preprocess3DTileContent(arrayBuffer);\n  subtree = await ImplicitSubtree.fromSubtreeJson(subtreeResource, preprocessed.jsonPayload, preprocessed.binaryPayload, implicitTileset, subtreeCoord);\n  subtreeCache.addSubtree(subtree);\n  return subtree;\n}\n\n/**\n * Requests the data for a given tile.\n *\n * @param {object} [options] Object with the following properties:\n * @param {number} [options.tileLevel=0] The tile's level.\n * @param {number} [options.tileX=0] The tile's X coordinate.\n * @param {number} [options.tileY=0] The tile's Y coordinate.\n * @param {number} [options.tileZ=0] The tile's Z coordinate.\n * @privateparam {number} [options.keyframe=0] The requested keyframe.\n * @returns {Promise<VoxelContent>|undefined} A promise resolving to a VoxelContent containing the data for the tile, or undefined if the request could not be scheduled this frame.\n */\nCesium3DTilesVoxelProvider.prototype.requestData = async function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const {\n    tileLevel = 0,\n    tileX = 0,\n    tileY = 0,\n    tileZ = 0,\n    keyframe = 0\n  } = options;\n  if (keyframe !== 0) {\n    return Promise.reject(`3D Tiles currently doesn't support time-dynamic data.`);\n  }\n\n  // 1. Load the subtree that the tile belongs to (possibly from the subtree cache)\n  // 2. Load the voxel content if available\n\n  // Can't use a scratch variable here because the object is used inside the promise chain.\n  const implicitTileset = this._implicitTileset;\n  const tileCoordinates = new ImplicitTileCoordinates({\n    subdivisionScheme: implicitTileset.subdivisionScheme,\n    subtreeLevels: implicitTileset.subtreeLevels,\n    level: tileLevel,\n    x: tileX,\n    y: tileY,\n    z: tileZ\n  });\n\n  // Find the coordinates of the parent subtree containing tileCoordinates\n  // If tileCoordinates is a subtree child, use that subtree\n  // If tileCoordinates is a subtree root, use its parent subtree\n  const isSubtreeRoot = tileCoordinates.isSubtreeRoot() && tileCoordinates.level > 0;\n  const subtreeCoord = isSubtreeRoot ? tileCoordinates.getParentSubtreeCoordinates() : tileCoordinates.getSubtreeCoordinates();\n  const that = this;\n  const subtree = await getSubtree(that, subtreeCoord);\n  // NOTE: these two subtree methods are ONLY used by voxels!\n  const isAvailable = isSubtreeRoot ? subtree.childSubtreeIsAvailableAtCoordinates : subtree.tileIsAvailableAtCoordinates;\n  const available = isAvailable.call(subtree, tileCoordinates);\n  if (!available) {\n    return Promise.reject(`Tile is not available at level ${tileLevel}, x ${tileX}, y ${tileY}, z ${tileZ}.`);\n  }\n  const {\n    contentUriTemplates,\n    baseResource\n  } = implicitTileset;\n  const gltfRelative = contentUriTemplates[0].getDerivedResource({\n    templateValues: tileCoordinates.getTemplateValues()\n  });\n  const gltfResource = baseResource.getDerivedResource({\n    url: gltfRelative.url\n  });\n  return VoxelContent.fromGltf(gltfResource);\n};\nexport default Cesium3DTilesVoxelProvider;","map":{"version":3,"names":["Cartesian3","Cesium3DTilesetMetadata","Check","Frozen","defined","Ellipsoid","hasExtension","ImplicitSubtree","ImplicitSubtreeCache","ImplicitTileCoordinates","ImplicitTileset","Matrix3","Matrix4","MetadataSemantic","MetadataType","OrientedBoundingBox","preprocess3DTileContent","Resource","ResourceCache","RuntimeError","VoxelContent","VoxelMetadataOrder","VoxelShapeType","CesiumMath","Quaternion","Cesium3DTilesVoxelProvider","options","EMPTY_OBJECT","className","names","types","componentTypes","shape","dimensions","paddingBefore","ZERO","clone","paddingAfter","globalTransform","IDENTITY","shapeTransform","minBounds","maxBounds","minimumValues","maximumValues","maximumTileCount","typeOf","string","object","_shapeTransform","_globalTransform","_shape","_minBounds","_maxBounds","_dimensions","_paddingBefore","_paddingAfter","_className","_names","_types","_componentTypes","_metadataOrder","ELLIPSOID","Z_UP","Y_UP","_minimumValues","_maximumValues","_maximumTileCount","_availableLevels","undefined","_implicitTileset","_subtreeCache","Object","defineProperties","prototype","get","metadataOrder","availableLevels","fromUrl","url","resource","createIfNeeded","tilesetJson","fetchJson","validate","schemaLoader","getMetadataSchemaLoader","load","root","metadataJson","extensions","tilesetMetadata","schema","voxel","content","class","providerOptions","getAttributeInfo","assign","getShape","transform","unpack","getTileCount","padding","before","after","provider","implicitTileset","unload","metadata","tileset","getPropertyBySemantic","TILESET_TILE_COUNT","implicitTiling","schemaUri","tile","boundingVolume","box","getBoxShape","region","getEllipsoidShape","getCylinderShape","west","south","east","north","minHeight","maxHeight","fromScale","WGS84","radii","scratchScale","scratchRotation","obb","scale","getScale","halfAxes","rotation","getRotation","BOX","negate","fromRotationTranslation","center","cylinder","minRadius","maxRadius","height","minAngle","PI","maxAngle","translation","number","fromTranslationQuaternionRotationScale","ONE","CYLINDER","fromElements","getSchemaLoader","getDerivedResource","statistics","classStatistics","classes","properties","propertyInfo","entries","map","id","property","type","componentType","min","max","componentCount","getComponentCount","minValue","copyArray","maxValue","info","hasMinimumValues","some","values","length","valuesArray","Array","isArray","from","v","i","getSubtree","subtreeCoord","subtreeCache","subtree","find","subtreeRelative","subtreeUriTemplate","templateValues","getTemplateValues","subtreeResource","baseResource","arrayBuffer","fetchArrayBuffer","preprocessed","fromSubtreeJson","jsonPayload","binaryPayload","addSubtree","requestData","tileLevel","tileX","tileY","tileZ","keyframe","Promise","reject","tileCoordinates","subdivisionScheme","subtreeLevels","level","x","y","z","isSubtreeRoot","getParentSubtreeCoordinates","getSubtreeCoordinates","that","isAvailable","childSubtreeIsAvailableAtCoordinates","tileIsAvailableAtCoordinates","available","call","contentUriTemplates","gltfRelative","gltfResource","fromGltf"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Cesium3DTilesVoxelProvider.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cesium3DTilesetMetadata from \"./Cesium3DTilesetMetadata.js\";\nimport Check from \"../Core/Check.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport hasExtension from \"./hasExtension.js\";\nimport ImplicitSubtree from \"./ImplicitSubtree.js\";\nimport ImplicitSubtreeCache from \"./ImplicitSubtreeCache.js\";\nimport ImplicitTileCoordinates from \"./ImplicitTileCoordinates.js\";\nimport ImplicitTileset from \"./ImplicitTileset.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport MetadataSemantic from \"./MetadataSemantic.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport preprocess3DTileContent from \"./preprocess3DTileContent.js\";\nimport Resource from \"../Core/Resource.js\";\nimport ResourceCache from \"./ResourceCache.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport VoxelContent from \"./VoxelContent.js\";\nimport VoxelMetadataOrder from \"./VoxelMetadataOrder.js\";\nimport VoxelShapeType from \"./VoxelShapeType.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\n\n/**\n * @typedef {Object} Cesium3DTilesVoxelProvider.ConstructorOptions\n *\n * Initialization options for the Cesium3DTilesVoxelProvider constructor\n *\n * @property {string} className The class in the tileset schema describing voxel metadata.\n * @property {string[]} names The metadata names.\n * @property {MetadataType[]} types The metadata types.\n * @property {MetadataComponentType[]} componentTypes The metadata component types.\n * @property {VoxelShapeType} shape The {@link VoxelShapeType}.\n * @property {Cartesian3} dimensions The number of voxels per dimension of a tile. This is the same for all tiles in the dataset.\n * @property {Cartesian3} [paddingBefore=Cartesian3.ZERO] The number of padding voxels before the tile. This improves rendering quality when sampling the edge of a tile, but it increases memory usage.\n * @property {Cartesian3} [paddingAfter=Cartesian3.ZERO] The number of padding voxels after the tile. This improves rendering quality when sampling the edge of a tile, but it increases memory usage.\n * @property {Matrix4} [globalTransform=Matrix4.IDENTITY] A transform from local space to global space.\n * @property {Matrix4} [shapeTransform=Matrix4.IDENTITY] A transform from shape space to local space.\n * @property {Cartesian3} [minBounds] The minimum bounds.\n * @property {Cartesian3} [maxBounds] The maximum bounds.\n * @property {number[][]} [minimumValues] The metadata minimum values.\n * @property {number[][]} [maximumValues] The metadata maximum values.\n * @property {number} [maximumTileCount] The maximum number of tiles that exist for this provider. This value is used as a hint to the voxel renderer to allocate an appropriate amount of GPU memory. If this value is not known it can be undefined.\n */\n\n/**\n * A {@link VoxelProvider} that fetches voxel data from a 3D Tiles tileset.\n * <p>\n * Implements the {@link VoxelProvider} interface.\n * </p>\n * <div class=\"notice\">\n * This object is normally not instantiated directly, use {@link Cesium3DTilesVoxelProvider.fromUrl}.\n * </div>\n *\n * @alias Cesium3DTilesVoxelProvider\n * @constructor\n * @augments VoxelProvider\n *\n * @param {Cesium3DTilesVoxelProvider.ConstructorOptions} options An object describing initialization options\n *\n * @see Cesium3DTilesVoxelProvider.fromUrl\n * @see VoxelProvider\n * @see VoxelPrimitive\n * @see VoxelShapeType\n *\n * @experimental This feature is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction Cesium3DTilesVoxelProvider(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const {\n    className,\n    names,\n    types,\n    componentTypes,\n    shape,\n    dimensions,\n    paddingBefore = Cartesian3.ZERO.clone(),\n    paddingAfter = Cartesian3.ZERO.clone(),\n    globalTransform = Matrix4.IDENTITY.clone(),\n    shapeTransform = Matrix4.IDENTITY.clone(),\n    minBounds,\n    maxBounds,\n    minimumValues,\n    maximumValues,\n    maximumTileCount,\n  } = options;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"className\", className);\n  Check.typeOf.object(\"names\", names);\n  Check.typeOf.object(\"types\", types);\n  Check.typeOf.object(\"componentTypes\", componentTypes);\n  Check.typeOf.string(\"shape\", shape);\n  Check.typeOf.object(\"dimensions\", dimensions);\n  //>>includeEnd('debug');\n\n  this._shapeTransform = shapeTransform;\n  this._globalTransform = globalTransform;\n  this._shape = shape;\n  this._minBounds = minBounds;\n  this._maxBounds = maxBounds;\n  this._dimensions = dimensions;\n  this._paddingBefore = paddingBefore;\n  this._paddingAfter = paddingAfter;\n  this._className = className;\n  this._names = names;\n  this._types = types;\n  this._componentTypes = componentTypes;\n  this._metadataOrder =\n    shape === VoxelShapeType.ELLIPSOID\n      ? VoxelMetadataOrder.Z_UP\n      : VoxelMetadataOrder.Y_UP;\n  this._minimumValues = minimumValues;\n  this._maximumValues = maximumValues;\n  this._maximumTileCount = maximumTileCount;\n  this._availableLevels = undefined;\n  this._implicitTileset = undefined;\n  this._subtreeCache = new ImplicitSubtreeCache();\n}\n\nObject.defineProperties(Cesium3DTilesVoxelProvider.prototype, {\n  /**\n   * A transform from local space to global space.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {Matrix4}\n   * @default Matrix4.IDENTITY\n   * @readonly\n   */\n  globalTransform: {\n    get: function () {\n      return this._globalTransform;\n    },\n  },\n\n  /**\n   * A transform from shape space to local space.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {Matrix4}\n   * @default Matrix4.IDENTITY\n   * @readonly\n   */\n  shapeTransform: {\n    get: function () {\n      return this._shapeTransform;\n    },\n  },\n\n  /**\n   * Gets the {@link VoxelShapeType}\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {VoxelShapeType}\n   * @readonly\n   */\n  shape: {\n    get: function () {\n      return this._shape;\n    },\n  },\n\n  /**\n   * Gets the minimum bounds.\n   * If undefined, the shape's default minimum bounds will be used instead.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {Cartesian3|undefined}\n   * @readonly\n   */\n  minBounds: {\n    get: function () {\n      return this._minBounds;\n    },\n  },\n\n  /**\n   * Gets the maximum bounds.\n   * If undefined, the shape's default maximum bounds will be used instead.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {Cartesian3|undefined}\n   * @readonly\n   */\n  maxBounds: {\n    get: function () {\n      return this._maxBounds;\n    },\n  },\n\n  /**\n   * Gets the number of voxels per dimension of a tile. This is the same for all tiles in the dataset.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  dimensions: {\n    get: function () {\n      return this._dimensions;\n    },\n  },\n\n  /**\n   * Gets the number of padding voxels before the tile. This improves rendering quality when sampling the edge of a tile, but it increases memory usage.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {Cartesian3}\n   * @default Cartesian3.ZERO\n   * @readonly\n   */\n  paddingBefore: {\n    get: function () {\n      return this._paddingBefore;\n    },\n  },\n\n  /**\n   * Gets the number of padding voxels after the tile. This improves rendering quality when sampling the edge of a tile, but it increases memory usage.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {Cartesian3}\n   * @default Cartesian3.ZERO\n   * @readonly\n   */\n  paddingAfter: {\n    get: function () {\n      return this._paddingAfter;\n    },\n  },\n\n  /**\n   * The metadata class for this tileset.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {string}\n   * @readonly\n   */\n  className: {\n    get: function () {\n      return this._className;\n    },\n  },\n\n  /**\n   * Gets the metadata names.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {string[]}\n   * @readonly\n   */\n  names: {\n    get: function () {\n      return this._names;\n    },\n  },\n\n  /**\n   * Gets the metadata types.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {MetadataType[]}\n   * @readonly\n   */\n  types: {\n    get: function () {\n      return this._types;\n    },\n  },\n\n  /**\n   * Gets the metadata component types.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {MetadataComponentType[]}\n   * @readonly\n   */\n  componentTypes: {\n    get: function () {\n      return this._componentTypes;\n    },\n  },\n\n  /**\n   * Gets the ordering of the metadata in the buffers.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {VoxelMetadataOrder}\n   * @readonly\n   * @private\n   */\n  metadataOrder: {\n    get: function () {\n      return this._metadataOrder;\n    },\n  },\n\n  /**\n   * Gets the metadata minimum values.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {number[][]|undefined}\n   * @readonly\n   */\n  minimumValues: {\n    get: function () {\n      return this._minimumValues;\n    },\n  },\n\n  /**\n   * Gets the metadata maximum values.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {number[][]|undefined}\n   * @readonly\n   */\n  maximumValues: {\n    get: function () {\n      return this._maximumValues;\n    },\n  },\n\n  /**\n   * The maximum number of tiles that exist for this provider.\n   * This value is used as a hint to the voxel renderer to allocate an appropriate amount of GPU memory.\n   * If this value is not known it can be undefined.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {number|undefined}\n   * @readonly\n   */\n  maximumTileCount: {\n    get: function () {\n      return this._maximumTileCount;\n    },\n  },\n\n  /**\n   * The number of levels of detail containing available tiles in the tileset.\n   *\n   * @memberof Cesium3DTilesVoxelProvider.prototype\n   * @type {number|undefined}\n   * @readonly\n   */\n  availableLevels: {\n    get: function () {\n      return this._availableLevels;\n    },\n  },\n});\n\n/**\n * Creates a {@link Cesium3DTilesVoxelProvider} that fetches voxel data from a 3D Tiles tileset.\n *\n * @param {Resource|string} url The URL to a tileset JSON file\n * @returns {Promise<Cesium3DTilesVoxelProvider>} The created provider\n *\n * @exception {RuntimeException} Root must have content\n * @exception {RuntimeException} Root tile content must have 3DTILES_content_voxels extension\n * @exception {RuntimeException} Root tile must have implicit tiling\n * @exception {RuntimeException} Tileset must have a metadata schema\n * @exception {RuntimeException} Only box, region and 3DTILES_bounding_volume_cylinder are supported in Cesium3DTilesVoxelProvider\n *\n * @example\n * try {\n *   const voxelProvider = await Cesium3DTilesVoxelProvider.fromUrl(\n *     \"http://localhost:8002/tilesets/voxel/tileset.json\"\n *   );\n *   const voxelPrimitive = new VoxelPrimitive({\n *     provider: voxelProvider,\n *     customShader: customShader,\n *   });\n *   scene.primitives.add(voxelPrimitive);\n * } catch (error) {\n *   console.error(`Error creating voxel primitive: ${error}`);\n * }\n *\n * @see {@link VoxelPrimitive}\n */\nCesium3DTilesVoxelProvider.fromUrl = async function (url) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  const resource = Resource.createIfNeeded(url);\n  const tilesetJson = await resource.fetchJson();\n\n  validate(tilesetJson);\n\n  const schemaLoader = getMetadataSchemaLoader(tilesetJson, resource);\n  await schemaLoader.load();\n\n  const { root } = tilesetJson;\n\n  const metadataJson = hasExtension(tilesetJson, \"3DTILES_metadata\")\n    ? tilesetJson.extensions[\"3DTILES_metadata\"]\n    : tilesetJson;\n\n  const tilesetMetadata = new Cesium3DTilesetMetadata({\n    metadataJson: metadataJson,\n    schema: schemaLoader.schema,\n  });\n\n  const voxel = root.content.extensions[\"3DTILES_content_voxels\"];\n  const className = voxel.class;\n\n  const providerOptions = getAttributeInfo(tilesetMetadata, className);\n  Object.assign(providerOptions, getShape(root));\n  if (defined(root.transform)) {\n    providerOptions.globalTransform = Matrix4.unpack(root.transform);\n  } else {\n    providerOptions.globalTransform = Matrix4.clone(Matrix4.IDENTITY);\n  }\n\n  providerOptions.dimensions = Cartesian3.unpack(voxel.dimensions);\n  providerOptions.maximumTileCount = getTileCount(tilesetMetadata);\n\n  if (defined(voxel.padding)) {\n    providerOptions.paddingBefore = Cartesian3.unpack(voxel.padding.before);\n    providerOptions.paddingAfter = Cartesian3.unpack(voxel.padding.after);\n  }\n\n  const provider = new Cesium3DTilesVoxelProvider(providerOptions);\n\n  const implicitTileset = new ImplicitTileset(\n    resource,\n    root,\n    schemaLoader.schema,\n  );\n  provider._implicitTileset = implicitTileset;\n  provider._availableLevels = implicitTileset.availableLevels;\n\n  ResourceCache.unload(schemaLoader);\n\n  return provider;\n};\n\nfunction getTileCount(metadata) {\n  if (!defined(metadata.tileset)) {\n    return undefined;\n  }\n\n  return metadata.tileset.getPropertyBySemantic(\n    MetadataSemantic.TILESET_TILE_COUNT,\n  );\n}\n\nfunction validate(tileset) {\n  const root = tileset.root;\n\n  if (!defined(root.content)) {\n    throw new RuntimeError(\"Root must have content\");\n  }\n\n  if (!hasExtension(root.content, \"3DTILES_content_voxels\")) {\n    throw new RuntimeError(\n      \"Root tile content must have 3DTILES_content_voxels extension\",\n    );\n  }\n\n  if (\n    !hasExtension(root, \"3DTILES_implicit_tiling\") &&\n    !defined(root.implicitTiling)\n  ) {\n    throw new RuntimeError(\"Root tile must have implicit tiling\");\n  }\n\n  if (\n    !defined(tileset.schema) &&\n    !defined(tileset.schemaUri) &&\n    !hasExtension(tileset, \"3DTILES_metadata\")\n  ) {\n    throw new RuntimeError(\"Tileset must have a metadata schema\");\n  }\n}\n\nfunction getShape(tile) {\n  const boundingVolume = tile.boundingVolume;\n\n  if (defined(boundingVolume.box)) {\n    return getBoxShape(boundingVolume.box);\n  } else if (defined(boundingVolume.region)) {\n    return getEllipsoidShape(boundingVolume.region);\n  } else if (hasExtension(boundingVolume, \"3DTILES_bounding_volume_cylinder\")) {\n    return getCylinderShape(\n      boundingVolume.extensions[\"3DTILES_bounding_volume_cylinder\"],\n    );\n  }\n\n  throw new RuntimeError(\n    \"Only box, region and 3DTILES_bounding_volume_cylinder are supported in Cesium3DTilesVoxelProvider\",\n  );\n}\n\nfunction getEllipsoidShape(region) {\n  const west = region[0];\n  const south = region[1];\n  const east = region[2];\n  const north = region[3];\n  const minHeight = region[4];\n  const maxHeight = region[5];\n\n  const shapeTransform = Matrix4.fromScale(Ellipsoid.WGS84.radii);\n\n  const minBounds = new Cartesian3(west, south, minHeight);\n  const maxBounds = new Cartesian3(east, north, maxHeight);\n\n  return {\n    shape: VoxelShapeType.ELLIPSOID,\n    minBounds: minBounds,\n    maxBounds: maxBounds,\n    shapeTransform: shapeTransform,\n  };\n}\n\nconst scratchScale = new Cartesian3();\nconst scratchRotation = new Matrix3();\n\nfunction getBoxShape(box) {\n  const obb = OrientedBoundingBox.unpack(box);\n  const scale = Matrix3.getScale(obb.halfAxes, scratchScale);\n  const rotation = Matrix3.getRotation(obb.halfAxes, scratchRotation);\n\n  return {\n    shape: VoxelShapeType.BOX,\n    minBounds: Cartesian3.negate(scale, new Cartesian3()),\n    maxBounds: Cartesian3.clone(scale),\n    shapeTransform: Matrix4.fromRotationTranslation(rotation, obb.center),\n  };\n}\n\nfunction getCylinderShape(cylinder) {\n  const {\n    minRadius,\n    maxRadius,\n    height,\n    minAngle = -CesiumMath.PI,\n    maxAngle = CesiumMath.PI,\n    translation = [0, 0, 0],\n    rotation = [0, 0, 0, 1],\n  } = cylinder;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"minRadius\", minRadius);\n  Check.typeOf.number(\"maxRadius\", maxRadius);\n  Check.typeOf.number(\"height\", height);\n  Check.typeOf.number(\"minAngle\", minAngle);\n  Check.typeOf.number(\"maxAngle\", maxAngle);\n  Check.typeOf.object(\"translation\", translation);\n  Check.typeOf.object(\"rotation\", rotation);\n  //>>includeEnd('debug');\n\n  const minHeight = -0.5 * height + translation[2];\n  const maxHeight = 0.5 * height + translation[2];\n\n  const shapeTransform = Matrix4.fromTranslationQuaternionRotationScale(\n    Cartesian3.unpack(translation),\n    Quaternion.unpack(rotation),\n    Cartesian3.ONE,\n  );\n\n  return {\n    shape: VoxelShapeType.CYLINDER,\n    minBounds: Cartesian3.fromElements(minRadius, minAngle, minHeight),\n    maxBounds: Cartesian3.fromElements(maxRadius, maxAngle, maxHeight),\n    shapeTransform: shapeTransform,\n  };\n}\n\nfunction getMetadataSchemaLoader(tilesetJson, resource) {\n  const { schemaUri, schema } = tilesetJson;\n  if (!defined(schemaUri)) {\n    return ResourceCache.getSchemaLoader({ schema });\n  }\n  return ResourceCache.getSchemaLoader({\n    resource: resource.getDerivedResource({\n      url: schemaUri,\n    }),\n  });\n}\n\nfunction getAttributeInfo(metadata, className) {\n  const { schema, statistics } = metadata;\n  const classStatistics = statistics?.classes[className];\n  const properties = schema.classes[className].properties;\n\n  const propertyInfo = Object.entries(properties).map(([id, property]) => {\n    const { type, componentType } = property;\n    const min = classStatistics?.properties[id].min;\n    const max = classStatistics?.properties[id].max;\n    const componentCount = MetadataType.getComponentCount(type);\n    const minValue = copyArray(min, componentCount);\n    const maxValue = copyArray(max, componentCount);\n\n    return { id, type, componentType, minValue, maxValue };\n  });\n\n  const names = propertyInfo.map((info) => info.id);\n  const types = propertyInfo.map((info) => info.type);\n  const componentTypes = propertyInfo.map((info) => info.componentType);\n\n  const minimumValues = propertyInfo.map((info) => info.minValue);\n  const maximumValues = propertyInfo.map((info) => info.maxValue);\n  const hasMinimumValues = minimumValues.some(defined);\n\n  return {\n    className,\n    names,\n    types,\n    componentTypes,\n    minimumValues: hasMinimumValues ? minimumValues : undefined,\n    maximumValues: hasMinimumValues ? maximumValues : undefined,\n  };\n}\n\nfunction copyArray(values, length) {\n  // Copy input values into a new array of a specified length.\n  // If the input is not an array, its value will be copied into the first element\n  // of the returned array. If the input is an array shorter than the returned\n  // array, the extra elements in the returned array will be undefined. If the\n  // input is undefined, the return will be undefined.\n  if (!defined(values)) {\n    return;\n  }\n  const valuesArray = Array.isArray(values) ? values : [values];\n  return Array.from({ length }, (v, i) => valuesArray[i]);\n}\n\n/**\n * Get the subtree at a given subtree coordinate\n * @param {VoxelProvider} provider The voxel provider\n * @param {ImplicitTileCoordinates} subtreeCoord The coordinate at which to retrieve the subtree\n * @returns {Promise<ImplicitSubtree>} The subtree at the given coordinate\n * @private\n */\nasync function getSubtree(provider, subtreeCoord) {\n  const implicitTileset = provider._implicitTileset;\n  const subtreeCache = provider._subtreeCache;\n\n  // First load the subtree to check if the tile is available.\n  // If the subtree has been requested previously it might still be in the cache\n  let subtree = subtreeCache.find(subtreeCoord);\n  if (defined(subtree)) {\n    return subtree;\n  }\n\n  const subtreeRelative = implicitTileset.subtreeUriTemplate.getDerivedResource(\n    {\n      templateValues: subtreeCoord.getTemplateValues(),\n    },\n  );\n  const subtreeResource = implicitTileset.baseResource.getDerivedResource({\n    url: subtreeRelative.url,\n  });\n\n  const arrayBuffer = await subtreeResource.fetchArrayBuffer();\n  // Check one more time if the subtree is in the cache.\n  // This could happen if there are two in-flight tile requests from the same\n  // subtree and one finishes before the other.\n  subtree = subtreeCache.find(subtreeCoord);\n  if (defined(subtree)) {\n    return subtree;\n  }\n\n  const preprocessed = preprocess3DTileContent(arrayBuffer);\n  subtree = await ImplicitSubtree.fromSubtreeJson(\n    subtreeResource,\n    preprocessed.jsonPayload,\n    preprocessed.binaryPayload,\n    implicitTileset,\n    subtreeCoord,\n  );\n  subtreeCache.addSubtree(subtree);\n  return subtree;\n}\n\n/**\n * Requests the data for a given tile.\n *\n * @param {object} [options] Object with the following properties:\n * @param {number} [options.tileLevel=0] The tile's level.\n * @param {number} [options.tileX=0] The tile's X coordinate.\n * @param {number} [options.tileY=0] The tile's Y coordinate.\n * @param {number} [options.tileZ=0] The tile's Z coordinate.\n * @privateparam {number} [options.keyframe=0] The requested keyframe.\n * @returns {Promise<VoxelContent>|undefined} A promise resolving to a VoxelContent containing the data for the tile, or undefined if the request could not be scheduled this frame.\n */\nCesium3DTilesVoxelProvider.prototype.requestData = async function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const {\n    tileLevel = 0,\n    tileX = 0,\n    tileY = 0,\n    tileZ = 0,\n    keyframe = 0,\n  } = options;\n\n  if (keyframe !== 0) {\n    return Promise.reject(\n      `3D Tiles currently doesn't support time-dynamic data.`,\n    );\n  }\n\n  // 1. Load the subtree that the tile belongs to (possibly from the subtree cache)\n  // 2. Load the voxel content if available\n\n  // Can't use a scratch variable here because the object is used inside the promise chain.\n  const implicitTileset = this._implicitTileset;\n  const tileCoordinates = new ImplicitTileCoordinates({\n    subdivisionScheme: implicitTileset.subdivisionScheme,\n    subtreeLevels: implicitTileset.subtreeLevels,\n    level: tileLevel,\n    x: tileX,\n    y: tileY,\n    z: tileZ,\n  });\n\n  // Find the coordinates of the parent subtree containing tileCoordinates\n  // If tileCoordinates is a subtree child, use that subtree\n  // If tileCoordinates is a subtree root, use its parent subtree\n  const isSubtreeRoot =\n    tileCoordinates.isSubtreeRoot() && tileCoordinates.level > 0;\n\n  const subtreeCoord = isSubtreeRoot\n    ? tileCoordinates.getParentSubtreeCoordinates()\n    : tileCoordinates.getSubtreeCoordinates();\n\n  const that = this;\n\n  const subtree = await getSubtree(that, subtreeCoord);\n  // NOTE: these two subtree methods are ONLY used by voxels!\n  const isAvailable = isSubtreeRoot\n    ? subtree.childSubtreeIsAvailableAtCoordinates\n    : subtree.tileIsAvailableAtCoordinates;\n\n  const available = isAvailable.call(subtree, tileCoordinates);\n\n  if (!available) {\n    return Promise.reject(\n      `Tile is not available at level ${tileLevel}, x ${tileX}, y ${tileY}, z ${tileZ}.`,\n    );\n  }\n\n  const { contentUriTemplates, baseResource } = implicitTileset;\n  const gltfRelative = contentUriTemplates[0].getDerivedResource({\n    templateValues: tileCoordinates.getTemplateValues(),\n  });\n  const gltfResource = baseResource.getDerivedResource({\n    url: gltfRelative.url,\n  });\n\n  return VoxelContent.fromGltf(gltfResource);\n};\n\nexport default Cesium3DTilesVoxelProvider;\n"],"mappings":"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AAa;EACnC,IAAI,CAACuB,iBAAiB,GAAGtB,gBAAgB;EACzC,IAAI,CAACuB,gBAAgB,GAAGC,SAAS;EACjC,IAAI,CAACC,gBAAgB,GAAGD,SAAS;EACjC,IAAI,CAACE,aAAa,GAAG,IAAI/D,oBAAoB,CAAC,CAAC;AACjD;AAEAgE,MAAM,CAACC,gBAAgB,CAAChD,0BAA0B,CAACiD,SAAS,EAAE;EAC5D;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEpC,eAAe,EAAE;IACfqC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACzB,gBAAgB;IAC9B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEV,cAAc,EAAE;IACdmC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC1B,eAAe;IAC7B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEjB,KAAK,EAAE;IACL2C,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACxB,MAAM;IACpB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEV,SAAS,EAAE;IACTkC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACvB,UAAU;IACxB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEV,SAAS,EAAE;IACTiC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACtB,UAAU;IACxB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEpB,UAAU,EAAE;IACV0C,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACrB,WAAW;IACzB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEpB,aAAa,EAAE;IACbyC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACpB,cAAc;IAC5B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACElB,YAAY,EAAE;IACZsC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACnB,aAAa;IAC3B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACE5B,SAAS,EAAE;IACT+C,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAClB,UAAU;IACxB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACE5B,KAAK,EAAE;IACL8C,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACjB,MAAM;IACpB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACE5B,KAAK,EAAE;IACL6C,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAChB,MAAM;IACpB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACE5B,cAAc,EAAE;IACd4C,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACf,eAAe;IAC7B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEgB,aAAa,EAAE;IACbD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACd,cAAc;IAC5B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACElB,aAAa,EAAE;IACbgC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACV,cAAc;IAC5B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACErB,aAAa,EAAE;IACb+B,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACT,cAAc;IAC5B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACErB,gBAAgB,EAAE;IAChB8B,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACR,iBAAiB;IAC/B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEU,eAAe,EAAE;IACfF,GAAG,EAAE,SAAAA,CAAA,EAA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}