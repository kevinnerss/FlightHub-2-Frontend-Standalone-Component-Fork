{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport CornerType from \"./CornerType.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Transforms from \"./Transforms.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nconst scratch2Array = [new Cartesian3(), new Cartesian3()];\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartesian4 = new Cartesian3();\nconst scratchCartesian5 = new Cartesian3();\nconst scratchCartesian6 = new Cartesian3();\nconst scratchCartesian7 = new Cartesian3();\nconst scratchCartesian8 = new Cartesian3();\nconst scratchCartesian9 = new Cartesian3();\nconst scratch1 = new Cartesian3();\nconst scratch2 = new Cartesian3();\n\n/**\n * @private\n */\nconst PolylineVolumeGeometryLibrary = {};\nlet cartographic = new Cartographic();\nfunction scaleToSurface(positions, ellipsoid) {\n  const heights = new Array(positions.length);\n  for (let i = 0; i < positions.length; i++) {\n    const pos = positions[i];\n    cartographic = ellipsoid.cartesianToCartographic(pos, cartographic);\n    heights[i] = cartographic.height;\n    positions[i] = ellipsoid.scaleToGeodeticSurface(pos, pos);\n  }\n  return heights;\n}\nfunction subdivideHeights(points, h0, h1, granularity) {\n  const p0 = points[0];\n  const p1 = points[1];\n  const angleBetween = Cartesian3.angleBetween(p0, p1);\n  const numPoints = Math.ceil(angleBetween / granularity);\n  const heights = new Array(numPoints);\n  let i;\n  if (h0 === h1) {\n    for (i = 0; i < numPoints; i++) {\n      heights[i] = h0;\n    }\n    heights.push(h1);\n    return heights;\n  }\n  const dHeight = h1 - h0;\n  const heightPerVertex = dHeight / numPoints;\n  for (i = 1; i < numPoints; i++) {\n    const h = h0 + i * heightPerVertex;\n    heights[i] = h;\n  }\n  heights[0] = h0;\n  heights.push(h1);\n  return heights;\n}\nconst nextScratch = new Cartesian3();\nconst prevScratch = new Cartesian3();\nfunction computeRotationAngle(start, end, position, ellipsoid) {\n  const tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\n  const next = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, start, nextScratch), nextScratch);\n  const prev = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, end, prevScratch), prevScratch);\n  const angle = Cartesian2.angleBetween(next, prev);\n  return prev.x * next.y - prev.y * next.x >= 0.0 ? -angle : angle;\n}\nconst negativeX = new Cartesian3(-1, 0, 0);\nlet transform = new Matrix4();\nconst translation = new Matrix4();\nlet rotationZ = new Matrix3();\nconst scaleMatrix = Matrix3.IDENTITY.clone();\nconst westScratch = new Cartesian3();\nconst finalPosScratch = new Cartesian4();\nconst heightCartesian = new Cartesian3();\nfunction addPosition(center, left, shape, finalPositions, ellipsoid, height, xScalar, repeat) {\n  let west = westScratch;\n  let finalPosition = finalPosScratch;\n  transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, transform);\n  west = Matrix4.multiplyByPointAsVector(transform, negativeX, west);\n  west = Cartesian3.normalize(west, west);\n  const angle = computeRotationAngle(west, left, center, ellipsoid);\n  rotationZ = Matrix3.fromRotationZ(angle, rotationZ);\n  heightCartesian.z = height;\n  transform = Matrix4.multiplyTransformation(transform, Matrix4.fromRotationTranslation(rotationZ, heightCartesian, translation), transform);\n  const scale = scaleMatrix;\n  scale[0] = xScalar;\n  for (let j = 0; j < repeat; j++) {\n    for (let i = 0; i < shape.length; i += 3) {\n      finalPosition = Cartesian3.fromArray(shape, i, finalPosition);\n      finalPosition = Matrix3.multiplyByVector(scale, finalPosition, finalPosition);\n      finalPosition = Matrix4.multiplyByPoint(transform, finalPosition, finalPosition);\n      finalPositions.push(finalPosition.x, finalPosition.y, finalPosition.z);\n    }\n  }\n  return finalPositions;\n}\nconst centerScratch = new Cartesian3();\nfunction addPositions(centers, left, shape, finalPositions, ellipsoid, heights, xScalar) {\n  for (let i = 0; i < centers.length; i += 3) {\n    const center = Cartesian3.fromArray(centers, i, centerScratch);\n    finalPositions = addPosition(center, left, shape, finalPositions, ellipsoid, heights[i / 3], xScalar, 1);\n  }\n  return finalPositions;\n}\nfunction convertShapeTo3DDuplicate(shape2D, boundingRectangle) {\n  //orientate 2D shape to XZ plane center at (0, 0, 0), duplicate points\n  const length = shape2D.length;\n  const shape = new Array(length * 6);\n  let index = 0;\n  const xOffset = boundingRectangle.x + boundingRectangle.width / 2;\n  const yOffset = boundingRectangle.y + boundingRectangle.height / 2;\n  let point = shape2D[0];\n  shape[index++] = point.x - xOffset;\n  shape[index++] = 0.0;\n  shape[index++] = point.y - yOffset;\n  for (let i = 1; i < length; i++) {\n    point = shape2D[i];\n    const x = point.x - xOffset;\n    const z = point.y - yOffset;\n    shape[index++] = x;\n    shape[index++] = 0.0;\n    shape[index++] = z;\n    shape[index++] = x;\n    shape[index++] = 0.0;\n    shape[index++] = z;\n  }\n  point = shape2D[0];\n  shape[index++] = point.x - xOffset;\n  shape[index++] = 0.0;\n  shape[index++] = point.y - yOffset;\n  return shape;\n}\nfunction convertShapeTo3D(shape2D, boundingRectangle) {\n  //orientate 2D shape to XZ plane center at (0, 0, 0)\n  const length = shape2D.length;\n  const shape = new Array(length * 3);\n  let index = 0;\n  const xOffset = boundingRectangle.x + boundingRectangle.width / 2;\n  const yOffset = boundingRectangle.y + boundingRectangle.height / 2;\n  for (let i = 0; i < length; i++) {\n    shape[index++] = shape2D[i].x - xOffset;\n    shape[index++] = 0;\n    shape[index++] = shape2D[i].y - yOffset;\n  }\n  return shape;\n}\nconst quaterion = new Quaternion();\nconst startPointScratch = new Cartesian3();\nconst rotMatrix = new Matrix3();\nfunction computeRoundCorner(pivot, startPoint, endPoint, cornerType, leftIsOutside, ellipsoid, finalPositions, shape, height, duplicatePoints) {\n  const angle = Cartesian3.angleBetween(Cartesian3.subtract(startPoint, pivot, scratch1), Cartesian3.subtract(endPoint, pivot, scratch2));\n  const granularity = cornerType === CornerType.BEVELED ? 0 : Math.ceil(angle / CesiumMath.toRadians(5));\n  let m;\n  if (leftIsOutside) {\n    m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(Cartesian3.negate(pivot, scratch1), angle / (granularity + 1), quaterion), rotMatrix);\n  } else {\n    m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(pivot, angle / (granularity + 1), quaterion), rotMatrix);\n  }\n  let left;\n  let surfacePoint;\n  startPoint = Cartesian3.clone(startPoint, startPointScratch);\n  if (granularity > 0) {\n    const repeat = duplicatePoints ? 2 : 1;\n    for (let i = 0; i < granularity; i++) {\n      startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n      left = Cartesian3.subtract(startPoint, pivot, scratch1);\n      left = Cartesian3.normalize(left, left);\n      if (!leftIsOutside) {\n        left = Cartesian3.negate(left, left);\n      }\n      surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\n      finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, repeat);\n    }\n  } else {\n    left = Cartesian3.subtract(startPoint, pivot, scratch1);\n    left = Cartesian3.normalize(left, left);\n    if (!leftIsOutside) {\n      left = Cartesian3.negate(left, left);\n    }\n    surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\n    finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, 1);\n    endPoint = Cartesian3.clone(endPoint, startPointScratch);\n    left = Cartesian3.subtract(endPoint, pivot, scratch1);\n    left = Cartesian3.normalize(left, left);\n    if (!leftIsOutside) {\n      left = Cartesian3.negate(left, left);\n    }\n    surfacePoint = ellipsoid.scaleToGeodeticSurface(endPoint, scratch2);\n    finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, 1);\n  }\n  return finalPositions;\n}\nPolylineVolumeGeometryLibrary.removeDuplicatesFromShape = function (shapePositions) {\n  const length = shapePositions.length;\n  const cleanedPositions = [];\n  for (let i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {\n    const v0 = shapePositions[i0];\n    const v1 = shapePositions[i1];\n    if (!Cartesian2.equals(v0, v1)) {\n      cleanedPositions.push(v1); // Shallow copy!\n    }\n  }\n  return cleanedPositions;\n};\nPolylineVolumeGeometryLibrary.angleIsGreaterThanPi = function (forward, backward, position, ellipsoid) {\n  const tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\n  const next = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, forward, nextScratch), nextScratch);\n  const prev = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, backward, prevScratch), prevScratch);\n  return prev.x * next.y - prev.y * next.x >= 0.0;\n};\nconst scratchForwardProjection = new Cartesian3();\nconst scratchBackwardProjection = new Cartesian3();\nPolylineVolumeGeometryLibrary.computePositions = function (positions, shape2D, boundingRectangle, geometry, duplicatePoints) {\n  const ellipsoid = geometry._ellipsoid;\n  const heights = scaleToSurface(positions, ellipsoid);\n  const granularity = geometry._granularity;\n  const cornerType = geometry._cornerType;\n  const shapeForSides = duplicatePoints ? convertShapeTo3DDuplicate(shape2D, boundingRectangle) : convertShapeTo3D(shape2D, boundingRectangle);\n  const shapeForEnds = duplicatePoints ? convertShapeTo3D(shape2D, boundingRectangle) : undefined;\n  const heightOffset = boundingRectangle.height / 2;\n  const width = boundingRectangle.width / 2;\n  let length = positions.length;\n  let finalPositions = [];\n  let ends = duplicatePoints ? [] : undefined;\n  let forward = scratchCartesian1;\n  let backward = scratchCartesian2;\n  let cornerDirection = scratchCartesian3;\n  let surfaceNormal = scratchCartesian4;\n  let pivot = scratchCartesian5;\n  let start = scratchCartesian6;\n  let end = scratchCartesian7;\n  let left = scratchCartesian8;\n  let previousPosition = scratchCartesian9;\n  let position = positions[0];\n  let nextPosition = positions[1];\n  surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\n  forward = Cartesian3.subtract(nextPosition, position, forward);\n  forward = Cartesian3.normalize(forward, forward);\n  left = Cartesian3.cross(surfaceNormal, forward, left);\n  left = Cartesian3.normalize(left, left);\n  let h0 = heights[0];\n  let h1 = heights[1];\n  if (duplicatePoints) {\n    ends = addPosition(position, left, shapeForEnds, ends, ellipsoid, h0 + heightOffset, 1, 1);\n  }\n  previousPosition = Cartesian3.clone(position, previousPosition);\n  position = nextPosition;\n  backward = Cartesian3.negate(forward, backward);\n  let subdividedHeights;\n  let subdividedPositions;\n  for (let i = 1; i < length - 1; i++) {\n    const repeat = duplicatePoints ? 2 : 1;\n    nextPosition = positions[i + 1];\n    if (position.equals(nextPosition)) {\n      oneTimeWarning(\"Positions are too close and are considered equivalent with rounding error.\");\n      continue;\n    }\n    forward = Cartesian3.subtract(nextPosition, position, forward);\n    forward = Cartesian3.normalize(forward, forward);\n    surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\n    const forwardProjection = Cartesian3.multiplyByScalar(surfaceNormal, Cartesian3.dot(forward, surfaceNormal), scratchForwardProjection);\n    Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n    Cartesian3.normalize(forwardProjection, forwardProjection);\n    const backwardProjection = Cartesian3.multiplyByScalar(surfaceNormal, Cartesian3.dot(backward, surfaceNormal), scratchBackwardProjection);\n    Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n    Cartesian3.normalize(backwardProjection, backwardProjection);\n    const doCorner = !CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)), 1.0, CesiumMath.EPSILON7);\n    if (doCorner) {\n      cornerDirection = Cartesian3.add(forward, backward, cornerDirection);\n      cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n      cornerDirection = Cartesian3.cross(cornerDirection, surfaceNormal, cornerDirection);\n      cornerDirection = Cartesian3.cross(surfaceNormal, cornerDirection, cornerDirection);\n      cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n      const scalar = 1 / Math.max(0.25, Cartesian3.magnitude(Cartesian3.cross(cornerDirection, backward, scratch1)));\n      const leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(forward, backward, position, ellipsoid);\n      if (leftIsOutside) {\n        pivot = Cartesian3.add(position, Cartesian3.multiplyByScalar(cornerDirection, scalar * width, cornerDirection), pivot);\n        start = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, width, start), start);\n        scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n        scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\n        subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scratch2Array,\n          granularity: granularity,\n          ellipsoid: ellipsoid\n        });\n        finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);\n        left = Cartesian3.cross(surfaceNormal, forward, left);\n        left = Cartesian3.normalize(left, left);\n        end = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, width, end), end);\n        if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n          computeRoundCorner(pivot, start, end, cornerType, leftIsOutside, ellipsoid, finalPositions, shapeForSides, h1 + heightOffset, duplicatePoints);\n        } else {\n          cornerDirection = Cartesian3.negate(cornerDirection, cornerDirection);\n          finalPositions = addPosition(position, cornerDirection, shapeForSides, finalPositions, ellipsoid, h1 + heightOffset, scalar, repeat);\n        }\n        previousPosition = Cartesian3.clone(end, previousPosition);\n      } else {\n        pivot = Cartesian3.add(position, Cartesian3.multiplyByScalar(cornerDirection, scalar * width, cornerDirection), pivot);\n        start = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, -width, start), start);\n        scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n        scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\n        subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scratch2Array,\n          granularity: granularity,\n          ellipsoid: ellipsoid\n        });\n        finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);\n        left = Cartesian3.cross(surfaceNormal, forward, left);\n        left = Cartesian3.normalize(left, left);\n        end = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, -width, end), end);\n        if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n          computeRoundCorner(pivot, start, end, cornerType, leftIsOutside, ellipsoid, finalPositions, shapeForSides, h1 + heightOffset, duplicatePoints);\n        } else {\n          finalPositions = addPosition(position, cornerDirection, shapeForSides, finalPositions, ellipsoid, h1 + heightOffset, scalar, repeat);\n        }\n        previousPosition = Cartesian3.clone(end, previousPosition);\n      }\n      backward = Cartesian3.negate(forward, backward);\n    } else {\n      finalPositions = addPosition(previousPosition, left, shapeForSides, finalPositions, ellipsoid, h0 + heightOffset, 1, 1);\n      previousPosition = position;\n    }\n    h0 = h1;\n    h1 = heights[i + 1];\n    position = nextPosition;\n  }\n  scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n  scratch2Array[1] = Cartesian3.clone(position, scratch2Array[1]);\n  subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);\n  subdividedPositions = PolylinePipeline.generateArc({\n    positions: scratch2Array,\n    granularity: granularity,\n    ellipsoid: ellipsoid\n  });\n  finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);\n  if (duplicatePoints) {\n    ends = addPosition(position, left, shapeForEnds, ends, ellipsoid, h1 + heightOffset, 1, 1);\n  }\n  length = finalPositions.length;\n  const posLength = duplicatePoints ? length + ends.length : length;\n  const combinedPositions = new Float64Array(posLength);\n  combinedPositions.set(finalPositions);\n  if (duplicatePoints) {\n    combinedPositions.set(ends, length);\n  }\n  return combinedPositions;\n};\nexport default PolylineVolumeGeometryLibrary;","map":{"version":3,"names":["Cartesian2","Cartesian3","Cartesian4","Cartographic","CornerType","EllipsoidTangentPlane","CesiumMath","Matrix3","Matrix4","PolylinePipeline","Quaternion","Transforms","oneTimeWarning","scratch2Array","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","scratchCartesian5","scratchCartesian6","scratchCartesian7","scratchCartesian8","scratchCartesian9","scratch1","scratch2","PolylineVolumeGeometryLibrary","cartographic","scaleToSurface","positions","ellipsoid","heights","Array","length","i","pos","cartesianToCartographic","height","scaleToGeodeticSurface","subdivideHeights","points","h0","h1","granularity","p0","p1","angleBetween","numPoints","Math","ceil","push","dHeight","heightPerVertex","h","nextScratch","prevScratch","computeRotationAngle","start","end","position","tangentPlane","next","projectPointOntoPlane","add","prev","angle","x","y","negativeX","transform","translation","rotationZ","scaleMatrix","IDENTITY","clone","westScratch","finalPosScratch","heightCartesian","addPosition","center","left","shape","finalPositions","xScalar","repeat","west","finalPosition","eastNorthUpToFixedFrame","multiplyByPointAsVector","normalize","fromRotationZ","z","multiplyTransformation","fromRotationTranslation","scale","j","fromArray","multiplyByVector","multiplyByPoint","centerScratch","addPositions","centers","convertShapeTo3DDuplicate","shape2D","boundingRectangle","index","xOffset","width","yOffset","point","convertShapeTo3D","quaterion","startPointScratch","rotMatrix","computeRoundCorner","pivot","startPoint","endPoint","cornerType","leftIsOutside","duplicatePoints","subtract","BEVELED","toRadians","m","fromQuaternion","fromAxisAngle","negate","surfacePoint","removeDuplicatesFromShape","shapePositions","cleanedPositions","i0","i1","v0","v1","equals","angleIsGreaterThanPi","forward","backward","scratchForwardProjection","scratchBackwardProjection","computePositions","geometry","_ellipsoid","_granularity","_cornerType","shapeForSides","shapeForEnds","undefined","heightOffset","ends","cornerDirection","surfaceNormal","previousPosition","nextPosition","geodeticSurfaceNormal","cross","subdividedHeights","subdividedPositions","forwardProjection","multiplyByScalar","dot","backwardProjection","doCorner","equalsEpsilon","abs","EPSILON7","scalar","max","magnitude","generateArc","ROUNDED","posLength","combinedPositions","Float64Array","set"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/PolylineVolumeGeometryLibrary.js"],"sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport CornerType from \"./CornerType.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Transforms from \"./Transforms.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\n\nconst scratch2Array = [new Cartesian3(), new Cartesian3()];\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartesian4 = new Cartesian3();\nconst scratchCartesian5 = new Cartesian3();\nconst scratchCartesian6 = new Cartesian3();\nconst scratchCartesian7 = new Cartesian3();\nconst scratchCartesian8 = new Cartesian3();\nconst scratchCartesian9 = new Cartesian3();\n\nconst scratch1 = new Cartesian3();\nconst scratch2 = new Cartesian3();\n\n/**\n * @private\n */\nconst PolylineVolumeGeometryLibrary = {};\n\nlet cartographic = new Cartographic();\nfunction scaleToSurface(positions, ellipsoid) {\n  const heights = new Array(positions.length);\n  for (let i = 0; i < positions.length; i++) {\n    const pos = positions[i];\n    cartographic = ellipsoid.cartesianToCartographic(pos, cartographic);\n    heights[i] = cartographic.height;\n    positions[i] = ellipsoid.scaleToGeodeticSurface(pos, pos);\n  }\n  return heights;\n}\n\nfunction subdivideHeights(points, h0, h1, granularity) {\n  const p0 = points[0];\n  const p1 = points[1];\n  const angleBetween = Cartesian3.angleBetween(p0, p1);\n  const numPoints = Math.ceil(angleBetween / granularity);\n  const heights = new Array(numPoints);\n  let i;\n  if (h0 === h1) {\n    for (i = 0; i < numPoints; i++) {\n      heights[i] = h0;\n    }\n    heights.push(h1);\n    return heights;\n  }\n\n  const dHeight = h1 - h0;\n  const heightPerVertex = dHeight / numPoints;\n\n  for (i = 1; i < numPoints; i++) {\n    const h = h0 + i * heightPerVertex;\n    heights[i] = h;\n  }\n\n  heights[0] = h0;\n  heights.push(h1);\n  return heights;\n}\n\nconst nextScratch = new Cartesian3();\nconst prevScratch = new Cartesian3();\n\nfunction computeRotationAngle(start, end, position, ellipsoid) {\n  const tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\n  const next = tangentPlane.projectPointOntoPlane(\n    Cartesian3.add(position, start, nextScratch),\n    nextScratch,\n  );\n  const prev = tangentPlane.projectPointOntoPlane(\n    Cartesian3.add(position, end, prevScratch),\n    prevScratch,\n  );\n  const angle = Cartesian2.angleBetween(next, prev);\n\n  return prev.x * next.y - prev.y * next.x >= 0.0 ? -angle : angle;\n}\n\nconst negativeX = new Cartesian3(-1, 0, 0);\nlet transform = new Matrix4();\nconst translation = new Matrix4();\nlet rotationZ = new Matrix3();\nconst scaleMatrix = Matrix3.IDENTITY.clone();\nconst westScratch = new Cartesian3();\nconst finalPosScratch = new Cartesian4();\nconst heightCartesian = new Cartesian3();\nfunction addPosition(\n  center,\n  left,\n  shape,\n  finalPositions,\n  ellipsoid,\n  height,\n  xScalar,\n  repeat,\n) {\n  let west = westScratch;\n  let finalPosition = finalPosScratch;\n  transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, transform);\n\n  west = Matrix4.multiplyByPointAsVector(transform, negativeX, west);\n  west = Cartesian3.normalize(west, west);\n  const angle = computeRotationAngle(west, left, center, ellipsoid);\n  rotationZ = Matrix3.fromRotationZ(angle, rotationZ);\n\n  heightCartesian.z = height;\n  transform = Matrix4.multiplyTransformation(\n    transform,\n    Matrix4.fromRotationTranslation(rotationZ, heightCartesian, translation),\n    transform,\n  );\n  const scale = scaleMatrix;\n  scale[0] = xScalar;\n\n  for (let j = 0; j < repeat; j++) {\n    for (let i = 0; i < shape.length; i += 3) {\n      finalPosition = Cartesian3.fromArray(shape, i, finalPosition);\n      finalPosition = Matrix3.multiplyByVector(\n        scale,\n        finalPosition,\n        finalPosition,\n      );\n      finalPosition = Matrix4.multiplyByPoint(\n        transform,\n        finalPosition,\n        finalPosition,\n      );\n      finalPositions.push(finalPosition.x, finalPosition.y, finalPosition.z);\n    }\n  }\n\n  return finalPositions;\n}\n\nconst centerScratch = new Cartesian3();\nfunction addPositions(\n  centers,\n  left,\n  shape,\n  finalPositions,\n  ellipsoid,\n  heights,\n  xScalar,\n) {\n  for (let i = 0; i < centers.length; i += 3) {\n    const center = Cartesian3.fromArray(centers, i, centerScratch);\n    finalPositions = addPosition(\n      center,\n      left,\n      shape,\n      finalPositions,\n      ellipsoid,\n      heights[i / 3],\n      xScalar,\n      1,\n    );\n  }\n  return finalPositions;\n}\n\nfunction convertShapeTo3DDuplicate(shape2D, boundingRectangle) {\n  //orientate 2D shape to XZ plane center at (0, 0, 0), duplicate points\n  const length = shape2D.length;\n  const shape = new Array(length * 6);\n  let index = 0;\n  const xOffset = boundingRectangle.x + boundingRectangle.width / 2;\n  const yOffset = boundingRectangle.y + boundingRectangle.height / 2;\n\n  let point = shape2D[0];\n  shape[index++] = point.x - xOffset;\n  shape[index++] = 0.0;\n  shape[index++] = point.y - yOffset;\n  for (let i = 1; i < length; i++) {\n    point = shape2D[i];\n    const x = point.x - xOffset;\n    const z = point.y - yOffset;\n    shape[index++] = x;\n    shape[index++] = 0.0;\n    shape[index++] = z;\n\n    shape[index++] = x;\n    shape[index++] = 0.0;\n    shape[index++] = z;\n  }\n  point = shape2D[0];\n  shape[index++] = point.x - xOffset;\n  shape[index++] = 0.0;\n  shape[index++] = point.y - yOffset;\n\n  return shape;\n}\n\nfunction convertShapeTo3D(shape2D, boundingRectangle) {\n  //orientate 2D shape to XZ plane center at (0, 0, 0)\n  const length = shape2D.length;\n  const shape = new Array(length * 3);\n  let index = 0;\n  const xOffset = boundingRectangle.x + boundingRectangle.width / 2;\n  const yOffset = boundingRectangle.y + boundingRectangle.height / 2;\n\n  for (let i = 0; i < length; i++) {\n    shape[index++] = shape2D[i].x - xOffset;\n    shape[index++] = 0;\n    shape[index++] = shape2D[i].y - yOffset;\n  }\n\n  return shape;\n}\n\nconst quaterion = new Quaternion();\nconst startPointScratch = new Cartesian3();\nconst rotMatrix = new Matrix3();\nfunction computeRoundCorner(\n  pivot,\n  startPoint,\n  endPoint,\n  cornerType,\n  leftIsOutside,\n  ellipsoid,\n  finalPositions,\n  shape,\n  height,\n  duplicatePoints,\n) {\n  const angle = Cartesian3.angleBetween(\n    Cartesian3.subtract(startPoint, pivot, scratch1),\n    Cartesian3.subtract(endPoint, pivot, scratch2),\n  );\n  const granularity =\n    cornerType === CornerType.BEVELED\n      ? 0\n      : Math.ceil(angle / CesiumMath.toRadians(5));\n\n  let m;\n  if (leftIsOutside) {\n    m = Matrix3.fromQuaternion(\n      Quaternion.fromAxisAngle(\n        Cartesian3.negate(pivot, scratch1),\n        angle / (granularity + 1),\n        quaterion,\n      ),\n      rotMatrix,\n    );\n  } else {\n    m = Matrix3.fromQuaternion(\n      Quaternion.fromAxisAngle(pivot, angle / (granularity + 1), quaterion),\n      rotMatrix,\n    );\n  }\n\n  let left;\n  let surfacePoint;\n  startPoint = Cartesian3.clone(startPoint, startPointScratch);\n  if (granularity > 0) {\n    const repeat = duplicatePoints ? 2 : 1;\n    for (let i = 0; i < granularity; i++) {\n      startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n      left = Cartesian3.subtract(startPoint, pivot, scratch1);\n      left = Cartesian3.normalize(left, left);\n      if (!leftIsOutside) {\n        left = Cartesian3.negate(left, left);\n      }\n      surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\n      finalPositions = addPosition(\n        surfacePoint,\n        left,\n        shape,\n        finalPositions,\n        ellipsoid,\n        height,\n        1,\n        repeat,\n      );\n    }\n  } else {\n    left = Cartesian3.subtract(startPoint, pivot, scratch1);\n    left = Cartesian3.normalize(left, left);\n    if (!leftIsOutside) {\n      left = Cartesian3.negate(left, left);\n    }\n    surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\n    finalPositions = addPosition(\n      surfacePoint,\n      left,\n      shape,\n      finalPositions,\n      ellipsoid,\n      height,\n      1,\n      1,\n    );\n\n    endPoint = Cartesian3.clone(endPoint, startPointScratch);\n    left = Cartesian3.subtract(endPoint, pivot, scratch1);\n    left = Cartesian3.normalize(left, left);\n    if (!leftIsOutside) {\n      left = Cartesian3.negate(left, left);\n    }\n    surfacePoint = ellipsoid.scaleToGeodeticSurface(endPoint, scratch2);\n    finalPositions = addPosition(\n      surfacePoint,\n      left,\n      shape,\n      finalPositions,\n      ellipsoid,\n      height,\n      1,\n      1,\n    );\n  }\n\n  return finalPositions;\n}\n\nPolylineVolumeGeometryLibrary.removeDuplicatesFromShape = function (\n  shapePositions,\n) {\n  const length = shapePositions.length;\n  const cleanedPositions = [];\n  for (let i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {\n    const v0 = shapePositions[i0];\n    const v1 = shapePositions[i1];\n\n    if (!Cartesian2.equals(v0, v1)) {\n      cleanedPositions.push(v1); // Shallow copy!\n    }\n  }\n\n  return cleanedPositions;\n};\n\nPolylineVolumeGeometryLibrary.angleIsGreaterThanPi = function (\n  forward,\n  backward,\n  position,\n  ellipsoid,\n) {\n  const tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\n  const next = tangentPlane.projectPointOntoPlane(\n    Cartesian3.add(position, forward, nextScratch),\n    nextScratch,\n  );\n  const prev = tangentPlane.projectPointOntoPlane(\n    Cartesian3.add(position, backward, prevScratch),\n    prevScratch,\n  );\n\n  return prev.x * next.y - prev.y * next.x >= 0.0;\n};\n\nconst scratchForwardProjection = new Cartesian3();\nconst scratchBackwardProjection = new Cartesian3();\n\nPolylineVolumeGeometryLibrary.computePositions = function (\n  positions,\n  shape2D,\n  boundingRectangle,\n  geometry,\n  duplicatePoints,\n) {\n  const ellipsoid = geometry._ellipsoid;\n  const heights = scaleToSurface(positions, ellipsoid);\n  const granularity = geometry._granularity;\n  const cornerType = geometry._cornerType;\n  const shapeForSides = duplicatePoints\n    ? convertShapeTo3DDuplicate(shape2D, boundingRectangle)\n    : convertShapeTo3D(shape2D, boundingRectangle);\n  const shapeForEnds = duplicatePoints\n    ? convertShapeTo3D(shape2D, boundingRectangle)\n    : undefined;\n  const heightOffset = boundingRectangle.height / 2;\n  const width = boundingRectangle.width / 2;\n  let length = positions.length;\n  let finalPositions = [];\n  let ends = duplicatePoints ? [] : undefined;\n\n  let forward = scratchCartesian1;\n  let backward = scratchCartesian2;\n  let cornerDirection = scratchCartesian3;\n  let surfaceNormal = scratchCartesian4;\n  let pivot = scratchCartesian5;\n  let start = scratchCartesian6;\n  let end = scratchCartesian7;\n  let left = scratchCartesian8;\n  let previousPosition = scratchCartesian9;\n\n  let position = positions[0];\n  let nextPosition = positions[1];\n  surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\n  forward = Cartesian3.subtract(nextPosition, position, forward);\n  forward = Cartesian3.normalize(forward, forward);\n  left = Cartesian3.cross(surfaceNormal, forward, left);\n  left = Cartesian3.normalize(left, left);\n  let h0 = heights[0];\n  let h1 = heights[1];\n  if (duplicatePoints) {\n    ends = addPosition(\n      position,\n      left,\n      shapeForEnds,\n      ends,\n      ellipsoid,\n      h0 + heightOffset,\n      1,\n      1,\n    );\n  }\n  previousPosition = Cartesian3.clone(position, previousPosition);\n  position = nextPosition;\n  backward = Cartesian3.negate(forward, backward);\n  let subdividedHeights;\n  let subdividedPositions;\n  for (let i = 1; i < length - 1; i++) {\n    const repeat = duplicatePoints ? 2 : 1;\n    nextPosition = positions[i + 1];\n    if (position.equals(nextPosition)) {\n      oneTimeWarning(\n        \"Positions are too close and are considered equivalent with rounding error.\",\n      );\n      continue;\n    }\n    forward = Cartesian3.subtract(nextPosition, position, forward);\n    forward = Cartesian3.normalize(forward, forward);\n    surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\n\n    const forwardProjection = Cartesian3.multiplyByScalar(\n      surfaceNormal,\n      Cartesian3.dot(forward, surfaceNormal),\n      scratchForwardProjection,\n    );\n    Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n    Cartesian3.normalize(forwardProjection, forwardProjection);\n\n    const backwardProjection = Cartesian3.multiplyByScalar(\n      surfaceNormal,\n      Cartesian3.dot(backward, surfaceNormal),\n      scratchBackwardProjection,\n    );\n    Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n    Cartesian3.normalize(backwardProjection, backwardProjection);\n\n    const doCorner = !CesiumMath.equalsEpsilon(\n      Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)),\n      1.0,\n      CesiumMath.EPSILON7,\n    );\n\n    if (doCorner) {\n      cornerDirection = Cartesian3.add(forward, backward, cornerDirection);\n      cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n      cornerDirection = Cartesian3.cross(\n        cornerDirection,\n        surfaceNormal,\n        cornerDirection,\n      );\n      cornerDirection = Cartesian3.cross(\n        surfaceNormal,\n        cornerDirection,\n        cornerDirection,\n      );\n      cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n      const scalar =\n        1 /\n        Math.max(\n          0.25,\n          Cartesian3.magnitude(\n            Cartesian3.cross(cornerDirection, backward, scratch1),\n          ),\n        );\n      const leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(\n        forward,\n        backward,\n        position,\n        ellipsoid,\n      );\n      if (leftIsOutside) {\n        pivot = Cartesian3.add(\n          position,\n          Cartesian3.multiplyByScalar(\n            cornerDirection,\n            scalar * width,\n            cornerDirection,\n          ),\n          pivot,\n        );\n        start = Cartesian3.add(\n          pivot,\n          Cartesian3.multiplyByScalar(left, width, start),\n          start,\n        );\n        scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n        scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\n        subdividedHeights = subdivideHeights(\n          scratch2Array,\n          h0 + heightOffset,\n          h1 + heightOffset,\n          granularity,\n        );\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scratch2Array,\n          granularity: granularity,\n          ellipsoid: ellipsoid,\n        });\n        finalPositions = addPositions(\n          subdividedPositions,\n          left,\n          shapeForSides,\n          finalPositions,\n          ellipsoid,\n          subdividedHeights,\n          1,\n        );\n        left = Cartesian3.cross(surfaceNormal, forward, left);\n        left = Cartesian3.normalize(left, left);\n        end = Cartesian3.add(\n          pivot,\n          Cartesian3.multiplyByScalar(left, width, end),\n          end,\n        );\n        if (\n          cornerType === CornerType.ROUNDED ||\n          cornerType === CornerType.BEVELED\n        ) {\n          computeRoundCorner(\n            pivot,\n            start,\n            end,\n            cornerType,\n            leftIsOutside,\n            ellipsoid,\n            finalPositions,\n            shapeForSides,\n            h1 + heightOffset,\n            duplicatePoints,\n          );\n        } else {\n          cornerDirection = Cartesian3.negate(cornerDirection, cornerDirection);\n          finalPositions = addPosition(\n            position,\n            cornerDirection,\n            shapeForSides,\n            finalPositions,\n            ellipsoid,\n            h1 + heightOffset,\n            scalar,\n            repeat,\n          );\n        }\n        previousPosition = Cartesian3.clone(end, previousPosition);\n      } else {\n        pivot = Cartesian3.add(\n          position,\n          Cartesian3.multiplyByScalar(\n            cornerDirection,\n            scalar * width,\n            cornerDirection,\n          ),\n          pivot,\n        );\n        start = Cartesian3.add(\n          pivot,\n          Cartesian3.multiplyByScalar(left, -width, start),\n          start,\n        );\n        scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n        scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\n        subdividedHeights = subdivideHeights(\n          scratch2Array,\n          h0 + heightOffset,\n          h1 + heightOffset,\n          granularity,\n        );\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scratch2Array,\n          granularity: granularity,\n          ellipsoid: ellipsoid,\n        });\n        finalPositions = addPositions(\n          subdividedPositions,\n          left,\n          shapeForSides,\n          finalPositions,\n          ellipsoid,\n          subdividedHeights,\n          1,\n        );\n        left = Cartesian3.cross(surfaceNormal, forward, left);\n        left = Cartesian3.normalize(left, left);\n        end = Cartesian3.add(\n          pivot,\n          Cartesian3.multiplyByScalar(left, -width, end),\n          end,\n        );\n        if (\n          cornerType === CornerType.ROUNDED ||\n          cornerType === CornerType.BEVELED\n        ) {\n          computeRoundCorner(\n            pivot,\n            start,\n            end,\n            cornerType,\n            leftIsOutside,\n            ellipsoid,\n            finalPositions,\n            shapeForSides,\n            h1 + heightOffset,\n            duplicatePoints,\n          );\n        } else {\n          finalPositions = addPosition(\n            position,\n            cornerDirection,\n            shapeForSides,\n            finalPositions,\n            ellipsoid,\n            h1 + heightOffset,\n            scalar,\n            repeat,\n          );\n        }\n        previousPosition = Cartesian3.clone(end, previousPosition);\n      }\n      backward = Cartesian3.negate(forward, backward);\n    } else {\n      finalPositions = addPosition(\n        previousPosition,\n        left,\n        shapeForSides,\n        finalPositions,\n        ellipsoid,\n        h0 + heightOffset,\n        1,\n        1,\n      );\n      previousPosition = position;\n    }\n    h0 = h1;\n    h1 = heights[i + 1];\n    position = nextPosition;\n  }\n\n  scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n  scratch2Array[1] = Cartesian3.clone(position, scratch2Array[1]);\n  subdividedHeights = subdivideHeights(\n    scratch2Array,\n    h0 + heightOffset,\n    h1 + heightOffset,\n    granularity,\n  );\n  subdividedPositions = PolylinePipeline.generateArc({\n    positions: scratch2Array,\n    granularity: granularity,\n    ellipsoid: ellipsoid,\n  });\n  finalPositions = addPositions(\n    subdividedPositions,\n    left,\n    shapeForSides,\n    finalPositions,\n    ellipsoid,\n    subdividedHeights,\n    1,\n  );\n  if (duplicatePoints) {\n    ends = addPosition(\n      position,\n      left,\n      shapeForEnds,\n      ends,\n      ellipsoid,\n      h1 + heightOffset,\n      1,\n      1,\n    );\n  }\n\n  length = finalPositions.length;\n  const posLength = duplicatePoints ? length + ends.length : length;\n  const combinedPositions = new Float64Array(posLength);\n  combinedPositions.set(finalPositions);\n  if (duplicatePoints) {\n    combinedPositions.set(ends, length);\n  }\n\n  return combinedPositions;\n};\nexport default PolylineVolumeGeometryLibrary;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}