{"ast":null,"code":"import addExtensionsUsed from \"./addExtensionsUsed.js\";\nimport addExtensionsRequired from \"./addExtensionsRequired.js\";\nimport addToArray from \"./addToArray.js\";\nimport ForEach from \"./ForEach.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Move glTF 1.0 material techniques to glTF 2.0 KHR_techniques_webgl extension.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @returns {object} The updated glTF asset.\n *\n * @private\n */\nfunction moveTechniquesToExtension(gltf) {\n  const techniquesLegacy = gltf.techniques;\n  const mappedUniforms = {};\n  const updatedTechniqueIndices = {};\n  const seenPrograms = {};\n  if (defined(techniquesLegacy)) {\n    const extension = {\n      programs: [],\n      shaders: [],\n      techniques: []\n    };\n\n    // Some 1.1 models have a glExtensionsUsed property that can be transferred to program.glExtensions\n    const glExtensions = gltf.glExtensionsUsed;\n    delete gltf.glExtensionsUsed;\n    ForEach.technique(gltf, function (techniqueLegacy, techniqueId) {\n      const technique = {\n        name: techniqueLegacy.name,\n        program: undefined,\n        attributes: {},\n        uniforms: {}\n      };\n      let parameterLegacy;\n      ForEach.techniqueAttribute(techniqueLegacy, function (parameterName, attributeName) {\n        parameterLegacy = techniqueLegacy.parameters[parameterName];\n        technique.attributes[attributeName] = {\n          semantic: parameterLegacy.semantic\n        };\n      });\n      ForEach.techniqueUniform(techniqueLegacy, function (parameterName, uniformName) {\n        parameterLegacy = techniqueLegacy.parameters[parameterName];\n        technique.uniforms[uniformName] = {\n          count: parameterLegacy.count,\n          node: parameterLegacy.node,\n          type: parameterLegacy.type,\n          semantic: parameterLegacy.semantic,\n          value: parameterLegacy.value\n        };\n\n        // Store the name of the uniform to update material values.\n        if (!defined(mappedUniforms[techniqueId])) {\n          mappedUniforms[techniqueId] = {};\n        }\n        mappedUniforms[techniqueId][parameterName] = uniformName;\n      });\n      if (!defined(seenPrograms[techniqueLegacy.program])) {\n        const programLegacy = gltf.programs[techniqueLegacy.program];\n        const program = {\n          name: programLegacy.name,\n          fragmentShader: undefined,\n          vertexShader: undefined,\n          glExtensions: glExtensions\n        };\n        const fs = gltf.shaders[programLegacy.fragmentShader];\n        program.fragmentShader = addToArray(extension.shaders, fs, true);\n        const vs = gltf.shaders[programLegacy.vertexShader];\n        program.vertexShader = addToArray(extension.shaders, vs, true);\n        technique.program = addToArray(extension.programs, program);\n        seenPrograms[techniqueLegacy.program] = technique.program;\n      } else {\n        technique.program = seenPrograms[techniqueLegacy.program];\n      }\n\n      // Store the index of the new technique to reference instead.\n      updatedTechniqueIndices[techniqueId] = addToArray(extension.techniques, technique);\n    });\n    if (extension.techniques.length > 0) {\n      if (!defined(gltf.extensions)) {\n        gltf.extensions = {};\n      }\n      gltf.extensions.KHR_techniques_webgl = extension;\n      addExtensionsUsed(gltf, \"KHR_techniques_webgl\");\n      addExtensionsRequired(gltf, \"KHR_techniques_webgl\");\n    }\n  }\n  ForEach.material(gltf, function (material) {\n    if (defined(material.technique)) {\n      const materialExtension = {\n        technique: updatedTechniqueIndices[material.technique]\n      };\n      ForEach.objectLegacy(material.values, function (value, parameterName) {\n        if (!defined(materialExtension.values)) {\n          materialExtension.values = {};\n        }\n        const uniformName = mappedUniforms[material.technique][parameterName];\n        if (defined(uniformName)) {\n          materialExtension.values[uniformName] = value;\n        }\n      });\n      if (!defined(material.extensions)) {\n        material.extensions = {};\n      }\n      material.extensions.KHR_techniques_webgl = materialExtension;\n    }\n    delete material.technique;\n    delete material.values;\n  });\n  delete gltf.techniques;\n  delete gltf.programs;\n  delete gltf.shaders;\n  return gltf;\n}\nexport default moveTechniquesToExtension;","map":{"version":3,"names":["addExtensionsUsed","addExtensionsRequired","addToArray","ForEach","defined","moveTechniquesToExtension","gltf","techniquesLegacy","techniques","mappedUniforms","updatedTechniqueIndices","seenPrograms","extension","programs","shaders","glExtensions","glExtensionsUsed","technique","techniqueLegacy","techniqueId","name","program","undefined","attributes","uniforms","parameterLegacy","techniqueAttribute","parameterName","attributeName","parameters","semantic","techniqueUniform","uniformName","count","node","type","value","programLegacy","fragmentShader","vertexShader","fs","vs","length","extensions","KHR_techniques_webgl","material","materialExtension","objectLegacy","values"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/GltfPipeline/moveTechniquesToExtension.js"],"sourcesContent":["import addExtensionsUsed from \"./addExtensionsUsed.js\";\nimport addExtensionsRequired from \"./addExtensionsRequired.js\";\nimport addToArray from \"./addToArray.js\";\nimport ForEach from \"./ForEach.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Move glTF 1.0 material techniques to glTF 2.0 KHR_techniques_webgl extension.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @returns {object} The updated glTF asset.\n *\n * @private\n */\nfunction moveTechniquesToExtension(gltf) {\n  const techniquesLegacy = gltf.techniques;\n  const mappedUniforms = {};\n  const updatedTechniqueIndices = {};\n  const seenPrograms = {};\n  if (defined(techniquesLegacy)) {\n    const extension = {\n      programs: [],\n      shaders: [],\n      techniques: [],\n    };\n\n    // Some 1.1 models have a glExtensionsUsed property that can be transferred to program.glExtensions\n    const glExtensions = gltf.glExtensionsUsed;\n    delete gltf.glExtensionsUsed;\n\n    ForEach.technique(gltf, function (techniqueLegacy, techniqueId) {\n      const technique = {\n        name: techniqueLegacy.name,\n        program: undefined,\n        attributes: {},\n        uniforms: {},\n      };\n\n      let parameterLegacy;\n      ForEach.techniqueAttribute(\n        techniqueLegacy,\n        function (parameterName, attributeName) {\n          parameterLegacy = techniqueLegacy.parameters[parameterName];\n          technique.attributes[attributeName] = {\n            semantic: parameterLegacy.semantic,\n          };\n        },\n      );\n\n      ForEach.techniqueUniform(\n        techniqueLegacy,\n        function (parameterName, uniformName) {\n          parameterLegacy = techniqueLegacy.parameters[parameterName];\n          technique.uniforms[uniformName] = {\n            count: parameterLegacy.count,\n            node: parameterLegacy.node,\n            type: parameterLegacy.type,\n            semantic: parameterLegacy.semantic,\n            value: parameterLegacy.value,\n          };\n\n          // Store the name of the uniform to update material values.\n          if (!defined(mappedUniforms[techniqueId])) {\n            mappedUniforms[techniqueId] = {};\n          }\n          mappedUniforms[techniqueId][parameterName] = uniformName;\n        },\n      );\n\n      if (!defined(seenPrograms[techniqueLegacy.program])) {\n        const programLegacy = gltf.programs[techniqueLegacy.program];\n\n        const program = {\n          name: programLegacy.name,\n          fragmentShader: undefined,\n          vertexShader: undefined,\n          glExtensions: glExtensions,\n        };\n\n        const fs = gltf.shaders[programLegacy.fragmentShader];\n        program.fragmentShader = addToArray(extension.shaders, fs, true);\n\n        const vs = gltf.shaders[programLegacy.vertexShader];\n        program.vertexShader = addToArray(extension.shaders, vs, true);\n\n        technique.program = addToArray(extension.programs, program);\n        seenPrograms[techniqueLegacy.program] = technique.program;\n      } else {\n        technique.program = seenPrograms[techniqueLegacy.program];\n      }\n\n      // Store the index of the new technique to reference instead.\n      updatedTechniqueIndices[techniqueId] = addToArray(\n        extension.techniques,\n        technique,\n      );\n    });\n\n    if (extension.techniques.length > 0) {\n      if (!defined(gltf.extensions)) {\n        gltf.extensions = {};\n      }\n\n      gltf.extensions.KHR_techniques_webgl = extension;\n      addExtensionsUsed(gltf, \"KHR_techniques_webgl\");\n      addExtensionsRequired(gltf, \"KHR_techniques_webgl\");\n    }\n  }\n\n  ForEach.material(gltf, function (material) {\n    if (defined(material.technique)) {\n      const materialExtension = {\n        technique: updatedTechniqueIndices[material.technique],\n      };\n\n      ForEach.objectLegacy(material.values, function (value, parameterName) {\n        if (!defined(materialExtension.values)) {\n          materialExtension.values = {};\n        }\n\n        const uniformName = mappedUniforms[material.technique][parameterName];\n        if (defined(uniformName)) {\n          materialExtension.values[uniformName] = value;\n        }\n      });\n\n      if (!defined(material.extensions)) {\n        material.extensions = {};\n      }\n\n      material.extensions.KHR_techniques_webgl = materialExtension;\n    }\n\n    delete material.technique;\n    delete material.values;\n  });\n\n  delete gltf.techniques;\n  delete gltf.programs;\n  delete gltf.shaders;\n\n  return gltf;\n}\n\nexport default moveTechniquesToExtension;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}