{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport oneTimeWarning from \"../../Core/oneTimeWarning.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport CustomShaderStageVS from \"../../Shaders/Model/CustomShaderStageVS.js\";\nimport CustomShaderStageFS from \"../../Shaders/Model/CustomShaderStageFS.js\";\nimport CustomShaderMode from \"./CustomShaderMode.js\";\nimport FeatureIdPipelineStage from \"./FeatureIdPipelineStage.js\";\nimport MetadataPipelineStage from \"./MetadataPipelineStage.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport CustomShaderTranslucencyMode from \"./CustomShaderTranslucencyMode.js\";\n\n/**\n * The custom shader pipeline stage takes GLSL callbacks from the\n * {@link CustomShader} and inserts them into the overall shader code for the\n * {@link Model}. The input to the callback is a struct with many\n * properties that depend on the attributes of the primitive. This shader code\n * is automatically generated by this stage.\n *\n * @namespace CustomShaderPipelineStage\n *\n * @private\n */\nconst CustomShaderPipelineStage = {\n  name: \"CustomShaderPipelineStage\",\n  // Helps with debugging\n\n  STRUCT_ID_ATTRIBUTES_VS: \"AttributesVS\",\n  STRUCT_ID_ATTRIBUTES_FS: \"AttributesFS\",\n  STRUCT_NAME_ATTRIBUTES: \"Attributes\",\n  STRUCT_ID_VERTEX_INPUT: \"VertexInput\",\n  STRUCT_NAME_VERTEX_INPUT: \"VertexInput\",\n  STRUCT_ID_FRAGMENT_INPUT: \"FragmentInput\",\n  STRUCT_NAME_FRAGMENT_INPUT: \"FragmentInput\",\n  FUNCTION_ID_INITIALIZE_INPUT_STRUCT_VS: \"initializeInputStructVS\",\n  FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_VS: \"void initializeInputStruct(out VertexInput vsInput, ProcessedAttributes attributes)\",\n  FUNCTION_ID_INITIALIZE_INPUT_STRUCT_FS: \"initializeInputStructFS\",\n  FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_FS: \"void initializeInputStruct(out FragmentInput fsInput, ProcessedAttributes attributes)\",\n  // Expose method for testing.\n  _oneTimeWarning: oneTimeWarning\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render\n * resources:\n * <ul>\n *   <li>Modifies the shader to include the custom shader code to the vertex and fragment shaders</li>\n *   <li>Modifies the shader to include automatically-generated structs that serve as input to the custom shader callbacks </li>\n *   <li>Modifies the shader to include any additional user-defined uniforms</li>\n *   <li>Modifies the shader to include any additional user-defined varyings</li>\n *   <li>Adds any user-defined uniforms to the uniform map</li>\n *   <li>If the user specified a lighting model, the settings are overridden in the render resources</li>\n * </ul>\n * <p>\n * This pipeline stage is designed to fail gracefully where possible. If the\n * primitive does not have the right attributes to satisfy the shader code,\n * defaults will be inferred (when reasonable to do so). If not, the custom\n * shader will be disabled.\n * <p>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {FrameState} frameState The frame state.\n * @private\n */\nCustomShaderPipelineStage.process = function (renderResources, primitive, frameState) {\n  const {\n    shaderBuilder,\n    model,\n    alphaOptions\n  } = renderResources;\n  const {\n    customShader\n  } = model;\n\n  // Check the lighting model and translucent options first, as sometimes\n  // these are used even if there is no vertex or fragment shader text.\n  const {\n    lightingModel,\n    translucencyMode\n  } = customShader;\n\n  // if present, the lighting model overrides the material's lighting model.\n  if (defined(lightingModel)) {\n    renderResources.lightingOptions.lightingModel = lightingModel;\n  }\n  if (translucencyMode === CustomShaderTranslucencyMode.TRANSLUCENT) {\n    alphaOptions.pass = Pass.TRANSLUCENT;\n  } else if (translucencyMode === CustomShaderTranslucencyMode.OPAQUE) {\n    // Use the default opqaue pass (either OPAQUE or 3D_TILES), regardless of whether\n    // the material pipeline stage used translucent. The default is configured\n    // in AlphaPipelineStage\n    alphaOptions.pass = undefined;\n  }\n  // For CustomShaderTranslucencyMode.INHERIT, do not modify alphaOptions.pass\n\n  // Generate lines of code for the shader, but don't add them to the shader\n  // yet.\n  const generatedCode = generateShaderLines(customShader, primitive);\n\n  // In some corner cases, the primitive may not be compatible with the\n  // shader. In this case, skip the custom shader.\n  if (!generatedCode.customShaderEnabled) {\n    return;\n  }\n  addLinesToShader(shaderBuilder, customShader, generatedCode);\n\n  // the input to the fragment shader may include a low-precision ECEF position\n  if (generatedCode.shouldComputePositionWC) {\n    shaderBuilder.addDefine(\"COMPUTE_POSITION_WC_CUSTOM_SHADER\", undefined, ShaderDestination.BOTH);\n  }\n  if (defined(customShader.vertexShaderText)) {\n    shaderBuilder.addDefine(\"HAS_CUSTOM_VERTEX_SHADER\", undefined, ShaderDestination.VERTEX);\n  }\n  if (defined(customShader.fragmentShaderText)) {\n    shaderBuilder.addDefine(\"HAS_CUSTOM_FRAGMENT_SHADER\", undefined, ShaderDestination.FRAGMENT);\n\n    // add defines like CUSTOM_SHADER_MODIFY_MATERIAL\n    const shaderModeDefine = CustomShaderMode.getDefineName(customShader.mode);\n    shaderBuilder.addDefine(shaderModeDefine, undefined, ShaderDestination.FRAGMENT);\n  }\n  const uniforms = customShader.uniforms;\n  for (const uniformName in uniforms) {\n    if (uniforms.hasOwnProperty(uniformName)) {\n      const uniform = uniforms[uniformName];\n      shaderBuilder.addUniform(uniform.type, uniformName);\n    }\n  }\n  const varyings = customShader.varyings;\n  for (const varyingName in varyings) {\n    if (varyings.hasOwnProperty(varyingName)) {\n      const varyingType = varyings[varyingName];\n      shaderBuilder.addVarying(varyingType, varyingName);\n    }\n  }\n  renderResources.uniformMap = combine(renderResources.uniformMap, customShader.uniformMap);\n};\n\n/**\n * @private\n * @param {ModelComponents.Attribute[]} attributes\n * @returns {Object<string, ModelComponents.Attribute>}\n */\nfunction getAttributesByName(attributes) {\n  const names = {};\n  for (let i = 0; i < attributes.length; i++) {\n    const attributeInfo = ModelUtility.getAttributeInfo(attributes[i]);\n    names[attributeInfo.variableName] = attributeInfo;\n  }\n  return names;\n}\n\n// GLSL types of standard attribute types when uniquely defined\nconst attributeTypeLUT = {\n  position: \"vec3\",\n  normal: \"vec3\",\n  tangent: \"vec3\",\n  bitangent: \"vec3\",\n  texCoord: \"vec2\",\n  color: \"vec4\",\n  joints: \"ivec4\",\n  weights: \"vec4\"\n};\n\n// Corresponding attribute values\nconst attributeDefaultValueLUT = {\n  position: \"vec3(0.0)\",\n  normal: \"vec3(0.0, 0.0, 1.0)\",\n  tangent: \"vec3(1.0, 0.0, 0.0)\",\n  bitangent: \"vec3(0.0, 1.0, 0.0)\",\n  texCoord: \"vec2(0.0)\",\n  color: \"vec4(1.0)\",\n  joints: \"ivec4(0)\",\n  weights: \"vec4(0.0)\"\n};\nfunction inferAttributeDefaults(attributeName) {\n  // remove trailing set indices. E.g. \"texCoord_0\" -> \"texCoord\"\n  let trimmed = attributeName.replace(/_[0-9]+$/, \"\");\n  // also remove the MC/EC since they will have the same default value\n  trimmed = trimmed.replace(/(MC|EC)$/, \"\");\n  const glslType = attributeTypeLUT[trimmed];\n  const value = attributeDefaultValueLUT[trimmed];\n\n  // - _CUSTOM_ATTRIBUTE has an unknown type.\n  if (!defined(glslType)) {\n    return undefined;\n  }\n  return {\n    attributeField: [glslType, attributeName],\n    value: value\n  };\n}\n\n/**\n * @private\n * @param {CustomShader} customShader\n * @param {Object<string, ModelComponents.Attribute>} attributesByName\n * @returns {object}\n */\nfunction generateVertexShaderLines(customShader, attributesByName) {\n  if (!defined(customShader.vertexShaderText)) {\n    return {\n      enabled: false\n    };\n  }\n  const primitiveAttributes = customShader.usedVariablesVertex.attributeSet;\n  const addToShader = getPrimitiveAttributesUsedInShader(attributesByName, primitiveAttributes, false);\n  const needsDefault = getAttributesNeedingDefaults(attributesByName, primitiveAttributes, false);\n  let vertexInitialization;\n  const attributeFields = [];\n  const initializationLines = [];\n  for (const variableName in addToShader) {\n    if (!addToShader.hasOwnProperty(variableName)) {\n      continue;\n    }\n    const attributeInfo = addToShader[variableName];\n    const attributeField = [attributeInfo.glslType, variableName];\n    attributeFields.push(attributeField);\n\n    // Initializing attribute structs are just a matter of copying the\n    // attribute or varying: E.g.:\n    // \"    vsInput.attributes.position = a_position;\"\n    vertexInitialization = `vsInput.attributes.${variableName} = attributes.${variableName};`;\n    initializationLines.push(vertexInitialization);\n  }\n  for (let i = 0; i < needsDefault.length; i++) {\n    const variableName = needsDefault[i];\n    const attributeDefaults = inferAttributeDefaults(variableName);\n    if (!defined(attributeDefaults)) {\n      CustomShaderPipelineStage._oneTimeWarning(\"CustomShaderPipelineStage.incompatiblePrimitiveVS\", `Primitive is missing attribute ${variableName}, disabling custom vertex shader`);\n      // This primitive isn't compatible with the shader. Return early\n      // to skip the vertex shader\n      return {\n        enabled: false\n      };\n    }\n    attributeFields.push(attributeDefaults.attributeField);\n    vertexInitialization = `vsInput.attributes.${variableName} = ${attributeDefaults.value};`;\n    initializationLines.push(vertexInitialization);\n  }\n  return {\n    enabled: true,\n    attributeFields: attributeFields,\n    initializationLines: initializationLines\n  };\n}\nfunction generatePositionBuiltins(customShader) {\n  const attributeFields = [];\n  const initializationLines = [];\n  const usedVariables = customShader.usedVariablesFragment.attributeSet;\n\n  // Model space position is the same position as in the glTF accessor,\n  // this is already added to the shader with other attributes.\n\n  // World coordinates in ECEF coordinates. Note that this is\n  // low precision (32-bit floats) on the GPU.\n  if (usedVariables.hasOwnProperty(\"positionWC\")) {\n    attributeFields.push([\"vec3\", \"positionWC\"]);\n    initializationLines.push(\"fsInput.attributes.positionWC = attributes.positionWC;\");\n  }\n\n  // position in eye coordinates\n  if (usedVariables.hasOwnProperty(\"positionEC\")) {\n    attributeFields.push([\"vec3\", \"positionEC\"]);\n    initializationLines.push(\"fsInput.attributes.positionEC = attributes.positionEC;\");\n  }\n  return {\n    attributeFields: attributeFields,\n    initializationLines: initializationLines\n  };\n}\n\n/**\n * @private\n * @param {CustomShader} customShader\n * @param {Object<string, ModelComponents.Attribute>} attributesByName\n * @returns {object}\n */\nfunction generateFragmentShaderLines(customShader, attributesByName) {\n  if (!defined(customShader.fragmentShaderText)) {\n    return {\n      enabled: false\n    };\n  }\n  const primitiveAttributes = customShader.usedVariablesFragment.attributeSet;\n  const addToShader = getPrimitiveAttributesUsedInShader(attributesByName, primitiveAttributes, true);\n  const needsDefault = getAttributesNeedingDefaults(attributesByName, primitiveAttributes, true);\n  let fragmentInitialization;\n  const attributeFields = [];\n  const initializationLines = [];\n  for (const variableName in addToShader) {\n    if (!addToShader.hasOwnProperty(variableName)) {\n      continue;\n    }\n    const attributeInfo = addToShader[variableName];\n    const attributeField = [attributeInfo.glslType, variableName];\n    attributeFields.push(attributeField);\n\n    // Initializing attribute structs are just a matter of copying the\n    // value from the processed attributes\n    // \"    fsInput.attributes.positionMC = attributes.positionMC;\"\n    fragmentInitialization = `fsInput.attributes.${variableName} = attributes.${variableName};`;\n    initializationLines.push(fragmentInitialization);\n  }\n  for (let i = 0; i < needsDefault.length; i++) {\n    const variableName = needsDefault[i];\n    const attributeDefaults = inferAttributeDefaults(variableName);\n    if (!defined(attributeDefaults)) {\n      CustomShaderPipelineStage._oneTimeWarning(\"CustomShaderPipelineStage.incompatiblePrimitiveFS\", `Primitive is missing attribute ${variableName}, disabling custom fragment shader.`);\n\n      // This primitive isn't compatible with the shader. Return early\n      // so the fragment shader is skipped\n      return {\n        enabled: false\n      };\n    }\n    attributeFields.push(attributeDefaults.attributeField);\n    fragmentInitialization = `fsInput.attributes.${variableName} = ${attributeDefaults.value};`;\n    initializationLines.push(fragmentInitialization);\n  }\n\n  // Built-ins for positions in various coordinate systems.\n  const positionBuiltins = generatePositionBuiltins(customShader);\n  return {\n    enabled: true,\n    attributeFields: attributeFields.concat(positionBuiltins.attributeFields),\n    initializationLines: positionBuiltins.initializationLines.concat(initializationLines)\n  };\n}\n\n// These attributes are derived from positionMC, and are handled separately\n// from other attributes\nconst builtinAttributes = {\n  positionWC: true,\n  positionEC: true\n};\n\n/**\n * Get the primitive attributes that are referenced in the shader\n *\n * @private\n * @param {Object<string, ModelComponents.Attribute>} primitiveAttributes set of all the primitive's attributes\n * @param {Object<string, ModelComponents.Attribute>} shaderAttributeSet set of all attributes used in the shader\n * @param {boolean} isFragmentShader\n * @returns {Object<string, ModelComponents.Attribute>} A dictionary of the primitive attributes used in the shader\n */\nfunction getPrimitiveAttributesUsedInShader(primitiveAttributes, shaderAttributeSet, isFragmentShader) {\n  const addToShader = {};\n  for (const attributeName in primitiveAttributes) {\n    if (!primitiveAttributes.hasOwnProperty(attributeName)) {\n      continue;\n    }\n    const attribute = primitiveAttributes[attributeName];\n\n    // normals and tangents are in model coordinates in the attributes but\n    // in eye coordinates in the fragment shader.\n    let renamed = attributeName;\n    if (isFragmentShader && attributeName === \"normalMC\") {\n      renamed = \"normalEC\";\n    } else if (isFragmentShader && attributeName === \"tangentMC\") {\n      renamed = \"tangentEC\";\n      attribute.glslType = \"vec3\";\n    }\n    if (shaderAttributeSet.hasOwnProperty(renamed)) {\n      addToShader[renamed] = attribute;\n    }\n  }\n  return addToShader;\n}\n\n/**\n * Get the attributes that will need to have default values defined.\n * Attributes referenced in the shader which are not already defined\n * for the primitive and are not built-in will need default values.\n *\n * @private\n * @param {Object<string, ModelComponents.Attribute>} primitiveAttributes set of all the primitive's attributes\n * @param {Object<string, ModelComponents.Attribute>} shaderAttributeSet set of all attributes used in the shader\n * @param {boolean} isFragmentShader\n * @returns {string[]} The names of the attributes needing defaults\n */\nfunction getAttributesNeedingDefaults(primitiveAttributes, shaderAttributeSet, isFragmentShader) {\n  const needDefaults = [];\n  for (const attributeName in shaderAttributeSet) {\n    if (!shaderAttributeSet.hasOwnProperty(attributeName)) {\n      continue;\n    }\n    if (builtinAttributes.hasOwnProperty(attributeName)) {\n      // Builtins are handled separately from attributes, so skip them here\n      continue;\n    }\n\n    // normals and tangents are in model coordinates in the attributes but\n    // in eye coordinates in the fragment shader.\n    let renamed = attributeName;\n    if (isFragmentShader && attributeName === \"normalEC\") {\n      renamed = \"normalMC\";\n    } else if (isFragmentShader && attributeName === \"tangentEC\") {\n      renamed = \"tangentMC\";\n    }\n    if (!primitiveAttributes.hasOwnProperty(renamed)) {\n      needDefaults.push(attributeName);\n    }\n  }\n  return needDefaults;\n}\n\n/**\n * @private\n * @param {CustomShader} customShader\n * @param {ModelComponents.Primitive} primitive\n * @returns {object}\n */\nfunction generateShaderLines(customShader, primitive) {\n  // Attempt to generate vertex and fragment shader lines before adding any\n  // code to the shader.\n  const attributesByName = getAttributesByName(primitive.attributes);\n  const vertexLines = generateVertexShaderLines(customShader, attributesByName);\n  const fragmentLines = generateFragmentShaderLines(customShader, attributesByName);\n\n  // positionWC must be computed in the vertex shader\n  // for use in the fragmentShader. However, this can be skipped if:\n  // - positionWC isn't used in the fragment shader\n  // - or the fragment shader is disabled\n  const attributeSetFS = customShader.usedVariablesFragment.attributeSet;\n  const shouldComputePositionWC = attributeSetFS.hasOwnProperty(\"positionWC\") && fragmentLines.enabled;\n\n  // Return any generated shader code along with some flags to indicate which\n  // defines should be added.\n  return {\n    vertexLines: vertexLines,\n    fragmentLines: fragmentLines,\n    customShaderEnabled: vertexLines.enabled || fragmentLines.enabled,\n    shouldComputePositionWC: shouldComputePositionWC\n  };\n}\nfunction addVertexLinesToShader(shaderBuilder, vertexLines) {\n  let structId = CustomShaderPipelineStage.STRUCT_ID_ATTRIBUTES_VS;\n  shaderBuilder.addStruct(structId, CustomShaderPipelineStage.STRUCT_NAME_ATTRIBUTES, ShaderDestination.VERTEX);\n  const {\n    attributeFields,\n    initializationLines\n  } = vertexLines;\n  for (let i = 0; i < attributeFields.length; i++) {\n    const [glslType, variableName] = attributeFields[i];\n    shaderBuilder.addStructField(structId, glslType, variableName);\n  }\n\n  // This could be hard-coded, but the symmetry with other structs makes unit\n  // tests more convenient\n  structId = CustomShaderPipelineStage.STRUCT_ID_VERTEX_INPUT;\n  shaderBuilder.addStruct(structId, CustomShaderPipelineStage.STRUCT_NAME_VERTEX_INPUT, ShaderDestination.VERTEX);\n  shaderBuilder.addStructField(structId, CustomShaderPipelineStage.STRUCT_NAME_ATTRIBUTES, \"attributes\");\n  // Add FeatureIds struct from the Feature ID stage\n  shaderBuilder.addStructField(structId, FeatureIdPipelineStage.STRUCT_NAME_FEATURE_IDS, \"featureIds\");\n  // Add Metadata struct from the metadata stage\n  shaderBuilder.addStructField(structId, MetadataPipelineStage.STRUCT_NAME_METADATA, \"metadata\");\n  // Add MetadataClass struct from the metadata stage\n  shaderBuilder.addStructField(structId, MetadataPipelineStage.STRUCT_NAME_METADATA_CLASS, \"metadataClass\");\n  // Add MetadataStatistics struct from the metadata stage\n  shaderBuilder.addStructField(structId, MetadataPipelineStage.STRUCT_NAME_METADATA_STATISTICS, \"metadataStatistics\");\n  const functionId = CustomShaderPipelineStage.FUNCTION_ID_INITIALIZE_INPUT_STRUCT_VS;\n  shaderBuilder.addFunction(functionId, CustomShaderPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_VS, ShaderDestination.VERTEX);\n  shaderBuilder.addFunctionLines(functionId, initializationLines);\n}\nfunction addFragmentLinesToShader(shaderBuilder, fragmentLines) {\n  let structId = CustomShaderPipelineStage.STRUCT_ID_ATTRIBUTES_FS;\n  shaderBuilder.addStruct(structId, CustomShaderPipelineStage.STRUCT_NAME_ATTRIBUTES, ShaderDestination.FRAGMENT);\n  const {\n    attributeFields,\n    initializationLines\n  } = fragmentLines;\n  for (let i = 0; i < attributeFields.length; i++) {\n    const [glslType, variableName] = attributeFields[i];\n    shaderBuilder.addStructField(structId, glslType, variableName);\n  }\n  structId = CustomShaderPipelineStage.STRUCT_ID_FRAGMENT_INPUT;\n  shaderBuilder.addStruct(structId, CustomShaderPipelineStage.STRUCT_NAME_FRAGMENT_INPUT, ShaderDestination.FRAGMENT);\n  shaderBuilder.addStructField(structId, CustomShaderPipelineStage.STRUCT_NAME_ATTRIBUTES, \"attributes\");\n  // Add FeatureIds struct from the Feature ID stage\n  shaderBuilder.addStructField(structId, FeatureIdPipelineStage.STRUCT_NAME_FEATURE_IDS, \"featureIds\");\n  // Add Metadata struct from the metadata stage\n  shaderBuilder.addStructField(structId, MetadataPipelineStage.STRUCT_NAME_METADATA, \"metadata\");\n  // Add MetadataClass struct from the metadata stage\n  shaderBuilder.addStructField(structId, MetadataPipelineStage.STRUCT_NAME_METADATA_CLASS, \"metadataClass\");\n  // Add MetadataStatistics struct from the metadata stage\n  shaderBuilder.addStructField(structId, MetadataPipelineStage.STRUCT_NAME_METADATA_STATISTICS, \"metadataStatistics\");\n  const functionId = CustomShaderPipelineStage.FUNCTION_ID_INITIALIZE_INPUT_STRUCT_FS;\n  shaderBuilder.addFunction(functionId, CustomShaderPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_FS, ShaderDestination.FRAGMENT);\n  shaderBuilder.addFunctionLines(functionId, initializationLines);\n}\nconst scratchShaderLines = [];\nfunction addLinesToShader(shaderBuilder, customShader, generatedCode) {\n  const {\n    vertexLines,\n    fragmentLines\n  } = generatedCode;\n  const shaderLines = scratchShaderLines;\n  if (vertexLines.enabled) {\n    addVertexLinesToShader(shaderBuilder, vertexLines);\n    shaderLines.length = 0;\n    shaderLines.push(\"#line 0\", customShader.vertexShaderText, CustomShaderStageVS);\n    shaderBuilder.addVertexLines(shaderLines);\n  }\n  if (fragmentLines.enabled) {\n    addFragmentLinesToShader(shaderBuilder, fragmentLines);\n    shaderLines.length = 0;\n    shaderLines.push(\"#line 0\", customShader.fragmentShaderText, CustomShaderStageFS);\n    shaderBuilder.addFragmentLines(shaderLines);\n  }\n}\nexport default CustomShaderPipelineStage;","map":{"version":3,"names":["combine","defined","oneTimeWarning","ShaderDestination","Pass","CustomShaderStageVS","CustomShaderStageFS","CustomShaderMode","FeatureIdPipelineStage","MetadataPipelineStage","ModelUtility","CustomShaderTranslucencyMode","CustomShaderPipelineStage","name","STRUCT_ID_ATTRIBUTES_VS","STRUCT_ID_ATTRIBUTES_FS","STRUCT_NAME_ATTRIBUTES","STRUCT_ID_VERTEX_INPUT","STRUCT_NAME_VERTEX_INPUT","STRUCT_ID_FRAGMENT_INPUT","STRUCT_NAME_FRAGMENT_INPUT","FUNCTION_ID_INITIALIZE_INPUT_STRUCT_VS","FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_VS","FUNCTION_ID_INITIALIZE_INPUT_STRUCT_FS","FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_FS","_oneTimeWarning","process","renderResources","primitive","frameState","shaderBuilder","model","alphaOptions","customShader","lightingModel","translucencyMode","lightingOptions","TRANSLUCENT","pass","OPAQUE","undefined","generatedCode","generateShaderLines","customShaderEnabled","addLinesToShader","shouldComputePositionWC","addDefine","BOTH","vertexShaderText","VERTEX","fragmentShaderText","FRAGMENT","shaderModeDefine","getDefineName","mode","uniforms","uniformName","hasOwnProperty","uniform","addUniform","type","varyings","varyingName","varyingType","addVarying","uniformMap","getAttributesByName","attributes","names","i","length","attributeInfo","getAttributeInfo","variableName","attributeTypeLUT","position","normal","tangent","bitangent","texCoord","color","joints","weights","attributeDefaultValueLUT","inferAttributeDefaults","attributeName","trimmed","replace","glslType","value","attributeField","generateVertexShaderLines","attributesByName","enabled","primitiveAttributes","usedVariablesVertex","attributeSet","addToShader","getPrimitiveAttributesUsedInShader","needsDefault","getAttributesNeedingDefaults","vertexInitialization","attributeFields","initializationLines","push","attributeDefaults","generatePositionBuiltins","usedVariables","usedVariablesFragment","generateFragmentShaderLines","fragmentInitialization","positionBuiltins","concat","builtinAttributes","positionWC","positionEC","shaderAttributeSet","isFragmentShader","attribute","renamed","needDefaults","vertexLines","fragmentLines","attributeSetFS","addVertexLinesToShader","structId","addStruct","addStructField","STRUCT_NAME_FEATURE_IDS","STRUCT_NAME_METADATA","STRUCT_NAME_METADATA_CLASS","STRUCT_NAME_METADATA_STATISTICS","functionId","addFunction","addFunctionLines","addFragmentLinesToShader","scratchShaderLines","shaderLines","addVertexLines","addFragmentLines"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Model/CustomShaderPipelineStage.js"],"sourcesContent":["import combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport oneTimeWarning from \"../../Core/oneTimeWarning.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport CustomShaderStageVS from \"../../Shaders/Model/CustomShaderStageVS.js\";\nimport CustomShaderStageFS from \"../../Shaders/Model/CustomShaderStageFS.js\";\nimport CustomShaderMode from \"./CustomShaderMode.js\";\nimport FeatureIdPipelineStage from \"./FeatureIdPipelineStage.js\";\nimport MetadataPipelineStage from \"./MetadataPipelineStage.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport CustomShaderTranslucencyMode from \"./CustomShaderTranslucencyMode.js\";\n\n/**\n * The custom shader pipeline stage takes GLSL callbacks from the\n * {@link CustomShader} and inserts them into the overall shader code for the\n * {@link Model}. The input to the callback is a struct with many\n * properties that depend on the attributes of the primitive. This shader code\n * is automatically generated by this stage.\n *\n * @namespace CustomShaderPipelineStage\n *\n * @private\n */\nconst CustomShaderPipelineStage = {\n  name: \"CustomShaderPipelineStage\", // Helps with debugging\n\n  STRUCT_ID_ATTRIBUTES_VS: \"AttributesVS\",\n  STRUCT_ID_ATTRIBUTES_FS: \"AttributesFS\",\n  STRUCT_NAME_ATTRIBUTES: \"Attributes\",\n  STRUCT_ID_VERTEX_INPUT: \"VertexInput\",\n  STRUCT_NAME_VERTEX_INPUT: \"VertexInput\",\n  STRUCT_ID_FRAGMENT_INPUT: \"FragmentInput\",\n  STRUCT_NAME_FRAGMENT_INPUT: \"FragmentInput\",\n  FUNCTION_ID_INITIALIZE_INPUT_STRUCT_VS: \"initializeInputStructVS\",\n  FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_VS:\n    \"void initializeInputStruct(out VertexInput vsInput, ProcessedAttributes attributes)\",\n  FUNCTION_ID_INITIALIZE_INPUT_STRUCT_FS: \"initializeInputStructFS\",\n  FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_FS:\n    \"void initializeInputStruct(out FragmentInput fsInput, ProcessedAttributes attributes)\",\n\n  // Expose method for testing.\n  _oneTimeWarning: oneTimeWarning,\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render\n * resources:\n * <ul>\n *   <li>Modifies the shader to include the custom shader code to the vertex and fragment shaders</li>\n *   <li>Modifies the shader to include automatically-generated structs that serve as input to the custom shader callbacks </li>\n *   <li>Modifies the shader to include any additional user-defined uniforms</li>\n *   <li>Modifies the shader to include any additional user-defined varyings</li>\n *   <li>Adds any user-defined uniforms to the uniform map</li>\n *   <li>If the user specified a lighting model, the settings are overridden in the render resources</li>\n * </ul>\n * <p>\n * This pipeline stage is designed to fail gracefully where possible. If the\n * primitive does not have the right attributes to satisfy the shader code,\n * defaults will be inferred (when reasonable to do so). If not, the custom\n * shader will be disabled.\n * <p>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {FrameState} frameState The frame state.\n * @private\n */\nCustomShaderPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  const { shaderBuilder, model, alphaOptions } = renderResources;\n  const { customShader } = model;\n\n  // Check the lighting model and translucent options first, as sometimes\n  // these are used even if there is no vertex or fragment shader text.\n  const { lightingModel, translucencyMode } = customShader;\n\n  // if present, the lighting model overrides the material's lighting model.\n  if (defined(lightingModel)) {\n    renderResources.lightingOptions.lightingModel = lightingModel;\n  }\n\n  if (translucencyMode === CustomShaderTranslucencyMode.TRANSLUCENT) {\n    alphaOptions.pass = Pass.TRANSLUCENT;\n  } else if (translucencyMode === CustomShaderTranslucencyMode.OPAQUE) {\n    // Use the default opqaue pass (either OPAQUE or 3D_TILES), regardless of whether\n    // the material pipeline stage used translucent. The default is configured\n    // in AlphaPipelineStage\n    alphaOptions.pass = undefined;\n  }\n  // For CustomShaderTranslucencyMode.INHERIT, do not modify alphaOptions.pass\n\n  // Generate lines of code for the shader, but don't add them to the shader\n  // yet.\n  const generatedCode = generateShaderLines(customShader, primitive);\n\n  // In some corner cases, the primitive may not be compatible with the\n  // shader. In this case, skip the custom shader.\n  if (!generatedCode.customShaderEnabled) {\n    return;\n  }\n  addLinesToShader(shaderBuilder, customShader, generatedCode);\n\n  // the input to the fragment shader may include a low-precision ECEF position\n  if (generatedCode.shouldComputePositionWC) {\n    shaderBuilder.addDefine(\n      \"COMPUTE_POSITION_WC_CUSTOM_SHADER\",\n      undefined,\n      ShaderDestination.BOTH,\n    );\n  }\n\n  if (defined(customShader.vertexShaderText)) {\n    shaderBuilder.addDefine(\n      \"HAS_CUSTOM_VERTEX_SHADER\",\n      undefined,\n      ShaderDestination.VERTEX,\n    );\n  }\n\n  if (defined(customShader.fragmentShaderText)) {\n    shaderBuilder.addDefine(\n      \"HAS_CUSTOM_FRAGMENT_SHADER\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n\n    // add defines like CUSTOM_SHADER_MODIFY_MATERIAL\n    const shaderModeDefine = CustomShaderMode.getDefineName(customShader.mode);\n    shaderBuilder.addDefine(\n      shaderModeDefine,\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  const uniforms = customShader.uniforms;\n  for (const uniformName in uniforms) {\n    if (uniforms.hasOwnProperty(uniformName)) {\n      const uniform = uniforms[uniformName];\n      shaderBuilder.addUniform(uniform.type, uniformName);\n    }\n  }\n\n  const varyings = customShader.varyings;\n  for (const varyingName in varyings) {\n    if (varyings.hasOwnProperty(varyingName)) {\n      const varyingType = varyings[varyingName];\n      shaderBuilder.addVarying(varyingType, varyingName);\n    }\n  }\n\n  renderResources.uniformMap = combine(\n    renderResources.uniformMap,\n    customShader.uniformMap,\n  );\n};\n\n/**\n * @private\n * @param {ModelComponents.Attribute[]} attributes\n * @returns {Object<string, ModelComponents.Attribute>}\n */\nfunction getAttributesByName(attributes) {\n  const names = {};\n  for (let i = 0; i < attributes.length; i++) {\n    const attributeInfo = ModelUtility.getAttributeInfo(attributes[i]);\n    names[attributeInfo.variableName] = attributeInfo;\n  }\n  return names;\n}\n\n// GLSL types of standard attribute types when uniquely defined\nconst attributeTypeLUT = {\n  position: \"vec3\",\n  normal: \"vec3\",\n  tangent: \"vec3\",\n  bitangent: \"vec3\",\n  texCoord: \"vec2\",\n  color: \"vec4\",\n  joints: \"ivec4\",\n  weights: \"vec4\",\n};\n\n// Corresponding attribute values\nconst attributeDefaultValueLUT = {\n  position: \"vec3(0.0)\",\n  normal: \"vec3(0.0, 0.0, 1.0)\",\n  tangent: \"vec3(1.0, 0.0, 0.0)\",\n  bitangent: \"vec3(0.0, 1.0, 0.0)\",\n  texCoord: \"vec2(0.0)\",\n  color: \"vec4(1.0)\",\n  joints: \"ivec4(0)\",\n  weights: \"vec4(0.0)\",\n};\n\nfunction inferAttributeDefaults(attributeName) {\n  // remove trailing set indices. E.g. \"texCoord_0\" -> \"texCoord\"\n  let trimmed = attributeName.replace(/_[0-9]+$/, \"\");\n  // also remove the MC/EC since they will have the same default value\n  trimmed = trimmed.replace(/(MC|EC)$/, \"\");\n\n  const glslType = attributeTypeLUT[trimmed];\n  const value = attributeDefaultValueLUT[trimmed];\n\n  // - _CUSTOM_ATTRIBUTE has an unknown type.\n  if (!defined(glslType)) {\n    return undefined;\n  }\n\n  return {\n    attributeField: [glslType, attributeName],\n    value: value,\n  };\n}\n\n/**\n * @private\n * @param {CustomShader} customShader\n * @param {Object<string, ModelComponents.Attribute>} attributesByName\n * @returns {object}\n */\nfunction generateVertexShaderLines(customShader, attributesByName) {\n  if (!defined(customShader.vertexShaderText)) {\n    return { enabled: false };\n  }\n\n  const primitiveAttributes = customShader.usedVariablesVertex.attributeSet;\n  const addToShader = getPrimitiveAttributesUsedInShader(\n    attributesByName,\n    primitiveAttributes,\n    false,\n  );\n  const needsDefault = getAttributesNeedingDefaults(\n    attributesByName,\n    primitiveAttributes,\n    false,\n  );\n\n  let vertexInitialization;\n  const attributeFields = [];\n  const initializationLines = [];\n  for (const variableName in addToShader) {\n    if (!addToShader.hasOwnProperty(variableName)) {\n      continue;\n    }\n    const attributeInfo = addToShader[variableName];\n    const attributeField = [attributeInfo.glslType, variableName];\n    attributeFields.push(attributeField);\n\n    // Initializing attribute structs are just a matter of copying the\n    // attribute or varying: E.g.:\n    // \"    vsInput.attributes.position = a_position;\"\n    vertexInitialization = `vsInput.attributes.${variableName} = attributes.${variableName};`;\n    initializationLines.push(vertexInitialization);\n  }\n\n  for (let i = 0; i < needsDefault.length; i++) {\n    const variableName = needsDefault[i];\n    const attributeDefaults = inferAttributeDefaults(variableName);\n    if (!defined(attributeDefaults)) {\n      CustomShaderPipelineStage._oneTimeWarning(\n        \"CustomShaderPipelineStage.incompatiblePrimitiveVS\",\n        `Primitive is missing attribute ${variableName}, disabling custom vertex shader`,\n      );\n      // This primitive isn't compatible with the shader. Return early\n      // to skip the vertex shader\n      return { enabled: false };\n    }\n\n    attributeFields.push(attributeDefaults.attributeField);\n    vertexInitialization = `vsInput.attributes.${variableName} = ${attributeDefaults.value};`;\n    initializationLines.push(vertexInitialization);\n  }\n\n  return {\n    enabled: true,\n    attributeFields: attributeFields,\n    initializationLines: initializationLines,\n  };\n}\n\nfunction generatePositionBuiltins(customShader) {\n  const attributeFields = [];\n  const initializationLines = [];\n  const usedVariables = customShader.usedVariablesFragment.attributeSet;\n\n  // Model space position is the same position as in the glTF accessor,\n  // this is already added to the shader with other attributes.\n\n  // World coordinates in ECEF coordinates. Note that this is\n  // low precision (32-bit floats) on the GPU.\n  if (usedVariables.hasOwnProperty(\"positionWC\")) {\n    attributeFields.push([\"vec3\", \"positionWC\"]);\n    initializationLines.push(\n      \"fsInput.attributes.positionWC = attributes.positionWC;\",\n    );\n  }\n\n  // position in eye coordinates\n  if (usedVariables.hasOwnProperty(\"positionEC\")) {\n    attributeFields.push([\"vec3\", \"positionEC\"]);\n    initializationLines.push(\n      \"fsInput.attributes.positionEC = attributes.positionEC;\",\n    );\n  }\n\n  return {\n    attributeFields: attributeFields,\n    initializationLines: initializationLines,\n  };\n}\n\n/**\n * @private\n * @param {CustomShader} customShader\n * @param {Object<string, ModelComponents.Attribute>} attributesByName\n * @returns {object}\n */\nfunction generateFragmentShaderLines(customShader, attributesByName) {\n  if (!defined(customShader.fragmentShaderText)) {\n    return { enabled: false };\n  }\n\n  const primitiveAttributes = customShader.usedVariablesFragment.attributeSet;\n  const addToShader = getPrimitiveAttributesUsedInShader(\n    attributesByName,\n    primitiveAttributes,\n    true,\n  );\n  const needsDefault = getAttributesNeedingDefaults(\n    attributesByName,\n    primitiveAttributes,\n    true,\n  );\n\n  let fragmentInitialization;\n  const attributeFields = [];\n  const initializationLines = [];\n  for (const variableName in addToShader) {\n    if (!addToShader.hasOwnProperty(variableName)) {\n      continue;\n    }\n    const attributeInfo = addToShader[variableName];\n\n    const attributeField = [attributeInfo.glslType, variableName];\n    attributeFields.push(attributeField);\n\n    // Initializing attribute structs are just a matter of copying the\n    // value from the processed attributes\n    // \"    fsInput.attributes.positionMC = attributes.positionMC;\"\n    fragmentInitialization = `fsInput.attributes.${variableName} = attributes.${variableName};`;\n    initializationLines.push(fragmentInitialization);\n  }\n\n  for (let i = 0; i < needsDefault.length; i++) {\n    const variableName = needsDefault[i];\n    const attributeDefaults = inferAttributeDefaults(variableName);\n    if (!defined(attributeDefaults)) {\n      CustomShaderPipelineStage._oneTimeWarning(\n        \"CustomShaderPipelineStage.incompatiblePrimitiveFS\",\n        `Primitive is missing attribute ${variableName}, disabling custom fragment shader.`,\n      );\n\n      // This primitive isn't compatible with the shader. Return early\n      // so the fragment shader is skipped\n      return { enabled: false };\n    }\n\n    attributeFields.push(attributeDefaults.attributeField);\n    fragmentInitialization = `fsInput.attributes.${variableName} = ${attributeDefaults.value};`;\n    initializationLines.push(fragmentInitialization);\n  }\n\n  // Built-ins for positions in various coordinate systems.\n  const positionBuiltins = generatePositionBuiltins(customShader);\n\n  return {\n    enabled: true,\n    attributeFields: attributeFields.concat(positionBuiltins.attributeFields),\n    initializationLines:\n      positionBuiltins.initializationLines.concat(initializationLines),\n  };\n}\n\n// These attributes are derived from positionMC, and are handled separately\n// from other attributes\nconst builtinAttributes = {\n  positionWC: true,\n  positionEC: true,\n};\n\n/**\n * Get the primitive attributes that are referenced in the shader\n *\n * @private\n * @param {Object<string, ModelComponents.Attribute>} primitiveAttributes set of all the primitive's attributes\n * @param {Object<string, ModelComponents.Attribute>} shaderAttributeSet set of all attributes used in the shader\n * @param {boolean} isFragmentShader\n * @returns {Object<string, ModelComponents.Attribute>} A dictionary of the primitive attributes used in the shader\n */\nfunction getPrimitiveAttributesUsedInShader(\n  primitiveAttributes,\n  shaderAttributeSet,\n  isFragmentShader,\n) {\n  const addToShader = {};\n  for (const attributeName in primitiveAttributes) {\n    if (!primitiveAttributes.hasOwnProperty(attributeName)) {\n      continue;\n    }\n    const attribute = primitiveAttributes[attributeName];\n\n    // normals and tangents are in model coordinates in the attributes but\n    // in eye coordinates in the fragment shader.\n    let renamed = attributeName;\n    if (isFragmentShader && attributeName === \"normalMC\") {\n      renamed = \"normalEC\";\n    } else if (isFragmentShader && attributeName === \"tangentMC\") {\n      renamed = \"tangentEC\";\n      attribute.glslType = \"vec3\";\n    }\n\n    if (shaderAttributeSet.hasOwnProperty(renamed)) {\n      addToShader[renamed] = attribute;\n    }\n  }\n  return addToShader;\n}\n\n/**\n * Get the attributes that will need to have default values defined.\n * Attributes referenced in the shader which are not already defined\n * for the primitive and are not built-in will need default values.\n *\n * @private\n * @param {Object<string, ModelComponents.Attribute>} primitiveAttributes set of all the primitive's attributes\n * @param {Object<string, ModelComponents.Attribute>} shaderAttributeSet set of all attributes used in the shader\n * @param {boolean} isFragmentShader\n * @returns {string[]} The names of the attributes needing defaults\n */\nfunction getAttributesNeedingDefaults(\n  primitiveAttributes,\n  shaderAttributeSet,\n  isFragmentShader,\n) {\n  const needDefaults = [];\n  for (const attributeName in shaderAttributeSet) {\n    if (!shaderAttributeSet.hasOwnProperty(attributeName)) {\n      continue;\n    }\n    if (builtinAttributes.hasOwnProperty(attributeName)) {\n      // Builtins are handled separately from attributes, so skip them here\n      continue;\n    }\n\n    // normals and tangents are in model coordinates in the attributes but\n    // in eye coordinates in the fragment shader.\n    let renamed = attributeName;\n    if (isFragmentShader && attributeName === \"normalEC\") {\n      renamed = \"normalMC\";\n    } else if (isFragmentShader && attributeName === \"tangentEC\") {\n      renamed = \"tangentMC\";\n    }\n\n    if (!primitiveAttributes.hasOwnProperty(renamed)) {\n      needDefaults.push(attributeName);\n    }\n  }\n  return needDefaults;\n}\n\n/**\n * @private\n * @param {CustomShader} customShader\n * @param {ModelComponents.Primitive} primitive\n * @returns {object}\n */\nfunction generateShaderLines(customShader, primitive) {\n  // Attempt to generate vertex and fragment shader lines before adding any\n  // code to the shader.\n  const attributesByName = getAttributesByName(primitive.attributes);\n  const vertexLines = generateVertexShaderLines(customShader, attributesByName);\n  const fragmentLines = generateFragmentShaderLines(\n    customShader,\n    attributesByName,\n  );\n\n  // positionWC must be computed in the vertex shader\n  // for use in the fragmentShader. However, this can be skipped if:\n  // - positionWC isn't used in the fragment shader\n  // - or the fragment shader is disabled\n  const attributeSetFS = customShader.usedVariablesFragment.attributeSet;\n  const shouldComputePositionWC =\n    attributeSetFS.hasOwnProperty(\"positionWC\") && fragmentLines.enabled;\n\n  // Return any generated shader code along with some flags to indicate which\n  // defines should be added.\n  return {\n    vertexLines: vertexLines,\n    fragmentLines: fragmentLines,\n    customShaderEnabled: vertexLines.enabled || fragmentLines.enabled,\n    shouldComputePositionWC: shouldComputePositionWC,\n  };\n}\n\nfunction addVertexLinesToShader(shaderBuilder, vertexLines) {\n  let structId = CustomShaderPipelineStage.STRUCT_ID_ATTRIBUTES_VS;\n  shaderBuilder.addStruct(\n    structId,\n    CustomShaderPipelineStage.STRUCT_NAME_ATTRIBUTES,\n    ShaderDestination.VERTEX,\n  );\n\n  const { attributeFields, initializationLines } = vertexLines;\n  for (let i = 0; i < attributeFields.length; i++) {\n    const [glslType, variableName] = attributeFields[i];\n    shaderBuilder.addStructField(structId, glslType, variableName);\n  }\n\n  // This could be hard-coded, but the symmetry with other structs makes unit\n  // tests more convenient\n  structId = CustomShaderPipelineStage.STRUCT_ID_VERTEX_INPUT;\n  shaderBuilder.addStruct(\n    structId,\n    CustomShaderPipelineStage.STRUCT_NAME_VERTEX_INPUT,\n    ShaderDestination.VERTEX,\n  );\n  shaderBuilder.addStructField(\n    structId,\n    CustomShaderPipelineStage.STRUCT_NAME_ATTRIBUTES,\n    \"attributes\",\n  );\n  // Add FeatureIds struct from the Feature ID stage\n  shaderBuilder.addStructField(\n    structId,\n    FeatureIdPipelineStage.STRUCT_NAME_FEATURE_IDS,\n    \"featureIds\",\n  );\n  // Add Metadata struct from the metadata stage\n  shaderBuilder.addStructField(\n    structId,\n    MetadataPipelineStage.STRUCT_NAME_METADATA,\n    \"metadata\",\n  );\n  // Add MetadataClass struct from the metadata stage\n  shaderBuilder.addStructField(\n    structId,\n    MetadataPipelineStage.STRUCT_NAME_METADATA_CLASS,\n    \"metadataClass\",\n  );\n  // Add MetadataStatistics struct from the metadata stage\n  shaderBuilder.addStructField(\n    structId,\n    MetadataPipelineStage.STRUCT_NAME_METADATA_STATISTICS,\n    \"metadataStatistics\",\n  );\n\n  const functionId =\n    CustomShaderPipelineStage.FUNCTION_ID_INITIALIZE_INPUT_STRUCT_VS;\n  shaderBuilder.addFunction(\n    functionId,\n    CustomShaderPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_VS,\n    ShaderDestination.VERTEX,\n  );\n\n  shaderBuilder.addFunctionLines(functionId, initializationLines);\n}\n\nfunction addFragmentLinesToShader(shaderBuilder, fragmentLines) {\n  let structId = CustomShaderPipelineStage.STRUCT_ID_ATTRIBUTES_FS;\n  shaderBuilder.addStruct(\n    structId,\n    CustomShaderPipelineStage.STRUCT_NAME_ATTRIBUTES,\n    ShaderDestination.FRAGMENT,\n  );\n\n  const { attributeFields, initializationLines } = fragmentLines;\n  for (let i = 0; i < attributeFields.length; i++) {\n    const [glslType, variableName] = attributeFields[i];\n    shaderBuilder.addStructField(structId, glslType, variableName);\n  }\n\n  structId = CustomShaderPipelineStage.STRUCT_ID_FRAGMENT_INPUT;\n  shaderBuilder.addStruct(\n    structId,\n    CustomShaderPipelineStage.STRUCT_NAME_FRAGMENT_INPUT,\n    ShaderDestination.FRAGMENT,\n  );\n  shaderBuilder.addStructField(\n    structId,\n    CustomShaderPipelineStage.STRUCT_NAME_ATTRIBUTES,\n    \"attributes\",\n  );\n  // Add FeatureIds struct from the Feature ID stage\n  shaderBuilder.addStructField(\n    structId,\n    FeatureIdPipelineStage.STRUCT_NAME_FEATURE_IDS,\n    \"featureIds\",\n  );\n  // Add Metadata struct from the metadata stage\n  shaderBuilder.addStructField(\n    structId,\n    MetadataPipelineStage.STRUCT_NAME_METADATA,\n    \"metadata\",\n  );\n  // Add MetadataClass struct from the metadata stage\n  shaderBuilder.addStructField(\n    structId,\n    MetadataPipelineStage.STRUCT_NAME_METADATA_CLASS,\n    \"metadataClass\",\n  );\n  // Add MetadataStatistics struct from the metadata stage\n  shaderBuilder.addStructField(\n    structId,\n    MetadataPipelineStage.STRUCT_NAME_METADATA_STATISTICS,\n    \"metadataStatistics\",\n  );\n\n  const functionId =\n    CustomShaderPipelineStage.FUNCTION_ID_INITIALIZE_INPUT_STRUCT_FS;\n  shaderBuilder.addFunction(\n    functionId,\n    CustomShaderPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_FS,\n    ShaderDestination.FRAGMENT,\n  );\n\n  shaderBuilder.addFunctionLines(functionId, initializationLines);\n}\n\nconst scratchShaderLines = [];\n\nfunction addLinesToShader(shaderBuilder, customShader, generatedCode) {\n  const { vertexLines, fragmentLines } = generatedCode;\n  const shaderLines = scratchShaderLines;\n\n  if (vertexLines.enabled) {\n    addVertexLinesToShader(shaderBuilder, vertexLines);\n\n    shaderLines.length = 0;\n    shaderLines.push(\n      \"#line 0\",\n      customShader.vertexShaderText,\n      CustomShaderStageVS,\n    );\n\n    shaderBuilder.addVertexLines(shaderLines);\n  }\n\n  if (fragmentLines.enabled) {\n    addFragmentLinesToShader(shaderBuilder, fragmentLines);\n\n    shaderLines.length = 0;\n    shaderLines.push(\n      \"#line 0\",\n      customShader.fragmentShaderText,\n      CustomShaderStageFS,\n    );\n\n    shaderBuilder.addFragmentLines(shaderLines);\n  }\n}\n\nexport default CustomShaderPipelineStage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}