{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport combine from \"../Core/combine.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport ShadowVolumeAppearanceVS from \"../Shaders/ShadowVolumeAppearanceVS.js\";\nimport ShadowVolumeFS from \"../Shaders/ShadowVolumeFS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowVolumeAppearance from \"./ShadowVolumeAppearance.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\n\n/**\n * A classification primitive represents a volume enclosing geometry in the {@link Scene} to be highlighted.\n * <p>\n * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including\n * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,\n * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix\n * and match most of them and add a new geometry or appearance independently of each other.\n * Only {@link PerInstanceColorAppearance} with the same color across all instances is supported at this time when using\n * ClassificationPrimitive directly.\n * For full {@link Appearance} support when classifying terrain or 3D Tiles use {@link GroundPrimitive} instead.\n * </p>\n * <p>\n * For correct rendering, this feature requires the EXT_frag_depth WebGL extension. For hardware that do not support this extension, there\n * will be rendering artifacts for some viewing angles.\n * </p>\n * <p>\n * Valid geometries are {@link BoxGeometry}, {@link CylinderGeometry}, {@link EllipsoidGeometry}, {@link PolylineVolumeGeometry}, and {@link SphereGeometry}.\n * </p>\n * <p>\n * Geometries that follow the surface of the ellipsoid, such as {@link CircleGeometry}, {@link CorridorGeometry}, {@link EllipseGeometry}, {@link PolygonGeometry}, and {@link RectangleGeometry},\n * are also valid if they are extruded volumes; otherwise, they will not be rendered.\n * </p>\n *\n * @alias ClassificationPrimitive\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Array|GeometryInstance} [options.geometryInstances] The geometry instances to render. This can either be a single instance or an array of length one.\n * @param {Appearance} [options.appearance] The appearance used to render the primitive. Defaults to PerInstanceColorAppearance when GeometryInstances have a color attribute.\n * @param {boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {boolean} [options.vertexCacheOptimize=false] When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n * @param {boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.\n * @param {boolean} [options.compressVertices=true] When <code>true</code>, the geometry vertices are compressed, which will save memory.\n * @param {boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n * @param {boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n * @param {boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.\n * @param {ClassificationType} [options.classificationType=ClassificationType.BOTH] Determines whether terrain, 3D Tiles or both will be classified.\n * @param {boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {boolean} [options.debugShowShadowVolume=false] For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on\n *                  creation for the volumes to be created before the geometry is released or options.releaseGeometryInstance must be <code>false</code>.\n *\n * @see Primitive\n * @see GroundPrimitive\n * @see GeometryInstance\n * @see Appearance\n */\nfunction ClassificationPrimitive(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const geometryInstances = options.geometryInstances;\n\n  /**\n   * The geometry instance rendered with this primitive.  This may\n   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>\n   * is <code>true</code> when the primitive is constructed.\n   * <p>\n   * Changing this property after the primitive is rendered has no effect.\n   * </p>\n   * <p>\n   * Because of the rendering technique used, all geometry instances must be the same color.\n   * If there is an instance with a differing color, a <code>DeveloperError</code> will be thrown\n   * on the first attempt to render.\n   * </p>\n   *\n   * @readonly\n   * @type {Array|GeometryInstance}\n   *\n   * @default undefined\n   */\n  this.geometryInstances = geometryInstances;\n  /**\n   * Determines if the primitive will be shown.  This affects all geometry\n   * instances in the primitive.\n   *\n   * @type {boolean}\n   *\n   * @default true\n   */\n  this.show = options.show ?? true;\n  /**\n   * Determines whether terrain, 3D Tiles or both will be classified.\n   *\n   * @type {ClassificationType}\n   *\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType = options.classificationType ?? ClassificationType.BOTH;\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = options.debugShowBoundingVolume ?? false;\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the shadow volume for each geometry in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowShadowVolume = options.debugShowShadowVolume ?? false;\n  this._debugShowShadowVolume = false;\n\n  // These are used by GroundPrimitive to augment the shader and uniform map.\n  this._extruded = options._extruded ?? false;\n  this._uniformMap = options._uniformMap;\n  this._sp = undefined;\n  this._spStencil = undefined;\n  this._spPick = undefined;\n  this._spColor = undefined;\n  this._spPick2D = undefined; // only derived if necessary\n  this._spColor2D = undefined; // only derived if necessary\n\n  this._rsStencilDepthPass = undefined;\n  this._rsStencilDepthPass3DTiles = undefined;\n  this._rsColorPass = undefined;\n  this._rsPickPass = undefined;\n  this._commandsIgnoreShow = [];\n  this._ready = false;\n  this._primitive = undefined;\n  this._pickPrimitive = options._pickPrimitive;\n\n  // Set in update\n  this._hasSphericalExtentsAttribute = false;\n  this._hasPlanarExtentsAttributes = false;\n  this._hasPerColorAttribute = false;\n  this.appearance = options.appearance;\n  this._createBoundingVolumeFunction = options._createBoundingVolumeFunction;\n  this._updateAndQueueCommandsFunction = options._updateAndQueueCommandsFunction;\n  this._usePickOffsets = false;\n  this._primitiveOptions = {\n    geometryInstances: undefined,\n    appearance: undefined,\n    vertexCacheOptimize: options.vertexCacheOptimize ?? false,\n    interleave: options.interleave ?? false,\n    releaseGeometryInstances: options.releaseGeometryInstances ?? true,\n    allowPicking: options.allowPicking ?? true,\n    asynchronous: options.asynchronous ?? true,\n    compressVertices: options.compressVertices ?? true,\n    _createBoundingVolumeFunction: undefined,\n    _createRenderStatesFunction: undefined,\n    _createShaderProgramFunction: undefined,\n    _createCommandsFunction: undefined,\n    _updateAndQueueCommandsFunction: undefined,\n    _createPickOffsets: true\n  };\n}\nObject.defineProperties(ClassificationPrimitive.prototype, {\n  /**\n   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  vertexCacheOptimize: {\n    get: function () {\n      return this._primitiveOptions.vertexCacheOptimize;\n    }\n  },\n  /**\n   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  interleave: {\n    get: function () {\n      return this._primitiveOptions.interleave;\n    }\n  },\n  /**\n   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  releaseGeometryInstances: {\n    get: function () {\n      return this._primitiveOptions.releaseGeometryInstances;\n    }\n  },\n  /**\n   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._primitiveOptions.allowPicking;\n    }\n  },\n  /**\n   * Determines if the geometry instances will be created and batched on a web worker.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._primitiveOptions.asynchronous;\n    }\n  },\n  /**\n   * When <code>true</code>, geometry vertices are compressed, which will save memory.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  compressVertices: {\n    get: function () {\n      return this._primitiveOptions.compressVertices;\n    }\n  },\n  /**\n   * Determines if the primitive is complete and ready to render.  If this property is\n   * true, the primitive will be rendered the next time that {@link ClassificationPrimitive#update}\n   * is called.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n  /**\n   * Returns true if the ClassificationPrimitive needs a separate shader and commands for 2D.\n   * This is because texture coordinates on ClassificationPrimitives are computed differently,\n   * and are used for culling when multiple GeometryInstances are batched in one ClassificationPrimitive.\n   * @memberof ClassificationPrimitive.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  _needs2DShader: {\n    get: function () {\n      return this._hasPlanarExtentsAttributes || this._hasSphericalExtentsAttribute;\n    }\n  }\n});\n\n/**\n * Determines if ClassificationPrimitive rendering is supported.\n *\n * @param {Scene} scene The scene.\n * @returns {boolean} <code>true</code> if ClassificationPrimitives are supported; otherwise, returns <code>false</code>\n */\nClassificationPrimitive.isSupported = function (scene) {\n  return scene.context.stencilBuffer;\n};\nfunction getStencilDepthRenderState(enableStencil, mask3DTiles) {\n  const stencilFunction = mask3DTiles ? StencilFunction.EQUAL : StencilFunction.ALWAYS;\n  return {\n    colorMask: {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false\n    },\n    stencilTest: {\n      enabled: enableStencil,\n      frontFunction: stencilFunction,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.DECREMENT_WRAP,\n        zPass: StencilOperation.KEEP\n      },\n      backFunction: stencilFunction,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.INCREMENT_WRAP,\n        zPass: StencilOperation.KEEP\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK\n    },\n    stencilMask: StencilConstants.CLASSIFICATION_MASK,\n    depthTest: {\n      enabled: true,\n      func: DepthFunction.LESS_OR_EQUAL\n    },\n    depthMask: false\n  };\n}\nfunction getColorRenderState(enableStencil) {\n  return {\n    stencilTest: {\n      enabled: enableStencil,\n      frontFunction: StencilFunction.NOT_EQUAL,\n      frontOperation: {\n        fail: StencilOperation.ZERO,\n        zFail: StencilOperation.ZERO,\n        zPass: StencilOperation.ZERO\n      },\n      backFunction: StencilFunction.NOT_EQUAL,\n      backOperation: {\n        fail: StencilOperation.ZERO,\n        zFail: StencilOperation.ZERO,\n        zPass: StencilOperation.ZERO\n      },\n      reference: 0,\n      mask: StencilConstants.CLASSIFICATION_MASK\n    },\n    stencilMask: StencilConstants.CLASSIFICATION_MASK,\n    depthTest: {\n      enabled: false\n    },\n    depthMask: false,\n    blending: BlendingState.PRE_MULTIPLIED_ALPHA_BLEND\n  };\n}\nconst pickRenderState = {\n  stencilTest: {\n    enabled: true,\n    frontFunction: StencilFunction.NOT_EQUAL,\n    frontOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO\n    },\n    backFunction: StencilFunction.NOT_EQUAL,\n    backOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO\n    },\n    reference: 0,\n    mask: StencilConstants.CLASSIFICATION_MASK\n  },\n  stencilMask: StencilConstants.CLASSIFICATION_MASK,\n  depthTest: {\n    enabled: false\n  },\n  depthMask: false\n};\nfunction createRenderStates(classificationPrimitive, context, appearance, twoPasses) {\n  if (defined(classificationPrimitive._rsStencilDepthPass)) {\n    return;\n  }\n  const stencilEnabled = !classificationPrimitive.debugShowShadowVolume;\n  classificationPrimitive._rsStencilDepthPass = RenderState.fromCache(getStencilDepthRenderState(stencilEnabled, false));\n  classificationPrimitive._rsStencilDepthPass3DTiles = RenderState.fromCache(getStencilDepthRenderState(stencilEnabled, true));\n  classificationPrimitive._rsColorPass = RenderState.fromCache(getColorRenderState(stencilEnabled, false));\n  classificationPrimitive._rsPickPass = RenderState.fromCache(pickRenderState);\n}\nfunction modifyForEncodedNormals(primitive, vertexShaderSource) {\n  if (!primitive.compressVertices) {\n    return vertexShaderSource;\n  }\n  if (vertexShaderSource.search(/in\\s+vec3\\s+extrudeDirection;/g) !== -1) {\n    const attributeName = \"compressedAttributes\";\n\n    //only shadow volumes use extrudeDirection, and shadow volumes use vertexFormat: POSITION_ONLY so we don't need to check other attributes\n    const attributeDecl = `in vec2 ${attributeName};`;\n    const globalDecl = \"vec3 extrudeDirection;\\n\";\n    const decode = `    extrudeDirection = czm_octDecode(${attributeName}, 65535.0);\\n`;\n    let modifiedVS = vertexShaderSource;\n    modifiedVS = modifiedVS.replace(/in\\s+vec3\\s+extrudeDirection;/g, \"\");\n    modifiedVS = ShaderSource.replaceMain(modifiedVS, \"czm_non_compressed_main\");\n    const compressedMain = `${\"void main() \\n\" + \"{ \\n\"}${decode}    czm_non_compressed_main(); \\n` + `}`;\n    return [attributeDecl, globalDecl, modifiedVS, compressedMain].join(\"\\n\");\n  }\n}\nfunction createShaderProgram(classificationPrimitive, frameState) {\n  const context = frameState.context;\n  const primitive = classificationPrimitive._primitive;\n  let vs = ShadowVolumeAppearanceVS;\n  vs = classificationPrimitive._primitive._batchTable.getVertexShaderCallback()(vs);\n  vs = Primitive._appendDistanceDisplayConditionToShader(primitive, vs);\n  vs = Primitive._modifyShaderPosition(classificationPrimitive, vs, frameState.scene3DOnly);\n  vs = Primitive._updateColorAttribute(primitive, vs);\n  const planarExtents = classificationPrimitive._hasPlanarExtentsAttributes;\n  const cullFragmentsUsingExtents = planarExtents || classificationPrimitive._hasSphericalExtentsAttribute;\n  if (classificationPrimitive._extruded) {\n    vs = modifyForEncodedNormals(primitive, vs);\n  }\n  const extrudedDefine = classificationPrimitive._extruded ? \"EXTRUDED_GEOMETRY\" : \"\";\n  let vsSource = new ShaderSource({\n    defines: [extrudedDefine],\n    sources: [vs]\n  });\n  const fsSource = new ShaderSource({\n    sources: [ShadowVolumeFS]\n  });\n  const attributeLocations = classificationPrimitive._primitive._attributeLocations;\n  const shadowVolumeAppearance = new ShadowVolumeAppearance(cullFragmentsUsingExtents, planarExtents, classificationPrimitive.appearance);\n  classificationPrimitive._spStencil = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: classificationPrimitive._spStencil,\n    vertexShaderSource: vsSource,\n    fragmentShaderSource: fsSource,\n    attributeLocations: attributeLocations\n  });\n  if (classificationPrimitive._primitive.allowPicking) {\n    let vsPick = ShaderSource.createPickVertexShaderSource(vs);\n    vsPick = Primitive._appendShowToShader(primitive, vsPick);\n    vsPick = Primitive._updatePickColorAttribute(vsPick);\n    const pickFS3D = shadowVolumeAppearance.createPickFragmentShader(false);\n    const pickVS3D = shadowVolumeAppearance.createPickVertexShader([extrudedDefine], vsPick, false, frameState.mapProjection);\n    classificationPrimitive._spPick = ShaderProgram.replaceCache({\n      context: context,\n      shaderProgram: classificationPrimitive._spPick,\n      vertexShaderSource: pickVS3D,\n      fragmentShaderSource: pickFS3D,\n      attributeLocations: attributeLocations\n    });\n\n    // Derive a 2D pick shader if the primitive uses texture coordinate-based fragment culling,\n    // since texture coordinates are computed differently in 2D.\n    if (cullFragmentsUsingExtents) {\n      let pickProgram2D = context.shaderCache.getDerivedShaderProgram(classificationPrimitive._spPick, \"2dPick\");\n      if (!defined(pickProgram2D)) {\n        const pickFS2D = shadowVolumeAppearance.createPickFragmentShader(true);\n        const pickVS2D = shadowVolumeAppearance.createPickVertexShader([extrudedDefine], vsPick, true, frameState.mapProjection);\n        pickProgram2D = context.shaderCache.createDerivedShaderProgram(classificationPrimitive._spPick, \"2dPick\", {\n          vertexShaderSource: pickVS2D,\n          fragmentShaderSource: pickFS2D,\n          attributeLocations: attributeLocations\n        });\n      }\n      classificationPrimitive._spPick2D = pickProgram2D;\n    }\n  } else {\n    classificationPrimitive._spPick = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vsSource,\n      fragmentShaderSource: fsSource,\n      attributeLocations: attributeLocations\n    });\n  }\n  vs = Primitive._appendShowToShader(primitive, vs);\n  vsSource = new ShaderSource({\n    defines: [extrudedDefine],\n    sources: [vs]\n  });\n  classificationPrimitive._sp = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: classificationPrimitive._sp,\n    vertexShaderSource: vsSource,\n    fragmentShaderSource: fsSource,\n    attributeLocations: attributeLocations\n  });\n\n  // Create a fragment shader that computes only required material hookups using screen space techniques\n  const fsColorSource = shadowVolumeAppearance.createFragmentShader(false);\n  const vsColorSource = shadowVolumeAppearance.createVertexShader([extrudedDefine], vs, false, frameState.mapProjection);\n  classificationPrimitive._spColor = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: classificationPrimitive._spColor,\n    vertexShaderSource: vsColorSource,\n    fragmentShaderSource: fsColorSource,\n    attributeLocations: attributeLocations\n  });\n\n  // Derive a 2D shader if the primitive uses texture coordinate-based fragment culling,\n  // since texture coordinates are computed differently in 2D.\n  // Any material that uses texture coordinates will also equip texture coordinate-based fragment culling.\n  if (cullFragmentsUsingExtents) {\n    let colorProgram2D = context.shaderCache.getDerivedShaderProgram(classificationPrimitive._spColor, \"2dColor\");\n    if (!defined(colorProgram2D)) {\n      const fsColorSource2D = shadowVolumeAppearance.createFragmentShader(true);\n      const vsColorSource2D = shadowVolumeAppearance.createVertexShader([extrudedDefine], vs, true, frameState.mapProjection);\n      colorProgram2D = context.shaderCache.createDerivedShaderProgram(classificationPrimitive._spColor, \"2dColor\", {\n        vertexShaderSource: vsColorSource2D,\n        fragmentShaderSource: fsColorSource2D,\n        attributeLocations: attributeLocations\n      });\n    }\n    classificationPrimitive._spColor2D = colorProgram2D;\n  }\n}\nfunction createColorCommands(classificationPrimitive, colorCommands) {\n  const primitive = classificationPrimitive._primitive;\n  let length = primitive._va.length * 2; // each geometry (pack of vertex attributes) needs 2 commands: front/back stencils and fill\n  colorCommands.length = length;\n  let i;\n  let command;\n  let derivedCommand;\n  let vaIndex = 0;\n  let uniformMap = primitive._batchTable.getUniformMapCallback()(classificationPrimitive._uniformMap);\n  const needs2DShader = classificationPrimitive._needs2DShader;\n  for (i = 0; i < length; i += 2) {\n    const vertexArray = primitive._va[vaIndex++];\n\n    // Stencil depth command\n    command = colorCommands[i];\n    if (!defined(command)) {\n      command = colorCommands[i] = new DrawCommand({\n        owner: classificationPrimitive,\n        primitiveType: primitive._primitiveType\n      });\n    }\n    command.vertexArray = vertexArray;\n    command.renderState = classificationPrimitive._rsStencilDepthPass;\n    command.shaderProgram = classificationPrimitive._sp;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n    derivedCommand = DrawCommand.shallowClone(command, command.derivedCommands.tileset);\n    derivedCommand.renderState = classificationPrimitive._rsStencilDepthPass3DTiles;\n    derivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedCommand;\n\n    // Color command\n    command = colorCommands[i + 1];\n    if (!defined(command)) {\n      command = colorCommands[i + 1] = new DrawCommand({\n        owner: classificationPrimitive,\n        primitiveType: primitive._primitiveType\n      });\n    }\n    command.vertexArray = vertexArray;\n    command.renderState = classificationPrimitive._rsColorPass;\n    command.shaderProgram = classificationPrimitive._spColor;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n    const appearance = classificationPrimitive.appearance;\n    const material = appearance.material;\n    if (defined(material)) {\n      uniformMap = combine(uniformMap, material._uniforms);\n    }\n    command.uniformMap = uniformMap;\n    derivedCommand = DrawCommand.shallowClone(command, command.derivedCommands.tileset);\n    derivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedCommand;\n\n    // Derive for 2D if texture coordinates are ever computed\n    if (needs2DShader) {\n      // First derive from the terrain command\n      let derived2DCommand = DrawCommand.shallowClone(command, command.derivedCommands.appearance2D);\n      derived2DCommand.shaderProgram = classificationPrimitive._spColor2D;\n      command.derivedCommands.appearance2D = derived2DCommand;\n\n      // Then derive from the 3D Tiles command\n      derived2DCommand = DrawCommand.shallowClone(derivedCommand, derivedCommand.derivedCommands.appearance2D);\n      derived2DCommand.shaderProgram = classificationPrimitive._spColor2D;\n      derivedCommand.derivedCommands.appearance2D = derived2DCommand;\n    }\n  }\n  const commandsIgnoreShow = classificationPrimitive._commandsIgnoreShow;\n  const spStencil = classificationPrimitive._spStencil;\n  let commandIndex = 0;\n  length = commandsIgnoreShow.length = length / 2;\n  for (let j = 0; j < length; ++j) {\n    const commandIgnoreShow = commandsIgnoreShow[j] = DrawCommand.shallowClone(colorCommands[commandIndex], commandsIgnoreShow[j]);\n    commandIgnoreShow.shaderProgram = spStencil;\n    commandIgnoreShow.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW;\n    commandIndex += 2;\n  }\n}\nfunction createPickCommands(classificationPrimitive, pickCommands) {\n  const usePickOffsets = classificationPrimitive._usePickOffsets;\n  const primitive = classificationPrimitive._primitive;\n  let length = primitive._va.length * 2; // each geometry (pack of vertex attributes) needs 2 commands: front/back stencils and fill\n\n  // Fallback for batching same-color geometry instances\n  let pickOffsets;\n  let pickIndex = 0;\n  let pickOffset;\n  if (usePickOffsets) {\n    pickOffsets = primitive._pickOffsets;\n    length = pickOffsets.length * 2;\n  }\n  pickCommands.length = length;\n  let j;\n  let command;\n  let derivedCommand;\n  let vaIndex = 0;\n  const uniformMap = primitive._batchTable.getUniformMapCallback()(classificationPrimitive._uniformMap);\n  const needs2DShader = classificationPrimitive._needs2DShader;\n  for (j = 0; j < length; j += 2) {\n    let vertexArray = primitive._va[vaIndex++];\n    if (usePickOffsets) {\n      pickOffset = pickOffsets[pickIndex++];\n      vertexArray = primitive._va[pickOffset.index];\n    }\n\n    // Stencil depth command\n    command = pickCommands[j];\n    if (!defined(command)) {\n      command = pickCommands[j] = new DrawCommand({\n        owner: classificationPrimitive,\n        primitiveType: primitive._primitiveType,\n        pickOnly: true\n      });\n    }\n    command.vertexArray = vertexArray;\n    command.renderState = classificationPrimitive._rsStencilDepthPass;\n    command.shaderProgram = classificationPrimitive._sp;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n    if (usePickOffsets) {\n      command.offset = pickOffset.offset;\n      command.count = pickOffset.count;\n    }\n\n    // Derive for 3D Tiles classification\n    derivedCommand = DrawCommand.shallowClone(command, command.derivedCommands.tileset);\n    derivedCommand.renderState = classificationPrimitive._rsStencilDepthPass3DTiles;\n    derivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedCommand;\n\n    // Pick color command\n    command = pickCommands[j + 1];\n    if (!defined(command)) {\n      command = pickCommands[j + 1] = new DrawCommand({\n        owner: classificationPrimitive,\n        primitiveType: primitive._primitiveType,\n        pickOnly: true\n      });\n    }\n    command.vertexArray = vertexArray;\n    command.renderState = classificationPrimitive._rsPickPass;\n    command.shaderProgram = classificationPrimitive._spPick;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n    if (usePickOffsets) {\n      command.offset = pickOffset.offset;\n      command.count = pickOffset.count;\n    }\n    derivedCommand = DrawCommand.shallowClone(command, command.derivedCommands.tileset);\n    derivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedCommand;\n\n    // Derive for 2D if texture coordinates are ever computed\n    if (needs2DShader) {\n      // First derive from the terrain command\n      let derived2DCommand = DrawCommand.shallowClone(command, command.derivedCommands.pick2D);\n      derived2DCommand.shaderProgram = classificationPrimitive._spPick2D;\n      command.derivedCommands.pick2D = derived2DCommand;\n\n      // Then derive from the 3D Tiles command\n      derived2DCommand = DrawCommand.shallowClone(derivedCommand, derivedCommand.derivedCommands.pick2D);\n      derived2DCommand.shaderProgram = classificationPrimitive._spPick2D;\n      derivedCommand.derivedCommands.pick2D = derived2DCommand;\n    }\n  }\n}\nfunction createCommands(classificationPrimitive, appearance, material, translucent, twoPasses, colorCommands, pickCommands) {\n  createColorCommands(classificationPrimitive, colorCommands);\n  createPickCommands(classificationPrimitive, pickCommands);\n}\nfunction boundingVolumeIndex(commandIndex, length) {\n  return Math.floor(commandIndex % length / 2);\n}\nfunction updateAndQueueRenderCommand(command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume) {\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n  command.debugShowBoundingVolume = debugShowBoundingVolume;\n  frameState.commandList.push(command);\n}\nfunction updateAndQueuePickCommand(command, frameState, modelMatrix, cull, boundingVolume) {\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n  frameState.commandList.push(command);\n}\nfunction updateAndQueueCommands(classificationPrimitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {\n  const primitive = classificationPrimitive._primitive;\n  Primitive._updateBoundingVolumes(primitive, frameState, modelMatrix);\n  let boundingVolumes;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingVolumes = primitive._boundingSphereWC;\n  } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n    boundingVolumes = primitive._boundingSphereCV;\n  } else if (frameState.mode === SceneMode.SCENE2D && defined(primitive._boundingSphere2D)) {\n    boundingVolumes = primitive._boundingSphere2D;\n  } else if (defined(primitive._boundingSphereMorph)) {\n    boundingVolumes = primitive._boundingSphereMorph;\n  }\n  const classificationType = classificationPrimitive.classificationType;\n  const queueTerrainCommands = classificationType !== ClassificationType.CESIUM_3D_TILE;\n  const queue3DTilesCommands = classificationType !== ClassificationType.TERRAIN;\n  const passes = frameState.passes;\n  let i;\n  let boundingVolume;\n  let command;\n  if (passes.render) {\n    const colorLength = colorCommands.length;\n    for (i = 0; i < colorLength; ++i) {\n      boundingVolume = boundingVolumes[boundingVolumeIndex(i, colorLength)];\n      if (queueTerrainCommands) {\n        command = colorCommands[i];\n        updateAndQueueRenderCommand(command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume);\n      }\n      if (queue3DTilesCommands) {\n        command = colorCommands[i].derivedCommands.tileset;\n        updateAndQueueRenderCommand(command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume);\n      }\n    }\n    if (frameState.invertClassification) {\n      const ignoreShowCommands = classificationPrimitive._commandsIgnoreShow;\n      const ignoreShowCommandsLength = ignoreShowCommands.length;\n      for (i = 0; i < ignoreShowCommandsLength; ++i) {\n        boundingVolume = boundingVolumes[i];\n        command = ignoreShowCommands[i];\n        updateAndQueueRenderCommand(command, frameState, modelMatrix, cull, boundingVolume, debugShowBoundingVolume);\n      }\n    }\n  }\n  if (passes.pick) {\n    const pickLength = pickCommands.length;\n    const pickOffsets = primitive._pickOffsets;\n    for (i = 0; i < pickLength; ++i) {\n      const pickOffset = pickOffsets[boundingVolumeIndex(i, pickLength)];\n      boundingVolume = boundingVolumes[pickOffset.index];\n      if (queueTerrainCommands) {\n        command = pickCommands[i];\n        updateAndQueuePickCommand(command, frameState, modelMatrix, cull, boundingVolume);\n      }\n      if (queue3DTilesCommands) {\n        command = pickCommands[i].derivedCommands.tileset;\n        updateAndQueuePickCommand(command, frameState, modelMatrix, cull, boundingVolume);\n      }\n    }\n  }\n}\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n * @exception {DeveloperError} Appearance and material have a uniform with the same name.\n * @exception {DeveloperError} Not all of the geometry instances have the same color attribute.\n */\nClassificationPrimitive.prototype.update = function (frameState) {\n  if (!defined(this._primitive) && !defined(this.geometryInstances)) {\n    return;\n  }\n  let appearance = this.appearance;\n  if (defined(appearance) && defined(appearance.material)) {\n    appearance.material.update(frameState.context);\n  }\n  const that = this;\n  const primitiveOptions = this._primitiveOptions;\n  if (!defined(this._primitive)) {\n    const instances = Array.isArray(this.geometryInstances) ? this.geometryInstances : [this.geometryInstances];\n    const length = instances.length;\n    let i;\n    let instance;\n    let attributes;\n    let hasPerColorAttribute = false;\n    let allColorsSame = true;\n    let firstColor;\n    let hasSphericalExtentsAttribute = false;\n    let hasPlanarExtentsAttributes = false;\n    if (length > 0) {\n      attributes = instances[0].attributes;\n      // Not expecting these to be set by users, should only be set via GroundPrimitive.\n      // So don't check for mismatch.\n      hasSphericalExtentsAttribute = ShadowVolumeAppearance.hasAttributesForSphericalExtents(attributes);\n      hasPlanarExtentsAttributes = ShadowVolumeAppearance.hasAttributesForTextureCoordinatePlanes(attributes);\n      firstColor = attributes.color;\n    }\n    for (i = 0; i < length; i++) {\n      instance = instances[i];\n      const color = instance.attributes.color;\n      if (defined(color)) {\n        hasPerColorAttribute = true;\n      }\n      //>>includeStart('debug', pragmas.debug);\n      else if (hasPerColorAttribute) {\n        throw new DeveloperError(\"All GeometryInstances must have color attributes to use per-instance color.\");\n      }\n      //>>includeEnd('debug');\n\n      allColorsSame = allColorsSame && defined(color) && ColorGeometryInstanceAttribute.equals(firstColor, color);\n    }\n\n    // If no attributes exist for computing spherical extents or fragment culling,\n    // throw if the colors aren't all the same.\n    if (!allColorsSame && !hasSphericalExtentsAttribute && !hasPlanarExtentsAttributes) {\n      throw new DeveloperError(\"All GeometryInstances must have the same color attribute except via GroundPrimitives\");\n    }\n\n    // default to a color appearance\n    if (hasPerColorAttribute && !defined(appearance)) {\n      appearance = new PerInstanceColorAppearance({\n        flat: true\n      });\n      this.appearance = appearance;\n    }\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!hasPerColorAttribute && appearance instanceof PerInstanceColorAppearance) {\n      throw new DeveloperError(\"PerInstanceColorAppearance requires color GeometryInstanceAttributes on all GeometryInstances\");\n    }\n    if (defined(appearance.material) && !hasSphericalExtentsAttribute && !hasPlanarExtentsAttributes) {\n      throw new DeveloperError(\"Materials on ClassificationPrimitives are not supported except via GroundPrimitives\");\n    }\n    //>>includeEnd('debug');\n\n    this._usePickOffsets = !hasSphericalExtentsAttribute && !hasPlanarExtentsAttributes;\n    this._hasSphericalExtentsAttribute = hasSphericalExtentsAttribute;\n    this._hasPlanarExtentsAttributes = hasPlanarExtentsAttributes;\n    this._hasPerColorAttribute = hasPerColorAttribute;\n    const geometryInstances = new Array(length);\n    for (i = 0; i < length; ++i) {\n      instance = instances[i];\n      geometryInstances[i] = new GeometryInstance({\n        geometry: instance.geometry,\n        attributes: instance.attributes,\n        modelMatrix: instance.modelMatrix,\n        id: instance.id,\n        pickPrimitive: this._pickPrimitive ?? that\n      });\n    }\n    primitiveOptions.appearance = appearance;\n    primitiveOptions.geometryInstances = geometryInstances;\n    if (defined(this._createBoundingVolumeFunction)) {\n      primitiveOptions._createBoundingVolumeFunction = function (frameState, geometry) {\n        that._createBoundingVolumeFunction(frameState, geometry);\n      };\n    }\n    primitiveOptions._createRenderStatesFunction = function (primitive, context, appearance, twoPasses) {\n      createRenderStates(that, context);\n    };\n    primitiveOptions._createShaderProgramFunction = function (primitive, frameState, appearance) {\n      createShaderProgram(that, frameState);\n    };\n    primitiveOptions._createCommandsFunction = function (primitive, appearance, material, translucent, twoPasses, colorCommands, pickCommands) {\n      createCommands(that, undefined, undefined, true, false, colorCommands, pickCommands);\n    };\n    if (defined(this._updateAndQueueCommandsFunction)) {\n      primitiveOptions._updateAndQueueCommandsFunction = function (primitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {\n        that._updateAndQueueCommandsFunction(primitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses);\n      };\n    } else {\n      primitiveOptions._updateAndQueueCommandsFunction = function (primitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {\n        updateAndQueueCommands(that, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses);\n      };\n    }\n    this._primitive = new Primitive(primitiveOptions);\n  }\n  if (this.debugShowShadowVolume && !this._debugShowShadowVolume && this._ready) {\n    this._debugShowShadowVolume = true;\n    this._rsStencilDepthPass = RenderState.fromCache(getStencilDepthRenderState(false, false));\n    this._rsStencilDepthPass3DTiles = RenderState.fromCache(getStencilDepthRenderState(false, true));\n    this._rsColorPass = RenderState.fromCache(getColorRenderState(false));\n  } else if (!this.debugShowShadowVolume && this._debugShowShadowVolume) {\n    this._debugShowShadowVolume = false;\n    this._rsStencilDepthPass = RenderState.fromCache(getStencilDepthRenderState(true, false));\n    this._rsStencilDepthPass3DTiles = RenderState.fromCache(getStencilDepthRenderState(true, true));\n    this._rsColorPass = RenderState.fromCache(getColorRenderState(true));\n  }\n  // Update primitive appearance\n  if (this._primitive.appearance !== appearance) {\n    //>>includeStart('debug', pragmas.debug);\n    // Check if the appearance is supported by the geometry attributes\n    if (!this._hasSphericalExtentsAttribute && !this._hasPlanarExtentsAttributes && defined(appearance.material)) {\n      throw new DeveloperError(\"Materials on ClassificationPrimitives are not supported except via GroundPrimitive\");\n    }\n    if (!this._hasPerColorAttribute && appearance instanceof PerInstanceColorAppearance) {\n      throw new DeveloperError(\"PerInstanceColorAppearance requires color GeometryInstanceAttribute\");\n    }\n    //>>includeEnd('debug');\n    this._primitive.appearance = appearance;\n  }\n  this._primitive.show = this.show;\n  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;\n  this._primitive.update(frameState);\n  frameState.afterRender.push(() => {\n    if (defined(this._primitive) && this._primitive.ready) {\n      this._ready = true;\n      if (this.releaseGeometryInstances) {\n        this.geometryInstances = undefined;\n      }\n    }\n  });\n};\n\n/**\n * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.\n *\n * @param {*} id The id of the {@link GeometryInstance}.\n * @returns {object} The typed array in the attribute's format or undefined if the is no instance with id.\n *\n * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.\n *\n * @example\n * const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n */\nClassificationPrimitive.prototype.getGeometryInstanceAttributes = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(this._primitive)) {\n    throw new DeveloperError(\"must call update before calling getGeometryInstanceAttributes\");\n  }\n  //>>includeEnd('debug');\n  return this._primitive.getGeometryInstanceAttributes(id);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ClassificationPrimitive#destroy\n */\nClassificationPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * e = e && e.destroy();\n *\n * @see ClassificationPrimitive#isDestroyed\n */\nClassificationPrimitive.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  this._sp = this._sp && this._sp.destroy();\n  this._spPick = this._spPick && this._spPick.destroy();\n  this._spColor = this._spColor && this._spColor.destroy();\n\n  // Derived programs, destroyed above if they existed.\n  this._spPick2D = undefined;\n  this._spColor2D = undefined;\n  return destroyObject(this);\n};\nexport default ClassificationPrimitive;","map":{"version":3,"names":["ColorGeometryInstanceAttribute","combine","Frozen","defined","destroyObject","DeveloperError","GeometryInstance","DrawCommand","Pass","RenderState","ShaderProgram","ShaderSource","ShadowVolumeAppearanceVS","ShadowVolumeFS","BlendingState","ClassificationType","DepthFunction","PerInstanceColorAppearance","Primitive","SceneMode","ShadowVolumeAppearance","StencilConstants","StencilFunction","StencilOperation","ClassificationPrimitive","options","EMPTY_OBJECT","geometryInstances","show","classificationType","BOTH","debugShowBoundingVolume","debugShowShadowVolume","_debugShowShadowVolume","_extruded","_uniformMap","_sp","undefined","_spStencil","_spPick","_spColor","_spPick2D","_spColor2D","_rsStencilDepthPass","_rsStencilDepthPass3DTiles","_rsColorPass","_rsPickPass","_commandsIgnoreShow","_ready","_primitive","_pickPrimitive","_hasSphericalExtentsAttribute","_hasPlanarExtentsAttributes","_hasPerColorAttribute","appearance","_createBoundingVolumeFunction","_updateAndQueueCommandsFunction","_usePickOffsets","_primitiveOptions","vertexCacheOptimize","interleave","releaseGeometryInstances","allowPicking","asynchronous","compressVertices","_createRenderStatesFunction","_createShaderProgramFunction","_createCommandsFunction","_createPickOffsets","Object","defineProperties","prototype","get","ready","_needs2DShader","isSupported","scene","context","stencilBuffer","getStencilDepthRenderState","enableStencil","mask3DTiles","stencilFunction","EQUAL","ALWAYS","colorMask","red","green","blue","alpha","stencilTest","enabled","frontFunction","frontOperation","fail","KEEP","zFail","DECREMENT_WRAP","zPass","backFunction","backOperation","INCREMENT_WRAP","reference","CESIUM_3D_TILE_MASK","mask","stencilMask","CLASSIFICATION_MASK","depthTest","func","LESS_OR_EQUAL","depthMask","getColorRenderState","NOT_EQUAL","ZERO","blending","PRE_MULTIPLIED_ALPHA_BLEND","pickRenderState","createRenderStates","classificationPrimitive","twoPasses","stencilEnabled","fromCache","modifyForEncodedNormals","primitive","vertexShaderSource","search","attributeName","attributeDecl","globalDecl","decode","modifiedVS","replace","replaceMain","compressedMain","join","createShaderProgram","frameState","vs","_batchTable","getVertexShaderCallback","_appendDistanceDisplayConditionToShader","_modifyShaderPosition","scene3DOnly","_updateColorAttribute","planarExtents","cullFragmentsUsingExtents","extrudedDefine","vsSource","defines","sources","fsSource","attributeLocations","_attributeLocations","shadowVolumeAppearance","replaceCache","shaderProgram","fragmentShaderSource","vsPick","createPickVertexShaderSource","_appendShowToShader","_updatePickColorAttribute","pickFS3D","createPickFragmentShader","pickVS3D","createPickVertexShader","mapProjection","pickProgram2D","shaderCache","getDerivedShaderProgram","pickFS2D","pickVS2D","createDerivedShaderProgram","fsColorSource","createFragmentShader","vsColorSource","createVertexShader","colorProgram2D","fsColorSource2D","vsColorSource2D","createColorCommands","colorCommands","length","_va","i","command","derivedCommand","vaIndex","uniformMap","getUniformMapCallback","needs2DShader","vertexArray","owner","primitiveType","_primitiveType","renderState","pass","TERRAIN_CLASSIFICATION","shallowClone","derivedCommands","tileset","CESIUM_3D_TILE_CLASSIFICATION","material","_uniforms","derived2DCommand","appearance2D","commandsIgnoreShow","spStencil","commandIndex","j","commandIgnoreShow","CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW","createPickCommands","pickCommands","usePickOffsets","pickOffsets","pickIndex","pickOffset","_pickOffsets","index","pickOnly","offset","count","pick2D","createCommands","translucent","boundingVolumeIndex","Math","floor","updateAndQueueRenderCommand","modelMatrix","cull","boundingVolume","commandList","push","updateAndQueuePickCommand","updateAndQueueCommands","_updateBoundingVolumes","boundingVolumes","mode","SCENE3D","_boundingSphereWC","COLUMBUS_VIEW","_boundingSphereCV","SCENE2D","_boundingSphere2D","_boundingSphereMorph","queueTerrainCommands","CESIUM_3D_TILE","queue3DTilesCommands","TERRAIN","passes","render","colorLength","invertClassification","ignoreShowCommands","ignoreShowCommandsLength","pick","pickLength","update","that","primitiveOptions","instances","Array","isArray","instance","attributes","hasPerColorAttribute","allColorsSame","firstColor","hasSphericalExtentsAttribute","hasPlanarExtentsAttributes","hasAttributesForSphericalExtents","hasAttributesForTextureCoordinatePlanes","color","equals","flat","geometry","id","pickPrimitive","afterRender","getGeometryInstanceAttributes","isDestroyed","destroy"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/ClassificationPrimitive.js"],"sourcesContent":["import ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport combine from \"../Core/combine.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport ShadowVolumeAppearanceVS from \"../Shaders/ShadowVolumeAppearanceVS.js\";\nimport ShadowVolumeFS from \"../Shaders/ShadowVolumeFS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowVolumeAppearance from \"./ShadowVolumeAppearance.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\n\n/**\n * A classification primitive represents a volume enclosing geometry in the {@link Scene} to be highlighted.\n * <p>\n * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including\n * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,\n * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix\n * and match most of them and add a new geometry or appearance independently of each other.\n * Only {@link PerInstanceColorAppearance} with the same color across all instances is supported at this time when using\n * ClassificationPrimitive directly.\n * For full {@link Appearance} support when classifying terrain or 3D Tiles use {@link GroundPrimitive} instead.\n * </p>\n * <p>\n * For correct rendering, this feature requires the EXT_frag_depth WebGL extension. For hardware that do not support this extension, there\n * will be rendering artifacts for some viewing angles.\n * </p>\n * <p>\n * Valid geometries are {@link BoxGeometry}, {@link CylinderGeometry}, {@link EllipsoidGeometry}, {@link PolylineVolumeGeometry}, and {@link SphereGeometry}.\n * </p>\n * <p>\n * Geometries that follow the surface of the ellipsoid, such as {@link CircleGeometry}, {@link CorridorGeometry}, {@link EllipseGeometry}, {@link PolygonGeometry}, and {@link RectangleGeometry},\n * are also valid if they are extruded volumes; otherwise, they will not be rendered.\n * </p>\n *\n * @alias ClassificationPrimitive\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Array|GeometryInstance} [options.geometryInstances] The geometry instances to render. This can either be a single instance or an array of length one.\n * @param {Appearance} [options.appearance] The appearance used to render the primitive. Defaults to PerInstanceColorAppearance when GeometryInstances have a color attribute.\n * @param {boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {boolean} [options.vertexCacheOptimize=false] When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n * @param {boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.\n * @param {boolean} [options.compressVertices=true] When <code>true</code>, the geometry vertices are compressed, which will save memory.\n * @param {boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n * @param {boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n * @param {boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.\n * @param {ClassificationType} [options.classificationType=ClassificationType.BOTH] Determines whether terrain, 3D Tiles or both will be classified.\n * @param {boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {boolean} [options.debugShowShadowVolume=false] For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on\n *                  creation for the volumes to be created before the geometry is released or options.releaseGeometryInstance must be <code>false</code>.\n *\n * @see Primitive\n * @see GroundPrimitive\n * @see GeometryInstance\n * @see Appearance\n */\nfunction ClassificationPrimitive(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const geometryInstances = options.geometryInstances;\n\n  /**\n   * The geometry instance rendered with this primitive.  This may\n   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>\n   * is <code>true</code> when the primitive is constructed.\n   * <p>\n   * Changing this property after the primitive is rendered has no effect.\n   * </p>\n   * <p>\n   * Because of the rendering technique used, all geometry instances must be the same color.\n   * If there is an instance with a differing color, a <code>DeveloperError</code> will be thrown\n   * on the first attempt to render.\n   * </p>\n   *\n   * @readonly\n   * @type {Array|GeometryInstance}\n   *\n   * @default undefined\n   */\n  this.geometryInstances = geometryInstances;\n  /**\n   * Determines if the primitive will be shown.  This affects all geometry\n   * instances in the primitive.\n   *\n   * @type {boolean}\n   *\n   * @default true\n   */\n  this.show = options.show ?? true;\n  /**\n   * Determines whether terrain, 3D Tiles or both will be classified.\n   *\n   * @type {ClassificationType}\n   *\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType =\n    options.classificationType ?? ClassificationType.BOTH;\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = options.debugShowBoundingVolume ?? false;\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the shadow volume for each geometry in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowShadowVolume = options.debugShowShadowVolume ?? false;\n  this._debugShowShadowVolume = false;\n\n  // These are used by GroundPrimitive to augment the shader and uniform map.\n  this._extruded = options._extruded ?? false;\n  this._uniformMap = options._uniformMap;\n\n  this._sp = undefined;\n  this._spStencil = undefined;\n  this._spPick = undefined;\n  this._spColor = undefined;\n\n  this._spPick2D = undefined; // only derived if necessary\n  this._spColor2D = undefined; // only derived if necessary\n\n  this._rsStencilDepthPass = undefined;\n  this._rsStencilDepthPass3DTiles = undefined;\n  this._rsColorPass = undefined;\n  this._rsPickPass = undefined;\n\n  this._commandsIgnoreShow = [];\n\n  this._ready = false;\n  this._primitive = undefined;\n  this._pickPrimitive = options._pickPrimitive;\n\n  // Set in update\n  this._hasSphericalExtentsAttribute = false;\n  this._hasPlanarExtentsAttributes = false;\n  this._hasPerColorAttribute = false;\n\n  this.appearance = options.appearance;\n\n  this._createBoundingVolumeFunction = options._createBoundingVolumeFunction;\n  this._updateAndQueueCommandsFunction =\n    options._updateAndQueueCommandsFunction;\n\n  this._usePickOffsets = false;\n\n  this._primitiveOptions = {\n    geometryInstances: undefined,\n    appearance: undefined,\n    vertexCacheOptimize: options.vertexCacheOptimize ?? false,\n    interleave: options.interleave ?? false,\n    releaseGeometryInstances: options.releaseGeometryInstances ?? true,\n    allowPicking: options.allowPicking ?? true,\n    asynchronous: options.asynchronous ?? true,\n    compressVertices: options.compressVertices ?? true,\n    _createBoundingVolumeFunction: undefined,\n    _createRenderStatesFunction: undefined,\n    _createShaderProgramFunction: undefined,\n    _createCommandsFunction: undefined,\n    _updateAndQueueCommandsFunction: undefined,\n    _createPickOffsets: true,\n  };\n}\n\nObject.defineProperties(ClassificationPrimitive.prototype, {\n  /**\n   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  vertexCacheOptimize: {\n    get: function () {\n      return this._primitiveOptions.vertexCacheOptimize;\n    },\n  },\n\n  /**\n   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  interleave: {\n    get: function () {\n      return this._primitiveOptions.interleave;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  releaseGeometryInstances: {\n    get: function () {\n      return this._primitiveOptions.releaseGeometryInstances;\n    },\n  },\n\n  /**\n   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._primitiveOptions.allowPicking;\n    },\n  },\n\n  /**\n   * Determines if the geometry instances will be created and batched on a web worker.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._primitiveOptions.asynchronous;\n    },\n  },\n\n  /**\n   * When <code>true</code>, geometry vertices are compressed, which will save memory.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  compressVertices: {\n    get: function () {\n      return this._primitiveOptions.compressVertices;\n    },\n  },\n\n  /**\n   * Determines if the primitive is complete and ready to render.  If this property is\n   * true, the primitive will be rendered the next time that {@link ClassificationPrimitive#update}\n   * is called.\n   *\n   * @memberof ClassificationPrimitive.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Returns true if the ClassificationPrimitive needs a separate shader and commands for 2D.\n   * This is because texture coordinates on ClassificationPrimitives are computed differently,\n   * and are used for culling when multiple GeometryInstances are batched in one ClassificationPrimitive.\n   * @memberof ClassificationPrimitive.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  _needs2DShader: {\n    get: function () {\n      return (\n        this._hasPlanarExtentsAttributes || this._hasSphericalExtentsAttribute\n      );\n    },\n  },\n});\n\n/**\n * Determines if ClassificationPrimitive rendering is supported.\n *\n * @param {Scene} scene The scene.\n * @returns {boolean} <code>true</code> if ClassificationPrimitives are supported; otherwise, returns <code>false</code>\n */\nClassificationPrimitive.isSupported = function (scene) {\n  return scene.context.stencilBuffer;\n};\n\nfunction getStencilDepthRenderState(enableStencil, mask3DTiles) {\n  const stencilFunction = mask3DTiles\n    ? StencilFunction.EQUAL\n    : StencilFunction.ALWAYS;\n  return {\n    colorMask: {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false,\n    },\n    stencilTest: {\n      enabled: enableStencil,\n      frontFunction: stencilFunction,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.DECREMENT_WRAP,\n        zPass: StencilOperation.KEEP,\n      },\n      backFunction: stencilFunction,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.INCREMENT_WRAP,\n        zPass: StencilOperation.KEEP,\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK,\n    },\n    stencilMask: StencilConstants.CLASSIFICATION_MASK,\n    depthTest: {\n      enabled: true,\n      func: DepthFunction.LESS_OR_EQUAL,\n    },\n    depthMask: false,\n  };\n}\n\nfunction getColorRenderState(enableStencil) {\n  return {\n    stencilTest: {\n      enabled: enableStencil,\n      frontFunction: StencilFunction.NOT_EQUAL,\n      frontOperation: {\n        fail: StencilOperation.ZERO,\n        zFail: StencilOperation.ZERO,\n        zPass: StencilOperation.ZERO,\n      },\n      backFunction: StencilFunction.NOT_EQUAL,\n      backOperation: {\n        fail: StencilOperation.ZERO,\n        zFail: StencilOperation.ZERO,\n        zPass: StencilOperation.ZERO,\n      },\n      reference: 0,\n      mask: StencilConstants.CLASSIFICATION_MASK,\n    },\n    stencilMask: StencilConstants.CLASSIFICATION_MASK,\n    depthTest: {\n      enabled: false,\n    },\n    depthMask: false,\n    blending: BlendingState.PRE_MULTIPLIED_ALPHA_BLEND,\n  };\n}\n\nconst pickRenderState = {\n  stencilTest: {\n    enabled: true,\n    frontFunction: StencilFunction.NOT_EQUAL,\n    frontOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO,\n    },\n    backFunction: StencilFunction.NOT_EQUAL,\n    backOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO,\n    },\n    reference: 0,\n    mask: StencilConstants.CLASSIFICATION_MASK,\n  },\n  stencilMask: StencilConstants.CLASSIFICATION_MASK,\n  depthTest: {\n    enabled: false,\n  },\n  depthMask: false,\n};\n\nfunction createRenderStates(\n  classificationPrimitive,\n  context,\n  appearance,\n  twoPasses,\n) {\n  if (defined(classificationPrimitive._rsStencilDepthPass)) {\n    return;\n  }\n  const stencilEnabled = !classificationPrimitive.debugShowShadowVolume;\n\n  classificationPrimitive._rsStencilDepthPass = RenderState.fromCache(\n    getStencilDepthRenderState(stencilEnabled, false),\n  );\n  classificationPrimitive._rsStencilDepthPass3DTiles = RenderState.fromCache(\n    getStencilDepthRenderState(stencilEnabled, true),\n  );\n  classificationPrimitive._rsColorPass = RenderState.fromCache(\n    getColorRenderState(stencilEnabled, false),\n  );\n  classificationPrimitive._rsPickPass = RenderState.fromCache(pickRenderState);\n}\n\nfunction modifyForEncodedNormals(primitive, vertexShaderSource) {\n  if (!primitive.compressVertices) {\n    return vertexShaderSource;\n  }\n\n  if (vertexShaderSource.search(/in\\s+vec3\\s+extrudeDirection;/g) !== -1) {\n    const attributeName = \"compressedAttributes\";\n\n    //only shadow volumes use extrudeDirection, and shadow volumes use vertexFormat: POSITION_ONLY so we don't need to check other attributes\n    const attributeDecl = `in vec2 ${attributeName};`;\n\n    const globalDecl = \"vec3 extrudeDirection;\\n\";\n    const decode = `    extrudeDirection = czm_octDecode(${attributeName}, 65535.0);\\n`;\n\n    let modifiedVS = vertexShaderSource;\n    modifiedVS = modifiedVS.replace(/in\\s+vec3\\s+extrudeDirection;/g, \"\");\n    modifiedVS = ShaderSource.replaceMain(\n      modifiedVS,\n      \"czm_non_compressed_main\",\n    );\n    const compressedMain =\n      `${\"void main() \\n\" + \"{ \\n\"}${decode}    czm_non_compressed_main(); \\n` +\n      `}`;\n\n    return [attributeDecl, globalDecl, modifiedVS, compressedMain].join(\"\\n\");\n  }\n}\n\nfunction createShaderProgram(classificationPrimitive, frameState) {\n  const context = frameState.context;\n  const primitive = classificationPrimitive._primitive;\n  let vs = ShadowVolumeAppearanceVS;\n  vs =\n    classificationPrimitive._primitive._batchTable.getVertexShaderCallback()(\n      vs,\n    );\n  vs = Primitive._appendDistanceDisplayConditionToShader(primitive, vs);\n  vs = Primitive._modifyShaderPosition(\n    classificationPrimitive,\n    vs,\n    frameState.scene3DOnly,\n  );\n  vs = Primitive._updateColorAttribute(primitive, vs);\n\n  const planarExtents = classificationPrimitive._hasPlanarExtentsAttributes;\n  const cullFragmentsUsingExtents =\n    planarExtents || classificationPrimitive._hasSphericalExtentsAttribute;\n\n  if (classificationPrimitive._extruded) {\n    vs = modifyForEncodedNormals(primitive, vs);\n  }\n\n  const extrudedDefine = classificationPrimitive._extruded\n    ? \"EXTRUDED_GEOMETRY\"\n    : \"\";\n\n  let vsSource = new ShaderSource({\n    defines: [extrudedDefine],\n    sources: [vs],\n  });\n  const fsSource = new ShaderSource({\n    sources: [ShadowVolumeFS],\n  });\n  const attributeLocations =\n    classificationPrimitive._primitive._attributeLocations;\n\n  const shadowVolumeAppearance = new ShadowVolumeAppearance(\n    cullFragmentsUsingExtents,\n    planarExtents,\n    classificationPrimitive.appearance,\n  );\n\n  classificationPrimitive._spStencil = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: classificationPrimitive._spStencil,\n    vertexShaderSource: vsSource,\n    fragmentShaderSource: fsSource,\n    attributeLocations: attributeLocations,\n  });\n\n  if (classificationPrimitive._primitive.allowPicking) {\n    let vsPick = ShaderSource.createPickVertexShaderSource(vs);\n    vsPick = Primitive._appendShowToShader(primitive, vsPick);\n    vsPick = Primitive._updatePickColorAttribute(vsPick);\n\n    const pickFS3D = shadowVolumeAppearance.createPickFragmentShader(false);\n    const pickVS3D = shadowVolumeAppearance.createPickVertexShader(\n      [extrudedDefine],\n      vsPick,\n      false,\n      frameState.mapProjection,\n    );\n\n    classificationPrimitive._spPick = ShaderProgram.replaceCache({\n      context: context,\n      shaderProgram: classificationPrimitive._spPick,\n      vertexShaderSource: pickVS3D,\n      fragmentShaderSource: pickFS3D,\n      attributeLocations: attributeLocations,\n    });\n\n    // Derive a 2D pick shader if the primitive uses texture coordinate-based fragment culling,\n    // since texture coordinates are computed differently in 2D.\n    if (cullFragmentsUsingExtents) {\n      let pickProgram2D = context.shaderCache.getDerivedShaderProgram(\n        classificationPrimitive._spPick,\n        \"2dPick\",\n      );\n      if (!defined(pickProgram2D)) {\n        const pickFS2D = shadowVolumeAppearance.createPickFragmentShader(true);\n        const pickVS2D = shadowVolumeAppearance.createPickVertexShader(\n          [extrudedDefine],\n          vsPick,\n          true,\n          frameState.mapProjection,\n        );\n\n        pickProgram2D = context.shaderCache.createDerivedShaderProgram(\n          classificationPrimitive._spPick,\n          \"2dPick\",\n          {\n            vertexShaderSource: pickVS2D,\n            fragmentShaderSource: pickFS2D,\n            attributeLocations: attributeLocations,\n          },\n        );\n      }\n      classificationPrimitive._spPick2D = pickProgram2D;\n    }\n  } else {\n    classificationPrimitive._spPick = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vsSource,\n      fragmentShaderSource: fsSource,\n      attributeLocations: attributeLocations,\n    });\n  }\n\n  vs = Primitive._appendShowToShader(primitive, vs);\n  vsSource = new ShaderSource({\n    defines: [extrudedDefine],\n    sources: [vs],\n  });\n\n  classificationPrimitive._sp = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: classificationPrimitive._sp,\n    vertexShaderSource: vsSource,\n    fragmentShaderSource: fsSource,\n    attributeLocations: attributeLocations,\n  });\n\n  // Create a fragment shader that computes only required material hookups using screen space techniques\n  const fsColorSource = shadowVolumeAppearance.createFragmentShader(false);\n  const vsColorSource = shadowVolumeAppearance.createVertexShader(\n    [extrudedDefine],\n    vs,\n    false,\n    frameState.mapProjection,\n  );\n\n  classificationPrimitive._spColor = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: classificationPrimitive._spColor,\n    vertexShaderSource: vsColorSource,\n    fragmentShaderSource: fsColorSource,\n    attributeLocations: attributeLocations,\n  });\n\n  // Derive a 2D shader if the primitive uses texture coordinate-based fragment culling,\n  // since texture coordinates are computed differently in 2D.\n  // Any material that uses texture coordinates will also equip texture coordinate-based fragment culling.\n  if (cullFragmentsUsingExtents) {\n    let colorProgram2D = context.shaderCache.getDerivedShaderProgram(\n      classificationPrimitive._spColor,\n      \"2dColor\",\n    );\n    if (!defined(colorProgram2D)) {\n      const fsColorSource2D = shadowVolumeAppearance.createFragmentShader(true);\n      const vsColorSource2D = shadowVolumeAppearance.createVertexShader(\n        [extrudedDefine],\n        vs,\n        true,\n        frameState.mapProjection,\n      );\n\n      colorProgram2D = context.shaderCache.createDerivedShaderProgram(\n        classificationPrimitive._spColor,\n        \"2dColor\",\n        {\n          vertexShaderSource: vsColorSource2D,\n          fragmentShaderSource: fsColorSource2D,\n          attributeLocations: attributeLocations,\n        },\n      );\n    }\n    classificationPrimitive._spColor2D = colorProgram2D;\n  }\n}\n\nfunction createColorCommands(classificationPrimitive, colorCommands) {\n  const primitive = classificationPrimitive._primitive;\n  let length = primitive._va.length * 2; // each geometry (pack of vertex attributes) needs 2 commands: front/back stencils and fill\n  colorCommands.length = length;\n\n  let i;\n  let command;\n  let derivedCommand;\n  let vaIndex = 0;\n  let uniformMap = primitive._batchTable.getUniformMapCallback()(\n    classificationPrimitive._uniformMap,\n  );\n\n  const needs2DShader = classificationPrimitive._needs2DShader;\n\n  for (i = 0; i < length; i += 2) {\n    const vertexArray = primitive._va[vaIndex++];\n\n    // Stencil depth command\n    command = colorCommands[i];\n    if (!defined(command)) {\n      command = colorCommands[i] = new DrawCommand({\n        owner: classificationPrimitive,\n        primitiveType: primitive._primitiveType,\n      });\n    }\n\n    command.vertexArray = vertexArray;\n    command.renderState = classificationPrimitive._rsStencilDepthPass;\n    command.shaderProgram = classificationPrimitive._sp;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    derivedCommand = DrawCommand.shallowClone(\n      command,\n      command.derivedCommands.tileset,\n    );\n    derivedCommand.renderState =\n      classificationPrimitive._rsStencilDepthPass3DTiles;\n    derivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedCommand;\n\n    // Color command\n    command = colorCommands[i + 1];\n    if (!defined(command)) {\n      command = colorCommands[i + 1] = new DrawCommand({\n        owner: classificationPrimitive,\n        primitiveType: primitive._primitiveType,\n      });\n    }\n\n    command.vertexArray = vertexArray;\n    command.renderState = classificationPrimitive._rsColorPass;\n    command.shaderProgram = classificationPrimitive._spColor;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    const appearance = classificationPrimitive.appearance;\n    const material = appearance.material;\n    if (defined(material)) {\n      uniformMap = combine(uniformMap, material._uniforms);\n    }\n\n    command.uniformMap = uniformMap;\n\n    derivedCommand = DrawCommand.shallowClone(\n      command,\n      command.derivedCommands.tileset,\n    );\n    derivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedCommand;\n\n    // Derive for 2D if texture coordinates are ever computed\n    if (needs2DShader) {\n      // First derive from the terrain command\n      let derived2DCommand = DrawCommand.shallowClone(\n        command,\n        command.derivedCommands.appearance2D,\n      );\n      derived2DCommand.shaderProgram = classificationPrimitive._spColor2D;\n      command.derivedCommands.appearance2D = derived2DCommand;\n\n      // Then derive from the 3D Tiles command\n      derived2DCommand = DrawCommand.shallowClone(\n        derivedCommand,\n        derivedCommand.derivedCommands.appearance2D,\n      );\n      derived2DCommand.shaderProgram = classificationPrimitive._spColor2D;\n      derivedCommand.derivedCommands.appearance2D = derived2DCommand;\n    }\n  }\n\n  const commandsIgnoreShow = classificationPrimitive._commandsIgnoreShow;\n  const spStencil = classificationPrimitive._spStencil;\n\n  let commandIndex = 0;\n  length = commandsIgnoreShow.length = length / 2;\n\n  for (let j = 0; j < length; ++j) {\n    const commandIgnoreShow = (commandsIgnoreShow[j] = DrawCommand.shallowClone(\n      colorCommands[commandIndex],\n      commandsIgnoreShow[j],\n    ));\n    commandIgnoreShow.shaderProgram = spStencil;\n    commandIgnoreShow.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW;\n\n    commandIndex += 2;\n  }\n}\n\nfunction createPickCommands(classificationPrimitive, pickCommands) {\n  const usePickOffsets = classificationPrimitive._usePickOffsets;\n\n  const primitive = classificationPrimitive._primitive;\n  let length = primitive._va.length * 2; // each geometry (pack of vertex attributes) needs 2 commands: front/back stencils and fill\n\n  // Fallback for batching same-color geometry instances\n  let pickOffsets;\n  let pickIndex = 0;\n  let pickOffset;\n  if (usePickOffsets) {\n    pickOffsets = primitive._pickOffsets;\n    length = pickOffsets.length * 2;\n  }\n\n  pickCommands.length = length;\n\n  let j;\n  let command;\n  let derivedCommand;\n  let vaIndex = 0;\n  const uniformMap = primitive._batchTable.getUniformMapCallback()(\n    classificationPrimitive._uniformMap,\n  );\n\n  const needs2DShader = classificationPrimitive._needs2DShader;\n\n  for (j = 0; j < length; j += 2) {\n    let vertexArray = primitive._va[vaIndex++];\n    if (usePickOffsets) {\n      pickOffset = pickOffsets[pickIndex++];\n      vertexArray = primitive._va[pickOffset.index];\n    }\n\n    // Stencil depth command\n    command = pickCommands[j];\n    if (!defined(command)) {\n      command = pickCommands[j] = new DrawCommand({\n        owner: classificationPrimitive,\n        primitiveType: primitive._primitiveType,\n        pickOnly: true,\n      });\n    }\n\n    command.vertexArray = vertexArray;\n    command.renderState = classificationPrimitive._rsStencilDepthPass;\n    command.shaderProgram = classificationPrimitive._sp;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n    if (usePickOffsets) {\n      command.offset = pickOffset.offset;\n      command.count = pickOffset.count;\n    }\n\n    // Derive for 3D Tiles classification\n    derivedCommand = DrawCommand.shallowClone(\n      command,\n      command.derivedCommands.tileset,\n    );\n    derivedCommand.renderState =\n      classificationPrimitive._rsStencilDepthPass3DTiles;\n    derivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedCommand;\n\n    // Pick color command\n    command = pickCommands[j + 1];\n    if (!defined(command)) {\n      command = pickCommands[j + 1] = new DrawCommand({\n        owner: classificationPrimitive,\n        primitiveType: primitive._primitiveType,\n        pickOnly: true,\n      });\n    }\n\n    command.vertexArray = vertexArray;\n    command.renderState = classificationPrimitive._rsPickPass;\n    command.shaderProgram = classificationPrimitive._spPick;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n    if (usePickOffsets) {\n      command.offset = pickOffset.offset;\n      command.count = pickOffset.count;\n    }\n\n    derivedCommand = DrawCommand.shallowClone(\n      command,\n      command.derivedCommands.tileset,\n    );\n    derivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedCommand;\n\n    // Derive for 2D if texture coordinates are ever computed\n    if (needs2DShader) {\n      // First derive from the terrain command\n      let derived2DCommand = DrawCommand.shallowClone(\n        command,\n        command.derivedCommands.pick2D,\n      );\n      derived2DCommand.shaderProgram = classificationPrimitive._spPick2D;\n      command.derivedCommands.pick2D = derived2DCommand;\n\n      // Then derive from the 3D Tiles command\n      derived2DCommand = DrawCommand.shallowClone(\n        derivedCommand,\n        derivedCommand.derivedCommands.pick2D,\n      );\n      derived2DCommand.shaderProgram = classificationPrimitive._spPick2D;\n      derivedCommand.derivedCommands.pick2D = derived2DCommand;\n    }\n  }\n}\n\nfunction createCommands(\n  classificationPrimitive,\n  appearance,\n  material,\n  translucent,\n  twoPasses,\n  colorCommands,\n  pickCommands,\n) {\n  createColorCommands(classificationPrimitive, colorCommands);\n  createPickCommands(classificationPrimitive, pickCommands);\n}\n\nfunction boundingVolumeIndex(commandIndex, length) {\n  return Math.floor((commandIndex % length) / 2);\n}\n\nfunction updateAndQueueRenderCommand(\n  command,\n  frameState,\n  modelMatrix,\n  cull,\n  boundingVolume,\n  debugShowBoundingVolume,\n) {\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n  command.debugShowBoundingVolume = debugShowBoundingVolume;\n\n  frameState.commandList.push(command);\n}\n\nfunction updateAndQueuePickCommand(\n  command,\n  frameState,\n  modelMatrix,\n  cull,\n  boundingVolume,\n) {\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n\n  frameState.commandList.push(command);\n}\n\nfunction updateAndQueueCommands(\n  classificationPrimitive,\n  frameState,\n  colorCommands,\n  pickCommands,\n  modelMatrix,\n  cull,\n  debugShowBoundingVolume,\n  twoPasses,\n) {\n  const primitive = classificationPrimitive._primitive;\n  Primitive._updateBoundingVolumes(primitive, frameState, modelMatrix);\n\n  let boundingVolumes;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingVolumes = primitive._boundingSphereWC;\n  } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n    boundingVolumes = primitive._boundingSphereCV;\n  } else if (\n    frameState.mode === SceneMode.SCENE2D &&\n    defined(primitive._boundingSphere2D)\n  ) {\n    boundingVolumes = primitive._boundingSphere2D;\n  } else if (defined(primitive._boundingSphereMorph)) {\n    boundingVolumes = primitive._boundingSphereMorph;\n  }\n\n  const classificationType = classificationPrimitive.classificationType;\n  const queueTerrainCommands =\n    classificationType !== ClassificationType.CESIUM_3D_TILE;\n  const queue3DTilesCommands =\n    classificationType !== ClassificationType.TERRAIN;\n\n  const passes = frameState.passes;\n\n  let i;\n  let boundingVolume;\n  let command;\n\n  if (passes.render) {\n    const colorLength = colorCommands.length;\n    for (i = 0; i < colorLength; ++i) {\n      boundingVolume = boundingVolumes[boundingVolumeIndex(i, colorLength)];\n      if (queueTerrainCommands) {\n        command = colorCommands[i];\n        updateAndQueueRenderCommand(\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n          debugShowBoundingVolume,\n        );\n      }\n      if (queue3DTilesCommands) {\n        command = colorCommands[i].derivedCommands.tileset;\n        updateAndQueueRenderCommand(\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n          debugShowBoundingVolume,\n        );\n      }\n    }\n\n    if (frameState.invertClassification) {\n      const ignoreShowCommands = classificationPrimitive._commandsIgnoreShow;\n      const ignoreShowCommandsLength = ignoreShowCommands.length;\n      for (i = 0; i < ignoreShowCommandsLength; ++i) {\n        boundingVolume = boundingVolumes[i];\n        command = ignoreShowCommands[i];\n        updateAndQueueRenderCommand(\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n          debugShowBoundingVolume,\n        );\n      }\n    }\n  }\n\n  if (passes.pick) {\n    const pickLength = pickCommands.length;\n    const pickOffsets = primitive._pickOffsets;\n    for (i = 0; i < pickLength; ++i) {\n      const pickOffset = pickOffsets[boundingVolumeIndex(i, pickLength)];\n      boundingVolume = boundingVolumes[pickOffset.index];\n      if (queueTerrainCommands) {\n        command = pickCommands[i];\n        updateAndQueuePickCommand(\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n        );\n      }\n      if (queue3DTilesCommands) {\n        command = pickCommands[i].derivedCommands.tileset;\n        updateAndQueuePickCommand(\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n        );\n      }\n    }\n  }\n}\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n * @exception {DeveloperError} Appearance and material have a uniform with the same name.\n * @exception {DeveloperError} Not all of the geometry instances have the same color attribute.\n */\nClassificationPrimitive.prototype.update = function (frameState) {\n  if (!defined(this._primitive) && !defined(this.geometryInstances)) {\n    return;\n  }\n\n  let appearance = this.appearance;\n  if (defined(appearance) && defined(appearance.material)) {\n    appearance.material.update(frameState.context);\n  }\n\n  const that = this;\n  const primitiveOptions = this._primitiveOptions;\n\n  if (!defined(this._primitive)) {\n    const instances = Array.isArray(this.geometryInstances)\n      ? this.geometryInstances\n      : [this.geometryInstances];\n    const length = instances.length;\n\n    let i;\n    let instance;\n    let attributes;\n\n    let hasPerColorAttribute = false;\n    let allColorsSame = true;\n    let firstColor;\n    let hasSphericalExtentsAttribute = false;\n    let hasPlanarExtentsAttributes = false;\n\n    if (length > 0) {\n      attributes = instances[0].attributes;\n      // Not expecting these to be set by users, should only be set via GroundPrimitive.\n      // So don't check for mismatch.\n      hasSphericalExtentsAttribute =\n        ShadowVolumeAppearance.hasAttributesForSphericalExtents(attributes);\n      hasPlanarExtentsAttributes =\n        ShadowVolumeAppearance.hasAttributesForTextureCoordinatePlanes(\n          attributes,\n        );\n      firstColor = attributes.color;\n    }\n\n    for (i = 0; i < length; i++) {\n      instance = instances[i];\n      const color = instance.attributes.color;\n      if (defined(color)) {\n        hasPerColorAttribute = true;\n      }\n      //>>includeStart('debug', pragmas.debug);\n      else if (hasPerColorAttribute) {\n        throw new DeveloperError(\n          \"All GeometryInstances must have color attributes to use per-instance color.\",\n        );\n      }\n      //>>includeEnd('debug');\n\n      allColorsSame =\n        allColorsSame &&\n        defined(color) &&\n        ColorGeometryInstanceAttribute.equals(firstColor, color);\n    }\n\n    // If no attributes exist for computing spherical extents or fragment culling,\n    // throw if the colors aren't all the same.\n    if (\n      !allColorsSame &&\n      !hasSphericalExtentsAttribute &&\n      !hasPlanarExtentsAttributes\n    ) {\n      throw new DeveloperError(\n        \"All GeometryInstances must have the same color attribute except via GroundPrimitives\",\n      );\n    }\n\n    // default to a color appearance\n    if (hasPerColorAttribute && !defined(appearance)) {\n      appearance = new PerInstanceColorAppearance({\n        flat: true,\n      });\n      this.appearance = appearance;\n    }\n\n    //>>includeStart('debug', pragmas.debug);\n    if (\n      !hasPerColorAttribute &&\n      appearance instanceof PerInstanceColorAppearance\n    ) {\n      throw new DeveloperError(\n        \"PerInstanceColorAppearance requires color GeometryInstanceAttributes on all GeometryInstances\",\n      );\n    }\n    if (\n      defined(appearance.material) &&\n      !hasSphericalExtentsAttribute &&\n      !hasPlanarExtentsAttributes\n    ) {\n      throw new DeveloperError(\n        \"Materials on ClassificationPrimitives are not supported except via GroundPrimitives\",\n      );\n    }\n    //>>includeEnd('debug');\n\n    this._usePickOffsets =\n      !hasSphericalExtentsAttribute && !hasPlanarExtentsAttributes;\n    this._hasSphericalExtentsAttribute = hasSphericalExtentsAttribute;\n    this._hasPlanarExtentsAttributes = hasPlanarExtentsAttributes;\n    this._hasPerColorAttribute = hasPerColorAttribute;\n\n    const geometryInstances = new Array(length);\n    for (i = 0; i < length; ++i) {\n      instance = instances[i];\n      geometryInstances[i] = new GeometryInstance({\n        geometry: instance.geometry,\n        attributes: instance.attributes,\n        modelMatrix: instance.modelMatrix,\n        id: instance.id,\n        pickPrimitive: this._pickPrimitive ?? that,\n      });\n    }\n\n    primitiveOptions.appearance = appearance;\n    primitiveOptions.geometryInstances = geometryInstances;\n\n    if (defined(this._createBoundingVolumeFunction)) {\n      primitiveOptions._createBoundingVolumeFunction = function (\n        frameState,\n        geometry,\n      ) {\n        that._createBoundingVolumeFunction(frameState, geometry);\n      };\n    }\n\n    primitiveOptions._createRenderStatesFunction = function (\n      primitive,\n      context,\n      appearance,\n      twoPasses,\n    ) {\n      createRenderStates(that, context);\n    };\n    primitiveOptions._createShaderProgramFunction = function (\n      primitive,\n      frameState,\n      appearance,\n    ) {\n      createShaderProgram(that, frameState);\n    };\n    primitiveOptions._createCommandsFunction = function (\n      primitive,\n      appearance,\n      material,\n      translucent,\n      twoPasses,\n      colorCommands,\n      pickCommands,\n    ) {\n      createCommands(\n        that,\n        undefined,\n        undefined,\n        true,\n        false,\n        colorCommands,\n        pickCommands,\n      );\n    };\n\n    if (defined(this._updateAndQueueCommandsFunction)) {\n      primitiveOptions._updateAndQueueCommandsFunction = function (\n        primitive,\n        frameState,\n        colorCommands,\n        pickCommands,\n        modelMatrix,\n        cull,\n        debugShowBoundingVolume,\n        twoPasses,\n      ) {\n        that._updateAndQueueCommandsFunction(\n          primitive,\n          frameState,\n          colorCommands,\n          pickCommands,\n          modelMatrix,\n          cull,\n          debugShowBoundingVolume,\n          twoPasses,\n        );\n      };\n    } else {\n      primitiveOptions._updateAndQueueCommandsFunction = function (\n        primitive,\n        frameState,\n        colorCommands,\n        pickCommands,\n        modelMatrix,\n        cull,\n        debugShowBoundingVolume,\n        twoPasses,\n      ) {\n        updateAndQueueCommands(\n          that,\n          frameState,\n          colorCommands,\n          pickCommands,\n          modelMatrix,\n          cull,\n          debugShowBoundingVolume,\n          twoPasses,\n        );\n      };\n    }\n\n    this._primitive = new Primitive(primitiveOptions);\n  }\n\n  if (\n    this.debugShowShadowVolume &&\n    !this._debugShowShadowVolume &&\n    this._ready\n  ) {\n    this._debugShowShadowVolume = true;\n    this._rsStencilDepthPass = RenderState.fromCache(\n      getStencilDepthRenderState(false, false),\n    );\n    this._rsStencilDepthPass3DTiles = RenderState.fromCache(\n      getStencilDepthRenderState(false, true),\n    );\n    this._rsColorPass = RenderState.fromCache(getColorRenderState(false));\n  } else if (!this.debugShowShadowVolume && this._debugShowShadowVolume) {\n    this._debugShowShadowVolume = false;\n    this._rsStencilDepthPass = RenderState.fromCache(\n      getStencilDepthRenderState(true, false),\n    );\n    this._rsStencilDepthPass3DTiles = RenderState.fromCache(\n      getStencilDepthRenderState(true, true),\n    );\n    this._rsColorPass = RenderState.fromCache(getColorRenderState(true));\n  }\n  // Update primitive appearance\n  if (this._primitive.appearance !== appearance) {\n    //>>includeStart('debug', pragmas.debug);\n    // Check if the appearance is supported by the geometry attributes\n    if (\n      !this._hasSphericalExtentsAttribute &&\n      !this._hasPlanarExtentsAttributes &&\n      defined(appearance.material)\n    ) {\n      throw new DeveloperError(\n        \"Materials on ClassificationPrimitives are not supported except via GroundPrimitive\",\n      );\n    }\n    if (\n      !this._hasPerColorAttribute &&\n      appearance instanceof PerInstanceColorAppearance\n    ) {\n      throw new DeveloperError(\n        \"PerInstanceColorAppearance requires color GeometryInstanceAttribute\",\n      );\n    }\n    //>>includeEnd('debug');\n    this._primitive.appearance = appearance;\n  }\n\n  this._primitive.show = this.show;\n  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;\n  this._primitive.update(frameState);\n\n  frameState.afterRender.push(() => {\n    if (defined(this._primitive) && this._primitive.ready) {\n      this._ready = true;\n\n      if (this.releaseGeometryInstances) {\n        this.geometryInstances = undefined;\n      }\n    }\n  });\n};\n\n/**\n * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.\n *\n * @param {*} id The id of the {@link GeometryInstance}.\n * @returns {object} The typed array in the attribute's format or undefined if the is no instance with id.\n *\n * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.\n *\n * @example\n * const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n */\nClassificationPrimitive.prototype.getGeometryInstanceAttributes = function (\n  id,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(this._primitive)) {\n    throw new DeveloperError(\n      \"must call update before calling getGeometryInstanceAttributes\",\n    );\n  }\n  //>>includeEnd('debug');\n  return this._primitive.getGeometryInstanceAttributes(id);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ClassificationPrimitive#destroy\n */\nClassificationPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * e = e && e.destroy();\n *\n * @see ClassificationPrimitive#isDestroyed\n */\nClassificationPrimitive.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  this._sp = this._sp && this._sp.destroy();\n  this._spPick = this._spPick && this._spPick.destroy();\n  this._spColor = this._spColor && this._spColor.destroy();\n\n  // Derived programs, destroyed above if they existed.\n  this._spPick2D = undefined;\n  this._spColor2D = undefined;\n  return destroyObject(this);\n};\nexport default ClassificationPrimitive;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}