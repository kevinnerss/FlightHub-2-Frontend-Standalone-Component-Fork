{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nconst viewerPositionWCScratch = new Cartesian3();\nfunction AutomaticUniform(options) {\n  this._size = options.size;\n  this._datatype = options.datatype;\n  this.getValue = options.getValue;\n}\nconst datatypeToGlsl = {};\ndatatypeToGlsl[WebGLConstants.FLOAT] = \"float\";\ndatatypeToGlsl[WebGLConstants.FLOAT_VEC2] = \"vec2\";\ndatatypeToGlsl[WebGLConstants.FLOAT_VEC3] = \"vec3\";\ndatatypeToGlsl[WebGLConstants.FLOAT_VEC4] = \"vec4\";\ndatatypeToGlsl[WebGLConstants.INT] = \"int\";\ndatatypeToGlsl[WebGLConstants.INT_VEC2] = \"ivec2\";\ndatatypeToGlsl[WebGLConstants.INT_VEC3] = \"ivec3\";\ndatatypeToGlsl[WebGLConstants.INT_VEC4] = \"ivec4\";\ndatatypeToGlsl[WebGLConstants.BOOL] = \"bool\";\ndatatypeToGlsl[WebGLConstants.BOOL_VEC2] = \"bvec2\";\ndatatypeToGlsl[WebGLConstants.BOOL_VEC3] = \"bvec3\";\ndatatypeToGlsl[WebGLConstants.BOOL_VEC4] = \"bvec4\";\ndatatypeToGlsl[WebGLConstants.FLOAT_MAT2] = \"mat2\";\ndatatypeToGlsl[WebGLConstants.FLOAT_MAT3] = \"mat3\";\ndatatypeToGlsl[WebGLConstants.FLOAT_MAT4] = \"mat4\";\ndatatypeToGlsl[WebGLConstants.SAMPLER_2D] = \"sampler2D\";\ndatatypeToGlsl[WebGLConstants.SAMPLER_CUBE] = \"samplerCube\";\nAutomaticUniform.prototype.getDeclaration = function (name) {\n  let declaration = `uniform ${datatypeToGlsl[this._datatype]} ${name}`;\n  const size = this._size;\n  if (size === 1) {\n    declaration += \";\";\n  } else {\n    declaration += `[${size.toString()}];`;\n  }\n  return declaration;\n};\n\n/**\n * @private\n */\nconst AutomaticUniforms = {\n  /**\n   * An automatic GLSL uniform containing the viewport's <code>x</code>, <code>y</code>, <code>width</code>,\n   * and <code>height</code> properties in an <code>vec4</code>'s <code>x</code>, <code>y</code>, <code>z</code>,\n   * and <code>w</code> components, respectively.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec4 czm_viewport;\n   *\n   * // Scale the window coordinate components to [0, 1] by dividing\n   * // by the viewport's width and height.\n   * vec2 v = gl_FragCoord.xy / czm_viewport.zw;\n   *\n   * @see Context#getViewport\n   */\n  czm_viewport: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC4,\n    getValue: function (uniformState) {\n      return uniformState.viewportCartesian4;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 4x4 orthographic projection matrix that\n   * transforms window coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   * <br /><br />\n   * This transform is useful when a vertex shader inputs or manipulates window coordinates\n   * as done by {@link BillboardCollection}.\n   * <br /><br />\n   * Do not confuse {@link czm_viewportTransformation} with <code>czm_viewportOrthographic</code>.\n   * The former transforms from normalized device coordinates to window coordinates; the later transforms\n   * from window coordinates to clip coordinates, and is often used to assign to <code>gl_Position</code>.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_viewportOrthographic;\n   *\n   * // Example\n   * gl_Position = czm_viewportOrthographic * vec4(windowPosition, 0.0, 1.0);\n   *\n   * @see UniformState#viewportOrthographic\n   * @see czm_viewport\n   * @see czm_viewportTransformation\n   * @see BillboardCollection\n   */\n  czm_viewportOrthographic: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.viewportOrthographic;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 4x4 transformation matrix that\n   * transforms normalized device coordinates to window coordinates.  The context's\n   * full viewport is used, and the depth range is assumed to be <code>near = 0</code>\n   * and <code>far = 1</code>.\n   * <br /><br />\n   * This transform is useful when there is a need to manipulate window coordinates\n   * in a vertex shader as done by {@link BillboardCollection}.  In many cases,\n   * this matrix will not be used directly; instead, {@link czm_modelToWindowCoordinates}\n   * will be used to transform directly from model to window coordinates.\n   * <br /><br />\n   * Do not confuse <code>czm_viewportTransformation</code> with {@link czm_viewportOrthographic}.\n   * The former transforms from normalized device coordinates to window coordinates; the later transforms\n   * from window coordinates to clip coordinates, and is often used to assign to <code>gl_Position</code>.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_viewportTransformation;\n   *\n   * // Use czm_viewportTransformation as part of the\n   * // transform from model to window coordinates.\n   * vec4 q = czm_modelViewProjection * positionMC;               // model to clip coordinates\n   * q.xyz /= q.w;                                                // clip to normalized device coordinates (ndc)\n   * q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // ndc to window coordinates\n   *\n   * @see UniformState#viewportTransformation\n   * @see czm_viewport\n   * @see czm_viewportOrthographic\n   * @see czm_modelToWindowCoordinates\n   * @see BillboardCollection\n   */\n  czm_viewportTransformation: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.viewportTransformation;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing the depth of the scene\n   * after the globe pass and then updated after the 3D Tiles pass.\n   * The depth is packed into an RGBA texture.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform sampler2D czm_globeDepthTexture;\n   *\n   * // Get the depth at the current fragment\n   * vec2 coords = gl_FragCoord.xy / czm_viewport.zw;\n   * float depth = czm_unpackDepth(texture(czm_globeDepthTexture, coords));\n   */\n  czm_globeDepthTexture: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.SAMPLER_2D,\n    getValue: function (uniformState) {\n      return uniformState.globeDepthTexture;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 4x4 model transformation matrix that\n   * transforms model coordinates to world coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_model;\n   *\n   * // Example\n   * vec4 worldPosition = czm_model * modelPosition;\n   *\n   * @see UniformState#model\n   * @see czm_inverseModel\n   * @see czm_modelView\n   * @see czm_modelViewProjection\n   */\n  czm_model: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.model;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 4x4 model transformation matrix that\n   * transforms world coordinates to model coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseModel;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModel * worldPosition;\n   *\n   * @see UniformState#inverseModel\n   * @see czm_model\n   * @see czm_inverseModelView\n   */\n  czm_inverseModel: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseModel;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 4x4 view transformation matrix that\n   * transforms world coordinates to eye coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_view;\n   *\n   * // Example\n   * vec4 eyePosition = czm_view * worldPosition;\n   *\n   * @see UniformState#view\n   * @see czm_viewRotation\n   * @see czm_modelView\n   * @see czm_viewProjection\n   * @see czm_modelViewProjection\n   * @see czm_inverseView\n   */\n  czm_view: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.view;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 4x4 view transformation matrix that\n   * transforms 3D world coordinates to eye coordinates.  In 3D mode, this is identical to\n   * {@link czm_view}, but in 2D and Columbus View it represents the view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_view3D;\n   *\n   * // Example\n   * vec4 eyePosition3D = czm_view3D * worldPosition3D;\n   *\n   * @see UniformState#view3D\n   * @see czm_view\n   */\n  czm_view3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.view3D;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 3x3 view rotation matrix that\n   * transforms vectors in world coordinates to eye coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_viewRotation;\n   *\n   * // Example\n   * vec3 eyeVector = czm_viewRotation * worldVector;\n   *\n   * @see UniformState#viewRotation\n   * @see czm_view\n   * @see czm_inverseView\n   * @see czm_inverseViewRotation\n   */\n  czm_viewRotation: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.viewRotation;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 3x3 view rotation matrix that\n   * transforms vectors in 3D world coordinates to eye coordinates.  In 3D mode, this is identical to\n   * {@link czm_viewRotation}, but in 2D and Columbus View it represents the view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_viewRotation3D;\n   *\n   * // Example\n   * vec3 eyeVector = czm_viewRotation3D * worldVector;\n   *\n   * @see UniformState#viewRotation3D\n   * @see czm_viewRotation\n   */\n  czm_viewRotation3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.viewRotation3D;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 4x4 transformation matrix that\n   * transforms from eye coordinates to world coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseView;\n   *\n   * // Example\n   * vec4 worldPosition = czm_inverseView * eyePosition;\n   *\n   * @see UniformState#inverseView\n   * @see czm_view\n   * @see czm_inverseNormal\n   */\n  czm_inverseView: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseView;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 4x4 transformation matrix that\n   * transforms from 3D eye coordinates to world coordinates.  In 3D mode, this is identical to\n   * {@link czm_inverseView}, but in 2D and Columbus View it represents the inverse view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseView3D;\n   *\n   * // Example\n   * vec4 worldPosition = czm_inverseView3D * eyePosition;\n   *\n   * @see UniformState#inverseView3D\n   * @see czm_inverseView\n   */\n  czm_inverseView3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseView3D;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 3x3 rotation matrix that\n   * transforms vectors from eye coordinates to world coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_inverseViewRotation;\n   *\n   * // Example\n   * vec4 worldVector = czm_inverseViewRotation * eyeVector;\n   *\n   * @see UniformState#inverseView\n   * @see czm_view\n   * @see czm_viewRotation\n   * @see czm_inverseViewRotation\n   */\n  czm_inverseViewRotation: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.inverseViewRotation;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 3x3 rotation matrix that\n   * transforms vectors from 3D eye coordinates to world coordinates.  In 3D mode, this is identical to\n   * {@link czm_inverseViewRotation}, but in 2D and Columbus View it represents the inverse view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_inverseViewRotation3D;\n   *\n   * // Example\n   * vec4 worldVector = czm_inverseViewRotation3D * eyeVector;\n   *\n   * @see UniformState#inverseView3D\n   * @see czm_inverseViewRotation\n   */\n  czm_inverseViewRotation3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.inverseViewRotation3D;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 4x4 projection transformation matrix that\n   * transforms eye coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_projection;\n   *\n   * // Example\n   * gl_Position = czm_projection * eyePosition;\n   *\n   * @see UniformState#projection\n   * @see czm_viewProjection\n   * @see czm_modelViewProjection\n   * @see czm_infiniteProjection\n   */\n  czm_projection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.projection;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 4x4 inverse projection transformation matrix that\n   * transforms from clip coordinates to eye coordinates. Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseProjection;\n   *\n   * // Example\n   * vec4 eyePosition = czm_inverseProjection * clipPosition;\n   *\n   * @see UniformState#inverseProjection\n   * @see czm_projection\n   */\n  czm_inverseProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseProjection;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 4x4 projection transformation matrix with the far plane at infinity,\n   * that transforms eye coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.  An infinite far plane is used\n   * in algorithms like shadow volumes and GPU ray casting with proxy geometry to ensure that triangles\n   * are not clipped by the far plane.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_infiniteProjection;\n   *\n   * // Example\n   * gl_Position = czm_infiniteProjection * eyePosition;\n   *\n   * @see UniformState#infiniteProjection\n   * @see czm_projection\n   * @see czm_modelViewInfiniteProjection\n   */\n  czm_infiniteProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.infiniteProjection;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that\n   * transforms model coordinates to eye coordinates.\n   * <br /><br />\n   * Positions should be transformed to eye coordinates using <code>czm_modelView</code> and\n   * normals should be transformed using {@link czm_normal}.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelView;\n   *\n   * // Example\n   * vec4 eyePosition = czm_modelView * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * vec4 eyePosition = czm_view * czm_model * modelPosition;\n   *\n   * @see UniformState#modelView\n   * @see czm_model\n   * @see czm_view\n   * @see czm_modelViewProjection\n   * @see czm_normal\n   */\n  czm_modelView: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelView;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that\n   * transforms 3D model coordinates to eye coordinates.  In 3D mode, this is identical to\n   * {@link czm_modelView}, but in 2D and Columbus View it represents the model-view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   * <br /><br />\n   * Positions should be transformed to eye coordinates using <code>czm_modelView3D</code> and\n   * normals should be transformed using {@link czm_normal3D}.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelView3D;\n   *\n   * // Example\n   * vec4 eyePosition = czm_modelView3D * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * vec4 eyePosition = czm_view3D * czm_model * modelPosition;\n   *\n   * @see UniformState#modelView3D\n   * @see czm_modelView\n   */\n  czm_modelView3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelView3D;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that\n   * transforms model coordinates, relative to the eye, to eye coordinates.  This is used\n   * in conjunction with {@link czm_translateRelativeToEye}.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelViewRelativeToEye;\n   *\n   * // Example\n   * attribute vec3 positionHigh;\n   * attribute vec3 positionLow;\n   *\n   * void main()\n   * {\n   *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n   *   gl_Position = czm_projection * (czm_modelViewRelativeToEye * p);\n   * }\n   *\n   * @see czm_modelViewProjectionRelativeToEye\n   * @see czm_translateRelativeToEye\n   * @see EncodedCartesian3\n   */\n  czm_modelViewRelativeToEye: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelViewRelativeToEye;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 4x4 transformation matrix that\n   * transforms from eye coordinates to model coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseModelView;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModelView * eyePosition;\n   *\n   * @see UniformState#inverseModelView\n   * @see czm_modelView\n   */\n  czm_inverseModelView: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseModelView;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 4x4 transformation matrix that\n   * transforms from eye coordinates to 3D model coordinates.  In 3D mode, this is identical to\n   * {@link czm_inverseModelView}, but in 2D and Columbus View it represents the inverse model-view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseModelView3D;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModelView3D * eyePosition;\n   *\n   * @see UniformState#inverseModelView\n   * @see czm_inverseModelView\n   * @see czm_modelView3D\n   */\n  czm_inverseModelView3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseModelView3D;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that\n   * transforms world coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_viewProjection;\n   *\n   * // Example\n   * vec4 gl_Position = czm_viewProjection * czm_model * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * gl_Position = czm_projection * czm_view * czm_model * modelPosition;\n   *\n   * @see UniformState#viewProjection\n   * @see czm_view\n   * @see czm_projection\n   * @see czm_modelViewProjection\n   * @see czm_inverseViewProjection\n   */\n  czm_viewProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.viewProjection;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that\n   * transforms clip coordinates to world coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseViewProjection;\n   *\n   * // Example\n   * vec4 worldPosition = czm_inverseViewProjection * clipPosition;\n   *\n   * @see UniformState#inverseViewProjection\n   * @see czm_viewProjection\n   */\n  czm_inverseViewProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseViewProjection;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that\n   * transforms model coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelViewProjection;\n   *\n   * // Example\n   * vec4 gl_Position = czm_modelViewProjection * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * gl_Position = czm_projection * czm_view * czm_model * modelPosition;\n   *\n   * @see UniformState#modelViewProjection\n   * @see czm_model\n   * @see czm_view\n   * @see czm_projection\n   * @see czm_modelView\n   * @see czm_viewProjection\n   * @see czm_modelViewInfiniteProjection\n   * @see czm_inverseModelViewProjection\n   */\n  czm_modelViewProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelViewProjection;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 4x4 inverse model-view-projection transformation matrix that\n   * transforms clip coordinates to model coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseModelViewProjection;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModelViewProjection * clipPosition;\n   *\n   * @see UniformState#modelViewProjection\n   * @see czm_modelViewProjection\n   */\n  czm_inverseModelViewProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseModelViewProjection;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that\n   * transforms model coordinates, relative to the eye, to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.  This is used in\n   * conjunction with {@link czm_translateRelativeToEye}.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelViewProjectionRelativeToEye;\n   *\n   * // Example\n   * attribute vec3 positionHigh;\n   * attribute vec3 positionLow;\n   *\n   * void main()\n   * {\n   *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n   *   gl_Position = czm_modelViewProjectionRelativeToEye * p;\n   * }\n   *\n   * @see czm_modelViewRelativeToEye\n   * @see czm_translateRelativeToEye\n   * @see EncodedCartesian3\n   */\n  czm_modelViewProjectionRelativeToEye: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelViewProjectionRelativeToEye;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that\n   * transforms model coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.  The projection matrix places\n   * the far plane at infinity.  This is useful in algorithms like shadow volumes and GPU ray casting with\n   * proxy geometry to ensure that triangles are not clipped by the far plane.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelViewInfiniteProjection;\n   *\n   * // Example\n   * vec4 gl_Position = czm_modelViewInfiniteProjection * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * gl_Position = czm_infiniteProjection * czm_view * czm_model * modelPosition;\n   *\n   * @see UniformState#modelViewInfiniteProjection\n   * @see czm_model\n   * @see czm_view\n   * @see czm_infiniteProjection\n   * @see czm_modelViewProjection\n   */\n  czm_modelViewInfiniteProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelViewInfiniteProjection;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform that indicates if the current camera is orthographic in 3D.\n   *\n   * @see UniformState#orthographicIn3D\n   */\n  czm_orthographicIn3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.orthographicIn3D ? 1 : 0;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that\n   * transforms normal vectors in model coordinates to eye coordinates.\n   * <br /><br />\n   * Positions should be transformed to eye coordinates using {@link czm_modelView} and\n   * normals should be transformed using <code>czm_normal</code>.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_normal;\n   *\n   * // Example\n   * vec3 eyeNormal = czm_normal * normal;\n   *\n   * @see UniformState#normal\n   * @see czm_inverseNormal\n   * @see czm_modelView\n   */\n  czm_normal: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.normal;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that\n   * transforms normal vectors in 3D model coordinates to eye coordinates.\n   * In 3D mode, this is identical to\n   * {@link czm_normal}, but in 2D and Columbus View it represents the normal transformation\n   * matrix as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   * <br /><br />\n   * Positions should be transformed to eye coordinates using {@link czm_modelView3D} and\n   * normals should be transformed using <code>czm_normal3D</code>.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_normal3D;\n   *\n   * // Example\n   * vec3 eyeNormal = czm_normal3D * normal;\n   *\n   * @see UniformState#normal3D\n   * @see czm_normal\n   */\n  czm_normal3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.normal3D;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that\n   * transforms normal vectors in eye coordinates to model coordinates.  This is\n   * the opposite of the transform provided by {@link czm_normal}.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_inverseNormal;\n   *\n   * // Example\n   * vec3 normalMC = czm_inverseNormal * normalEC;\n   *\n   * @see UniformState#inverseNormal\n   * @see czm_normal\n   * @see czm_modelView\n   * @see czm_inverseView\n   */\n  czm_inverseNormal: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.inverseNormal;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that\n   * transforms normal vectors in eye coordinates to 3D model coordinates.  This is\n   * the opposite of the transform provided by {@link czm_normal}.\n   * In 3D mode, this is identical to\n   * {@link czm_inverseNormal}, but in 2D and Columbus View it represents the inverse normal transformation\n   * matrix as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_inverseNormal3D;\n   *\n   * // Example\n   * vec3 normalMC = czm_inverseNormal3D * normalEC;\n   *\n   * @see UniformState#inverseNormal3D\n   * @see czm_inverseNormal\n   */\n  czm_inverseNormal3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.inverseNormal3D;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform containing the height in meters of the\n   * eye (camera) above or below the ellipsoid.\n   *\n   * @see UniformState#eyeHeight\n   */\n  czm_eyeHeight: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.eyeHeight;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform containing height (<code>x</code>) and height squared (<code>y</code>)\n   * in meters of the eye (camera) above the 2D world plane. This uniform is only valid\n   * when the {@link SceneMode} is <code>SCENE2D</code>.\n   *\n   * @see UniformState#eyeHeight2D\n   */\n  czm_eyeHeight2D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC2,\n    getValue: function (uniformState) {\n      return uniformState.eyeHeight2D;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform containing the ellipsoid surface normal\n   * at the position below the eye (camera), in eye coordinates.\n   * This uniform is only valid when the {@link SceneMode} is <code>SCENE3D</code>.\n   */\n  czm_eyeEllipsoidNormalEC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.eyeEllipsoidNormalEC;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform containing the ellipsoid radii of curvature at the camera position.\n   * The .x component is the prime vertical radius of curvature (east-west direction)\n   * .y is the meridional radius of curvature (north-south direction)\n   * This uniform is only valid when the {@link SceneMode} is <code>SCENE3D</code>.\n   */\n  czm_eyeEllipsoidCurvature: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC2,\n    getValue: function (uniformState) {\n      return uniformState.eyeEllipsoidCurvature;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform containing the transform from model coordinates\n   * to an east-north-up coordinate system centered at the position on the\n   * ellipsoid below the camera.\n   * This uniform is only valid when the {@link SceneMode} is <code>SCENE3D</code>.\n   */\n  czm_modelToEnu: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelToEnu;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform containing the the inverse of\n   * {@link AutomaticUniforms.czm_modelToEnu}.\n   * This uniform is only valid when the {@link SceneMode} is <code>SCENE3D</code>.\n   */\n  czm_enuToModel: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.enuToModel;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform containing the near distance (<code>x</code>) and the far distance (<code>y</code>)\n   * of the frustum defined by the camera.  This is the largest possible frustum, not an individual\n   * frustum used for multi-frustum rendering.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec2 czm_entireFrustum;\n   *\n   * // Example\n   * float frustumLength = czm_entireFrustum.y - czm_entireFrustum.x;\n   *\n   * @see UniformState#entireFrustum\n   * @see czm_currentFrustum\n   */\n  czm_entireFrustum: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC2,\n    getValue: function (uniformState) {\n      return uniformState.entireFrustum;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform containing the near distance (<code>x</code>) and the far distance (<code>y</code>)\n   * of the frustum defined by the camera.  This is the individual\n   * frustum used for multi-frustum rendering.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec2 czm_currentFrustum;\n   *\n   * // Example\n   * float frustumLength = czm_currentFrustum.y - czm_currentFrustum.x;\n   *\n   * @see UniformState#currentFrustum\n   * @see czm_entireFrustum\n   */\n  czm_currentFrustum: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC2,\n    getValue: function (uniformState) {\n      return uniformState.currentFrustum;\n    }\n  }),\n  /**\n   * The distances to the frustum planes. The top, bottom, left and right distances are\n   * the x, y, z, and w components, respectively.\n   */\n  czm_frustumPlanes: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC4,\n    getValue: function (uniformState) {\n      return uniformState.frustumPlanes;\n    }\n  }),\n  /**\n   * Gets the far plane's distance from the near plane, plus 1.0.\n   */\n  czm_farDepthFromNearPlusOne: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.farDepthFromNearPlusOne;\n    }\n  }),\n  /**\n   * Gets the log2 of {@link AutomaticUniforms#czm_farDepthFromNearPlusOne}.\n   */\n  czm_log2FarDepthFromNearPlusOne: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.log2FarDepthFromNearPlusOne;\n    }\n  }),\n  /**\n   * Gets 1.0 divided by {@link AutomaticUniforms#czm_log2FarDepthFromNearPlusOne}.\n   */\n  czm_oneOverLog2FarDepthFromNearPlusOne: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.oneOverLog2FarDepthFromNearPlusOne;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing the sun position in world coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_sunPositionWC;\n   *\n   * @see UniformState#sunPositionWC\n   * @see czm_sunPositionColumbusView\n   * @see czm_sunDirectionWC\n   */\n  czm_sunPositionWC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.sunPositionWC;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing the sun position in Columbus view world coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_sunPositionColumbusView;\n   *\n   * @see UniformState#sunPositionColumbusView\n   * @see czm_sunPositionWC\n   */\n  czm_sunPositionColumbusView: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.sunPositionColumbusView;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing the normalized direction to the sun in eye coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_sunDirectionEC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_sunDirectionEC, normalEC), 0.0);\n   *\n   * @see UniformState#sunDirectionEC\n   * @see czm_moonDirectionEC\n   * @see czm_sunDirectionWC\n   */\n  czm_sunDirectionEC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.sunDirectionEC;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing the normalized direction to the sun in world coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_sunDirectionWC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_sunDirectionWC, normalWC), 0.0);\n   *\n   * @see UniformState#sunDirectionWC\n   * @see czm_sunPositionWC\n   * @see czm_sunDirectionEC\n   */\n  czm_sunDirectionWC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.sunDirectionWC;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing the normalized direction to the moon in eye coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_moonDirectionEC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_moonDirectionEC, normalEC), 0.0);\n   *\n   * @see UniformState#moonDirectionEC\n   * @see czm_sunDirectionEC\n   */\n  czm_moonDirectionEC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.moonDirectionEC;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing the normalized direction to the scene's light source in eye coordinates.\n   * This is commonly used for directional lighting computations.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_lightDirectionEC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_lightDirectionEC, normalEC), 0.0);\n   *\n   * @see UniformState#lightDirectionEC\n   * @see czm_lightDirectionWC\n   */\n  czm_lightDirectionEC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.lightDirectionEC;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing the normalized direction to the scene's light source in world coordinates.\n   * This is commonly used for directional lighting computations.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_lightDirectionWC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_lightDirectionWC, normalWC), 0.0);\n   *\n   * @see UniformState#lightDirectionWC\n   * @see czm_lightDirectionEC\n   */\n  czm_lightDirectionWC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.lightDirectionWC;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform that represents the color of light emitted by the scene's light source. This\n   * is equivalent to the light color multiplied by the light intensity limited to a maximum luminance of 1.0\n   * suitable for non-HDR lighting.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_lightColor;\n   *\n   * // Example\n   * vec3 diffuseColor = czm_lightColor * max(dot(czm_lightDirectionWC, normalWC), 0.0);\n   *\n   * @see UniformState#lightColor\n   * @see czm_lightColorHdr\n   */\n  czm_lightColor: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.lightColor;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform that represents the high dynamic range color of light emitted by the scene's light\n   * source. This is equivalent to the light color multiplied by the light intensity suitable for HDR lighting.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_lightColorHdr;\n   *\n   * // Example\n   * vec3 diffuseColor = czm_lightColorHdr * max(dot(czm_lightDirectionWC, normalWC), 0.0);\n   *\n   * @see UniformState#lightColorHdr\n   * @see czm_lightColor\n   */\n  czm_lightColorHdr: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.lightColorHdr;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing the high bits of the camera position in model\n   * coordinates.  This is used for GPU RTE to eliminate jittering artifacts when rendering\n   * as described in {@link http://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_encodedCameraPositionMCHigh;\n   *\n   * @see czm_encodedCameraPositionMCLow\n   * @see czm_modelViewRelativeToEye\n   * @see czm_modelViewProjectionRelativeToEye\n   */\n  czm_encodedCameraPositionMCHigh: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.encodedCameraPositionMCHigh;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing the low bits of the camera position in model\n   * coordinates.  This is used for GPU RTE to eliminate jittering artifacts when rendering\n   * as described in {@linkhttp://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_encodedCameraPositionMCLow;\n   *\n   * @see czm_encodedCameraPositionMCHigh\n   * @see czm_modelViewRelativeToEye\n   * @see czm_modelViewProjectionRelativeToEye\n   */\n  czm_encodedCameraPositionMCLow: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.encodedCameraPositionMCLow;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing the position of the viewer (camera) in world coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_viewerPositionWC;\n   */\n  czm_viewerPositionWC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return Matrix4.getTranslation(uniformState.inverseView, viewerPositionWCScratch);\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing the frame number. This uniform is automatically incremented\n   * every frame.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_frameNumber;\n   */\n  czm_frameNumber: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.frameState.frameNumber;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing the current morph transition time between\n   * 2D/Columbus View and 3D, with 0.0 being 2D or Columbus View and 1.0 being 3D.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_morphTime;\n   *\n   * // Example\n   * vec4 p = czm_columbusViewMorph(position2D, position3D, czm_morphTime);\n   */\n  czm_morphTime: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.frameState.morphTime;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing the current {@link SceneMode}, expressed\n   * as a float.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_sceneMode;\n   *\n   * // Example\n   * if (czm_sceneMode == czm_sceneMode2D)\n   * {\n   *     eyeHeightSq = czm_eyeHeight2D.y;\n   * }\n   *\n   * @see czm_sceneMode2D\n   * @see czm_sceneModeColumbusView\n   * @see czm_sceneMode3D\n   * @see czm_sceneModeMorphing\n   */\n  czm_sceneMode: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.frameState.mode;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing the current rendering pass.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_pass;\n   *\n   * // Example\n   * if ((czm_pass == czm_passTranslucent) && isOpaque())\n   * {\n   *     gl_Position *= 0.0; // Cull opaque geometry in the translucent pass\n   * }\n   */\n  czm_pass: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.pass;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing the current scene background color.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec4 czm_backgroundColor;\n   *\n   * // Example: If the given color's RGB matches the background color, invert it.\n   * vec4 adjustColorForContrast(vec4 color)\n   * {\n   *     if (czm_backgroundColor.rgb == color.rgb)\n   *     {\n   *         color.rgb = vec3(1.0) - color.rgb;\n   *     }\n   *\n   *     return color;\n   * }\n   */\n  czm_backgroundColor: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC4,\n    getValue: function (uniformState) {\n      return uniformState.backgroundColor;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform containing the BRDF look up texture used for image-based lighting computations.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform sampler2D czm_brdfLut;\n   *\n   * // Example: For a given roughness and NdotV value, find the material's BRDF information in the red and green channels\n   * float roughness = 0.5;\n   * float NdotV = dot(normal, view);\n   * vec2 brdfLut = texture(czm_brdfLut, vec2(NdotV, roughness)).rg;\n   */\n  czm_brdfLut: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.SAMPLER_2D,\n    getValue: function (uniformState) {\n      return uniformState.brdfLut;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform containing the environment map used within the scene.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform samplerCube czm_environmentMap;\n   *\n   * // Example: Create a perfect reflection of the environment map on a  model\n   * float reflected = reflect(view, normal);\n   * vec4 reflectedColor = texture(czm_environmentMap, reflected);\n   */\n  czm_environmentMap: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.SAMPLER_CUBE,\n    getValue: function (uniformState) {\n      return uniformState.environmentMap;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform containing the specular environment cube map used within the scene.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform samplerCube czm_specularEnvironmentMaps;\n   */\n  czm_specularEnvironmentMaps: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.SAMPLER_CUBE,\n    getValue: function (uniformState) {\n      return uniformState.specularEnvironmentMaps;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform containing the maximum valid level-of-detail of the specular environment cube map used within the scene.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_specularEnvironmentMapsMaximumLOD;\n   */\n  czm_specularEnvironmentMapsMaximumLOD: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.specularEnvironmentMapsMaximumLOD;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform containing the spherical harmonic coefficients used within the scene.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3[9] czm_sphericalHarmonicCoefficients;\n   */\n  czm_sphericalHarmonicCoefficients: new AutomaticUniform({\n    size: 9,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.sphericalHarmonicCoefficients;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing a 3x3 rotation matrix that transforms\n   * from True Equator Mean Equinox (TEME) axes to the pseudo-fixed axes at the current scene time.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_temeToPseudoFixed;\n   *\n   * // Example\n   * vec3 pseudoFixed = czm_temeToPseudoFixed * teme;\n   *\n   * @see UniformState#temeToPseudoFixedMatrix\n   * @see Transforms.computeTemeToPseudoFixedMatrix\n   */\n  czm_temeToPseudoFixed: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.temeToPseudoFixedMatrix;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing the ratio of canvas coordinate space to canvas pixel space.\n   *\n   * @example\n   * uniform float czm_pixelRatio;\n   */\n  czm_pixelRatio: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.pixelRatio;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform scalar used to mix a color with the fog color based on the distance to the camera.\n   *\n   * @see czm_fog\n   */\n  czm_fogDensity: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.fogDensity;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform scalar used to mix a color with the fog color based on the distance to the camera.\n   *\n   * @see czm_fog\n   */\n  czm_fogVisualDensityScalar: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.fogVisualDensityScalar;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform scalar used to set a minimum brightness when dynamic lighting is applied to fog.\n   *\n   * @see czm_fog\n   */\n  czm_fogMinimumBrightness: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.fogMinimumBrightness;\n    }\n  }),\n  /**\n   * An automatic uniform representing the color shift for the atmosphere in HSB color space\n   *\n   * @example\n   * uniform vec3 czm_atmosphereHsbShift;\n   */\n  czm_atmosphereHsbShift: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.atmosphereHsbShift;\n    }\n  }),\n  /**\n   * An automatic uniform representing the intensity of the light that is used for computing the atmosphere color\n   *\n   * @example\n   * uniform float czm_atmosphereLightIntensity;\n   */\n  czm_atmosphereLightIntensity: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.atmosphereLightIntensity;\n    }\n  }),\n  /**\n   * An automatic uniform representing the Rayleigh scattering coefficient used when computing the atmosphere scattering\n   *\n   * @example\n   * uniform vec3 czm_atmosphereRayleighCoefficient;\n   */\n  czm_atmosphereRayleighCoefficient: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.atmosphereRayleighCoefficient;\n    }\n  }),\n  /**\n   * An automatic uniform representing the Rayleigh scale height in meters used for computing atmosphere scattering.\n   *\n   * @example\n   * uniform vec3 czm_atmosphereRayleighScaleHeight;\n   */\n  czm_atmosphereRayleighScaleHeight: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.atmosphereRayleighScaleHeight;\n    }\n  }),\n  /**\n   * An automatic uniform representing the Mie scattering coefficient used when computing atmosphere scattering.\n   *\n   * @example\n   * uniform vec3 czm_atmosphereMieCoefficient;\n   */\n  czm_atmosphereMieCoefficient: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.atmosphereMieCoefficient;\n    }\n  }),\n  /**\n   * An automatic uniform storign the Mie scale height used when computing atmosphere scattering.\n   *\n   * @example\n   * uniform float czm_atmosphereMieScaleHeight;\n   */\n  czm_atmosphereMieScaleHeight: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.atmosphereMieScaleHeight;\n    }\n  }),\n  /**\n   * An automatic uniform representing the anisotropy of the medium to consider for Mie scattering.\n   *\n   * @example\n   * uniform float czm_atmosphereAnisotropy;\n   */\n  czm_atmosphereMieAnisotropy: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.atmosphereMieAnisotropy;\n    }\n  }),\n  /**\n   * An automatic uniform representing which light source to use for dynamic lighting\n   *\n   * @example\n   * uniform float czm_atmosphereDynamicLighting\n   */\n  czm_atmosphereDynamicLighting: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.atmosphereDynamicLighting;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing the splitter position to use when rendering with a splitter.\n   * This will be in pixel coordinates relative to the canvas.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_splitPosition;\n   */\n  czm_splitPosition: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.splitPosition;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform scalar representing the geometric tolerance per meter\n   */\n  czm_geometricToleranceOverMeter: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.geometricToleranceOverMeter;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform representing the distance from the camera at which to disable the depth test of billboards, labels and points\n   * to, for example, prevent clipping against terrain. When set to zero, the depth test should always be applied. When less than zero,\n   * the depth test should never be applied.\n   */\n  czm_minimumDisableDepthTestDistance: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.minimumDisableDepthTestDistance;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform that will be the highlight color of unclassified 3D Tiles.\n   */\n  czm_invertClassificationColor: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC4,\n    getValue: function (uniformState) {\n      return uniformState.invertClassificationColor;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform that is used for gamma correction.\n   */\n  czm_gamma: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.gamma;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform that stores the ellipsoid radii.\n   */\n  czm_ellipsoidRadii: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.ellipsoid.radii;\n    }\n  }),\n  /**\n   * An automatic GLSL uniform that stores the ellipsoid inverse radii.\n   */\n  czm_ellipsoidInverseRadii: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.ellipsoid.oneOverRadii;\n    }\n  })\n};\nexport default AutomaticUniforms;","map":{"version":3,"names":["Cartesian3","Matrix4","WebGLConstants","viewerPositionWCScratch","AutomaticUniform","options","_size","size","_datatype","datatype","getValue","datatypeToGlsl","FLOAT","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","INT","INT_VEC2","INT_VEC3","INT_VEC4","BOOL","BOOL_VEC2","BOOL_VEC3","BOOL_VEC4","FLOAT_MAT2","FLOAT_MAT3","FLOAT_MAT4","SAMPLER_2D","SAMPLER_CUBE","prototype","getDeclaration","name","declaration","toString","AutomaticUniforms","czm_viewport","uniformState","viewportCartesian4","czm_viewportOrthographic","viewportOrthographic","czm_viewportTransformation","viewportTransformation","czm_globeDepthTexture","globeDepthTexture","czm_model","model","czm_inverseModel","inverseModel","czm_view","view","czm_view3D","view3D","czm_viewRotation","viewRotation","czm_viewRotation3D","viewRotation3D","czm_inverseView","inverseView","czm_inverseView3D","inverseView3D","czm_inverseViewRotation","inverseViewRotation","czm_inverseViewRotation3D","inverseViewRotation3D","czm_projection","projection","czm_inverseProjection","inverseProjection","czm_infiniteProjection","infiniteProjection","czm_modelView","modelView","czm_modelView3D","modelView3D","czm_modelViewRelativeToEye","modelViewRelativeToEye","czm_inverseModelView","inverseModelView","czm_inverseModelView3D","inverseModelView3D","czm_viewProjection","viewProjection","czm_inverseViewProjection","inverseViewProjection","czm_modelViewProjection","modelViewProjection","czm_inverseModelViewProjection","inverseModelViewProjection","czm_modelViewProjectionRelativeToEye","modelViewProjectionRelativeToEye","czm_modelViewInfiniteProjection","modelViewInfiniteProjection","czm_orthographicIn3D","orthographicIn3D","czm_normal","normal","czm_normal3D","normal3D","czm_inverseNormal","inverseNormal","czm_inverseNormal3D","inverseNormal3D","czm_eyeHeight","eyeHeight","czm_eyeHeight2D","eyeHeight2D","czm_eyeEllipsoidNormalEC","eyeEllipsoidNormalEC","czm_eyeEllipsoidCurvature","eyeEllipsoidCurvature","czm_modelToEnu","modelToEnu","czm_enuToModel","enuToModel","czm_entireFrustum","entireFrustum","czm_currentFrustum","currentFrustum","czm_frustumPlanes","frustumPlanes","czm_farDepthFromNearPlusOne","farDepthFromNearPlusOne","czm_log2FarDepthFromNearPlusOne","log2FarDepthFromNearPlusOne","czm_oneOverLog2FarDepthFromNearPlusOne","oneOverLog2FarDepthFromNearPlusOne","czm_sunPositionWC","sunPositionWC","czm_sunPositionColumbusView","sunPositionColumbusView","czm_sunDirectionEC","sunDirectionEC","czm_sunDirectionWC","sunDirectionWC","czm_moonDirectionEC","moonDirectionEC","czm_lightDirectionEC","lightDirectionEC","czm_lightDirectionWC","lightDirectionWC","czm_lightColor","lightColor","czm_lightColorHdr","lightColorHdr","czm_encodedCameraPositionMCHigh","encodedCameraPositionMCHigh","czm_encodedCameraPositionMCLow","encodedCameraPositionMCLow","czm_viewerPositionWC","getTranslation","czm_frameNumber","frameState","frameNumber","czm_morphTime","morphTime","czm_sceneMode","mode","czm_pass","pass","czm_backgroundColor","backgroundColor","czm_brdfLut","brdfLut","czm_environmentMap","environmentMap","czm_specularEnvironmentMaps","specularEnvironmentMaps","czm_specularEnvironmentMapsMaximumLOD","specularEnvironmentMapsMaximumLOD","czm_sphericalHarmonicCoefficients","sphericalHarmonicCoefficients","czm_temeToPseudoFixed","temeToPseudoFixedMatrix","czm_pixelRatio","pixelRatio","czm_fogDensity","fogDensity","czm_fogVisualDensityScalar","fogVisualDensityScalar","czm_fogMinimumBrightness","fogMinimumBrightness","czm_atmosphereHsbShift","atmosphereHsbShift","czm_atmosphereLightIntensity","atmosphereLightIntensity","czm_atmosphereRayleighCoefficient","atmosphereRayleighCoefficient","czm_atmosphereRayleighScaleHeight","atmosphereRayleighScaleHeight","czm_atmosphereMieCoefficient","atmosphereMieCoefficient","czm_atmosphereMieScaleHeight","atmosphereMieScaleHeight","czm_atmosphereMieAnisotropy","atmosphereMieAnisotropy","czm_atmosphereDynamicLighting","atmosphereDynamicLighting","czm_splitPosition","splitPosition","czm_geometricToleranceOverMeter","geometricToleranceOverMeter","czm_minimumDisableDepthTestDistance","minimumDisableDepthTestDistance","czm_invertClassificationColor","invertClassificationColor","czm_gamma","gamma","czm_ellipsoidRadii","ellipsoid","radii","czm_ellipsoidInverseRadii","oneOverRadii"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Renderer/AutomaticUniforms.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\n\nconst viewerPositionWCScratch = new Cartesian3();\n\nfunction AutomaticUniform(options) {\n  this._size = options.size;\n  this._datatype = options.datatype;\n  this.getValue = options.getValue;\n}\n\nconst datatypeToGlsl = {};\ndatatypeToGlsl[WebGLConstants.FLOAT] = \"float\";\ndatatypeToGlsl[WebGLConstants.FLOAT_VEC2] = \"vec2\";\ndatatypeToGlsl[WebGLConstants.FLOAT_VEC3] = \"vec3\";\ndatatypeToGlsl[WebGLConstants.FLOAT_VEC4] = \"vec4\";\ndatatypeToGlsl[WebGLConstants.INT] = \"int\";\ndatatypeToGlsl[WebGLConstants.INT_VEC2] = \"ivec2\";\ndatatypeToGlsl[WebGLConstants.INT_VEC3] = \"ivec3\";\ndatatypeToGlsl[WebGLConstants.INT_VEC4] = \"ivec4\";\ndatatypeToGlsl[WebGLConstants.BOOL] = \"bool\";\ndatatypeToGlsl[WebGLConstants.BOOL_VEC2] = \"bvec2\";\ndatatypeToGlsl[WebGLConstants.BOOL_VEC3] = \"bvec3\";\ndatatypeToGlsl[WebGLConstants.BOOL_VEC4] = \"bvec4\";\ndatatypeToGlsl[WebGLConstants.FLOAT_MAT2] = \"mat2\";\ndatatypeToGlsl[WebGLConstants.FLOAT_MAT3] = \"mat3\";\ndatatypeToGlsl[WebGLConstants.FLOAT_MAT4] = \"mat4\";\ndatatypeToGlsl[WebGLConstants.SAMPLER_2D] = \"sampler2D\";\ndatatypeToGlsl[WebGLConstants.SAMPLER_CUBE] = \"samplerCube\";\n\nAutomaticUniform.prototype.getDeclaration = function (name) {\n  let declaration = `uniform ${datatypeToGlsl[this._datatype]} ${name}`;\n\n  const size = this._size;\n  if (size === 1) {\n    declaration += \";\";\n  } else {\n    declaration += `[${size.toString()}];`;\n  }\n\n  return declaration;\n};\n\n/**\n * @private\n */\nconst AutomaticUniforms = {\n  /**\n   * An automatic GLSL uniform containing the viewport's <code>x</code>, <code>y</code>, <code>width</code>,\n   * and <code>height</code> properties in an <code>vec4</code>'s <code>x</code>, <code>y</code>, <code>z</code>,\n   * and <code>w</code> components, respectively.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec4 czm_viewport;\n   *\n   * // Scale the window coordinate components to [0, 1] by dividing\n   * // by the viewport's width and height.\n   * vec2 v = gl_FragCoord.xy / czm_viewport.zw;\n   *\n   * @see Context#getViewport\n   */\n  czm_viewport: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC4,\n    getValue: function (uniformState) {\n      return uniformState.viewportCartesian4;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 orthographic projection matrix that\n   * transforms window coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   * <br /><br />\n   * This transform is useful when a vertex shader inputs or manipulates window coordinates\n   * as done by {@link BillboardCollection}.\n   * <br /><br />\n   * Do not confuse {@link czm_viewportTransformation} with <code>czm_viewportOrthographic</code>.\n   * The former transforms from normalized device coordinates to window coordinates; the later transforms\n   * from window coordinates to clip coordinates, and is often used to assign to <code>gl_Position</code>.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_viewportOrthographic;\n   *\n   * // Example\n   * gl_Position = czm_viewportOrthographic * vec4(windowPosition, 0.0, 1.0);\n   *\n   * @see UniformState#viewportOrthographic\n   * @see czm_viewport\n   * @see czm_viewportTransformation\n   * @see BillboardCollection\n   */\n  czm_viewportOrthographic: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.viewportOrthographic;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 transformation matrix that\n   * transforms normalized device coordinates to window coordinates.  The context's\n   * full viewport is used, and the depth range is assumed to be <code>near = 0</code>\n   * and <code>far = 1</code>.\n   * <br /><br />\n   * This transform is useful when there is a need to manipulate window coordinates\n   * in a vertex shader as done by {@link BillboardCollection}.  In many cases,\n   * this matrix will not be used directly; instead, {@link czm_modelToWindowCoordinates}\n   * will be used to transform directly from model to window coordinates.\n   * <br /><br />\n   * Do not confuse <code>czm_viewportTransformation</code> with {@link czm_viewportOrthographic}.\n   * The former transforms from normalized device coordinates to window coordinates; the later transforms\n   * from window coordinates to clip coordinates, and is often used to assign to <code>gl_Position</code>.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_viewportTransformation;\n   *\n   * // Use czm_viewportTransformation as part of the\n   * // transform from model to window coordinates.\n   * vec4 q = czm_modelViewProjection * positionMC;               // model to clip coordinates\n   * q.xyz /= q.w;                                                // clip to normalized device coordinates (ndc)\n   * q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // ndc to window coordinates\n   *\n   * @see UniformState#viewportTransformation\n   * @see czm_viewport\n   * @see czm_viewportOrthographic\n   * @see czm_modelToWindowCoordinates\n   * @see BillboardCollection\n   */\n  czm_viewportTransformation: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.viewportTransformation;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the depth of the scene\n   * after the globe pass and then updated after the 3D Tiles pass.\n   * The depth is packed into an RGBA texture.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform sampler2D czm_globeDepthTexture;\n   *\n   * // Get the depth at the current fragment\n   * vec2 coords = gl_FragCoord.xy / czm_viewport.zw;\n   * float depth = czm_unpackDepth(texture(czm_globeDepthTexture, coords));\n   */\n  czm_globeDepthTexture: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.SAMPLER_2D,\n    getValue: function (uniformState) {\n      return uniformState.globeDepthTexture;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model transformation matrix that\n   * transforms model coordinates to world coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_model;\n   *\n   * // Example\n   * vec4 worldPosition = czm_model * modelPosition;\n   *\n   * @see UniformState#model\n   * @see czm_inverseModel\n   * @see czm_modelView\n   * @see czm_modelViewProjection\n   */\n  czm_model: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.model;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model transformation matrix that\n   * transforms world coordinates to model coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseModel;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModel * worldPosition;\n   *\n   * @see UniformState#inverseModel\n   * @see czm_model\n   * @see czm_inverseModelView\n   */\n  czm_inverseModel: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseModel;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 view transformation matrix that\n   * transforms world coordinates to eye coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_view;\n   *\n   * // Example\n   * vec4 eyePosition = czm_view * worldPosition;\n   *\n   * @see UniformState#view\n   * @see czm_viewRotation\n   * @see czm_modelView\n   * @see czm_viewProjection\n   * @see czm_modelViewProjection\n   * @see czm_inverseView\n   */\n  czm_view: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.view;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 view transformation matrix that\n   * transforms 3D world coordinates to eye coordinates.  In 3D mode, this is identical to\n   * {@link czm_view}, but in 2D and Columbus View it represents the view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_view3D;\n   *\n   * // Example\n   * vec4 eyePosition3D = czm_view3D * worldPosition3D;\n   *\n   * @see UniformState#view3D\n   * @see czm_view\n   */\n  czm_view3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.view3D;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 view rotation matrix that\n   * transforms vectors in world coordinates to eye coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_viewRotation;\n   *\n   * // Example\n   * vec3 eyeVector = czm_viewRotation * worldVector;\n   *\n   * @see UniformState#viewRotation\n   * @see czm_view\n   * @see czm_inverseView\n   * @see czm_inverseViewRotation\n   */\n  czm_viewRotation: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.viewRotation;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 view rotation matrix that\n   * transforms vectors in 3D world coordinates to eye coordinates.  In 3D mode, this is identical to\n   * {@link czm_viewRotation}, but in 2D and Columbus View it represents the view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_viewRotation3D;\n   *\n   * // Example\n   * vec3 eyeVector = czm_viewRotation3D * worldVector;\n   *\n   * @see UniformState#viewRotation3D\n   * @see czm_viewRotation\n   */\n  czm_viewRotation3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.viewRotation3D;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 transformation matrix that\n   * transforms from eye coordinates to world coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseView;\n   *\n   * // Example\n   * vec4 worldPosition = czm_inverseView * eyePosition;\n   *\n   * @see UniformState#inverseView\n   * @see czm_view\n   * @see czm_inverseNormal\n   */\n  czm_inverseView: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseView;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 transformation matrix that\n   * transforms from 3D eye coordinates to world coordinates.  In 3D mode, this is identical to\n   * {@link czm_inverseView}, but in 2D and Columbus View it represents the inverse view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseView3D;\n   *\n   * // Example\n   * vec4 worldPosition = czm_inverseView3D * eyePosition;\n   *\n   * @see UniformState#inverseView3D\n   * @see czm_inverseView\n   */\n  czm_inverseView3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseView3D;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 rotation matrix that\n   * transforms vectors from eye coordinates to world coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_inverseViewRotation;\n   *\n   * // Example\n   * vec4 worldVector = czm_inverseViewRotation * eyeVector;\n   *\n   * @see UniformState#inverseView\n   * @see czm_view\n   * @see czm_viewRotation\n   * @see czm_inverseViewRotation\n   */\n  czm_inverseViewRotation: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.inverseViewRotation;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 rotation matrix that\n   * transforms vectors from 3D eye coordinates to world coordinates.  In 3D mode, this is identical to\n   * {@link czm_inverseViewRotation}, but in 2D and Columbus View it represents the inverse view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_inverseViewRotation3D;\n   *\n   * // Example\n   * vec4 worldVector = czm_inverseViewRotation3D * eyeVector;\n   *\n   * @see UniformState#inverseView3D\n   * @see czm_inverseViewRotation\n   */\n  czm_inverseViewRotation3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.inverseViewRotation3D;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 projection transformation matrix that\n   * transforms eye coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_projection;\n   *\n   * // Example\n   * gl_Position = czm_projection * eyePosition;\n   *\n   * @see UniformState#projection\n   * @see czm_viewProjection\n   * @see czm_modelViewProjection\n   * @see czm_infiniteProjection\n   */\n  czm_projection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.projection;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 inverse projection transformation matrix that\n   * transforms from clip coordinates to eye coordinates. Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseProjection;\n   *\n   * // Example\n   * vec4 eyePosition = czm_inverseProjection * clipPosition;\n   *\n   * @see UniformState#inverseProjection\n   * @see czm_projection\n   */\n  czm_inverseProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseProjection;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 projection transformation matrix with the far plane at infinity,\n   * that transforms eye coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.  An infinite far plane is used\n   * in algorithms like shadow volumes and GPU ray casting with proxy geometry to ensure that triangles\n   * are not clipped by the far plane.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_infiniteProjection;\n   *\n   * // Example\n   * gl_Position = czm_infiniteProjection * eyePosition;\n   *\n   * @see UniformState#infiniteProjection\n   * @see czm_projection\n   * @see czm_modelViewInfiniteProjection\n   */\n  czm_infiniteProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.infiniteProjection;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that\n   * transforms model coordinates to eye coordinates.\n   * <br /><br />\n   * Positions should be transformed to eye coordinates using <code>czm_modelView</code> and\n   * normals should be transformed using {@link czm_normal}.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelView;\n   *\n   * // Example\n   * vec4 eyePosition = czm_modelView * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * vec4 eyePosition = czm_view * czm_model * modelPosition;\n   *\n   * @see UniformState#modelView\n   * @see czm_model\n   * @see czm_view\n   * @see czm_modelViewProjection\n   * @see czm_normal\n   */\n  czm_modelView: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelView;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that\n   * transforms 3D model coordinates to eye coordinates.  In 3D mode, this is identical to\n   * {@link czm_modelView}, but in 2D and Columbus View it represents the model-view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   * <br /><br />\n   * Positions should be transformed to eye coordinates using <code>czm_modelView3D</code> and\n   * normals should be transformed using {@link czm_normal3D}.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelView3D;\n   *\n   * // Example\n   * vec4 eyePosition = czm_modelView3D * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * vec4 eyePosition = czm_view3D * czm_model * modelPosition;\n   *\n   * @see UniformState#modelView3D\n   * @see czm_modelView\n   */\n  czm_modelView3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelView3D;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that\n   * transforms model coordinates, relative to the eye, to eye coordinates.  This is used\n   * in conjunction with {@link czm_translateRelativeToEye}.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelViewRelativeToEye;\n   *\n   * // Example\n   * attribute vec3 positionHigh;\n   * attribute vec3 positionLow;\n   *\n   * void main()\n   * {\n   *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n   *   gl_Position = czm_projection * (czm_modelViewRelativeToEye * p);\n   * }\n   *\n   * @see czm_modelViewProjectionRelativeToEye\n   * @see czm_translateRelativeToEye\n   * @see EncodedCartesian3\n   */\n  czm_modelViewRelativeToEye: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelViewRelativeToEye;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 transformation matrix that\n   * transforms from eye coordinates to model coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseModelView;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModelView * eyePosition;\n   *\n   * @see UniformState#inverseModelView\n   * @see czm_modelView\n   */\n  czm_inverseModelView: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseModelView;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 transformation matrix that\n   * transforms from eye coordinates to 3D model coordinates.  In 3D mode, this is identical to\n   * {@link czm_inverseModelView}, but in 2D and Columbus View it represents the inverse model-view matrix\n   * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseModelView3D;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModelView3D * eyePosition;\n   *\n   * @see UniformState#inverseModelView\n   * @see czm_inverseModelView\n   * @see czm_modelView3D\n   */\n  czm_inverseModelView3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseModelView3D;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that\n   * transforms world coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_viewProjection;\n   *\n   * // Example\n   * vec4 gl_Position = czm_viewProjection * czm_model * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * gl_Position = czm_projection * czm_view * czm_model * modelPosition;\n   *\n   * @see UniformState#viewProjection\n   * @see czm_view\n   * @see czm_projection\n   * @see czm_modelViewProjection\n   * @see czm_inverseViewProjection\n   */\n  czm_viewProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.viewProjection;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that\n   * transforms clip coordinates to world coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseViewProjection;\n   *\n   * // Example\n   * vec4 worldPosition = czm_inverseViewProjection * clipPosition;\n   *\n   * @see UniformState#inverseViewProjection\n   * @see czm_viewProjection\n   */\n  czm_inverseViewProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseViewProjection;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that\n   * transforms model coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelViewProjection;\n   *\n   * // Example\n   * vec4 gl_Position = czm_modelViewProjection * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * gl_Position = czm_projection * czm_view * czm_model * modelPosition;\n   *\n   * @see UniformState#modelViewProjection\n   * @see czm_model\n   * @see czm_view\n   * @see czm_projection\n   * @see czm_modelView\n   * @see czm_viewProjection\n   * @see czm_modelViewInfiniteProjection\n   * @see czm_inverseModelViewProjection\n   */\n  czm_modelViewProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelViewProjection;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 inverse model-view-projection transformation matrix that\n   * transforms clip coordinates to model coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_inverseModelViewProjection;\n   *\n   * // Example\n   * vec4 modelPosition = czm_inverseModelViewProjection * clipPosition;\n   *\n   * @see UniformState#modelViewProjection\n   * @see czm_modelViewProjection\n   */\n  czm_inverseModelViewProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.inverseModelViewProjection;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that\n   * transforms model coordinates, relative to the eye, to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.  This is used in\n   * conjunction with {@link czm_translateRelativeToEye}.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelViewProjectionRelativeToEye;\n   *\n   * // Example\n   * attribute vec3 positionHigh;\n   * attribute vec3 positionLow;\n   *\n   * void main()\n   * {\n   *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n   *   gl_Position = czm_modelViewProjectionRelativeToEye * p;\n   * }\n   *\n   * @see czm_modelViewRelativeToEye\n   * @see czm_translateRelativeToEye\n   * @see EncodedCartesian3\n   */\n  czm_modelViewProjectionRelativeToEye: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelViewProjectionRelativeToEye;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that\n   * transforms model coordinates to clip coordinates.  Clip coordinates is the\n   * coordinate system for a vertex shader's <code>gl_Position</code> output.  The projection matrix places\n   * the far plane at infinity.  This is useful in algorithms like shadow volumes and GPU ray casting with\n   * proxy geometry to ensure that triangles are not clipped by the far plane.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat4 czm_modelViewInfiniteProjection;\n   *\n   * // Example\n   * vec4 gl_Position = czm_modelViewInfiniteProjection * modelPosition;\n   *\n   * // The above is equivalent to, but more efficient than:\n   * gl_Position = czm_infiniteProjection * czm_view * czm_model * modelPosition;\n   *\n   * @see UniformState#modelViewInfiniteProjection\n   * @see czm_model\n   * @see czm_view\n   * @see czm_infiniteProjection\n   * @see czm_modelViewProjection\n   */\n  czm_modelViewInfiniteProjection: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelViewInfiniteProjection;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform that indicates if the current camera is orthographic in 3D.\n   *\n   * @see UniformState#orthographicIn3D\n   */\n  czm_orthographicIn3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.orthographicIn3D ? 1 : 0;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that\n   * transforms normal vectors in model coordinates to eye coordinates.\n   * <br /><br />\n   * Positions should be transformed to eye coordinates using {@link czm_modelView} and\n   * normals should be transformed using <code>czm_normal</code>.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_normal;\n   *\n   * // Example\n   * vec3 eyeNormal = czm_normal * normal;\n   *\n   * @see UniformState#normal\n   * @see czm_inverseNormal\n   * @see czm_modelView\n   */\n  czm_normal: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.normal;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that\n   * transforms normal vectors in 3D model coordinates to eye coordinates.\n   * In 3D mode, this is identical to\n   * {@link czm_normal}, but in 2D and Columbus View it represents the normal transformation\n   * matrix as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   * <br /><br />\n   * Positions should be transformed to eye coordinates using {@link czm_modelView3D} and\n   * normals should be transformed using <code>czm_normal3D</code>.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_normal3D;\n   *\n   * // Example\n   * vec3 eyeNormal = czm_normal3D * normal;\n   *\n   * @see UniformState#normal3D\n   * @see czm_normal\n   */\n  czm_normal3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.normal3D;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that\n   * transforms normal vectors in eye coordinates to model coordinates.  This is\n   * the opposite of the transform provided by {@link czm_normal}.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_inverseNormal;\n   *\n   * // Example\n   * vec3 normalMC = czm_inverseNormal * normalEC;\n   *\n   * @see UniformState#inverseNormal\n   * @see czm_normal\n   * @see czm_modelView\n   * @see czm_inverseView\n   */\n  czm_inverseNormal: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.inverseNormal;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 normal transformation matrix that\n   * transforms normal vectors in eye coordinates to 3D model coordinates.  This is\n   * the opposite of the transform provided by {@link czm_normal}.\n   * In 3D mode, this is identical to\n   * {@link czm_inverseNormal}, but in 2D and Columbus View it represents the inverse normal transformation\n   * matrix as if the camera were at an equivalent location in 3D mode.  This is useful for lighting\n   * 2D and Columbus View in the same way that 3D is lit.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_inverseNormal3D;\n   *\n   * // Example\n   * vec3 normalMC = czm_inverseNormal3D * normalEC;\n   *\n   * @see UniformState#inverseNormal3D\n   * @see czm_inverseNormal\n   */\n  czm_inverseNormal3D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.inverseNormal3D;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the height in meters of the\n   * eye (camera) above or below the ellipsoid.\n   *\n   * @see UniformState#eyeHeight\n   */\n  czm_eyeHeight: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.eyeHeight;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform containing height (<code>x</code>) and height squared (<code>y</code>)\n   * in meters of the eye (camera) above the 2D world plane. This uniform is only valid\n   * when the {@link SceneMode} is <code>SCENE2D</code>.\n   *\n   * @see UniformState#eyeHeight2D\n   */\n  czm_eyeHeight2D: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC2,\n    getValue: function (uniformState) {\n      return uniformState.eyeHeight2D;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the ellipsoid surface normal\n   * at the position below the eye (camera), in eye coordinates.\n   * This uniform is only valid when the {@link SceneMode} is <code>SCENE3D</code>.\n   */\n  czm_eyeEllipsoidNormalEC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.eyeEllipsoidNormalEC;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the ellipsoid radii of curvature at the camera position.\n   * The .x component is the prime vertical radius of curvature (east-west direction)\n   * .y is the meridional radius of curvature (north-south direction)\n   * This uniform is only valid when the {@link SceneMode} is <code>SCENE3D</code>.\n   */\n  czm_eyeEllipsoidCurvature: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC2,\n    getValue: function (uniformState) {\n      return uniformState.eyeEllipsoidCurvature;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the transform from model coordinates\n   * to an east-north-up coordinate system centered at the position on the\n   * ellipsoid below the camera.\n   * This uniform is only valid when the {@link SceneMode} is <code>SCENE3D</code>.\n   */\n  czm_modelToEnu: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.modelToEnu;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the the inverse of\n   * {@link AutomaticUniforms.czm_modelToEnu}.\n   * This uniform is only valid when the {@link SceneMode} is <code>SCENE3D</code>.\n   */\n  czm_enuToModel: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT4,\n    getValue: function (uniformState) {\n      return uniformState.enuToModel;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the near distance (<code>x</code>) and the far distance (<code>y</code>)\n   * of the frustum defined by the camera.  This is the largest possible frustum, not an individual\n   * frustum used for multi-frustum rendering.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec2 czm_entireFrustum;\n   *\n   * // Example\n   * float frustumLength = czm_entireFrustum.y - czm_entireFrustum.x;\n   *\n   * @see UniformState#entireFrustum\n   * @see czm_currentFrustum\n   */\n  czm_entireFrustum: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC2,\n    getValue: function (uniformState) {\n      return uniformState.entireFrustum;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the near distance (<code>x</code>) and the far distance (<code>y</code>)\n   * of the frustum defined by the camera.  This is the individual\n   * frustum used for multi-frustum rendering.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec2 czm_currentFrustum;\n   *\n   * // Example\n   * float frustumLength = czm_currentFrustum.y - czm_currentFrustum.x;\n   *\n   * @see UniformState#currentFrustum\n   * @see czm_entireFrustum\n   */\n  czm_currentFrustum: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC2,\n    getValue: function (uniformState) {\n      return uniformState.currentFrustum;\n    },\n  }),\n\n  /**\n   * The distances to the frustum planes. The top, bottom, left and right distances are\n   * the x, y, z, and w components, respectively.\n   */\n  czm_frustumPlanes: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC4,\n    getValue: function (uniformState) {\n      return uniformState.frustumPlanes;\n    },\n  }),\n\n  /**\n   * Gets the far plane's distance from the near plane, plus 1.0.\n   */\n  czm_farDepthFromNearPlusOne: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.farDepthFromNearPlusOne;\n    },\n  }),\n\n  /**\n   * Gets the log2 of {@link AutomaticUniforms#czm_farDepthFromNearPlusOne}.\n   */\n  czm_log2FarDepthFromNearPlusOne: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.log2FarDepthFromNearPlusOne;\n    },\n  }),\n\n  /**\n   * Gets 1.0 divided by {@link AutomaticUniforms#czm_log2FarDepthFromNearPlusOne}.\n   */\n  czm_oneOverLog2FarDepthFromNearPlusOne: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.oneOverLog2FarDepthFromNearPlusOne;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the sun position in world coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_sunPositionWC;\n   *\n   * @see UniformState#sunPositionWC\n   * @see czm_sunPositionColumbusView\n   * @see czm_sunDirectionWC\n   */\n  czm_sunPositionWC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.sunPositionWC;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the sun position in Columbus view world coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_sunPositionColumbusView;\n   *\n   * @see UniformState#sunPositionColumbusView\n   * @see czm_sunPositionWC\n   */\n  czm_sunPositionColumbusView: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.sunPositionColumbusView;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the normalized direction to the sun in eye coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_sunDirectionEC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_sunDirectionEC, normalEC), 0.0);\n   *\n   * @see UniformState#sunDirectionEC\n   * @see czm_moonDirectionEC\n   * @see czm_sunDirectionWC\n   */\n  czm_sunDirectionEC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.sunDirectionEC;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the normalized direction to the sun in world coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_sunDirectionWC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_sunDirectionWC, normalWC), 0.0);\n   *\n   * @see UniformState#sunDirectionWC\n   * @see czm_sunPositionWC\n   * @see czm_sunDirectionEC\n   */\n  czm_sunDirectionWC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.sunDirectionWC;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the normalized direction to the moon in eye coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_moonDirectionEC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_moonDirectionEC, normalEC), 0.0);\n   *\n   * @see UniformState#moonDirectionEC\n   * @see czm_sunDirectionEC\n   */\n  czm_moonDirectionEC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.moonDirectionEC;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the normalized direction to the scene's light source in eye coordinates.\n   * This is commonly used for directional lighting computations.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_lightDirectionEC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_lightDirectionEC, normalEC), 0.0);\n   *\n   * @see UniformState#lightDirectionEC\n   * @see czm_lightDirectionWC\n   */\n  czm_lightDirectionEC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.lightDirectionEC;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the normalized direction to the scene's light source in world coordinates.\n   * This is commonly used for directional lighting computations.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_lightDirectionWC;\n   *\n   * // Example\n   * float diffuse = max(dot(czm_lightDirectionWC, normalWC), 0.0);\n   *\n   * @see UniformState#lightDirectionWC\n   * @see czm_lightDirectionEC\n   */\n  czm_lightDirectionWC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.lightDirectionWC;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform that represents the color of light emitted by the scene's light source. This\n   * is equivalent to the light color multiplied by the light intensity limited to a maximum luminance of 1.0\n   * suitable for non-HDR lighting.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_lightColor;\n   *\n   * // Example\n   * vec3 diffuseColor = czm_lightColor * max(dot(czm_lightDirectionWC, normalWC), 0.0);\n   *\n   * @see UniformState#lightColor\n   * @see czm_lightColorHdr\n   */\n  czm_lightColor: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.lightColor;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform that represents the high dynamic range color of light emitted by the scene's light\n   * source. This is equivalent to the light color multiplied by the light intensity suitable for HDR lighting.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_lightColorHdr;\n   *\n   * // Example\n   * vec3 diffuseColor = czm_lightColorHdr * max(dot(czm_lightDirectionWC, normalWC), 0.0);\n   *\n   * @see UniformState#lightColorHdr\n   * @see czm_lightColor\n   */\n  czm_lightColorHdr: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.lightColorHdr;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the high bits of the camera position in model\n   * coordinates.  This is used for GPU RTE to eliminate jittering artifacts when rendering\n   * as described in {@link http://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_encodedCameraPositionMCHigh;\n   *\n   * @see czm_encodedCameraPositionMCLow\n   * @see czm_modelViewRelativeToEye\n   * @see czm_modelViewProjectionRelativeToEye\n   */\n  czm_encodedCameraPositionMCHigh: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.encodedCameraPositionMCHigh;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the low bits of the camera position in model\n   * coordinates.  This is used for GPU RTE to eliminate jittering artifacts when rendering\n   * as described in {@linkhttp://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_encodedCameraPositionMCLow;\n   *\n   * @see czm_encodedCameraPositionMCHigh\n   * @see czm_modelViewRelativeToEye\n   * @see czm_modelViewProjectionRelativeToEye\n   */\n  czm_encodedCameraPositionMCLow: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.encodedCameraPositionMCLow;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the position of the viewer (camera) in world coordinates.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3 czm_viewerPositionWC;\n   */\n  czm_viewerPositionWC: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return Matrix4.getTranslation(\n        uniformState.inverseView,\n        viewerPositionWCScratch,\n      );\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the frame number. This uniform is automatically incremented\n   * every frame.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_frameNumber;\n   */\n  czm_frameNumber: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.frameState.frameNumber;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the current morph transition time between\n   * 2D/Columbus View and 3D, with 0.0 being 2D or Columbus View and 1.0 being 3D.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_morphTime;\n   *\n   * // Example\n   * vec4 p = czm_columbusViewMorph(position2D, position3D, czm_morphTime);\n   */\n  czm_morphTime: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.frameState.morphTime;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the current {@link SceneMode}, expressed\n   * as a float.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_sceneMode;\n   *\n   * // Example\n   * if (czm_sceneMode == czm_sceneMode2D)\n   * {\n   *     eyeHeightSq = czm_eyeHeight2D.y;\n   * }\n   *\n   * @see czm_sceneMode2D\n   * @see czm_sceneModeColumbusView\n   * @see czm_sceneMode3D\n   * @see czm_sceneModeMorphing\n   */\n  czm_sceneMode: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.frameState.mode;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the current rendering pass.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_pass;\n   *\n   * // Example\n   * if ((czm_pass == czm_passTranslucent) && isOpaque())\n   * {\n   *     gl_Position *= 0.0; // Cull opaque geometry in the translucent pass\n   * }\n   */\n  czm_pass: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.pass;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the current scene background color.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec4 czm_backgroundColor;\n   *\n   * // Example: If the given color's RGB matches the background color, invert it.\n   * vec4 adjustColorForContrast(vec4 color)\n   * {\n   *     if (czm_backgroundColor.rgb == color.rgb)\n   *     {\n   *         color.rgb = vec3(1.0) - color.rgb;\n   *     }\n   *\n   *     return color;\n   * }\n   */\n  czm_backgroundColor: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC4,\n    getValue: function (uniformState) {\n      return uniformState.backgroundColor;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the BRDF look up texture used for image-based lighting computations.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform sampler2D czm_brdfLut;\n   *\n   * // Example: For a given roughness and NdotV value, find the material's BRDF information in the red and green channels\n   * float roughness = 0.5;\n   * float NdotV = dot(normal, view);\n   * vec2 brdfLut = texture(czm_brdfLut, vec2(NdotV, roughness)).rg;\n   */\n  czm_brdfLut: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.SAMPLER_2D,\n    getValue: function (uniformState) {\n      return uniformState.brdfLut;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the environment map used within the scene.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform samplerCube czm_environmentMap;\n   *\n   * // Example: Create a perfect reflection of the environment map on a  model\n   * float reflected = reflect(view, normal);\n   * vec4 reflectedColor = texture(czm_environmentMap, reflected);\n   */\n  czm_environmentMap: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.SAMPLER_CUBE,\n    getValue: function (uniformState) {\n      return uniformState.environmentMap;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the specular environment cube map used within the scene.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform samplerCube czm_specularEnvironmentMaps;\n   */\n  czm_specularEnvironmentMaps: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.SAMPLER_CUBE,\n    getValue: function (uniformState) {\n      return uniformState.specularEnvironmentMaps;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the maximum valid level-of-detail of the specular environment cube map used within the scene.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_specularEnvironmentMapsMaximumLOD;\n   */\n  czm_specularEnvironmentMapsMaximumLOD: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.specularEnvironmentMapsMaximumLOD;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform containing the spherical harmonic coefficients used within the scene.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform vec3[9] czm_sphericalHarmonicCoefficients;\n   */\n  czm_sphericalHarmonicCoefficients: new AutomaticUniform({\n    size: 9,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.sphericalHarmonicCoefficients;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing a 3x3 rotation matrix that transforms\n   * from True Equator Mean Equinox (TEME) axes to the pseudo-fixed axes at the current scene time.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform mat3 czm_temeToPseudoFixed;\n   *\n   * // Example\n   * vec3 pseudoFixed = czm_temeToPseudoFixed * teme;\n   *\n   * @see UniformState#temeToPseudoFixedMatrix\n   * @see Transforms.computeTemeToPseudoFixedMatrix\n   */\n  czm_temeToPseudoFixed: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_MAT3,\n    getValue: function (uniformState) {\n      return uniformState.temeToPseudoFixedMatrix;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the ratio of canvas coordinate space to canvas pixel space.\n   *\n   * @example\n   * uniform float czm_pixelRatio;\n   */\n  czm_pixelRatio: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.pixelRatio;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform scalar used to mix a color with the fog color based on the distance to the camera.\n   *\n   * @see czm_fog\n   */\n  czm_fogDensity: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.fogDensity;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform scalar used to mix a color with the fog color based on the distance to the camera.\n   *\n   * @see czm_fog\n   */\n  czm_fogVisualDensityScalar: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.fogVisualDensityScalar;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform scalar used to set a minimum brightness when dynamic lighting is applied to fog.\n   *\n   * @see czm_fog\n   */\n  czm_fogMinimumBrightness: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.fogMinimumBrightness;\n    },\n  }),\n\n  /**\n   * An automatic uniform representing the color shift for the atmosphere in HSB color space\n   *\n   * @example\n   * uniform vec3 czm_atmosphereHsbShift;\n   */\n  czm_atmosphereHsbShift: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.atmosphereHsbShift;\n    },\n  }),\n  /**\n   * An automatic uniform representing the intensity of the light that is used for computing the atmosphere color\n   *\n   * @example\n   * uniform float czm_atmosphereLightIntensity;\n   */\n  czm_atmosphereLightIntensity: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.atmosphereLightIntensity;\n    },\n  }),\n  /**\n   * An automatic uniform representing the Rayleigh scattering coefficient used when computing the atmosphere scattering\n   *\n   * @example\n   * uniform vec3 czm_atmosphereRayleighCoefficient;\n   */\n  czm_atmosphereRayleighCoefficient: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.atmosphereRayleighCoefficient;\n    },\n  }),\n  /**\n   * An automatic uniform representing the Rayleigh scale height in meters used for computing atmosphere scattering.\n   *\n   * @example\n   * uniform vec3 czm_atmosphereRayleighScaleHeight;\n   */\n  czm_atmosphereRayleighScaleHeight: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.atmosphereRayleighScaleHeight;\n    },\n  }),\n  /**\n   * An automatic uniform representing the Mie scattering coefficient used when computing atmosphere scattering.\n   *\n   * @example\n   * uniform vec3 czm_atmosphereMieCoefficient;\n   */\n  czm_atmosphereMieCoefficient: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.atmosphereMieCoefficient;\n    },\n  }),\n  /**\n   * An automatic uniform storign the Mie scale height used when computing atmosphere scattering.\n   *\n   * @example\n   * uniform float czm_atmosphereMieScaleHeight;\n   */\n  czm_atmosphereMieScaleHeight: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.atmosphereMieScaleHeight;\n    },\n  }),\n  /**\n   * An automatic uniform representing the anisotropy of the medium to consider for Mie scattering.\n   *\n   * @example\n   * uniform float czm_atmosphereAnisotropy;\n   */\n  czm_atmosphereMieAnisotropy: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.atmosphereMieAnisotropy;\n    },\n  }),\n\n  /**\n   * An automatic uniform representing which light source to use for dynamic lighting\n   *\n   * @example\n   * uniform float czm_atmosphereDynamicLighting\n   */\n  czm_atmosphereDynamicLighting: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.atmosphereDynamicLighting;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the splitter position to use when rendering with a splitter.\n   * This will be in pixel coordinates relative to the canvas.\n   *\n   * @example\n   * // GLSL declaration\n   * uniform float czm_splitPosition;\n   */\n  czm_splitPosition: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.splitPosition;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform scalar representing the geometric tolerance per meter\n   */\n  czm_geometricToleranceOverMeter: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.geometricToleranceOverMeter;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform representing the distance from the camera at which to disable the depth test of billboards, labels and points\n   * to, for example, prevent clipping against terrain. When set to zero, the depth test should always be applied. When less than zero,\n   * the depth test should never be applied.\n   */\n  czm_minimumDisableDepthTestDistance: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.minimumDisableDepthTestDistance;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform that will be the highlight color of unclassified 3D Tiles.\n   */\n  czm_invertClassificationColor: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC4,\n    getValue: function (uniformState) {\n      return uniformState.invertClassificationColor;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform that is used for gamma correction.\n   */\n  czm_gamma: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT,\n    getValue: function (uniformState) {\n      return uniformState.gamma;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform that stores the ellipsoid radii.\n   */\n  czm_ellipsoidRadii: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.ellipsoid.radii;\n    },\n  }),\n\n  /**\n   * An automatic GLSL uniform that stores the ellipsoid inverse radii.\n   */\n  czm_ellipsoidInverseRadii: new AutomaticUniform({\n    size: 1,\n    datatype: WebGLConstants.FLOAT_VEC3,\n    getValue: function (uniformState) {\n      return uniformState.ellipsoid.oneOverRadii;\n    },\n  }),\n};\nexport default AutomaticUniforms;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}