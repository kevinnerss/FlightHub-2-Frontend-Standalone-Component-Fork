{"ast":null,"code":"import defined from \"../../Core/defined.js\";\n\n/**\n * The node statistics update stage updates memory usage statistics for a Model\n * on the node level. This counts the binary resources that exist for the\n * lifetime of the Model (e.g. attributes loaded by GltfLoader). It does not\n * count resources that are created every time the pipeline is run.\n * The individual pipeline stages are responsible for keeping track of any\n * additional memory they allocate.\n *\n * @namespace NodeStatisticsPipelineStage\n *\n * @private\n */\nconst NodeStatisticsPipelineStage = {\n  name: \"NodeStatisticsPipelineStage\",\n  // Helps with debugging\n\n  // Expose some methods for testing\n  _countInstancingAttributes: countInstancingAttributes,\n  _countGeneratedBuffers: countGeneratedBuffers\n};\nNodeStatisticsPipelineStage.process = function (renderResources, node, frameState) {\n  const statistics = renderResources.model.statistics;\n  const instances = node.instances;\n  const runtimeNode = renderResources.runtimeNode;\n  countInstancingAttributes(statistics, instances);\n  countGeneratedBuffers(statistics, runtimeNode);\n};\nfunction countInstancingAttributes(statistics, instances) {\n  if (!defined(instances)) {\n    return;\n  }\n  const attributes = instances.attributes;\n  const length = attributes.length;\n  for (let i = 0; i < length; i++) {\n    const attribute = attributes[i];\n    if (defined(attribute.buffer)) {\n      // Any typed arrays should have been unloaded before this stage.\n      const hasCpuCopy = false;\n      statistics.addBuffer(attribute.buffer, hasCpuCopy);\n    }\n  }\n}\nfunction countGeneratedBuffers(statistics, runtimeNode) {\n  if (defined(runtimeNode.instancingTransformsBuffer)) {\n    // The typed array containing the computed transforms isn't saved\n    // after the buffer is created.\n    const hasCpuCopy = false;\n    statistics.addBuffer(runtimeNode.instancingTransformsBuffer, hasCpuCopy);\n  }\n  if (defined(runtimeNode.instancingTransformsBuffer2D)) {\n    // The typed array containing the computed 2D transforms isn't saved\n    // after the buffer is created.\n    const hasCpuCopy = false;\n    statistics.addBuffer(runtimeNode.instancingTransformsBuffer2D, hasCpuCopy);\n  }\n  if (defined(runtimeNode.instancingTranslationBuffer2D)) {\n    // The typed array containing the computed 2D translations isn't saved\n    // after the buffer is created.\n    const hasCpuCopy = false;\n    statistics.addBuffer(runtimeNode.instancingTranslationBuffer2D, hasCpuCopy);\n  }\n}\nexport default NodeStatisticsPipelineStage;","map":{"version":3,"names":["defined","NodeStatisticsPipelineStage","name","_countInstancingAttributes","countInstancingAttributes","_countGeneratedBuffers","countGeneratedBuffers","process","renderResources","node","frameState","statistics","model","instances","runtimeNode","attributes","length","i","attribute","buffer","hasCpuCopy","addBuffer","instancingTransformsBuffer","instancingTransformsBuffer2D","instancingTranslationBuffer2D"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Model/NodeStatisticsPipelineStage.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\n\n/**\n * The node statistics update stage updates memory usage statistics for a Model\n * on the node level. This counts the binary resources that exist for the\n * lifetime of the Model (e.g. attributes loaded by GltfLoader). It does not\n * count resources that are created every time the pipeline is run.\n * The individual pipeline stages are responsible for keeping track of any\n * additional memory they allocate.\n *\n * @namespace NodeStatisticsPipelineStage\n *\n * @private\n */\nconst NodeStatisticsPipelineStage = {\n  name: \"NodeStatisticsPipelineStage\", // Helps with debugging\n\n  // Expose some methods for testing\n  _countInstancingAttributes: countInstancingAttributes,\n  _countGeneratedBuffers: countGeneratedBuffers,\n};\n\nNodeStatisticsPipelineStage.process = function (\n  renderResources,\n  node,\n  frameState,\n) {\n  const statistics = renderResources.model.statistics;\n  const instances = node.instances;\n  const runtimeNode = renderResources.runtimeNode;\n\n  countInstancingAttributes(statistics, instances);\n  countGeneratedBuffers(statistics, runtimeNode);\n};\n\nfunction countInstancingAttributes(statistics, instances) {\n  if (!defined(instances)) {\n    return;\n  }\n\n  const attributes = instances.attributes;\n  const length = attributes.length;\n  for (let i = 0; i < length; i++) {\n    const attribute = attributes[i];\n    if (defined(attribute.buffer)) {\n      // Any typed arrays should have been unloaded before this stage.\n      const hasCpuCopy = false;\n      statistics.addBuffer(attribute.buffer, hasCpuCopy);\n    }\n  }\n}\n\nfunction countGeneratedBuffers(statistics, runtimeNode) {\n  if (defined(runtimeNode.instancingTransformsBuffer)) {\n    // The typed array containing the computed transforms isn't saved\n    // after the buffer is created.\n    const hasCpuCopy = false;\n    statistics.addBuffer(runtimeNode.instancingTransformsBuffer, hasCpuCopy);\n  }\n  if (defined(runtimeNode.instancingTransformsBuffer2D)) {\n    // The typed array containing the computed 2D transforms isn't saved\n    // after the buffer is created.\n    const hasCpuCopy = false;\n    statistics.addBuffer(runtimeNode.instancingTransformsBuffer2D, hasCpuCopy);\n  }\n\n  if (defined(runtimeNode.instancingTranslationBuffer2D)) {\n    // The typed array containing the computed 2D translations isn't saved\n    // after the buffer is created.\n    const hasCpuCopy = false;\n    statistics.addBuffer(runtimeNode.instancingTranslationBuffer2D, hasCpuCopy);\n  }\n}\n\nexport default NodeStatisticsPipelineStage;\n"],"mappings":"AAAA,OAAOA,OAAO,MAAM,uBAAuB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,2BAA2B,GAAG;EAClCC,IAAI,EAAE,6BAA6B;EAAE;;EAErC;EACAC,0BAA0B,EAAEC,yBAAyB;EACrDC,sBAAsB,EAAEC;AAC1B,CAAC;AAEDL,2BAA2B,CAACM,OAAO,GAAG,UACpCC,eAAe,EACfC,IAAI,EACJC,UAAU,EACV;EACA,MAAMC,UAAU,GAAGH,eAAe,CAACI,KAAK,CAACD,UAAU;EACnD,MAAME,SAAS,GAAGJ,IAAI,CAACI,SAAS;EAChC,MAAMC,WAAW,GAAGN,eAAe,CAACM,WAAW;EAE/CV,yBAAyB,CAACO,UAAU,EAAEE,SAAS,CAAC;EAChDP,qBAAqB,CAACK,UAAU,EAAEG,WAAW,CAAC;AAChD,CAAC;AAED,SAASV,yBAAyBA,CAACO,UAAU,EAAEE,SAAS,EAAE;EACxD,IAAI,CAACb,OAAO,CAACa,SAAS,CAAC,EAAE;IACvB;EACF;EAEA,MAAME,UAAU,GAAGF,SAAS,CAACE,UAAU;EACvC,MAAMC,MAAM,GAAGD,UAAU,CAACC,MAAM;EAChC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,EAAEC,CAAC,EAAE,EAAE;IAC/B,MAAMC,SAAS,GAAGH,UAAU,CAACE,CAAC,CAAC;IAC/B,IAAIjB,OAAO,CAACkB,SAAS,CAACC,MAAM,CAAC,EAAE;MAC7B;MACA,MAAMC,UAAU,GAAG,KAAK;MACxBT,UAAU,CAACU,SAAS,CAACH,SAAS,CAACC,MAAM,EAAEC,UAAU,CAAC;IACpD;EACF;AACF;AAEA,SAASd,qBAAqBA,CAACK,UAAU,EAAEG,WAAW,EAAE;EACtD,IAAId,OAAO,CAACc,WAAW,CAACQ,0BAA0B,CAAC,EAAE;IACnD;IACA;IACA,MAAMF,UAAU,GAAG,KAAK;IACxBT,UAAU,CAACU,SAAS,CAACP,WAAW,CAACQ,0BAA0B,EAAEF,UAAU,CAAC;EAC1E;EACA,IAAIpB,OAAO,CAACc,WAAW,CAACS,4BAA4B,CAAC,EAAE;IACrD;IACA;IACA,MAAMH,UAAU,GAAG,KAAK;IACxBT,UAAU,CAACU,SAAS,CAACP,WAAW,CAACS,4BAA4B,EAAEH,UAAU,CAAC;EAC5E;EAEA,IAAIpB,OAAO,CAACc,WAAW,CAACU,6BAA6B,CAAC,EAAE;IACtD;IACA;IACA,MAAMJ,UAAU,GAAG,KAAK;IACxBT,UAAU,CAACU,SAAS,CAACP,WAAW,CAACU,6BAA6B,EAAEJ,UAAU,CAAC;EAC7E;AACF;AAEA,eAAenB,2BAA2B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}