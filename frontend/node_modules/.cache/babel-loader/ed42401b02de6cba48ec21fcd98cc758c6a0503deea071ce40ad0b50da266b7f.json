{"ast":null,"code":"import { isDigitChar, isAsciiLetterChar, isAlphaNumericOrMarkChar, isUrlSuffixAllowedSpecialChar, isUrlSuffixNotAllowedAsFinalChar } from '../char-utils';\nimport { tldRegex } from './known-tlds';\n/**\n * Regular expression to match an http:// or https:// scheme.\n */\nexport var httpSchemeRe = /https?:\\/\\//i;\n/**\n * Regular expression to match an http:// or https:// scheme as the prefix of\n * a string.\n */\nexport var httpSchemePrefixRe = new RegExp('^' + httpSchemeRe.source, 'i');\n/**\n * A regular expression used to determine the schemes we should not autolink\n */\nexport var invalidSchemeRe = /^(javascript|vbscript):/i;\n// A regular expression used to determine if the URL is a scheme match (such as\n// 'http://google.com', and as opposed to a \"TLD match\"). This regular\n// expression is used to parse out the host along with if the URL has an\n// authority component (i.e. '//')\n//\n// Capturing groups:\n//    1. '//' if the URL has an authority component, empty string otherwise\n//    2. The host (if one exists). Ex: 'google.com'\n//\n// See https://www.rfc-editor.org/rfc/rfc3986#appendix-A for terminology\nexport var schemeUrlRe = /^[A-Za-z][-.+A-Za-z0-9]*:(\\/\\/)?([^:/]*)/;\n// A regular expression used to determine if the URL is a TLD match (such as\n// 'google.com', and as opposed to a \"scheme match\"). This regular\n// expression is used to help parse out the TLD (top-level domain) of the host.\n//\n// See https://www.rfc-editor.org/rfc/rfc3986#appendix-A for terminology\nexport var tldUrlHostRe = /^(?:\\/\\/)?([^/#?:]+)/; // optionally prefixed with protocol-relative '//' chars\n/**\n * Determines if the given character code represents a character that may start\n * a scheme (ex: the 'h' in 'http')\n */\nexport var isSchemeStartChar = isAsciiLetterChar; // Equivalent to checking the RegExp `/[A-Za-z]/`, but aliased for clarity and maintainability\n/**\n * Determines if the given character is a valid character in a scheme (such as\n * 'http' or 'ssh+git'), but only after the start char (which is handled by\n * {@link isSchemeStartChar}.\n */\nexport function isSchemeChar(charCode) {\n  return isAsciiLetterChar(charCode) || isDigitChar(charCode) || charCode === 43 /* Char.Plus */ ||\n  // '+'\n  charCode === 45 /* Char.Dash */ ||\n  // '-'\n  charCode === 46 /* Char.Dot */ // '.'\n  ;\n}\n/**\n * Determines if the character can begin a domain label, which must be an\n * alphanumeric character and not an underscore or dash.\n *\n * A domain label is a segment of a hostname such as subdomain.google.com.\n */\nexport var isDomainLabelStartChar = isAlphaNumericOrMarkChar; // alias function for clarity\n/**\n * Determines if the character is part of a domain label (but not a domain label\n * start character).\n *\n * A domain label is a segment of a hostname such as subdomain.google.com.\n */\nexport function isDomainLabelChar(charCode) {\n  return charCode === 95 /* Char.Underscore */ || isDomainLabelStartChar(charCode);\n}\n/**\n * Determines if the character is a path character (\"pchar\") as defined by\n * https://tools.ietf.org/html/rfc3986#appendix-A\n *\n *     pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n *\n *     unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n *     pct-encoded   = \"%\" HEXDIG HEXDIG\n *     sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n *                   / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n *\n * Note that this implementation doesn't follow the spec exactly, but rather\n * follows URL path characters found out in the wild (spec might be out of date?)\n */\nexport function isPathChar(charCode) {\n  return isAlphaNumericOrMarkChar(charCode) || isUrlSuffixAllowedSpecialChar(charCode) || isUrlSuffixNotAllowedAsFinalChar(charCode) // characters in addition to those allowed by isUrlSuffixAllowedSpecialChar()\n  ;\n}\n/**\n * Determines if the character given may begin the \"URL Suffix\" section of a\n * URI (i.e. the path, query, or hash section). These are the '/', '?' and '#'\n * characters.\n *\n * See https://tools.ietf.org/html/rfc3986#appendix-A\n */\nexport function isUrlSuffixStartChar(charCode) {\n  return charCode === 47 /* Char.Slash */ ||\n  // '/'\n  charCode === 63 /* Char.Question */ ||\n  // '?'\n  charCode === 35 /* Char.NumberSign */ // '#'\n  ;\n}\n/**\n * Determines if the top-level domain (TLD) read in the host is a known TLD.\n *\n * Example: 'com' would be a known TLD (for a host of 'google.com'), but\n * 'local' would not (for a domain name of 'my-computer.local').\n */\nexport function isKnownTld(tld) {\n  return tldRegex.test(tld.toLowerCase()); // make sure the tld is lowercase for the regex\n}\n/**\n * Determines if the given `url` is a valid scheme-prefixed URL.\n */\nexport function isValidSchemeUrl(url) {\n  // If the scheme is 'javascript:' or 'vbscript:', these link\n  // types can be dangerous. Don't link them.\n  if (invalidSchemeRe.test(url)) {\n    return false;\n  }\n  var schemeMatch = url.match(schemeUrlRe);\n  if (!schemeMatch) {\n    return false;\n  }\n  var isAuthorityMatch = !!schemeMatch[1];\n  var host = schemeMatch[2];\n  if (isAuthorityMatch) {\n    // Any match that has an authority ('//' chars) after the scheme is\n    // valid, such as 'http://anything'\n    return true;\n  }\n  // If there's no authority ('//' chars), check that we have a hostname\n  // that looks valid.\n  //\n  // The host must contain at least one '.' char and have a domain label\n  // with at least one letter to be considered valid.\n  //\n  // Accept:\n  //   - git:domain.com (scheme followed by a host\n  // Do not accept:\n  //   - git:something ('something' doesn't look like a host)\n  //   - version:1.0   ('1.0' doesn't look like a host)\n  if (host.indexOf('.') === -1 || !/[A-Za-z]/.test(host)) {\n    // `letterRe` RegExp checks for a letter anywhere in the host string\n    return false;\n  }\n  return true;\n}\n/**\n * Determines if the given `url` is a match with a valid TLD.\n */\nexport function isValidTldMatch(url) {\n  // TLD URL such as 'google.com', we need to confirm that we have a valid\n  // top-level domain\n  var tldUrlHostMatch = url.match(tldUrlHostRe);\n  if (!tldUrlHostMatch) {\n    // At this point, if the URL didn't match our TLD re, it must be invalid\n    // (highly unlikely to happen, but just in case)\n    return false;\n  }\n  var host = tldUrlHostMatch[0];\n  var hostLabels = host.split('.');\n  if (hostLabels.length < 2) {\n    // 0 or 1 host label, there's no TLD. Ex: 'localhost'\n    return false;\n  }\n  var tld = hostLabels[hostLabels.length - 1];\n  if (!isKnownTld(tld)) {\n    return false;\n  }\n  // TODO: Implement these conditions for TLD matcher:\n  // (\n  //     this.longestDomainLabelLength <= 63 &&\n  //     this.domainNameLength <= 255\n  // );\n  return true;\n}\n// Regular expression to confirm a valid IPv4 address (ex: '192.168.0.1')\n// TODO: encode this into the state machine so that we don't need to run this\n//       regexp separately to confirm the match\nvar ipV4Re = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;\n// Regular expression used to split the IPv4 address itself from any port/path/query/hash\nvar ipV4PartRe = /[:/?#]/;\n/**\n * Determines if the given URL is a valid IPv4-prefixed URL.\n */\nexport function isValidIpV4Address(url) {\n  // Grab just the IP address\n  var ipV4Part = url.split(ipV4PartRe, 1)[0]; // only 1 result needed\n  return ipV4Re.test(ipV4Part);\n}","map":{"version":3,"names":["isDigitChar","isAsciiLetterChar","isAlphaNumericOrMarkChar","isUrlSuffixAllowedSpecialChar","isUrlSuffixNotAllowedAsFinalChar","tldRegex","httpSchemeRe","httpSchemePrefixRe","RegExp","source","invalidSchemeRe","schemeUrlRe","tldUrlHostRe","isSchemeStartChar","isSchemeChar","charCode","isDomainLabelStartChar","isDomainLabelChar","isPathChar","isUrlSuffixStartChar","isKnownTld","tld","test","toLowerCase","isValidSchemeUrl","url","schemeMatch","match","isAuthorityMatch","host","indexOf","isValidTldMatch","tldUrlHostMatch","hostLabels","split","length","ipV4Re","ipV4PartRe","isValidIpV4Address","ipV4Part"],"sources":["../../../src/parser/uri-utils.ts"],"sourcesContent":["import { Char } from '../char';\nimport {\n    isDigitChar,\n    isAsciiLetterChar,\n    isAlphaNumericOrMarkChar,\n    isUrlSuffixAllowedSpecialChar,\n    isUrlSuffixNotAllowedAsFinalChar,\n} from '../char-utils';\nimport { tldRegex } from './known-tlds';\n\n/**\n * Regular expression to match an http:// or https:// scheme.\n */\nexport const httpSchemeRe = /https?:\\/\\//i;\n\n/**\n * Regular expression to match an http:// or https:// scheme as the prefix of\n * a string.\n */\nexport const httpSchemePrefixRe = new RegExp('^' + httpSchemeRe.source, 'i');\n\n/**\n * A regular expression used to determine the schemes we should not autolink\n */\nexport const invalidSchemeRe = /^(javascript|vbscript):/i;\n\n// A regular expression used to determine if the URL is a scheme match (such as\n// 'http://google.com', and as opposed to a \"TLD match\"). This regular\n// expression is used to parse out the host along with if the URL has an\n// authority component (i.e. '//')\n//\n// Capturing groups:\n//    1. '//' if the URL has an authority component, empty string otherwise\n//    2. The host (if one exists). Ex: 'google.com'\n//\n// See https://www.rfc-editor.org/rfc/rfc3986#appendix-A for terminology\nexport const schemeUrlRe = /^[A-Za-z][-.+A-Za-z0-9]*:(\\/\\/)?([^:/]*)/;\n\n// A regular expression used to determine if the URL is a TLD match (such as\n// 'google.com', and as opposed to a \"scheme match\"). This regular\n// expression is used to help parse out the TLD (top-level domain) of the host.\n//\n// See https://www.rfc-editor.org/rfc/rfc3986#appendix-A for terminology\nexport const tldUrlHostRe = /^(?:\\/\\/)?([^/#?:]+)/; // optionally prefixed with protocol-relative '//' chars\n\n/**\n * Determines if the given character code represents a character that may start\n * a scheme (ex: the 'h' in 'http')\n */\nexport const isSchemeStartChar: (code: number) => boolean = isAsciiLetterChar; // Equivalent to checking the RegExp `/[A-Za-z]/`, but aliased for clarity and maintainability\n\n/**\n * Determines if the given character is a valid character in a scheme (such as\n * 'http' or 'ssh+git'), but only after the start char (which is handled by\n * {@link isSchemeStartChar}.\n */\nexport function isSchemeChar(charCode: number): boolean {\n    return (\n        isAsciiLetterChar(charCode) ||\n        isDigitChar(charCode) ||\n        charCode === Char.Plus || // '+'\n        charCode === Char.Dash || // '-'\n        charCode === Char.Dot // '.'\n    );\n}\n\n/**\n * Determines if the character can begin a domain label, which must be an\n * alphanumeric character and not an underscore or dash.\n *\n * A domain label is a segment of a hostname such as subdomain.google.com.\n */\nexport const isDomainLabelStartChar: (charCode: number) => boolean = isAlphaNumericOrMarkChar; // alias function for clarity\n\n/**\n * Determines if the character is part of a domain label (but not a domain label\n * start character).\n *\n * A domain label is a segment of a hostname such as subdomain.google.com.\n */\nexport function isDomainLabelChar(charCode: number): boolean {\n    return charCode === Char.Underscore || isDomainLabelStartChar(charCode);\n}\n\n/**\n * Determines if the character is a path character (\"pchar\") as defined by\n * https://tools.ietf.org/html/rfc3986#appendix-A\n *\n *     pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n *\n *     unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n *     pct-encoded   = \"%\" HEXDIG HEXDIG\n *     sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n *                   / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n *\n * Note that this implementation doesn't follow the spec exactly, but rather\n * follows URL path characters found out in the wild (spec might be out of date?)\n */\nexport function isPathChar(charCode: number): boolean {\n    return (\n        isAlphaNumericOrMarkChar(charCode) ||\n        isUrlSuffixAllowedSpecialChar(charCode) ||\n        isUrlSuffixNotAllowedAsFinalChar(charCode) // characters in addition to those allowed by isUrlSuffixAllowedSpecialChar()\n    );\n}\n\n/**\n * Determines if the character given may begin the \"URL Suffix\" section of a\n * URI (i.e. the path, query, or hash section). These are the '/', '?' and '#'\n * characters.\n *\n * See https://tools.ietf.org/html/rfc3986#appendix-A\n */\nexport function isUrlSuffixStartChar(charCode: number): boolean {\n    return (\n        charCode === Char.Slash || // '/'\n        charCode === Char.Question || // '?'\n        charCode === Char.NumberSign // '#'\n    );\n}\n\n/**\n * Determines if the top-level domain (TLD) read in the host is a known TLD.\n *\n * Example: 'com' would be a known TLD (for a host of 'google.com'), but\n * 'local' would not (for a domain name of 'my-computer.local').\n */\nexport function isKnownTld(tld: string) {\n    return tldRegex.test(tld.toLowerCase()); // make sure the tld is lowercase for the regex\n}\n\n/**\n * Determines if the given `url` is a valid scheme-prefixed URL.\n */\nexport function isValidSchemeUrl(url: string): boolean {\n    // If the scheme is 'javascript:' or 'vbscript:', these link\n    // types can be dangerous. Don't link them.\n    if (invalidSchemeRe.test(url)) {\n        return false;\n    }\n\n    const schemeMatch = url.match(schemeUrlRe);\n    if (!schemeMatch) {\n        return false;\n    }\n\n    const isAuthorityMatch = !!schemeMatch![1];\n    const host = schemeMatch![2];\n    if (isAuthorityMatch) {\n        // Any match that has an authority ('//' chars) after the scheme is\n        // valid, such as 'http://anything'\n        return true;\n    }\n\n    // If there's no authority ('//' chars), check that we have a hostname\n    // that looks valid.\n    //\n    // The host must contain at least one '.' char and have a domain label\n    // with at least one letter to be considered valid.\n    //\n    // Accept:\n    //   - git:domain.com (scheme followed by a host\n    // Do not accept:\n    //   - git:something ('something' doesn't look like a host)\n    //   - version:1.0   ('1.0' doesn't look like a host)\n    if (host.indexOf('.') === -1 || !/[A-Za-z]/.test(host)) {\n        // `letterRe` RegExp checks for a letter anywhere in the host string\n        return false;\n    }\n    return true;\n}\n\n/**\n * Determines if the given `url` is a match with a valid TLD.\n */\nexport function isValidTldMatch(url: string): boolean {\n    // TLD URL such as 'google.com', we need to confirm that we have a valid\n    // top-level domain\n    const tldUrlHostMatch = url.match(tldUrlHostRe);\n    if (!tldUrlHostMatch) {\n        // At this point, if the URL didn't match our TLD re, it must be invalid\n        // (highly unlikely to happen, but just in case)\n        return false;\n    }\n\n    const host = tldUrlHostMatch[0];\n    const hostLabels = host.split('.');\n    if (hostLabels.length < 2) {\n        // 0 or 1 host label, there's no TLD. Ex: 'localhost'\n        return false;\n    }\n\n    const tld = hostLabels[hostLabels.length - 1];\n    if (!isKnownTld(tld)) {\n        return false;\n    }\n\n    // TODO: Implement these conditions for TLD matcher:\n    // (\n    //     this.longestDomainLabelLength <= 63 &&\n    //     this.domainNameLength <= 255\n    // );\n\n    return true;\n}\n\n// Regular expression to confirm a valid IPv4 address (ex: '192.168.0.1')\n// TODO: encode this into the state machine so that we don't need to run this\n//       regexp separately to confirm the match\nconst ipV4Re =\n    /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;\n\n// Regular expression used to split the IPv4 address itself from any port/path/query/hash\nconst ipV4PartRe = /[:/?#]/;\n\n/**\n * Determines if the given URL is a valid IPv4-prefixed URL.\n */\nexport function isValidIpV4Address(url: string): boolean {\n    // Grab just the IP address\n    const ipV4Part = url.split(ipV4PartRe, 1)[0]; // only 1 result needed\n\n    return ipV4Re.test(ipV4Part);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}