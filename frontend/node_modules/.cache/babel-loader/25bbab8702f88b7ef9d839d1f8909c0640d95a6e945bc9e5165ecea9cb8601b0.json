{"ast":null,"code":"import defined from \"../../Core/defined.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport Matrix3 from \"../../Core/Matrix3.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport MaterialStageFS from \"../../Shaders/Model/MaterialStageFS.js\";\nimport AlphaMode from \"../AlphaMode.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport LightingModel from \"./LightingModel.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nconst {\n  Material,\n  MetallicRoughness,\n  SpecularGlossiness,\n  Specular,\n  Clearcoat\n} = ModelComponents;\n\n/**\n * The material pipeline stage processes textures and other uniforms needed\n * to render a primitive. This handles the following material types:\n * <ul>\n *   <li>Basic glTF materials (PBR metallic roughness model)</li>\n *   <li>The `KHR_materials_specular` glTF extension</li>\n *   <li>The `KHR_materials_pbrSpecularGlossiness` glTF extension</li>\n *   <li>The `KHR_materials_unlit` glTF extension</li>\n * </ul>\n *\n * @namespace MaterialPipelineStage\n *\n * @private\n */\nconst MaterialPipelineStage = {\n  name: \"MaterialPipelineStage\",\n  // Helps with debugging\n\n  // Expose some methods for testing\n  _processTexture: processTexture,\n  _processTextureTransform: processTextureTransform\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render\n * resources:\n * <ul>\n *   <li>Modifies the shader to include the material processing stage</li>\n *   <li>Modifies the shader to include additional uniforms for textures and other rendering details</li>\n *   <li>Modifies the lighting options to set either PBR or unlit lighting</li>\n *   <li>Sets the render state for back-face culling</li>\n * </ul>\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {FrameState} frameState The frame state.\n * @private\n */\nMaterialPipelineStage.process = function (renderResources, primitive, frameState) {\n  // gltf-pipeline automatically creates a default material so this will always\n  // be defined.\n  const material = primitive.material;\n  const {\n    model,\n    uniformMap,\n    shaderBuilder\n  } = renderResources;\n\n  // Classification models only use position and feature ID attributes,\n  // so textures should be disabled to avoid compile errors.\n  const hasClassification = defined(model.classificationType);\n  const disableTextures = hasClassification;\n\n  // When textures are loaded incrementally, fall back to a default 1x1 texture\n  const {\n    defaultTexture,\n    defaultNormalTexture,\n    defaultEmissiveTexture\n  } = frameState.context;\n  processMaterialUniforms(material, uniformMap, shaderBuilder, defaultTexture, defaultNormalTexture, defaultEmissiveTexture, disableTextures);\n  if (defined(material.specularGlossiness)) {\n    processSpecularGlossinessUniforms(material.specularGlossiness, uniformMap, shaderBuilder, defaultTexture, disableTextures);\n  } else {\n    if (defined(material.specular) && ModelUtility.supportedExtensions.KHR_materials_specular) {\n      processSpecularUniforms(material.specular, uniformMap, shaderBuilder, defaultTexture, disableTextures);\n    }\n    if (defined(material.anisotropy) && ModelUtility.supportedExtensions.KHR_materials_anisotropy) {\n      processAnisotropyUniforms(material.anisotropy, uniformMap, shaderBuilder, defaultTexture, disableTextures);\n    }\n    if (defined(material.clearcoat) && ModelUtility.supportedExtensions.KHR_materials_clearcoat) {\n      processClearcoatUniforms(material.clearcoat, uniformMap, shaderBuilder, defaultTexture, disableTextures);\n    }\n    processMetallicRoughnessUniforms(material.metallicRoughness, uniformMap, shaderBuilder, defaultTexture, disableTextures);\n  }\n\n  // If the primitive does not have normals, fall back to unlit lighting.\n  const hasNormals = ModelUtility.getAttributeBySemantic(primitive, VertexAttributeSemantic.NORMAL);\n\n  // Disable PointCloud normals if the user explicitly turned them off.\n  const disablePointCloudNormals = defined(model.pointCloudShading) && !model.pointCloudShading.normalShading;\n\n  // Classification models will be rendered as unlit.\n  const lightingOptions = renderResources.lightingOptions;\n  if (material.unlit || !hasNormals || hasClassification || disablePointCloudNormals) {\n    lightingOptions.lightingModel = LightingModel.UNLIT;\n  } else {\n    lightingOptions.lightingModel = LightingModel.PBR;\n  }\n\n  // Configure back-face culling\n  const cull = model.backFaceCulling && !material.doubleSided;\n  renderResources.renderStateOptions.cull.enabled = cull;\n  const alphaOptions = renderResources.alphaOptions;\n  if (material.alphaMode === AlphaMode.BLEND) {\n    alphaOptions.pass = Pass.TRANSLUCENT;\n  } else if (material.alphaMode === AlphaMode.MASK) {\n    alphaOptions.alphaCutoff = material.alphaCutoff;\n  }\n  shaderBuilder.addFragmentLines(MaterialStageFS);\n  if (material.doubleSided) {\n    shaderBuilder.addDefine(\"HAS_DOUBLE_SIDED_MATERIAL\", undefined, ShaderDestination.BOTH);\n  }\n};\n\n/**\n * Process a single texture transformation and add it to the shader and uniform map.\n *\n * @param {ShaderBuilder} shaderBuilder The shader builder to modify\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ModelComponents.TextureReader} textureReader The texture to add to the shader\n * @param {string} uniformName The name of the sampler uniform such as <code>u_baseColorTexture</code>\n * @param {string} defineName The name of the texture for use in the defines, minus any prefix or suffix. For example, \"BASE_COLOR\" or \"EMISSIVE\"\n *\n * @private\n */\nfunction processTextureTransform(shaderBuilder, uniformMap, textureReader, uniformName, defineName) {\n  // Add a define to enable the texture transformation code in the shader.\n  const transformDefine = `HAS_${defineName}_TEXTURE_TRANSFORM`;\n  shaderBuilder.addDefine(transformDefine, undefined, ShaderDestination.FRAGMENT);\n\n  // Add a uniform for the transformation matrix\n  const transformUniformName = `${uniformName}Transform`;\n  shaderBuilder.addUniform(\"mat3\", transformUniformName, ShaderDestination.FRAGMENT);\n  uniformMap[transformUniformName] = function () {\n    return textureReader.transform;\n  };\n}\n\n/**\n * Process a single texture scale and add it to the shader and uniform map.\n *\n * @param {ShaderBuilder} shaderBuilder The shader builder to modify\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ModelComponents.TextureReader} textureReader The texture to add to the shader\n * @param {string} uniformName The name of the sampler uniform such as <code>u_baseColorTexture</code>\n * @param {string} defineName The name of the texture for use in the defines, minus any prefix or suffix. For example, \"BASE_COLOR\" or \"EMISSIVE\"\n *\n * @private\n */\nfunction processTextureScale(shaderBuilder, uniformMap, textureReader, uniformName, defineName) {\n  // Add a define to enable the texture transformation code in the shader.\n  const transformDefine = `HAS_${defineName}_TEXTURE_SCALE`;\n  shaderBuilder.addDefine(transformDefine, undefined, ShaderDestination.FRAGMENT);\n\n  // Add a uniform for the transformation matrix\n  const scaleUniformName = `${uniformName}Scale`;\n  shaderBuilder.addUniform(\"float\", scaleUniformName, ShaderDestination.FRAGMENT);\n  uniformMap[scaleUniformName] = function () {\n    return textureReader.scale;\n  };\n}\n\n/**\n * Process a single texture and add it to the shader and uniform map.\n *\n * @param {ShaderBuilder} shaderBuilder The shader builder to modify\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ModelComponents.TextureReader} textureReader The texture to add to the shader\n * @param {string} uniformName The name of the sampler uniform such as <code>u_baseColorTexture</code>\n * @param {string} defineName The name of the texture for use in the defines, minus any prefix or suffix. For example, \"BASE_COLOR\" or \"EMISSIVE\"\n *\n * @private\n */\nfunction processTexture(shaderBuilder, uniformMap, textureReader, uniformName, defineName, defaultTexture) {\n  // Add a uniform for the texture itself\n  shaderBuilder.addUniform(\"sampler2D\", uniformName, ShaderDestination.FRAGMENT);\n  uniformMap[uniformName] = function () {\n    return textureReader.texture ?? defaultTexture;\n  };\n\n  // Add a #define directive to enable using the texture in the shader\n  const textureDefine = `HAS_${defineName}_TEXTURE`;\n  shaderBuilder.addDefine(textureDefine, undefined, ShaderDestination.FRAGMENT);\n\n  // Add a #define to tell the shader which texture coordinates varying to use.\n  const texCoordIndex = textureReader.texCoord;\n  const texCoordVarying = `v_texCoord_${texCoordIndex}`;\n  const texCoordDefine = `TEXCOORD_${defineName}`;\n  shaderBuilder.addDefine(texCoordDefine, texCoordVarying, ShaderDestination.FRAGMENT);\n\n  // Some textures have matrix transforms (e.g. for texture atlases). Add those\n  // to the shader if present.\n  const textureTransform = textureReader.transform;\n  if (defined(textureTransform) && !Matrix3.equals(textureTransform, Matrix3.IDENTITY)) {\n    processTextureTransform(shaderBuilder, uniformMap, textureReader, uniformName, defineName);\n  }\n  const {\n    scale\n  } = textureReader;\n  if (defined(scale) && scale !== 1.0) {\n    processTextureScale(shaderBuilder, uniformMap, textureReader, uniformName, defineName);\n  }\n}\nfunction processMaterialUniforms(material, uniformMap, shaderBuilder, defaultTexture, defaultNormalTexture, defaultEmissiveTexture, disableTextures) {\n  const {\n    emissiveFactor,\n    emissiveTexture,\n    normalTexture,\n    occlusionTexture\n  } = material;\n  if (defined(emissiveFactor) && !Cartesian3.equals(emissiveFactor, Material.DEFAULT_EMISSIVE_FACTOR)) {\n    shaderBuilder.addUniform(\"vec3\", \"u_emissiveFactor\", ShaderDestination.FRAGMENT);\n    uniformMap.u_emissiveFactor = function () {\n      return material.emissiveFactor;\n    };\n    shaderBuilder.addDefine(\"HAS_EMISSIVE_FACTOR\", undefined, ShaderDestination.FRAGMENT);\n    if (defined(emissiveTexture) && !disableTextures) {\n      processTexture(shaderBuilder, uniformMap, emissiveTexture, \"u_emissiveTexture\", \"EMISSIVE\", defaultEmissiveTexture);\n    }\n  }\n  if (defined(normalTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, normalTexture, \"u_normalTexture\", \"NORMAL\", defaultNormalTexture);\n  }\n  if (defined(occlusionTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, occlusionTexture, \"u_occlusionTexture\", \"OCCLUSION\", defaultTexture);\n  }\n}\n\n/**\n * Add uniforms and defines for the KHR_materials_pbrSpecularGlossiness extension\n *\n * @param {ModelComponents.SpecularGlossiness} specularGlossiness\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processSpecularGlossinessUniforms(specularGlossiness, uniformMap, shaderBuilder, defaultTexture, disableTextures) {\n  const {\n    diffuseTexture,\n    diffuseFactor,\n    specularGlossinessTexture,\n    specularFactor,\n    glossinessFactor\n  } = specularGlossiness;\n  shaderBuilder.addDefine(\"USE_SPECULAR_GLOSSINESS\", undefined, ShaderDestination.FRAGMENT);\n  if (defined(diffuseTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, diffuseTexture, \"u_diffuseTexture\", \"DIFFUSE\", defaultTexture);\n  }\n  if (defined(diffuseFactor) && !Cartesian4.equals(diffuseFactor, SpecularGlossiness.DEFAULT_DIFFUSE_FACTOR)) {\n    shaderBuilder.addUniform(\"vec4\", \"u_diffuseFactor\", ShaderDestination.FRAGMENT);\n    uniformMap.u_diffuseFactor = function () {\n      return specularGlossiness.diffuseFactor;\n    };\n    shaderBuilder.addDefine(\"HAS_DIFFUSE_FACTOR\", undefined, ShaderDestination.FRAGMENT);\n  }\n  if (defined(specularGlossinessTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, specularGlossinessTexture, \"u_specularGlossinessTexture\", \"SPECULAR_GLOSSINESS\", defaultTexture);\n  }\n  if (defined(specularFactor) && !Cartesian3.equals(specularFactor, SpecularGlossiness.DEFAULT_SPECULAR_FACTOR)) {\n    shaderBuilder.addUniform(\"vec3\", \"u_legacySpecularFactor\", ShaderDestination.FRAGMENT);\n    uniformMap.u_legacySpecularFactor = function () {\n      return specularGlossiness.specularFactor;\n    };\n    shaderBuilder.addDefine(\"HAS_LEGACY_SPECULAR_FACTOR\", undefined, ShaderDestination.FRAGMENT);\n  }\n  if (defined(glossinessFactor) && glossinessFactor !== SpecularGlossiness.DEFAULT_GLOSSINESS_FACTOR) {\n    shaderBuilder.addUniform(\"float\", \"u_glossinessFactor\", ShaderDestination.FRAGMENT);\n    uniformMap.u_glossinessFactor = function () {\n      return specularGlossiness.glossinessFactor;\n    };\n    shaderBuilder.addDefine(\"HAS_GLOSSINESS_FACTOR\", undefined, ShaderDestination.FRAGMENT);\n  }\n}\n\n/**\n * Add uniforms and defines for the KHR_materials_specular extension\n *\n * @param {ModelComponents.Specular} specular\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processSpecularUniforms(specular, uniformMap, shaderBuilder, defaultTexture, disableTextures) {\n  const {\n    specularTexture,\n    specularFactor,\n    specularColorTexture,\n    specularColorFactor\n  } = specular;\n  shaderBuilder.addDefine(\"USE_SPECULAR\", undefined, ShaderDestination.FRAGMENT);\n  if (defined(specularTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, specularTexture, \"u_specularTexture\", \"SPECULAR\", defaultTexture);\n  }\n  if (defined(specularFactor) && specularFactor !== Specular.DEFAULT_SPECULAR_FACTOR) {\n    shaderBuilder.addUniform(\"float\", \"u_specularFactor\", ShaderDestination.FRAGMENT);\n    uniformMap.u_specularFactor = function () {\n      return specular.specularFactor;\n    };\n    shaderBuilder.addDefine(\"HAS_SPECULAR_FACTOR\", undefined, ShaderDestination.FRAGMENT);\n  }\n  if (defined(specularColorTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, specularColorTexture, \"u_specularColorTexture\", \"SPECULAR_COLOR\", defaultTexture);\n  }\n  if (defined(specularColorFactor) && !Cartesian3.equals(specularColorFactor, Specular.DEFAULT_SPECULAR_COLOR_FACTOR)) {\n    shaderBuilder.addUniform(\"vec3\", \"u_specularColorFactor\", ShaderDestination.FRAGMENT);\n    uniformMap.u_specularColorFactor = function () {\n      return specular.specularColorFactor;\n    };\n    shaderBuilder.addDefine(\"HAS_SPECULAR_COLOR_FACTOR\", undefined, ShaderDestination.FRAGMENT);\n  }\n}\nconst scratchAnisotropy = new Cartesian3();\n\n/**\n * Add uniforms and defines for the KHR_materials_anisotropy extension\n *\n * @param {ModelComponents.Anisotropy} anisotropy\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processAnisotropyUniforms(anisotropy, uniformMap, shaderBuilder, defaultTexture, disableTextures) {\n  const {\n    anisotropyStrength,\n    anisotropyRotation,\n    anisotropyTexture\n  } = anisotropy;\n  shaderBuilder.addDefine(\"USE_ANISOTROPY\", undefined, ShaderDestination.FRAGMENT);\n  if (defined(anisotropyTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, anisotropyTexture, \"u_anisotropyTexture\", \"ANISOTROPY\", defaultTexture);\n  }\n\n  // Pre-compute cos and sin of rotation, since they are the same for all fragments.\n  // Combine with strength as one vec3 uniform.\n  const cosRotation = Math.cos(anisotropyRotation);\n  const sinRotation = Math.sin(anisotropyRotation);\n  shaderBuilder.addUniform(\"vec3\", \"u_anisotropy\", ShaderDestination.FRAGMENT);\n  uniformMap.u_anisotropy = function () {\n    return Cartesian3.fromElements(cosRotation, sinRotation, anisotropyStrength, scratchAnisotropy);\n  };\n}\n\n/**\n * Add uniforms and defines for the KHR_materials_clearcoat extension\n *\n * @param {ModelComponents.Clearcoat} clearcoat\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processClearcoatUniforms(clearcoat, uniformMap, shaderBuilder, defaultTexture, disableTextures) {\n  const {\n    clearcoatFactor,\n    clearcoatTexture,\n    clearcoatRoughnessFactor,\n    clearcoatRoughnessTexture,\n    clearcoatNormalTexture\n  } = clearcoat;\n  shaderBuilder.addDefine(\"USE_CLEARCOAT\", undefined, ShaderDestination.FRAGMENT);\n  if (defined(clearcoatFactor) && clearcoatFactor !== Clearcoat.DEFAULT_CLEARCOAT_FACTOR) {\n    shaderBuilder.addUniform(\"float\", \"u_clearcoatFactor\", ShaderDestination.FRAGMENT);\n    uniformMap.u_clearcoatFactor = function () {\n      return clearcoat.clearcoatFactor;\n    };\n    shaderBuilder.addDefine(\"HAS_CLEARCOAT_FACTOR\", undefined, ShaderDestination.FRAGMENT);\n  }\n  if (defined(clearcoatTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, clearcoatTexture, \"u_clearcoatTexture\", \"CLEARCOAT\", defaultTexture);\n  }\n  if (defined(clearcoatRoughnessFactor) && clearcoatFactor !== Clearcoat.DEFAULT_CLEARCOAT_ROUGHNESS_FACTOR) {\n    shaderBuilder.addUniform(\"float\", \"u_clearcoatRoughnessFactor\", ShaderDestination.FRAGMENT);\n    uniformMap.u_clearcoatRoughnessFactor = function () {\n      return clearcoat.clearcoatRoughnessFactor;\n    };\n    shaderBuilder.addDefine(\"HAS_CLEARCOAT_ROUGHNESS_FACTOR\", undefined, ShaderDestination.FRAGMENT);\n  }\n  if (defined(clearcoatRoughnessTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, clearcoatRoughnessTexture, \"u_clearcoatRoughnessTexture\", \"CLEARCOAT_ROUGHNESS\", defaultTexture);\n  }\n  if (defined(clearcoatNormalTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, clearcoatNormalTexture, \"u_clearcoatNormalTexture\", \"CLEARCOAT_NORMAL\", defaultTexture);\n  }\n}\n\n/**\n * Add uniforms and defines for the PBR metallic roughness model\n *\n * @param {ModelComponents.MetallicRoughness} metallicRoughness\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processMetallicRoughnessUniforms(metallicRoughness, uniformMap, shaderBuilder, defaultTexture, disableTextures) {\n  shaderBuilder.addDefine(\"USE_METALLIC_ROUGHNESS\", undefined, ShaderDestination.FRAGMENT);\n  const baseColorTexture = metallicRoughness.baseColorTexture;\n  if (defined(baseColorTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, baseColorTexture, \"u_baseColorTexture\", \"BASE_COLOR\", defaultTexture);\n  }\n  const baseColorFactor = metallicRoughness.baseColorFactor;\n  if (defined(baseColorFactor) && !Cartesian4.equals(baseColorFactor, MetallicRoughness.DEFAULT_BASE_COLOR_FACTOR)) {\n    shaderBuilder.addUniform(\"vec4\", \"u_baseColorFactor\", ShaderDestination.FRAGMENT);\n    uniformMap.u_baseColorFactor = function () {\n      return metallicRoughness.baseColorFactor;\n    };\n    shaderBuilder.addDefine(\"HAS_BASE_COLOR_FACTOR\", undefined, ShaderDestination.FRAGMENT);\n  }\n  const metallicRoughnessTexture = metallicRoughness.metallicRoughnessTexture;\n  if (defined(metallicRoughnessTexture) && !disableTextures) {\n    processTexture(shaderBuilder, uniformMap, metallicRoughnessTexture, \"u_metallicRoughnessTexture\", \"METALLIC_ROUGHNESS\", defaultTexture);\n  }\n  const metallicFactor = metallicRoughness.metallicFactor;\n  if (defined(metallicFactor) && metallicFactor !== MetallicRoughness.DEFAULT_METALLIC_FACTOR) {\n    shaderBuilder.addUniform(\"float\", \"u_metallicFactor\", ShaderDestination.FRAGMENT);\n    uniformMap.u_metallicFactor = function () {\n      return metallicRoughness.metallicFactor;\n    };\n    shaderBuilder.addDefine(\"HAS_METALLIC_FACTOR\", undefined, ShaderDestination.FRAGMENT);\n  }\n  const roughnessFactor = metallicRoughness.roughnessFactor;\n  if (defined(roughnessFactor) && roughnessFactor !== MetallicRoughness.DEFAULT_ROUGHNESS_FACTOR) {\n    shaderBuilder.addUniform(\"float\", \"u_roughnessFactor\", ShaderDestination.FRAGMENT);\n    uniformMap.u_roughnessFactor = function () {\n      return metallicRoughness.roughnessFactor;\n    };\n    shaderBuilder.addDefine(\"HAS_ROUGHNESS_FACTOR\", undefined, ShaderDestination.FRAGMENT);\n  }\n}\nexport default MaterialPipelineStage;","map":{"version":3,"names":["defined","Cartesian3","Cartesian4","Matrix3","ShaderDestination","Pass","MaterialStageFS","AlphaMode","ModelComponents","VertexAttributeSemantic","LightingModel","ModelUtility","Material","MetallicRoughness","SpecularGlossiness","Specular","Clearcoat","MaterialPipelineStage","name","_processTexture","processTexture","_processTextureTransform","processTextureTransform","process","renderResources","primitive","frameState","material","model","uniformMap","shaderBuilder","hasClassification","classificationType","disableTextures","defaultTexture","defaultNormalTexture","defaultEmissiveTexture","context","processMaterialUniforms","specularGlossiness","processSpecularGlossinessUniforms","specular","supportedExtensions","KHR_materials_specular","processSpecularUniforms","anisotropy","KHR_materials_anisotropy","processAnisotropyUniforms","clearcoat","KHR_materials_clearcoat","processClearcoatUniforms","processMetallicRoughnessUniforms","metallicRoughness","hasNormals","getAttributeBySemantic","NORMAL","disablePointCloudNormals","pointCloudShading","normalShading","lightingOptions","unlit","lightingModel","UNLIT","PBR","cull","backFaceCulling","doubleSided","renderStateOptions","enabled","alphaOptions","alphaMode","BLEND","pass","TRANSLUCENT","MASK","alphaCutoff","addFragmentLines","addDefine","undefined","BOTH","textureReader","uniformName","defineName","transformDefine","FRAGMENT","transformUniformName","addUniform","transform","processTextureScale","scaleUniformName","scale","texture","textureDefine","texCoordIndex","texCoord","texCoordVarying","texCoordDefine","textureTransform","equals","IDENTITY","emissiveFactor","emissiveTexture","normalTexture","occlusionTexture","DEFAULT_EMISSIVE_FACTOR","u_emissiveFactor","diffuseTexture","diffuseFactor","specularGlossinessTexture","specularFactor","glossinessFactor","DEFAULT_DIFFUSE_FACTOR","u_diffuseFactor","DEFAULT_SPECULAR_FACTOR","u_legacySpecularFactor","DEFAULT_GLOSSINESS_FACTOR","u_glossinessFactor","specularTexture","specularColorTexture","specularColorFactor","u_specularFactor","DEFAULT_SPECULAR_COLOR_FACTOR","u_specularColorFactor","scratchAnisotropy","anisotropyStrength","anisotropyRotation","anisotropyTexture","cosRotation","Math","cos","sinRotation","sin","u_anisotropy","fromElements","clearcoatFactor","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughnessTexture","clearcoatNormalTexture","DEFAULT_CLEARCOAT_FACTOR","u_clearcoatFactor","DEFAULT_CLEARCOAT_ROUGHNESS_FACTOR","u_clearcoatRoughnessFactor","baseColorTexture","baseColorFactor","DEFAULT_BASE_COLOR_FACTOR","u_baseColorFactor","metallicRoughnessTexture","metallicFactor","DEFAULT_METALLIC_FACTOR","u_metallicFactor","roughnessFactor","DEFAULT_ROUGHNESS_FACTOR","u_roughnessFactor"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Model/MaterialPipelineStage.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport Matrix3 from \"../../Core/Matrix3.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport MaterialStageFS from \"../../Shaders/Model/MaterialStageFS.js\";\nimport AlphaMode from \"../AlphaMode.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport LightingModel from \"./LightingModel.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\nconst { Material, MetallicRoughness, SpecularGlossiness, Specular, Clearcoat } =\n  ModelComponents;\n\n/**\n * The material pipeline stage processes textures and other uniforms needed\n * to render a primitive. This handles the following material types:\n * <ul>\n *   <li>Basic glTF materials (PBR metallic roughness model)</li>\n *   <li>The `KHR_materials_specular` glTF extension</li>\n *   <li>The `KHR_materials_pbrSpecularGlossiness` glTF extension</li>\n *   <li>The `KHR_materials_unlit` glTF extension</li>\n * </ul>\n *\n * @namespace MaterialPipelineStage\n *\n * @private\n */\nconst MaterialPipelineStage = {\n  name: \"MaterialPipelineStage\", // Helps with debugging\n\n  // Expose some methods for testing\n  _processTexture: processTexture,\n  _processTextureTransform: processTextureTransform,\n};\n\n/**\n * Process a primitive. This modifies the following parts of the render\n * resources:\n * <ul>\n *   <li>Modifies the shader to include the material processing stage</li>\n *   <li>Modifies the shader to include additional uniforms for textures and other rendering details</li>\n *   <li>Modifies the lighting options to set either PBR or unlit lighting</li>\n *   <li>Sets the render state for back-face culling</li>\n * </ul>\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {FrameState} frameState The frame state.\n * @private\n */\nMaterialPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState,\n) {\n  // gltf-pipeline automatically creates a default material so this will always\n  // be defined.\n  const material = primitive.material;\n  const { model, uniformMap, shaderBuilder } = renderResources;\n\n  // Classification models only use position and feature ID attributes,\n  // so textures should be disabled to avoid compile errors.\n  const hasClassification = defined(model.classificationType);\n  const disableTextures = hasClassification;\n\n  // When textures are loaded incrementally, fall back to a default 1x1 texture\n  const { defaultTexture, defaultNormalTexture, defaultEmissiveTexture } =\n    frameState.context;\n\n  processMaterialUniforms(\n    material,\n    uniformMap,\n    shaderBuilder,\n    defaultTexture,\n    defaultNormalTexture,\n    defaultEmissiveTexture,\n    disableTextures,\n  );\n\n  if (defined(material.specularGlossiness)) {\n    processSpecularGlossinessUniforms(\n      material.specularGlossiness,\n      uniformMap,\n      shaderBuilder,\n      defaultTexture,\n      disableTextures,\n    );\n  } else {\n    if (\n      defined(material.specular) &&\n      ModelUtility.supportedExtensions.KHR_materials_specular\n    ) {\n      processSpecularUniforms(\n        material.specular,\n        uniformMap,\n        shaderBuilder,\n        defaultTexture,\n        disableTextures,\n      );\n    }\n    if (\n      defined(material.anisotropy) &&\n      ModelUtility.supportedExtensions.KHR_materials_anisotropy\n    ) {\n      processAnisotropyUniforms(\n        material.anisotropy,\n        uniformMap,\n        shaderBuilder,\n        defaultTexture,\n        disableTextures,\n      );\n    }\n    if (\n      defined(material.clearcoat) &&\n      ModelUtility.supportedExtensions.KHR_materials_clearcoat\n    ) {\n      processClearcoatUniforms(\n        material.clearcoat,\n        uniformMap,\n        shaderBuilder,\n        defaultTexture,\n        disableTextures,\n      );\n    }\n    processMetallicRoughnessUniforms(\n      material.metallicRoughness,\n      uniformMap,\n      shaderBuilder,\n      defaultTexture,\n      disableTextures,\n    );\n  }\n\n  // If the primitive does not have normals, fall back to unlit lighting.\n  const hasNormals = ModelUtility.getAttributeBySemantic(\n    primitive,\n    VertexAttributeSemantic.NORMAL,\n  );\n\n  // Disable PointCloud normals if the user explicitly turned them off.\n  const disablePointCloudNormals =\n    defined(model.pointCloudShading) && !model.pointCloudShading.normalShading;\n\n  // Classification models will be rendered as unlit.\n  const lightingOptions = renderResources.lightingOptions;\n  if (\n    material.unlit ||\n    !hasNormals ||\n    hasClassification ||\n    disablePointCloudNormals\n  ) {\n    lightingOptions.lightingModel = LightingModel.UNLIT;\n  } else {\n    lightingOptions.lightingModel = LightingModel.PBR;\n  }\n\n  // Configure back-face culling\n  const cull = model.backFaceCulling && !material.doubleSided;\n  renderResources.renderStateOptions.cull.enabled = cull;\n\n  const alphaOptions = renderResources.alphaOptions;\n  if (material.alphaMode === AlphaMode.BLEND) {\n    alphaOptions.pass = Pass.TRANSLUCENT;\n  } else if (material.alphaMode === AlphaMode.MASK) {\n    alphaOptions.alphaCutoff = material.alphaCutoff;\n  }\n\n  shaderBuilder.addFragmentLines(MaterialStageFS);\n\n  if (material.doubleSided) {\n    shaderBuilder.addDefine(\n      \"HAS_DOUBLE_SIDED_MATERIAL\",\n      undefined,\n      ShaderDestination.BOTH,\n    );\n  }\n};\n\n/**\n * Process a single texture transformation and add it to the shader and uniform map.\n *\n * @param {ShaderBuilder} shaderBuilder The shader builder to modify\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ModelComponents.TextureReader} textureReader The texture to add to the shader\n * @param {string} uniformName The name of the sampler uniform such as <code>u_baseColorTexture</code>\n * @param {string} defineName The name of the texture for use in the defines, minus any prefix or suffix. For example, \"BASE_COLOR\" or \"EMISSIVE\"\n *\n * @private\n */\nfunction processTextureTransform(\n  shaderBuilder,\n  uniformMap,\n  textureReader,\n  uniformName,\n  defineName,\n) {\n  // Add a define to enable the texture transformation code in the shader.\n  const transformDefine = `HAS_${defineName}_TEXTURE_TRANSFORM`;\n  shaderBuilder.addDefine(\n    transformDefine,\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // Add a uniform for the transformation matrix\n  const transformUniformName = `${uniformName}Transform`;\n  shaderBuilder.addUniform(\n    \"mat3\",\n    transformUniformName,\n    ShaderDestination.FRAGMENT,\n  );\n  uniformMap[transformUniformName] = function () {\n    return textureReader.transform;\n  };\n}\n\n/**\n * Process a single texture scale and add it to the shader and uniform map.\n *\n * @param {ShaderBuilder} shaderBuilder The shader builder to modify\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ModelComponents.TextureReader} textureReader The texture to add to the shader\n * @param {string} uniformName The name of the sampler uniform such as <code>u_baseColorTexture</code>\n * @param {string} defineName The name of the texture for use in the defines, minus any prefix or suffix. For example, \"BASE_COLOR\" or \"EMISSIVE\"\n *\n * @private\n */\nfunction processTextureScale(\n  shaderBuilder,\n  uniformMap,\n  textureReader,\n  uniformName,\n  defineName,\n) {\n  // Add a define to enable the texture transformation code in the shader.\n  const transformDefine = `HAS_${defineName}_TEXTURE_SCALE`;\n  shaderBuilder.addDefine(\n    transformDefine,\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // Add a uniform for the transformation matrix\n  const scaleUniformName = `${uniformName}Scale`;\n  shaderBuilder.addUniform(\n    \"float\",\n    scaleUniformName,\n    ShaderDestination.FRAGMENT,\n  );\n  uniformMap[scaleUniformName] = function () {\n    return textureReader.scale;\n  };\n}\n\n/**\n * Process a single texture and add it to the shader and uniform map.\n *\n * @param {ShaderBuilder} shaderBuilder The shader builder to modify\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ModelComponents.TextureReader} textureReader The texture to add to the shader\n * @param {string} uniformName The name of the sampler uniform such as <code>u_baseColorTexture</code>\n * @param {string} defineName The name of the texture for use in the defines, minus any prefix or suffix. For example, \"BASE_COLOR\" or \"EMISSIVE\"\n *\n * @private\n */\nfunction processTexture(\n  shaderBuilder,\n  uniformMap,\n  textureReader,\n  uniformName,\n  defineName,\n  defaultTexture,\n) {\n  // Add a uniform for the texture itself\n  shaderBuilder.addUniform(\n    \"sampler2D\",\n    uniformName,\n    ShaderDestination.FRAGMENT,\n  );\n  uniformMap[uniformName] = function () {\n    return textureReader.texture ?? defaultTexture;\n  };\n\n  // Add a #define directive to enable using the texture in the shader\n  const textureDefine = `HAS_${defineName}_TEXTURE`;\n  shaderBuilder.addDefine(textureDefine, undefined, ShaderDestination.FRAGMENT);\n\n  // Add a #define to tell the shader which texture coordinates varying to use.\n  const texCoordIndex = textureReader.texCoord;\n  const texCoordVarying = `v_texCoord_${texCoordIndex}`;\n  const texCoordDefine = `TEXCOORD_${defineName}`;\n  shaderBuilder.addDefine(\n    texCoordDefine,\n    texCoordVarying,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // Some textures have matrix transforms (e.g. for texture atlases). Add those\n  // to the shader if present.\n  const textureTransform = textureReader.transform;\n  if (\n    defined(textureTransform) &&\n    !Matrix3.equals(textureTransform, Matrix3.IDENTITY)\n  ) {\n    processTextureTransform(\n      shaderBuilder,\n      uniformMap,\n      textureReader,\n      uniformName,\n      defineName,\n    );\n  }\n\n  const { scale } = textureReader;\n  if (defined(scale) && scale !== 1.0) {\n    processTextureScale(\n      shaderBuilder,\n      uniformMap,\n      textureReader,\n      uniformName,\n      defineName,\n    );\n  }\n}\n\nfunction processMaterialUniforms(\n  material,\n  uniformMap,\n  shaderBuilder,\n  defaultTexture,\n  defaultNormalTexture,\n  defaultEmissiveTexture,\n  disableTextures,\n) {\n  const { emissiveFactor, emissiveTexture, normalTexture, occlusionTexture } =\n    material;\n\n  if (\n    defined(emissiveFactor) &&\n    !Cartesian3.equals(emissiveFactor, Material.DEFAULT_EMISSIVE_FACTOR)\n  ) {\n    shaderBuilder.addUniform(\n      \"vec3\",\n      \"u_emissiveFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_emissiveFactor = function () {\n      return material.emissiveFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_EMISSIVE_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n\n    if (defined(emissiveTexture) && !disableTextures) {\n      processTexture(\n        shaderBuilder,\n        uniformMap,\n        emissiveTexture,\n        \"u_emissiveTexture\",\n        \"EMISSIVE\",\n        defaultEmissiveTexture,\n      );\n    }\n  }\n\n  if (defined(normalTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      normalTexture,\n      \"u_normalTexture\",\n      \"NORMAL\",\n      defaultNormalTexture,\n    );\n  }\n\n  if (defined(occlusionTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      occlusionTexture,\n      \"u_occlusionTexture\",\n      \"OCCLUSION\",\n      defaultTexture,\n    );\n  }\n}\n\n/**\n * Add uniforms and defines for the KHR_materials_pbrSpecularGlossiness extension\n *\n * @param {ModelComponents.SpecularGlossiness} specularGlossiness\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processSpecularGlossinessUniforms(\n  specularGlossiness,\n  uniformMap,\n  shaderBuilder,\n  defaultTexture,\n  disableTextures,\n) {\n  const {\n    diffuseTexture,\n    diffuseFactor,\n    specularGlossinessTexture,\n    specularFactor,\n    glossinessFactor,\n  } = specularGlossiness;\n\n  shaderBuilder.addDefine(\n    \"USE_SPECULAR_GLOSSINESS\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  if (defined(diffuseTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      diffuseTexture,\n      \"u_diffuseTexture\",\n      \"DIFFUSE\",\n      defaultTexture,\n    );\n  }\n\n  if (\n    defined(diffuseFactor) &&\n    !Cartesian4.equals(diffuseFactor, SpecularGlossiness.DEFAULT_DIFFUSE_FACTOR)\n  ) {\n    shaderBuilder.addUniform(\n      \"vec4\",\n      \"u_diffuseFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_diffuseFactor = function () {\n      return specularGlossiness.diffuseFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_DIFFUSE_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  if (defined(specularGlossinessTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      specularGlossinessTexture,\n      \"u_specularGlossinessTexture\",\n      \"SPECULAR_GLOSSINESS\",\n      defaultTexture,\n    );\n  }\n\n  if (\n    defined(specularFactor) &&\n    !Cartesian3.equals(\n      specularFactor,\n      SpecularGlossiness.DEFAULT_SPECULAR_FACTOR,\n    )\n  ) {\n    shaderBuilder.addUniform(\n      \"vec3\",\n      \"u_legacySpecularFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_legacySpecularFactor = function () {\n      return specularGlossiness.specularFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_LEGACY_SPECULAR_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  if (\n    defined(glossinessFactor) &&\n    glossinessFactor !== SpecularGlossiness.DEFAULT_GLOSSINESS_FACTOR\n  ) {\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_glossinessFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_glossinessFactor = function () {\n      return specularGlossiness.glossinessFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_GLOSSINESS_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n}\n\n/**\n * Add uniforms and defines for the KHR_materials_specular extension\n *\n * @param {ModelComponents.Specular} specular\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processSpecularUniforms(\n  specular,\n  uniformMap,\n  shaderBuilder,\n  defaultTexture,\n  disableTextures,\n) {\n  const {\n    specularTexture,\n    specularFactor,\n    specularColorTexture,\n    specularColorFactor,\n  } = specular;\n\n  shaderBuilder.addDefine(\n    \"USE_SPECULAR\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  if (defined(specularTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      specularTexture,\n      \"u_specularTexture\",\n      \"SPECULAR\",\n      defaultTexture,\n    );\n  }\n\n  if (\n    defined(specularFactor) &&\n    specularFactor !== Specular.DEFAULT_SPECULAR_FACTOR\n  ) {\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_specularFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_specularFactor = function () {\n      return specular.specularFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_SPECULAR_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  if (defined(specularColorTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      specularColorTexture,\n      \"u_specularColorTexture\",\n      \"SPECULAR_COLOR\",\n      defaultTexture,\n    );\n  }\n\n  if (\n    defined(specularColorFactor) &&\n    !Cartesian3.equals(\n      specularColorFactor,\n      Specular.DEFAULT_SPECULAR_COLOR_FACTOR,\n    )\n  ) {\n    shaderBuilder.addUniform(\n      \"vec3\",\n      \"u_specularColorFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_specularColorFactor = function () {\n      return specular.specularColorFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_SPECULAR_COLOR_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n}\n\nconst scratchAnisotropy = new Cartesian3();\n\n/**\n * Add uniforms and defines for the KHR_materials_anisotropy extension\n *\n * @param {ModelComponents.Anisotropy} anisotropy\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processAnisotropyUniforms(\n  anisotropy,\n  uniformMap,\n  shaderBuilder,\n  defaultTexture,\n  disableTextures,\n) {\n  const { anisotropyStrength, anisotropyRotation, anisotropyTexture } =\n    anisotropy;\n\n  shaderBuilder.addDefine(\n    \"USE_ANISOTROPY\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  if (defined(anisotropyTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      anisotropyTexture,\n      \"u_anisotropyTexture\",\n      \"ANISOTROPY\",\n      defaultTexture,\n    );\n  }\n\n  // Pre-compute cos and sin of rotation, since they are the same for all fragments.\n  // Combine with strength as one vec3 uniform.\n  const cosRotation = Math.cos(anisotropyRotation);\n  const sinRotation = Math.sin(anisotropyRotation);\n  shaderBuilder.addUniform(\"vec3\", \"u_anisotropy\", ShaderDestination.FRAGMENT);\n  uniformMap.u_anisotropy = function () {\n    return Cartesian3.fromElements(\n      cosRotation,\n      sinRotation,\n      anisotropyStrength,\n      scratchAnisotropy,\n    );\n  };\n}\n\n/**\n * Add uniforms and defines for the KHR_materials_clearcoat extension\n *\n * @param {ModelComponents.Clearcoat} clearcoat\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processClearcoatUniforms(\n  clearcoat,\n  uniformMap,\n  shaderBuilder,\n  defaultTexture,\n  disableTextures,\n) {\n  const {\n    clearcoatFactor,\n    clearcoatTexture,\n    clearcoatRoughnessFactor,\n    clearcoatRoughnessTexture,\n    clearcoatNormalTexture,\n  } = clearcoat;\n\n  shaderBuilder.addDefine(\n    \"USE_CLEARCOAT\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  if (\n    defined(clearcoatFactor) &&\n    clearcoatFactor !== Clearcoat.DEFAULT_CLEARCOAT_FACTOR\n  ) {\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_clearcoatFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_clearcoatFactor = function () {\n      return clearcoat.clearcoatFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_CLEARCOAT_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  if (defined(clearcoatTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      clearcoatTexture,\n      \"u_clearcoatTexture\",\n      \"CLEARCOAT\",\n      defaultTexture,\n    );\n  }\n\n  if (\n    defined(clearcoatRoughnessFactor) &&\n    clearcoatFactor !== Clearcoat.DEFAULT_CLEARCOAT_ROUGHNESS_FACTOR\n  ) {\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_clearcoatRoughnessFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_clearcoatRoughnessFactor = function () {\n      return clearcoat.clearcoatRoughnessFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_CLEARCOAT_ROUGHNESS_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  if (defined(clearcoatRoughnessTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      clearcoatRoughnessTexture,\n      \"u_clearcoatRoughnessTexture\",\n      \"CLEARCOAT_ROUGHNESS\",\n      defaultTexture,\n    );\n  }\n\n  if (defined(clearcoatNormalTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      clearcoatNormalTexture,\n      \"u_clearcoatNormalTexture\",\n      \"CLEARCOAT_NORMAL\",\n      defaultTexture,\n    );\n  }\n}\n\n/**\n * Add uniforms and defines for the PBR metallic roughness model\n *\n * @param {ModelComponents.MetallicRoughness} metallicRoughness\n * @param {Object<string, Function>} uniformMap The uniform map to modify.\n * @param {ShaderBuilder} shaderBuilder\n * @param {Texture} defaultTexture\n * @param {boolean} disableTextures\n * @private\n */\nfunction processMetallicRoughnessUniforms(\n  metallicRoughness,\n  uniformMap,\n  shaderBuilder,\n  defaultTexture,\n  disableTextures,\n) {\n  shaderBuilder.addDefine(\n    \"USE_METALLIC_ROUGHNESS\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n\n  const baseColorTexture = metallicRoughness.baseColorTexture;\n  if (defined(baseColorTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      baseColorTexture,\n      \"u_baseColorTexture\",\n      \"BASE_COLOR\",\n      defaultTexture,\n    );\n  }\n\n  const baseColorFactor = metallicRoughness.baseColorFactor;\n  if (\n    defined(baseColorFactor) &&\n    !Cartesian4.equals(\n      baseColorFactor,\n      MetallicRoughness.DEFAULT_BASE_COLOR_FACTOR,\n    )\n  ) {\n    shaderBuilder.addUniform(\n      \"vec4\",\n      \"u_baseColorFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_baseColorFactor = function () {\n      return metallicRoughness.baseColorFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_BASE_COLOR_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  const metallicRoughnessTexture = metallicRoughness.metallicRoughnessTexture;\n  if (defined(metallicRoughnessTexture) && !disableTextures) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      metallicRoughnessTexture,\n      \"u_metallicRoughnessTexture\",\n      \"METALLIC_ROUGHNESS\",\n      defaultTexture,\n    );\n  }\n\n  const metallicFactor = metallicRoughness.metallicFactor;\n  if (\n    defined(metallicFactor) &&\n    metallicFactor !== MetallicRoughness.DEFAULT_METALLIC_FACTOR\n  ) {\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_metallicFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_metallicFactor = function () {\n      return metallicRoughness.metallicFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_METALLIC_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  const roughnessFactor = metallicRoughness.roughnessFactor;\n  if (\n    defined(roughnessFactor) &&\n    roughnessFactor !== MetallicRoughness.DEFAULT_ROUGHNESS_FACTOR\n  ) {\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_roughnessFactor\",\n      ShaderDestination.FRAGMENT,\n    );\n    uniformMap.u_roughnessFactor = function () {\n      return metallicRoughness.roughnessFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_ROUGHNESS_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n}\n\nexport default MaterialPipelineStage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}