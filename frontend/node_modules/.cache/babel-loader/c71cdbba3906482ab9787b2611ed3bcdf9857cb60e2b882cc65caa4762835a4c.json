{"ast":null,"code":"import binarySearch from \"./binarySearch.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport GregorianDate from \"./GregorianDate.js\";\nimport isLeapYear from \"./isLeapYear.js\";\nimport LeapSecond from \"./LeapSecond.js\";\nimport TimeConstants from \"./TimeConstants.js\";\nimport TimeStandard from \"./TimeStandard.js\";\nconst gregorianDateScratch = new GregorianDate();\nconst daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst daysInLeapFebruary = 29;\nfunction compareLeapSecondDates(leapSecond, dateToFind) {\n  return JulianDate.compare(leapSecond.julianDate, dateToFind.julianDate);\n}\n\n// we don't really need a leap second instance, anything with a julianDate property will do\nconst binarySearchScratchLeapSecond = new LeapSecond();\nfunction convertUtcToTai(julianDate) {\n  //Even though julianDate is in UTC, we'll treat it as TAI and\n  //search the leap second table for it.\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  const leapSeconds = JulianDate.leapSeconds;\n  let index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);\n  if (index < 0) {\n    index = ~index;\n  }\n  if (index >= leapSeconds.length) {\n    index = leapSeconds.length - 1;\n  }\n  let offset = leapSeconds[index].offset;\n  if (index > 0) {\n    //Now we have the index of the closest leap second that comes on or after our UTC time.\n    //However, if the difference between the UTC date being converted and the TAI\n    //defined leap second is greater than the offset, we are off by one and need to use\n    //the previous leap second.\n    const difference = JulianDate.secondsDifference(leapSeconds[index].julianDate, julianDate);\n    if (difference > offset) {\n      index--;\n      offset = leapSeconds[index].offset;\n    }\n  }\n  JulianDate.addSeconds(julianDate, offset, julianDate);\n}\nfunction convertTaiToUtc(julianDate, result) {\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  const leapSeconds = JulianDate.leapSeconds;\n  let index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);\n  if (index < 0) {\n    index = ~index;\n  }\n\n  //All times before our first leap second get the first offset.\n  if (index === 0) {\n    return JulianDate.addSeconds(julianDate, -leapSeconds[0].offset, result);\n  }\n\n  //All times after our leap second get the last offset.\n  if (index >= leapSeconds.length) {\n    return JulianDate.addSeconds(julianDate, -leapSeconds[index - 1].offset, result);\n  }\n\n  //Compute the difference between the found leap second and the time we are converting.\n  const difference = JulianDate.secondsDifference(leapSeconds[index].julianDate, julianDate);\n  if (difference === 0) {\n    //The date is in our leap second table.\n    return JulianDate.addSeconds(julianDate, -leapSeconds[index].offset, result);\n  }\n  if (difference <= 1.0) {\n    //The requested date is during the moment of a leap second, then we cannot convert to UTC\n    return undefined;\n  }\n\n  //The time is in between two leap seconds, index is the leap second after the date\n  //we're converting, so we subtract one to get the correct LeapSecond instance.\n  return JulianDate.addSeconds(julianDate, -leapSeconds[--index].offset, result);\n}\nfunction setComponents(wholeDays, secondsOfDay, julianDate) {\n  const extraDays = secondsOfDay / TimeConstants.SECONDS_PER_DAY | 0;\n  wholeDays += extraDays;\n  secondsOfDay -= TimeConstants.SECONDS_PER_DAY * extraDays;\n  if (secondsOfDay < 0) {\n    wholeDays--;\n    secondsOfDay += TimeConstants.SECONDS_PER_DAY;\n  }\n  julianDate.dayNumber = wholeDays;\n  julianDate.secondsOfDay = secondsOfDay;\n  return julianDate;\n}\nfunction computeJulianDateComponents(year, month, day, hour, minute, second, millisecond) {\n  // Algorithm from page 604 of the Explanatory Supplement to the\n  // Astronomical Almanac (Seidelmann 1992).\n\n  const a = (month - 14) / 12 | 0;\n  const b = year + 4800 + a;\n  let dayNumber = (1461 * b / 4 | 0) + (367 * (month - 2 - 12 * a) / 12 | 0) - (3 * ((b + 100) / 100 | 0) / 4 | 0) + day - 32075;\n\n  // JulianDates are noon-based\n  hour = hour - 12;\n  if (hour < 0) {\n    hour += 24;\n  }\n  const secondsOfDay = second + (hour * TimeConstants.SECONDS_PER_HOUR + minute * TimeConstants.SECONDS_PER_MINUTE + millisecond * TimeConstants.SECONDS_PER_MILLISECOND);\n  if (secondsOfDay >= 43200.0) {\n    dayNumber -= 1;\n  }\n  return [dayNumber, secondsOfDay];\n}\n\n//Regular expressions used for ISO8601 date parsing.\n//YYYY\nconst matchCalendarYear = /^(\\d{4})$/;\n//YYYY-MM (YYYYMM is invalid)\nconst matchCalendarMonth = /^(\\d{4})-(\\d{2})$/;\n//YYYY-DDD or YYYYDDD\nconst matchOrdinalDate = /^(\\d{4})-?(\\d{3})$/;\n//YYYY-Www or YYYYWww or YYYY-Www-D or YYYYWwwD\nconst matchWeekDate = /^(\\d{4})-?W(\\d{2})-?(\\d{1})?$/;\n//YYYY-MM-DD or YYYYMMDD\nconst matchCalendarDate = /^(\\d{4})-?(\\d{2})-?(\\d{2})$/;\n// Match utc offset\nconst utcOffset = /([Z+\\-])?(\\d{2})?:?(\\d{2})?$/;\n// Match hours HH or HH.xxxxx\nconst matchHours = /^(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n// Match hours/minutes HH:MM HHMM.xxxxx\nconst matchHoursMinutes = /^(\\d{2}):?(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n// Match hours/minutes HH:MM:SS HHMMSS.xxxxx\nconst matchHoursMinutesSeconds = /^(\\d{2}):?(\\d{2}):?(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\nconst iso8601ErrorMessage = \"Invalid ISO 8601 date.\";\n\n/**\n * Represents an astronomical Julian date, which is the number of days since noon on January 1, -4712 (4713 BC).\n * For increased precision, this class stores the whole number part of the date and the seconds\n * part of the date in separate components.  In order to be safe for arithmetic and represent\n * leap seconds, the date is always stored in the International Atomic Time standard\n * {@link TimeStandard.TAI}.\n * @alias JulianDate\n * @constructor\n *\n * @param {number} [julianDayNumber=0.0] The Julian Day Number representing the number of whole days.  Fractional days will also be handled correctly.\n * @param {number} [secondsOfDay=0.0] The number of seconds into the current Julian Day Number.  Fractional seconds, negative seconds and seconds greater than a day will be handled correctly.\n * @param {TimeStandard} [timeStandard=TimeStandard.UTC] The time standard in which the first two parameters are defined.\n */\nfunction JulianDate(julianDayNumber, secondsOfDay, timeStandard) {\n  /**\n   * Gets or sets the number of whole days.\n   * @type {number}\n   */\n  this.dayNumber = undefined;\n\n  /**\n   * Gets or sets the number of seconds into the current day.\n   * @type {number}\n   */\n  this.secondsOfDay = undefined;\n  julianDayNumber = julianDayNumber ?? 0.0;\n  secondsOfDay = secondsOfDay ?? 0.0;\n  timeStandard = timeStandard ?? TimeStandard.UTC;\n\n  //If julianDayNumber is fractional, make it an integer and add the number of seconds the fraction represented.\n  const wholeDays = julianDayNumber | 0;\n  secondsOfDay = secondsOfDay + (julianDayNumber - wholeDays) * TimeConstants.SECONDS_PER_DAY;\n  setComponents(wholeDays, secondsOfDay, this);\n  if (timeStandard === TimeStandard.UTC) {\n    convertUtcToTai(this);\n  }\n}\n\n/**\n * Creates a new instance from a GregorianDate.\n *\n * @param {GregorianDate} date A GregorianDate.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} date must be a valid GregorianDate.\n */\nJulianDate.fromGregorianDate = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!(date instanceof GregorianDate)) {\n    throw new DeveloperError(\"date must be a valid GregorianDate.\");\n  }\n  //>>includeEnd('debug');\n\n  const components = computeJulianDateComponents(date.year, date.month, date.day, date.hour, date.minute, date.second, date.millisecond);\n  if (!defined(result)) {\n    return new JulianDate(components[0], components[1], TimeStandard.UTC);\n  }\n  setComponents(components[0], components[1], result);\n  convertUtcToTai(result);\n  return result;\n};\n\n/**\n * Creates a new instance from a JavaScript Date.\n *\n * @param {Date} date A JavaScript Date.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} date must be a valid JavaScript Date.\n */\nJulianDate.fromDate = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!(date instanceof Date) || isNaN(date.getTime())) {\n    throw new DeveloperError(\"date must be a valid JavaScript Date.\");\n  }\n  //>>includeEnd('debug');\n\n  const components = computeJulianDateComponents(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());\n  if (!defined(result)) {\n    return new JulianDate(components[0], components[1], TimeStandard.UTC);\n  }\n  setComponents(components[0], components[1], result);\n  convertUtcToTai(result);\n  return result;\n};\n\n/**\n * Creates a new instance from a from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date.\n * This method is superior to <code>Date.parse</code> because it will handle all valid formats defined by the ISO 8601\n * specification, including leap seconds and sub-millisecond times, which discarded by most JavaScript implementations.\n *\n * @param {string} iso8601String An ISO 8601 date.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} Invalid ISO 8601 date.\n */\nJulianDate.fromIso8601 = function (iso8601String, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof iso8601String !== \"string\") {\n    throw new DeveloperError(iso8601ErrorMessage);\n  }\n  //>>includeEnd('debug');\n\n  //Comma and decimal point both indicate a fractional number according to ISO 8601,\n  //start out by blanket replacing , with . which is the only valid such symbol in JS.\n  iso8601String = iso8601String.replace(\",\", \".\");\n\n  //Split the string into its date and time components, denoted by a mandatory T\n  let tokens = iso8601String.split(\"T\");\n  let year;\n  let month = 1;\n  let day = 1;\n  let hour = 0;\n  let minute = 0;\n  let second = 0;\n  let millisecond = 0;\n\n  //Lacking a time is okay, but a missing date is illegal.\n  const date = tokens[0];\n  const time = tokens[1];\n  let tmp;\n  let inLeapYear;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(iso8601ErrorMessage);\n  }\n  let dashCount;\n  //>>includeEnd('debug');\n\n  //First match the date against possible regular expressions.\n  tokens = date.match(matchCalendarDate);\n  if (tokens !== null) {\n    //>>includeStart('debug', pragmas.debug);\n    dashCount = date.split(\"-\").length - 1;\n    if (dashCount > 0 && dashCount !== 2) {\n      throw new DeveloperError(iso8601ErrorMessage);\n    }\n    //>>includeEnd('debug');\n    year = +tokens[1];\n    month = +tokens[2];\n    day = +tokens[3];\n  } else {\n    tokens = date.match(matchCalendarMonth);\n    if (tokens !== null) {\n      year = +tokens[1];\n      month = +tokens[2];\n    } else {\n      tokens = date.match(matchCalendarYear);\n      if (tokens !== null) {\n        year = +tokens[1];\n      } else {\n        //Not a year/month/day so it must be an ordinal date.\n        let dayOfYear;\n        tokens = date.match(matchOrdinalDate);\n        if (tokens !== null) {\n          year = +tokens[1];\n          dayOfYear = +tokens[2];\n          inLeapYear = isLeapYear(year);\n\n          //This validation is only applicable for this format.\n          //>>includeStart('debug', pragmas.debug);\n          if (dayOfYear < 1 || inLeapYear && dayOfYear > 366 || !inLeapYear && dayOfYear > 365) {\n            throw new DeveloperError(iso8601ErrorMessage);\n          }\n          //>>includeEnd('debug');\n        } else {\n          tokens = date.match(matchWeekDate);\n          if (tokens !== null) {\n            //ISO week date to ordinal date from\n            //http://en.wikipedia.org/w/index.php?title=ISO_week_date&oldid=474176775\n            year = +tokens[1];\n            const weekNumber = +tokens[2];\n            const dayOfWeek = +tokens[3] || 0;\n\n            //>>includeStart('debug', pragmas.debug);\n            dashCount = date.split(\"-\").length - 1;\n            if (dashCount > 0 && (!defined(tokens[3]) && dashCount !== 1 || defined(tokens[3]) && dashCount !== 2)) {\n              throw new DeveloperError(iso8601ErrorMessage);\n            }\n            //>>includeEnd('debug');\n\n            const january4 = new Date(Date.UTC(year, 0, 4));\n            dayOfYear = weekNumber * 7 + dayOfWeek - january4.getUTCDay() - 3;\n          } else {\n            //None of our regular expressions succeeded in parsing the date properly.\n            //>>includeStart('debug', pragmas.debug);\n            throw new DeveloperError(iso8601ErrorMessage);\n            //>>includeEnd('debug');\n          }\n        }\n        //Split an ordinal date into month/day.\n        tmp = new Date(Date.UTC(year, 0, 1));\n        tmp.setUTCDate(dayOfYear);\n        month = tmp.getUTCMonth() + 1;\n        day = tmp.getUTCDate();\n      }\n    }\n  }\n\n  //Now that we have all of the date components, validate them to make sure nothing is out of range.\n  inLeapYear = isLeapYear(year);\n  //>>includeStart('debug', pragmas.debug);\n  if (month < 1 || month > 12 || day < 1 || (month !== 2 || !inLeapYear) && day > daysInMonth[month - 1] || inLeapYear && month === 2 && day > daysInLeapFebruary) {\n    throw new DeveloperError(iso8601ErrorMessage);\n  }\n  //>>includeEnd('debug');\n\n  //Now move onto the time string, which is much simpler.\n  //If no time is specified, it is considered the beginning of the day, UTC to match Javascript's implementation.\n  let offsetIndex;\n  if (defined(time)) {\n    tokens = time.match(matchHoursMinutesSeconds);\n    if (tokens !== null) {\n      //>>includeStart('debug', pragmas.debug);\n      dashCount = time.split(\":\").length - 1;\n      if (dashCount > 0 && dashCount !== 2 && dashCount !== 3) {\n        throw new DeveloperError(iso8601ErrorMessage);\n      }\n      //>>includeEnd('debug');\n\n      hour = +tokens[1];\n      minute = +tokens[2];\n      second = +tokens[3];\n      millisecond = +(tokens[4] || 0) * 1000.0;\n      offsetIndex = 5;\n    } else {\n      tokens = time.match(matchHoursMinutes);\n      if (tokens !== null) {\n        //>>includeStart('debug', pragmas.debug);\n        dashCount = time.split(\":\").length - 1;\n        if (dashCount > 2) {\n          throw new DeveloperError(iso8601ErrorMessage);\n        }\n        //>>includeEnd('debug');\n\n        hour = +tokens[1];\n        minute = +tokens[2];\n        second = +(tokens[3] || 0) * 60.0;\n        offsetIndex = 4;\n      } else {\n        tokens = time.match(matchHours);\n        if (tokens !== null) {\n          hour = +tokens[1];\n          minute = +(tokens[2] || 0) * 60.0;\n          offsetIndex = 3;\n        } else {\n          //>>includeStart('debug', pragmas.debug);\n          throw new DeveloperError(iso8601ErrorMessage);\n          //>>includeEnd('debug');\n        }\n      }\n    }\n\n    //Validate that all values are in proper range.  Minutes and hours have special cases at 60 and 24.\n    //>>includeStart('debug', pragmas.debug);\n    if (minute >= 60 || second >= 61 || hour > 24 || hour === 24 && (minute > 0 || second > 0 || millisecond > 0)) {\n      throw new DeveloperError(iso8601ErrorMessage);\n    }\n    //>>includeEnd('debug');\n\n    //Check the UTC offset value, if no value exists, use local time\n    //a Z indicates UTC, + or - are offsets.\n    const offset = tokens[offsetIndex];\n    const offsetHours = +tokens[offsetIndex + 1];\n    const offsetMinutes = +(tokens[offsetIndex + 2] || 0);\n    switch (offset) {\n      case \"+\":\n        hour = hour - offsetHours;\n        minute = minute - offsetMinutes;\n        break;\n      case \"-\":\n        hour = hour + offsetHours;\n        minute = minute + offsetMinutes;\n        break;\n      case \"Z\":\n        break;\n      default:\n        minute = minute + new Date(Date.UTC(year, month - 1, day, hour, minute)).getTimezoneOffset();\n        break;\n    }\n  }\n\n  //ISO8601 denotes a leap second by any time having a seconds component of 60 seconds.\n  //If that's the case, we need to temporarily subtract a second in order to build a UTC date.\n  //Then we add it back in after converting to TAI.\n  const isLeapSecond = second === 60;\n  if (isLeapSecond) {\n    second--;\n  }\n\n  //Even if we successfully parsed the string into its components, after applying UTC offset or\n  //special cases like 24:00:00 denoting midnight, we need to normalize the data appropriately.\n\n  //milliseconds can never be greater than 1000, and seconds can't be above 60, so we start with minutes\n  while (minute >= 60) {\n    minute -= 60;\n    hour++;\n  }\n  while (hour >= 24) {\n    hour -= 24;\n    day++;\n  }\n  tmp = inLeapYear && month === 2 ? daysInLeapFebruary : daysInMonth[month - 1];\n  while (day > tmp) {\n    day -= tmp;\n    month++;\n    if (month > 12) {\n      month -= 12;\n      year++;\n    }\n    tmp = inLeapYear && month === 2 ? daysInLeapFebruary : daysInMonth[month - 1];\n  }\n\n  //If UTC offset is at the beginning/end of the day, minutes can be negative.\n  while (minute < 0) {\n    minute += 60;\n    hour--;\n  }\n  while (hour < 0) {\n    hour += 24;\n    day--;\n  }\n  while (day < 1) {\n    month--;\n    if (month < 1) {\n      month += 12;\n      year--;\n    }\n    tmp = inLeapYear && month === 2 ? daysInLeapFebruary : daysInMonth[month - 1];\n    day += tmp;\n  }\n\n  //Now create the JulianDate components from the Gregorian date and actually create our instance.\n  const components = computeJulianDateComponents(year, month, day, hour, minute, second, millisecond);\n  if (!defined(result)) {\n    result = new JulianDate(components[0], components[1], TimeStandard.UTC);\n  } else {\n    setComponents(components[0], components[1], result);\n    convertUtcToTai(result);\n  }\n\n  //If we were on a leap second, add it back.\n  if (isLeapSecond) {\n    JulianDate.addSeconds(result, 1, result);\n  }\n  return result;\n};\n\n/**\n * Creates a new instance that represents the current system time.\n * This is equivalent to calling <code>JulianDate.fromDate(new Date());</code>.\n *\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n */\nJulianDate.now = function (result) {\n  return JulianDate.fromDate(new Date(), result);\n};\nconst toGregorianDateScratch = new JulianDate(0, 0, TimeStandard.TAI);\n\n/**\n * Creates a {@link GregorianDate} from the provided instance.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @param {GregorianDate} [result] An existing instance to use for the result.\n * @returns {GregorianDate} The modified result parameter or a new instance if none was provided.\n */\nJulianDate.toGregorianDate = function (julianDate, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let isLeapSecond = false;\n  let thisUtc = convertTaiToUtc(julianDate, toGregorianDateScratch);\n  if (!defined(thisUtc)) {\n    //Conversion to UTC will fail if we are during a leap second.\n    //If that's the case, subtract a second and convert again.\n    //JavaScript doesn't support leap seconds, so this results in second 59 being repeated twice.\n    JulianDate.addSeconds(julianDate, -1, toGregorianDateScratch);\n    thisUtc = convertTaiToUtc(toGregorianDateScratch, toGregorianDateScratch);\n    isLeapSecond = true;\n  }\n  let julianDayNumber = thisUtc.dayNumber;\n  const secondsOfDay = thisUtc.secondsOfDay;\n  if (secondsOfDay >= 43200.0) {\n    julianDayNumber += 1;\n  }\n\n  // Algorithm from page 604 of the Explanatory Supplement to the\n  // Astronomical Almanac (Seidelmann 1992).\n  let L = julianDayNumber + 68569 | 0;\n  const N = 4 * L / 146097 | 0;\n  L = L - ((146097 * N + 3) / 4 | 0) | 0;\n  const I = 4000 * (L + 1) / 1461001 | 0;\n  L = L - (1461 * I / 4 | 0) + 31 | 0;\n  const J = 80 * L / 2447 | 0;\n  const day = L - (2447 * J / 80 | 0) | 0;\n  L = J / 11 | 0;\n  const month = J + 2 - 12 * L | 0;\n  const year = 100 * (N - 49) + I + L | 0;\n  let hour = secondsOfDay / TimeConstants.SECONDS_PER_HOUR | 0;\n  let remainingSeconds = secondsOfDay - hour * TimeConstants.SECONDS_PER_HOUR;\n  const minute = remainingSeconds / TimeConstants.SECONDS_PER_MINUTE | 0;\n  remainingSeconds = remainingSeconds - minute * TimeConstants.SECONDS_PER_MINUTE;\n  let second = remainingSeconds | 0;\n  const millisecond = (remainingSeconds - second) / TimeConstants.SECONDS_PER_MILLISECOND;\n\n  // JulianDates are noon-based\n  hour += 12;\n  if (hour > 23) {\n    hour -= 24;\n  }\n\n  //If we were on a leap second, add it back.\n  if (isLeapSecond) {\n    second += 1;\n  }\n  if (!defined(result)) {\n    return new GregorianDate(year, month, day, hour, minute, second, millisecond, isLeapSecond);\n  }\n  result.year = year;\n  result.month = month;\n  result.day = day;\n  result.hour = hour;\n  result.minute = minute;\n  result.second = second;\n  result.millisecond = millisecond;\n  result.isLeapSecond = isLeapSecond;\n  return result;\n};\n\n/**\n * Creates a JavaScript Date from the provided instance.\n * Since JavaScript dates are only accurate to the nearest millisecond and\n * cannot represent a leap second, consider using {@link JulianDate.toGregorianDate} instead.\n * If the provided JulianDate is during a leap second, the previous second is used.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @returns {Date} A new instance representing the provided date.\n */\nJulianDate.toDate = function (julianDate) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);\n  let second = gDate.second;\n  if (gDate.isLeapSecond) {\n    second -= 1;\n  }\n  return new Date(Date.UTC(gDate.year, gDate.month - 1, gDate.day, gDate.hour, gDate.minute, second, gDate.millisecond));\n};\n\n/**\n * Creates an ISO8601 representation of the provided date.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @param {number} [precision] The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.\n * @returns {string} The ISO8601 representation of the provided date.\n */\nJulianDate.toIso8601 = function (julianDate, precision) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);\n  let year = gDate.year;\n  let month = gDate.month;\n  let day = gDate.day;\n  let hour = gDate.hour;\n  const minute = gDate.minute;\n  const second = gDate.second;\n  const millisecond = gDate.millisecond;\n\n  // special case - Iso8601.MAXIMUM_VALUE produces a string which we can't parse unless we adjust.\n  // 10000-01-01T00:00:00 is the same instant as 9999-12-31T24:00:00\n  if (year === 10000 && month === 1 && day === 1 && hour === 0 && minute === 0 && second === 0 && millisecond === 0) {\n    year = 9999;\n    month = 12;\n    day = 31;\n    hour = 24;\n  }\n  let millisecondStr;\n  if (!defined(precision) && millisecond !== 0) {\n    // Forces milliseconds into a number with at least 3 digits.\n    const millisecondHundreds = millisecond * 0.01;\n    // Below 1e-6, toString returns scientific notation, so it should be replaced by toFixed with appropriate number of digits.\n    // 20 digits is a trade-off choice guided by JavaScript's Number representation accuracy (15-17 decimal digits for most numbers).\n    // Using toFixed(20) ensures capturing enough precision while avoiding inaccuracies due to floating-point limitations.\n    millisecondStr = millisecondHundreds < 1e-6 ? millisecondHundreds.toFixed(20).replace(\".\", \"\").replace(/0+$/, \"\") : millisecondHundreds.toString().replace(\".\", \"\");\n    return `${year.toString().padStart(4, \"0\")}-${month.toString().padStart(2, \"0\")}-${day.toString().padStart(2, \"0\")}T${hour.toString().padStart(2, \"0\")}:${minute.toString().padStart(2, \"0\")}:${second.toString().padStart(2, \"0\")}.${millisecondStr}Z`;\n  }\n\n  //Precision is either 0 or milliseconds is 0 with undefined precision, in either case, leave off milliseconds entirely\n  if (!defined(precision) || precision === 0) {\n    return `${year.toString().padStart(4, \"0\")}-${month.toString().padStart(2, \"0\")}-${day.toString().padStart(2, \"0\")}T${hour.toString().padStart(2, \"0\")}:${minute.toString().padStart(2, \"0\")}:${second.toString().padStart(2, \"0\")}Z`;\n  }\n\n  //Forces milliseconds into a number with at least 3 digits to whatever the specified precision is.\n  millisecondStr = (millisecond * 0.01).toFixed(precision).replace(\".\", \"\").slice(0, precision);\n  return `${year.toString().padStart(4, \"0\")}-${month.toString().padStart(2, \"0\")}-${day.toString().padStart(2, \"0\")}T${hour.toString().padStart(2, \"0\")}:${minute.toString().padStart(2, \"0\")}:${second.toString().padStart(2, \"0\")}.${millisecondStr}Z`;\n};\n\n/**\n * Duplicates a JulianDate instance.\n *\n * @param {JulianDate} julianDate The date to duplicate.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided. Returns undefined if julianDate is undefined.\n */\nJulianDate.clone = function (julianDate, result) {\n  if (!defined(julianDate)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new JulianDate(julianDate.dayNumber, julianDate.secondsOfDay, TimeStandard.TAI);\n  }\n  result.dayNumber = julianDate.dayNumber;\n  result.secondsOfDay = julianDate.secondsOfDay;\n  return result;\n};\n\n/**\n * Compares two instances.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {number} A negative value if left is less than right, a positive value if left is greater than right, or zero if left and right are equal.\n */\nJulianDate.compare = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const julianDayNumberDifference = left.dayNumber - right.dayNumber;\n  if (julianDayNumberDifference !== 0) {\n    return julianDayNumberDifference;\n  }\n  return left.secondsOfDay - right.secondsOfDay;\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {JulianDate} [left] The first instance.\n * @param {JulianDate} [right] The second instance.\n * @returns {boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n */\nJulianDate.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && left.dayNumber === right.dayNumber && left.secondsOfDay === right.secondsOfDay;\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n * each other.  That is, in order for the dates to be considered equal (and for\n * this function to return <code>true</code>), the absolute value of the difference between them, in\n * seconds, must be less than <code>epsilon</code>.\n *\n * @param {JulianDate} [left] The first instance.\n * @param {JulianDate} [right] The second instance.\n * @param {number} [epsilon=0] The maximum number of seconds that should separate the two instances.\n * @returns {boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n */\nJulianDate.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = epsilon ?? 0;\n  return left === right || defined(left) && defined(right) && Math.abs(JulianDate.secondsDifference(left, right)) <= epsilon;\n};\n\n/**\n * Computes the total number of whole and fractional days represented by the provided instance.\n *\n * @param {JulianDate} julianDate The date.\n * @returns {number} The Julian date as single floating point number.\n */\nJulianDate.totalDays = function (julianDate) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n  return julianDate.dayNumber + julianDate.secondsOfDay / TimeConstants.SECONDS_PER_DAY;\n};\n\n/**\n * Computes the difference in seconds between the provided instance.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {number} The difference, in seconds, when subtracting <code>right</code> from <code>left</code>.\n */\nJulianDate.secondsDifference = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const dayDifference = (left.dayNumber - right.dayNumber) * TimeConstants.SECONDS_PER_DAY;\n  return dayDifference + (left.secondsOfDay - right.secondsOfDay);\n};\n\n/**\n * Computes the difference in days between the provided instance.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {number} The difference, in days, when subtracting <code>right</code> from <code>left</code>.\n */\nJulianDate.daysDifference = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const dayDifference = left.dayNumber - right.dayNumber;\n  const secondDifference = (left.secondsOfDay - right.secondsOfDay) / TimeConstants.SECONDS_PER_DAY;\n  return dayDifference + secondDifference;\n};\n\n/**\n * Computes the number of seconds the provided instance is ahead of UTC.\n *\n * @param {JulianDate} julianDate The date.\n * @returns {number} The number of seconds the provided instance is ahead of UTC\n */\nJulianDate.computeTaiMinusUtc = function (julianDate) {\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  const leapSeconds = JulianDate.leapSeconds;\n  let index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);\n  if (index < 0) {\n    index = ~index;\n    --index;\n    if (index < 0) {\n      index = 0;\n    }\n  }\n  return leapSeconds[index].offset;\n};\n\n/**\n * Adds the provided number of seconds to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {number} seconds The number of seconds to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addSeconds = function (julianDate, seconds, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  if (!defined(seconds)) {\n    throw new DeveloperError(\"seconds is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return setComponents(julianDate.dayNumber, julianDate.secondsOfDay + seconds, result);\n};\n\n/**\n * Adds the provided number of minutes to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {number} minutes The number of minutes to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addMinutes = function (julianDate, minutes, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  if (!defined(minutes)) {\n    throw new DeveloperError(\"minutes is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const newSecondsOfDay = julianDate.secondsOfDay + minutes * TimeConstants.SECONDS_PER_MINUTE;\n  return setComponents(julianDate.dayNumber, newSecondsOfDay, result);\n};\n\n/**\n * Adds the provided number of hours to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {number} hours The number of hours to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addHours = function (julianDate, hours, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  if (!defined(hours)) {\n    throw new DeveloperError(\"hours is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const newSecondsOfDay = julianDate.secondsOfDay + hours * TimeConstants.SECONDS_PER_HOUR;\n  return setComponents(julianDate.dayNumber, newSecondsOfDay, result);\n};\n\n/**\n * Adds the provided number of days to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {number} days The number of days to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addDays = function (julianDate, days, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  if (!defined(days)) {\n    throw new DeveloperError(\"days is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const newJulianDayNumber = julianDate.dayNumber + days;\n  return setComponents(newJulianDayNumber, julianDate.secondsOfDay, result);\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {boolean} <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.lessThan = function (left, right) {\n  return JulianDate.compare(left, right) < 0;\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {boolean} <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.lessThanOrEquals = function (left, right) {\n  return JulianDate.compare(left, right) <= 0;\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {boolean} <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.greaterThan = function (left, right) {\n  return JulianDate.compare(left, right) > 0;\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {boolean} <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.greaterThanOrEquals = function (left, right) {\n  return JulianDate.compare(left, right) >= 0;\n};\n\n/**\n * Duplicates this instance.\n *\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n */\nJulianDate.prototype.clone = function (result) {\n  return JulianDate.clone(this, result);\n};\n\n/**\n * Compares this and the provided instance and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {JulianDate} [right] The second instance.\n * @returns {boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n */\nJulianDate.prototype.equals = function (right) {\n  return JulianDate.equals(this, right);\n};\n\n/**\n * Compares this and the provided instance and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n * each other.  That is, in order for the dates to be considered equal (and for\n * this function to return <code>true</code>), the absolute value of the difference between them, in\n * seconds, must be less than <code>epsilon</code>.\n *\n * @param {JulianDate} [right] The second instance.\n * @param {number} [epsilon=0] The maximum number of seconds that should separate the two instances.\n * @returns {boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n */\nJulianDate.prototype.equalsEpsilon = function (right, epsilon) {\n  return JulianDate.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this date in ISO8601 format.\n *\n * @returns {string} A string representing this date in ISO8601 format.\n */\nJulianDate.prototype.toString = function () {\n  return JulianDate.toIso8601(this);\n};\n\n/**\n * Gets or sets the list of leap seconds used throughout Cesium.\n * @memberof JulianDate\n * @type {LeapSecond[]}\n */\nJulianDate.leapSeconds = [new LeapSecond(new JulianDate(2441317, 43210.0, TimeStandard.TAI), 10),\n// January 1, 1972 00:00:00 UTC\nnew LeapSecond(new JulianDate(2441499, 43211.0, TimeStandard.TAI), 11),\n// July 1, 1972 00:00:00 UTC\nnew LeapSecond(new JulianDate(2441683, 43212.0, TimeStandard.TAI), 12),\n// January 1, 1973 00:00:00 UTC\nnew LeapSecond(new JulianDate(2442048, 43213.0, TimeStandard.TAI), 13),\n// January 1, 1974 00:00:00 UTC\nnew LeapSecond(new JulianDate(2442413, 43214.0, TimeStandard.TAI), 14),\n// January 1, 1975 00:00:00 UTC\nnew LeapSecond(new JulianDate(2442778, 43215.0, TimeStandard.TAI), 15),\n// January 1, 1976 00:00:00 UTC\nnew LeapSecond(new JulianDate(2443144, 43216.0, TimeStandard.TAI), 16),\n// January 1, 1977 00:00:00 UTC\nnew LeapSecond(new JulianDate(2443509, 43217.0, TimeStandard.TAI), 17),\n// January 1, 1978 00:00:00 UTC\nnew LeapSecond(new JulianDate(2443874, 43218.0, TimeStandard.TAI), 18),\n// January 1, 1979 00:00:00 UTC\nnew LeapSecond(new JulianDate(2444239, 43219.0, TimeStandard.TAI), 19),\n// January 1, 1980 00:00:00 UTC\nnew LeapSecond(new JulianDate(2444786, 43220.0, TimeStandard.TAI), 20),\n// July 1, 1981 00:00:00 UTC\nnew LeapSecond(new JulianDate(2445151, 43221.0, TimeStandard.TAI), 21),\n// July 1, 1982 00:00:00 UTC\nnew LeapSecond(new JulianDate(2445516, 43222.0, TimeStandard.TAI), 22),\n// July 1, 1983 00:00:00 UTC\nnew LeapSecond(new JulianDate(2446247, 43223.0, TimeStandard.TAI), 23),\n// July 1, 1985 00:00:00 UTC\nnew LeapSecond(new JulianDate(2447161, 43224.0, TimeStandard.TAI), 24),\n// January 1, 1988 00:00:00 UTC\nnew LeapSecond(new JulianDate(2447892, 43225.0, TimeStandard.TAI), 25),\n// January 1, 1990 00:00:00 UTC\nnew LeapSecond(new JulianDate(2448257, 43226.0, TimeStandard.TAI), 26),\n// January 1, 1991 00:00:00 UTC\nnew LeapSecond(new JulianDate(2448804, 43227.0, TimeStandard.TAI), 27),\n// July 1, 1992 00:00:00 UTC\nnew LeapSecond(new JulianDate(2449169, 43228.0, TimeStandard.TAI), 28),\n// July 1, 1993 00:00:00 UTC\nnew LeapSecond(new JulianDate(2449534, 43229.0, TimeStandard.TAI), 29),\n// July 1, 1994 00:00:00 UTC\nnew LeapSecond(new JulianDate(2450083, 43230.0, TimeStandard.TAI), 30),\n// January 1, 1996 00:00:00 UTC\nnew LeapSecond(new JulianDate(2450630, 43231.0, TimeStandard.TAI), 31),\n// July 1, 1997 00:00:00 UTC\nnew LeapSecond(new JulianDate(2451179, 43232.0, TimeStandard.TAI), 32),\n// January 1, 1999 00:00:00 UTC\nnew LeapSecond(new JulianDate(2453736, 43233.0, TimeStandard.TAI), 33),\n// January 1, 2006 00:00:00 UTC\nnew LeapSecond(new JulianDate(2454832, 43234.0, TimeStandard.TAI), 34),\n// January 1, 2009 00:00:00 UTC\nnew LeapSecond(new JulianDate(2456109, 43235.0, TimeStandard.TAI), 35),\n// July 1, 2012 00:00:00 UTC\nnew LeapSecond(new JulianDate(2457204, 43236.0, TimeStandard.TAI), 36),\n// July 1, 2015 00:00:00 UTC\nnew LeapSecond(new JulianDate(2457754, 43237.0, TimeStandard.TAI), 37) // January 1, 2017 00:00:00 UTC\n];\nexport default JulianDate;","map":{"version":3,"names":["binarySearch","defined","DeveloperError","GregorianDate","isLeapYear","LeapSecond","TimeConstants","TimeStandard","gregorianDateScratch","daysInMonth","daysInLeapFebruary","compareLeapSecondDates","leapSecond","dateToFind","JulianDate","compare","julianDate","binarySearchScratchLeapSecond","convertUtcToTai","leapSeconds","index","length","offset","difference","secondsDifference","addSeconds","convertTaiToUtc","result","undefined","setComponents","wholeDays","secondsOfDay","extraDays","SECONDS_PER_DAY","dayNumber","computeJulianDateComponents","year","month","day","hour","minute","second","millisecond","a","b","SECONDS_PER_HOUR","SECONDS_PER_MINUTE","SECONDS_PER_MILLISECOND","matchCalendarYear","matchCalendarMonth","matchOrdinalDate","matchWeekDate","matchCalendarDate","utcOffset","matchHours","source","matchHoursMinutes","matchHoursMinutesSeconds","iso8601ErrorMessage","julianDayNumber","timeStandard","UTC","fromGregorianDate","date","components","fromDate","Date","isNaN","getTime","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","fromIso8601","iso8601String","replace","tokens","split","time","tmp","inLeapYear","dashCount","match","dayOfYear","weekNumber","dayOfWeek","january4","getUTCDay","setUTCDate","offsetIndex","offsetHours","offsetMinutes","getTimezoneOffset","isLeapSecond","now","toGregorianDateScratch","TAI","toGregorianDate","thisUtc","L","N","I","J","remainingSeconds","toDate","gDate","toIso8601","precision","millisecondStr","millisecondHundreds","toFixed","toString","padStart","slice","clone","left","right","julianDayNumberDifference","equals","equalsEpsilon","epsilon","Math","abs","totalDays","dayDifference","daysDifference","secondDifference","computeTaiMinusUtc","seconds","addMinutes","minutes","newSecondsOfDay","addHours","hours","addDays","days","newJulianDayNumber","lessThan","lessThanOrEquals","greaterThan","greaterThanOrEquals","prototype"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/JulianDate.js"],"sourcesContent":["import binarySearch from \"./binarySearch.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport GregorianDate from \"./GregorianDate.js\";\nimport isLeapYear from \"./isLeapYear.js\";\nimport LeapSecond from \"./LeapSecond.js\";\nimport TimeConstants from \"./TimeConstants.js\";\nimport TimeStandard from \"./TimeStandard.js\";\n\nconst gregorianDateScratch = new GregorianDate();\nconst daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst daysInLeapFebruary = 29;\n\nfunction compareLeapSecondDates(leapSecond, dateToFind) {\n  return JulianDate.compare(leapSecond.julianDate, dateToFind.julianDate);\n}\n\n// we don't really need a leap second instance, anything with a julianDate property will do\nconst binarySearchScratchLeapSecond = new LeapSecond();\n\nfunction convertUtcToTai(julianDate) {\n  //Even though julianDate is in UTC, we'll treat it as TAI and\n  //search the leap second table for it.\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  const leapSeconds = JulianDate.leapSeconds;\n  let index = binarySearch(\n    leapSeconds,\n    binarySearchScratchLeapSecond,\n    compareLeapSecondDates,\n  );\n\n  if (index < 0) {\n    index = ~index;\n  }\n\n  if (index >= leapSeconds.length) {\n    index = leapSeconds.length - 1;\n  }\n\n  let offset = leapSeconds[index].offset;\n  if (index > 0) {\n    //Now we have the index of the closest leap second that comes on or after our UTC time.\n    //However, if the difference between the UTC date being converted and the TAI\n    //defined leap second is greater than the offset, we are off by one and need to use\n    //the previous leap second.\n    const difference = JulianDate.secondsDifference(\n      leapSeconds[index].julianDate,\n      julianDate,\n    );\n    if (difference > offset) {\n      index--;\n      offset = leapSeconds[index].offset;\n    }\n  }\n\n  JulianDate.addSeconds(julianDate, offset, julianDate);\n}\n\nfunction convertTaiToUtc(julianDate, result) {\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  const leapSeconds = JulianDate.leapSeconds;\n  let index = binarySearch(\n    leapSeconds,\n    binarySearchScratchLeapSecond,\n    compareLeapSecondDates,\n  );\n  if (index < 0) {\n    index = ~index;\n  }\n\n  //All times before our first leap second get the first offset.\n  if (index === 0) {\n    return JulianDate.addSeconds(julianDate, -leapSeconds[0].offset, result);\n  }\n\n  //All times after our leap second get the last offset.\n  if (index >= leapSeconds.length) {\n    return JulianDate.addSeconds(\n      julianDate,\n      -leapSeconds[index - 1].offset,\n      result,\n    );\n  }\n\n  //Compute the difference between the found leap second and the time we are converting.\n  const difference = JulianDate.secondsDifference(\n    leapSeconds[index].julianDate,\n    julianDate,\n  );\n\n  if (difference === 0) {\n    //The date is in our leap second table.\n    return JulianDate.addSeconds(\n      julianDate,\n      -leapSeconds[index].offset,\n      result,\n    );\n  }\n\n  if (difference <= 1.0) {\n    //The requested date is during the moment of a leap second, then we cannot convert to UTC\n    return undefined;\n  }\n\n  //The time is in between two leap seconds, index is the leap second after the date\n  //we're converting, so we subtract one to get the correct LeapSecond instance.\n  return JulianDate.addSeconds(\n    julianDate,\n    -leapSeconds[--index].offset,\n    result,\n  );\n}\n\nfunction setComponents(wholeDays, secondsOfDay, julianDate) {\n  const extraDays = (secondsOfDay / TimeConstants.SECONDS_PER_DAY) | 0;\n  wholeDays += extraDays;\n  secondsOfDay -= TimeConstants.SECONDS_PER_DAY * extraDays;\n\n  if (secondsOfDay < 0) {\n    wholeDays--;\n    secondsOfDay += TimeConstants.SECONDS_PER_DAY;\n  }\n\n  julianDate.dayNumber = wholeDays;\n  julianDate.secondsOfDay = secondsOfDay;\n  return julianDate;\n}\n\nfunction computeJulianDateComponents(\n  year,\n  month,\n  day,\n  hour,\n  minute,\n  second,\n  millisecond,\n) {\n  // Algorithm from page 604 of the Explanatory Supplement to the\n  // Astronomical Almanac (Seidelmann 1992).\n\n  const a = ((month - 14) / 12) | 0;\n  const b = year + 4800 + a;\n  let dayNumber =\n    (((1461 * b) / 4) | 0) +\n    (((367 * (month - 2 - 12 * a)) / 12) | 0) -\n    (((3 * (((b + 100) / 100) | 0)) / 4) | 0) +\n    day -\n    32075;\n\n  // JulianDates are noon-based\n  hour = hour - 12;\n  if (hour < 0) {\n    hour += 24;\n  }\n\n  const secondsOfDay =\n    second +\n    (hour * TimeConstants.SECONDS_PER_HOUR +\n      minute * TimeConstants.SECONDS_PER_MINUTE +\n      millisecond * TimeConstants.SECONDS_PER_MILLISECOND);\n\n  if (secondsOfDay >= 43200.0) {\n    dayNumber -= 1;\n  }\n\n  return [dayNumber, secondsOfDay];\n}\n\n//Regular expressions used for ISO8601 date parsing.\n//YYYY\nconst matchCalendarYear = /^(\\d{4})$/;\n//YYYY-MM (YYYYMM is invalid)\nconst matchCalendarMonth = /^(\\d{4})-(\\d{2})$/;\n//YYYY-DDD or YYYYDDD\nconst matchOrdinalDate = /^(\\d{4})-?(\\d{3})$/;\n//YYYY-Www or YYYYWww or YYYY-Www-D or YYYYWwwD\nconst matchWeekDate = /^(\\d{4})-?W(\\d{2})-?(\\d{1})?$/;\n//YYYY-MM-DD or YYYYMMDD\nconst matchCalendarDate = /^(\\d{4})-?(\\d{2})-?(\\d{2})$/;\n// Match utc offset\nconst utcOffset = /([Z+\\-])?(\\d{2})?:?(\\d{2})?$/;\n// Match hours HH or HH.xxxxx\nconst matchHours = /^(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n// Match hours/minutes HH:MM HHMM.xxxxx\nconst matchHoursMinutes = /^(\\d{2}):?(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n// Match hours/minutes HH:MM:SS HHMMSS.xxxxx\nconst matchHoursMinutesSeconds =\n  /^(\\d{2}):?(\\d{2}):?(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n\nconst iso8601ErrorMessage = \"Invalid ISO 8601 date.\";\n\n/**\n * Represents an astronomical Julian date, which is the number of days since noon on January 1, -4712 (4713 BC).\n * For increased precision, this class stores the whole number part of the date and the seconds\n * part of the date in separate components.  In order to be safe for arithmetic and represent\n * leap seconds, the date is always stored in the International Atomic Time standard\n * {@link TimeStandard.TAI}.\n * @alias JulianDate\n * @constructor\n *\n * @param {number} [julianDayNumber=0.0] The Julian Day Number representing the number of whole days.  Fractional days will also be handled correctly.\n * @param {number} [secondsOfDay=0.0] The number of seconds into the current Julian Day Number.  Fractional seconds, negative seconds and seconds greater than a day will be handled correctly.\n * @param {TimeStandard} [timeStandard=TimeStandard.UTC] The time standard in which the first two parameters are defined.\n */\nfunction JulianDate(julianDayNumber, secondsOfDay, timeStandard) {\n  /**\n   * Gets or sets the number of whole days.\n   * @type {number}\n   */\n  this.dayNumber = undefined;\n\n  /**\n   * Gets or sets the number of seconds into the current day.\n   * @type {number}\n   */\n  this.secondsOfDay = undefined;\n\n  julianDayNumber = julianDayNumber ?? 0.0;\n  secondsOfDay = secondsOfDay ?? 0.0;\n  timeStandard = timeStandard ?? TimeStandard.UTC;\n\n  //If julianDayNumber is fractional, make it an integer and add the number of seconds the fraction represented.\n  const wholeDays = julianDayNumber | 0;\n  secondsOfDay =\n    secondsOfDay +\n    (julianDayNumber - wholeDays) * TimeConstants.SECONDS_PER_DAY;\n\n  setComponents(wholeDays, secondsOfDay, this);\n\n  if (timeStandard === TimeStandard.UTC) {\n    convertUtcToTai(this);\n  }\n}\n\n/**\n * Creates a new instance from a GregorianDate.\n *\n * @param {GregorianDate} date A GregorianDate.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} date must be a valid GregorianDate.\n */\nJulianDate.fromGregorianDate = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!(date instanceof GregorianDate)) {\n    throw new DeveloperError(\"date must be a valid GregorianDate.\");\n  }\n  //>>includeEnd('debug');\n\n  const components = computeJulianDateComponents(\n    date.year,\n    date.month,\n    date.day,\n    date.hour,\n    date.minute,\n    date.second,\n    date.millisecond,\n  );\n  if (!defined(result)) {\n    return new JulianDate(components[0], components[1], TimeStandard.UTC);\n  }\n  setComponents(components[0], components[1], result);\n  convertUtcToTai(result);\n  return result;\n};\n\n/**\n * Creates a new instance from a JavaScript Date.\n *\n * @param {Date} date A JavaScript Date.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} date must be a valid JavaScript Date.\n */\nJulianDate.fromDate = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!(date instanceof Date) || isNaN(date.getTime())) {\n    throw new DeveloperError(\"date must be a valid JavaScript Date.\");\n  }\n  //>>includeEnd('debug');\n\n  const components = computeJulianDateComponents(\n    date.getUTCFullYear(),\n    date.getUTCMonth() + 1,\n    date.getUTCDate(),\n    date.getUTCHours(),\n    date.getUTCMinutes(),\n    date.getUTCSeconds(),\n    date.getUTCMilliseconds(),\n  );\n  if (!defined(result)) {\n    return new JulianDate(components[0], components[1], TimeStandard.UTC);\n  }\n  setComponents(components[0], components[1], result);\n  convertUtcToTai(result);\n  return result;\n};\n\n/**\n * Creates a new instance from a from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date.\n * This method is superior to <code>Date.parse</code> because it will handle all valid formats defined by the ISO 8601\n * specification, including leap seconds and sub-millisecond times, which discarded by most JavaScript implementations.\n *\n * @param {string} iso8601String An ISO 8601 date.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} Invalid ISO 8601 date.\n */\nJulianDate.fromIso8601 = function (iso8601String, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof iso8601String !== \"string\") {\n    throw new DeveloperError(iso8601ErrorMessage);\n  }\n  //>>includeEnd('debug');\n\n  //Comma and decimal point both indicate a fractional number according to ISO 8601,\n  //start out by blanket replacing , with . which is the only valid such symbol in JS.\n  iso8601String = iso8601String.replace(\",\", \".\");\n\n  //Split the string into its date and time components, denoted by a mandatory T\n  let tokens = iso8601String.split(\"T\");\n  let year;\n  let month = 1;\n  let day = 1;\n  let hour = 0;\n  let minute = 0;\n  let second = 0;\n  let millisecond = 0;\n\n  //Lacking a time is okay, but a missing date is illegal.\n  const date = tokens[0];\n  const time = tokens[1];\n  let tmp;\n  let inLeapYear;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(iso8601ErrorMessage);\n  }\n\n  let dashCount;\n  //>>includeEnd('debug');\n\n  //First match the date against possible regular expressions.\n  tokens = date.match(matchCalendarDate);\n  if (tokens !== null) {\n    //>>includeStart('debug', pragmas.debug);\n    dashCount = date.split(\"-\").length - 1;\n    if (dashCount > 0 && dashCount !== 2) {\n      throw new DeveloperError(iso8601ErrorMessage);\n    }\n    //>>includeEnd('debug');\n    year = +tokens[1];\n    month = +tokens[2];\n    day = +tokens[3];\n  } else {\n    tokens = date.match(matchCalendarMonth);\n    if (tokens !== null) {\n      year = +tokens[1];\n      month = +tokens[2];\n    } else {\n      tokens = date.match(matchCalendarYear);\n      if (tokens !== null) {\n        year = +tokens[1];\n      } else {\n        //Not a year/month/day so it must be an ordinal date.\n        let dayOfYear;\n        tokens = date.match(matchOrdinalDate);\n        if (tokens !== null) {\n          year = +tokens[1];\n          dayOfYear = +tokens[2];\n          inLeapYear = isLeapYear(year);\n\n          //This validation is only applicable for this format.\n          //>>includeStart('debug', pragmas.debug);\n          if (\n            dayOfYear < 1 ||\n            (inLeapYear && dayOfYear > 366) ||\n            (!inLeapYear && dayOfYear > 365)\n          ) {\n            throw new DeveloperError(iso8601ErrorMessage);\n          }\n          //>>includeEnd('debug');\n        } else {\n          tokens = date.match(matchWeekDate);\n          if (tokens !== null) {\n            //ISO week date to ordinal date from\n            //http://en.wikipedia.org/w/index.php?title=ISO_week_date&oldid=474176775\n            year = +tokens[1];\n            const weekNumber = +tokens[2];\n            const dayOfWeek = +tokens[3] || 0;\n\n            //>>includeStart('debug', pragmas.debug);\n            dashCount = date.split(\"-\").length - 1;\n            if (\n              dashCount > 0 &&\n              ((!defined(tokens[3]) && dashCount !== 1) ||\n                (defined(tokens[3]) && dashCount !== 2))\n            ) {\n              throw new DeveloperError(iso8601ErrorMessage);\n            }\n            //>>includeEnd('debug');\n\n            const january4 = new Date(Date.UTC(year, 0, 4));\n            dayOfYear = weekNumber * 7 + dayOfWeek - january4.getUTCDay() - 3;\n          } else {\n            //None of our regular expressions succeeded in parsing the date properly.\n            //>>includeStart('debug', pragmas.debug);\n            throw new DeveloperError(iso8601ErrorMessage);\n            //>>includeEnd('debug');\n          }\n        }\n        //Split an ordinal date into month/day.\n        tmp = new Date(Date.UTC(year, 0, 1));\n        tmp.setUTCDate(dayOfYear);\n        month = tmp.getUTCMonth() + 1;\n        day = tmp.getUTCDate();\n      }\n    }\n  }\n\n  //Now that we have all of the date components, validate them to make sure nothing is out of range.\n  inLeapYear = isLeapYear(year);\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    month < 1 ||\n    month > 12 ||\n    day < 1 ||\n    ((month !== 2 || !inLeapYear) && day > daysInMonth[month - 1]) ||\n    (inLeapYear && month === 2 && day > daysInLeapFebruary)\n  ) {\n    throw new DeveloperError(iso8601ErrorMessage);\n  }\n  //>>includeEnd('debug');\n\n  //Now move onto the time string, which is much simpler.\n  //If no time is specified, it is considered the beginning of the day, UTC to match Javascript's implementation.\n  let offsetIndex;\n  if (defined(time)) {\n    tokens = time.match(matchHoursMinutesSeconds);\n    if (tokens !== null) {\n      //>>includeStart('debug', pragmas.debug);\n      dashCount = time.split(\":\").length - 1;\n      if (dashCount > 0 && dashCount !== 2 && dashCount !== 3) {\n        throw new DeveloperError(iso8601ErrorMessage);\n      }\n      //>>includeEnd('debug');\n\n      hour = +tokens[1];\n      minute = +tokens[2];\n      second = +tokens[3];\n      millisecond = +(tokens[4] || 0) * 1000.0;\n      offsetIndex = 5;\n    } else {\n      tokens = time.match(matchHoursMinutes);\n      if (tokens !== null) {\n        //>>includeStart('debug', pragmas.debug);\n        dashCount = time.split(\":\").length - 1;\n        if (dashCount > 2) {\n          throw new DeveloperError(iso8601ErrorMessage);\n        }\n        //>>includeEnd('debug');\n\n        hour = +tokens[1];\n        minute = +tokens[2];\n        second = +(tokens[3] || 0) * 60.0;\n        offsetIndex = 4;\n      } else {\n        tokens = time.match(matchHours);\n        if (tokens !== null) {\n          hour = +tokens[1];\n          minute = +(tokens[2] || 0) * 60.0;\n          offsetIndex = 3;\n        } else {\n          //>>includeStart('debug', pragmas.debug);\n          throw new DeveloperError(iso8601ErrorMessage);\n          //>>includeEnd('debug');\n        }\n      }\n    }\n\n    //Validate that all values are in proper range.  Minutes and hours have special cases at 60 and 24.\n    //>>includeStart('debug', pragmas.debug);\n    if (\n      minute >= 60 ||\n      second >= 61 ||\n      hour > 24 ||\n      (hour === 24 && (minute > 0 || second > 0 || millisecond > 0))\n    ) {\n      throw new DeveloperError(iso8601ErrorMessage);\n    }\n    //>>includeEnd('debug');\n\n    //Check the UTC offset value, if no value exists, use local time\n    //a Z indicates UTC, + or - are offsets.\n    const offset = tokens[offsetIndex];\n    const offsetHours = +tokens[offsetIndex + 1];\n    const offsetMinutes = +(tokens[offsetIndex + 2] || 0);\n    switch (offset) {\n      case \"+\":\n        hour = hour - offsetHours;\n        minute = minute - offsetMinutes;\n        break;\n      case \"-\":\n        hour = hour + offsetHours;\n        minute = minute + offsetMinutes;\n        break;\n      case \"Z\":\n        break;\n      default:\n        minute =\n          minute +\n          new Date(\n            Date.UTC(year, month - 1, day, hour, minute),\n          ).getTimezoneOffset();\n        break;\n    }\n  }\n\n  //ISO8601 denotes a leap second by any time having a seconds component of 60 seconds.\n  //If that's the case, we need to temporarily subtract a second in order to build a UTC date.\n  //Then we add it back in after converting to TAI.\n  const isLeapSecond = second === 60;\n  if (isLeapSecond) {\n    second--;\n  }\n\n  //Even if we successfully parsed the string into its components, after applying UTC offset or\n  //special cases like 24:00:00 denoting midnight, we need to normalize the data appropriately.\n\n  //milliseconds can never be greater than 1000, and seconds can't be above 60, so we start with minutes\n  while (minute >= 60) {\n    minute -= 60;\n    hour++;\n  }\n\n  while (hour >= 24) {\n    hour -= 24;\n    day++;\n  }\n\n  tmp = inLeapYear && month === 2 ? daysInLeapFebruary : daysInMonth[month - 1];\n  while (day > tmp) {\n    day -= tmp;\n    month++;\n\n    if (month > 12) {\n      month -= 12;\n      year++;\n    }\n\n    tmp =\n      inLeapYear && month === 2 ? daysInLeapFebruary : daysInMonth[month - 1];\n  }\n\n  //If UTC offset is at the beginning/end of the day, minutes can be negative.\n  while (minute < 0) {\n    minute += 60;\n    hour--;\n  }\n\n  while (hour < 0) {\n    hour += 24;\n    day--;\n  }\n\n  while (day < 1) {\n    month--;\n    if (month < 1) {\n      month += 12;\n      year--;\n    }\n\n    tmp =\n      inLeapYear && month === 2 ? daysInLeapFebruary : daysInMonth[month - 1];\n    day += tmp;\n  }\n\n  //Now create the JulianDate components from the Gregorian date and actually create our instance.\n  const components = computeJulianDateComponents(\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n  );\n\n  if (!defined(result)) {\n    result = new JulianDate(components[0], components[1], TimeStandard.UTC);\n  } else {\n    setComponents(components[0], components[1], result);\n    convertUtcToTai(result);\n  }\n\n  //If we were on a leap second, add it back.\n  if (isLeapSecond) {\n    JulianDate.addSeconds(result, 1, result);\n  }\n\n  return result;\n};\n\n/**\n * Creates a new instance that represents the current system time.\n * This is equivalent to calling <code>JulianDate.fromDate(new Date());</code>.\n *\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n */\nJulianDate.now = function (result) {\n  return JulianDate.fromDate(new Date(), result);\n};\n\nconst toGregorianDateScratch = new JulianDate(0, 0, TimeStandard.TAI);\n\n/**\n * Creates a {@link GregorianDate} from the provided instance.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @param {GregorianDate} [result] An existing instance to use for the result.\n * @returns {GregorianDate} The modified result parameter or a new instance if none was provided.\n */\nJulianDate.toGregorianDate = function (julianDate, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let isLeapSecond = false;\n  let thisUtc = convertTaiToUtc(julianDate, toGregorianDateScratch);\n  if (!defined(thisUtc)) {\n    //Conversion to UTC will fail if we are during a leap second.\n    //If that's the case, subtract a second and convert again.\n    //JavaScript doesn't support leap seconds, so this results in second 59 being repeated twice.\n    JulianDate.addSeconds(julianDate, -1, toGregorianDateScratch);\n    thisUtc = convertTaiToUtc(toGregorianDateScratch, toGregorianDateScratch);\n    isLeapSecond = true;\n  }\n\n  let julianDayNumber = thisUtc.dayNumber;\n  const secondsOfDay = thisUtc.secondsOfDay;\n\n  if (secondsOfDay >= 43200.0) {\n    julianDayNumber += 1;\n  }\n\n  // Algorithm from page 604 of the Explanatory Supplement to the\n  // Astronomical Almanac (Seidelmann 1992).\n  let L = (julianDayNumber + 68569) | 0;\n  const N = ((4 * L) / 146097) | 0;\n  L = (L - (((146097 * N + 3) / 4) | 0)) | 0;\n  const I = ((4000 * (L + 1)) / 1461001) | 0;\n  L = (L - (((1461 * I) / 4) | 0) + 31) | 0;\n  const J = ((80 * L) / 2447) | 0;\n  const day = (L - (((2447 * J) / 80) | 0)) | 0;\n  L = (J / 11) | 0;\n  const month = (J + 2 - 12 * L) | 0;\n  const year = (100 * (N - 49) + I + L) | 0;\n\n  let hour = (secondsOfDay / TimeConstants.SECONDS_PER_HOUR) | 0;\n  let remainingSeconds = secondsOfDay - hour * TimeConstants.SECONDS_PER_HOUR;\n  const minute = (remainingSeconds / TimeConstants.SECONDS_PER_MINUTE) | 0;\n  remainingSeconds =\n    remainingSeconds - minute * TimeConstants.SECONDS_PER_MINUTE;\n  let second = remainingSeconds | 0;\n  const millisecond =\n    (remainingSeconds - second) / TimeConstants.SECONDS_PER_MILLISECOND;\n\n  // JulianDates are noon-based\n  hour += 12;\n  if (hour > 23) {\n    hour -= 24;\n  }\n\n  //If we were on a leap second, add it back.\n  if (isLeapSecond) {\n    second += 1;\n  }\n\n  if (!defined(result)) {\n    return new GregorianDate(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      isLeapSecond,\n    );\n  }\n\n  result.year = year;\n  result.month = month;\n  result.day = day;\n  result.hour = hour;\n  result.minute = minute;\n  result.second = second;\n  result.millisecond = millisecond;\n  result.isLeapSecond = isLeapSecond;\n  return result;\n};\n\n/**\n * Creates a JavaScript Date from the provided instance.\n * Since JavaScript dates are only accurate to the nearest millisecond and\n * cannot represent a leap second, consider using {@link JulianDate.toGregorianDate} instead.\n * If the provided JulianDate is during a leap second, the previous second is used.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @returns {Date} A new instance representing the provided date.\n */\nJulianDate.toDate = function (julianDate) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);\n  let second = gDate.second;\n  if (gDate.isLeapSecond) {\n    second -= 1;\n  }\n  return new Date(\n    Date.UTC(\n      gDate.year,\n      gDate.month - 1,\n      gDate.day,\n      gDate.hour,\n      gDate.minute,\n      second,\n      gDate.millisecond,\n    ),\n  );\n};\n\n/**\n * Creates an ISO8601 representation of the provided date.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @param {number} [precision] The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.\n * @returns {string} The ISO8601 representation of the provided date.\n */\nJulianDate.toIso8601 = function (julianDate, precision) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);\n  let year = gDate.year;\n  let month = gDate.month;\n  let day = gDate.day;\n  let hour = gDate.hour;\n  const minute = gDate.minute;\n  const second = gDate.second;\n  const millisecond = gDate.millisecond;\n\n  // special case - Iso8601.MAXIMUM_VALUE produces a string which we can't parse unless we adjust.\n  // 10000-01-01T00:00:00 is the same instant as 9999-12-31T24:00:00\n  if (\n    year === 10000 &&\n    month === 1 &&\n    day === 1 &&\n    hour === 0 &&\n    minute === 0 &&\n    second === 0 &&\n    millisecond === 0\n  ) {\n    year = 9999;\n    month = 12;\n    day = 31;\n    hour = 24;\n  }\n\n  let millisecondStr;\n\n  if (!defined(precision) && millisecond !== 0) {\n    // Forces milliseconds into a number with at least 3 digits.\n    const millisecondHundreds = millisecond * 0.01;\n    // Below 1e-6, toString returns scientific notation, so it should be replaced by toFixed with appropriate number of digits.\n    // 20 digits is a trade-off choice guided by JavaScript's Number representation accuracy (15-17 decimal digits for most numbers).\n    // Using toFixed(20) ensures capturing enough precision while avoiding inaccuracies due to floating-point limitations.\n    millisecondStr =\n      millisecondHundreds < 1e-6\n        ? millisecondHundreds.toFixed(20).replace(\".\", \"\").replace(/0+$/, \"\")\n        : millisecondHundreds.toString().replace(\".\", \"\");\n    return `${year.toString().padStart(4, \"0\")}-${month\n      .toString()\n      .padStart(2, \"0\")}-${day.toString().padStart(2, \"0\")}T${hour\n      .toString()\n      .padStart(2, \"0\")}:${minute.toString().padStart(2, \"0\")}:${second\n      .toString()\n      .padStart(2, \"0\")}.${millisecondStr}Z`;\n  }\n\n  //Precision is either 0 or milliseconds is 0 with undefined precision, in either case, leave off milliseconds entirely\n  if (!defined(precision) || precision === 0) {\n    return `${year.toString().padStart(4, \"0\")}-${month\n      .toString()\n      .padStart(2, \"0\")}-${day.toString().padStart(2, \"0\")}T${hour\n      .toString()\n      .padStart(2, \"0\")}:${minute\n      .toString()\n      .padStart(2, \"0\")}:${second.toString().padStart(2, \"0\")}Z`;\n  }\n\n  //Forces milliseconds into a number with at least 3 digits to whatever the specified precision is.\n  millisecondStr = (millisecond * 0.01)\n    .toFixed(precision)\n    .replace(\".\", \"\")\n    .slice(0, precision);\n  return `${year.toString().padStart(4, \"0\")}-${month\n    .toString()\n    .padStart(2, \"0\")}-${day.toString().padStart(2, \"0\")}T${hour\n    .toString()\n    .padStart(2, \"0\")}:${minute.toString().padStart(2, \"0\")}:${second\n    .toString()\n    .padStart(2, \"0\")}.${millisecondStr}Z`;\n};\n\n/**\n * Duplicates a JulianDate instance.\n *\n * @param {JulianDate} julianDate The date to duplicate.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided. Returns undefined if julianDate is undefined.\n */\nJulianDate.clone = function (julianDate, result) {\n  if (!defined(julianDate)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new JulianDate(\n      julianDate.dayNumber,\n      julianDate.secondsOfDay,\n      TimeStandard.TAI,\n    );\n  }\n  result.dayNumber = julianDate.dayNumber;\n  result.secondsOfDay = julianDate.secondsOfDay;\n  return result;\n};\n\n/**\n * Compares two instances.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {number} A negative value if left is less than right, a positive value if left is greater than right, or zero if left and right are equal.\n */\nJulianDate.compare = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const julianDayNumberDifference = left.dayNumber - right.dayNumber;\n  if (julianDayNumberDifference !== 0) {\n    return julianDayNumberDifference;\n  }\n  return left.secondsOfDay - right.secondsOfDay;\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {JulianDate} [left] The first instance.\n * @param {JulianDate} [right] The second instance.\n * @returns {boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n */\nJulianDate.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.dayNumber === right.dayNumber &&\n      left.secondsOfDay === right.secondsOfDay)\n  );\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n * each other.  That is, in order for the dates to be considered equal (and for\n * this function to return <code>true</code>), the absolute value of the difference between them, in\n * seconds, must be less than <code>epsilon</code>.\n *\n * @param {JulianDate} [left] The first instance.\n * @param {JulianDate} [right] The second instance.\n * @param {number} [epsilon=0] The maximum number of seconds that should separate the two instances.\n * @returns {boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n */\nJulianDate.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = epsilon ?? 0;\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(JulianDate.secondsDifference(left, right)) <= epsilon)\n  );\n};\n\n/**\n * Computes the total number of whole and fractional days represented by the provided instance.\n *\n * @param {JulianDate} julianDate The date.\n * @returns {number} The Julian date as single floating point number.\n */\nJulianDate.totalDays = function (julianDate) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n  return (\n    julianDate.dayNumber +\n    julianDate.secondsOfDay / TimeConstants.SECONDS_PER_DAY\n  );\n};\n\n/**\n * Computes the difference in seconds between the provided instance.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {number} The difference, in seconds, when subtracting <code>right</code> from <code>left</code>.\n */\nJulianDate.secondsDifference = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const dayDifference =\n    (left.dayNumber - right.dayNumber) * TimeConstants.SECONDS_PER_DAY;\n  return dayDifference + (left.secondsOfDay - right.secondsOfDay);\n};\n\n/**\n * Computes the difference in days between the provided instance.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {number} The difference, in days, when subtracting <code>right</code> from <code>left</code>.\n */\nJulianDate.daysDifference = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const dayDifference = left.dayNumber - right.dayNumber;\n  const secondDifference =\n    (left.secondsOfDay - right.secondsOfDay) / TimeConstants.SECONDS_PER_DAY;\n  return dayDifference + secondDifference;\n};\n\n/**\n * Computes the number of seconds the provided instance is ahead of UTC.\n *\n * @param {JulianDate} julianDate The date.\n * @returns {number} The number of seconds the provided instance is ahead of UTC\n */\nJulianDate.computeTaiMinusUtc = function (julianDate) {\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  const leapSeconds = JulianDate.leapSeconds;\n  let index = binarySearch(\n    leapSeconds,\n    binarySearchScratchLeapSecond,\n    compareLeapSecondDates,\n  );\n  if (index < 0) {\n    index = ~index;\n    --index;\n    if (index < 0) {\n      index = 0;\n    }\n  }\n  return leapSeconds[index].offset;\n};\n\n/**\n * Adds the provided number of seconds to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {number} seconds The number of seconds to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addSeconds = function (julianDate, seconds, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  if (!defined(seconds)) {\n    throw new DeveloperError(\"seconds is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return setComponents(\n    julianDate.dayNumber,\n    julianDate.secondsOfDay + seconds,\n    result,\n  );\n};\n\n/**\n * Adds the provided number of minutes to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {number} minutes The number of minutes to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addMinutes = function (julianDate, minutes, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  if (!defined(minutes)) {\n    throw new DeveloperError(\"minutes is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const newSecondsOfDay =\n    julianDate.secondsOfDay + minutes * TimeConstants.SECONDS_PER_MINUTE;\n  return setComponents(julianDate.dayNumber, newSecondsOfDay, result);\n};\n\n/**\n * Adds the provided number of hours to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {number} hours The number of hours to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addHours = function (julianDate, hours, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  if (!defined(hours)) {\n    throw new DeveloperError(\"hours is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const newSecondsOfDay =\n    julianDate.secondsOfDay + hours * TimeConstants.SECONDS_PER_HOUR;\n  return setComponents(julianDate.dayNumber, newSecondsOfDay, result);\n};\n\n/**\n * Adds the provided number of days to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {number} days The number of days to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addDays = function (julianDate, days, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  if (!defined(days)) {\n    throw new DeveloperError(\"days is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const newJulianDayNumber = julianDate.dayNumber + days;\n  return setComponents(newJulianDayNumber, julianDate.secondsOfDay, result);\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {boolean} <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.lessThan = function (left, right) {\n  return JulianDate.compare(left, right) < 0;\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {boolean} <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.lessThanOrEquals = function (left, right) {\n  return JulianDate.compare(left, right) <= 0;\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {boolean} <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.greaterThan = function (left, right) {\n  return JulianDate.compare(left, right) > 0;\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {boolean} <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.greaterThanOrEquals = function (left, right) {\n  return JulianDate.compare(left, right) >= 0;\n};\n\n/**\n * Duplicates this instance.\n *\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n */\nJulianDate.prototype.clone = function (result) {\n  return JulianDate.clone(this, result);\n};\n\n/**\n * Compares this and the provided instance and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {JulianDate} [right] The second instance.\n * @returns {boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n */\nJulianDate.prototype.equals = function (right) {\n  return JulianDate.equals(this, right);\n};\n\n/**\n * Compares this and the provided instance and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n * each other.  That is, in order for the dates to be considered equal (and for\n * this function to return <code>true</code>), the absolute value of the difference between them, in\n * seconds, must be less than <code>epsilon</code>.\n *\n * @param {JulianDate} [right] The second instance.\n * @param {number} [epsilon=0] The maximum number of seconds that should separate the two instances.\n * @returns {boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n */\nJulianDate.prototype.equalsEpsilon = function (right, epsilon) {\n  return JulianDate.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this date in ISO8601 format.\n *\n * @returns {string} A string representing this date in ISO8601 format.\n */\nJulianDate.prototype.toString = function () {\n  return JulianDate.toIso8601(this);\n};\n\n/**\n * Gets or sets the list of leap seconds used throughout Cesium.\n * @memberof JulianDate\n * @type {LeapSecond[]}\n */\nJulianDate.leapSeconds = [\n  new LeapSecond(new JulianDate(2441317, 43210.0, TimeStandard.TAI), 10), // January 1, 1972 00:00:00 UTC\n  new LeapSecond(new JulianDate(2441499, 43211.0, TimeStandard.TAI), 11), // July 1, 1972 00:00:00 UTC\n  new LeapSecond(new JulianDate(2441683, 43212.0, TimeStandard.TAI), 12), // January 1, 1973 00:00:00 UTC\n  new LeapSecond(new JulianDate(2442048, 43213.0, TimeStandard.TAI), 13), // January 1, 1974 00:00:00 UTC\n  new LeapSecond(new JulianDate(2442413, 43214.0, TimeStandard.TAI), 14), // January 1, 1975 00:00:00 UTC\n  new LeapSecond(new JulianDate(2442778, 43215.0, TimeStandard.TAI), 15), // January 1, 1976 00:00:00 UTC\n  new LeapSecond(new JulianDate(2443144, 43216.0, TimeStandard.TAI), 16), // January 1, 1977 00:00:00 UTC\n  new LeapSecond(new JulianDate(2443509, 43217.0, TimeStandard.TAI), 17), // January 1, 1978 00:00:00 UTC\n  new LeapSecond(new JulianDate(2443874, 43218.0, TimeStandard.TAI), 18), // January 1, 1979 00:00:00 UTC\n  new LeapSecond(new JulianDate(2444239, 43219.0, TimeStandard.TAI), 19), // January 1, 1980 00:00:00 UTC\n  new LeapSecond(new JulianDate(2444786, 43220.0, TimeStandard.TAI), 20), // July 1, 1981 00:00:00 UTC\n  new LeapSecond(new JulianDate(2445151, 43221.0, TimeStandard.TAI), 21), // July 1, 1982 00:00:00 UTC\n  new LeapSecond(new JulianDate(2445516, 43222.0, TimeStandard.TAI), 22), // July 1, 1983 00:00:00 UTC\n  new LeapSecond(new JulianDate(2446247, 43223.0, TimeStandard.TAI), 23), // July 1, 1985 00:00:00 UTC\n  new LeapSecond(new JulianDate(2447161, 43224.0, TimeStandard.TAI), 24), // January 1, 1988 00:00:00 UTC\n  new LeapSecond(new JulianDate(2447892, 43225.0, TimeStandard.TAI), 25), // January 1, 1990 00:00:00 UTC\n  new LeapSecond(new JulianDate(2448257, 43226.0, TimeStandard.TAI), 26), // January 1, 1991 00:00:00 UTC\n  new LeapSecond(new JulianDate(2448804, 43227.0, TimeStandard.TAI), 27), // July 1, 1992 00:00:00 UTC\n  new LeapSecond(new JulianDate(2449169, 43228.0, TimeStandard.TAI), 28), // July 1, 1993 00:00:00 UTC\n  new LeapSecond(new JulianDate(2449534, 43229.0, TimeStandard.TAI), 29), // July 1, 1994 00:00:00 UTC\n  new LeapSecond(new JulianDate(2450083, 43230.0, TimeStandard.TAI), 30), // January 1, 1996 00:00:00 UTC\n  new LeapSecond(new JulianDate(2450630, 43231.0, TimeStandard.TAI), 31), // July 1, 1997 00:00:00 UTC\n  new LeapSecond(new JulianDate(2451179, 43232.0, TimeStandard.TAI), 32), // January 1, 1999 00:00:00 UTC\n  new LeapSecond(new JulianDate(2453736, 43233.0, TimeStandard.TAI), 33), // January 1, 2006 00:00:00 UTC\n  new LeapSecond(new JulianDate(2454832, 43234.0, TimeStandard.TAI), 34), // January 1, 2009 00:00:00 UTC\n  new LeapSecond(new JulianDate(2456109, 43235.0, TimeStandard.TAI), 35), // July 1, 2012 00:00:00 UTC\n  new LeapSecond(new JulianDate(2457204, 43236.0, TimeStandard.TAI), 36), // July 1, 2015 00:00:00 UTC\n  new LeapSecond(new JulianDate(2457754, 43237.0, TimeStandard.TAI), 37), // January 1, 2017 00:00:00 UTC\n];\nexport default JulianDate;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}