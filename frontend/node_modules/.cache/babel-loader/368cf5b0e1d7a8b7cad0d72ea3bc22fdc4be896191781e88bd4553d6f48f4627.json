{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { isDigitChar, isAsciiLetterChar, isQuoteChar, isWhitespaceChar, isControlChar } from '../char-utils';\nimport { assertNever } from '../utils';\n// For debugging: search for other \"For debugging\" lines\n// import CliTable from 'cli-table';\nvar CurrentTag = /** @class */function () {\n  function CurrentTag(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n    this.idx = cfg.idx !== undefined ? cfg.idx : -1;\n    this.type = cfg.type || 'tag';\n    this.name = cfg.name || '';\n    this.isOpening = !!cfg.isOpening;\n    this.isClosing = !!cfg.isClosing;\n  }\n  return CurrentTag;\n}();\nvar noCurrentTag = new CurrentTag(); // shared reference for when there is no current tag currently being read\n/**\n * Context object containing all the state needed by the HTML parsing state\n * machine function.\n *\n * ## Historical note\n *\n * In v4.1.5, we used nested functions to handle the context via closures, but\n * this necessitated re-creating the functions for each call to `parseHtml()`,\n * which made them difficult for v8 to JIT optimize. In v4.1.6, we lifted all of\n * the functions to the top-level scope and passed the context object between\n * them, which allows the functions to be JIT compiled once and reused.\n */\nvar ParseHtmlContext = /** @class */function () {\n  function ParseHtmlContext(html, callbacks) {\n    this.charIdx = 0; // Current character index being processed\n    this.state = 0 /* State.Data */; // begin in the Data state\n    this.currentDataIdx = 0; // where the current data start index is\n    this.currentTag = noCurrentTag; // describes the current tag that is being read\n    this.html = html;\n    this.callbacks = callbacks;\n  }\n  return ParseHtmlContext;\n}();\n/**\n * Parses an HTML string, calling the callbacks to notify of tags and text.\n *\n * ## History\n *\n * This file previously used a regular expression to find html tags in the input\n * text. Unfortunately, we ran into a bunch of catastrophic backtracking issues\n * with certain input text, causing Autolinker to either hang or just take a\n * really long time to parse the string.\n *\n * The current code is intended to be a O(n) algorithm that walks through\n * the string in one pass, and tries to be as cheap as possible. We don't need\n * to implement the full HTML spec, but rather simply determine where the string\n * looks like an HTML tag, and where it looks like text (so that we can autolink\n * that).\n *\n * This state machine parser is intended just to be a simple but performant\n * parser of HTML for the subset of requirements we have. We simply need to:\n *\n * 1. Determine where HTML tags are\n * 2. Determine the tag name (Autolinker specifically only cares about <a>,\n *    <script>, and <style> tags, so as not to link any text within them)\n *\n * We don't need to:\n *\n * 1. Create a parse tree\n * 2. Auto-close tags with invalid markup\n * 3. etc.\n *\n * The other intention behind this is that we didn't want to add external\n * dependencies on the Autolinker utility which would increase its size. For\n * instance, adding htmlparser2 adds 125kb to the minified output file,\n * increasing its final size from 47kb to 172kb (at the time of writing). It\n * also doesn't work exactly correctly, treating the string \"<3 blah blah blah\"\n * as an HTML tag.\n *\n * Reference for HTML spec:\n *\n *     https://www.w3.org/TR/html51/syntax.html#sec-tokenization\n *\n * @param {String} html The HTML to parse\n * @param {Object} callbacks\n * @param {Function} callbacks.onOpenTag Callback function to call when an open\n *   tag is parsed. Called with the tagName as its argument.\n * @param {Function} callbacks.onCloseTag Callback function to call when a close\n *   tag is parsed. Called with the tagName as its argument. If a self-closing\n *   tag is found, `onCloseTag` is called immediately after `onOpenTag`.\n * @param {Function} callbacks.onText Callback function to call when text (i.e\n *   not an HTML tag) is parsed. Called with the text (string) as its first\n *   argument, and offset (number) into the string as its second.\n */\nexport function parseHtml(html, callbacks) {\n  var context = new ParseHtmlContext(html, callbacks);\n  // For debugging: search for other \"For debugging\" lines\n  // const table = new CliTable( {\n  // \thead: [ 'charIdx', 'char', 'state', 'currentDataIdx', 'currentOpenTagIdx', 'tag.type' ]\n  // } );\n  var len = html.length;\n  while (context.charIdx < len) {\n    var char = html.charAt(context.charIdx);\n    var charCode = html.charCodeAt(context.charIdx);\n    // For debugging: search for other \"For debugging\" lines\n    // ALSO: Temporarily remove the 'const' keyword on the State enum\n    // table.push([\n    //     String(charIdx),\n    //     char,\n    //     State[state],\n    //     String(currentDataIdx),\n    //     String(currentTag.idx),\n    //     currentTag.idx === -1 ? '' : currentTag.type\n    // ]);\n    switch (context.state) {\n      case 0 /* State.Data */:\n        stateData(context, char);\n        break;\n      case 1 /* State.TagOpen */:\n        stateTagOpen(context, char, charCode);\n        break;\n      case 2 /* State.EndTagOpen */:\n        stateEndTagOpen(context, char, charCode);\n        break;\n      case 3 /* State.TagName */:\n        stateTagName(context, char, charCode);\n        break;\n      case 4 /* State.BeforeAttributeName */:\n        stateBeforeAttributeName(context, char, charCode);\n        break;\n      case 5 /* State.AttributeName */:\n        stateAttributeName(context, char, charCode);\n        break;\n      case 6 /* State.AfterAttributeName */:\n        stateAfterAttributeName(context, char, charCode);\n        break;\n      case 7 /* State.BeforeAttributeValue */:\n        stateBeforeAttributeValue(context, char, charCode);\n        break;\n      case 8 /* State.AttributeValueDoubleQuoted */:\n        stateAttributeValueDoubleQuoted(context, char);\n        break;\n      case 9 /* State.AttributeValueSingleQuoted */:\n        stateAttributeValueSingleQuoted(context, char);\n        break;\n      case 10 /* State.AttributeValueUnquoted */:\n        stateAttributeValueUnquoted(context, char, charCode);\n        break;\n      case 11 /* State.AfterAttributeValueQuoted */:\n        stateAfterAttributeValueQuoted(context, char, charCode);\n        break;\n      case 12 /* State.SelfClosingStartTag */:\n        stateSelfClosingStartTag(context, char);\n        break;\n      case 13 /* State.MarkupDeclarationOpenState */:\n        stateMarkupDeclarationOpen(context);\n        break;\n      case 14 /* State.CommentStart */:\n        stateCommentStart(context, char);\n        break;\n      case 15 /* State.CommentStartDash */:\n        stateCommentStartDash(context, char);\n        break;\n      case 16 /* State.Comment */:\n        stateComment(context, char);\n        break;\n      case 17 /* State.CommentEndDash */:\n        stateCommentEndDash(context, char);\n        break;\n      case 18 /* State.CommentEnd */:\n        stateCommentEnd(context, char);\n        break;\n      case 19 /* State.CommentEndBang */:\n        stateCommentEndBang(context, char);\n        break;\n      case 20 /* State.Doctype */:\n        stateDoctype(context, char);\n        break;\n      /* istanbul ignore next */\n      default:\n        assertNever(context.state);\n    }\n    // For debugging: search for other \"For debugging\" lines\n    // ALSO: Temporarily remove the 'const' keyword on the State enum\n    // table.push([\n    //     String(context.charIdx),\n    //     char,\n    //     State[context.state],\n    //     String(context.currentDataIdx),\n    //     String(context.currentTag.idx),\n    //     context.currentTag.idx === -1 ? '' : context.currentTag.type\n    // ]);\n    context.charIdx++;\n  }\n  if (context.currentDataIdx < context.charIdx) {\n    emitText(context);\n  }\n  // For debugging: search for other \"For debugging\" lines\n  // console.log( '\\n' + table.toString() );\n}\n// Called when non-tags are being read (i.e. the text around HTML †ags)\n// https://www.w3.org/TR/html51/syntax.html#data-state\nfunction stateData(context, char) {\n  if (char === '<') {\n    startNewTag(context);\n  }\n}\n// Called after a '<' is read from the Data state\n// https://www.w3.org/TR/html51/syntax.html#tag-open-state\nfunction stateTagOpen(context, char, charCode) {\n  if (char === '!') {\n    context.state = 13 /* State.MarkupDeclarationOpenState */;\n  } else if (char === '/') {\n    context.state = 2 /* State.EndTagOpen */;\n    context.currentTag = new CurrentTag(__assign(__assign({}, context.currentTag), {\n      isClosing: true\n    }));\n  } else if (char === '<') {\n    // start of another tag (ignore the previous, incomplete one)\n    startNewTag(context);\n  } else if (isAsciiLetterChar(charCode)) {\n    // tag name start (and no '/' read)\n    context.state = 3 /* State.TagName */;\n    context.currentTag = new CurrentTag(__assign(__assign({}, context.currentTag), {\n      isOpening: true\n    }));\n  } else {\n    // Any other\n    context.state = 0 /* State.Data */;\n    context.currentTag = noCurrentTag;\n  }\n}\n// After a '<x', '</x' sequence is read (where 'x' is a letter character),\n// this is to continue reading the tag name\n// https://www.w3.org/TR/html51/syntax.html#tag-name-state\nfunction stateTagName(context, char, charCode) {\n  if (isWhitespaceChar(charCode)) {\n    context.currentTag = new CurrentTag(__assign(__assign({}, context.currentTag), {\n      name: captureTagName(context)\n    }));\n    context.state = 4 /* State.BeforeAttributeName */;\n  } else if (char === '<') {\n    // start of another tag (ignore the previous, incomplete one)\n    startNewTag(context);\n  } else if (char === '/') {\n    context.currentTag = new CurrentTag(__assign(__assign({}, context.currentTag), {\n      name: captureTagName(context)\n    }));\n    context.state = 12 /* State.SelfClosingStartTag */;\n  } else if (char === '>') {\n    context.currentTag = new CurrentTag(__assign(__assign({}, context.currentTag), {\n      name: captureTagName(context)\n    }));\n    emitTagAndPreviousTextNode(context); // resets to Data state as well\n  } else if (!isAsciiLetterChar(charCode) && !isDigitChar(charCode) && char !== ':') {\n    // Anything else that does not form an html tag. Note: the colon\n    // character is accepted for XML namespaced tags\n    resetToDataState(context);\n  } else {\n    // continue reading tag name\n  }\n}\n// Called after the '/' is read from a '</' sequence\n// https://www.w3.org/TR/html51/syntax.html#end-tag-open-state\nfunction stateEndTagOpen(context, char, charCode) {\n  if (char === '>') {\n    // parse error. Encountered \"</>\". Skip it without treating as a tag\n    resetToDataState(context);\n  } else if (isAsciiLetterChar(charCode)) {\n    context.state = 3 /* State.TagName */;\n  } else {\n    // some other non-tag-like character, don't treat this as a tag\n    resetToDataState(context);\n  }\n}\n// https://www.w3.org/TR/html51/syntax.html#before-attribute-name-state\nfunction stateBeforeAttributeName(context, char, charCode) {\n  if (isWhitespaceChar(charCode)) {\n    // stay in BeforeAttributeName state - continue reading chars\n  } else if (char === '/') {\n    context.state = 12 /* State.SelfClosingStartTag */;\n  } else if (char === '>') {\n    emitTagAndPreviousTextNode(context); // resets to Data state as well\n  } else if (char === '<') {\n    // start of another tag (ignore the previous, incomplete one)\n    startNewTag(context);\n  } else if (char === \"=\" || isQuoteChar(charCode) || isControlChar(charCode)) {\n    // \"Parse error\" characters that, according to the spec, should be\n    // appended to the attribute name, but we'll treat these characters\n    // as not forming a real HTML tag\n    resetToDataState(context);\n  } else {\n    // Any other char, start of a new attribute name\n    context.state = 5 /* State.AttributeName */;\n  }\n}\n// https://www.w3.org/TR/html51/syntax.html#attribute-name-state\nfunction stateAttributeName(context, char, charCode) {\n  if (isWhitespaceChar(charCode)) {\n    context.state = 6 /* State.AfterAttributeName */;\n  } else if (char === '/') {\n    context.state = 12 /* State.SelfClosingStartTag */;\n  } else if (char === '=') {\n    context.state = 7 /* State.BeforeAttributeValue */;\n  } else if (char === '>') {\n    emitTagAndPreviousTextNode(context); // resets to Data state as well\n  } else if (char === '<') {\n    // start of another tag (ignore the previous, incomplete one)\n    startNewTag(context);\n  } else if (isQuoteChar(charCode)) {\n    // \"Parse error\" characters that, according to the spec, should be\n    // appended to the attribute name, but we'll treat these characters\n    // as not forming a real HTML tag\n    resetToDataState(context);\n  } else {\n    // anything else: continue reading attribute name\n  }\n}\n// https://www.w3.org/TR/html51/syntax.html#after-attribute-name-state\nfunction stateAfterAttributeName(context, char, charCode) {\n  if (isWhitespaceChar(charCode)) {\n    // ignore the character - continue reading\n  } else if (char === '/') {\n    context.state = 12 /* State.SelfClosingStartTag */;\n  } else if (char === '=') {\n    context.state = 7 /* State.BeforeAttributeValue */;\n  } else if (char === '>') {\n    emitTagAndPreviousTextNode(context);\n  } else if (char === '<') {\n    // start of another tag (ignore the previous, incomplete one)\n    startNewTag(context);\n  } else if (isQuoteChar(charCode)) {\n    // \"Parse error\" characters that, according to the spec, should be\n    // appended to the attribute name, but we'll treat these characters\n    // as not forming a real HTML tag\n    resetToDataState(context);\n  } else {\n    // Any other character, start a new attribute in the current tag\n    context.state = 5 /* State.AttributeName */;\n  }\n}\n// https://www.w3.org/TR/html51/syntax.html#before-attribute-value-state\nfunction stateBeforeAttributeValue(context, char, charCode) {\n  if (isWhitespaceChar(charCode)) {\n    // ignore the character - continue reading\n  } else if (char === \"\\\"\") {\n    context.state = 8 /* State.AttributeValueDoubleQuoted */;\n  } else if (char === \"'\") {\n    context.state = 9 /* State.AttributeValueSingleQuoted */;\n  } else if (/[>=`]/.test(char)) {\n    // Invalid chars after an '=' for an attribute value, don't count\n    // the current tag as an HTML tag\n    resetToDataState(context);\n  } else if (char === '<') {\n    // start of another tag (ignore the previous, incomplete one)\n    startNewTag(context);\n  } else {\n    // Any other character, consider it an unquoted attribute value\n    context.state = 10 /* State.AttributeValueUnquoted */;\n  }\n}\n// https://www.w3.org/TR/html51/syntax.html#attribute-value-double-quoted-state\nfunction stateAttributeValueDoubleQuoted(context, char) {\n  if (char === \"\\\"\") {\n    // end the current double-quoted attribute\n    context.state = 11 /* State.AfterAttributeValueQuoted */;\n  } else {\n    // consume the character as part of the double-quoted attribute value\n  }\n}\n// https://www.w3.org/TR/html51/syntax.html#attribute-value-single-quoted-state\nfunction stateAttributeValueSingleQuoted(context, char) {\n  if (char === \"'\") {\n    // end the current single-quoted attribute\n    context.state = 11 /* State.AfterAttributeValueQuoted */;\n  } else {\n    // consume the character as part of the double-quoted attribute value\n  }\n}\n// https://www.w3.org/TR/html51/syntax.html#attribute-value-unquoted-state\nfunction stateAttributeValueUnquoted(context, char, charCode) {\n  if (isWhitespaceChar(charCode)) {\n    context.state = 4 /* State.BeforeAttributeName */;\n  } else if (char === '>') {\n    emitTagAndPreviousTextNode(context);\n  } else if (char === '<') {\n    // start of another tag (ignore the previous, incomplete one)\n    startNewTag(context);\n  } else {\n    // Any other character, treat it as part of the attribute value\n  }\n}\n// Called after a double-quoted or single-quoted attribute value is read\n// (i.e. after the closing quote character)\n// https://www.w3.org/TR/html51/syntax.html#after-attribute-value-quoted-state\nfunction stateAfterAttributeValueQuoted(context, char, charCode) {\n  if (isWhitespaceChar(charCode)) {\n    context.state = 4 /* State.BeforeAttributeName */;\n  } else if (char === '/') {\n    context.state = 12 /* State.SelfClosingStartTag */;\n  } else if (char === '>') {\n    emitTagAndPreviousTextNode(context);\n  } else if (char === '<') {\n    // start of another tag (ignore the previous, incomplete one)\n    startNewTag(context);\n  } else {\n    // Any other character, \"parse error\". Spec says to switch to the\n    // BeforeAttributeState and re-consume the character, as it may be\n    // the start of a new attribute name\n    context.state = 4 /* State.BeforeAttributeName */;\n    reconsumeCurrentChar(context);\n  }\n}\n// A '/' has just been read in the current tag (presumably for '/>'), and\n// this handles the next character\n// https://www.w3.org/TR/html51/syntax.html#self-closing-start-tag-state\nfunction stateSelfClosingStartTag(context, char) {\n  if (char === '>') {\n    context.currentTag = new CurrentTag(__assign(__assign({}, context.currentTag), {\n      isClosing: true\n    }));\n    emitTagAndPreviousTextNode(context); // resets to Data state as well\n  } else {\n    // Note: the spec calls for a character after a '/' within a start\n    // tag to go back into the BeforeAttributeName state (in order to\n    // read more attributes, but for the purposes of Autolinker, this is\n    // most likely not a valid HTML tag. For example: \"<something / other>\"\n    // state = State.BeforeAttributeName;\n    // Instead, just treat as regular text\n    resetToDataState(context);\n  }\n}\n// https://www.w3.org/TR/html51/syntax.html#markup-declaration-open-state\n// (HTML Comments or !DOCTYPE)\nfunction stateMarkupDeclarationOpen(context) {\n  var html = context.html,\n    charIdx = context.charIdx;\n  if (html.slice(charIdx, charIdx + 2) === '--') {\n    // html comment\n    context.charIdx++; // \"consume\" the second '-' character. Next loop iteration will consume the character after the '<!--' sequence\n    context.currentTag = new CurrentTag(__assign(__assign({}, context.currentTag), {\n      type: 'comment'\n    }));\n    context.state = 14 /* State.CommentStart */;\n  } else if (html.slice(charIdx, charIdx + 7).toUpperCase() === 'DOCTYPE') {\n    context.charIdx += 6; // \"consume\" the characters \"OCTYPE\" (the current loop iteraction consumed the 'D'). Next loop iteration will consume the character after the '<!DOCTYPE' sequence\n    context.currentTag = new CurrentTag(__assign(__assign({}, context.currentTag), {\n      type: 'doctype'\n    }));\n    context.state = 20 /* State.Doctype */;\n  } else {\n    // At this point, the spec specifies that the state machine should\n    // enter the \"bogus comment\" state, in which case any character(s)\n    // after the '<!' that were read should become an HTML comment up\n    // until the first '>' that is read (or EOF). Instead, we'll assume\n    // that a user just typed '<!' as part of some piece of non-html\n    // text\n    resetToDataState(context);\n  }\n}\n// Handles after the sequence '<!--' has been read\n// https://www.w3.org/TR/html51/syntax.html#comment-start-state\nfunction stateCommentStart(context, char) {\n  if (char === '-') {\n    // We've read the sequence '<!---' at this point (3 dashes)\n    context.state = 15 /* State.CommentStartDash */;\n  } else if (char === '>') {\n    // At this point, we'll assume the comment wasn't a real comment\n    // so we'll just emit it as data. We basically read the sequence\n    // '<!-->'\n    resetToDataState(context);\n  } else {\n    // Any other char, take it as part of the comment\n    context.state = 16 /* State.Comment */;\n  }\n}\n// We've read the sequence '<!---' at this point (3 dashes)\n// https://www.w3.org/TR/html51/syntax.html#comment-start-dash-state\nfunction stateCommentStartDash(context, char) {\n  if (char === '-') {\n    // We've read '<!----' (4 dashes) at this point\n    context.state = 18 /* State.CommentEnd */;\n  } else if (char === '>') {\n    // At this point, we'll assume the comment wasn't a real comment\n    // so we'll just emit it as data. We basically read the sequence\n    // '<!--->'\n    resetToDataState(context);\n  } else {\n    // Anything else, take it as a valid comment\n    context.state = 16 /* State.Comment */;\n  }\n}\n// Currently reading the comment's text (data)\n// https://www.w3.org/TR/html51/syntax.html#comment-state\nfunction stateComment(context, char) {\n  if (char === '-') {\n    context.state = 17 /* State.CommentEndDash */;\n  } else {\n    // Any other character, stay in the Comment state\n  }\n}\n// When we we've read the first dash inside a comment, it may signal the\n// end of the comment if we read another dash\n// https://www.w3.org/TR/html51/syntax.html#comment-end-dash-state\nfunction stateCommentEndDash(context, char) {\n  if (char === '-') {\n    context.state = 18 /* State.CommentEnd */;\n  } else {\n    // Wasn't a dash, must still be part of the comment\n    context.state = 16 /* State.Comment */;\n  }\n}\n// After we've read two dashes inside a comment, it may signal the end of\n// the comment if we then read a '>' char\n// https://www.w3.org/TR/html51/syntax.html#comment-end-state\nfunction stateCommentEnd(context, char) {\n  if (char === '>') {\n    emitTagAndPreviousTextNode(context);\n  } else if (char === '!') {\n    context.state = 19 /* State.CommentEndBang */;\n  } else if (char === '-') {\n    // A 3rd '-' has been read: stay in the CommentEnd state\n  } else {\n    // Anything else, switch back to the comment state since we didn't\n    // read the full \"end comment\" sequence (i.e. '-->')\n    context.state = 16 /* State.Comment */;\n  }\n}\n// We've read the sequence '--!' inside of a comment\n// https://www.w3.org/TR/html51/syntax.html#comment-end-bang-state\nfunction stateCommentEndBang(context, char) {\n  if (char === '-') {\n    // We read the sequence '--!-' inside of a comment. The last dash\n    // could signify that the comment is going to close\n    context.state = 17 /* State.CommentEndDash */;\n  } else if (char === '>') {\n    // End of comment with the sequence '--!>'\n    emitTagAndPreviousTextNode(context);\n  } else {\n    // The '--!' was not followed by a '>', continue reading the\n    // comment's text\n    context.state = 16 /* State.Comment */;\n  }\n}\n/**\n * For DOCTYPES in particular, we don't care about the attributes. Just\n * advance to the '>' character and emit the tag, unless we find a '<'\n * character in which case we'll start a new tag.\n *\n * Example doctype tag:\n *    <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n *\n * Actual spec: https://www.w3.org/TR/html51/syntax.html#doctype-state\n */\nfunction stateDoctype(context, char) {\n  if (char === '>') {\n    emitTagAndPreviousTextNode(context);\n  } else if (char === '<') {\n    startNewTag(context);\n  } else {\n    // stay in the Doctype state\n  }\n}\n/**\n * Resets the state back to the Data state, and removes the current tag.\n *\n * We'll generally run this function whenever a \"parse error\" is\n * encountered, where the current tag that is being read no longer looks\n * like a real HTML tag.\n */\nfunction resetToDataState(context) {\n  context.state = 0 /* State.Data */;\n  context.currentTag = noCurrentTag;\n}\n/**\n * Starts a new HTML tag at the current index, ignoring any previous HTML\n * tag that was being read.\n *\n * We'll generally run this function whenever we read a new '<' character,\n * including when we read a '<' character inside of an HTML tag that we were\n * previously reading.\n */\nfunction startNewTag(context) {\n  context.state = 1 /* State.TagOpen */;\n  context.currentTag = new CurrentTag({\n    idx: context.charIdx\n  });\n}\n/**\n * Once we've decided to emit an open tag, that means we can also emit the\n * text node before it.\n */\nfunction emitTagAndPreviousTextNode(context) {\n  var textBeforeTag = context.html.slice(context.currentDataIdx, context.currentTag.idx);\n  if (textBeforeTag) {\n    // the html tag was the first element in the html string, or two\n    // tags next to each other, in which case we should not emit a text\n    // node\n    context.callbacks.onText(textBeforeTag, context.currentDataIdx);\n  }\n  var currentTag = context.currentTag;\n  if (currentTag.type === 'comment') {\n    context.callbacks.onComment(currentTag.idx);\n  } else if (currentTag.type === 'doctype') {\n    context.callbacks.onDoctype(currentTag.idx);\n  } else {\n    if (currentTag.isOpening) {\n      context.callbacks.onOpenTag(currentTag.name, currentTag.idx);\n    }\n    if (currentTag.isClosing) {\n      // note: self-closing tags will emit both opening and closing\n      context.callbacks.onCloseTag(currentTag.name, currentTag.idx);\n    }\n  }\n  // Since we just emitted a tag, reset to the data state for the next char\n  resetToDataState(context);\n  context.currentDataIdx = context.charIdx + 1;\n}\nfunction emitText(context) {\n  var text = context.html.slice(context.currentDataIdx, context.charIdx);\n  context.callbacks.onText(text, context.currentDataIdx);\n  context.currentDataIdx = context.charIdx + 1;\n}\n/**\n * Captures the tag name from the start of the tag to the current character\n * index, and converts it to lower case\n */\nfunction captureTagName(context) {\n  var startIdx = context.currentTag.idx + (context.currentTag.isClosing ? 2 : 1);\n  return context.html.slice(startIdx, context.charIdx).toLowerCase();\n}\n/**\n * Causes the main loop to re-consume the current character, such as after\n * encountering a \"parse error\" that changed state and needs to reconsume\n * the same character in that new state.\n */\nfunction reconsumeCurrentChar(context) {\n  context.charIdx--;\n}","map":{"version":3,"names":["isDigitChar","isAsciiLetterChar","isQuoteChar","isWhitespaceChar","isControlChar","assertNever","CurrentTag","cfg","idx","undefined","type","name","isOpening","isClosing","noCurrentTag","ParseHtmlContext","html","callbacks","charIdx","state","currentDataIdx","currentTag","parseHtml","context","len","length","char","charAt","charCode","charCodeAt","stateData","stateTagOpen","stateEndTagOpen","stateTagName","stateBeforeAttributeName","stateAttributeName","stateAfterAttributeName","stateBeforeAttributeValue","stateAttributeValueDoubleQuoted","stateAttributeValueSingleQuoted","stateAttributeValueUnquoted","stateAfterAttributeValueQuoted","stateSelfClosingStartTag","stateMarkupDeclarationOpen","stateCommentStart","stateCommentStartDash","stateComment","stateCommentEndDash","stateCommentEnd","stateCommentEndBang","stateDoctype","emitText","startNewTag","__assign","captureTagName","emitTagAndPreviousTextNode","resetToDataState","test","reconsumeCurrentChar","slice","toUpperCase","textBeforeTag","onText","onComment","onDoctype","onOpenTag","onCloseTag","text","startIdx","toLowerCase"],"sources":["../../../src/htmlParser/parse-html.ts"],"sourcesContent":["import {\n    isDigitChar,\n    isAsciiLetterChar,\n    isQuoteChar,\n    isWhitespaceChar,\n    isControlChar,\n} from '../char-utils';\nimport { assertNever } from '../utils';\n\n// For debugging: search for other \"For debugging\" lines\n// import CliTable from 'cli-table';\n\nclass CurrentTag {\n    readonly idx: number; // the index of the '<' in the html string\n    readonly type: 'tag' | 'comment' | 'doctype';\n    readonly name: string;\n    readonly isOpening: boolean; // true if it's an opening tag, OR a self-closing open tag\n    readonly isClosing: boolean; // true if it's a closing tag, OR a self-closing open tag\n\n    constructor(cfg: Partial<CurrentTag> = {}) {\n        this.idx = cfg.idx !== undefined ? cfg.idx : -1;\n        this.type = cfg.type || 'tag';\n        this.name = cfg.name || '';\n        this.isOpening = !!cfg.isOpening;\n        this.isClosing = !!cfg.isClosing;\n    }\n}\n\nconst noCurrentTag = new CurrentTag(); // shared reference for when there is no current tag currently being read\n\n/**\n * Context object containing all the state needed by the HTML parsing state\n * machine function.\n *\n * ## Historical note\n *\n * In v4.1.5, we used nested functions to handle the context via closures, but\n * this necessitated re-creating the functions for each call to `parseHtml()`,\n * which made them difficult for v8 to JIT optimize. In v4.1.6, we lifted all of\n * the functions to the top-level scope and passed the context object between\n * them, which allows the functions to be JIT compiled once and reused.\n */\nclass ParseHtmlContext {\n    public charIdx = 0; // Current character index being processed\n    public readonly html: string; // The input html being parsed\n    public readonly callbacks: ParseHtmlCallbacks;\n    public state: State = State.Data; // begin in the Data state\n    public currentDataIdx = 0; // where the current data start index is\n    public currentTag: CurrentTag = noCurrentTag; // describes the current tag that is being read\n\n    constructor(html: string, callbacks: ParseHtmlCallbacks) {\n        this.html = html;\n        this.callbacks = callbacks;\n    }\n}\n\n/**\n * The callback functions that can be provided to {@link #parseHtml}.\n */\nexport interface ParseHtmlCallbacks {\n    onOpenTag: (tagName: string, offset: number) => void;\n    onCloseTag: (tagName: string, offset: number) => void;\n    onText: (text: string, offset: number) => void;\n    onComment: (offset: number) => void;\n    onDoctype: (offset: number) => void;\n}\n\n/**\n * Parses an HTML string, calling the callbacks to notify of tags and text.\n *\n * ## History\n *\n * This file previously used a regular expression to find html tags in the input\n * text. Unfortunately, we ran into a bunch of catastrophic backtracking issues\n * with certain input text, causing Autolinker to either hang or just take a\n * really long time to parse the string.\n *\n * The current code is intended to be a O(n) algorithm that walks through\n * the string in one pass, and tries to be as cheap as possible. We don't need\n * to implement the full HTML spec, but rather simply determine where the string\n * looks like an HTML tag, and where it looks like text (so that we can autolink\n * that).\n *\n * This state machine parser is intended just to be a simple but performant\n * parser of HTML for the subset of requirements we have. We simply need to:\n *\n * 1. Determine where HTML tags are\n * 2. Determine the tag name (Autolinker specifically only cares about <a>,\n *    <script>, and <style> tags, so as not to link any text within them)\n *\n * We don't need to:\n *\n * 1. Create a parse tree\n * 2. Auto-close tags with invalid markup\n * 3. etc.\n *\n * The other intention behind this is that we didn't want to add external\n * dependencies on the Autolinker utility which would increase its size. For\n * instance, adding htmlparser2 adds 125kb to the minified output file,\n * increasing its final size from 47kb to 172kb (at the time of writing). It\n * also doesn't work exactly correctly, treating the string \"<3 blah blah blah\"\n * as an HTML tag.\n *\n * Reference for HTML spec:\n *\n *     https://www.w3.org/TR/html51/syntax.html#sec-tokenization\n *\n * @param {String} html The HTML to parse\n * @param {Object} callbacks\n * @param {Function} callbacks.onOpenTag Callback function to call when an open\n *   tag is parsed. Called with the tagName as its argument.\n * @param {Function} callbacks.onCloseTag Callback function to call when a close\n *   tag is parsed. Called with the tagName as its argument. If a self-closing\n *   tag is found, `onCloseTag` is called immediately after `onOpenTag`.\n * @param {Function} callbacks.onText Callback function to call when text (i.e\n *   not an HTML tag) is parsed. Called with the text (string) as its first\n *   argument, and offset (number) into the string as its second.\n */\nexport function parseHtml(html: string, callbacks: ParseHtmlCallbacks) {\n    const context = new ParseHtmlContext(html, callbacks);\n\n    // For debugging: search for other \"For debugging\" lines\n    // const table = new CliTable( {\n    // \thead: [ 'charIdx', 'char', 'state', 'currentDataIdx', 'currentOpenTagIdx', 'tag.type' ]\n    // } );\n\n    const len = html.length;\n    while (context.charIdx < len) {\n        const char = html.charAt(context.charIdx);\n        const charCode = html.charCodeAt(context.charIdx);\n\n        // For debugging: search for other \"For debugging\" lines\n        // ALSO: Temporarily remove the 'const' keyword on the State enum\n        // table.push([\n        //     String(charIdx),\n        //     char,\n        //     State[state],\n        //     String(currentDataIdx),\n        //     String(currentTag.idx),\n        //     currentTag.idx === -1 ? '' : currentTag.type\n        // ]);\n\n        switch (context.state) {\n            case State.Data:\n                stateData(context, char);\n                break;\n            case State.TagOpen:\n                stateTagOpen(context, char, charCode);\n                break;\n            case State.EndTagOpen:\n                stateEndTagOpen(context, char, charCode);\n                break;\n            case State.TagName:\n                stateTagName(context, char, charCode);\n                break;\n            case State.BeforeAttributeName:\n                stateBeforeAttributeName(context, char, charCode);\n                break;\n            case State.AttributeName:\n                stateAttributeName(context, char, charCode);\n                break;\n            case State.AfterAttributeName:\n                stateAfterAttributeName(context, char, charCode);\n                break;\n            case State.BeforeAttributeValue:\n                stateBeforeAttributeValue(context, char, charCode);\n                break;\n            case State.AttributeValueDoubleQuoted:\n                stateAttributeValueDoubleQuoted(context, char);\n                break;\n            case State.AttributeValueSingleQuoted:\n                stateAttributeValueSingleQuoted(context, char);\n                break;\n            case State.AttributeValueUnquoted:\n                stateAttributeValueUnquoted(context, char, charCode);\n                break;\n            case State.AfterAttributeValueQuoted:\n                stateAfterAttributeValueQuoted(context, char, charCode);\n                break;\n            case State.SelfClosingStartTag:\n                stateSelfClosingStartTag(context, char);\n                break;\n            case State.MarkupDeclarationOpenState:\n                stateMarkupDeclarationOpen(context);\n                break;\n            case State.CommentStart:\n                stateCommentStart(context, char);\n                break;\n            case State.CommentStartDash:\n                stateCommentStartDash(context, char);\n                break;\n            case State.Comment:\n                stateComment(context, char);\n                break;\n            case State.CommentEndDash:\n                stateCommentEndDash(context, char);\n                break;\n            case State.CommentEnd:\n                stateCommentEnd(context, char);\n                break;\n            case State.CommentEndBang:\n                stateCommentEndBang(context, char);\n                break;\n            case State.Doctype:\n                stateDoctype(context, char);\n                break;\n\n            /* istanbul ignore next */\n            default:\n                assertNever(context.state);\n        }\n\n        // For debugging: search for other \"For debugging\" lines\n        // ALSO: Temporarily remove the 'const' keyword on the State enum\n        // table.push([\n        //     String(context.charIdx),\n        //     char,\n        //     State[context.state],\n        //     String(context.currentDataIdx),\n        //     String(context.currentTag.idx),\n        //     context.currentTag.idx === -1 ? '' : context.currentTag.type\n        // ]);\n\n        context.charIdx++;\n    }\n\n    if (context.currentDataIdx < context.charIdx) {\n        emitText(context);\n    }\n\n    // For debugging: search for other \"For debugging\" lines\n    // console.log( '\\n' + table.toString() );\n}\n\n// Called when non-tags are being read (i.e. the text around HTML †ags)\n// https://www.w3.org/TR/html51/syntax.html#data-state\nfunction stateData(context: ParseHtmlContext, char: string) {\n    if (char === '<') {\n        startNewTag(context);\n    }\n}\n\n// Called after a '<' is read from the Data state\n// https://www.w3.org/TR/html51/syntax.html#tag-open-state\nfunction stateTagOpen(context: ParseHtmlContext, char: string, charCode: number) {\n    if (char === '!') {\n        context.state = State.MarkupDeclarationOpenState;\n    } else if (char === '/') {\n        context.state = State.EndTagOpen;\n        context.currentTag = new CurrentTag({ ...context.currentTag, isClosing: true });\n    } else if (char === '<') {\n        // start of another tag (ignore the previous, incomplete one)\n        startNewTag(context);\n    } else if (isAsciiLetterChar(charCode)) {\n        // tag name start (and no '/' read)\n        context.state = State.TagName;\n        context.currentTag = new CurrentTag({ ...context.currentTag, isOpening: true });\n    } else {\n        // Any other\n        context.state = State.Data;\n        context.currentTag = noCurrentTag;\n    }\n}\n\n// After a '<x', '</x' sequence is read (where 'x' is a letter character),\n// this is to continue reading the tag name\n// https://www.w3.org/TR/html51/syntax.html#tag-name-state\nfunction stateTagName(context: ParseHtmlContext, char: string, charCode: number) {\n    if (isWhitespaceChar(charCode)) {\n        context.currentTag = new CurrentTag({\n            ...context.currentTag,\n            name: captureTagName(context),\n        });\n        context.state = State.BeforeAttributeName;\n    } else if (char === '<') {\n        // start of another tag (ignore the previous, incomplete one)\n        startNewTag(context);\n    } else if (char === '/') {\n        context.currentTag = new CurrentTag({\n            ...context.currentTag,\n            name: captureTagName(context),\n        });\n        context.state = State.SelfClosingStartTag;\n    } else if (char === '>') {\n        context.currentTag = new CurrentTag({\n            ...context.currentTag,\n            name: captureTagName(context),\n        });\n        emitTagAndPreviousTextNode(context); // resets to Data state as well\n    } else if (!isAsciiLetterChar(charCode) && !isDigitChar(charCode) && char !== ':') {\n        // Anything else that does not form an html tag. Note: the colon\n        // character is accepted for XML namespaced tags\n        resetToDataState(context);\n    } else {\n        // continue reading tag name\n    }\n}\n\n// Called after the '/' is read from a '</' sequence\n// https://www.w3.org/TR/html51/syntax.html#end-tag-open-state\nfunction stateEndTagOpen(context: ParseHtmlContext, char: string, charCode: number) {\n    if (char === '>') {\n        // parse error. Encountered \"</>\". Skip it without treating as a tag\n        resetToDataState(context);\n    } else if (isAsciiLetterChar(charCode)) {\n        context.state = State.TagName;\n    } else {\n        // some other non-tag-like character, don't treat this as a tag\n        resetToDataState(context);\n    }\n}\n\n// https://www.w3.org/TR/html51/syntax.html#before-attribute-name-state\nfunction stateBeforeAttributeName(context: ParseHtmlContext, char: string, charCode: number) {\n    if (isWhitespaceChar(charCode)) {\n        // stay in BeforeAttributeName state - continue reading chars\n    } else if (char === '/') {\n        context.state = State.SelfClosingStartTag;\n    } else if (char === '>') {\n        emitTagAndPreviousTextNode(context); // resets to Data state as well\n    } else if (char === '<') {\n        // start of another tag (ignore the previous, incomplete one)\n        startNewTag(context);\n    } else if (char === `=` || isQuoteChar(charCode) || isControlChar(charCode)) {\n        // \"Parse error\" characters that, according to the spec, should be\n        // appended to the attribute name, but we'll treat these characters\n        // as not forming a real HTML tag\n        resetToDataState(context);\n    } else {\n        // Any other char, start of a new attribute name\n        context.state = State.AttributeName;\n    }\n}\n\n// https://www.w3.org/TR/html51/syntax.html#attribute-name-state\nfunction stateAttributeName(context: ParseHtmlContext, char: string, charCode: number) {\n    if (isWhitespaceChar(charCode)) {\n        context.state = State.AfterAttributeName;\n    } else if (char === '/') {\n        context.state = State.SelfClosingStartTag;\n    } else if (char === '=') {\n        context.state = State.BeforeAttributeValue;\n    } else if (char === '>') {\n        emitTagAndPreviousTextNode(context); // resets to Data state as well\n    } else if (char === '<') {\n        // start of another tag (ignore the previous, incomplete one)\n        startNewTag(context);\n    } else if (isQuoteChar(charCode)) {\n        // \"Parse error\" characters that, according to the spec, should be\n        // appended to the attribute name, but we'll treat these characters\n        // as not forming a real HTML tag\n        resetToDataState(context);\n    } else {\n        // anything else: continue reading attribute name\n    }\n}\n\n// https://www.w3.org/TR/html51/syntax.html#after-attribute-name-state\nfunction stateAfterAttributeName(context: ParseHtmlContext, char: string, charCode: number) {\n    if (isWhitespaceChar(charCode)) {\n        // ignore the character - continue reading\n    } else if (char === '/') {\n        context.state = State.SelfClosingStartTag;\n    } else if (char === '=') {\n        context.state = State.BeforeAttributeValue;\n    } else if (char === '>') {\n        emitTagAndPreviousTextNode(context);\n    } else if (char === '<') {\n        // start of another tag (ignore the previous, incomplete one)\n        startNewTag(context);\n    } else if (isQuoteChar(charCode)) {\n        // \"Parse error\" characters that, according to the spec, should be\n        // appended to the attribute name, but we'll treat these characters\n        // as not forming a real HTML tag\n        resetToDataState(context);\n    } else {\n        // Any other character, start a new attribute in the current tag\n        context.state = State.AttributeName;\n    }\n}\n\n// https://www.w3.org/TR/html51/syntax.html#before-attribute-value-state\nfunction stateBeforeAttributeValue(context: ParseHtmlContext, char: string, charCode: number) {\n    if (isWhitespaceChar(charCode)) {\n        // ignore the character - continue reading\n    } else if (char === `\"`) {\n        context.state = State.AttributeValueDoubleQuoted;\n    } else if (char === `'`) {\n        context.state = State.AttributeValueSingleQuoted;\n    } else if (/[>=`]/.test(char)) {\n        // Invalid chars after an '=' for an attribute value, don't count\n        // the current tag as an HTML tag\n        resetToDataState(context);\n    } else if (char === '<') {\n        // start of another tag (ignore the previous, incomplete one)\n        startNewTag(context);\n    } else {\n        // Any other character, consider it an unquoted attribute value\n        context.state = State.AttributeValueUnquoted;\n    }\n}\n\n// https://www.w3.org/TR/html51/syntax.html#attribute-value-double-quoted-state\nfunction stateAttributeValueDoubleQuoted(context: ParseHtmlContext, char: string) {\n    if (char === `\"`) {\n        // end the current double-quoted attribute\n        context.state = State.AfterAttributeValueQuoted;\n    } else {\n        // consume the character as part of the double-quoted attribute value\n    }\n}\n\n// https://www.w3.org/TR/html51/syntax.html#attribute-value-single-quoted-state\nfunction stateAttributeValueSingleQuoted(context: ParseHtmlContext, char: string) {\n    if (char === `'`) {\n        // end the current single-quoted attribute\n        context.state = State.AfterAttributeValueQuoted;\n    } else {\n        // consume the character as part of the double-quoted attribute value\n    }\n}\n\n// https://www.w3.org/TR/html51/syntax.html#attribute-value-unquoted-state\nfunction stateAttributeValueUnquoted(context: ParseHtmlContext, char: string, charCode: number) {\n    if (isWhitespaceChar(charCode)) {\n        context.state = State.BeforeAttributeName;\n    } else if (char === '>') {\n        emitTagAndPreviousTextNode(context);\n    } else if (char === '<') {\n        // start of another tag (ignore the previous, incomplete one)\n        startNewTag(context);\n    } else {\n        // Any other character, treat it as part of the attribute value\n    }\n}\n\n// Called after a double-quoted or single-quoted attribute value is read\n// (i.e. after the closing quote character)\n// https://www.w3.org/TR/html51/syntax.html#after-attribute-value-quoted-state\nfunction stateAfterAttributeValueQuoted(context: ParseHtmlContext, char: string, charCode: number) {\n    if (isWhitespaceChar(charCode)) {\n        context.state = State.BeforeAttributeName;\n    } else if (char === '/') {\n        context.state = State.SelfClosingStartTag;\n    } else if (char === '>') {\n        emitTagAndPreviousTextNode(context);\n    } else if (char === '<') {\n        // start of another tag (ignore the previous, incomplete one)\n        startNewTag(context);\n    } else {\n        // Any other character, \"parse error\". Spec says to switch to the\n        // BeforeAttributeState and re-consume the character, as it may be\n        // the start of a new attribute name\n        context.state = State.BeforeAttributeName;\n        reconsumeCurrentChar(context);\n    }\n}\n\n// A '/' has just been read in the current tag (presumably for '/>'), and\n// this handles the next character\n// https://www.w3.org/TR/html51/syntax.html#self-closing-start-tag-state\nfunction stateSelfClosingStartTag(context: ParseHtmlContext, char: string) {\n    if (char === '>') {\n        context.currentTag = new CurrentTag({ ...context.currentTag, isClosing: true });\n        emitTagAndPreviousTextNode(context); // resets to Data state as well\n    } else {\n        // Note: the spec calls for a character after a '/' within a start\n        // tag to go back into the BeforeAttributeName state (in order to\n        // read more attributes, but for the purposes of Autolinker, this is\n        // most likely not a valid HTML tag. For example: \"<something / other>\"\n        // state = State.BeforeAttributeName;\n\n        // Instead, just treat as regular text\n        resetToDataState(context);\n    }\n}\n\n// https://www.w3.org/TR/html51/syntax.html#markup-declaration-open-state\n// (HTML Comments or !DOCTYPE)\nfunction stateMarkupDeclarationOpen(context: ParseHtmlContext) {\n    const { html, charIdx } = context;\n\n    if (html.slice(charIdx, charIdx + 2) === '--') {\n        // html comment\n        context.charIdx++; // \"consume\" the second '-' character. Next loop iteration will consume the character after the '<!--' sequence\n        context.currentTag = new CurrentTag({ ...context.currentTag, type: 'comment' });\n        context.state = State.CommentStart;\n    } else if (html.slice(charIdx, charIdx + 7).toUpperCase() === 'DOCTYPE') {\n        context.charIdx += 6; // \"consume\" the characters \"OCTYPE\" (the current loop iteraction consumed the 'D'). Next loop iteration will consume the character after the '<!DOCTYPE' sequence\n        context.currentTag = new CurrentTag({ ...context.currentTag, type: 'doctype' });\n        context.state = State.Doctype;\n    } else {\n        // At this point, the spec specifies that the state machine should\n        // enter the \"bogus comment\" state, in which case any character(s)\n        // after the '<!' that were read should become an HTML comment up\n        // until the first '>' that is read (or EOF). Instead, we'll assume\n        // that a user just typed '<!' as part of some piece of non-html\n        // text\n        resetToDataState(context);\n    }\n}\n\n// Handles after the sequence '<!--' has been read\n// https://www.w3.org/TR/html51/syntax.html#comment-start-state\nfunction stateCommentStart(context: ParseHtmlContext, char: string) {\n    if (char === '-') {\n        // We've read the sequence '<!---' at this point (3 dashes)\n        context.state = State.CommentStartDash;\n    } else if (char === '>') {\n        // At this point, we'll assume the comment wasn't a real comment\n        // so we'll just emit it as data. We basically read the sequence\n        // '<!-->'\n        resetToDataState(context);\n    } else {\n        // Any other char, take it as part of the comment\n        context.state = State.Comment;\n    }\n}\n\n// We've read the sequence '<!---' at this point (3 dashes)\n// https://www.w3.org/TR/html51/syntax.html#comment-start-dash-state\nfunction stateCommentStartDash(context: ParseHtmlContext, char: string) {\n    if (char === '-') {\n        // We've read '<!----' (4 dashes) at this point\n        context.state = State.CommentEnd;\n    } else if (char === '>') {\n        // At this point, we'll assume the comment wasn't a real comment\n        // so we'll just emit it as data. We basically read the sequence\n        // '<!--->'\n        resetToDataState(context);\n    } else {\n        // Anything else, take it as a valid comment\n        context.state = State.Comment;\n    }\n}\n\n// Currently reading the comment's text (data)\n// https://www.w3.org/TR/html51/syntax.html#comment-state\nfunction stateComment(context: ParseHtmlContext, char: string) {\n    if (char === '-') {\n        context.state = State.CommentEndDash;\n    } else {\n        // Any other character, stay in the Comment state\n    }\n}\n\n// When we we've read the first dash inside a comment, it may signal the\n// end of the comment if we read another dash\n// https://www.w3.org/TR/html51/syntax.html#comment-end-dash-state\nfunction stateCommentEndDash(context: ParseHtmlContext, char: string) {\n    if (char === '-') {\n        context.state = State.CommentEnd;\n    } else {\n        // Wasn't a dash, must still be part of the comment\n        context.state = State.Comment;\n    }\n}\n\n// After we've read two dashes inside a comment, it may signal the end of\n// the comment if we then read a '>' char\n// https://www.w3.org/TR/html51/syntax.html#comment-end-state\nfunction stateCommentEnd(context: ParseHtmlContext, char: string) {\n    if (char === '>') {\n        emitTagAndPreviousTextNode(context);\n    } else if (char === '!') {\n        context.state = State.CommentEndBang;\n    } else if (char === '-') {\n        // A 3rd '-' has been read: stay in the CommentEnd state\n    } else {\n        // Anything else, switch back to the comment state since we didn't\n        // read the full \"end comment\" sequence (i.e. '-->')\n        context.state = State.Comment;\n    }\n}\n\n// We've read the sequence '--!' inside of a comment\n// https://www.w3.org/TR/html51/syntax.html#comment-end-bang-state\nfunction stateCommentEndBang(context: ParseHtmlContext, char: string) {\n    if (char === '-') {\n        // We read the sequence '--!-' inside of a comment. The last dash\n        // could signify that the comment is going to close\n        context.state = State.CommentEndDash;\n    } else if (char === '>') {\n        // End of comment with the sequence '--!>'\n        emitTagAndPreviousTextNode(context);\n    } else {\n        // The '--!' was not followed by a '>', continue reading the\n        // comment's text\n        context.state = State.Comment;\n    }\n}\n\n/**\n * For DOCTYPES in particular, we don't care about the attributes. Just\n * advance to the '>' character and emit the tag, unless we find a '<'\n * character in which case we'll start a new tag.\n *\n * Example doctype tag:\n *    <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n *\n * Actual spec: https://www.w3.org/TR/html51/syntax.html#doctype-state\n */\nfunction stateDoctype(context: ParseHtmlContext, char: string) {\n    if (char === '>') {\n        emitTagAndPreviousTextNode(context);\n    } else if (char === '<') {\n        startNewTag(context);\n    } else {\n        // stay in the Doctype state\n    }\n}\n\n/**\n * Resets the state back to the Data state, and removes the current tag.\n *\n * We'll generally run this function whenever a \"parse error\" is\n * encountered, where the current tag that is being read no longer looks\n * like a real HTML tag.\n */\nfunction resetToDataState(context: ParseHtmlContext) {\n    context.state = State.Data;\n    context.currentTag = noCurrentTag;\n}\n\n/**\n * Starts a new HTML tag at the current index, ignoring any previous HTML\n * tag that was being read.\n *\n * We'll generally run this function whenever we read a new '<' character,\n * including when we read a '<' character inside of an HTML tag that we were\n * previously reading.\n */\nfunction startNewTag(context: ParseHtmlContext) {\n    context.state = State.TagOpen;\n    context.currentTag = new CurrentTag({ idx: context.charIdx });\n}\n\n/**\n * Once we've decided to emit an open tag, that means we can also emit the\n * text node before it.\n */\nfunction emitTagAndPreviousTextNode(context: ParseHtmlContext) {\n    const textBeforeTag = context.html.slice(context.currentDataIdx, context.currentTag.idx);\n    if (textBeforeTag) {\n        // the html tag was the first element in the html string, or two\n        // tags next to each other, in which case we should not emit a text\n        // node\n        context.callbacks.onText(textBeforeTag, context.currentDataIdx);\n    }\n\n    const currentTag = context.currentTag;\n    if (currentTag.type === 'comment') {\n        context.callbacks.onComment(currentTag.idx);\n    } else if (currentTag.type === 'doctype') {\n        context.callbacks.onDoctype(currentTag.idx);\n    } else {\n        if (currentTag.isOpening) {\n            context.callbacks.onOpenTag(currentTag.name, currentTag.idx);\n        }\n        if (currentTag.isClosing) {\n            // note: self-closing tags will emit both opening and closing\n            context.callbacks.onCloseTag(currentTag.name, currentTag.idx);\n        }\n    }\n\n    // Since we just emitted a tag, reset to the data state for the next char\n    resetToDataState(context);\n    context.currentDataIdx = context.charIdx + 1;\n}\n\nfunction emitText(context: ParseHtmlContext) {\n    const text = context.html.slice(context.currentDataIdx, context.charIdx);\n    context.callbacks.onText(text, context.currentDataIdx);\n\n    context.currentDataIdx = context.charIdx + 1;\n}\n\n/**\n * Captures the tag name from the start of the tag to the current character\n * index, and converts it to lower case\n */\nfunction captureTagName(context: ParseHtmlContext) {\n    const startIdx = context.currentTag.idx + (context.currentTag.isClosing ? 2 : 1);\n    return context.html.slice(startIdx, context.charIdx).toLowerCase();\n}\n\n/**\n * Causes the main loop to re-consume the current character, such as after\n * encountering a \"parse error\" that changed state and needs to reconsume\n * the same character in that new state.\n */\nfunction reconsumeCurrentChar(context: ParseHtmlContext) {\n    context.charIdx--;\n}\n\n/**\n * The subset of the parser states defined in https://www.w3.org/TR/html51/syntax.html\n * which are useful for Autolinker.\n */\n// For debugging: temporarily remove 'const' keyword on the State enum\nexport const enum State {\n    Data = 0,\n    TagOpen,\n    EndTagOpen,\n    TagName,\n    BeforeAttributeName,\n    AttributeName,\n    AfterAttributeName,\n    BeforeAttributeValue,\n    AttributeValueDoubleQuoted,\n    AttributeValueSingleQuoted,\n    AttributeValueUnquoted,\n    AfterAttributeValueQuoted,\n    SelfClosingStartTag,\n    MarkupDeclarationOpenState, // When the sequence '<!' is read for an HTML comment or doctype\n    CommentStart,\n    CommentStartDash,\n    Comment,\n    CommentEndDash,\n    CommentEnd,\n    CommentEndBang,\n    Doctype,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}