{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport KeyboardEventModifier from \"../Core/KeyboardEventModifier.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport Plane from \"../Core/Plane.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Ray from \"../Core/Ray.js\";\nimport VerticalExaggeration from \"../Core/VerticalExaggeration.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport CameraEventAggregator from \"./CameraEventAggregator.js\";\nimport CameraEventType from \"./CameraEventType.js\";\nimport MapMode2D from \"./MapMode2D.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SceneTransforms from \"./SceneTransforms.js\";\nimport TweenCollection from \"./TweenCollection.js\";\n\n/**\n * Modifies the camera position and orientation based on mouse input to a canvas.\n * @alias ScreenSpaceCameraController\n * @constructor\n *\n * @param {Scene} scene The scene.\n */\nfunction ScreenSpaceCameraController(scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * If true, inputs are allowed conditionally with the flags enableTranslate, enableZoom,\n   * enableRotate, enableTilt, and enableLook.  If false, all inputs are disabled.\n   *\n   * NOTE: This setting is for temporary use cases, such as camera flights and\n   * drag-selection of regions (see Picking demo).  It is typically set to false at the\n   * start of such events, and set true on completion.  To keep inputs disabled\n   * past the end of camera flights, you must use the other booleans (enableTranslate,\n   * enableZoom, enableRotate, enableTilt, and enableLook).\n   * @type {boolean}\n   * @default true\n   */\n  this.enableInputs = true;\n  /**\n   * If true, allows the user to pan around the map.  If false, the camera stays locked at the current position.\n   * This flag only applies in 2D and Columbus view modes.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableTranslate = true;\n  /**\n   * If true, allows the user to zoom in and out.  If false, the camera is locked to the current distance from the ellipsoid.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableZoom = true;\n  /**\n   * If true, allows the user to rotate the world which translates the user's position.\n   * This flag only applies in 2D and 3D.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableRotate = true;\n  /**\n   * If true, allows the user to tilt the camera.  If false, the camera is locked to the current heading.\n   * This flag only applies in 3D and Columbus view.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableTilt = true;\n  /**\n   * If true, allows the user to use free-look. If false, the camera view direction can only be changed through translating\n   * or rotating. This flag only applies in 3D and Columbus view modes.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableLook = true;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to spin because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {number}\n   * @default 0.9\n   */\n  this.inertiaSpin = 0.9;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to translate because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {number}\n   * @default 0.9\n   */\n  this.inertiaTranslate = 0.9;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to zoom because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {number}\n   * @default 0.8\n   */\n  this.inertiaZoom = 0.8;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to limit the range\n   * of various user inputs to a percentage of the window width/height per animation frame.\n   * This helps keep the camera under control in low-frame-rate situations.\n   * @type {number}\n   * @default 0.1\n   */\n  this.maximumMovementRatio = 0.1;\n  /**\n   * Sets the duration, in seconds, of the bounce back animations in 2D and Columbus view.\n   * @type {number}\n   * @default 3.0\n   */\n  this.bounceAnimationTime = 3.0;\n  /**\n   * The minimum magnitude, in meters, of the camera position when zooming. Defaults to 1.0.\n   * @type {number}\n   * @default 1.0\n   */\n  this.minimumZoomDistance = 1.0;\n  /**\n   * The maximum magnitude, in meters, of the camera position when zooming. Defaults to positive infinity.\n   * @type {number}\n   * @default {@link Number.POSITIVE_INFINITY}\n   */\n  this.maximumZoomDistance = Number.POSITIVE_INFINITY;\n\n  /**\n   * A multiplier for the speed at which the camera will zoom.\n   * @type {Number}\n   * @default 5.0\n   */\n  this.zoomFactor = 5.0;\n\n  /**\n   * The input that allows the user to pan around the map. This only applies in 2D and Columbus view modes.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default {@link CameraEventType.LEFT_DRAG}\n   */\n  this.translateEventTypes = CameraEventType.LEFT_DRAG;\n  /**\n   * The input that allows the user to zoom in/out.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default [{@link CameraEventType.RIGHT_DRAG}, {@link CameraEventType.WHEEL}, {@link CameraEventType.PINCH}]\n   */\n  this.zoomEventTypes = [CameraEventType.RIGHT_DRAG, CameraEventType.WHEEL, CameraEventType.PINCH];\n  /**\n   * The input that allows the user to rotate around the globe or another object. This only applies in 3D and Columbus view modes.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default {@link CameraEventType.LEFT_DRAG}\n   */\n  this.rotateEventTypes = CameraEventType.LEFT_DRAG;\n  /**\n   * The input that allows the user to tilt in 3D and Columbus view or twist in 2D.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default [{@link CameraEventType.MIDDLE_DRAG}, {@link CameraEventType.PINCH}, {\n   *     eventType : {@link CameraEventType.LEFT_DRAG},\n   *     modifier : {@link KeyboardEventModifier.CTRL}\n   * }, {\n   *     eventType : {@link CameraEventType.RIGHT_DRAG},\n   *     modifier : {@link KeyboardEventModifier.CTRL}\n   * }]\n   */\n  this.tiltEventTypes = [CameraEventType.MIDDLE_DRAG, CameraEventType.PINCH, {\n    eventType: CameraEventType.LEFT_DRAG,\n    modifier: KeyboardEventModifier.CTRL\n  }, {\n    eventType: CameraEventType.RIGHT_DRAG,\n    modifier: KeyboardEventModifier.CTRL\n  }];\n  /**\n   * The input that allows the user to change the direction the camera is viewing. This only applies in 3D and Columbus view modes.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default { eventType : {@link CameraEventType.LEFT_DRAG}, modifier : {@link KeyboardEventModifier.SHIFT} }\n   */\n  this.lookEventTypes = {\n    eventType: CameraEventType.LEFT_DRAG,\n    modifier: KeyboardEventModifier.SHIFT\n  };\n  const ellipsoid = scene.ellipsoid ?? Ellipsoid.default;\n\n  /**\n   * The minimum height the camera must be before picking the terrain or scene content instead of the ellipsoid. Defaults to scene.ellipsoid.minimumRadius * 0.025 when another ellipsoid than WGS84 is used.\n   * @type {number}\n   * @default 150000.0 or scene.ellipsoid.minimumRadius * 0.025\n   */\n  this.minimumPickingTerrainHeight = Ellipsoid.WGS84.equals(ellipsoid) ? 150000.0 : ellipsoid.minimumRadius * 0.025;\n  this._minimumPickingTerrainHeight = this.minimumPickingTerrainHeight;\n  /**\n   * The minimum distance the camera must be before testing for collision with terrain when zoom with inertia. Default to scene.ellipsoid.minimumRadius * 0.00063 when another ellipsoid than WGS84 is used.\n   * @type {number}\n   * @default 4000.0 or scene.ellipsoid.minimumRadius * 0.00063\n   */\n  this.minimumPickingTerrainDistanceWithInertia = Ellipsoid.WGS84.equals(ellipsoid) ? 4000.0 : ellipsoid.minimumRadius * 0.00063;\n  /**\n   * The minimum height the camera must be before testing for collision with terrain. Default to scene.ellipsoid.minimumRadius * 0.0025 when another ellipsoid than WGS84 is used.\n   * @type {number}\n   * @default 15000.0 or scene.ellipsoid.minimumRadius * 0.0025.\n   */\n  this.minimumCollisionTerrainHeight = Ellipsoid.WGS84.equals(ellipsoid) ? 15000.0 : ellipsoid.minimumRadius * 0.0025;\n  this._minimumCollisionTerrainHeight = this.minimumCollisionTerrainHeight;\n  /**\n   * The minimum height the camera must be before switching from rotating a track ball to\n   * free look when clicks originate on the sky or in space. Defaults to ellipsoid.minimumRadius * 1.175 when another ellipsoid than WGS84 is used.\n   * @type {number}\n   * @default 7500000.0 or scene.ellipsoid.minimumRadius * 1.175\n   */\n  this.minimumTrackBallHeight = Ellipsoid.WGS84.equals(ellipsoid) ? 7500000.0 : ellipsoid.minimumRadius * 1.175;\n  this._minimumTrackBallHeight = this.minimumTrackBallHeight;\n  /**\n   * When disabled, the values of <code>maximumZoomDistance</code> and <code>minimumZoomDistance</code> are ignored.\n   * Also used in conjunction with {@link Cesium3DTileset#enableCollision} to prevent the camera from moving through or below a 3D Tileset surface.\n   * This may also affect clamping behavior when using {@link HeightReference.CLAMP_TO_GROUND} on 3D Tiles.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableCollisionDetection = true;\n  /**\n   * The angle, relative to the ellipsoid normal, restricting the maximum amount that the user can tilt the camera. If <code>undefined</code>, the angle of the camera tilt is unrestricted.\n   * @type {number|undefined}\n   * @default undefined\n   *\n   * @example\n   * // Prevent the camera from tilting below the ellipsoid surface\n   * viewer.scene.screenSpaceCameraController.maximumTiltAngle = Math.PI / 2.0;\n   */\n  this.maximumTiltAngle = undefined;\n  this._scene = scene;\n  this._globe = undefined;\n  this._ellipsoid = ellipsoid;\n  this._lastGlobeHeight = 0.0;\n  this._aggregator = new CameraEventAggregator(scene.canvas);\n  this._lastInertiaSpinMovement = undefined;\n  this._lastInertiaZoomMovement = undefined;\n  this._lastInertiaTranslateMovement = undefined;\n  this._lastInertiaTiltMovement = undefined;\n\n  // Zoom disables tilt, spin, and translate inertia\n  // Tilt disables spin and translate inertia\n  this._inertiaDisablers = {\n    _lastInertiaZoomMovement: [\"_lastInertiaSpinMovement\", \"_lastInertiaTranslateMovement\", \"_lastInertiaTiltMovement\"],\n    _lastInertiaTiltMovement: [\"_lastInertiaSpinMovement\", \"_lastInertiaTranslateMovement\"]\n  };\n  this._tweens = new TweenCollection();\n  this._tween = undefined;\n  this._horizontalRotationAxis = undefined;\n  this._tiltCenterMousePosition = new Cartesian2(-1.0, -1.0);\n  this._tiltCenter = new Cartesian3();\n  this._rotateMousePosition = new Cartesian2(-1.0, -1.0);\n  this._rotateStartPosition = new Cartesian3();\n  this._strafeStartPosition = new Cartesian3();\n  this._strafeMousePosition = new Cartesian2();\n  this._strafeEndMousePosition = new Cartesian2();\n  this._zoomMouseStart = new Cartesian2(-1.0, -1.0);\n  this._zoomWorldPosition = new Cartesian3();\n  this._useZoomWorldPosition = false;\n  this._panLastMousePosition = new Cartesian2();\n  this._panLastWorldPosition = new Cartesian3();\n  this._tiltCVOffMap = false;\n  this._looking = false;\n  this._rotating = false;\n  this._strafing = false;\n  this._zoomingOnVector = false;\n  this._zoomingUnderground = false;\n  this._rotatingZoom = false;\n  this._adjustedHeightForTerrain = false;\n  this._cameraUnderground = false;\n  const projection = scene.mapProjection;\n  this._maxCoord = projection.project(new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO));\n\n  // Constants, Make any of these public?\n  this._rotateFactor = undefined;\n  this._rotateRateRangeAdjustment = undefined;\n  this._maximumRotateRate = 1.77;\n  this._minimumRotateRate = 1.0 / 5000.0;\n  this._minimumZoomRate = 20.0;\n  this._maximumZoomRate = 5906376272000.0; // distance from the Sun to Pluto in meters.\n  this._minimumUndergroundPickDistance = 2000.0;\n  this._maximumUndergroundPickDistance = 10000.0;\n}\nfunction decay(time, coefficient) {\n  if (time < 0) {\n    return 0.0;\n  }\n  const tau = (1.0 - coefficient) * 25.0;\n  return Math.exp(-tau * time);\n}\nfunction sameMousePosition(movement) {\n  return Cartesian2.equalsEpsilon(movement.startPosition, movement.endPosition, CesiumMath.EPSILON14);\n}\n\n// If the time between mouse down and mouse up is not between\n// these thresholds, the camera will not move with inertia.\n// This value is probably dependent on the browser and/or the\n// hardware. Should be investigated further.\nconst inertiaMaxClickTimeThreshold = 0.4;\nfunction maintainInertia(aggregator, type, modifier, decayCoef, action, object, lastMovementName) {\n  let movementState = object[lastMovementName];\n  if (!defined(movementState)) {\n    movementState = object[lastMovementName] = {\n      startPosition: new Cartesian2(),\n      endPosition: new Cartesian2(),\n      motion: new Cartesian2(),\n      inertiaEnabled: true\n    };\n  }\n  const ts = aggregator.getButtonPressTime(type, modifier);\n  const tr = aggregator.getButtonReleaseTime(type, modifier);\n  const threshold = ts && tr && (tr.getTime() - ts.getTime()) / 1000.0;\n  const now = new Date();\n  const fromNow = tr && (now.getTime() - tr.getTime()) / 1000.0;\n  if (ts && tr && threshold < inertiaMaxClickTimeThreshold) {\n    const d = decay(fromNow, decayCoef);\n    const lastMovement = aggregator.getLastMovement(type, modifier);\n    if (!defined(lastMovement) || sameMousePosition(lastMovement) || !movementState.inertiaEnabled) {\n      return;\n    }\n    movementState.motion.x = (lastMovement.endPosition.x - lastMovement.startPosition.x) * 0.5;\n    movementState.motion.y = (lastMovement.endPosition.y - lastMovement.startPosition.y) * 0.5;\n    movementState.startPosition = Cartesian2.clone(lastMovement.startPosition, movementState.startPosition);\n    movementState.endPosition = Cartesian2.multiplyByScalar(movementState.motion, d, movementState.endPosition);\n    movementState.endPosition = Cartesian2.add(movementState.startPosition, movementState.endPosition, movementState.endPosition);\n\n    // If value from the decreasing exponential function is close to zero,\n    // the end coordinates may be NaN.\n    if (isNaN(movementState.endPosition.x) || isNaN(movementState.endPosition.y) || Cartesian2.distance(movementState.startPosition, movementState.endPosition) < 0.5) {\n      return;\n    }\n    if (!aggregator.isButtonDown(type, modifier)) {\n      const startPosition = aggregator.getStartMousePosition(type, modifier);\n      action(object, startPosition, movementState);\n    }\n  }\n}\nfunction activateInertia(controller, inertiaStateName) {\n  if (defined(inertiaStateName)) {\n    // Re-enable inertia if it was disabled\n    let movementState = controller[inertiaStateName];\n    if (defined(movementState)) {\n      movementState.inertiaEnabled = true;\n    }\n    // Disable inertia on other movements\n    const inertiasToDisable = controller._inertiaDisablers[inertiaStateName];\n    if (defined(inertiasToDisable)) {\n      const length = inertiasToDisable.length;\n      for (let i = 0; i < length; ++i) {\n        movementState = controller[inertiasToDisable[i]];\n        if (defined(movementState)) {\n          movementState.inertiaEnabled = false;\n        }\n      }\n    }\n  }\n}\nconst scratchEventTypeArray = [];\nfunction reactToInput(controller, enabled, eventTypes, action, inertiaConstant, inertiaStateName) {\n  if (!defined(eventTypes)) {\n    return;\n  }\n  const aggregator = controller._aggregator;\n  if (!Array.isArray(eventTypes)) {\n    scratchEventTypeArray[0] = eventTypes;\n    eventTypes = scratchEventTypeArray;\n  }\n  const length = eventTypes.length;\n  for (let i = 0; i < length; ++i) {\n    const eventType = eventTypes[i];\n    const type = defined(eventType.eventType) ? eventType.eventType : eventType;\n    const modifier = eventType.modifier;\n    const movement = aggregator.isMoving(type, modifier) && aggregator.getMovement(type, modifier);\n    const startPosition = aggregator.getStartMousePosition(type, modifier);\n    if (controller.enableInputs && enabled) {\n      if (movement) {\n        action(controller, startPosition, movement);\n        activateInertia(controller, inertiaStateName);\n      } else if (inertiaConstant < 1.0) {\n        maintainInertia(aggregator, type, modifier, inertiaConstant, action, controller, inertiaStateName);\n      }\n    }\n  }\n}\nconst scratchZoomPickRay = new Ray();\nconst scratchPickCartesian = new Cartesian3();\nconst scratchZoomOffset = new Cartesian2();\nconst scratchZoomDirection = new Cartesian3();\nconst scratchCenterPixel = new Cartesian2();\nconst scratchCenterPosition = new Cartesian3();\nconst scratchPositionNormal = new Cartesian3();\nconst scratchPickNormal = new Cartesian3();\nconst scratchZoomAxis = new Cartesian3();\nconst scratchCameraPositionNormal = new Cartesian3();\n\n// Scratch variables used in zooming algorithm\nconst scratchTargetNormal = new Cartesian3();\nconst scratchCameraPosition = new Cartesian3();\nconst scratchCameraUpNormal = new Cartesian3();\nconst scratchCameraRightNormal = new Cartesian3();\nconst scratchForwardNormal = new Cartesian3();\nconst scratchPositionToTarget = new Cartesian3();\nconst scratchPositionToTargetNormal = new Cartesian3();\nconst scratchPan = new Cartesian3();\nconst scratchCenterMovement = new Cartesian3();\nconst scratchCenter = new Cartesian3();\nconst scratchCartesian = new Cartesian3();\nconst scratchCartesianTwo = new Cartesian3();\nconst scratchCartesianThree = new Cartesian3();\nconst scratchZoomViewOptions = {\n  orientation: new HeadingPitchRoll()\n};\nfunction handleZoom(object, startPosition, movement, zoomFactor, distanceMeasure, unitPositionDotDirection) {\n  let percentage = 1.0;\n  if (defined(unitPositionDotDirection)) {\n    percentage = CesiumMath.clamp(Math.abs(unitPositionDotDirection), 0.25, 1.0);\n  }\n  const diff = movement.endPosition.y - movement.startPosition.y;\n\n  // distanceMeasure should be the height above the ellipsoid.\n  // When approaching the surface, the zoomRate slows and stops minimumZoomDistance above it.\n  const approachingSurface = diff > 0;\n  const minHeight = approachingSurface ? object.minimumZoomDistance * percentage : 0;\n  const maxHeight = object.maximumZoomDistance;\n  const minDistance = distanceMeasure - minHeight;\n  let zoomRate = zoomFactor * minDistance;\n  zoomRate = CesiumMath.clamp(zoomRate, object._minimumZoomRate, object._maximumZoomRate);\n  let rangeWindowRatio = diff / object._scene.canvas.clientHeight;\n  rangeWindowRatio = Math.min(rangeWindowRatio, object.maximumMovementRatio);\n  let distance = zoomRate * rangeWindowRatio;\n  if (object.enableCollisionDetection || object.minimumZoomDistance === 0.0 || !defined(object._globe) // look-at mode\n  ) {\n    if (distance > 0.0 && Math.abs(distanceMeasure - minHeight) < 1.0) {\n      return;\n    }\n    if (distance < 0.0 && Math.abs(distanceMeasure - maxHeight) < 1.0) {\n      return;\n    }\n    if (distanceMeasure - distance < minHeight) {\n      distance = distanceMeasure - minHeight - 1.0;\n    } else if (distanceMeasure - distance > maxHeight) {\n      distance = distanceMeasure - maxHeight;\n    }\n  }\n  const scene = object._scene;\n  const camera = scene.camera;\n  const mode = scene.mode;\n  const orientation = scratchZoomViewOptions.orientation;\n  orientation.heading = camera.heading;\n  orientation.pitch = camera.pitch;\n  orientation.roll = camera.roll;\n  const sameStartPosition = movement.inertiaEnabled ?? Cartesian2.equals(startPosition, object._zoomMouseStart);\n  let zoomingOnVector = object._zoomingOnVector;\n  let rotatingZoom = object._rotatingZoom;\n  let pickedPosition;\n  if (!sameStartPosition) {\n    object._zoomMouseStart = Cartesian2.clone(startPosition, object._zoomMouseStart);\n\n    // When camera transform is set, such as tracking an entity, object._globe will be undefined, and no position should be picked\n    if (defined(object._globe) && mode === SceneMode.SCENE2D) {\n      pickedPosition = camera.getPickRay(startPosition, scratchZoomPickRay).origin;\n      pickedPosition = Cartesian3.fromElements(pickedPosition.y, pickedPosition.z, pickedPosition.x);\n    } else if (defined(object._globe)) {\n      pickedPosition = pickPosition(object, startPosition, scratchPickCartesian);\n    }\n    if (defined(pickedPosition)) {\n      object._useZoomWorldPosition = true;\n      object._zoomWorldPosition = Cartesian3.clone(pickedPosition, object._zoomWorldPosition);\n    } else {\n      object._useZoomWorldPosition = false;\n    }\n    zoomingOnVector = object._zoomingOnVector = false;\n    rotatingZoom = object._rotatingZoom = false;\n    object._zoomingUnderground = object._cameraUnderground;\n  }\n  if (!object._useZoomWorldPosition) {\n    camera.zoomIn(distance);\n    return;\n  }\n  let zoomOnVector = mode === SceneMode.COLUMBUS_VIEW;\n  if (camera.positionCartographic.height < 2000000) {\n    rotatingZoom = true;\n  }\n  if (!sameStartPosition || rotatingZoom) {\n    if (mode === SceneMode.SCENE2D) {\n      const worldPosition = object._zoomWorldPosition;\n      const endPosition = camera.position;\n      if (!Cartesian3.equals(worldPosition, endPosition) && camera.positionCartographic.height < object._maxCoord.x * 2.0) {\n        const savedX = camera.position.x;\n        const direction = Cartesian3.subtract(worldPosition, endPosition, scratchZoomDirection);\n        Cartesian3.normalize(direction, direction);\n        const d = Cartesian3.distance(worldPosition, endPosition) * distance / (camera.getMagnitude() * 0.5);\n        camera.move(direction, d * 0.5);\n        if (camera.position.x < 0.0 && savedX > 0.0 || camera.position.x > 0.0 && savedX < 0.0) {\n          pickedPosition = camera.getPickRay(startPosition, scratchZoomPickRay).origin;\n          pickedPosition = Cartesian3.fromElements(pickedPosition.y, pickedPosition.z, pickedPosition.x);\n          object._zoomWorldPosition = Cartesian3.clone(pickedPosition, object._zoomWorldPosition);\n        }\n      }\n    } else if (mode === SceneMode.SCENE3D) {\n      const cameraPositionNormal = Cartesian3.normalize(camera.position, scratchCameraPositionNormal);\n      if (object._cameraUnderground || object._zoomingUnderground || camera.positionCartographic.height < 3000.0 && Math.abs(Cartesian3.dot(camera.direction, cameraPositionNormal)) < 0.6) {\n        zoomOnVector = true;\n      } else {\n        const canvas = scene.canvas;\n        const centerPixel = scratchCenterPixel;\n        centerPixel.x = canvas.clientWidth / 2;\n        centerPixel.y = canvas.clientHeight / 2;\n        const centerPosition = pickPosition(object, centerPixel, scratchCenterPosition);\n        // If centerPosition is not defined, it means the globe does not cover the center position of screen\n\n        if (!defined(centerPosition)) {\n          zoomOnVector = true;\n        } else if (camera.positionCartographic.height < 1000000) {\n          // The math in the else block assumes the camera\n          // points toward the earth surface, so we check it here.\n          // Theoretically, we should check for 90 degree, but it doesn't behave well when parallel\n          // to the earth surface\n          if (Cartesian3.dot(camera.direction, cameraPositionNormal) >= -0.5) {\n            zoomOnVector = true;\n          } else {\n            const cameraPosition = scratchCameraPosition;\n            Cartesian3.clone(camera.position, cameraPosition);\n            const target = object._zoomWorldPosition;\n            let targetNormal = scratchTargetNormal;\n            targetNormal = Cartesian3.normalize(target, targetNormal);\n            if (Cartesian3.dot(targetNormal, cameraPositionNormal) < 0.0) {\n              return;\n            }\n            const center = scratchCenter;\n            const forward = scratchForwardNormal;\n            Cartesian3.clone(camera.direction, forward);\n            Cartesian3.add(cameraPosition, Cartesian3.multiplyByScalar(forward, 1000, scratchCartesian), center);\n            const positionToTarget = scratchPositionToTarget;\n            const positionToTargetNormal = scratchPositionToTargetNormal;\n            Cartesian3.subtract(target, cameraPosition, positionToTarget);\n            Cartesian3.normalize(positionToTarget, positionToTargetNormal);\n            const alphaDot = Cartesian3.dot(cameraPositionNormal, positionToTargetNormal);\n            if (alphaDot >= 0.0) {\n              // We zoomed past the target, and this zoom is not valid anymore.\n              // This line causes the next zoom movement to pick a new starting point.\n              object._zoomMouseStart.x = -1;\n              return;\n            }\n            const alpha = Math.acos(-alphaDot);\n            const cameraDistance = Cartesian3.magnitude(cameraPosition);\n            const targetDistance = Cartesian3.magnitude(target);\n            const remainingDistance = cameraDistance - distance;\n            const positionToTargetDistance = Cartesian3.magnitude(positionToTarget);\n            const gamma = Math.asin(CesiumMath.clamp(positionToTargetDistance / targetDistance * Math.sin(alpha), -1.0, 1.0));\n            const delta = Math.asin(CesiumMath.clamp(remainingDistance / targetDistance * Math.sin(alpha), -1.0, 1.0));\n            const beta = gamma - delta + alpha;\n            const up = scratchCameraUpNormal;\n            Cartesian3.normalize(cameraPosition, up);\n            let right = scratchCameraRightNormal;\n            right = Cartesian3.cross(positionToTargetNormal, up, right);\n            right = Cartesian3.normalize(right, right);\n            Cartesian3.normalize(Cartesian3.cross(up, right, scratchCartesian), forward);\n\n            // Calculate new position to move to\n            Cartesian3.multiplyByScalar(Cartesian3.normalize(center, scratchCartesian), Cartesian3.magnitude(center) - distance, center);\n            Cartesian3.normalize(cameraPosition, cameraPosition);\n            Cartesian3.multiplyByScalar(cameraPosition, remainingDistance, cameraPosition);\n\n            // Pan\n            const pMid = scratchPan;\n            Cartesian3.multiplyByScalar(Cartesian3.add(Cartesian3.multiplyByScalar(up, Math.cos(beta) - 1, scratchCartesianTwo), Cartesian3.multiplyByScalar(forward, Math.sin(beta), scratchCartesianThree), scratchCartesian), remainingDistance, pMid);\n            Cartesian3.add(cameraPosition, pMid, cameraPosition);\n            Cartesian3.normalize(center, up);\n            Cartesian3.normalize(Cartesian3.cross(up, right, scratchCartesian), forward);\n            const cMid = scratchCenterMovement;\n            Cartesian3.multiplyByScalar(Cartesian3.add(Cartesian3.multiplyByScalar(up, Math.cos(beta) - 1, scratchCartesianTwo), Cartesian3.multiplyByScalar(forward, Math.sin(beta), scratchCartesianThree), scratchCartesian), Cartesian3.magnitude(center), cMid);\n            Cartesian3.add(center, cMid, center);\n\n            // Update camera\n\n            // Set new position\n            Cartesian3.clone(cameraPosition, camera.position);\n\n            // Set new direction\n            Cartesian3.normalize(Cartesian3.subtract(center, cameraPosition, scratchCartesian), camera.direction);\n            Cartesian3.clone(camera.direction, camera.direction);\n\n            // Set new right & up vectors\n            Cartesian3.cross(camera.direction, camera.up, camera.right);\n            Cartesian3.cross(camera.right, camera.direction, camera.up);\n            camera.setView(scratchZoomViewOptions);\n            return;\n          }\n        } else {\n          const positionNormal = Cartesian3.normalize(centerPosition, scratchPositionNormal);\n          const pickedNormal = Cartesian3.normalize(object._zoomWorldPosition, scratchPickNormal);\n          const dotProduct = Cartesian3.dot(pickedNormal, positionNormal);\n          if (dotProduct > 0.0 && dotProduct < 1.0) {\n            const angle = CesiumMath.acosClamped(dotProduct);\n            const axis = Cartesian3.cross(pickedNormal, positionNormal, scratchZoomAxis);\n            const denom = Math.abs(angle) > CesiumMath.toRadians(20.0) ? camera.positionCartographic.height * 0.75 : camera.positionCartographic.height - distance;\n            const scalar = distance / denom;\n            camera.rotate(axis, angle * scalar);\n          }\n        }\n      }\n    }\n    object._rotatingZoom = !zoomOnVector;\n  }\n  if (!sameStartPosition && zoomOnVector || zoomingOnVector) {\n    let ray;\n    const zoomMouseStart = SceneTransforms.worldToWindowCoordinates(scene, object._zoomWorldPosition, scratchZoomOffset);\n    if (mode !== SceneMode.COLUMBUS_VIEW && Cartesian2.equals(startPosition, object._zoomMouseStart) && defined(zoomMouseStart)) {\n      ray = camera.getPickRay(zoomMouseStart, scratchZoomPickRay);\n    } else {\n      ray = camera.getPickRay(startPosition, scratchZoomPickRay);\n    }\n    const rayDirection = ray.direction;\n    if (mode === SceneMode.COLUMBUS_VIEW || mode === SceneMode.SCENE2D) {\n      Cartesian3.fromElements(rayDirection.y, rayDirection.z, rayDirection.x, rayDirection);\n    }\n    camera.move(rayDirection, distance);\n    object._zoomingOnVector = true;\n  } else {\n    camera.zoomIn(distance);\n  }\n  if (!object._cameraUnderground) {\n    camera.setView(scratchZoomViewOptions);\n  }\n}\nconst translate2DStart = new Ray();\nconst translate2DEnd = new Ray();\nconst scratchTranslateP0 = new Cartesian3();\nfunction translate2D(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  let start = camera.getPickRay(movement.startPosition, translate2DStart).origin;\n  let end = camera.getPickRay(movement.endPosition, translate2DEnd).origin;\n  start = Cartesian3.fromElements(start.y, start.z, start.x, start);\n  end = Cartesian3.fromElements(end.y, end.z, end.x, end);\n  const direction = Cartesian3.subtract(start, end, scratchTranslateP0);\n  const distance = Cartesian3.magnitude(direction);\n  if (distance > 0.0) {\n    Cartesian3.normalize(direction, direction);\n    camera.move(direction, distance);\n  }\n}\nfunction zoom2D(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n  const scene = controller._scene;\n  const camera = scene.camera;\n  handleZoom(controller, startPosition, movement, controller.zoomFactor, camera.getMagnitude());\n}\nconst twist2DStart = new Cartesian2();\nconst twist2DEnd = new Cartesian2();\nfunction twist2D(controller, startPosition, movement) {\n  if (defined(movement.angleAndHeight)) {\n    singleAxisTwist2D(controller, startPosition, movement.angleAndHeight);\n    return;\n  }\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n  const width = canvas.clientWidth;\n  const height = canvas.clientHeight;\n  let start = twist2DStart;\n  start.x = 2.0 / width * movement.startPosition.x - 1.0;\n  start.y = 2.0 / height * (height - movement.startPosition.y) - 1.0;\n  start = Cartesian2.normalize(start, start);\n  let end = twist2DEnd;\n  end.x = 2.0 / width * movement.endPosition.x - 1.0;\n  end.y = 2.0 / height * (height - movement.endPosition.y) - 1.0;\n  end = Cartesian2.normalize(end, end);\n  let startTheta = CesiumMath.acosClamped(start.x);\n  if (start.y < 0) {\n    startTheta = CesiumMath.TWO_PI - startTheta;\n  }\n  let endTheta = CesiumMath.acosClamped(end.x);\n  if (end.y < 0) {\n    endTheta = CesiumMath.TWO_PI - endTheta;\n  }\n  const theta = endTheta - startTheta;\n  camera.twistRight(theta);\n}\nfunction singleAxisTwist2D(controller, startPosition, movement) {\n  let rotateRate = controller._rotateFactor * controller._rotateRateRangeAdjustment;\n  if (rotateRate > controller._maximumRotateRate) {\n    rotateRate = controller._maximumRotateRate;\n  }\n  if (rotateRate < controller._minimumRotateRate) {\n    rotateRate = controller._minimumRotateRate;\n  }\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n  let phiWindowRatio = (movement.endPosition.x - movement.startPosition.x) / canvas.clientWidth;\n  phiWindowRatio = Math.min(phiWindowRatio, controller.maximumMovementRatio);\n  const deltaPhi = rotateRate * phiWindowRatio * Math.PI * 4.0;\n  camera.twistRight(deltaPhi);\n}\nfunction update2D(controller) {\n  const rotatable2D = controller._scene.mapMode2D === MapMode2D.ROTATE;\n  if (!Matrix4.equals(Matrix4.IDENTITY, controller._scene.camera.transform)) {\n    reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoom2D, controller.inertiaZoom, \"_lastInertiaZoomMovement\");\n    if (rotatable2D) {\n      reactToInput(controller, controller.enableRotate, controller.translateEventTypes, twist2D, controller.inertiaSpin, \"_lastInertiaSpinMovement\");\n    }\n  } else {\n    reactToInput(controller, controller.enableTranslate, controller.translateEventTypes, translate2D, controller.inertiaTranslate, \"_lastInertiaTranslateMovement\");\n    reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoom2D, controller.inertiaZoom, \"_lastInertiaZoomMovement\");\n    if (rotatable2D) {\n      reactToInput(controller, controller.enableRotate, controller.tiltEventTypes, twist2D, controller.inertiaSpin, \"_lastInertiaTiltMovement\");\n    }\n  }\n}\nconst pickGlobeScratchRay = new Ray();\nconst scratchDepthIntersection = new Cartesian3();\nconst scratchRayIntersection = new Cartesian3();\nfunction pickPosition(controller, mousePosition, result) {\n  const scene = controller._scene;\n  const globe = controller._globe;\n  const camera = scene.camera;\n  let depthIntersection;\n  if (scene.pickPositionSupported) {\n    depthIntersection = scene.pickPositionWorldCoordinates(mousePosition, scratchDepthIntersection);\n  }\n  if (!defined(globe)) {\n    return Cartesian3.clone(depthIntersection, result);\n  }\n  const cullBackFaces = !controller._cameraUnderground;\n  const ray = camera.getPickRay(mousePosition, pickGlobeScratchRay);\n  const rayIntersection = globe.pickWorldCoordinates(ray, scene, cullBackFaces, scratchRayIntersection);\n  const pickDistance = defined(depthIntersection) ? Cartesian3.distance(depthIntersection, camera.positionWC) : Number.POSITIVE_INFINITY;\n  const rayDistance = defined(rayIntersection) ? Cartesian3.distance(rayIntersection, camera.positionWC) : Number.POSITIVE_INFINITY;\n  if (pickDistance < rayDistance) {\n    return Cartesian3.clone(depthIntersection, result);\n  }\n  return Cartesian3.clone(rayIntersection, result);\n}\nconst scratchDistanceCartographic = new Cartographic();\nfunction getDistanceFromSurface(controller) {\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const mode = scene.mode;\n  let height = 0.0;\n  if (mode === SceneMode.SCENE3D) {\n    const cartographic = ellipsoid.cartesianToCartographic(camera.position, scratchDistanceCartographic);\n    if (defined(cartographic)) {\n      height = cartographic.height;\n    }\n  } else {\n    height = camera.position.z;\n  }\n  const globeHeight = controller._scene.globeHeight ?? 0.0;\n  const distanceFromSurface = Math.abs(globeHeight - height);\n  return distanceFromSurface;\n}\nconst scratchSurfaceNormal = new Cartesian3();\nfunction getZoomDistanceUnderground(controller, ray) {\n  const origin = ray.origin;\n  const direction = ray.direction;\n  const distanceFromSurface = getDistanceFromSurface(controller);\n\n  // Weight zoom distance based on how strongly the pick ray is pointing inward.\n  // Geocentric normal is accurate enough for these purposes\n  const surfaceNormal = Cartesian3.normalize(origin, scratchSurfaceNormal);\n  let strength = Math.abs(Cartesian3.dot(surfaceNormal, direction));\n  strength = Math.max(strength, 0.5) * 2.0;\n  return distanceFromSurface * strength;\n}\nfunction getTiltCenterUnderground(controller, ray, pickedPosition, result) {\n  let distance = Cartesian3.distance(ray.origin, pickedPosition);\n  const distanceFromSurface = getDistanceFromSurface(controller);\n  const maximumDistance = CesiumMath.clamp(distanceFromSurface * 5.0, controller._minimumUndergroundPickDistance, controller._maximumUndergroundPickDistance);\n  if (distance > maximumDistance) {\n    // Simulate look-at behavior by tilting around a small invisible sphere\n    distance = Math.min(distance, distanceFromSurface / 5.0);\n    distance = Math.max(distance, 100.0);\n  }\n  return Ray.getPoint(ray, distance, result);\n}\nfunction getStrafeStartPositionUnderground(controller, ray, pickedPosition, result) {\n  let distance;\n  if (!defined(pickedPosition)) {\n    distance = getDistanceFromSurface(controller);\n  } else {\n    distance = Cartesian3.distance(ray.origin, pickedPosition);\n    if (distance > controller._maximumUndergroundPickDistance) {\n      // If the picked position is too far away set the strafe speed based on the\n      // camera's height from the globe surface\n      distance = getDistanceFromSurface(controller);\n    }\n  }\n  return Ray.getPoint(ray, distance, result);\n}\nconst scratchInertialDelta = new Cartesian2();\nfunction continueStrafing(controller, movement) {\n  // Update the end position continually based on the inertial delta\n  const originalEndPosition = movement.endPosition;\n  const inertialDelta = Cartesian2.subtract(movement.endPosition, movement.startPosition, scratchInertialDelta);\n  const endPosition = controller._strafeEndMousePosition;\n  Cartesian2.add(endPosition, inertialDelta, endPosition);\n  movement.endPosition = endPosition;\n  strafe(controller, movement, controller._strafeStartPosition);\n  movement.endPosition = originalEndPosition;\n}\nconst translateCVStartRay = new Ray();\nconst translateCVEndRay = new Ray();\nconst translateCVStartPos = new Cartesian3();\nconst translateCVEndPos = new Cartesian3();\nconst translateCVDifference = new Cartesian3();\nconst translateCVOrigin = new Cartesian3();\nconst translateCVPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst translateCVStartMouse = new Cartesian2();\nconst translateCVEndMouse = new Cartesian2();\nfunction translateCV(controller, startPosition, movement) {\n  if (!Cartesian3.equals(startPosition, controller._translateMousePosition)) {\n    controller._looking = false;\n  }\n  if (!Cartesian3.equals(startPosition, controller._strafeMousePosition)) {\n    controller._strafing = false;\n  }\n  if (controller._looking) {\n    look3D(controller, startPosition, movement);\n    return;\n  }\n  if (controller._strafing) {\n    continueStrafing(controller, movement);\n    return;\n  }\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n  const startMouse = Cartesian2.clone(movement.startPosition, translateCVStartMouse);\n  const endMouse = Cartesian2.clone(movement.endPosition, translateCVEndMouse);\n  let startRay = camera.getPickRay(startMouse, translateCVStartRay);\n  const origin = Cartesian3.clone(Cartesian3.ZERO, translateCVOrigin);\n  const normal = Cartesian3.UNIT_X;\n  let globePos;\n  if (camera.position.z < controller._minimumPickingTerrainHeight) {\n    globePos = pickPosition(controller, startMouse, translateCVStartPos);\n    if (defined(globePos)) {\n      origin.x = globePos.x;\n    }\n  }\n  if (cameraUnderground || origin.x > camera.position.z && defined(globePos)) {\n    let pickPosition = globePos;\n    if (cameraUnderground) {\n      pickPosition = getStrafeStartPositionUnderground(controller, startRay, globePos, translateCVStartPos);\n    }\n    Cartesian2.clone(startPosition, controller._strafeMousePosition);\n    Cartesian2.clone(startPosition, controller._strafeEndMousePosition);\n    Cartesian3.clone(pickPosition, controller._strafeStartPosition);\n    controller._strafing = true;\n    strafe(controller, movement, controller._strafeStartPosition);\n    return;\n  }\n  const plane = Plane.fromPointNormal(origin, normal, translateCVPlane);\n  startRay = camera.getPickRay(startMouse, translateCVStartRay);\n  const startPlanePos = IntersectionTests.rayPlane(startRay, plane, translateCVStartPos);\n  const endRay = camera.getPickRay(endMouse, translateCVEndRay);\n  const endPlanePos = IntersectionTests.rayPlane(endRay, plane, translateCVEndPos);\n  if (!defined(startPlanePos) || !defined(endPlanePos)) {\n    controller._looking = true;\n    look3D(controller, startPosition, movement);\n    Cartesian2.clone(startPosition, controller._translateMousePosition);\n    return;\n  }\n  const diff = Cartesian3.subtract(startPlanePos, endPlanePos, translateCVDifference);\n  const temp = diff.x;\n  diff.x = diff.y;\n  diff.y = diff.z;\n  diff.z = temp;\n  const mag = Cartesian3.magnitude(diff);\n  if (mag > CesiumMath.EPSILON6) {\n    Cartesian3.normalize(diff, diff);\n    camera.move(diff, mag);\n  }\n}\nconst rotateCVWindowPos = new Cartesian2();\nconst rotateCVWindowRay = new Ray();\nconst rotateCVCenter = new Cartesian3();\nconst rotateCVVerticalCenter = new Cartesian3();\nconst rotateCVTransform = new Matrix4();\nconst rotateCVVerticalTransform = new Matrix4();\nconst rotateCVOrigin = new Cartesian3();\nconst rotateCVPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst rotateCVCartesian3 = new Cartesian3();\nconst rotateCVCart = new Cartographic();\nconst rotateCVOldTransform = new Matrix4();\nconst rotateCVQuaternion = new Quaternion();\nconst rotateCVMatrix = new Matrix3();\nconst tilt3DCartesian3 = new Cartesian3();\nfunction rotateCV(controller, startPosition, movement) {\n  if (defined(movement.angleAndHeight)) {\n    movement = movement.angleAndHeight;\n  }\n  if (!Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    controller._tiltCVOffMap = false;\n    controller._looking = false;\n  }\n  if (controller._looking) {\n    look3D(controller, startPosition, movement);\n    return;\n  }\n  const scene = controller._scene;\n  const camera = scene.camera;\n  if (controller._tiltCVOffMap || !controller.onMap() || Math.abs(camera.position.z) > controller._minimumPickingTerrainHeight) {\n    controller._tiltCVOffMap = true;\n    rotateCVOnPlane(controller, startPosition, movement);\n  } else {\n    rotateCVOnTerrain(controller, startPosition, movement);\n  }\n}\nfunction rotateCVOnPlane(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n  const windowPosition = rotateCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  const ray = camera.getPickRay(windowPosition, rotateCVWindowRay);\n  const normal = Cartesian3.UNIT_X;\n  const position = ray.origin;\n  const direction = ray.direction;\n  let scalar;\n  const normalDotDirection = Cartesian3.dot(normal, direction);\n  if (Math.abs(normalDotDirection) > CesiumMath.EPSILON6) {\n    scalar = -Cartesian3.dot(normal, position) / normalDotDirection;\n  }\n  if (!defined(scalar) || scalar <= 0.0) {\n    controller._looking = true;\n    look3D(controller, startPosition, movement);\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    return;\n  }\n  const center = Cartesian3.multiplyByScalar(direction, scalar, rotateCVCenter);\n  Cartesian3.add(position, center, center);\n  const projection = scene.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n  Cartesian3.fromElements(center.y, center.z, center.x, center);\n  const cart = projection.unproject(center, rotateCVCart);\n  ellipsoid.cartographicToCartesian(cart, center);\n  const transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, rotateCVTransform);\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n  const oldTransform = Matrix4.clone(camera.transform, rotateCVOldTransform);\n  camera._setTransform(transform);\n  rotate3D(controller, startPosition, movement, Cartesian3.UNIT_Z);\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n}\nfunction rotateCVOnTerrain(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n  let center;\n  let ray;\n  const normal = Cartesian3.UNIT_X;\n  if (Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    center = Cartesian3.clone(controller._tiltCenter, rotateCVCenter);\n  } else {\n    if (camera.position.z < controller._minimumPickingTerrainHeight) {\n      center = pickPosition(controller, startPosition, rotateCVCenter);\n    }\n    if (!defined(center)) {\n      ray = camera.getPickRay(startPosition, rotateCVWindowRay);\n      const position = ray.origin;\n      const direction = ray.direction;\n      let scalar;\n      const normalDotDirection = Cartesian3.dot(normal, direction);\n      if (Math.abs(normalDotDirection) > CesiumMath.EPSILON6) {\n        scalar = -Cartesian3.dot(normal, position) / normalDotDirection;\n      }\n      if (!defined(scalar) || scalar <= 0.0) {\n        controller._looking = true;\n        look3D(controller, startPosition, movement);\n        Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n        return;\n      }\n      center = Cartesian3.multiplyByScalar(direction, scalar, rotateCVCenter);\n      Cartesian3.add(position, center, center);\n    }\n    if (cameraUnderground) {\n      if (!defined(ray)) {\n        ray = camera.getPickRay(startPosition, rotateCVWindowRay);\n      }\n      getTiltCenterUnderground(controller, ray, center, center);\n    }\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    Cartesian3.clone(center, controller._tiltCenter);\n  }\n  const canvas = scene.canvas;\n  const windowPosition = rotateCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = controller._tiltCenterMousePosition.y;\n  ray = camera.getPickRay(windowPosition, rotateCVWindowRay);\n  const origin = Cartesian3.clone(Cartesian3.ZERO, rotateCVOrigin);\n  origin.x = center.x;\n  const plane = Plane.fromPointNormal(origin, normal, rotateCVPlane);\n  const verticalCenter = IntersectionTests.rayPlane(ray, plane, rotateCVVerticalCenter);\n  const projection = camera._projection;\n  const ellipsoid = projection.ellipsoid;\n  Cartesian3.fromElements(center.y, center.z, center.x, center);\n  let cart = projection.unproject(center, rotateCVCart);\n  ellipsoid.cartographicToCartesian(cart, center);\n  const transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, rotateCVTransform);\n  let verticalTransform;\n  if (defined(verticalCenter)) {\n    Cartesian3.fromElements(verticalCenter.y, verticalCenter.z, verticalCenter.x, verticalCenter);\n    cart = projection.unproject(verticalCenter, rotateCVCart);\n    ellipsoid.cartographicToCartesian(cart, verticalCenter);\n    verticalTransform = Transforms.eastNorthUpToFixedFrame(verticalCenter, ellipsoid, rotateCVVerticalTransform);\n  } else {\n    verticalTransform = transform;\n  }\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n  let constrainedAxis = Cartesian3.UNIT_Z;\n  const oldTransform = Matrix4.clone(camera.transform, rotateCVOldTransform);\n  camera._setTransform(transform);\n  const tangent = Cartesian3.cross(Cartesian3.UNIT_Z, Cartesian3.normalize(camera.position, rotateCVCartesian3), rotateCVCartesian3);\n  const dot = Cartesian3.dot(camera.right, tangent);\n  rotate3D(controller, startPosition, movement, constrainedAxis, false, true);\n  camera._setTransform(verticalTransform);\n  if (dot < 0.0) {\n    const movementDelta = movement.startPosition.y - movement.endPosition.y;\n    if (cameraUnderground && movementDelta < 0.0 || !cameraUnderground && movementDelta > 0.0) {\n      // Prevent camera from flipping past the up axis\n      constrainedAxis = undefined;\n    }\n    const oldConstrainedAxis = camera.constrainedAxis;\n    camera.constrainedAxis = undefined;\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n    camera.constrainedAxis = oldConstrainedAxis;\n  } else {\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n  }\n  if (defined(camera.constrainedAxis)) {\n    const right = Cartesian3.cross(camera.direction, camera.constrainedAxis, tilt3DCartesian3);\n    if (!Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)) {\n      if (Cartesian3.dot(right, camera.right) < 0.0) {\n        Cartesian3.negate(right, right);\n      }\n      Cartesian3.cross(right, camera.direction, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.normalize(camera.up, camera.up);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n  }\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n  const originalPosition = Cartesian3.clone(camera.positionWC, rotateCVCartesian3);\n  if (controller.enableCollisionDetection) {\n    adjustHeightForTerrain(controller, true);\n  }\n  if (!Cartesian3.equals(camera.positionWC, originalPosition)) {\n    camera._setTransform(verticalTransform);\n    camera.worldToCameraCoordinatesPoint(originalPosition, originalPosition);\n    const magSqrd = Cartesian3.magnitudeSquared(originalPosition);\n    if (Cartesian3.magnitudeSquared(camera.position) > magSqrd) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.multiplyByScalar(camera.position, Math.sqrt(magSqrd), camera.position);\n    }\n    const angle = Cartesian3.angleBetween(originalPosition, camera.position);\n    const axis = Cartesian3.cross(originalPosition, camera.position, originalPosition);\n    Cartesian3.normalize(axis, axis);\n    const quaternion = Quaternion.fromAxisAngle(axis, angle, rotateCVQuaternion);\n    const rotation = Matrix3.fromQuaternion(quaternion, rotateCVMatrix);\n    Matrix3.multiplyByVector(rotation, camera.direction, camera.direction);\n    Matrix3.multiplyByVector(rotation, camera.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.cross(camera.right, camera.direction, camera.up);\n    camera._setTransform(oldTransform);\n  }\n}\nconst zoomCVWindowPos = new Cartesian2();\nconst zoomCVWindowRay = new Ray();\nconst zoomCVIntersection = new Cartesian3();\nfunction zoomCV(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n  const cameraUnderground = controller._cameraUnderground;\n  let windowPosition;\n  if (cameraUnderground) {\n    windowPosition = startPosition;\n  } else {\n    windowPosition = zoomCVWindowPos;\n    windowPosition.x = canvas.clientWidth / 2;\n    windowPosition.y = canvas.clientHeight / 2;\n  }\n  const ray = camera.getPickRay(windowPosition, zoomCVWindowRay);\n  const position = ray.origin;\n  const direction = ray.direction;\n  const height = camera.position.z;\n  let intersection;\n  if (height < controller._minimumPickingTerrainHeight) {\n    intersection = pickPosition(controller, windowPosition, zoomCVIntersection);\n  }\n  let distance;\n  if (defined(intersection)) {\n    distance = Cartesian3.distance(position, intersection);\n  }\n  if (cameraUnderground) {\n    const distanceUnderground = getZoomDistanceUnderground(controller, ray, height);\n    if (defined(distance)) {\n      distance = Math.min(distance, distanceUnderground);\n    } else {\n      distance = distanceUnderground;\n    }\n  }\n  if (!defined(distance)) {\n    const normal = Cartesian3.UNIT_X;\n    distance = -Cartesian3.dot(normal, position) / Cartesian3.dot(normal, direction);\n  }\n  handleZoom(controller, startPosition, movement, controller.zoomFactor, distance);\n}\nfunction updateCV(controller) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  if (!Matrix4.equals(Matrix4.IDENTITY, camera.transform)) {\n    reactToInput(controller, controller.enableRotate, controller.rotateEventTypes, rotate3D, controller.inertiaSpin, \"_lastInertiaSpinMovement\");\n    reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoom3D, controller.inertiaZoom, \"_lastInertiaZoomMovement\");\n  } else {\n    const tweens = controller._tweens;\n    if (controller._aggregator.anyButtonDown) {\n      tweens.removeAll();\n    }\n    reactToInput(controller, controller.enableTilt, controller.tiltEventTypes, rotateCV, controller.inertiaSpin, \"_lastInertiaTiltMovement\");\n    reactToInput(controller, controller.enableTranslate, controller.translateEventTypes, translateCV, controller.inertiaTranslate, \"_lastInertiaTranslateMovement\");\n    reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoomCV, controller.inertiaZoom, \"_lastInertiaZoomMovement\");\n    reactToInput(controller, controller.enableLook, controller.lookEventTypes, look3D);\n    if (!controller._aggregator.anyButtonDown && !tweens.contains(controller._tween)) {\n      const tween = camera.createCorrectPositionTween(controller.bounceAnimationTime);\n      if (defined(tween)) {\n        controller._tween = tweens.add(tween);\n      }\n    }\n    tweens.update();\n  }\n}\nconst scratchStrafeRay = new Ray();\nconst scratchStrafePlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst scratchStrafeIntersection = new Cartesian3();\nconst scratchStrafeDirection = new Cartesian3();\nfunction strafe(controller, movement, strafeStartPosition) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const ray = camera.getPickRay(movement.endPosition, scratchStrafeRay);\n  let direction = Cartesian3.clone(camera.direction, scratchStrafeDirection);\n  if (scene.mode === SceneMode.COLUMBUS_VIEW) {\n    Cartesian3.fromElements(direction.z, direction.x, direction.y, direction);\n  }\n  const plane = Plane.fromPointNormal(strafeStartPosition, direction, scratchStrafePlane);\n  const intersection = IntersectionTests.rayPlane(ray, plane, scratchStrafeIntersection);\n  if (!defined(intersection)) {\n    return;\n  }\n  direction = Cartesian3.subtract(strafeStartPosition, intersection, direction);\n  if (scene.mode === SceneMode.COLUMBUS_VIEW) {\n    Cartesian3.fromElements(direction.y, direction.z, direction.x, direction);\n  }\n  Cartesian3.add(camera.position, direction, camera.position);\n}\nconst spin3DPick = new Cartesian3();\nconst scratchCartographic = new Cartographic();\nconst scratchRadii = new Cartesian3();\nconst scratchEllipsoid = new Ellipsoid();\nconst scratchLookUp = new Cartesian3();\nconst scratchNormal = new Cartesian3();\nconst scratchMousePosition = new Cartesian3();\nfunction spin3D(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n  let ellipsoid = controller._ellipsoid;\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    rotate3D(controller, startPosition, movement);\n    return;\n  }\n  let magnitude;\n  let radii;\n  const up = ellipsoid.geodeticSurfaceNormal(camera.position, scratchLookUp);\n  if (Cartesian2.equals(startPosition, controller._rotateMousePosition)) {\n    if (controller._looking) {\n      look3D(controller, startPosition, movement, up);\n    } else if (controller._rotating) {\n      rotate3D(controller, startPosition, movement);\n    } else if (controller._strafing) {\n      continueStrafing(controller, movement);\n    } else {\n      if (Cartesian3.magnitude(camera.position) < Cartesian3.magnitude(controller._rotateStartPosition)) {\n        // Pan action is no longer valid if camera moves below the pan ellipsoid\n        return;\n      }\n      magnitude = Cartesian3.magnitude(controller._rotateStartPosition);\n      radii = scratchRadii;\n      radii.x = radii.y = radii.z = magnitude;\n      ellipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n      pan3D(controller, startPosition, movement, ellipsoid);\n    }\n    return;\n  }\n  controller._looking = false;\n  controller._rotating = false;\n  controller._strafing = false;\n  const height = ellipsoid.cartesianToCartographic(camera.positionWC, scratchCartographic).height;\n  const globe = controller._globe;\n  if (defined(globe) && height < controller._minimumPickingTerrainHeight) {\n    const mousePos = pickPosition(controller, movement.startPosition, scratchMousePosition);\n    if (defined(mousePos)) {\n      let strafing = false;\n      const ray = camera.getPickRay(movement.startPosition, pickGlobeScratchRay);\n      if (cameraUnderground) {\n        strafing = true;\n        getStrafeStartPositionUnderground(controller, ray, mousePos, mousePos);\n      } else {\n        const normal = ellipsoid.geodeticSurfaceNormal(mousePos, scratchNormal);\n        const tangentPick = Math.abs(Cartesian3.dot(ray.direction, normal)) < 0.05;\n        if (tangentPick) {\n          strafing = true;\n        } else {\n          strafing = Cartesian3.magnitude(camera.position) < Cartesian3.magnitude(mousePos);\n        }\n      }\n      if (strafing) {\n        Cartesian2.clone(startPosition, controller._strafeEndMousePosition);\n        Cartesian3.clone(mousePos, controller._strafeStartPosition);\n        controller._strafing = true;\n        strafe(controller, movement, controller._strafeStartPosition);\n      } else {\n        magnitude = Cartesian3.magnitude(mousePos);\n        radii = scratchRadii;\n        radii.x = radii.y = radii.z = magnitude;\n        ellipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n        pan3D(controller, startPosition, movement, ellipsoid);\n        Cartesian3.clone(mousePos, controller._rotateStartPosition);\n      }\n    } else {\n      controller._looking = true;\n      look3D(controller, startPosition, movement, up);\n    }\n  } else if (defined(camera.pickEllipsoid(movement.startPosition, controller._ellipsoid, spin3DPick))) {\n    pan3D(controller, startPosition, movement, controller._ellipsoid);\n    Cartesian3.clone(spin3DPick, controller._rotateStartPosition);\n  } else if (height > controller._minimumTrackBallHeight) {\n    controller._rotating = true;\n    rotate3D(controller, startPosition, movement);\n  } else {\n    controller._looking = true;\n    look3D(controller, startPosition, movement, up);\n  }\n  Cartesian2.clone(startPosition, controller._rotateMousePosition);\n}\nfunction rotate3D(controller, startPosition, movement, constrainedAxis, rotateOnlyVertical, rotateOnlyHorizontal) {\n  rotateOnlyVertical = rotateOnlyVertical ?? false;\n  rotateOnlyHorizontal = rotateOnlyHorizontal ?? false;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n  const oldAxis = camera.constrainedAxis;\n  if (defined(constrainedAxis)) {\n    camera.constrainedAxis = constrainedAxis;\n  }\n  const rho = Cartesian3.magnitude(camera.position);\n  let rotateRate = controller._rotateFactor * (rho - controller._rotateRateRangeAdjustment);\n  if (rotateRate > controller._maximumRotateRate) {\n    rotateRate = controller._maximumRotateRate;\n  }\n  if (rotateRate < controller._minimumRotateRate) {\n    rotateRate = controller._minimumRotateRate;\n  }\n  let phiWindowRatio = (movement.startPosition.x - movement.endPosition.x) / canvas.clientWidth;\n  let thetaWindowRatio = (movement.startPosition.y - movement.endPosition.y) / canvas.clientHeight;\n  phiWindowRatio = Math.min(phiWindowRatio, controller.maximumMovementRatio);\n  thetaWindowRatio = Math.min(thetaWindowRatio, controller.maximumMovementRatio);\n  const deltaPhi = rotateRate * phiWindowRatio * Math.PI * 2.0;\n  let deltaTheta = rotateRate * thetaWindowRatio * Math.PI;\n  if (defined(constrainedAxis) && defined(controller.maximumTiltAngle)) {\n    const maximumTiltAngle = controller.maximumTiltAngle;\n    const dotProduct = Cartesian3.dot(camera.direction, constrainedAxis);\n    const tilt = Math.PI - Math.acos(dotProduct) + deltaTheta;\n    if (tilt > maximumTiltAngle) {\n      deltaTheta -= tilt - maximumTiltAngle;\n    }\n  }\n  if (!rotateOnlyVertical) {\n    camera.rotateRight(deltaPhi);\n  }\n  if (!rotateOnlyHorizontal) {\n    camera.rotateUp(deltaTheta);\n  }\n  camera.constrainedAxis = oldAxis;\n}\nconst pan3DP0 = Cartesian4.clone(Cartesian4.UNIT_W);\nconst pan3DP1 = Cartesian4.clone(Cartesian4.UNIT_W);\nconst pan3DTemp0 = new Cartesian3();\nconst pan3DTemp1 = new Cartesian3();\nconst pan3DTemp2 = new Cartesian3();\nconst pan3DTemp3 = new Cartesian3();\nconst pan3DStartMousePosition = new Cartesian2();\nconst pan3DEndMousePosition = new Cartesian2();\nconst pan3DDiffMousePosition = new Cartesian2();\nconst pan3DPixelDimensions = new Cartesian2();\nconst panRay = new Ray();\nfunction pan3D(controller, startPosition, movement, ellipsoid) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const startMousePosition = Cartesian2.clone(movement.startPosition, pan3DStartMousePosition);\n  const endMousePosition = Cartesian2.clone(movement.endPosition, pan3DEndMousePosition);\n  const height = ellipsoid.cartesianToCartographic(camera.positionWC, scratchCartographic).height;\n  let p0, p1;\n  if (!movement.inertiaEnabled && height < controller._minimumPickingTerrainHeight) {\n    p0 = Cartesian3.clone(controller._panLastWorldPosition, pan3DP0);\n\n    // Use the last picked world position unless we're starting a new drag\n    if (!defined(controller._globe) && !Cartesian2.equalsEpsilon(startMousePosition, controller._panLastMousePosition)) {\n      p0 = pickPosition(controller, startMousePosition, pan3DP0);\n    }\n    if (!defined(controller._globe) && defined(p0)) {\n      const toCenter = Cartesian3.subtract(p0, camera.positionWC, pan3DTemp1);\n      const toCenterProj = Cartesian3.multiplyByScalar(camera.directionWC, Cartesian3.dot(camera.directionWC, toCenter), pan3DTemp1);\n      const distanceToNearPlane = Cartesian3.magnitude(toCenterProj);\n      const pixelDimensions = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distanceToNearPlane, scene.pixelRatio, pan3DPixelDimensions);\n      const dragDelta = Cartesian2.subtract(endMousePosition, startMousePosition, pan3DDiffMousePosition);\n\n      // Move the camera to the the distance the cursor moved in worldspace\n      const right = Cartesian3.multiplyByScalar(camera.rightWC, dragDelta.x * pixelDimensions.x, pan3DTemp1);\n\n      // Move the camera towards the picked position in worldspace as the camera is pointed towards a horizon view\n      const cameraPositionNormal = Cartesian3.normalize(camera.positionWC, scratchCameraPositionNormal);\n      const endPickDirection = camera.getPickRay(endMousePosition, panRay).direction;\n      const endPickProj = Cartesian3.subtract(endPickDirection, Cartesian3.projectVector(endPickDirection, camera.rightWC, pan3DTemp2), pan3DTemp2);\n      const angle = Cartesian3.angleBetween(endPickProj, camera.directionWC);\n      let forward = 1.0;\n      if (defined(camera.frustum.fov)) {\n        forward = Math.max(Math.tan(angle), 0.1); // Clamp so we don't make the magnitude infinitely large when the angle is small\n      }\n      let dot = Math.abs(Cartesian3.dot(camera.directionWC, cameraPositionNormal));\n      const magnitude = -dragDelta.y * pixelDimensions.y * 2.0 / Math.sqrt(forward) * (1.0 - dot);\n      const direction = Cartesian3.multiplyByScalar(endPickDirection, magnitude, pan3DTemp2);\n\n      // Move the camera up the distance the cursor moved in worldspace as the camera is pointed towards the center\n      dot = Math.abs(Cartesian3.dot(camera.upWC, cameraPositionNormal));\n      const up = Cartesian3.multiplyByScalar(camera.upWC, -dragDelta.y * (1.0 - dot) * pixelDimensions.y, pan3DTemp3);\n      p1 = Cartesian3.add(p0, right, pan3DP1);\n      p1 = Cartesian3.add(p1, direction, p1);\n      p1 = Cartesian3.add(p1, up, p1);\n      Cartesian3.clone(p1, controller._panLastWorldPosition);\n      Cartesian2.clone(endMousePosition, controller._panLastMousePosition);\n    }\n  }\n  if (!defined(p0) || !defined(p1)) {\n    p0 = camera.pickEllipsoid(startMousePosition, ellipsoid, pan3DP0);\n    p1 = camera.pickEllipsoid(endMousePosition, ellipsoid, pan3DP1);\n  }\n  if (!defined(p0) || !defined(p1)) {\n    controller._rotating = true;\n    rotate3D(controller, startPosition, movement);\n    return;\n  }\n  p0 = camera.worldToCameraCoordinates(p0, p0);\n  p1 = camera.worldToCameraCoordinates(p1, p1);\n  if (!defined(camera.constrainedAxis)) {\n    Cartesian3.normalize(p0, p0);\n    Cartesian3.normalize(p1, p1);\n    const dot = Cartesian3.dot(p0, p1);\n    const axis = Cartesian3.cross(p0, p1, pan3DTemp0);\n    if (dot < 1.0 && !Cartesian3.equalsEpsilon(axis, Cartesian3.ZERO, CesiumMath.EPSILON14)) {\n      // dot is in [0, 1]\n      const angle = Math.acos(dot);\n      camera.rotate(axis, angle);\n    }\n  } else {\n    const basis0 = camera.constrainedAxis;\n    const basis1 = Cartesian3.mostOrthogonalAxis(basis0, pan3DTemp0);\n    Cartesian3.cross(basis1, basis0, basis1);\n    Cartesian3.normalize(basis1, basis1);\n    const basis2 = Cartesian3.cross(basis0, basis1, pan3DTemp1);\n    const startRho = Cartesian3.magnitude(p0);\n    const startDot = Cartesian3.dot(basis0, p0);\n    const startTheta = Math.acos(startDot / startRho);\n    const startRej = Cartesian3.multiplyByScalar(basis0, startDot, pan3DTemp2);\n    Cartesian3.subtract(p0, startRej, startRej);\n    Cartesian3.normalize(startRej, startRej);\n    const endRho = Cartesian3.magnitude(p1);\n    const endDot = Cartesian3.dot(basis0, p1);\n    const endTheta = Math.acos(endDot / endRho);\n    const endRej = Cartesian3.multiplyByScalar(basis0, endDot, pan3DTemp3);\n    Cartesian3.subtract(p1, endRej, endRej);\n    Cartesian3.normalize(endRej, endRej);\n    let startPhi = Math.acos(Cartesian3.dot(startRej, basis1));\n    if (Cartesian3.dot(startRej, basis2) < 0) {\n      startPhi = CesiumMath.TWO_PI - startPhi;\n    }\n    let endPhi = Math.acos(Cartesian3.dot(endRej, basis1));\n    if (Cartesian3.dot(endRej, basis2) < 0) {\n      endPhi = CesiumMath.TWO_PI - endPhi;\n    }\n    const deltaPhi = startPhi - endPhi;\n    let east;\n    if (Cartesian3.equalsEpsilon(basis0, camera.position, CesiumMath.EPSILON2)) {\n      east = camera.right;\n    } else {\n      east = Cartesian3.cross(basis0, camera.position, pan3DTemp0);\n    }\n    const planeNormal = Cartesian3.cross(basis0, east, pan3DTemp0);\n    const side0 = Cartesian3.dot(planeNormal, Cartesian3.subtract(p0, basis0, pan3DTemp1));\n    const side1 = Cartesian3.dot(planeNormal, Cartesian3.subtract(p1, basis0, pan3DTemp1));\n    let deltaTheta;\n    if (side0 > 0 && side1 > 0) {\n      deltaTheta = endTheta - startTheta;\n    } else if (side0 > 0 && side1 <= 0) {\n      if (Cartesian3.dot(camera.position, basis0) > 0) {\n        deltaTheta = -startTheta - endTheta;\n      } else {\n        deltaTheta = startTheta + endTheta;\n      }\n    } else {\n      deltaTheta = startTheta - endTheta;\n    }\n    camera.rotateRight(deltaPhi);\n    camera.rotateUp(deltaTheta);\n  }\n}\nconst zoom3DUnitPosition = new Cartesian3();\nconst zoom3DCartographic = new Cartographic();\nlet preIntersectionDistance = 0;\nfunction zoom3D(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n  const inertiaMovement = movement.inertiaEnabled;\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n  const cameraUnderground = controller._cameraUnderground;\n  let windowPosition;\n  if (cameraUnderground) {\n    windowPosition = startPosition;\n  } else {\n    windowPosition = zoomCVWindowPos;\n    windowPosition.x = canvas.clientWidth / 2;\n    windowPosition.y = canvas.clientHeight / 2;\n  }\n  const ray = camera.getPickRay(windowPosition, zoomCVWindowRay);\n  let intersection;\n  const height = ellipsoid.cartesianToCartographic(camera.position, zoom3DCartographic).height;\n  const approachingCollision = Math.abs(preIntersectionDistance) < controller.minimumPickingTerrainDistanceWithInertia;\n  const needPickGlobe = inertiaMovement ? approachingCollision : height < controller._minimumPickingTerrainHeight;\n  if (needPickGlobe) {\n    intersection = pickPosition(controller, windowPosition, zoomCVIntersection);\n  }\n  let distance;\n  if (defined(intersection)) {\n    distance = Cartesian3.distance(ray.origin, intersection);\n    preIntersectionDistance = distance;\n  }\n  if (cameraUnderground) {\n    const distanceUnderground = getZoomDistanceUnderground(controller, ray, height);\n    if (defined(distance)) {\n      distance = Math.min(distance, distanceUnderground);\n    } else {\n      distance = distanceUnderground;\n    }\n  }\n  if (!defined(distance)) {\n    distance = height;\n  }\n  const unitPosition = Cartesian3.normalize(camera.position, zoom3DUnitPosition);\n  handleZoom(controller, startPosition, movement, controller.zoomFactor, distance, Cartesian3.dot(unitPosition, camera.direction));\n}\nconst tilt3DWindowPos = new Cartesian2();\nconst tilt3DRay = new Ray();\nconst tilt3DCenter = new Cartesian3();\nconst tilt3DVerticalCenter = new Cartesian3();\nconst tilt3DTransform = new Matrix4();\nconst tilt3DVerticalTransform = new Matrix4();\nconst tilt3DOldTransform = new Matrix4();\nconst tilt3DQuaternion = new Quaternion();\nconst tilt3DMatrix = new Matrix3();\nconst tilt3DCart = new Cartographic();\nconst tilt3DLookUp = new Cartesian3();\nfunction tilt3D(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    return;\n  }\n  if (defined(movement.angleAndHeight)) {\n    movement = movement.angleAndHeight;\n  }\n  if (!Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    controller._tiltOnEllipsoid = false;\n    controller._looking = false;\n  }\n  if (controller._looking) {\n    const up = controller._ellipsoid.geodeticSurfaceNormal(camera.position, tilt3DLookUp);\n    look3D(controller, startPosition, movement, up);\n    return;\n  }\n  const ellipsoid = controller._ellipsoid;\n  const cartographic = ellipsoid.cartesianToCartographic(camera.position, tilt3DCart);\n  if (controller._tiltOnEllipsoid || cartographic.height > controller._minimumCollisionTerrainHeight) {\n    controller._tiltOnEllipsoid = true;\n    tilt3DOnEllipsoid(controller, startPosition, movement);\n  } else {\n    tilt3DOnTerrain(controller, startPosition, movement);\n  }\n}\nconst tilt3DOnEllipsoidCartographic = new Cartographic();\nfunction tilt3DOnEllipsoid(controller, startPosition, movement) {\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const minHeight = controller.minimumZoomDistance * 0.25;\n  const height = ellipsoid.cartesianToCartographic(camera.positionWC, tilt3DOnEllipsoidCartographic).height;\n  if (height - minHeight - 1.0 < CesiumMath.EPSILON3 && movement.endPosition.y - movement.startPosition.y < 0) {\n    return;\n  }\n  const canvas = scene.canvas;\n  const windowPosition = tilt3DWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  const ray = camera.getPickRay(windowPosition, tilt3DRay);\n  let center;\n  const intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n  if (defined(intersection)) {\n    center = Ray.getPoint(ray, intersection.start, tilt3DCenter);\n  } else if (height > controller._minimumTrackBallHeight) {\n    const grazingAltitudeLocation = IntersectionTests.grazingAltitudeLocation(ray, ellipsoid);\n    if (!defined(grazingAltitudeLocation)) {\n      return;\n    }\n    const grazingAltitudeCart = ellipsoid.cartesianToCartographic(grazingAltitudeLocation, tilt3DCart);\n    grazingAltitudeCart.height = 0.0;\n    center = ellipsoid.cartographicToCartesian(grazingAltitudeCart, tilt3DCenter);\n  } else {\n    controller._looking = true;\n    const up = controller._ellipsoid.geodeticSurfaceNormal(camera.position, tilt3DLookUp);\n    look3D(controller, startPosition, movement, up);\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    return;\n  }\n  const transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, tilt3DTransform);\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n  const oldTransform = Matrix4.clone(camera.transform, tilt3DOldTransform);\n  camera._setTransform(transform);\n  rotate3D(controller, startPosition, movement, Cartesian3.UNIT_Z);\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n}\nfunction tilt3DOnTerrain(controller, startPosition, movement) {\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n  let center;\n  let ray;\n  let intersection;\n  if (Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    center = Cartesian3.clone(controller._tiltCenter, tilt3DCenter);\n  } else {\n    center = pickPosition(controller, startPosition, tilt3DCenter);\n    if (!defined(center)) {\n      ray = camera.getPickRay(startPosition, tilt3DRay);\n      intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n      if (!defined(intersection)) {\n        const cartographic = ellipsoid.cartesianToCartographic(camera.position, tilt3DCart);\n        if (cartographic.height <= controller._minimumTrackBallHeight) {\n          controller._looking = true;\n          const up = controller._ellipsoid.geodeticSurfaceNormal(camera.position, tilt3DLookUp);\n          look3D(controller, startPosition, movement, up);\n          Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n        }\n        return;\n      }\n      center = Ray.getPoint(ray, intersection.start, tilt3DCenter);\n    }\n    if (cameraUnderground) {\n      if (!defined(ray)) {\n        ray = camera.getPickRay(startPosition, tilt3DRay);\n      }\n      getTiltCenterUnderground(controller, ray, center, center);\n    }\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    Cartesian3.clone(center, controller._tiltCenter);\n  }\n  const canvas = scene.canvas;\n  const windowPosition = tilt3DWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = controller._tiltCenterMousePosition.y;\n  ray = camera.getPickRay(windowPosition, tilt3DRay);\n  const mag = Cartesian3.magnitude(center);\n  const radii = Cartesian3.fromElements(mag, mag, mag, scratchRadii);\n  const newEllipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n  intersection = IntersectionTests.rayEllipsoid(ray, newEllipsoid);\n  if (!defined(intersection)) {\n    return;\n  }\n  const t = Cartesian3.magnitude(ray.origin) > mag ? intersection.start : intersection.stop;\n  const verticalCenter = Ray.getPoint(ray, t, tilt3DVerticalCenter);\n  const transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, tilt3DTransform);\n  const verticalTransform = Transforms.eastNorthUpToFixedFrame(verticalCenter, newEllipsoid, tilt3DVerticalTransform);\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n  let constrainedAxis = Cartesian3.UNIT_Z;\n  const oldTransform = Matrix4.clone(camera.transform, tilt3DOldTransform);\n  camera._setTransform(verticalTransform);\n  const tangent = Cartesian3.cross(verticalCenter, camera.positionWC, tilt3DCartesian3);\n  const dot = Cartesian3.dot(camera.rightWC, tangent);\n  if (dot < 0.0) {\n    const movementDelta = movement.startPosition.y - movement.endPosition.y;\n    if (cameraUnderground && movementDelta < 0.0 || !cameraUnderground && movementDelta > 0.0) {\n      // Prevent camera from flipping past the up axis\n      constrainedAxis = undefined;\n    }\n    const oldConstrainedAxis = camera.constrainedAxis;\n    camera.constrainedAxis = undefined;\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n    camera.constrainedAxis = oldConstrainedAxis;\n  } else {\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n  }\n  camera._setTransform(transform);\n  rotate3D(controller, startPosition, movement, constrainedAxis, false, true);\n  if (defined(camera.constrainedAxis)) {\n    const right = Cartesian3.cross(camera.direction, camera.constrainedAxis, tilt3DCartesian3);\n    if (!Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)) {\n      if (Cartesian3.dot(right, camera.right) < 0.0) {\n        Cartesian3.negate(right, right);\n      }\n      Cartesian3.cross(right, camera.direction, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.normalize(camera.up, camera.up);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n  }\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n  const originalPosition = Cartesian3.clone(camera.positionWC, tilt3DCartesian3);\n  if (controller.enableCollisionDetection) {\n    adjustHeightForTerrain(controller, true);\n  }\n  if (!Cartesian3.equals(camera.positionWC, originalPosition)) {\n    camera._setTransform(verticalTransform);\n    camera.worldToCameraCoordinatesPoint(originalPosition, originalPosition);\n    const magSqrd = Cartesian3.magnitudeSquared(originalPosition);\n    if (Cartesian3.magnitudeSquared(camera.position) > magSqrd) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.multiplyByScalar(camera.position, Math.sqrt(magSqrd), camera.position);\n    }\n    const angle = Cartesian3.angleBetween(originalPosition, camera.position);\n    const axis = Cartesian3.cross(originalPosition, camera.position, originalPosition);\n    Cartesian3.normalize(axis, axis);\n    const quaternion = Quaternion.fromAxisAngle(axis, angle, tilt3DQuaternion);\n    const rotation = Matrix3.fromQuaternion(quaternion, tilt3DMatrix);\n    Matrix3.multiplyByVector(rotation, camera.direction, camera.direction);\n    Matrix3.multiplyByVector(rotation, camera.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.cross(camera.right, camera.direction, camera.up);\n    camera._setTransform(oldTransform);\n  }\n}\nconst look3DStartPos = new Cartesian2();\nconst look3DEndPos = new Cartesian2();\nconst look3DStartRay = new Ray();\nconst look3DEndRay = new Ray();\nconst look3DNegativeRot = new Cartesian3();\nconst look3DTan = new Cartesian3();\nfunction look3D(controller, startPosition, movement, rotationAxis) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const startPos = look3DStartPos;\n  startPos.x = movement.startPosition.x;\n  startPos.y = 0.0;\n  const endPos = look3DEndPos;\n  endPos.x = movement.endPosition.x;\n  endPos.y = 0.0;\n  let startRay = camera.getPickRay(startPos, look3DStartRay);\n  let endRay = camera.getPickRay(endPos, look3DEndRay);\n  let angle = 0.0;\n  let start;\n  let end;\n  if (camera.frustum instanceof OrthographicFrustum) {\n    start = startRay.origin;\n    end = endRay.origin;\n    Cartesian3.add(camera.direction, start, start);\n    Cartesian3.add(camera.direction, end, end);\n    Cartesian3.subtract(start, camera.position, start);\n    Cartesian3.subtract(end, camera.position, end);\n    Cartesian3.normalize(start, start);\n    Cartesian3.normalize(end, end);\n  } else {\n    start = startRay.direction;\n    end = endRay.direction;\n  }\n  let dot = Cartesian3.dot(start, end);\n  if (dot < 1.0) {\n    // dot is in [0, 1]\n    angle = Math.acos(dot);\n  }\n  angle = movement.startPosition.x > movement.endPosition.x ? -angle : angle;\n  const horizontalRotationAxis = controller._horizontalRotationAxis;\n  if (defined(rotationAxis)) {\n    camera.look(rotationAxis, -angle);\n  } else if (defined(horizontalRotationAxis)) {\n    camera.look(horizontalRotationAxis, -angle);\n  } else {\n    camera.lookLeft(angle);\n  }\n  startPos.x = 0.0;\n  startPos.y = movement.startPosition.y;\n  endPos.x = 0.0;\n  endPos.y = movement.endPosition.y;\n  startRay = camera.getPickRay(startPos, look3DStartRay);\n  endRay = camera.getPickRay(endPos, look3DEndRay);\n  angle = 0.0;\n  if (camera.frustum instanceof OrthographicFrustum) {\n    start = startRay.origin;\n    end = endRay.origin;\n    Cartesian3.add(camera.direction, start, start);\n    Cartesian3.add(camera.direction, end, end);\n    Cartesian3.subtract(start, camera.position, start);\n    Cartesian3.subtract(end, camera.position, end);\n    Cartesian3.normalize(start, start);\n    Cartesian3.normalize(end, end);\n  } else {\n    start = startRay.direction;\n    end = endRay.direction;\n  }\n  dot = Cartesian3.dot(start, end);\n  if (dot < 1.0) {\n    // dot is in [0, 1]\n    angle = Math.acos(dot);\n  }\n  angle = movement.startPosition.y > movement.endPosition.y ? -angle : angle;\n  rotationAxis = rotationAxis ?? horizontalRotationAxis;\n  if (defined(rotationAxis)) {\n    const direction = camera.direction;\n    const negativeRotationAxis = Cartesian3.negate(rotationAxis, look3DNegativeRot);\n    const northParallel = Cartesian3.equalsEpsilon(direction, rotationAxis, CesiumMath.EPSILON2);\n    const southParallel = Cartesian3.equalsEpsilon(direction, negativeRotationAxis, CesiumMath.EPSILON2);\n    if (!northParallel && !southParallel) {\n      dot = Cartesian3.dot(direction, rotationAxis);\n      let angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle > 0 && angle > angleToAxis) {\n        angle = angleToAxis - CesiumMath.EPSILON4;\n      }\n      dot = Cartesian3.dot(direction, negativeRotationAxis);\n      angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle < 0 && -angle > angleToAxis) {\n        angle = -angleToAxis + CesiumMath.EPSILON4;\n      }\n      const tangent = Cartesian3.cross(rotationAxis, direction, look3DTan);\n      camera.look(tangent, angle);\n    } else if (northParallel && angle < 0 || southParallel && angle > 0) {\n      camera.look(camera.right, -angle);\n    }\n  } else {\n    camera.lookUp(angle);\n  }\n}\nfunction update3D(controller) {\n  reactToInput(controller, controller.enableRotate, controller.rotateEventTypes, spin3D, controller.inertiaSpin, \"_lastInertiaSpinMovement\");\n  reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoom3D, controller.inertiaZoom, \"_lastInertiaZoomMovement\");\n  reactToInput(controller, controller.enableTilt, controller.tiltEventTypes, tilt3D, controller.inertiaSpin, \"_lastInertiaTiltMovement\");\n  reactToInput(controller, controller.enableLook, controller.lookEventTypes, look3D);\n}\nconst scratchAdjustHeightTransform = new Matrix4();\nconst scratchAdjustHeightCartographic = new Cartographic();\nfunction adjustHeightForTerrain(controller, cameraChanged) {\n  controller._adjustedHeightForTerrain = true;\n  const scene = controller._scene;\n  const mode = scene.mode;\n  if (mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {\n    return;\n  }\n  const camera = scene.camera;\n  const ellipsoid = scene.ellipsoid ?? Ellipsoid.WGS84;\n  const projection = scene.mapProjection;\n  let transform;\n  let mag;\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    transform = Matrix4.clone(camera.transform, scratchAdjustHeightTransform);\n    mag = Cartesian3.magnitude(camera.position);\n    camera._setTransform(Matrix4.IDENTITY);\n  }\n  const cartographic = scratchAdjustHeightCartographic;\n  if (mode === SceneMode.SCENE3D) {\n    ellipsoid.cartesianToCartographic(camera.position, cartographic);\n  } else {\n    projection.unproject(camera.position, cartographic);\n  }\n  let heightUpdated = false;\n  if (cartographic.height < controller._minimumCollisionTerrainHeight) {\n    const globeHeight = controller._scene.globeHeight;\n    if (defined(globeHeight)) {\n      const height = globeHeight + controller.minimumZoomDistance;\n      const difference = globeHeight - controller._lastGlobeHeight;\n      const percentDifference = difference / controller._lastGlobeHeight;\n\n      // Unless the camera has been moved by user input, to avoid big jumps during tile loads\n      // only make height updates when the globe height has been fairly stable across several frames\n      if (cartographic.height < height && (cameraChanged || Math.abs(percentDifference) <= 0.1)) {\n        cartographic.height = height;\n        if (mode === SceneMode.SCENE3D) {\n          ellipsoid.cartographicToCartesian(cartographic, camera.position);\n        } else {\n          projection.project(cartographic, camera.position);\n        }\n        heightUpdated = true;\n      }\n      if (cameraChanged || Math.abs(percentDifference) <= 0.1) {\n        controller._lastGlobeHeight = globeHeight;\n      } else {\n        controller._lastGlobeHeight += difference * 0.1;\n      }\n    }\n  }\n  if (defined(transform)) {\n    camera._setTransform(transform);\n    if (heightUpdated) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.negate(camera.position, camera.direction);\n      Cartesian3.multiplyByScalar(camera.position, Math.max(mag, controller.minimumZoomDistance), camera.position);\n      Cartesian3.normalize(camera.direction, camera.direction);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.cross(camera.right, camera.direction, camera.up);\n    }\n  }\n}\n\n/**\n * @private\n */\nScreenSpaceCameraController.prototype.onMap = function () {\n  const scene = this._scene;\n  const mode = scene.mode;\n  const camera = scene.camera;\n  if (mode === SceneMode.COLUMBUS_VIEW) {\n    return Math.abs(camera.position.x) - this._maxCoord.x < 0 && Math.abs(camera.position.y) - this._maxCoord.y < 0;\n  }\n  return true;\n};\nconst scratchPreviousPosition = new Cartesian3();\nconst scratchPreviousDirection = new Cartesian3();\n\n/**\n * @private\n */\nScreenSpaceCameraController.prototype.update = function () {\n  const scene = this._scene;\n  const {\n    camera,\n    globe,\n    mode\n  } = scene;\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    this._globe = undefined;\n    this._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  } else {\n    this._globe = globe;\n    this._ellipsoid = scene.ellipsoid ?? Ellipsoid.default;\n  }\n  const {\n    verticalExaggeration,\n    verticalExaggerationRelativeHeight\n  } = scene;\n  this._minimumCollisionTerrainHeight = VerticalExaggeration.getHeight(this.minimumCollisionTerrainHeight, verticalExaggeration, verticalExaggerationRelativeHeight);\n  this._minimumPickingTerrainHeight = VerticalExaggeration.getHeight(this.minimumPickingTerrainHeight, verticalExaggeration, verticalExaggerationRelativeHeight);\n  this._minimumTrackBallHeight = VerticalExaggeration.getHeight(this.minimumTrackBallHeight, verticalExaggeration, verticalExaggerationRelativeHeight);\n  this._cameraUnderground = scene.cameraUnderground && defined(this._globe);\n  const radius = this._ellipsoid.maximumRadius;\n  this._rotateFactor = 1.0 / radius;\n  this._rotateRateRangeAdjustment = radius;\n  this._adjustedHeightForTerrain = false;\n  const previousPosition = Cartesian3.clone(camera.positionWC, scratchPreviousPosition);\n  const previousDirection = Cartesian3.clone(camera.directionWC, scratchPreviousDirection);\n  if (mode === SceneMode.SCENE2D) {\n    update2D(this);\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    this._horizontalRotationAxis = Cartesian3.UNIT_Z;\n    updateCV(this);\n  } else if (mode === SceneMode.SCENE3D) {\n    this._horizontalRotationAxis = undefined;\n    update3D(this);\n  }\n  if (this.enableCollisionDetection && !this._adjustedHeightForTerrain) {\n    // Adjust the camera height if the camera moved at all (user input or inertia) and an action didn't already adjust the camera height\n    const cameraChanged = !Cartesian3.equals(previousPosition, camera.positionWC) || !Cartesian3.equals(previousDirection, camera.directionWC);\n    adjustHeightForTerrain(this, cameraChanged);\n  }\n  this._aggregator.reset();\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ScreenSpaceCameraController#destroy\n */\nScreenSpaceCameraController.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes mouse listeners held by this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * controller = controller && controller.destroy();\n *\n * @see ScreenSpaceCameraController#isDestroyed\n */\nScreenSpaceCameraController.prototype.destroy = function () {\n  this._tweens.removeAll();\n  this._aggregator = this._aggregator && this._aggregator.destroy();\n  return destroyObject(this);\n};\nexport default ScreenSpaceCameraController;","map":{"version":3,"names":["Cartesian2","Cartesian3","Cartesian4","Cartographic","defined","destroyObject","DeveloperError","Ellipsoid","HeadingPitchRoll","IntersectionTests","KeyboardEventModifier","CesiumMath","Matrix3","Matrix4","OrthographicFrustum","Plane","Quaternion","Ray","VerticalExaggeration","Transforms","CameraEventAggregator","CameraEventType","MapMode2D","SceneMode","SceneTransforms","TweenCollection","ScreenSpaceCameraController","scene","enableInputs","enableTranslate","enableZoom","enableRotate","enableTilt","enableLook","inertiaSpin","inertiaTranslate","inertiaZoom","maximumMovementRatio","bounceAnimationTime","minimumZoomDistance","maximumZoomDistance","Number","POSITIVE_INFINITY","zoomFactor","translateEventTypes","LEFT_DRAG","zoomEventTypes","RIGHT_DRAG","WHEEL","PINCH","rotateEventTypes","tiltEventTypes","MIDDLE_DRAG","eventType","modifier","CTRL","lookEventTypes","SHIFT","ellipsoid","default","minimumPickingTerrainHeight","WGS84","equals","minimumRadius","_minimumPickingTerrainHeight","minimumPickingTerrainDistanceWithInertia","minimumCollisionTerrainHeight","_minimumCollisionTerrainHeight","minimumTrackBallHeight","_minimumTrackBallHeight","enableCollisionDetection","maximumTiltAngle","undefined","_scene","_globe","_ellipsoid","_lastGlobeHeight","_aggregator","canvas","_lastInertiaSpinMovement","_lastInertiaZoomMovement","_lastInertiaTranslateMovement","_lastInertiaTiltMovement","_inertiaDisablers","_tweens","_tween","_horizontalRotationAxis","_tiltCenterMousePosition","_tiltCenter","_rotateMousePosition","_rotateStartPosition","_strafeStartPosition","_strafeMousePosition","_strafeEndMousePosition","_zoomMouseStart","_zoomWorldPosition","_useZoomWorldPosition","_panLastMousePosition","_panLastWorldPosition","_tiltCVOffMap","_looking","_rotating","_strafing","_zoomingOnVector","_zoomingUnderground","_rotatingZoom","_adjustedHeightForTerrain","_cameraUnderground","projection","mapProjection","_maxCoord","project","Math","PI","PI_OVER_TWO","_rotateFactor","_rotateRateRangeAdjustment","_maximumRotateRate","_minimumRotateRate","_minimumZoomRate","_maximumZoomRate","_minimumUndergroundPickDistance","_maximumUndergroundPickDistance","decay","time","coefficient","tau","exp","sameMousePosition","movement","equalsEpsilon","startPosition","endPosition","EPSILON14","inertiaMaxClickTimeThreshold","maintainInertia","aggregator","type","decayCoef","action","object","lastMovementName","movementState","motion","inertiaEnabled","ts","getButtonPressTime","tr","getButtonReleaseTime","threshold","getTime","now","Date","fromNow","d","lastMovement","getLastMovement","x","y","clone","multiplyByScalar","add","isNaN","distance","isButtonDown","getStartMousePosition","activateInertia","controller","inertiaStateName","inertiasToDisable","length","i","scratchEventTypeArray","reactToInput","enabled","eventTypes","inertiaConstant","Array","isArray","isMoving","getMovement","scratchZoomPickRay","scratchPickCartesian","scratchZoomOffset","scratchZoomDirection","scratchCenterPixel","scratchCenterPosition","scratchPositionNormal","scratchPickNormal","scratchZoomAxis","scratchCameraPositionNormal","scratchTargetNormal","scratchCameraPosition","scratchCameraUpNormal","scratchCameraRightNormal","scratchForwardNormal","scratchPositionToTarget","scratchPositionToTargetNormal","scratchPan","scratchCenterMovement","scratchCenter","scratchCartesian","scratchCartesianTwo","scratchCartesianThree","scratchZoomViewOptions","orientation","handleZoom","distanceMeasure","unitPositionDotDirection","percentage","clamp","abs","diff","approachingSurface","minHeight","maxHeight","minDistance","zoomRate","rangeWindowRatio","clientHeight","min","camera","mode","heading","pitch","roll","sameStartPosition","zoomingOnVector","rotatingZoom","pickedPosition","SCENE2D","getPickRay","origin","fromElements","z","pickPosition","zoomIn","zoomOnVector","COLUMBUS_VIEW","positionCartographic","height","worldPosition","position","savedX","direction","subtract","normalize","getMagnitude","move","SCENE3D","cameraPositionNormal","dot","centerPixel","clientWidth","centerPosition","cameraPosition","target","targetNormal","center","forward","positionToTarget","positionToTargetNormal","alphaDot","alpha","acos","cameraDistance","magnitude","targetDistance","remainingDistance","positionToTargetDistance","gamma","asin","sin","delta","beta","up","right","cross","pMid","cos","cMid","setView","positionNormal","pickedNormal","dotProduct","angle","acosClamped","axis","denom","toRadians","scalar","rotate","ray","zoomMouseStart","worldToWindowCoordinates","rayDirection","translate2DStart","translate2DEnd","scratchTranslateP0","translate2D","start","end","zoom2D","twist2DStart","twist2DEnd","twist2D","angleAndHeight","singleAxisTwist2D","width","startTheta","TWO_PI","endTheta","theta","twistRight","rotateRate","phiWindowRatio","deltaPhi","update2D","rotatable2D","mapMode2D","ROTATE","IDENTITY","transform","pickGlobeScratchRay","scratchDepthIntersection","scratchRayIntersection","mousePosition","result","globe","depthIntersection","pickPositionSupported","pickPositionWorldCoordinates","cullBackFaces","rayIntersection","pickWorldCoordinates","pickDistance","positionWC","rayDistance","scratchDistanceCartographic","getDistanceFromSurface","cartographic","cartesianToCartographic","globeHeight","distanceFromSurface","scratchSurfaceNormal","getZoomDistanceUnderground","surfaceNormal","strength","max","getTiltCenterUnderground","maximumDistance","getPoint","getStrafeStartPositionUnderground","scratchInertialDelta","continueStrafing","originalEndPosition","inertialDelta","strafe","translateCVStartRay","translateCVEndRay","translateCVStartPos","translateCVEndPos","translateCVDifference","translateCVOrigin","translateCVPlane","UNIT_X","translateCVStartMouse","translateCVEndMouse","translateCV","_translateMousePosition","look3D","cameraUnderground","startMouse","endMouse","startRay","ZERO","normal","globePos","plane","fromPointNormal","startPlanePos","rayPlane","endRay","endPlanePos","temp","mag","EPSILON6","rotateCVWindowPos","rotateCVWindowRay","rotateCVCenter","rotateCVVerticalCenter","rotateCVTransform","rotateCVVerticalTransform","rotateCVOrigin","rotateCVPlane","rotateCVCartesian3","rotateCVCart","rotateCVOldTransform","rotateCVQuaternion","rotateCVMatrix","tilt3DCartesian3","rotateCV","onMap","rotateCVOnPlane","rotateCVOnTerrain","windowPosition","normalDotDirection","cart","unproject","cartographicToCartesian","eastNorthUpToFixedFrame","oldGlobe","oldEllipsoid","UNIT_SPHERE","oldTransform","_setTransform","rotate3D","UNIT_Z","radius","maximumRadius","verticalCenter","_projection","verticalTransform","constrainedAxis","tangent","movementDelta","oldConstrainedAxis","negate","originalPosition","adjustHeightForTerrain","worldToCameraCoordinatesPoint","magSqrd","magnitudeSquared","sqrt","angleBetween","quaternion","fromAxisAngle","rotation","fromQuaternion","multiplyByVector","zoomCVWindowPos","zoomCVWindowRay","zoomCVIntersection","zoomCV","intersection","distanceUnderground","updateCV","zoom3D","tweens","anyButtonDown","removeAll","contains","tween","createCorrectPositionTween","update","scratchStrafeRay","scratchStrafePlane","scratchStrafeIntersection","scratchStrafeDirection","strafeStartPosition","spin3DPick","scratchCartographic","scratchRadii","scratchEllipsoid","scratchLookUp","scratchNormal","scratchMousePosition","spin3D","radii","geodeticSurfaceNormal","fromCartesian3","pan3D","mousePos","strafing","tangentPick","pickEllipsoid","rotateOnlyVertical","rotateOnlyHorizontal","oldAxis","rho","thetaWindowRatio","deltaTheta","tilt","rotateRight","rotateUp","pan3DP0","UNIT_W","pan3DP1","pan3DTemp0","pan3DTemp1","pan3DTemp2","pan3DTemp3","pan3DStartMousePosition","pan3DEndMousePosition","pan3DDiffMousePosition","pan3DPixelDimensions","panRay","startMousePosition","endMousePosition","p0","p1","toCenter","toCenterProj","directionWC","distanceToNearPlane","pixelDimensions","frustum","getPixelDimensions","drawingBufferWidth","drawingBufferHeight","pixelRatio","dragDelta","rightWC","endPickDirection","endPickProj","projectVector","fov","tan","upWC","worldToCameraCoordinates","basis0","basis1","mostOrthogonalAxis","basis2","startRho","startDot","startRej","endRho","endDot","endRej","startPhi","endPhi","east","EPSILON2","planeNormal","side0","side1","zoom3DUnitPosition","zoom3DCartographic","preIntersectionDistance","inertiaMovement","approachingCollision","needPickGlobe","unitPosition","tilt3DWindowPos","tilt3DRay","tilt3DCenter","tilt3DVerticalCenter","tilt3DTransform","tilt3DVerticalTransform","tilt3DOldTransform","tilt3DQuaternion","tilt3DMatrix","tilt3DCart","tilt3DLookUp","tilt3D","_tiltOnEllipsoid","tilt3DOnEllipsoid","tilt3DOnTerrain","tilt3DOnEllipsoidCartographic","EPSILON3","rayEllipsoid","grazingAltitudeLocation","grazingAltitudeCart","newEllipsoid","t","stop","look3DStartPos","look3DEndPos","look3DStartRay","look3DEndRay","look3DNegativeRot","look3DTan","rotationAxis","startPos","endPos","horizontalRotationAxis","look","lookLeft","negativeRotationAxis","northParallel","southParallel","angleToAxis","EPSILON4","lookUp","update3D","scratchAdjustHeightTransform","scratchAdjustHeightCartographic","cameraChanged","MORPHING","heightUpdated","difference","percentDifference","prototype","scratchPreviousPosition","scratchPreviousDirection","verticalExaggeration","verticalExaggerationRelativeHeight","getHeight","previousPosition","previousDirection","reset","isDestroyed","destroy"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/ScreenSpaceCameraController.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport KeyboardEventModifier from \"../Core/KeyboardEventModifier.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport Plane from \"../Core/Plane.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Ray from \"../Core/Ray.js\";\nimport VerticalExaggeration from \"../Core/VerticalExaggeration.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport CameraEventAggregator from \"./CameraEventAggregator.js\";\nimport CameraEventType from \"./CameraEventType.js\";\nimport MapMode2D from \"./MapMode2D.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SceneTransforms from \"./SceneTransforms.js\";\nimport TweenCollection from \"./TweenCollection.js\";\n\n/**\n * Modifies the camera position and orientation based on mouse input to a canvas.\n * @alias ScreenSpaceCameraController\n * @constructor\n *\n * @param {Scene} scene The scene.\n */\nfunction ScreenSpaceCameraController(scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * If true, inputs are allowed conditionally with the flags enableTranslate, enableZoom,\n   * enableRotate, enableTilt, and enableLook.  If false, all inputs are disabled.\n   *\n   * NOTE: This setting is for temporary use cases, such as camera flights and\n   * drag-selection of regions (see Picking demo).  It is typically set to false at the\n   * start of such events, and set true on completion.  To keep inputs disabled\n   * past the end of camera flights, you must use the other booleans (enableTranslate,\n   * enableZoom, enableRotate, enableTilt, and enableLook).\n   * @type {boolean}\n   * @default true\n   */\n  this.enableInputs = true;\n  /**\n   * If true, allows the user to pan around the map.  If false, the camera stays locked at the current position.\n   * This flag only applies in 2D and Columbus view modes.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableTranslate = true;\n  /**\n   * If true, allows the user to zoom in and out.  If false, the camera is locked to the current distance from the ellipsoid.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableZoom = true;\n  /**\n   * If true, allows the user to rotate the world which translates the user's position.\n   * This flag only applies in 2D and 3D.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableRotate = true;\n  /**\n   * If true, allows the user to tilt the camera.  If false, the camera is locked to the current heading.\n   * This flag only applies in 3D and Columbus view.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableTilt = true;\n  /**\n   * If true, allows the user to use free-look. If false, the camera view direction can only be changed through translating\n   * or rotating. This flag only applies in 3D and Columbus view modes.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableLook = true;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to spin because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {number}\n   * @default 0.9\n   */\n  this.inertiaSpin = 0.9;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to translate because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {number}\n   * @default 0.9\n   */\n  this.inertiaTranslate = 0.9;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to zoom because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {number}\n   * @default 0.8\n   */\n  this.inertiaZoom = 0.8;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to limit the range\n   * of various user inputs to a percentage of the window width/height per animation frame.\n   * This helps keep the camera under control in low-frame-rate situations.\n   * @type {number}\n   * @default 0.1\n   */\n  this.maximumMovementRatio = 0.1;\n  /**\n   * Sets the duration, in seconds, of the bounce back animations in 2D and Columbus view.\n   * @type {number}\n   * @default 3.0\n   */\n  this.bounceAnimationTime = 3.0;\n  /**\n   * The minimum magnitude, in meters, of the camera position when zooming. Defaults to 1.0.\n   * @type {number}\n   * @default 1.0\n   */\n  this.minimumZoomDistance = 1.0;\n  /**\n   * The maximum magnitude, in meters, of the camera position when zooming. Defaults to positive infinity.\n   * @type {number}\n   * @default {@link Number.POSITIVE_INFINITY}\n   */\n  this.maximumZoomDistance = Number.POSITIVE_INFINITY;\n\n  /**\n   * A multiplier for the speed at which the camera will zoom.\n   * @type {Number}\n   * @default 5.0\n   */\n  this.zoomFactor = 5.0;\n\n  /**\n   * The input that allows the user to pan around the map. This only applies in 2D and Columbus view modes.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default {@link CameraEventType.LEFT_DRAG}\n   */\n  this.translateEventTypes = CameraEventType.LEFT_DRAG;\n  /**\n   * The input that allows the user to zoom in/out.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default [{@link CameraEventType.RIGHT_DRAG}, {@link CameraEventType.WHEEL}, {@link CameraEventType.PINCH}]\n   */\n  this.zoomEventTypes = [\n    CameraEventType.RIGHT_DRAG,\n    CameraEventType.WHEEL,\n    CameraEventType.PINCH,\n  ];\n  /**\n   * The input that allows the user to rotate around the globe or another object. This only applies in 3D and Columbus view modes.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default {@link CameraEventType.LEFT_DRAG}\n   */\n  this.rotateEventTypes = CameraEventType.LEFT_DRAG;\n  /**\n   * The input that allows the user to tilt in 3D and Columbus view or twist in 2D.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default [{@link CameraEventType.MIDDLE_DRAG}, {@link CameraEventType.PINCH}, {\n   *     eventType : {@link CameraEventType.LEFT_DRAG},\n   *     modifier : {@link KeyboardEventModifier.CTRL}\n   * }, {\n   *     eventType : {@link CameraEventType.RIGHT_DRAG},\n   *     modifier : {@link KeyboardEventModifier.CTRL}\n   * }]\n   */\n  this.tiltEventTypes = [\n    CameraEventType.MIDDLE_DRAG,\n    CameraEventType.PINCH,\n    {\n      eventType: CameraEventType.LEFT_DRAG,\n      modifier: KeyboardEventModifier.CTRL,\n    },\n    {\n      eventType: CameraEventType.RIGHT_DRAG,\n      modifier: KeyboardEventModifier.CTRL,\n    },\n  ];\n  /**\n   * The input that allows the user to change the direction the camera is viewing. This only applies in 3D and Columbus view modes.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default { eventType : {@link CameraEventType.LEFT_DRAG}, modifier : {@link KeyboardEventModifier.SHIFT} }\n   */\n  this.lookEventTypes = {\n    eventType: CameraEventType.LEFT_DRAG,\n    modifier: KeyboardEventModifier.SHIFT,\n  };\n\n  const ellipsoid = scene.ellipsoid ?? Ellipsoid.default;\n\n  /**\n   * The minimum height the camera must be before picking the terrain or scene content instead of the ellipsoid. Defaults to scene.ellipsoid.minimumRadius * 0.025 when another ellipsoid than WGS84 is used.\n   * @type {number}\n   * @default 150000.0 or scene.ellipsoid.minimumRadius * 0.025\n   */\n  this.minimumPickingTerrainHeight = Ellipsoid.WGS84.equals(ellipsoid)\n    ? 150000.0\n    : ellipsoid.minimumRadius * 0.025;\n  this._minimumPickingTerrainHeight = this.minimumPickingTerrainHeight;\n  /**\n   * The minimum distance the camera must be before testing for collision with terrain when zoom with inertia. Default to scene.ellipsoid.minimumRadius * 0.00063 when another ellipsoid than WGS84 is used.\n   * @type {number}\n   * @default 4000.0 or scene.ellipsoid.minimumRadius * 0.00063\n   */\n  this.minimumPickingTerrainDistanceWithInertia = Ellipsoid.WGS84.equals(\n    ellipsoid,\n  )\n    ? 4000.0\n    : ellipsoid.minimumRadius * 0.00063;\n  /**\n   * The minimum height the camera must be before testing for collision with terrain. Default to scene.ellipsoid.minimumRadius * 0.0025 when another ellipsoid than WGS84 is used.\n   * @type {number}\n   * @default 15000.0 or scene.ellipsoid.minimumRadius * 0.0025.\n   */\n  this.minimumCollisionTerrainHeight = Ellipsoid.WGS84.equals(ellipsoid)\n    ? 15000.0\n    : ellipsoid.minimumRadius * 0.0025;\n  this._minimumCollisionTerrainHeight = this.minimumCollisionTerrainHeight;\n  /**\n   * The minimum height the camera must be before switching from rotating a track ball to\n   * free look when clicks originate on the sky or in space. Defaults to ellipsoid.minimumRadius * 1.175 when another ellipsoid than WGS84 is used.\n   * @type {number}\n   * @default 7500000.0 or scene.ellipsoid.minimumRadius * 1.175\n   */\n  this.minimumTrackBallHeight = Ellipsoid.WGS84.equals(ellipsoid)\n    ? 7500000.0\n    : ellipsoid.minimumRadius * 1.175;\n  this._minimumTrackBallHeight = this.minimumTrackBallHeight;\n  /**\n   * When disabled, the values of <code>maximumZoomDistance</code> and <code>minimumZoomDistance</code> are ignored.\n   * Also used in conjunction with {@link Cesium3DTileset#enableCollision} to prevent the camera from moving through or below a 3D Tileset surface.\n   * This may also affect clamping behavior when using {@link HeightReference.CLAMP_TO_GROUND} on 3D Tiles.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableCollisionDetection = true;\n  /**\n   * The angle, relative to the ellipsoid normal, restricting the maximum amount that the user can tilt the camera. If <code>undefined</code>, the angle of the camera tilt is unrestricted.\n   * @type {number|undefined}\n   * @default undefined\n   *\n   * @example\n   * // Prevent the camera from tilting below the ellipsoid surface\n   * viewer.scene.screenSpaceCameraController.maximumTiltAngle = Math.PI / 2.0;\n   */\n  this.maximumTiltAngle = undefined;\n\n  this._scene = scene;\n  this._globe = undefined;\n  this._ellipsoid = ellipsoid;\n\n  this._lastGlobeHeight = 0.0;\n\n  this._aggregator = new CameraEventAggregator(scene.canvas);\n\n  this._lastInertiaSpinMovement = undefined;\n  this._lastInertiaZoomMovement = undefined;\n  this._lastInertiaTranslateMovement = undefined;\n  this._lastInertiaTiltMovement = undefined;\n\n  // Zoom disables tilt, spin, and translate inertia\n  // Tilt disables spin and translate inertia\n  this._inertiaDisablers = {\n    _lastInertiaZoomMovement: [\n      \"_lastInertiaSpinMovement\",\n      \"_lastInertiaTranslateMovement\",\n      \"_lastInertiaTiltMovement\",\n    ],\n    _lastInertiaTiltMovement: [\n      \"_lastInertiaSpinMovement\",\n      \"_lastInertiaTranslateMovement\",\n    ],\n  };\n\n  this._tweens = new TweenCollection();\n  this._tween = undefined;\n\n  this._horizontalRotationAxis = undefined;\n\n  this._tiltCenterMousePosition = new Cartesian2(-1.0, -1.0);\n  this._tiltCenter = new Cartesian3();\n  this._rotateMousePosition = new Cartesian2(-1.0, -1.0);\n  this._rotateStartPosition = new Cartesian3();\n  this._strafeStartPosition = new Cartesian3();\n  this._strafeMousePosition = new Cartesian2();\n  this._strafeEndMousePosition = new Cartesian2();\n  this._zoomMouseStart = new Cartesian2(-1.0, -1.0);\n  this._zoomWorldPosition = new Cartesian3();\n  this._useZoomWorldPosition = false;\n  this._panLastMousePosition = new Cartesian2();\n  this._panLastWorldPosition = new Cartesian3();\n  this._tiltCVOffMap = false;\n  this._looking = false;\n  this._rotating = false;\n  this._strafing = false;\n  this._zoomingOnVector = false;\n  this._zoomingUnderground = false;\n  this._rotatingZoom = false;\n  this._adjustedHeightForTerrain = false;\n  this._cameraUnderground = false;\n\n  const projection = scene.mapProjection;\n  this._maxCoord = projection.project(\n    new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO),\n  );\n\n  // Constants, Make any of these public?\n  this._rotateFactor = undefined;\n  this._rotateRateRangeAdjustment = undefined;\n  this._maximumRotateRate = 1.77;\n  this._minimumRotateRate = 1.0 / 5000.0;\n  this._minimumZoomRate = 20.0;\n  this._maximumZoomRate = 5906376272000.0; // distance from the Sun to Pluto in meters.\n  this._minimumUndergroundPickDistance = 2000.0;\n  this._maximumUndergroundPickDistance = 10000.0;\n}\n\nfunction decay(time, coefficient) {\n  if (time < 0) {\n    return 0.0;\n  }\n\n  const tau = (1.0 - coefficient) * 25.0;\n  return Math.exp(-tau * time);\n}\n\nfunction sameMousePosition(movement) {\n  return Cartesian2.equalsEpsilon(\n    movement.startPosition,\n    movement.endPosition,\n    CesiumMath.EPSILON14,\n  );\n}\n\n// If the time between mouse down and mouse up is not between\n// these thresholds, the camera will not move with inertia.\n// This value is probably dependent on the browser and/or the\n// hardware. Should be investigated further.\nconst inertiaMaxClickTimeThreshold = 0.4;\n\nfunction maintainInertia(\n  aggregator,\n  type,\n  modifier,\n  decayCoef,\n  action,\n  object,\n  lastMovementName,\n) {\n  let movementState = object[lastMovementName];\n  if (!defined(movementState)) {\n    movementState = object[lastMovementName] = {\n      startPosition: new Cartesian2(),\n      endPosition: new Cartesian2(),\n      motion: new Cartesian2(),\n      inertiaEnabled: true,\n    };\n  }\n\n  const ts = aggregator.getButtonPressTime(type, modifier);\n  const tr = aggregator.getButtonReleaseTime(type, modifier);\n\n  const threshold = ts && tr && (tr.getTime() - ts.getTime()) / 1000.0;\n  const now = new Date();\n  const fromNow = tr && (now.getTime() - tr.getTime()) / 1000.0;\n\n  if (ts && tr && threshold < inertiaMaxClickTimeThreshold) {\n    const d = decay(fromNow, decayCoef);\n\n    const lastMovement = aggregator.getLastMovement(type, modifier);\n    if (\n      !defined(lastMovement) ||\n      sameMousePosition(lastMovement) ||\n      !movementState.inertiaEnabled\n    ) {\n      return;\n    }\n\n    movementState.motion.x =\n      (lastMovement.endPosition.x - lastMovement.startPosition.x) * 0.5;\n    movementState.motion.y =\n      (lastMovement.endPosition.y - lastMovement.startPosition.y) * 0.5;\n\n    movementState.startPosition = Cartesian2.clone(\n      lastMovement.startPosition,\n      movementState.startPosition,\n    );\n\n    movementState.endPosition = Cartesian2.multiplyByScalar(\n      movementState.motion,\n      d,\n      movementState.endPosition,\n    );\n    movementState.endPosition = Cartesian2.add(\n      movementState.startPosition,\n      movementState.endPosition,\n      movementState.endPosition,\n    );\n\n    // If value from the decreasing exponential function is close to zero,\n    // the end coordinates may be NaN.\n    if (\n      isNaN(movementState.endPosition.x) ||\n      isNaN(movementState.endPosition.y) ||\n      Cartesian2.distance(\n        movementState.startPosition,\n        movementState.endPosition,\n      ) < 0.5\n    ) {\n      return;\n    }\n\n    if (!aggregator.isButtonDown(type, modifier)) {\n      const startPosition = aggregator.getStartMousePosition(type, modifier);\n      action(object, startPosition, movementState);\n    }\n  }\n}\n\nfunction activateInertia(controller, inertiaStateName) {\n  if (defined(inertiaStateName)) {\n    // Re-enable inertia if it was disabled\n    let movementState = controller[inertiaStateName];\n    if (defined(movementState)) {\n      movementState.inertiaEnabled = true;\n    }\n    // Disable inertia on other movements\n    const inertiasToDisable = controller._inertiaDisablers[inertiaStateName];\n    if (defined(inertiasToDisable)) {\n      const length = inertiasToDisable.length;\n      for (let i = 0; i < length; ++i) {\n        movementState = controller[inertiasToDisable[i]];\n        if (defined(movementState)) {\n          movementState.inertiaEnabled = false;\n        }\n      }\n    }\n  }\n}\n\nconst scratchEventTypeArray = [];\n\nfunction reactToInput(\n  controller,\n  enabled,\n  eventTypes,\n  action,\n  inertiaConstant,\n  inertiaStateName,\n) {\n  if (!defined(eventTypes)) {\n    return;\n  }\n\n  const aggregator = controller._aggregator;\n\n  if (!Array.isArray(eventTypes)) {\n    scratchEventTypeArray[0] = eventTypes;\n    eventTypes = scratchEventTypeArray;\n  }\n\n  const length = eventTypes.length;\n  for (let i = 0; i < length; ++i) {\n    const eventType = eventTypes[i];\n    const type = defined(eventType.eventType) ? eventType.eventType : eventType;\n    const modifier = eventType.modifier;\n\n    const movement =\n      aggregator.isMoving(type, modifier) &&\n      aggregator.getMovement(type, modifier);\n    const startPosition = aggregator.getStartMousePosition(type, modifier);\n\n    if (controller.enableInputs && enabled) {\n      if (movement) {\n        action(controller, startPosition, movement);\n        activateInertia(controller, inertiaStateName);\n      } else if (inertiaConstant < 1.0) {\n        maintainInertia(\n          aggregator,\n          type,\n          modifier,\n          inertiaConstant,\n          action,\n          controller,\n          inertiaStateName,\n        );\n      }\n    }\n  }\n}\n\nconst scratchZoomPickRay = new Ray();\nconst scratchPickCartesian = new Cartesian3();\nconst scratchZoomOffset = new Cartesian2();\nconst scratchZoomDirection = new Cartesian3();\nconst scratchCenterPixel = new Cartesian2();\nconst scratchCenterPosition = new Cartesian3();\nconst scratchPositionNormal = new Cartesian3();\nconst scratchPickNormal = new Cartesian3();\nconst scratchZoomAxis = new Cartesian3();\nconst scratchCameraPositionNormal = new Cartesian3();\n\n// Scratch variables used in zooming algorithm\nconst scratchTargetNormal = new Cartesian3();\nconst scratchCameraPosition = new Cartesian3();\nconst scratchCameraUpNormal = new Cartesian3();\nconst scratchCameraRightNormal = new Cartesian3();\nconst scratchForwardNormal = new Cartesian3();\nconst scratchPositionToTarget = new Cartesian3();\nconst scratchPositionToTargetNormal = new Cartesian3();\nconst scratchPan = new Cartesian3();\nconst scratchCenterMovement = new Cartesian3();\nconst scratchCenter = new Cartesian3();\nconst scratchCartesian = new Cartesian3();\nconst scratchCartesianTwo = new Cartesian3();\nconst scratchCartesianThree = new Cartesian3();\nconst scratchZoomViewOptions = {\n  orientation: new HeadingPitchRoll(),\n};\n\nfunction handleZoom(\n  object,\n  startPosition,\n  movement,\n  zoomFactor,\n  distanceMeasure,\n  unitPositionDotDirection,\n) {\n  let percentage = 1.0;\n  if (defined(unitPositionDotDirection)) {\n    percentage = CesiumMath.clamp(\n      Math.abs(unitPositionDotDirection),\n      0.25,\n      1.0,\n    );\n  }\n\n  const diff = movement.endPosition.y - movement.startPosition.y;\n\n  // distanceMeasure should be the height above the ellipsoid.\n  // When approaching the surface, the zoomRate slows and stops minimumZoomDistance above it.\n  const approachingSurface = diff > 0;\n  const minHeight = approachingSurface\n    ? object.minimumZoomDistance * percentage\n    : 0;\n  const maxHeight = object.maximumZoomDistance;\n\n  const minDistance = distanceMeasure - minHeight;\n  let zoomRate = zoomFactor * minDistance;\n  zoomRate = CesiumMath.clamp(\n    zoomRate,\n    object._minimumZoomRate,\n    object._maximumZoomRate,\n  );\n\n  let rangeWindowRatio = diff / object._scene.canvas.clientHeight;\n  rangeWindowRatio = Math.min(rangeWindowRatio, object.maximumMovementRatio);\n  let distance = zoomRate * rangeWindowRatio;\n\n  if (\n    object.enableCollisionDetection ||\n    object.minimumZoomDistance === 0.0 ||\n    !defined(object._globe) // look-at mode\n  ) {\n    if (distance > 0.0 && Math.abs(distanceMeasure - minHeight) < 1.0) {\n      return;\n    }\n\n    if (distance < 0.0 && Math.abs(distanceMeasure - maxHeight) < 1.0) {\n      return;\n    }\n\n    if (distanceMeasure - distance < minHeight) {\n      distance = distanceMeasure - minHeight - 1.0;\n    } else if (distanceMeasure - distance > maxHeight) {\n      distance = distanceMeasure - maxHeight;\n    }\n  }\n\n  const scene = object._scene;\n  const camera = scene.camera;\n  const mode = scene.mode;\n\n  const orientation = scratchZoomViewOptions.orientation;\n  orientation.heading = camera.heading;\n  orientation.pitch = camera.pitch;\n  orientation.roll = camera.roll;\n\n  const sameStartPosition =\n    movement.inertiaEnabled ??\n    Cartesian2.equals(startPosition, object._zoomMouseStart);\n  let zoomingOnVector = object._zoomingOnVector;\n  let rotatingZoom = object._rotatingZoom;\n  let pickedPosition;\n\n  if (!sameStartPosition) {\n    object._zoomMouseStart = Cartesian2.clone(\n      startPosition,\n      object._zoomMouseStart,\n    );\n\n    // When camera transform is set, such as tracking an entity, object._globe will be undefined, and no position should be picked\n    if (defined(object._globe) && mode === SceneMode.SCENE2D) {\n      pickedPosition = camera.getPickRay(\n        startPosition,\n        scratchZoomPickRay,\n      ).origin;\n      pickedPosition = Cartesian3.fromElements(\n        pickedPosition.y,\n        pickedPosition.z,\n        pickedPosition.x,\n      );\n    } else if (defined(object._globe)) {\n      pickedPosition = pickPosition(\n        object,\n        startPosition,\n        scratchPickCartesian,\n      );\n    }\n\n    if (defined(pickedPosition)) {\n      object._useZoomWorldPosition = true;\n      object._zoomWorldPosition = Cartesian3.clone(\n        pickedPosition,\n        object._zoomWorldPosition,\n      );\n    } else {\n      object._useZoomWorldPosition = false;\n    }\n\n    zoomingOnVector = object._zoomingOnVector = false;\n    rotatingZoom = object._rotatingZoom = false;\n    object._zoomingUnderground = object._cameraUnderground;\n  }\n\n  if (!object._useZoomWorldPosition) {\n    camera.zoomIn(distance);\n    return;\n  }\n\n  let zoomOnVector = mode === SceneMode.COLUMBUS_VIEW;\n\n  if (camera.positionCartographic.height < 2000000) {\n    rotatingZoom = true;\n  }\n\n  if (!sameStartPosition || rotatingZoom) {\n    if (mode === SceneMode.SCENE2D) {\n      const worldPosition = object._zoomWorldPosition;\n      const endPosition = camera.position;\n\n      if (\n        !Cartesian3.equals(worldPosition, endPosition) &&\n        camera.positionCartographic.height < object._maxCoord.x * 2.0\n      ) {\n        const savedX = camera.position.x;\n\n        const direction = Cartesian3.subtract(\n          worldPosition,\n          endPosition,\n          scratchZoomDirection,\n        );\n        Cartesian3.normalize(direction, direction);\n\n        const d =\n          (Cartesian3.distance(worldPosition, endPosition) * distance) /\n          (camera.getMagnitude() * 0.5);\n        camera.move(direction, d * 0.5);\n\n        if (\n          (camera.position.x < 0.0 && savedX > 0.0) ||\n          (camera.position.x > 0.0 && savedX < 0.0)\n        ) {\n          pickedPosition = camera.getPickRay(\n            startPosition,\n            scratchZoomPickRay,\n          ).origin;\n          pickedPosition = Cartesian3.fromElements(\n            pickedPosition.y,\n            pickedPosition.z,\n            pickedPosition.x,\n          );\n          object._zoomWorldPosition = Cartesian3.clone(\n            pickedPosition,\n            object._zoomWorldPosition,\n          );\n        }\n      }\n    } else if (mode === SceneMode.SCENE3D) {\n      const cameraPositionNormal = Cartesian3.normalize(\n        camera.position,\n        scratchCameraPositionNormal,\n      );\n      if (\n        object._cameraUnderground ||\n        object._zoomingUnderground ||\n        (camera.positionCartographic.height < 3000.0 &&\n          Math.abs(Cartesian3.dot(camera.direction, cameraPositionNormal)) <\n            0.6)\n      ) {\n        zoomOnVector = true;\n      } else {\n        const canvas = scene.canvas;\n\n        const centerPixel = scratchCenterPixel;\n        centerPixel.x = canvas.clientWidth / 2;\n        centerPixel.y = canvas.clientHeight / 2;\n        const centerPosition = pickPosition(\n          object,\n          centerPixel,\n          scratchCenterPosition,\n        );\n        // If centerPosition is not defined, it means the globe does not cover the center position of screen\n\n        if (!defined(centerPosition)) {\n          zoomOnVector = true;\n        } else if (camera.positionCartographic.height < 1000000) {\n          // The math in the else block assumes the camera\n          // points toward the earth surface, so we check it here.\n          // Theoretically, we should check for 90 degree, but it doesn't behave well when parallel\n          // to the earth surface\n          if (Cartesian3.dot(camera.direction, cameraPositionNormal) >= -0.5) {\n            zoomOnVector = true;\n          } else {\n            const cameraPosition = scratchCameraPosition;\n            Cartesian3.clone(camera.position, cameraPosition);\n            const target = object._zoomWorldPosition;\n\n            let targetNormal = scratchTargetNormal;\n\n            targetNormal = Cartesian3.normalize(target, targetNormal);\n\n            if (Cartesian3.dot(targetNormal, cameraPositionNormal) < 0.0) {\n              return;\n            }\n\n            const center = scratchCenter;\n            const forward = scratchForwardNormal;\n            Cartesian3.clone(camera.direction, forward);\n            Cartesian3.add(\n              cameraPosition,\n              Cartesian3.multiplyByScalar(forward, 1000, scratchCartesian),\n              center,\n            );\n\n            const positionToTarget = scratchPositionToTarget;\n            const positionToTargetNormal = scratchPositionToTargetNormal;\n            Cartesian3.subtract(target, cameraPosition, positionToTarget);\n\n            Cartesian3.normalize(positionToTarget, positionToTargetNormal);\n\n            const alphaDot = Cartesian3.dot(\n              cameraPositionNormal,\n              positionToTargetNormal,\n            );\n            if (alphaDot >= 0.0) {\n              // We zoomed past the target, and this zoom is not valid anymore.\n              // This line causes the next zoom movement to pick a new starting point.\n              object._zoomMouseStart.x = -1;\n              return;\n            }\n            const alpha = Math.acos(-alphaDot);\n            const cameraDistance = Cartesian3.magnitude(cameraPosition);\n            const targetDistance = Cartesian3.magnitude(target);\n            const remainingDistance = cameraDistance - distance;\n            const positionToTargetDistance =\n              Cartesian3.magnitude(positionToTarget);\n\n            const gamma = Math.asin(\n              CesiumMath.clamp(\n                (positionToTargetDistance / targetDistance) * Math.sin(alpha),\n                -1.0,\n                1.0,\n              ),\n            );\n            const delta = Math.asin(\n              CesiumMath.clamp(\n                (remainingDistance / targetDistance) * Math.sin(alpha),\n                -1.0,\n                1.0,\n              ),\n            );\n            const beta = gamma - delta + alpha;\n\n            const up = scratchCameraUpNormal;\n            Cartesian3.normalize(cameraPosition, up);\n            let right = scratchCameraRightNormal;\n            right = Cartesian3.cross(positionToTargetNormal, up, right);\n            right = Cartesian3.normalize(right, right);\n\n            Cartesian3.normalize(\n              Cartesian3.cross(up, right, scratchCartesian),\n              forward,\n            );\n\n            // Calculate new position to move to\n            Cartesian3.multiplyByScalar(\n              Cartesian3.normalize(center, scratchCartesian),\n              Cartesian3.magnitude(center) - distance,\n              center,\n            );\n            Cartesian3.normalize(cameraPosition, cameraPosition);\n            Cartesian3.multiplyByScalar(\n              cameraPosition,\n              remainingDistance,\n              cameraPosition,\n            );\n\n            // Pan\n            const pMid = scratchPan;\n            Cartesian3.multiplyByScalar(\n              Cartesian3.add(\n                Cartesian3.multiplyByScalar(\n                  up,\n                  Math.cos(beta) - 1,\n                  scratchCartesianTwo,\n                ),\n                Cartesian3.multiplyByScalar(\n                  forward,\n                  Math.sin(beta),\n                  scratchCartesianThree,\n                ),\n                scratchCartesian,\n              ),\n              remainingDistance,\n              pMid,\n            );\n            Cartesian3.add(cameraPosition, pMid, cameraPosition);\n\n            Cartesian3.normalize(center, up);\n            Cartesian3.normalize(\n              Cartesian3.cross(up, right, scratchCartesian),\n              forward,\n            );\n\n            const cMid = scratchCenterMovement;\n            Cartesian3.multiplyByScalar(\n              Cartesian3.add(\n                Cartesian3.multiplyByScalar(\n                  up,\n                  Math.cos(beta) - 1,\n                  scratchCartesianTwo,\n                ),\n                Cartesian3.multiplyByScalar(\n                  forward,\n                  Math.sin(beta),\n                  scratchCartesianThree,\n                ),\n                scratchCartesian,\n              ),\n              Cartesian3.magnitude(center),\n              cMid,\n            );\n            Cartesian3.add(center, cMid, center);\n\n            // Update camera\n\n            // Set new position\n            Cartesian3.clone(cameraPosition, camera.position);\n\n            // Set new direction\n            Cartesian3.normalize(\n              Cartesian3.subtract(center, cameraPosition, scratchCartesian),\n              camera.direction,\n            );\n            Cartesian3.clone(camera.direction, camera.direction);\n\n            // Set new right & up vectors\n            Cartesian3.cross(camera.direction, camera.up, camera.right);\n            Cartesian3.cross(camera.right, camera.direction, camera.up);\n\n            camera.setView(scratchZoomViewOptions);\n            return;\n          }\n        } else {\n          const positionNormal = Cartesian3.normalize(\n            centerPosition,\n            scratchPositionNormal,\n          );\n          const pickedNormal = Cartesian3.normalize(\n            object._zoomWorldPosition,\n            scratchPickNormal,\n          );\n          const dotProduct = Cartesian3.dot(pickedNormal, positionNormal);\n\n          if (dotProduct > 0.0 && dotProduct < 1.0) {\n            const angle = CesiumMath.acosClamped(dotProduct);\n            const axis = Cartesian3.cross(\n              pickedNormal,\n              positionNormal,\n              scratchZoomAxis,\n            );\n\n            const denom =\n              Math.abs(angle) > CesiumMath.toRadians(20.0)\n                ? camera.positionCartographic.height * 0.75\n                : camera.positionCartographic.height - distance;\n            const scalar = distance / denom;\n            camera.rotate(axis, angle * scalar);\n          }\n        }\n      }\n    }\n\n    object._rotatingZoom = !zoomOnVector;\n  }\n\n  if ((!sameStartPosition && zoomOnVector) || zoomingOnVector) {\n    let ray;\n    const zoomMouseStart = SceneTransforms.worldToWindowCoordinates(\n      scene,\n      object._zoomWorldPosition,\n      scratchZoomOffset,\n    );\n    if (\n      mode !== SceneMode.COLUMBUS_VIEW &&\n      Cartesian2.equals(startPosition, object._zoomMouseStart) &&\n      defined(zoomMouseStart)\n    ) {\n      ray = camera.getPickRay(zoomMouseStart, scratchZoomPickRay);\n    } else {\n      ray = camera.getPickRay(startPosition, scratchZoomPickRay);\n    }\n\n    const rayDirection = ray.direction;\n    if (mode === SceneMode.COLUMBUS_VIEW || mode === SceneMode.SCENE2D) {\n      Cartesian3.fromElements(\n        rayDirection.y,\n        rayDirection.z,\n        rayDirection.x,\n        rayDirection,\n      );\n    }\n\n    camera.move(rayDirection, distance);\n\n    object._zoomingOnVector = true;\n  } else {\n    camera.zoomIn(distance);\n  }\n\n  if (!object._cameraUnderground) {\n    camera.setView(scratchZoomViewOptions);\n  }\n}\n\nconst translate2DStart = new Ray();\nconst translate2DEnd = new Ray();\nconst scratchTranslateP0 = new Cartesian3();\n\nfunction translate2D(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  let start = camera.getPickRay(\n    movement.startPosition,\n    translate2DStart,\n  ).origin;\n  let end = camera.getPickRay(movement.endPosition, translate2DEnd).origin;\n\n  start = Cartesian3.fromElements(start.y, start.z, start.x, start);\n  end = Cartesian3.fromElements(end.y, end.z, end.x, end);\n\n  const direction = Cartesian3.subtract(start, end, scratchTranslateP0);\n  const distance = Cartesian3.magnitude(direction);\n\n  if (distance > 0.0) {\n    Cartesian3.normalize(direction, direction);\n    camera.move(direction, distance);\n  }\n}\n\nfunction zoom2D(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  handleZoom(\n    controller,\n    startPosition,\n    movement,\n    controller.zoomFactor,\n    camera.getMagnitude(),\n  );\n}\n\nconst twist2DStart = new Cartesian2();\nconst twist2DEnd = new Cartesian2();\n\nfunction twist2D(controller, startPosition, movement) {\n  if (defined(movement.angleAndHeight)) {\n    singleAxisTwist2D(controller, startPosition, movement.angleAndHeight);\n    return;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n  const width = canvas.clientWidth;\n  const height = canvas.clientHeight;\n\n  let start = twist2DStart;\n  start.x = (2.0 / width) * movement.startPosition.x - 1.0;\n  start.y = (2.0 / height) * (height - movement.startPosition.y) - 1.0;\n  start = Cartesian2.normalize(start, start);\n\n  let end = twist2DEnd;\n  end.x = (2.0 / width) * movement.endPosition.x - 1.0;\n  end.y = (2.0 / height) * (height - movement.endPosition.y) - 1.0;\n  end = Cartesian2.normalize(end, end);\n\n  let startTheta = CesiumMath.acosClamped(start.x);\n  if (start.y < 0) {\n    startTheta = CesiumMath.TWO_PI - startTheta;\n  }\n  let endTheta = CesiumMath.acosClamped(end.x);\n  if (end.y < 0) {\n    endTheta = CesiumMath.TWO_PI - endTheta;\n  }\n  const theta = endTheta - startTheta;\n\n  camera.twistRight(theta);\n}\n\nfunction singleAxisTwist2D(controller, startPosition, movement) {\n  let rotateRate =\n    controller._rotateFactor * controller._rotateRateRangeAdjustment;\n\n  if (rotateRate > controller._maximumRotateRate) {\n    rotateRate = controller._maximumRotateRate;\n  }\n\n  if (rotateRate < controller._minimumRotateRate) {\n    rotateRate = controller._minimumRotateRate;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n\n  let phiWindowRatio =\n    (movement.endPosition.x - movement.startPosition.x) / canvas.clientWidth;\n  phiWindowRatio = Math.min(phiWindowRatio, controller.maximumMovementRatio);\n\n  const deltaPhi = rotateRate * phiWindowRatio * Math.PI * 4.0;\n\n  camera.twistRight(deltaPhi);\n}\n\nfunction update2D(controller) {\n  const rotatable2D = controller._scene.mapMode2D === MapMode2D.ROTATE;\n  if (!Matrix4.equals(Matrix4.IDENTITY, controller._scene.camera.transform)) {\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoom2D,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\",\n    );\n    if (rotatable2D) {\n      reactToInput(\n        controller,\n        controller.enableRotate,\n        controller.translateEventTypes,\n        twist2D,\n        controller.inertiaSpin,\n        \"_lastInertiaSpinMovement\",\n      );\n    }\n  } else {\n    reactToInput(\n      controller,\n      controller.enableTranslate,\n      controller.translateEventTypes,\n      translate2D,\n      controller.inertiaTranslate,\n      \"_lastInertiaTranslateMovement\",\n    );\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoom2D,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\",\n    );\n    if (rotatable2D) {\n      reactToInput(\n        controller,\n        controller.enableRotate,\n        controller.tiltEventTypes,\n        twist2D,\n        controller.inertiaSpin,\n        \"_lastInertiaTiltMovement\",\n      );\n    }\n  }\n}\n\nconst pickGlobeScratchRay = new Ray();\nconst scratchDepthIntersection = new Cartesian3();\nconst scratchRayIntersection = new Cartesian3();\n\nfunction pickPosition(controller, mousePosition, result) {\n  const scene = controller._scene;\n  const globe = controller._globe;\n  const camera = scene.camera;\n\n  let depthIntersection;\n  if (scene.pickPositionSupported) {\n    depthIntersection = scene.pickPositionWorldCoordinates(\n      mousePosition,\n      scratchDepthIntersection,\n    );\n  }\n\n  if (!defined(globe)) {\n    return Cartesian3.clone(depthIntersection, result);\n  }\n\n  const cullBackFaces = !controller._cameraUnderground;\n  const ray = camera.getPickRay(mousePosition, pickGlobeScratchRay);\n  const rayIntersection = globe.pickWorldCoordinates(\n    ray,\n    scene,\n    cullBackFaces,\n    scratchRayIntersection,\n  );\n\n  const pickDistance = defined(depthIntersection)\n    ? Cartesian3.distance(depthIntersection, camera.positionWC)\n    : Number.POSITIVE_INFINITY;\n  const rayDistance = defined(rayIntersection)\n    ? Cartesian3.distance(rayIntersection, camera.positionWC)\n    : Number.POSITIVE_INFINITY;\n\n  if (pickDistance < rayDistance) {\n    return Cartesian3.clone(depthIntersection, result);\n  }\n\n  return Cartesian3.clone(rayIntersection, result);\n}\n\nconst scratchDistanceCartographic = new Cartographic();\n\nfunction getDistanceFromSurface(controller) {\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const mode = scene.mode;\n\n  let height = 0.0;\n  if (mode === SceneMode.SCENE3D) {\n    const cartographic = ellipsoid.cartesianToCartographic(\n      camera.position,\n      scratchDistanceCartographic,\n    );\n    if (defined(cartographic)) {\n      height = cartographic.height;\n    }\n  } else {\n    height = camera.position.z;\n  }\n  const globeHeight = controller._scene.globeHeight ?? 0.0;\n  const distanceFromSurface = Math.abs(globeHeight - height);\n  return distanceFromSurface;\n}\n\nconst scratchSurfaceNormal = new Cartesian3();\n\nfunction getZoomDistanceUnderground(controller, ray) {\n  const origin = ray.origin;\n  const direction = ray.direction;\n  const distanceFromSurface = getDistanceFromSurface(controller);\n\n  // Weight zoom distance based on how strongly the pick ray is pointing inward.\n  // Geocentric normal is accurate enough for these purposes\n  const surfaceNormal = Cartesian3.normalize(origin, scratchSurfaceNormal);\n  let strength = Math.abs(Cartesian3.dot(surfaceNormal, direction));\n  strength = Math.max(strength, 0.5) * 2.0;\n  return distanceFromSurface * strength;\n}\n\nfunction getTiltCenterUnderground(controller, ray, pickedPosition, result) {\n  let distance = Cartesian3.distance(ray.origin, pickedPosition);\n  const distanceFromSurface = getDistanceFromSurface(controller);\n\n  const maximumDistance = CesiumMath.clamp(\n    distanceFromSurface * 5.0,\n    controller._minimumUndergroundPickDistance,\n    controller._maximumUndergroundPickDistance,\n  );\n\n  if (distance > maximumDistance) {\n    // Simulate look-at behavior by tilting around a small invisible sphere\n    distance = Math.min(distance, distanceFromSurface / 5.0);\n    distance = Math.max(distance, 100.0);\n  }\n\n  return Ray.getPoint(ray, distance, result);\n}\n\nfunction getStrafeStartPositionUnderground(\n  controller,\n  ray,\n  pickedPosition,\n  result,\n) {\n  let distance;\n  if (!defined(pickedPosition)) {\n    distance = getDistanceFromSurface(controller);\n  } else {\n    distance = Cartesian3.distance(ray.origin, pickedPosition);\n    if (distance > controller._maximumUndergroundPickDistance) {\n      // If the picked position is too far away set the strafe speed based on the\n      // camera's height from the globe surface\n      distance = getDistanceFromSurface(controller);\n    }\n  }\n\n  return Ray.getPoint(ray, distance, result);\n}\n\nconst scratchInertialDelta = new Cartesian2();\n\nfunction continueStrafing(controller, movement) {\n  // Update the end position continually based on the inertial delta\n  const originalEndPosition = movement.endPosition;\n  const inertialDelta = Cartesian2.subtract(\n    movement.endPosition,\n    movement.startPosition,\n    scratchInertialDelta,\n  );\n  const endPosition = controller._strafeEndMousePosition;\n  Cartesian2.add(endPosition, inertialDelta, endPosition);\n  movement.endPosition = endPosition;\n  strafe(controller, movement, controller._strafeStartPosition);\n  movement.endPosition = originalEndPosition;\n}\n\nconst translateCVStartRay = new Ray();\nconst translateCVEndRay = new Ray();\nconst translateCVStartPos = new Cartesian3();\nconst translateCVEndPos = new Cartesian3();\nconst translateCVDifference = new Cartesian3();\nconst translateCVOrigin = new Cartesian3();\nconst translateCVPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst translateCVStartMouse = new Cartesian2();\nconst translateCVEndMouse = new Cartesian2();\n\nfunction translateCV(controller, startPosition, movement) {\n  if (!Cartesian3.equals(startPosition, controller._translateMousePosition)) {\n    controller._looking = false;\n  }\n\n  if (!Cartesian3.equals(startPosition, controller._strafeMousePosition)) {\n    controller._strafing = false;\n  }\n\n  if (controller._looking) {\n    look3D(controller, startPosition, movement);\n    return;\n  }\n\n  if (controller._strafing) {\n    continueStrafing(controller, movement);\n    return;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n  const startMouse = Cartesian2.clone(\n    movement.startPosition,\n    translateCVStartMouse,\n  );\n  const endMouse = Cartesian2.clone(movement.endPosition, translateCVEndMouse);\n  let startRay = camera.getPickRay(startMouse, translateCVStartRay);\n\n  const origin = Cartesian3.clone(Cartesian3.ZERO, translateCVOrigin);\n  const normal = Cartesian3.UNIT_X;\n\n  let globePos;\n  if (camera.position.z < controller._minimumPickingTerrainHeight) {\n    globePos = pickPosition(controller, startMouse, translateCVStartPos);\n\n    if (defined(globePos)) {\n      origin.x = globePos.x;\n    }\n  }\n\n  if (\n    cameraUnderground ||\n    (origin.x > camera.position.z && defined(globePos))\n  ) {\n    let pickPosition = globePos;\n    if (cameraUnderground) {\n      pickPosition = getStrafeStartPositionUnderground(\n        controller,\n        startRay,\n        globePos,\n        translateCVStartPos,\n      );\n    }\n    Cartesian2.clone(startPosition, controller._strafeMousePosition);\n    Cartesian2.clone(startPosition, controller._strafeEndMousePosition);\n    Cartesian3.clone(pickPosition, controller._strafeStartPosition);\n    controller._strafing = true;\n    strafe(controller, movement, controller._strafeStartPosition);\n    return;\n  }\n\n  const plane = Plane.fromPointNormal(origin, normal, translateCVPlane);\n\n  startRay = camera.getPickRay(startMouse, translateCVStartRay);\n  const startPlanePos = IntersectionTests.rayPlane(\n    startRay,\n    plane,\n    translateCVStartPos,\n  );\n\n  const endRay = camera.getPickRay(endMouse, translateCVEndRay);\n  const endPlanePos = IntersectionTests.rayPlane(\n    endRay,\n    plane,\n    translateCVEndPos,\n  );\n\n  if (!defined(startPlanePos) || !defined(endPlanePos)) {\n    controller._looking = true;\n    look3D(controller, startPosition, movement);\n    Cartesian2.clone(startPosition, controller._translateMousePosition);\n    return;\n  }\n\n  const diff = Cartesian3.subtract(\n    startPlanePos,\n    endPlanePos,\n    translateCVDifference,\n  );\n  const temp = diff.x;\n  diff.x = diff.y;\n  diff.y = diff.z;\n  diff.z = temp;\n  const mag = Cartesian3.magnitude(diff);\n  if (mag > CesiumMath.EPSILON6) {\n    Cartesian3.normalize(diff, diff);\n    camera.move(diff, mag);\n  }\n}\n\nconst rotateCVWindowPos = new Cartesian2();\nconst rotateCVWindowRay = new Ray();\nconst rotateCVCenter = new Cartesian3();\nconst rotateCVVerticalCenter = new Cartesian3();\nconst rotateCVTransform = new Matrix4();\nconst rotateCVVerticalTransform = new Matrix4();\nconst rotateCVOrigin = new Cartesian3();\nconst rotateCVPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst rotateCVCartesian3 = new Cartesian3();\nconst rotateCVCart = new Cartographic();\nconst rotateCVOldTransform = new Matrix4();\nconst rotateCVQuaternion = new Quaternion();\nconst rotateCVMatrix = new Matrix3();\nconst tilt3DCartesian3 = new Cartesian3();\n\nfunction rotateCV(controller, startPosition, movement) {\n  if (defined(movement.angleAndHeight)) {\n    movement = movement.angleAndHeight;\n  }\n\n  if (!Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    controller._tiltCVOffMap = false;\n    controller._looking = false;\n  }\n\n  if (controller._looking) {\n    look3D(controller, startPosition, movement);\n    return;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  if (\n    controller._tiltCVOffMap ||\n    !controller.onMap() ||\n    Math.abs(camera.position.z) > controller._minimumPickingTerrainHeight\n  ) {\n    controller._tiltCVOffMap = true;\n    rotateCVOnPlane(controller, startPosition, movement);\n  } else {\n    rotateCVOnTerrain(controller, startPosition, movement);\n  }\n}\n\nfunction rotateCVOnPlane(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n\n  const windowPosition = rotateCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  const ray = camera.getPickRay(windowPosition, rotateCVWindowRay);\n  const normal = Cartesian3.UNIT_X;\n\n  const position = ray.origin;\n  const direction = ray.direction;\n  let scalar;\n  const normalDotDirection = Cartesian3.dot(normal, direction);\n  if (Math.abs(normalDotDirection) > CesiumMath.EPSILON6) {\n    scalar = -Cartesian3.dot(normal, position) / normalDotDirection;\n  }\n\n  if (!defined(scalar) || scalar <= 0.0) {\n    controller._looking = true;\n    look3D(controller, startPosition, movement);\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    return;\n  }\n\n  const center = Cartesian3.multiplyByScalar(direction, scalar, rotateCVCenter);\n  Cartesian3.add(position, center, center);\n\n  const projection = scene.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n\n  Cartesian3.fromElements(center.y, center.z, center.x, center);\n  const cart = projection.unproject(center, rotateCVCart);\n  ellipsoid.cartographicToCartesian(cart, center);\n\n  const transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    rotateCVTransform,\n  );\n\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  const oldTransform = Matrix4.clone(camera.transform, rotateCVOldTransform);\n  camera._setTransform(transform);\n\n  rotate3D(controller, startPosition, movement, Cartesian3.UNIT_Z);\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n}\n\nfunction rotateCVOnTerrain(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n\n  let center;\n  let ray;\n  const normal = Cartesian3.UNIT_X;\n\n  if (Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    center = Cartesian3.clone(controller._tiltCenter, rotateCVCenter);\n  } else {\n    if (camera.position.z < controller._minimumPickingTerrainHeight) {\n      center = pickPosition(controller, startPosition, rotateCVCenter);\n    }\n\n    if (!defined(center)) {\n      ray = camera.getPickRay(startPosition, rotateCVWindowRay);\n      const position = ray.origin;\n      const direction = ray.direction;\n\n      let scalar;\n      const normalDotDirection = Cartesian3.dot(normal, direction);\n      if (Math.abs(normalDotDirection) > CesiumMath.EPSILON6) {\n        scalar = -Cartesian3.dot(normal, position) / normalDotDirection;\n      }\n\n      if (!defined(scalar) || scalar <= 0.0) {\n        controller._looking = true;\n        look3D(controller, startPosition, movement);\n        Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n        return;\n      }\n\n      center = Cartesian3.multiplyByScalar(direction, scalar, rotateCVCenter);\n      Cartesian3.add(position, center, center);\n    }\n\n    if (cameraUnderground) {\n      if (!defined(ray)) {\n        ray = camera.getPickRay(startPosition, rotateCVWindowRay);\n      }\n      getTiltCenterUnderground(controller, ray, center, center);\n    }\n\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    Cartesian3.clone(center, controller._tiltCenter);\n  }\n\n  const canvas = scene.canvas;\n\n  const windowPosition = rotateCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = controller._tiltCenterMousePosition.y;\n  ray = camera.getPickRay(windowPosition, rotateCVWindowRay);\n\n  const origin = Cartesian3.clone(Cartesian3.ZERO, rotateCVOrigin);\n  origin.x = center.x;\n\n  const plane = Plane.fromPointNormal(origin, normal, rotateCVPlane);\n  const verticalCenter = IntersectionTests.rayPlane(\n    ray,\n    plane,\n    rotateCVVerticalCenter,\n  );\n\n  const projection = camera._projection;\n  const ellipsoid = projection.ellipsoid;\n\n  Cartesian3.fromElements(center.y, center.z, center.x, center);\n  let cart = projection.unproject(center, rotateCVCart);\n  ellipsoid.cartographicToCartesian(cart, center);\n\n  const transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    rotateCVTransform,\n  );\n\n  let verticalTransform;\n  if (defined(verticalCenter)) {\n    Cartesian3.fromElements(\n      verticalCenter.y,\n      verticalCenter.z,\n      verticalCenter.x,\n      verticalCenter,\n    );\n    cart = projection.unproject(verticalCenter, rotateCVCart);\n    ellipsoid.cartographicToCartesian(cart, verticalCenter);\n\n    verticalTransform = Transforms.eastNorthUpToFixedFrame(\n      verticalCenter,\n      ellipsoid,\n      rotateCVVerticalTransform,\n    );\n  } else {\n    verticalTransform = transform;\n  }\n\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  let constrainedAxis = Cartesian3.UNIT_Z;\n\n  const oldTransform = Matrix4.clone(camera.transform, rotateCVOldTransform);\n  camera._setTransform(transform);\n\n  const tangent = Cartesian3.cross(\n    Cartesian3.UNIT_Z,\n    Cartesian3.normalize(camera.position, rotateCVCartesian3),\n    rotateCVCartesian3,\n  );\n  const dot = Cartesian3.dot(camera.right, tangent);\n\n  rotate3D(controller, startPosition, movement, constrainedAxis, false, true);\n\n  camera._setTransform(verticalTransform);\n  if (dot < 0.0) {\n    const movementDelta = movement.startPosition.y - movement.endPosition.y;\n    if (\n      (cameraUnderground && movementDelta < 0.0) ||\n      (!cameraUnderground && movementDelta > 0.0)\n    ) {\n      // Prevent camera from flipping past the up axis\n      constrainedAxis = undefined;\n    }\n\n    const oldConstrainedAxis = camera.constrainedAxis;\n    camera.constrainedAxis = undefined;\n\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n\n    camera.constrainedAxis = oldConstrainedAxis;\n  } else {\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n  }\n\n  if (defined(camera.constrainedAxis)) {\n    const right = Cartesian3.cross(\n      camera.direction,\n      camera.constrainedAxis,\n      tilt3DCartesian3,\n    );\n    if (\n      !Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)\n    ) {\n      if (Cartesian3.dot(right, camera.right) < 0.0) {\n        Cartesian3.negate(right, right);\n      }\n\n      Cartesian3.cross(right, camera.direction, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n      Cartesian3.normalize(camera.up, camera.up);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n  }\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n\n  const originalPosition = Cartesian3.clone(\n    camera.positionWC,\n    rotateCVCartesian3,\n  );\n\n  if (controller.enableCollisionDetection) {\n    adjustHeightForTerrain(controller, true);\n  }\n\n  if (!Cartesian3.equals(camera.positionWC, originalPosition)) {\n    camera._setTransform(verticalTransform);\n    camera.worldToCameraCoordinatesPoint(originalPosition, originalPosition);\n\n    const magSqrd = Cartesian3.magnitudeSquared(originalPosition);\n    if (Cartesian3.magnitudeSquared(camera.position) > magSqrd) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.multiplyByScalar(\n        camera.position,\n        Math.sqrt(magSqrd),\n        camera.position,\n      );\n    }\n\n    const angle = Cartesian3.angleBetween(originalPosition, camera.position);\n    const axis = Cartesian3.cross(\n      originalPosition,\n      camera.position,\n      originalPosition,\n    );\n    Cartesian3.normalize(axis, axis);\n\n    const quaternion = Quaternion.fromAxisAngle(\n      axis,\n      angle,\n      rotateCVQuaternion,\n    );\n    const rotation = Matrix3.fromQuaternion(quaternion, rotateCVMatrix);\n    Matrix3.multiplyByVector(rotation, camera.direction, camera.direction);\n    Matrix3.multiplyByVector(rotation, camera.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.cross(camera.right, camera.direction, camera.up);\n\n    camera._setTransform(oldTransform);\n  }\n}\n\nconst zoomCVWindowPos = new Cartesian2();\nconst zoomCVWindowRay = new Ray();\nconst zoomCVIntersection = new Cartesian3();\n\nfunction zoomCV(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n\n  const cameraUnderground = controller._cameraUnderground;\n\n  let windowPosition;\n\n  if (cameraUnderground) {\n    windowPosition = startPosition;\n  } else {\n    windowPosition = zoomCVWindowPos;\n    windowPosition.x = canvas.clientWidth / 2;\n    windowPosition.y = canvas.clientHeight / 2;\n  }\n\n  const ray = camera.getPickRay(windowPosition, zoomCVWindowRay);\n  const position = ray.origin;\n  const direction = ray.direction;\n  const height = camera.position.z;\n\n  let intersection;\n  if (height < controller._minimumPickingTerrainHeight) {\n    intersection = pickPosition(controller, windowPosition, zoomCVIntersection);\n  }\n\n  let distance;\n  if (defined(intersection)) {\n    distance = Cartesian3.distance(position, intersection);\n  }\n\n  if (cameraUnderground) {\n    const distanceUnderground = getZoomDistanceUnderground(\n      controller,\n      ray,\n      height,\n    );\n    if (defined(distance)) {\n      distance = Math.min(distance, distanceUnderground);\n    } else {\n      distance = distanceUnderground;\n    }\n  }\n\n  if (!defined(distance)) {\n    const normal = Cartesian3.UNIT_X;\n    distance =\n      -Cartesian3.dot(normal, position) / Cartesian3.dot(normal, direction);\n  }\n\n  handleZoom(\n    controller,\n    startPosition,\n    movement,\n    controller.zoomFactor,\n    distance,\n  );\n}\n\nfunction updateCV(controller) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  if (!Matrix4.equals(Matrix4.IDENTITY, camera.transform)) {\n    reactToInput(\n      controller,\n      controller.enableRotate,\n      controller.rotateEventTypes,\n      rotate3D,\n      controller.inertiaSpin,\n      \"_lastInertiaSpinMovement\",\n    );\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoom3D,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\",\n    );\n  } else {\n    const tweens = controller._tweens;\n\n    if (controller._aggregator.anyButtonDown) {\n      tweens.removeAll();\n    }\n\n    reactToInput(\n      controller,\n      controller.enableTilt,\n      controller.tiltEventTypes,\n      rotateCV,\n      controller.inertiaSpin,\n      \"_lastInertiaTiltMovement\",\n    );\n    reactToInput(\n      controller,\n      controller.enableTranslate,\n      controller.translateEventTypes,\n      translateCV,\n      controller.inertiaTranslate,\n      \"_lastInertiaTranslateMovement\",\n    );\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoomCV,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\",\n    );\n    reactToInput(\n      controller,\n      controller.enableLook,\n      controller.lookEventTypes,\n      look3D,\n    );\n\n    if (\n      !controller._aggregator.anyButtonDown &&\n      !tweens.contains(controller._tween)\n    ) {\n      const tween = camera.createCorrectPositionTween(\n        controller.bounceAnimationTime,\n      );\n      if (defined(tween)) {\n        controller._tween = tweens.add(tween);\n      }\n    }\n\n    tweens.update();\n  }\n}\n\nconst scratchStrafeRay = new Ray();\nconst scratchStrafePlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst scratchStrafeIntersection = new Cartesian3();\nconst scratchStrafeDirection = new Cartesian3();\n\nfunction strafe(controller, movement, strafeStartPosition) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  const ray = camera.getPickRay(movement.endPosition, scratchStrafeRay);\n\n  let direction = Cartesian3.clone(camera.direction, scratchStrafeDirection);\n  if (scene.mode === SceneMode.COLUMBUS_VIEW) {\n    Cartesian3.fromElements(direction.z, direction.x, direction.y, direction);\n  }\n\n  const plane = Plane.fromPointNormal(\n    strafeStartPosition,\n    direction,\n    scratchStrafePlane,\n  );\n  const intersection = IntersectionTests.rayPlane(\n    ray,\n    plane,\n    scratchStrafeIntersection,\n  );\n  if (!defined(intersection)) {\n    return;\n  }\n\n  direction = Cartesian3.subtract(strafeStartPosition, intersection, direction);\n  if (scene.mode === SceneMode.COLUMBUS_VIEW) {\n    Cartesian3.fromElements(direction.y, direction.z, direction.x, direction);\n  }\n\n  Cartesian3.add(camera.position, direction, camera.position);\n}\n\nconst spin3DPick = new Cartesian3();\nconst scratchCartographic = new Cartographic();\nconst scratchRadii = new Cartesian3();\nconst scratchEllipsoid = new Ellipsoid();\nconst scratchLookUp = new Cartesian3();\nconst scratchNormal = new Cartesian3();\nconst scratchMousePosition = new Cartesian3();\n\nfunction spin3D(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n  let ellipsoid = controller._ellipsoid;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    rotate3D(controller, startPosition, movement);\n    return;\n  }\n\n  let magnitude;\n  let radii;\n\n  const up = ellipsoid.geodeticSurfaceNormal(camera.position, scratchLookUp);\n\n  if (Cartesian2.equals(startPosition, controller._rotateMousePosition)) {\n    if (controller._looking) {\n      look3D(controller, startPosition, movement, up);\n    } else if (controller._rotating) {\n      rotate3D(controller, startPosition, movement);\n    } else if (controller._strafing) {\n      continueStrafing(controller, movement);\n    } else {\n      if (\n        Cartesian3.magnitude(camera.position) <\n        Cartesian3.magnitude(controller._rotateStartPosition)\n      ) {\n        // Pan action is no longer valid if camera moves below the pan ellipsoid\n        return;\n      }\n      magnitude = Cartesian3.magnitude(controller._rotateStartPosition);\n      radii = scratchRadii;\n      radii.x = radii.y = radii.z = magnitude;\n      ellipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n      pan3D(controller, startPosition, movement, ellipsoid);\n    }\n    return;\n  }\n  controller._looking = false;\n  controller._rotating = false;\n  controller._strafing = false;\n\n  const height = ellipsoid.cartesianToCartographic(\n    camera.positionWC,\n    scratchCartographic,\n  ).height;\n  const globe = controller._globe;\n\n  if (defined(globe) && height < controller._minimumPickingTerrainHeight) {\n    const mousePos = pickPosition(\n      controller,\n      movement.startPosition,\n      scratchMousePosition,\n    );\n    if (defined(mousePos)) {\n      let strafing = false;\n      const ray = camera.getPickRay(\n        movement.startPosition,\n        pickGlobeScratchRay,\n      );\n\n      if (cameraUnderground) {\n        strafing = true;\n        getStrafeStartPositionUnderground(controller, ray, mousePos, mousePos);\n      } else {\n        const normal = ellipsoid.geodeticSurfaceNormal(mousePos, scratchNormal);\n        const tangentPick =\n          Math.abs(Cartesian3.dot(ray.direction, normal)) < 0.05;\n\n        if (tangentPick) {\n          strafing = true;\n        } else {\n          strafing =\n            Cartesian3.magnitude(camera.position) <\n            Cartesian3.magnitude(mousePos);\n        }\n      }\n\n      if (strafing) {\n        Cartesian2.clone(startPosition, controller._strafeEndMousePosition);\n        Cartesian3.clone(mousePos, controller._strafeStartPosition);\n        controller._strafing = true;\n        strafe(controller, movement, controller._strafeStartPosition);\n      } else {\n        magnitude = Cartesian3.magnitude(mousePos);\n        radii = scratchRadii;\n        radii.x = radii.y = radii.z = magnitude;\n        ellipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n        pan3D(controller, startPosition, movement, ellipsoid);\n\n        Cartesian3.clone(mousePos, controller._rotateStartPosition);\n      }\n    } else {\n      controller._looking = true;\n      look3D(controller, startPosition, movement, up);\n    }\n  } else if (\n    defined(\n      camera.pickEllipsoid(\n        movement.startPosition,\n        controller._ellipsoid,\n        spin3DPick,\n      ),\n    )\n  ) {\n    pan3D(controller, startPosition, movement, controller._ellipsoid);\n    Cartesian3.clone(spin3DPick, controller._rotateStartPosition);\n  } else if (height > controller._minimumTrackBallHeight) {\n    controller._rotating = true;\n    rotate3D(controller, startPosition, movement);\n  } else {\n    controller._looking = true;\n    look3D(controller, startPosition, movement, up);\n  }\n\n  Cartesian2.clone(startPosition, controller._rotateMousePosition);\n}\n\nfunction rotate3D(\n  controller,\n  startPosition,\n  movement,\n  constrainedAxis,\n  rotateOnlyVertical,\n  rotateOnlyHorizontal,\n) {\n  rotateOnlyVertical = rotateOnlyVertical ?? false;\n  rotateOnlyHorizontal = rotateOnlyHorizontal ?? false;\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n\n  const oldAxis = camera.constrainedAxis;\n  if (defined(constrainedAxis)) {\n    camera.constrainedAxis = constrainedAxis;\n  }\n\n  const rho = Cartesian3.magnitude(camera.position);\n  let rotateRate =\n    controller._rotateFactor * (rho - controller._rotateRateRangeAdjustment);\n\n  if (rotateRate > controller._maximumRotateRate) {\n    rotateRate = controller._maximumRotateRate;\n  }\n\n  if (rotateRate < controller._minimumRotateRate) {\n    rotateRate = controller._minimumRotateRate;\n  }\n\n  let phiWindowRatio =\n    (movement.startPosition.x - movement.endPosition.x) / canvas.clientWidth;\n  let thetaWindowRatio =\n    (movement.startPosition.y - movement.endPosition.y) / canvas.clientHeight;\n  phiWindowRatio = Math.min(phiWindowRatio, controller.maximumMovementRatio);\n  thetaWindowRatio = Math.min(\n    thetaWindowRatio,\n    controller.maximumMovementRatio,\n  );\n\n  const deltaPhi = rotateRate * phiWindowRatio * Math.PI * 2.0;\n  let deltaTheta = rotateRate * thetaWindowRatio * Math.PI;\n\n  if (defined(constrainedAxis) && defined(controller.maximumTiltAngle)) {\n    const maximumTiltAngle = controller.maximumTiltAngle;\n    const dotProduct = Cartesian3.dot(camera.direction, constrainedAxis);\n    const tilt = Math.PI - Math.acos(dotProduct) + deltaTheta;\n    if (tilt > maximumTiltAngle) {\n      deltaTheta -= tilt - maximumTiltAngle;\n    }\n  }\n\n  if (!rotateOnlyVertical) {\n    camera.rotateRight(deltaPhi);\n  }\n\n  if (!rotateOnlyHorizontal) {\n    camera.rotateUp(deltaTheta);\n  }\n\n  camera.constrainedAxis = oldAxis;\n}\n\nconst pan3DP0 = Cartesian4.clone(Cartesian4.UNIT_W);\nconst pan3DP1 = Cartesian4.clone(Cartesian4.UNIT_W);\nconst pan3DTemp0 = new Cartesian3();\nconst pan3DTemp1 = new Cartesian3();\nconst pan3DTemp2 = new Cartesian3();\nconst pan3DTemp3 = new Cartesian3();\nconst pan3DStartMousePosition = new Cartesian2();\nconst pan3DEndMousePosition = new Cartesian2();\nconst pan3DDiffMousePosition = new Cartesian2();\nconst pan3DPixelDimensions = new Cartesian2();\nconst panRay = new Ray();\n\nfunction pan3D(controller, startPosition, movement, ellipsoid) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  const startMousePosition = Cartesian2.clone(\n    movement.startPosition,\n    pan3DStartMousePosition,\n  );\n  const endMousePosition = Cartesian2.clone(\n    movement.endPosition,\n    pan3DEndMousePosition,\n  );\n  const height = ellipsoid.cartesianToCartographic(\n    camera.positionWC,\n    scratchCartographic,\n  ).height;\n\n  let p0, p1;\n\n  if (\n    !movement.inertiaEnabled &&\n    height < controller._minimumPickingTerrainHeight\n  ) {\n    p0 = Cartesian3.clone(controller._panLastWorldPosition, pan3DP0);\n\n    // Use the last picked world position unless we're starting a new drag\n    if (\n      !defined(controller._globe) &&\n      !Cartesian2.equalsEpsilon(\n        startMousePosition,\n        controller._panLastMousePosition,\n      )\n    ) {\n      p0 = pickPosition(controller, startMousePosition, pan3DP0);\n    }\n\n    if (!defined(controller._globe) && defined(p0)) {\n      const toCenter = Cartesian3.subtract(p0, camera.positionWC, pan3DTemp1);\n      const toCenterProj = Cartesian3.multiplyByScalar(\n        camera.directionWC,\n        Cartesian3.dot(camera.directionWC, toCenter),\n        pan3DTemp1,\n      );\n      const distanceToNearPlane = Cartesian3.magnitude(toCenterProj);\n      const pixelDimensions = camera.frustum.getPixelDimensions(\n        scene.drawingBufferWidth,\n        scene.drawingBufferHeight,\n        distanceToNearPlane,\n        scene.pixelRatio,\n        pan3DPixelDimensions,\n      );\n\n      const dragDelta = Cartesian2.subtract(\n        endMousePosition,\n        startMousePosition,\n        pan3DDiffMousePosition,\n      );\n\n      // Move the camera to the the distance the cursor moved in worldspace\n      const right = Cartesian3.multiplyByScalar(\n        camera.rightWC,\n        dragDelta.x * pixelDimensions.x,\n        pan3DTemp1,\n      );\n\n      // Move the camera towards the picked position in worldspace as the camera is pointed towards a horizon view\n      const cameraPositionNormal = Cartesian3.normalize(\n        camera.positionWC,\n        scratchCameraPositionNormal,\n      );\n      const endPickDirection = camera.getPickRay(\n        endMousePosition,\n        panRay,\n      ).direction;\n      const endPickProj = Cartesian3.subtract(\n        endPickDirection,\n        Cartesian3.projectVector(endPickDirection, camera.rightWC, pan3DTemp2),\n        pan3DTemp2,\n      );\n      const angle = Cartesian3.angleBetween(endPickProj, camera.directionWC);\n      let forward = 1.0;\n      if (defined(camera.frustum.fov)) {\n        forward = Math.max(Math.tan(angle), 0.1); // Clamp so we don't make the magnitude infinitely large when the angle is small\n      }\n      let dot = Math.abs(\n        Cartesian3.dot(camera.directionWC, cameraPositionNormal),\n      );\n      const magnitude =\n        ((-dragDelta.y * pixelDimensions.y * 2.0) / Math.sqrt(forward)) *\n        (1.0 - dot);\n      const direction = Cartesian3.multiplyByScalar(\n        endPickDirection,\n        magnitude,\n        pan3DTemp2,\n      );\n\n      // Move the camera up the distance the cursor moved in worldspace as the camera is pointed towards the center\n      dot = Math.abs(Cartesian3.dot(camera.upWC, cameraPositionNormal));\n      const up = Cartesian3.multiplyByScalar(\n        camera.upWC,\n        -dragDelta.y * (1.0 - dot) * pixelDimensions.y,\n        pan3DTemp3,\n      );\n\n      p1 = Cartesian3.add(p0, right, pan3DP1);\n      p1 = Cartesian3.add(p1, direction, p1);\n      p1 = Cartesian3.add(p1, up, p1);\n\n      Cartesian3.clone(p1, controller._panLastWorldPosition);\n      Cartesian2.clone(endMousePosition, controller._panLastMousePosition);\n    }\n  }\n\n  if (!defined(p0) || !defined(p1)) {\n    p0 = camera.pickEllipsoid(startMousePosition, ellipsoid, pan3DP0);\n    p1 = camera.pickEllipsoid(endMousePosition, ellipsoid, pan3DP1);\n  }\n\n  if (!defined(p0) || !defined(p1)) {\n    controller._rotating = true;\n    rotate3D(controller, startPosition, movement);\n    return;\n  }\n\n  p0 = camera.worldToCameraCoordinates(p0, p0);\n  p1 = camera.worldToCameraCoordinates(p1, p1);\n\n  if (!defined(camera.constrainedAxis)) {\n    Cartesian3.normalize(p0, p0);\n    Cartesian3.normalize(p1, p1);\n    const dot = Cartesian3.dot(p0, p1);\n    const axis = Cartesian3.cross(p0, p1, pan3DTemp0);\n\n    if (\n      dot < 1.0 &&\n      !Cartesian3.equalsEpsilon(axis, Cartesian3.ZERO, CesiumMath.EPSILON14)\n    ) {\n      // dot is in [0, 1]\n      const angle = Math.acos(dot);\n      camera.rotate(axis, angle);\n    }\n  } else {\n    const basis0 = camera.constrainedAxis;\n    const basis1 = Cartesian3.mostOrthogonalAxis(basis0, pan3DTemp0);\n    Cartesian3.cross(basis1, basis0, basis1);\n    Cartesian3.normalize(basis1, basis1);\n    const basis2 = Cartesian3.cross(basis0, basis1, pan3DTemp1);\n\n    const startRho = Cartesian3.magnitude(p0);\n    const startDot = Cartesian3.dot(basis0, p0);\n    const startTheta = Math.acos(startDot / startRho);\n    const startRej = Cartesian3.multiplyByScalar(basis0, startDot, pan3DTemp2);\n    Cartesian3.subtract(p0, startRej, startRej);\n    Cartesian3.normalize(startRej, startRej);\n\n    const endRho = Cartesian3.magnitude(p1);\n    const endDot = Cartesian3.dot(basis0, p1);\n    const endTheta = Math.acos(endDot / endRho);\n    const endRej = Cartesian3.multiplyByScalar(basis0, endDot, pan3DTemp3);\n    Cartesian3.subtract(p1, endRej, endRej);\n    Cartesian3.normalize(endRej, endRej);\n\n    let startPhi = Math.acos(Cartesian3.dot(startRej, basis1));\n    if (Cartesian3.dot(startRej, basis2) < 0) {\n      startPhi = CesiumMath.TWO_PI - startPhi;\n    }\n\n    let endPhi = Math.acos(Cartesian3.dot(endRej, basis1));\n    if (Cartesian3.dot(endRej, basis2) < 0) {\n      endPhi = CesiumMath.TWO_PI - endPhi;\n    }\n\n    const deltaPhi = startPhi - endPhi;\n\n    let east;\n    if (\n      Cartesian3.equalsEpsilon(basis0, camera.position, CesiumMath.EPSILON2)\n    ) {\n      east = camera.right;\n    } else {\n      east = Cartesian3.cross(basis0, camera.position, pan3DTemp0);\n    }\n\n    const planeNormal = Cartesian3.cross(basis0, east, pan3DTemp0);\n    const side0 = Cartesian3.dot(\n      planeNormal,\n      Cartesian3.subtract(p0, basis0, pan3DTemp1),\n    );\n    const side1 = Cartesian3.dot(\n      planeNormal,\n      Cartesian3.subtract(p1, basis0, pan3DTemp1),\n    );\n\n    let deltaTheta;\n    if (side0 > 0 && side1 > 0) {\n      deltaTheta = endTheta - startTheta;\n    } else if (side0 > 0 && side1 <= 0) {\n      if (Cartesian3.dot(camera.position, basis0) > 0) {\n        deltaTheta = -startTheta - endTheta;\n      } else {\n        deltaTheta = startTheta + endTheta;\n      }\n    } else {\n      deltaTheta = startTheta - endTheta;\n    }\n\n    camera.rotateRight(deltaPhi);\n    camera.rotateUp(deltaTheta);\n  }\n}\n\nconst zoom3DUnitPosition = new Cartesian3();\nconst zoom3DCartographic = new Cartographic();\n\nlet preIntersectionDistance = 0;\n\nfunction zoom3D(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n  const inertiaMovement = movement.inertiaEnabled;\n\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n\n  const cameraUnderground = controller._cameraUnderground;\n\n  let windowPosition;\n\n  if (cameraUnderground) {\n    windowPosition = startPosition;\n  } else {\n    windowPosition = zoomCVWindowPos;\n    windowPosition.x = canvas.clientWidth / 2;\n    windowPosition.y = canvas.clientHeight / 2;\n  }\n\n  const ray = camera.getPickRay(windowPosition, zoomCVWindowRay);\n\n  let intersection;\n  const height = ellipsoid.cartesianToCartographic(\n    camera.position,\n    zoom3DCartographic,\n  ).height;\n\n  const approachingCollision =\n    Math.abs(preIntersectionDistance) <\n    controller.minimumPickingTerrainDistanceWithInertia;\n\n  const needPickGlobe = inertiaMovement\n    ? approachingCollision\n    : height < controller._minimumPickingTerrainHeight;\n  if (needPickGlobe) {\n    intersection = pickPosition(controller, windowPosition, zoomCVIntersection);\n  }\n\n  let distance;\n  if (defined(intersection)) {\n    distance = Cartesian3.distance(ray.origin, intersection);\n    preIntersectionDistance = distance;\n  }\n\n  if (cameraUnderground) {\n    const distanceUnderground = getZoomDistanceUnderground(\n      controller,\n      ray,\n      height,\n    );\n    if (defined(distance)) {\n      distance = Math.min(distance, distanceUnderground);\n    } else {\n      distance = distanceUnderground;\n    }\n  }\n\n  if (!defined(distance)) {\n    distance = height;\n  }\n\n  const unitPosition = Cartesian3.normalize(\n    camera.position,\n    zoom3DUnitPosition,\n  );\n  handleZoom(\n    controller,\n    startPosition,\n    movement,\n    controller.zoomFactor,\n    distance,\n    Cartesian3.dot(unitPosition, camera.direction),\n  );\n}\n\nconst tilt3DWindowPos = new Cartesian2();\nconst tilt3DRay = new Ray();\nconst tilt3DCenter = new Cartesian3();\nconst tilt3DVerticalCenter = new Cartesian3();\nconst tilt3DTransform = new Matrix4();\nconst tilt3DVerticalTransform = new Matrix4();\nconst tilt3DOldTransform = new Matrix4();\nconst tilt3DQuaternion = new Quaternion();\nconst tilt3DMatrix = new Matrix3();\nconst tilt3DCart = new Cartographic();\nconst tilt3DLookUp = new Cartesian3();\n\nfunction tilt3D(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    return;\n  }\n\n  if (defined(movement.angleAndHeight)) {\n    movement = movement.angleAndHeight;\n  }\n\n  if (!Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    controller._tiltOnEllipsoid = false;\n    controller._looking = false;\n  }\n\n  if (controller._looking) {\n    const up = controller._ellipsoid.geodeticSurfaceNormal(\n      camera.position,\n      tilt3DLookUp,\n    );\n    look3D(controller, startPosition, movement, up);\n    return;\n  }\n\n  const ellipsoid = controller._ellipsoid;\n  const cartographic = ellipsoid.cartesianToCartographic(\n    camera.position,\n    tilt3DCart,\n  );\n\n  if (\n    controller._tiltOnEllipsoid ||\n    cartographic.height > controller._minimumCollisionTerrainHeight\n  ) {\n    controller._tiltOnEllipsoid = true;\n    tilt3DOnEllipsoid(controller, startPosition, movement);\n  } else {\n    tilt3DOnTerrain(controller, startPosition, movement);\n  }\n}\n\nconst tilt3DOnEllipsoidCartographic = new Cartographic();\n\nfunction tilt3DOnEllipsoid(controller, startPosition, movement) {\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const minHeight = controller.minimumZoomDistance * 0.25;\n  const height = ellipsoid.cartesianToCartographic(\n    camera.positionWC,\n    tilt3DOnEllipsoidCartographic,\n  ).height;\n  if (\n    height - minHeight - 1.0 < CesiumMath.EPSILON3 &&\n    movement.endPosition.y - movement.startPosition.y < 0\n  ) {\n    return;\n  }\n\n  const canvas = scene.canvas;\n\n  const windowPosition = tilt3DWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  const ray = camera.getPickRay(windowPosition, tilt3DRay);\n\n  let center;\n  const intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n  if (defined(intersection)) {\n    center = Ray.getPoint(ray, intersection.start, tilt3DCenter);\n  } else if (height > controller._minimumTrackBallHeight) {\n    const grazingAltitudeLocation = IntersectionTests.grazingAltitudeLocation(\n      ray,\n      ellipsoid,\n    );\n    if (!defined(grazingAltitudeLocation)) {\n      return;\n    }\n    const grazingAltitudeCart = ellipsoid.cartesianToCartographic(\n      grazingAltitudeLocation,\n      tilt3DCart,\n    );\n    grazingAltitudeCart.height = 0.0;\n    center = ellipsoid.cartographicToCartesian(\n      grazingAltitudeCart,\n      tilt3DCenter,\n    );\n  } else {\n    controller._looking = true;\n    const up = controller._ellipsoid.geodeticSurfaceNormal(\n      camera.position,\n      tilt3DLookUp,\n    );\n    look3D(controller, startPosition, movement, up);\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    return;\n  }\n\n  const transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    tilt3DTransform,\n  );\n\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  const oldTransform = Matrix4.clone(camera.transform, tilt3DOldTransform);\n  camera._setTransform(transform);\n\n  rotate3D(controller, startPosition, movement, Cartesian3.UNIT_Z);\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n}\n\nfunction tilt3DOnTerrain(controller, startPosition, movement) {\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n\n  let center;\n  let ray;\n  let intersection;\n\n  if (Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    center = Cartesian3.clone(controller._tiltCenter, tilt3DCenter);\n  } else {\n    center = pickPosition(controller, startPosition, tilt3DCenter);\n\n    if (!defined(center)) {\n      ray = camera.getPickRay(startPosition, tilt3DRay);\n      intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n      if (!defined(intersection)) {\n        const cartographic = ellipsoid.cartesianToCartographic(\n          camera.position,\n          tilt3DCart,\n        );\n        if (cartographic.height <= controller._minimumTrackBallHeight) {\n          controller._looking = true;\n          const up = controller._ellipsoid.geodeticSurfaceNormal(\n            camera.position,\n            tilt3DLookUp,\n          );\n          look3D(controller, startPosition, movement, up);\n          Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n        }\n        return;\n      }\n      center = Ray.getPoint(ray, intersection.start, tilt3DCenter);\n    }\n\n    if (cameraUnderground) {\n      if (!defined(ray)) {\n        ray = camera.getPickRay(startPosition, tilt3DRay);\n      }\n      getTiltCenterUnderground(controller, ray, center, center);\n    }\n\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    Cartesian3.clone(center, controller._tiltCenter);\n  }\n\n  const canvas = scene.canvas;\n\n  const windowPosition = tilt3DWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = controller._tiltCenterMousePosition.y;\n  ray = camera.getPickRay(windowPosition, tilt3DRay);\n\n  const mag = Cartesian3.magnitude(center);\n  const radii = Cartesian3.fromElements(mag, mag, mag, scratchRadii);\n  const newEllipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n\n  intersection = IntersectionTests.rayEllipsoid(ray, newEllipsoid);\n  if (!defined(intersection)) {\n    return;\n  }\n\n  const t =\n    Cartesian3.magnitude(ray.origin) > mag\n      ? intersection.start\n      : intersection.stop;\n  const verticalCenter = Ray.getPoint(ray, t, tilt3DVerticalCenter);\n\n  const transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    tilt3DTransform,\n  );\n  const verticalTransform = Transforms.eastNorthUpToFixedFrame(\n    verticalCenter,\n    newEllipsoid,\n    tilt3DVerticalTransform,\n  );\n\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  let constrainedAxis = Cartesian3.UNIT_Z;\n\n  const oldTransform = Matrix4.clone(camera.transform, tilt3DOldTransform);\n  camera._setTransform(verticalTransform);\n\n  const tangent = Cartesian3.cross(\n    verticalCenter,\n    camera.positionWC,\n    tilt3DCartesian3,\n  );\n  const dot = Cartesian3.dot(camera.rightWC, tangent);\n\n  if (dot < 0.0) {\n    const movementDelta = movement.startPosition.y - movement.endPosition.y;\n    if (\n      (cameraUnderground && movementDelta < 0.0) ||\n      (!cameraUnderground && movementDelta > 0.0)\n    ) {\n      // Prevent camera from flipping past the up axis\n      constrainedAxis = undefined;\n    }\n\n    const oldConstrainedAxis = camera.constrainedAxis;\n    camera.constrainedAxis = undefined;\n\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n\n    camera.constrainedAxis = oldConstrainedAxis;\n  } else {\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n  }\n\n  camera._setTransform(transform);\n  rotate3D(controller, startPosition, movement, constrainedAxis, false, true);\n\n  if (defined(camera.constrainedAxis)) {\n    const right = Cartesian3.cross(\n      camera.direction,\n      camera.constrainedAxis,\n      tilt3DCartesian3,\n    );\n    if (\n      !Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)\n    ) {\n      if (Cartesian3.dot(right, camera.right) < 0.0) {\n        Cartesian3.negate(right, right);\n      }\n\n      Cartesian3.cross(right, camera.direction, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n      Cartesian3.normalize(camera.up, camera.up);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n  }\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n\n  const originalPosition = Cartesian3.clone(\n    camera.positionWC,\n    tilt3DCartesian3,\n  );\n\n  if (controller.enableCollisionDetection) {\n    adjustHeightForTerrain(controller, true);\n  }\n\n  if (!Cartesian3.equals(camera.positionWC, originalPosition)) {\n    camera._setTransform(verticalTransform);\n    camera.worldToCameraCoordinatesPoint(originalPosition, originalPosition);\n\n    const magSqrd = Cartesian3.magnitudeSquared(originalPosition);\n    if (Cartesian3.magnitudeSquared(camera.position) > magSqrd) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.multiplyByScalar(\n        camera.position,\n        Math.sqrt(magSqrd),\n        camera.position,\n      );\n    }\n\n    const angle = Cartesian3.angleBetween(originalPosition, camera.position);\n    const axis = Cartesian3.cross(\n      originalPosition,\n      camera.position,\n      originalPosition,\n    );\n    Cartesian3.normalize(axis, axis);\n\n    const quaternion = Quaternion.fromAxisAngle(axis, angle, tilt3DQuaternion);\n    const rotation = Matrix3.fromQuaternion(quaternion, tilt3DMatrix);\n    Matrix3.multiplyByVector(rotation, camera.direction, camera.direction);\n    Matrix3.multiplyByVector(rotation, camera.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.cross(camera.right, camera.direction, camera.up);\n\n    camera._setTransform(oldTransform);\n  }\n}\n\nconst look3DStartPos = new Cartesian2();\nconst look3DEndPos = new Cartesian2();\nconst look3DStartRay = new Ray();\nconst look3DEndRay = new Ray();\nconst look3DNegativeRot = new Cartesian3();\nconst look3DTan = new Cartesian3();\n\nfunction look3D(controller, startPosition, movement, rotationAxis) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  const startPos = look3DStartPos;\n  startPos.x = movement.startPosition.x;\n  startPos.y = 0.0;\n  const endPos = look3DEndPos;\n  endPos.x = movement.endPosition.x;\n  endPos.y = 0.0;\n\n  let startRay = camera.getPickRay(startPos, look3DStartRay);\n  let endRay = camera.getPickRay(endPos, look3DEndRay);\n  let angle = 0.0;\n  let start;\n  let end;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    start = startRay.origin;\n    end = endRay.origin;\n\n    Cartesian3.add(camera.direction, start, start);\n    Cartesian3.add(camera.direction, end, end);\n\n    Cartesian3.subtract(start, camera.position, start);\n    Cartesian3.subtract(end, camera.position, end);\n\n    Cartesian3.normalize(start, start);\n    Cartesian3.normalize(end, end);\n  } else {\n    start = startRay.direction;\n    end = endRay.direction;\n  }\n\n  let dot = Cartesian3.dot(start, end);\n  if (dot < 1.0) {\n    // dot is in [0, 1]\n    angle = Math.acos(dot);\n  }\n\n  angle = movement.startPosition.x > movement.endPosition.x ? -angle : angle;\n\n  const horizontalRotationAxis = controller._horizontalRotationAxis;\n  if (defined(rotationAxis)) {\n    camera.look(rotationAxis, -angle);\n  } else if (defined(horizontalRotationAxis)) {\n    camera.look(horizontalRotationAxis, -angle);\n  } else {\n    camera.lookLeft(angle);\n  }\n\n  startPos.x = 0.0;\n  startPos.y = movement.startPosition.y;\n  endPos.x = 0.0;\n  endPos.y = movement.endPosition.y;\n\n  startRay = camera.getPickRay(startPos, look3DStartRay);\n  endRay = camera.getPickRay(endPos, look3DEndRay);\n  angle = 0.0;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    start = startRay.origin;\n    end = endRay.origin;\n\n    Cartesian3.add(camera.direction, start, start);\n    Cartesian3.add(camera.direction, end, end);\n\n    Cartesian3.subtract(start, camera.position, start);\n    Cartesian3.subtract(end, camera.position, end);\n\n    Cartesian3.normalize(start, start);\n    Cartesian3.normalize(end, end);\n  } else {\n    start = startRay.direction;\n    end = endRay.direction;\n  }\n\n  dot = Cartesian3.dot(start, end);\n  if (dot < 1.0) {\n    // dot is in [0, 1]\n    angle = Math.acos(dot);\n  }\n  angle = movement.startPosition.y > movement.endPosition.y ? -angle : angle;\n\n  rotationAxis = rotationAxis ?? horizontalRotationAxis;\n  if (defined(rotationAxis)) {\n    const direction = camera.direction;\n    const negativeRotationAxis = Cartesian3.negate(\n      rotationAxis,\n      look3DNegativeRot,\n    );\n    const northParallel = Cartesian3.equalsEpsilon(\n      direction,\n      rotationAxis,\n      CesiumMath.EPSILON2,\n    );\n    const southParallel = Cartesian3.equalsEpsilon(\n      direction,\n      negativeRotationAxis,\n      CesiumMath.EPSILON2,\n    );\n    if (!northParallel && !southParallel) {\n      dot = Cartesian3.dot(direction, rotationAxis);\n      let angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle > 0 && angle > angleToAxis) {\n        angle = angleToAxis - CesiumMath.EPSILON4;\n      }\n\n      dot = Cartesian3.dot(direction, negativeRotationAxis);\n      angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle < 0 && -angle > angleToAxis) {\n        angle = -angleToAxis + CesiumMath.EPSILON4;\n      }\n\n      const tangent = Cartesian3.cross(rotationAxis, direction, look3DTan);\n      camera.look(tangent, angle);\n    } else if ((northParallel && angle < 0) || (southParallel && angle > 0)) {\n      camera.look(camera.right, -angle);\n    }\n  } else {\n    camera.lookUp(angle);\n  }\n}\n\nfunction update3D(controller) {\n  reactToInput(\n    controller,\n    controller.enableRotate,\n    controller.rotateEventTypes,\n    spin3D,\n    controller.inertiaSpin,\n    \"_lastInertiaSpinMovement\",\n  );\n  reactToInput(\n    controller,\n    controller.enableZoom,\n    controller.zoomEventTypes,\n    zoom3D,\n    controller.inertiaZoom,\n    \"_lastInertiaZoomMovement\",\n  );\n  reactToInput(\n    controller,\n    controller.enableTilt,\n    controller.tiltEventTypes,\n    tilt3D,\n    controller.inertiaSpin,\n    \"_lastInertiaTiltMovement\",\n  );\n  reactToInput(\n    controller,\n    controller.enableLook,\n    controller.lookEventTypes,\n    look3D,\n  );\n}\n\nconst scratchAdjustHeightTransform = new Matrix4();\nconst scratchAdjustHeightCartographic = new Cartographic();\n\nfunction adjustHeightForTerrain(controller, cameraChanged) {\n  controller._adjustedHeightForTerrain = true;\n\n  const scene = controller._scene;\n  const mode = scene.mode;\n\n  if (mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  const camera = scene.camera;\n  const ellipsoid = scene.ellipsoid ?? Ellipsoid.WGS84;\n  const projection = scene.mapProjection;\n\n  let transform;\n  let mag;\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    transform = Matrix4.clone(camera.transform, scratchAdjustHeightTransform);\n    mag = Cartesian3.magnitude(camera.position);\n    camera._setTransform(Matrix4.IDENTITY);\n  }\n\n  const cartographic = scratchAdjustHeightCartographic;\n  if (mode === SceneMode.SCENE3D) {\n    ellipsoid.cartesianToCartographic(camera.position, cartographic);\n  } else {\n    projection.unproject(camera.position, cartographic);\n  }\n\n  let heightUpdated = false;\n  if (cartographic.height < controller._minimumCollisionTerrainHeight) {\n    const globeHeight = controller._scene.globeHeight;\n    if (defined(globeHeight)) {\n      const height = globeHeight + controller.minimumZoomDistance;\n      const difference = globeHeight - controller._lastGlobeHeight;\n      const percentDifference = difference / controller._lastGlobeHeight;\n\n      // Unless the camera has been moved by user input, to avoid big jumps during tile loads\n      // only make height updates when the globe height has been fairly stable across several frames\n      if (\n        cartographic.height < height &&\n        (cameraChanged || Math.abs(percentDifference) <= 0.1)\n      ) {\n        cartographic.height = height;\n        if (mode === SceneMode.SCENE3D) {\n          ellipsoid.cartographicToCartesian(cartographic, camera.position);\n        } else {\n          projection.project(cartographic, camera.position);\n        }\n        heightUpdated = true;\n      }\n\n      if (cameraChanged || Math.abs(percentDifference) <= 0.1) {\n        controller._lastGlobeHeight = globeHeight;\n      } else {\n        controller._lastGlobeHeight += difference * 0.1;\n      }\n    }\n  }\n\n  if (defined(transform)) {\n    camera._setTransform(transform);\n    if (heightUpdated) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.negate(camera.position, camera.direction);\n      Cartesian3.multiplyByScalar(\n        camera.position,\n        Math.max(mag, controller.minimumZoomDistance),\n        camera.position,\n      );\n      Cartesian3.normalize(camera.direction, camera.direction);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.cross(camera.right, camera.direction, camera.up);\n    }\n  }\n}\n\n/**\n * @private\n */\nScreenSpaceCameraController.prototype.onMap = function () {\n  const scene = this._scene;\n  const mode = scene.mode;\n  const camera = scene.camera;\n\n  if (mode === SceneMode.COLUMBUS_VIEW) {\n    return (\n      Math.abs(camera.position.x) - this._maxCoord.x < 0 &&\n      Math.abs(camera.position.y) - this._maxCoord.y < 0\n    );\n  }\n\n  return true;\n};\n\nconst scratchPreviousPosition = new Cartesian3();\nconst scratchPreviousDirection = new Cartesian3();\n\n/**\n * @private\n */\nScreenSpaceCameraController.prototype.update = function () {\n  const scene = this._scene;\n  const { camera, globe, mode } = scene;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    this._globe = undefined;\n    this._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  } else {\n    this._globe = globe;\n    this._ellipsoid = scene.ellipsoid ?? Ellipsoid.default;\n  }\n\n  const { verticalExaggeration, verticalExaggerationRelativeHeight } = scene;\n  this._minimumCollisionTerrainHeight = VerticalExaggeration.getHeight(\n    this.minimumCollisionTerrainHeight,\n    verticalExaggeration,\n    verticalExaggerationRelativeHeight,\n  );\n  this._minimumPickingTerrainHeight = VerticalExaggeration.getHeight(\n    this.minimumPickingTerrainHeight,\n    verticalExaggeration,\n    verticalExaggerationRelativeHeight,\n  );\n  this._minimumTrackBallHeight = VerticalExaggeration.getHeight(\n    this.minimumTrackBallHeight,\n    verticalExaggeration,\n    verticalExaggerationRelativeHeight,\n  );\n\n  this._cameraUnderground = scene.cameraUnderground && defined(this._globe);\n\n  const radius = this._ellipsoid.maximumRadius;\n  this._rotateFactor = 1.0 / radius;\n  this._rotateRateRangeAdjustment = radius;\n\n  this._adjustedHeightForTerrain = false;\n  const previousPosition = Cartesian3.clone(\n    camera.positionWC,\n    scratchPreviousPosition,\n  );\n  const previousDirection = Cartesian3.clone(\n    camera.directionWC,\n    scratchPreviousDirection,\n  );\n\n  if (mode === SceneMode.SCENE2D) {\n    update2D(this);\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    this._horizontalRotationAxis = Cartesian3.UNIT_Z;\n    updateCV(this);\n  } else if (mode === SceneMode.SCENE3D) {\n    this._horizontalRotationAxis = undefined;\n    update3D(this);\n  }\n\n  if (this.enableCollisionDetection && !this._adjustedHeightForTerrain) {\n    // Adjust the camera height if the camera moved at all (user input or inertia) and an action didn't already adjust the camera height\n    const cameraChanged =\n      !Cartesian3.equals(previousPosition, camera.positionWC) ||\n      !Cartesian3.equals(previousDirection, camera.directionWC);\n    adjustHeightForTerrain(this, cameraChanged);\n  }\n\n  this._aggregator.reset();\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ScreenSpaceCameraController#destroy\n */\nScreenSpaceCameraController.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes mouse listeners held by this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * controller = controller && controller.destroy();\n *\n * @see ScreenSpaceCameraController#isDestroyed\n */\nScreenSpaceCameraController.prototype.destroy = function () {\n  this._tweens.removeAll();\n  this._aggregator = this._aggregator && this._aggregator.destroy();\n  return destroyObject(this);\n};\nexport default ScreenSpaceCameraController;\n"],"mappings":"AAAA,OAAOA,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,aAAa,MAAM,0BAA0B;AACpD,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,SAAS,MAAM,sBAAsB;AAC5C,OAAOC,gBAAgB,MAAM,6BAA6B;AAC1D,OAAOC,iBAAiB,MAAM,8BAA8B;AAC5D,OAAOC,qBAAqB,MAAM,kCAAkC;AACpE,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,mBAAmB,MAAM,gCAAgC;AAChE,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,GAAG,MAAM,gBAAgB;AAChC,OAAOC,oBAAoB,MAAM,iCAAiC;AAClE,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,qBAAqB,MAAM,4BAA4B;AAC9D,OAAOC,eAAe,MAAM,sBAAsB;AAClD,OAAOC,SAAS,MAAM,gBAAgB;AACtC,OAAOC,SAAS,MAAM,gBAAgB;AACtC,OAAOC,eAAe,MAAM,sBAAsB;AAClD,OAAOC,eAAe,MAAM,sBAAsB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,2BAA2BA,CAACC,KAAK,EAAE;EAC1C;EACA,IAAI,CAACvB,OAAO,CAACuB,KAAK,CAAC,EAAE;IACnB,MAAM,IAAIrB,cAAc,CAAC,oBAAoB,CAAC;EAChD;EACA;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACsB,YAAY,GAAG,IAAI;EACxB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,eAAe,GAAG,IAAI;EAC3B;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAG,IAAI;EACtB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,YAAY,GAAG,IAAI;EACxB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAG,IAAI;EACtB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAG,IAAI;EACtB;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,WAAW,GAAG,GAAG;EACtB;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,gBAAgB,GAAG,GAAG;EAC3B;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,WAAW,GAAG,GAAG;EACtB;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,oBAAoB,GAAG,GAAG;EAC/B;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,mBAAmB,GAAG,GAAG;EAC9B;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,mBAAmB,GAAG,GAAG;EAC9B;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,mBAAmB,GAAGC,MAAM,CAACC,iBAAiB;;EAEnD;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAG,GAAG;;EAErB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,mBAAmB,GAAGvB,eAAe,CAACwB,SAAS;EACpD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,cAAc,GAAG,CACpBzB,eAAe,CAAC0B,UAAU,EAC1B1B,eAAe,CAAC2B,KAAK,EACrB3B,eAAe,CAAC4B,KAAK,CACtB;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,gBAAgB,GAAG7B,eAAe,CAACwB,SAAS;EACjD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACM,cAAc,GAAG,CACpB9B,eAAe,CAAC+B,WAAW,EAC3B/B,eAAe,CAAC4B,KAAK,EACrB;IACEI,SAAS,EAAEhC,eAAe,CAA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}