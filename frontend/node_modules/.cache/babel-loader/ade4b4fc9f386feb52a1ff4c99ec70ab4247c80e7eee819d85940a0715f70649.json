{"ast":null,"code":"import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport Simon1994PlanetaryPositions from \"../Core/Simon1994PlanetaryPositions.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport SunLight from \"../Scene/SunLight.js\";\n\n/**\n * @private\n * @constructor\n */\nfunction UniformState() {\n  /**\n   * @type {Texture}\n   */\n  this.globeDepthTexture = undefined;\n  /**\n   * @type {number}\n   */\n  this.gamma = undefined;\n  this._viewport = new BoundingRectangle();\n  this._viewportCartesian4 = new Cartesian4();\n  this._viewportDirty = false;\n  this._viewportOrthographicMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._viewportTransformation = Matrix4.clone(Matrix4.IDENTITY);\n  this._model = Matrix4.clone(Matrix4.IDENTITY);\n  this._view = Matrix4.clone(Matrix4.IDENTITY);\n  this._inverseView = Matrix4.clone(Matrix4.IDENTITY);\n  this._projection = Matrix4.clone(Matrix4.IDENTITY);\n  this._infiniteProjection = Matrix4.clone(Matrix4.IDENTITY);\n  this._entireFrustum = new Cartesian2();\n  this._currentFrustum = new Cartesian2();\n  this._frustumPlanes = new Cartesian4();\n  this._farDepthFromNearPlusOne = undefined;\n  this._log2FarDepthFromNearPlusOne = undefined;\n  this._oneOverLog2FarDepthFromNearPlusOne = undefined;\n  this._frameState = undefined;\n  this._temeToPseudoFixed = Matrix3.clone(Matrix4.IDENTITY);\n\n  // Derived members\n  this._view3DDirty = true;\n  this._view3D = new Matrix4();\n  this._inverseView3DDirty = true;\n  this._inverseView3D = new Matrix4();\n  this._inverseModelDirty = true;\n  this._inverseModel = new Matrix4();\n  this._inverseTransposeModelDirty = true;\n  this._inverseTransposeModel = new Matrix3();\n  this._viewRotation = new Matrix3();\n  this._inverseViewRotation = new Matrix3();\n  this._viewRotation3D = new Matrix3();\n  this._inverseViewRotation3D = new Matrix3();\n  this._inverseProjectionDirty = true;\n  this._inverseProjection = new Matrix4();\n  this._modelViewDirty = true;\n  this._modelView = new Matrix4();\n  this._modelView3DDirty = true;\n  this._modelView3D = new Matrix4();\n  this._modelViewRelativeToEyeDirty = true;\n  this._modelViewRelativeToEye = new Matrix4();\n  this._inverseModelViewDirty = true;\n  this._inverseModelView = new Matrix4();\n  this._inverseModelView3DDirty = true;\n  this._inverseModelView3D = new Matrix4();\n  this._viewProjectionDirty = true;\n  this._viewProjection = new Matrix4();\n  this._inverseViewProjectionDirty = true;\n  this._inverseViewProjection = new Matrix4();\n  this._modelViewProjectionDirty = true;\n  this._modelViewProjection = new Matrix4();\n  this._inverseModelViewProjectionDirty = true;\n  this._inverseModelViewProjection = new Matrix4();\n  this._modelViewProjectionRelativeToEyeDirty = true;\n  this._modelViewProjectionRelativeToEye = new Matrix4();\n  this._modelViewInfiniteProjectionDirty = true;\n  this._modelViewInfiniteProjection = new Matrix4();\n  this._normalDirty = true;\n  this._normal = new Matrix3();\n  this._normal3DDirty = true;\n  this._normal3D = new Matrix3();\n  this._inverseNormalDirty = true;\n  this._inverseNormal = new Matrix3();\n  this._inverseNormal3DDirty = true;\n  this._inverseNormal3D = new Matrix3();\n  this._encodedCameraPositionMCDirty = true;\n  this._encodedCameraPositionMC = new EncodedCartesian3();\n  this._cameraPosition = new Cartesian3();\n  this._sunPositionWC = new Cartesian3();\n  this._sunPositionColumbusView = new Cartesian3();\n  this._sunDirectionWC = new Cartesian3();\n  this._sunDirectionEC = new Cartesian3();\n  this._moonDirectionEC = new Cartesian3();\n  this._lightDirectionWC = new Cartesian3();\n  this._lightDirectionEC = new Cartesian3();\n  this._lightColor = new Cartesian3();\n  this._lightColorHdr = new Cartesian3();\n  this._pass = undefined;\n  this._mode = undefined;\n  this._mapProjection = undefined;\n  this._ellipsoid = undefined;\n  this._cameraDirection = new Cartesian3();\n  this._cameraRight = new Cartesian3();\n  this._cameraUp = new Cartesian3();\n  this._frustum2DWidth = 0.0;\n  this._eyeHeight = 0.0;\n  this._eyeHeight2D = new Cartesian2();\n  this._eyeEllipsoidNormalEC = new Cartesian3();\n  this._eyeEllipsoidCurvature = new Cartesian2();\n  this._modelToEnu = new Matrix4();\n  this._enuToModel = new Matrix4();\n  this._pixelRatio = 1.0;\n  this._orthographicIn3D = false;\n  this._backgroundColor = new Color();\n  this._brdfLut = undefined;\n  this._environmentMap = undefined;\n  this._sphericalHarmonicCoefficients = undefined;\n  this._specularEnvironmentMaps = undefined;\n  this._specularEnvironmentMapsMaximumLOD = undefined;\n  this._fogDensity = undefined;\n  this._fogVisualDensityScalar = undefined;\n  this._fogMinimumBrightness = undefined;\n  this._atmosphereHsbShift = undefined;\n  this._atmosphereLightIntensity = undefined;\n  this._atmosphereRayleighCoefficient = new Cartesian3();\n  this._atmosphereRayleighScaleHeight = new Cartesian3();\n  this._atmosphereMieCoefficient = new Cartesian3();\n  this._atmosphereMieScaleHeight = undefined;\n  this._atmosphereMieAnisotropy = undefined;\n  this._atmosphereDynamicLighting = undefined;\n  this._invertClassificationColor = undefined;\n  this._splitPosition = 0.0;\n  this._pixelSizePerMeter = undefined;\n  this._geometricToleranceOverMeter = undefined;\n  this._minimumDisableDepthTestDistance = undefined;\n}\nObject.defineProperties(UniformState.prototype, {\n  /**\n   * @memberof UniformState.prototype\n   * @type {FrameState}\n   * @readonly\n   */\n  frameState: {\n    get: function () {\n      return this._frameState;\n    }\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @type {BoundingRectangle}\n   */\n  viewport: {\n    get: function () {\n      return this._viewport;\n    },\n    set: function (viewport) {\n      if (!BoundingRectangle.equals(viewport, this._viewport)) {\n        BoundingRectangle.clone(viewport, this._viewport);\n        const v = this._viewport;\n        const vc = this._viewportCartesian4;\n        vc.x = v.x;\n        vc.y = v.y;\n        vc.z = v.width;\n        vc.w = v.height;\n        this._viewportDirty = true;\n      }\n    }\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @private\n   */\n  viewportCartesian4: {\n    get: function () {\n      return this._viewportCartesian4;\n    }\n  },\n  viewportOrthographic: {\n    get: function () {\n      cleanViewport(this);\n      return this._viewportOrthographicMatrix;\n    }\n  },\n  viewportTransformation: {\n    get: function () {\n      cleanViewport(this);\n      return this._viewportTransformation;\n    }\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  model: {\n    get: function () {\n      return this._model;\n    },\n    set: function (matrix) {\n      Matrix4.clone(matrix, this._model);\n      this._modelView3DDirty = true;\n      this._inverseModelView3DDirty = true;\n      this._inverseModelDirty = true;\n      this._inverseTransposeModelDirty = true;\n      this._modelViewDirty = true;\n      this._inverseModelViewDirty = true;\n      this._modelViewRelativeToEyeDirty = true;\n      this._inverseModelViewDirty = true;\n      this._modelViewProjectionDirty = true;\n      this._inverseModelViewProjectionDirty = true;\n      this._modelViewProjectionRelativeToEyeDirty = true;\n      this._modelViewInfiniteProjectionDirty = true;\n      this._normalDirty = true;\n      this._inverseNormalDirty = true;\n      this._normal3DDirty = true;\n      this._inverseNormal3DDirty = true;\n      this._encodedCameraPositionMCDirty = true;\n    }\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModel: {\n    get: function () {\n      if (this._inverseModelDirty) {\n        this._inverseModelDirty = false;\n        Matrix4.inverse(this._model, this._inverseModel);\n      }\n      return this._inverseModel;\n    }\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @private\n   */\n  inverseTransposeModel: {\n    get: function () {\n      const m = this._inverseTransposeModel;\n      if (this._inverseTransposeModelDirty) {\n        this._inverseTransposeModelDirty = false;\n        Matrix4.getMatrix3(this.inverseModel, m);\n        Matrix3.transpose(m, m);\n      }\n      return m;\n    }\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  view: {\n    get: function () {\n      return this._view;\n    }\n  },\n  /**\n   * The 3D view matrix.  In 3D mode, this is identical to {@link UniformState#view},\n   * but in 2D and Columbus View it is a synthetic matrix based on the equivalent position\n   * of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  view3D: {\n    get: function () {\n      updateView3D(this);\n      return this._view3D;\n    }\n  },\n  /**\n   * The 3x3 rotation matrix of the current view matrix ({@link UniformState#view}).\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  viewRotation: {\n    get: function () {\n      updateView3D(this);\n      return this._viewRotation;\n    }\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  viewRotation3D: {\n    get: function () {\n      updateView3D(this);\n      return this._viewRotation3D;\n    }\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseView: {\n    get: function () {\n      return this._inverseView;\n    }\n  },\n  /**\n   * the 4x4 inverse-view matrix that transforms from eye to 3D world coordinates.  In 3D mode, this is\n   * identical to {@link UniformState#inverseView}, but in 2D and Columbus View it is a synthetic matrix\n   * based on the equivalent position of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseView3D: {\n    get: function () {\n      updateInverseView3D(this);\n      return this._inverseView3D;\n    }\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseViewRotation: {\n    get: function () {\n      return this._inverseViewRotation;\n    }\n  },\n  /**\n   * The 3x3 rotation matrix of the current 3D inverse-view matrix ({@link UniformState#inverseView3D}).\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseViewRotation3D: {\n    get: function () {\n      updateInverseView3D(this);\n      return this._inverseViewRotation3D;\n    }\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  projection: {\n    get: function () {\n      return this._projection;\n    }\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseProjection: {\n    get: function () {\n      cleanInverseProjection(this);\n      return this._inverseProjection;\n    }\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  infiniteProjection: {\n    get: function () {\n      return this._infiniteProjection;\n    }\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelView: {\n    get: function () {\n      cleanModelView(this);\n      return this._modelView;\n    }\n  },\n  /**\n   * The 3D model-view matrix.  In 3D mode, this is equivalent to {@link UniformState#modelView}.  In 2D and\n   * Columbus View, however, it is a synthetic matrix based on the equivalent position of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelView3D: {\n    get: function () {\n      cleanModelView3D(this);\n      return this._modelView3D;\n    }\n  },\n  /**\n   * Model-view relative to eye matrix.\n   *\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewRelativeToEye: {\n    get: function () {\n      cleanModelViewRelativeToEye(this);\n      return this._modelViewRelativeToEye;\n    }\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModelView: {\n    get: function () {\n      cleanInverseModelView(this);\n      return this._inverseModelView;\n    }\n  },\n  /**\n   * The inverse of the 3D model-view matrix.  In 3D mode, this is equivalent to {@link UniformState#inverseModelView}.\n   * In 2D and Columbus View, however, it is a synthetic matrix based on the equivalent position of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModelView3D: {\n    get: function () {\n      cleanInverseModelView3D(this);\n      return this._inverseModelView3D;\n    }\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  viewProjection: {\n    get: function () {\n      cleanViewProjection(this);\n      return this._viewProjection;\n    }\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseViewProjection: {\n    get: function () {\n      cleanInverseViewProjection(this);\n      return this._inverseViewProjection;\n    }\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewProjection: {\n    get: function () {\n      cleanModelViewProjection(this);\n      return this._modelViewProjection;\n    }\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModelViewProjection: {\n    get: function () {\n      cleanInverseModelViewProjection(this);\n      return this._inverseModelViewProjection;\n    }\n  },\n  /**\n   * Model-view-projection relative to eye matrix.\n   *\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewProjectionRelativeToEye: {\n    get: function () {\n      cleanModelViewProjectionRelativeToEye(this);\n      return this._modelViewProjectionRelativeToEye;\n    }\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewInfiniteProjection: {\n    get: function () {\n      cleanModelViewInfiniteProjection(this);\n      return this._modelViewInfiniteProjection;\n    }\n  },\n  /**\n   * A 3x3 normal transformation matrix that transforms normal vectors in model coordinates to\n   * eye coordinates.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  normal: {\n    get: function () {\n      cleanNormal(this);\n      return this._normal;\n    }\n  },\n  /**\n   * A 3x3 normal transformation matrix that transforms normal vectors in 3D model\n   * coordinates to eye coordinates.  In 3D mode, this is identical to\n   * {@link UniformState#normal}, but in 2D and Columbus View it represents the normal transformation\n   * matrix as if the camera were at an equivalent location in 3D mode.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  normal3D: {\n    get: function () {\n      cleanNormal3D(this);\n      return this._normal3D;\n    }\n  },\n  /**\n   * An inverse 3x3 normal transformation matrix that transforms normal vectors in model coordinates\n   * to eye coordinates.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseNormal: {\n    get: function () {\n      cleanInverseNormal(this);\n      return this._inverseNormal;\n    }\n  },\n  /**\n   * An inverse 3x3 normal transformation matrix that transforms normal vectors in eye coordinates\n   * to 3D model coordinates.  In 3D mode, this is identical to\n   * {@link UniformState#inverseNormal}, but in 2D and Columbus View it represents the normal transformation\n   * matrix as if the camera were at an equivalent location in 3D mode.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseNormal3D: {\n    get: function () {\n      cleanInverseNormal3D(this);\n      return this._inverseNormal3D;\n    }\n  },\n  /**\n   * The near distance (<code>x</code>) and the far distance (<code>y</code>) of the frustum defined by the camera.\n   * This is the largest possible frustum, not an individual frustum used for multi-frustum rendering.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  entireFrustum: {\n    get: function () {\n      return this._entireFrustum;\n    }\n  },\n  /**\n   * The near distance (<code>x</code>) and the far distance (<code>y</code>) of the frustum defined by the camera.\n   * This is the individual frustum used for multi-frustum rendering.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  currentFrustum: {\n    get: function () {\n      return this._currentFrustum;\n    }\n  },\n  /**\n   * The distances to the frustum planes. The top, bottom, left and right distances are\n   * the x, y, z, and w components, respectively.\n   * @memberof UniformState.prototype\n   * @type {Cartesian4}\n   */\n  frustumPlanes: {\n    get: function () {\n      return this._frustumPlanes;\n    }\n  },\n  /**\n   * The far plane's distance from the near plane, plus 1.0.\n   *\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  farDepthFromNearPlusOne: {\n    get: function () {\n      return this._farDepthFromNearPlusOne;\n    }\n  },\n  /**\n   * The log2 of {@link UniformState#farDepthFromNearPlusOne}.\n   *\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  log2FarDepthFromNearPlusOne: {\n    get: function () {\n      return this._log2FarDepthFromNearPlusOne;\n    }\n  },\n  /**\n   * 1.0 divided by {@link UniformState#log2FarDepthFromNearPlusOne}.\n   *\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  oneOverLog2FarDepthFromNearPlusOne: {\n    get: function () {\n      return this._oneOverLog2FarDepthFromNearPlusOne;\n    }\n  },\n  /**\n   * The height in meters of the eye (camera) above or below the ellipsoid.\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  eyeHeight: {\n    get: function () {\n      return this._eyeHeight;\n    }\n  },\n  /**\n   * The height (<code>x</code>) and the height squared (<code>y</code>)\n   * in meters of the eye (camera) above the 2D world plane. This uniform is only valid\n   * when the {@link SceneMode} is <code>SCENE2D</code>.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  eyeHeight2D: {\n    get: function () {\n      return this._eyeHeight2D;\n    }\n  },\n  /**\n   * The ellipsoid surface normal at the camera position, in model coordinates.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  eyeEllipsoidNormalEC: {\n    get: function () {\n      return this._eyeEllipsoidNormalEC;\n    }\n  },\n  /**\n   * The ellipsoid radii of curvature at the camera position.\n   * The .x component is the prime vertical radius, .y is the meridional.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  eyeEllipsoidCurvature: {\n    get: function () {\n      return this._eyeEllipsoidCurvature;\n    }\n  },\n  /**\n   * A transform from model coordinates to an east-north-up coordinate system\n   * centered at the position on the ellipsoid below the camera\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelToEnu: {\n    get: function () {\n      return this._modelToEnu;\n    }\n  },\n  /**\n   * The inverse of {@link UniformState.prototype.modelToEnu}\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  enuToModel: {\n    get: function () {\n      return this._enuToModel;\n    }\n  },\n  /**\n   * The sun position in 3D world coordinates at the current scene time.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunPositionWC: {\n    get: function () {\n      return this._sunPositionWC;\n    }\n  },\n  /**\n   * The sun position in 2D world coordinates at the current scene time.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunPositionColumbusView: {\n    get: function () {\n      return this._sunPositionColumbusView;\n    }\n  },\n  /**\n   * A normalized vector to the sun in 3D world coordinates at the current scene time.  Even in 2D or\n   * Columbus View mode, this returns the direction to the sun in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunDirectionWC: {\n    get: function () {\n      return this._sunDirectionWC;\n    }\n  },\n  /**\n   * A normalized vector to the sun in eye coordinates at the current scene time.  In 3D mode, this\n   * returns the actual vector from the camera position to the sun position.  In 2D and Columbus View, it returns\n   * the vector from the equivalent 3D camera position to the position of the sun in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunDirectionEC: {\n    get: function () {\n      return this._sunDirectionEC;\n    }\n  },\n  /**\n   * A normalized vector to the moon in eye coordinates at the current scene time.  In 3D mode, this\n   * returns the actual vector from the camera position to the moon position.  In 2D and Columbus View, it returns\n   * the vector from the equivalent 3D camera position to the position of the moon in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  moonDirectionEC: {\n    get: function () {\n      return this._moonDirectionEC;\n    }\n  },\n  /**\n   * A normalized vector to the scene's light source in 3D world coordinates.  Even in 2D or\n   * Columbus View mode, this returns the direction to the light in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightDirectionWC: {\n    get: function () {\n      return this._lightDirectionWC;\n    }\n  },\n  /**\n   * A normalized vector to the scene's light source in eye coordinates.  In 3D mode, this\n   * returns the actual vector from the camera position to the light.  In 2D and Columbus View, it returns\n   * the vector from the equivalent 3D camera position in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightDirectionEC: {\n    get: function () {\n      return this._lightDirectionEC;\n    }\n  },\n  /**\n   * The color of light emitted by the scene's light source. This is equivalent to the light\n   * color multiplied by the light intensity limited to a maximum luminance of 1.0 suitable\n   * for non-HDR lighting.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightColor: {\n    get: function () {\n      return this._lightColor;\n    }\n  },\n  /**\n   * The high dynamic range color of light emitted by the scene's light source. This is equivalent to\n   * the light color multiplied by the light intensity suitable for HDR lighting.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightColorHdr: {\n    get: function () {\n      return this._lightColorHdr;\n    }\n  },\n  /**\n   * The high bits of the camera position.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  encodedCameraPositionMCHigh: {\n    get: function () {\n      cleanEncodedCameraPositionMC(this);\n      return this._encodedCameraPositionMC.high;\n    }\n  },\n  /**\n   * The low bits of the camera position.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  encodedCameraPositionMCLow: {\n    get: function () {\n      cleanEncodedCameraPositionMC(this);\n      return this._encodedCameraPositionMC.low;\n    }\n  },\n  /**\n   * A 3x3 matrix that transforms from True Equator Mean Equinox (TEME) axes to the\n   * pseudo-fixed axes at the Scene's current time.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  temeToPseudoFixedMatrix: {\n    get: function () {\n      return this._temeToPseudoFixed;\n    }\n  },\n  /**\n   * Gets the scaling factor for transforming from the canvas\n   * pixel space to canvas coordinate space.\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  pixelRatio: {\n    get: function () {\n      return this._pixelRatio;\n    }\n  },\n  /**\n   * A scalar used to mix a color with the fog color based on the distance to the camera.\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  fogDensity: {\n    get: function () {\n      return this._fogDensity;\n    }\n  },\n  /**\n   * A scalar used to mix a color with the fog color based on the distance to the camera.\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  fogVisualDensityScalar: {\n    get: function () {\n      return this._fogVisualDensityScalar;\n    }\n  },\n  /**\n   * A scalar used as a minimum value when brightening fog\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  fogMinimumBrightness: {\n    get: function () {\n      return this._fogMinimumBrightness;\n    }\n  },\n  /**\n   * A color shift to apply to the atmosphere color in HSB.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  atmosphereHsbShift: {\n    get: function () {\n      return this._atmosphereHsbShift;\n    }\n  },\n  /**\n   * The intensity of the light that is used for computing the atmosphere color\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  atmosphereLightIntensity: {\n    get: function () {\n      return this._atmosphereLightIntensity;\n    }\n  },\n  /**\n   * The Rayleigh scattering coefficient used in the atmospheric scattering equations for the sky atmosphere.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  atmosphereRayleighCoefficient: {\n    get: function () {\n      return this._atmosphereRayleighCoefficient;\n    }\n  },\n  /**\n   * The Rayleigh scale height used in the atmospheric scattering equations for the sky atmosphere, in meters.\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  atmosphereRayleighScaleHeight: {\n    get: function () {\n      return this._atmosphereRayleighScaleHeight;\n    }\n  },\n  /**\n   * The Mie scattering coefficient used in the atmospheric scattering equations for the sky atmosphere.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  atmosphereMieCoefficient: {\n    get: function () {\n      return this._atmosphereMieCoefficient;\n    }\n  },\n  /**\n   * The Mie scale height used in the atmospheric scattering equations for the sky atmosphere, in meters.\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  atmosphereMieScaleHeight: {\n    get: function () {\n      return this._atmosphereMieScaleHeight;\n    }\n  },\n  /**\n   * The anisotropy of the medium to consider for Mie scattering.\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  atmosphereMieAnisotropy: {\n    get: function () {\n      return this._atmosphereMieAnisotropy;\n    }\n  },\n  /**\n   * Which light source to use for dynamically lighting the atmosphere\n   *\n   * @memberof UniformState.prototype\n   * @type {DynamicAtmosphereLightingType}\n   */\n  atmosphereDynamicLighting: {\n    get: function () {\n      return this._atmosphereDynamicLighting;\n    }\n  },\n  /**\n   * A scalar that represents the geometric tolerance per meter\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  geometricToleranceOverMeter: {\n    get: function () {\n      return this._geometricToleranceOverMeter;\n    }\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @type {Pass}\n   */\n  pass: {\n    get: function () {\n      return this._pass;\n    }\n  },\n  /**\n   * The current background color\n   * @memberof UniformState.prototype\n   * @type {Color}\n   */\n  backgroundColor: {\n    get: function () {\n      return this._backgroundColor;\n    }\n  },\n  /**\n   * The look up texture used to find the BRDF for a material\n   * @memberof UniformState.prototype\n   * @type {Texture}\n   */\n  brdfLut: {\n    get: function () {\n      return this._brdfLut;\n    }\n  },\n  /**\n   * The environment map of the scene\n   * @memberof UniformState.prototype\n   * @type {CubeMap}\n   */\n  environmentMap: {\n    get: function () {\n      return this._environmentMap;\n    }\n  },\n  /**\n   * The spherical harmonic coefficients of the scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3[]}\n   */\n  sphericalHarmonicCoefficients: {\n    get: function () {\n      return this._sphericalHarmonicCoefficients;\n    }\n  },\n  /**\n   * The specular environment cube map of the scene.\n   * @memberof UniformState.prototype\n   * @type {Texture}\n   */\n  specularEnvironmentMaps: {\n    get: function () {\n      return this._specularEnvironmentMaps;\n    }\n  },\n  /**\n   * The maximum level-of-detail of the specular environment cube map of the scene.\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  specularEnvironmentMapsMaximumLOD: {\n    get: function () {\n      return this._specularEnvironmentMapsMaximumLOD;\n    }\n  },\n  /**\n   * The splitter position to use when rendering with a splitter. This will be in pixel coordinates relative to the canvas.\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  splitPosition: {\n    get: function () {\n      return this._splitPosition;\n    }\n  },\n  /**\n   * The distance from the camera at which to disable the depth test of billboards, labels and points\n   * to, for example, prevent clipping against terrain. When set to zero, the depth test should always\n   * be applied. When less than zero, the depth test should never be applied.\n   *\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  minimumDisableDepthTestDistance: {\n    get: function () {\n      return this._minimumDisableDepthTestDistance;\n    }\n  },\n  /**\n   * The highlight color of unclassified 3D Tiles.\n   *\n   * @memberof UniformState.prototype\n   * @type {Color}\n   */\n  invertClassificationColor: {\n    get: function () {\n      return this._invertClassificationColor;\n    }\n  },\n  /**\n   * Whether or not the current projection is orthographic in 3D.\n   *\n   * @memberOf UniformState.prototype\n   * @type {boolean}\n   */\n  orthographicIn3D: {\n    get: function () {\n      return this._orthographicIn3D;\n    }\n  },\n  /**\n   * The current ellipsoid.\n   *\n   * @memberOf UniformState.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid ?? Ellipsoid.default;\n    }\n  }\n});\nfunction setView(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._view);\n  Matrix4.getMatrix3(matrix, uniformState._viewRotation);\n  uniformState._view3DDirty = true;\n  uniformState._inverseView3DDirty = true;\n  uniformState._modelViewDirty = true;\n  uniformState._modelView3DDirty = true;\n  uniformState._modelViewRelativeToEyeDirty = true;\n  uniformState._inverseModelViewDirty = true;\n  uniformState._inverseModelView3DDirty = true;\n  uniformState._viewProjectionDirty = true;\n  uniformState._inverseViewProjectionDirty = true;\n  uniformState._modelViewProjectionDirty = true;\n  uniformState._modelViewProjectionRelativeToEyeDirty = true;\n  uniformState._modelViewInfiniteProjectionDirty = true;\n  uniformState._normalDirty = true;\n  uniformState._inverseNormalDirty = true;\n  uniformState._normal3DDirty = true;\n  uniformState._inverseNormal3DDirty = true;\n}\nfunction setInverseView(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._inverseView);\n  Matrix4.getMatrix3(matrix, uniformState._inverseViewRotation);\n}\nfunction setProjection(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._projection);\n  uniformState._inverseProjectionDirty = true;\n  uniformState._viewProjectionDirty = true;\n  uniformState._inverseViewProjectionDirty = true;\n  uniformState._modelViewProjectionDirty = true;\n  uniformState._modelViewProjectionRelativeToEyeDirty = true;\n}\nfunction setInfiniteProjection(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._infiniteProjection);\n  uniformState._modelViewInfiniteProjectionDirty = true;\n}\nconst surfacePositionScratch = new Cartesian3();\nconst enuTransformScratch = new Matrix4();\nfunction setCamera(uniformState, camera) {\n  Cartesian3.clone(camera.positionWC, uniformState._cameraPosition);\n  Cartesian3.clone(camera.directionWC, uniformState._cameraDirection);\n  Cartesian3.clone(camera.rightWC, uniformState._cameraRight);\n  Cartesian3.clone(camera.upWC, uniformState._cameraUp);\n  const ellipsoid = uniformState._ellipsoid;\n  let surfacePosition;\n  const positionCartographic = camera.positionCartographic;\n  if (!defined(positionCartographic)) {\n    uniformState._eyeHeight = -ellipsoid.maximumRadius;\n    if (Cartesian3.magnitude(camera.positionWC) > 0.0) {\n      uniformState._eyeEllipsoidNormalEC = Cartesian3.normalize(camera.positionWC, uniformState._eyeEllipsoidNormalEC);\n    }\n    surfacePosition = ellipsoid.scaleToGeodeticSurface(camera.positionWC, surfacePositionScratch);\n  } else {\n    uniformState._eyeHeight = positionCartographic.height;\n    uniformState._eyeEllipsoidNormalEC = ellipsoid.geodeticSurfaceNormalCartographic(positionCartographic, uniformState._eyeEllipsoidNormalEC);\n    surfacePosition = Cartesian3.fromRadians(positionCartographic.longitude, positionCartographic.latitude, 0.0, ellipsoid, surfacePositionScratch);\n  }\n  uniformState._encodedCameraPositionMCDirty = true;\n  if (!defined(surfacePosition)) {\n    return;\n  }\n  uniformState._eyeEllipsoidNormalEC = Matrix3.multiplyByVector(uniformState._viewRotation, uniformState._eyeEllipsoidNormalEC, uniformState._eyeEllipsoidNormalEC);\n  const enuToWorld = Transforms.eastNorthUpToFixedFrame(surfacePosition, ellipsoid, enuTransformScratch);\n  uniformState._enuToModel = Matrix4.multiplyTransformation(uniformState.inverseModel, enuToWorld, uniformState._enuToModel);\n  uniformState._modelToEnu = Matrix4.inverseTransformation(uniformState._enuToModel, uniformState._modelToEnu);\n  if (!CesiumMath.equalsEpsilon(ellipsoid._radii.x, ellipsoid._radii.y, CesiumMath.EPSILON15)) {\n    // Ellipsoid curvature calculations assume radii.x === radii.y as is true for WGS84\n    return;\n  }\n  uniformState._eyeEllipsoidCurvature = ellipsoid.getLocalCurvature(surfacePosition, uniformState._eyeEllipsoidCurvature);\n}\nconst transformMatrix = new Matrix3();\nconst sunCartographicScratch = new Cartographic();\nfunction setSunAndMoonDirections(uniformState, frameState) {\n  Transforms.computeIcrfToCentralBodyFixedMatrix(frameState.time, transformMatrix);\n  let position = Simon1994PlanetaryPositions.computeSunPositionInEarthInertialFrame(frameState.time, uniformState._sunPositionWC);\n  Matrix3.multiplyByVector(transformMatrix, position, position);\n  Cartesian3.normalize(position, uniformState._sunDirectionWC);\n  position = Matrix3.multiplyByVector(uniformState.viewRotation3D, position, uniformState._sunDirectionEC);\n  Cartesian3.normalize(position, position);\n  position = Simon1994PlanetaryPositions.computeMoonPositionInEarthInertialFrame(frameState.time, uniformState._moonDirectionEC);\n  Matrix3.multiplyByVector(transformMatrix, position, position);\n  Matrix3.multiplyByVector(uniformState.viewRotation3D, position, position);\n  Cartesian3.normalize(position, position);\n  const projection = frameState.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n  const sunCartographic = ellipsoid.cartesianToCartographic(uniformState._sunPositionWC, sunCartographicScratch);\n  projection.project(sunCartographic, uniformState._sunPositionColumbusView);\n}\n\n/**\n * Synchronizes the frustum's state with the camera state.  This is called\n * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms\n * are set to the right value.\n *\n * @param {object} camera The camera to synchronize with.\n */\nUniformState.prototype.updateCamera = function (camera) {\n  setView(this, camera.viewMatrix);\n  setInverseView(this, camera.inverseViewMatrix);\n  setCamera(this, camera);\n  this._entireFrustum.x = camera.frustum.near;\n  this._entireFrustum.y = camera.frustum.far;\n  this.updateFrustum(camera.frustum);\n  this._orthographicIn3D = this._mode !== SceneMode.SCENE2D && camera.frustum instanceof OrthographicFrustum;\n};\n\n/**\n * Synchronizes the frustum's state with the uniform state.  This is called\n * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms\n * are set to the right value.\n *\n * @param {object} frustum The frustum to synchronize with.\n */\nUniformState.prototype.updateFrustum = function (frustum) {\n  // If any frustum parameters have changed, calling the frustum.projectionMatrix\n  // getter will recompute the projection before it is copied.\n  setProjection(this, frustum.projectionMatrix);\n  if (defined(frustum.infiniteProjectionMatrix)) {\n    setInfiniteProjection(this, frustum.infiniteProjectionMatrix);\n  }\n  this._currentFrustum.x = frustum.near;\n  this._currentFrustum.y = frustum.far;\n  this._farDepthFromNearPlusOne = frustum.far - frustum.near + 1.0;\n  this._log2FarDepthFromNearPlusOne = CesiumMath.log2(this._farDepthFromNearPlusOne);\n  this._oneOverLog2FarDepthFromNearPlusOne = 1.0 / this._log2FarDepthFromNearPlusOne;\n  const offCenterFrustum = frustum.offCenterFrustum;\n  if (defined(offCenterFrustum)) {\n    frustum = offCenterFrustum;\n  }\n  this._frustumPlanes.x = frustum.top;\n  this._frustumPlanes.y = frustum.bottom;\n  this._frustumPlanes.z = frustum.left;\n  this._frustumPlanes.w = frustum.right;\n};\nUniformState.prototype.updatePass = function (pass) {\n  this._pass = pass;\n};\nconst EMPTY_ARRAY = [];\nconst defaultLight = new SunLight();\n\n/**\n * Synchronizes frame state with the uniform state.  This is called\n * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms\n * are set to the right value.\n *\n * @param {FrameState} frameState The frameState to synchronize with.\n */\nUniformState.prototype.update = function (frameState) {\n  this._mode = frameState.mode;\n  this._mapProjection = frameState.mapProjection;\n  this._ellipsoid = frameState.mapProjection.ellipsoid;\n  this._pixelRatio = frameState.pixelRatio;\n  const camera = frameState.camera;\n  this.updateCamera(camera);\n  if (frameState.mode === SceneMode.SCENE2D) {\n    this._frustum2DWidth = camera.frustum.right - camera.frustum.left;\n    this._eyeHeight2D.x = this._frustum2DWidth * 0.5;\n    this._eyeHeight2D.y = this._eyeHeight2D.x * this._eyeHeight2D.x;\n  } else {\n    this._frustum2DWidth = 0.0;\n    this._eyeHeight2D.x = 0.0;\n    this._eyeHeight2D.y = 0.0;\n  }\n  setSunAndMoonDirections(this, frameState);\n  const light = frameState.light ?? defaultLight;\n  if (light instanceof SunLight) {\n    this._lightDirectionWC = Cartesian3.clone(this._sunDirectionWC, this._lightDirectionWC);\n    this._lightDirectionEC = Cartesian3.clone(this._sunDirectionEC, this._lightDirectionEC);\n  } else {\n    this._lightDirectionWC = Cartesian3.normalize(Cartesian3.negate(light.direction, this._lightDirectionWC), this._lightDirectionWC);\n    this._lightDirectionEC = Matrix3.multiplyByVector(this.viewRotation3D, this._lightDirectionWC, this._lightDirectionEC);\n  }\n  const lightColor = light.color;\n  let lightColorHdr = Cartesian3.fromElements(lightColor.red, lightColor.green, lightColor.blue, this._lightColorHdr);\n  lightColorHdr = Cartesian3.multiplyByScalar(lightColorHdr, light.intensity, lightColorHdr);\n  const maximumComponent = Cartesian3.maximumComponent(lightColorHdr);\n  if (maximumComponent > 1.0) {\n    Cartesian3.divideByScalar(lightColorHdr, maximumComponent, this._lightColor);\n  } else {\n    Cartesian3.clone(lightColorHdr, this._lightColor);\n  }\n  const brdfLutGenerator = frameState.brdfLutGenerator;\n  const brdfLut = defined(brdfLutGenerator) ? brdfLutGenerator.colorTexture : undefined;\n  this._brdfLut = brdfLut;\n  this._environmentMap = frameState.environmentMap ?? frameState.context.defaultCubeMap;\n\n  // IE 11 doesn't optimize out uniforms that are #ifdef'd out. So undefined values for the spherical harmonic\n  // coefficients cause a crash.\n  this._sphericalHarmonicCoefficients = frameState.sphericalHarmonicCoefficients ?? EMPTY_ARRAY;\n  this._specularEnvironmentMaps = frameState.specularEnvironmentMaps;\n  this._specularEnvironmentMapsMaximumLOD = frameState.specularEnvironmentMapsMaximumLOD;\n  this._fogDensity = frameState.fog.density;\n  this._fogVisualDensityScalar = frameState.fog.visualDensityScalar;\n  this._fogMinimumBrightness = frameState.fog.minimumBrightness;\n  const atmosphere = frameState.atmosphere;\n  if (defined(atmosphere)) {\n    this._atmosphereHsbShift = Cartesian3.fromElements(atmosphere.hueShift, atmosphere.saturationShift, atmosphere.brightnessShift, this._atmosphereHsbShift);\n    this._atmosphereLightIntensity = atmosphere.lightIntensity;\n    this._atmosphereRayleighCoefficient = Cartesian3.clone(atmosphere.rayleighCoefficient, this._atmosphereRayleighCoefficient);\n    this._atmosphereRayleighScaleHeight = atmosphere.rayleighScaleHeight;\n    this._atmosphereMieCoefficient = Cartesian3.clone(atmosphere.mieCoefficient, this._atmosphereMieCoefficient);\n    this._atmosphereMieScaleHeight = atmosphere.mieScaleHeight;\n    this._atmosphereMieAnisotropy = atmosphere.mieAnisotropy;\n    this._atmosphereDynamicLighting = atmosphere.dynamicLighting;\n  }\n  this._invertClassificationColor = frameState.invertClassificationColor;\n  this._frameState = frameState;\n  this._temeToPseudoFixed = Transforms.computeTemeToPseudoFixedMatrix(frameState.time, this._temeToPseudoFixed);\n\n  // Convert the relative splitPosition to absolute pixel coordinates\n  this._splitPosition = frameState.splitPosition * frameState.context.drawingBufferWidth;\n  const fov = camera.frustum.fov;\n  const viewport = this._viewport;\n  let pixelSizePerMeter;\n  if (defined(fov)) {\n    if (viewport.height > viewport.width) {\n      pixelSizePerMeter = Math.tan(0.5 * fov) * 2.0 / viewport.height;\n    } else {\n      pixelSizePerMeter = Math.tan(0.5 * fov) * 2.0 / viewport.width;\n    }\n  } else {\n    pixelSizePerMeter = 1.0 / Math.max(viewport.width, viewport.height);\n  }\n  this._geometricToleranceOverMeter = pixelSizePerMeter * frameState.maximumScreenSpaceError;\n  Color.clone(frameState.backgroundColor, this._backgroundColor);\n  this._minimumDisableDepthTestDistance = frameState.minimumDisableDepthTestDistance;\n  this._minimumDisableDepthTestDistance *= this._minimumDisableDepthTestDistance;\n  if (this._minimumDisableDepthTestDistance === Number.POSITIVE_INFINITY) {\n    this._minimumDisableDepthTestDistance = -1.0;\n  }\n};\nfunction cleanViewport(uniformState) {\n  if (uniformState._viewportDirty) {\n    const v = uniformState._viewport;\n    Matrix4.computeOrthographicOffCenter(v.x, v.x + v.width, v.y, v.y + v.height, 0.0, 1.0, uniformState._viewportOrthographicMatrix);\n    Matrix4.computeViewportTransformation(v, 0.0, 1.0, uniformState._viewportTransformation);\n    uniformState._viewportDirty = false;\n  }\n}\nfunction cleanInverseProjection(uniformState) {\n  if (uniformState._inverseProjectionDirty) {\n    uniformState._inverseProjectionDirty = false;\n    if (uniformState._mode !== SceneMode.SCENE2D && uniformState._mode !== SceneMode.MORPHING && !uniformState._orthographicIn3D) {\n      Matrix4.inverse(uniformState._projection, uniformState._inverseProjection);\n    } else {\n      Matrix4.clone(Matrix4.ZERO, uniformState._inverseProjection);\n    }\n  }\n}\n\n// Derived\nfunction cleanModelView(uniformState) {\n  if (uniformState._modelViewDirty) {\n    uniformState._modelViewDirty = false;\n    Matrix4.multiplyTransformation(uniformState._view, uniformState._model, uniformState._modelView);\n  }\n}\nfunction cleanModelView3D(uniformState) {\n  if (uniformState._modelView3DDirty) {\n    uniformState._modelView3DDirty = false;\n    Matrix4.multiplyTransformation(uniformState.view3D, uniformState._model, uniformState._modelView3D);\n  }\n}\nfunction cleanInverseModelView(uniformState) {\n  if (uniformState._inverseModelViewDirty) {\n    uniformState._inverseModelViewDirty = false;\n    Matrix4.inverse(uniformState.modelView, uniformState._inverseModelView);\n  }\n}\nfunction cleanInverseModelView3D(uniformState) {\n  if (uniformState._inverseModelView3DDirty) {\n    uniformState._inverseModelView3DDirty = false;\n    Matrix4.inverse(uniformState.modelView3D, uniformState._inverseModelView3D);\n  }\n}\nfunction cleanViewProjection(uniformState) {\n  if (uniformState._viewProjectionDirty) {\n    uniformState._viewProjectionDirty = false;\n    Matrix4.multiply(uniformState._projection, uniformState._view, uniformState._viewProjection);\n  }\n}\nfunction cleanInverseViewProjection(uniformState) {\n  if (uniformState._inverseViewProjectionDirty) {\n    uniformState._inverseViewProjectionDirty = false;\n    Matrix4.inverse(uniformState.viewProjection, uniformState._inverseViewProjection);\n  }\n}\nfunction cleanModelViewProjection(uniformState) {\n  if (uniformState._modelViewProjectionDirty) {\n    uniformState._modelViewProjectionDirty = false;\n    Matrix4.multiply(uniformState._projection, uniformState.modelView, uniformState._modelViewProjection);\n  }\n}\nfunction cleanModelViewRelativeToEye(uniformState) {\n  if (uniformState._modelViewRelativeToEyeDirty) {\n    uniformState._modelViewRelativeToEyeDirty = false;\n    const mv = uniformState.modelView;\n    const mvRte = uniformState._modelViewRelativeToEye;\n    mvRte[0] = mv[0];\n    mvRte[1] = mv[1];\n    mvRte[2] = mv[2];\n    mvRte[3] = mv[3];\n    mvRte[4] = mv[4];\n    mvRte[5] = mv[5];\n    mvRte[6] = mv[6];\n    mvRte[7] = mv[7];\n    mvRte[8] = mv[8];\n    mvRte[9] = mv[9];\n    mvRte[10] = mv[10];\n    mvRte[11] = mv[11];\n    mvRte[12] = 0.0;\n    mvRte[13] = 0.0;\n    mvRte[14] = 0.0;\n    mvRte[15] = mv[15];\n  }\n}\nfunction cleanInverseModelViewProjection(uniformState) {\n  if (uniformState._inverseModelViewProjectionDirty) {\n    uniformState._inverseModelViewProjectionDirty = false;\n    Matrix4.inverse(uniformState.modelViewProjection, uniformState._inverseModelViewProjection);\n  }\n}\nfunction cleanModelViewProjectionRelativeToEye(uniformState) {\n  if (uniformState._modelViewProjectionRelativeToEyeDirty) {\n    uniformState._modelViewProjectionRelativeToEyeDirty = false;\n    Matrix4.multiply(uniformState._projection, uniformState.modelViewRelativeToEye, uniformState._modelViewProjectionRelativeToEye);\n  }\n}\nfunction cleanModelViewInfiniteProjection(uniformState) {\n  if (uniformState._modelViewInfiniteProjectionDirty) {\n    uniformState._modelViewInfiniteProjectionDirty = false;\n    Matrix4.multiply(uniformState._infiniteProjection, uniformState.modelView, uniformState._modelViewInfiniteProjection);\n  }\n}\nfunction cleanNormal(uniformState) {\n  if (uniformState._normalDirty) {\n    uniformState._normalDirty = false;\n    const m = uniformState._normal;\n    Matrix4.getMatrix3(uniformState.inverseModelView, m);\n    Matrix3.transpose(m, m);\n  }\n}\nfunction cleanNormal3D(uniformState) {\n  if (uniformState._normal3DDirty) {\n    uniformState._normal3DDirty = false;\n    const m = uniformState._normal3D;\n    Matrix4.getMatrix3(uniformState.inverseModelView3D, m);\n    Matrix3.transpose(m, m);\n  }\n}\nfunction cleanInverseNormal(uniformState) {\n  if (uniformState._inverseNormalDirty) {\n    uniformState._inverseNormalDirty = false;\n    const m = uniformState._inverseNormal;\n    Matrix4.getMatrix3(uniformState.modelView, m);\n    Matrix3.transpose(m, m);\n  }\n}\nfunction cleanInverseNormal3D(uniformState) {\n  if (uniformState._inverseNormal3DDirty) {\n    uniformState._inverseNormal3DDirty = false;\n    const m = uniformState._inverseNormal3D;\n    Matrix4.getMatrix3(uniformState.modelView3D, m);\n    Matrix3.transpose(m, m);\n  }\n}\nconst cameraPositionMC = new Cartesian3();\nfunction cleanEncodedCameraPositionMC(uniformState) {\n  if (uniformState._encodedCameraPositionMCDirty) {\n    uniformState._encodedCameraPositionMCDirty = false;\n    Matrix4.multiplyByPoint(uniformState.inverseModel, uniformState._cameraPosition, cameraPositionMC);\n    EncodedCartesian3.fromCartesian(cameraPositionMC, uniformState._encodedCameraPositionMC);\n  }\n}\nconst view2Dto3DPScratch = new Cartesian3();\nconst view2Dto3DRScratch = new Cartesian3();\nconst view2Dto3DUScratch = new Cartesian3();\nconst view2Dto3DDScratch = new Cartesian3();\nconst view2Dto3DCartographicScratch = new Cartographic();\nconst view2Dto3DCartesian3Scratch = new Cartesian3();\nconst view2Dto3DMatrix4Scratch = new Matrix4();\nfunction view2Dto3D(position2D, direction2D, right2D, up2D, frustum2DWidth, mode, projection, result) {\n  // The camera position and directions are expressed in the 2D coordinate system where the Y axis is to the East,\n  // the Z axis is to the North, and the X axis is out of the map.  Express them instead in the ENU axes where\n  // X is to the East, Y is to the North, and Z is out of the local horizontal plane.\n  const p = view2Dto3DPScratch;\n  p.x = position2D.y;\n  p.y = position2D.z;\n  p.z = position2D.x;\n  const r = view2Dto3DRScratch;\n  r.x = right2D.y;\n  r.y = right2D.z;\n  r.z = right2D.x;\n  const u = view2Dto3DUScratch;\n  u.x = up2D.y;\n  u.y = up2D.z;\n  u.z = up2D.x;\n  const d = view2Dto3DDScratch;\n  d.x = direction2D.y;\n  d.y = direction2D.z;\n  d.z = direction2D.x;\n\n  // In 2D, the camera height is always 12.7 million meters.\n  // The apparent height is equal to half the frustum width.\n  if (mode === SceneMode.SCENE2D) {\n    p.z = frustum2DWidth * 0.5;\n  }\n\n  // Compute the equivalent camera position in the real (3D) world.\n  // In 2D and Columbus View, the camera can travel outside the projection, and when it does so\n  // there's not really any corresponding location in the real world.  So clamp the unprojected\n  // longitude and latitude to their valid ranges.\n  const cartographic = projection.unproject(p, view2Dto3DCartographicScratch);\n  cartographic.longitude = CesiumMath.clamp(cartographic.longitude, -Math.PI, Math.PI);\n  cartographic.latitude = CesiumMath.clamp(cartographic.latitude, -CesiumMath.PI_OVER_TWO, CesiumMath.PI_OVER_TWO);\n  const ellipsoid = projection.ellipsoid;\n  const position3D = ellipsoid.cartographicToCartesian(cartographic, view2Dto3DCartesian3Scratch);\n\n  // Compute the rotation from the local ENU at the real world camera position to the fixed axes.\n  const enuToFixed = Transforms.eastNorthUpToFixedFrame(position3D, ellipsoid, view2Dto3DMatrix4Scratch);\n\n  // Transform each camera direction to the fixed axes.\n  Matrix4.multiplyByPointAsVector(enuToFixed, r, r);\n  Matrix4.multiplyByPointAsVector(enuToFixed, u, u);\n  Matrix4.multiplyByPointAsVector(enuToFixed, d, d);\n\n  // Compute the view matrix based on the new fixed-frame camera position and directions.\n  if (!defined(result)) {\n    result = new Matrix4();\n  }\n  result[0] = r.x;\n  result[1] = u.x;\n  result[2] = -d.x;\n  result[3] = 0.0;\n  result[4] = r.y;\n  result[5] = u.y;\n  result[6] = -d.y;\n  result[7] = 0.0;\n  result[8] = r.z;\n  result[9] = u.z;\n  result[10] = -d.z;\n  result[11] = 0.0;\n  result[12] = -Cartesian3.dot(r, position3D);\n  result[13] = -Cartesian3.dot(u, position3D);\n  result[14] = Cartesian3.dot(d, position3D);\n  result[15] = 1.0;\n  return result;\n}\nfunction updateView3D(that) {\n  if (that._view3DDirty) {\n    if (that._mode === SceneMode.SCENE3D) {\n      Matrix4.clone(that._view, that._view3D);\n    } else {\n      view2Dto3D(that._cameraPosition, that._cameraDirection, that._cameraRight, that._cameraUp, that._frustum2DWidth, that._mode, that._mapProjection, that._view3D);\n    }\n    Matrix4.getMatrix3(that._view3D, that._viewRotation3D);\n    that._view3DDirty = false;\n  }\n}\nfunction updateInverseView3D(that) {\n  if (that._inverseView3DDirty) {\n    Matrix4.inverseTransformation(that.view3D, that._inverseView3D);\n    Matrix4.getMatrix3(that._inverseView3D, that._inverseViewRotation3D);\n    that._inverseView3DDirty = false;\n  }\n}\nexport default UniformState;","map":{"version":3,"names":["BoundingRectangle","Cartesian2","Cartesian3","Cartesian4","Cartographic","Color","defined","Ellipsoid","EncodedCartesian3","CesiumMath","Matrix3","Matrix4","OrthographicFrustum","Simon1994PlanetaryPositions","Transforms","SceneMode","SunLight","UniformState","globeDepthTexture","undefined","gamma","_viewport","_viewportCartesian4","_viewportDirty","_viewportOrthographicMatrix","clone","IDENTITY","_viewportTransformation","_model","_view","_inverseView","_projection","_infiniteProjection","_entireFrustum","_currentFrustum","_frustumPlanes","_farDepthFromNearPlusOne","_log2FarDepthFromNearPlusOne","_oneOverLog2FarDepthFromNearPlusOne","_frameState","_temeToPseudoFixed","_view3DDirty","_view3D","_inverseView3DDirty","_inverseView3D","_inverseModelDirty","_inverseModel","_inverseTransposeModelDirty","_inverseTransposeModel","_viewRotation","_inverseViewRotation","_viewRotation3D","_inverseViewRotation3D","_inverseProjectionDirty","_inverseProjection","_modelViewDirty","_modelView","_modelView3DDirty","_modelView3D","_modelViewRelativeToEyeDirty","_modelViewRelativeToEye","_inverseModelViewDirty","_inverseModelView","_inverseModelView3DDirty","_inverseModelView3D","_viewProjectionDirty","_viewProjection","_inverseViewProjectionDirty","_inverseViewProjection","_modelViewProjectionDirty","_modelViewProjection","_inverseModelViewProjectionDirty","_inverseModelViewProjection","_modelViewProjectionRelativeToEyeDirty","_modelViewProjectionRelativeToEye","_modelViewInfiniteProjectionDirty","_modelViewInfiniteProjection","_normalDirty","_normal","_normal3DDirty","_normal3D","_inverseNormalDirty","_inverseNormal","_inverseNormal3DDirty","_inverseNormal3D","_encodedCameraPositionMCDirty","_encodedCameraPositionMC","_cameraPosition","_sunPositionWC","_sunPositionColumbusView","_sunDirectionWC","_sunDirectionEC","_moonDirectionEC","_lightDirectionWC","_lightDirectionEC","_lightColor","_lightColorHdr","_pass","_mode","_mapProjection","_ellipsoid","_cameraDirection","_cameraRight","_cameraUp","_frustum2DWidth","_eyeHeight","_eyeHeight2D","_eyeEllipsoidNormalEC","_eyeEllipsoidCurvature","_modelToEnu","_enuToModel","_pixelRatio","_orthographicIn3D","_backgroundColor","_brdfLut","_environmentMap","_sphericalHarmonicCoefficients","_specularEnvironmentMaps","_specularEnvironmentMapsMaximumLOD","_fogDensity","_fogVisualDensityScalar","_fogMinimumBrightness","_atmosphereHsbShift","_atmosphereLightIntensity","_atmosphereRayleighCoefficient","_atmosphereRayleighScaleHeight","_atmosphereMieCoefficient","_atmosphereMieScaleHeight","_atmosphereMieAnisotropy","_atmosphereDynamicLighting","_invertClassificationColor","_splitPosition","_pixelSizePerMeter","_geometricToleranceOverMeter","_minimumDisableDepthTestDistance","Object","defineProperties","prototype","frameState","get","viewport","set","equals","v","vc","x","y","z","width","w","height","viewportCartesian4","viewportOrthographic","cleanViewport","viewportTransformation","model","matrix","inverseModel","inverse","inverseTransposeModel","m","getMatrix3","transpose","view","view3D","updateView3D","viewRotation","viewRotation3D","inverseView","inverseView3D","updateInverseView3D","inverseViewRotation","inverseViewRotation3D","projection","inverseProjection","cleanInverseProjection","infiniteProjection","modelView","cleanModelView","modelView3D","cleanModelView3D","modelViewRelativeToEye","cleanModelViewRelativeToEye","inverseModelView","cleanInverseModelView","inverseModelView3D","cleanInverseModelView3D","viewProjection","cleanViewProjection","inverseViewProjection","cleanInverseViewProjection","modelViewProjection","cleanModelViewProjection","inverseModelViewProjection","cleanInverseModelViewProjection","modelViewProjectionRelativeToEye","cleanModelViewProjectionRelativeToEye","modelViewInfiniteProjection","cleanModelViewInfiniteProjection","normal","cleanNormal","normal3D","cleanNormal3D","inverseNormal","cleanInverseNormal","inverseNormal3D","cleanInverseNormal3D","entireFrustum","currentFrustum","frustumPlanes","farDepthFromNearPlusOne","log2FarDepthFromNearPlusOne","oneOverLog2FarDepthFromNearPlusOne","eyeHeight","eyeHeight2D","eyeEllipsoidNormalEC","eyeEllipsoidCurvature","modelToEnu","enuToModel","sunPositionWC","sunPositionColumbusView","sunDirectionWC","sunDirectionEC","moonDirectionEC","lightDirectionWC","lightDirectionEC","lightColor","lightColorHdr","encodedCameraPositionMCHigh","cleanEncodedCameraPositionMC","high","encodedCameraPositionMCLow","low","temeToPseudoFixedMatrix","pixelRatio","fogDensity","fogVisualDensityScalar","fogMinimumBrightness","atmosphereHsbShift","atmosphereLightIntensity","atmosphereRayleighCoefficient","atmosphereRayleighScaleHeight","atmosphereMieCoefficient","atmosphereMieScaleHeight","atmosphereMieAnisotropy","atmosphereDynamicLighting","geometricToleranceOverMeter","pass","backgroundColor","brdfLut","environmentMap","sphericalHarmonicCoefficients","specularEnvironmentMaps","specularEnvironmentMapsMaximumLOD","splitPosition","minimumDisableDepthTestDistance","invertClassificationColor","orthographicIn3D","ellipsoid","default","setView","uniformState","setInverseView","setProjection","setInfiniteProjection","surfacePositionScratch","enuTransformScratch","setCamera","camera","positionWC","directionWC","rightWC","upWC","surfacePosition","positionCartographic","maximumRadius","magnitude","normalize","scaleToGeodeticSurface","geodeticSurfaceNormalCartographic","fromRadians","longitude","latitude","multiplyByVector","enuToWorld","eastNorthUpToFixedFrame","multiplyTransformation","inverseTransformation","equalsEpsilon","_radii","EPSILON15","getLocalCurvature","transformMatrix","sunCartographicScratch","setSunAndMoonDirections","computeIcrfToCentralBodyFixedMatrix","time","position","computeSunPositionInEarthInertialFrame","computeMoonPositionInEarthInertialFrame","mapProjection","sunCartographic","cartesianToCartographic","project","updateCamera","viewMatrix","inverseViewMatrix","frustum","near","far","updateFrustum","SCENE2D","projectionMatrix","infiniteProjectionMatrix","log2","offCenterFrustum","top","bottom","left","right","updatePass","EMPTY_ARRAY","defaultLight","update","mode","light","negate","direction","color","fromElements","red","green","blue","multiplyByScalar","intensity","maximumComponent","divideByScalar","brdfLutGenerator","colorTexture","context","defaultCubeMap","fog","density","visualDensityScalar","minimumBrightness","atmosphere","hueShift","saturationShift","brightnessShift","lightIntensity","rayleighCoefficient","rayleighScaleHeight","mieCoefficient","mieScaleHeight","mieAnisotropy","dynamicLighting","computeTemeToPseudoFixedMatrix","drawingBufferWidth","fov","pixelSizePerMeter","Math","tan","max","maximumScreenSpaceError","Number","POSITIVE_INFINITY","computeOrthographicOffCenter","computeViewportTransformation","MORPHING","ZERO","multiply","mv","mvRte","cameraPositionMC","multiplyByPoint","fromCartesian","view2Dto3DPScratch","view2Dto3DRScratch","view2Dto3DUScratch","view2Dto3DDScratch","view2Dto3DCartographicScratch","view2Dto3DCartesian3Scratch","view2Dto3DMatrix4Scratch","view2Dto3D","position2D","direction2D","right2D","up2D","frustum2DWidth","result","p","r","u","d","cartographic","unproject","clamp","PI","PI_OVER_TWO","position3D","cartographicToCartesian","enuToFixed","multiplyByPointAsVector","dot","that","SCENE3D"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Renderer/UniformState.js"],"sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport Simon1994PlanetaryPositions from \"../Core/Simon1994PlanetaryPositions.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport SunLight from \"../Scene/SunLight.js\";\n\n/**\n * @private\n * @constructor\n */\nfunction UniformState() {\n  /**\n   * @type {Texture}\n   */\n  this.globeDepthTexture = undefined;\n  /**\n   * @type {number}\n   */\n  this.gamma = undefined;\n\n  this._viewport = new BoundingRectangle();\n  this._viewportCartesian4 = new Cartesian4();\n  this._viewportDirty = false;\n  this._viewportOrthographicMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._viewportTransformation = Matrix4.clone(Matrix4.IDENTITY);\n\n  this._model = Matrix4.clone(Matrix4.IDENTITY);\n  this._view = Matrix4.clone(Matrix4.IDENTITY);\n  this._inverseView = Matrix4.clone(Matrix4.IDENTITY);\n  this._projection = Matrix4.clone(Matrix4.IDENTITY);\n  this._infiniteProjection = Matrix4.clone(Matrix4.IDENTITY);\n  this._entireFrustum = new Cartesian2();\n  this._currentFrustum = new Cartesian2();\n  this._frustumPlanes = new Cartesian4();\n  this._farDepthFromNearPlusOne = undefined;\n  this._log2FarDepthFromNearPlusOne = undefined;\n  this._oneOverLog2FarDepthFromNearPlusOne = undefined;\n\n  this._frameState = undefined;\n  this._temeToPseudoFixed = Matrix3.clone(Matrix4.IDENTITY);\n\n  // Derived members\n  this._view3DDirty = true;\n  this._view3D = new Matrix4();\n\n  this._inverseView3DDirty = true;\n  this._inverseView3D = new Matrix4();\n\n  this._inverseModelDirty = true;\n  this._inverseModel = new Matrix4();\n\n  this._inverseTransposeModelDirty = true;\n  this._inverseTransposeModel = new Matrix3();\n\n  this._viewRotation = new Matrix3();\n  this._inverseViewRotation = new Matrix3();\n\n  this._viewRotation3D = new Matrix3();\n  this._inverseViewRotation3D = new Matrix3();\n\n  this._inverseProjectionDirty = true;\n  this._inverseProjection = new Matrix4();\n\n  this._modelViewDirty = true;\n  this._modelView = new Matrix4();\n\n  this._modelView3DDirty = true;\n  this._modelView3D = new Matrix4();\n\n  this._modelViewRelativeToEyeDirty = true;\n  this._modelViewRelativeToEye = new Matrix4();\n\n  this._inverseModelViewDirty = true;\n  this._inverseModelView = new Matrix4();\n\n  this._inverseModelView3DDirty = true;\n  this._inverseModelView3D = new Matrix4();\n\n  this._viewProjectionDirty = true;\n  this._viewProjection = new Matrix4();\n\n  this._inverseViewProjectionDirty = true;\n  this._inverseViewProjection = new Matrix4();\n\n  this._modelViewProjectionDirty = true;\n  this._modelViewProjection = new Matrix4();\n\n  this._inverseModelViewProjectionDirty = true;\n  this._inverseModelViewProjection = new Matrix4();\n\n  this._modelViewProjectionRelativeToEyeDirty = true;\n  this._modelViewProjectionRelativeToEye = new Matrix4();\n\n  this._modelViewInfiniteProjectionDirty = true;\n  this._modelViewInfiniteProjection = new Matrix4();\n\n  this._normalDirty = true;\n  this._normal = new Matrix3();\n\n  this._normal3DDirty = true;\n  this._normal3D = new Matrix3();\n\n  this._inverseNormalDirty = true;\n  this._inverseNormal = new Matrix3();\n\n  this._inverseNormal3DDirty = true;\n  this._inverseNormal3D = new Matrix3();\n\n  this._encodedCameraPositionMCDirty = true;\n  this._encodedCameraPositionMC = new EncodedCartesian3();\n  this._cameraPosition = new Cartesian3();\n\n  this._sunPositionWC = new Cartesian3();\n  this._sunPositionColumbusView = new Cartesian3();\n  this._sunDirectionWC = new Cartesian3();\n  this._sunDirectionEC = new Cartesian3();\n  this._moonDirectionEC = new Cartesian3();\n\n  this._lightDirectionWC = new Cartesian3();\n  this._lightDirectionEC = new Cartesian3();\n  this._lightColor = new Cartesian3();\n  this._lightColorHdr = new Cartesian3();\n\n  this._pass = undefined;\n  this._mode = undefined;\n  this._mapProjection = undefined;\n  this._ellipsoid = undefined;\n  this._cameraDirection = new Cartesian3();\n  this._cameraRight = new Cartesian3();\n  this._cameraUp = new Cartesian3();\n  this._frustum2DWidth = 0.0;\n  this._eyeHeight = 0.0;\n  this._eyeHeight2D = new Cartesian2();\n  this._eyeEllipsoidNormalEC = new Cartesian3();\n  this._eyeEllipsoidCurvature = new Cartesian2();\n  this._modelToEnu = new Matrix4();\n  this._enuToModel = new Matrix4();\n  this._pixelRatio = 1.0;\n  this._orthographicIn3D = false;\n  this._backgroundColor = new Color();\n\n  this._brdfLut = undefined;\n  this._environmentMap = undefined;\n\n  this._sphericalHarmonicCoefficients = undefined;\n  this._specularEnvironmentMaps = undefined;\n  this._specularEnvironmentMapsMaximumLOD = undefined;\n\n  this._fogDensity = undefined;\n  this._fogVisualDensityScalar = undefined;\n  this._fogMinimumBrightness = undefined;\n\n  this._atmosphereHsbShift = undefined;\n  this._atmosphereLightIntensity = undefined;\n  this._atmosphereRayleighCoefficient = new Cartesian3();\n  this._atmosphereRayleighScaleHeight = new Cartesian3();\n  this._atmosphereMieCoefficient = new Cartesian3();\n  this._atmosphereMieScaleHeight = undefined;\n  this._atmosphereMieAnisotropy = undefined;\n  this._atmosphereDynamicLighting = undefined;\n\n  this._invertClassificationColor = undefined;\n\n  this._splitPosition = 0.0;\n  this._pixelSizePerMeter = undefined;\n  this._geometricToleranceOverMeter = undefined;\n\n  this._minimumDisableDepthTestDistance = undefined;\n}\n\nObject.defineProperties(UniformState.prototype, {\n  /**\n   * @memberof UniformState.prototype\n   * @type {FrameState}\n   * @readonly\n   */\n  frameState: {\n    get: function () {\n      return this._frameState;\n    },\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @type {BoundingRectangle}\n   */\n  viewport: {\n    get: function () {\n      return this._viewport;\n    },\n    set: function (viewport) {\n      if (!BoundingRectangle.equals(viewport, this._viewport)) {\n        BoundingRectangle.clone(viewport, this._viewport);\n\n        const v = this._viewport;\n        const vc = this._viewportCartesian4;\n        vc.x = v.x;\n        vc.y = v.y;\n        vc.z = v.width;\n        vc.w = v.height;\n\n        this._viewportDirty = true;\n      }\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @private\n   */\n  viewportCartesian4: {\n    get: function () {\n      return this._viewportCartesian4;\n    },\n  },\n\n  viewportOrthographic: {\n    get: function () {\n      cleanViewport(this);\n      return this._viewportOrthographicMatrix;\n    },\n  },\n\n  viewportTransformation: {\n    get: function () {\n      cleanViewport(this);\n      return this._viewportTransformation;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  model: {\n    get: function () {\n      return this._model;\n    },\n    set: function (matrix) {\n      Matrix4.clone(matrix, this._model);\n\n      this._modelView3DDirty = true;\n      this._inverseModelView3DDirty = true;\n      this._inverseModelDirty = true;\n      this._inverseTransposeModelDirty = true;\n      this._modelViewDirty = true;\n      this._inverseModelViewDirty = true;\n      this._modelViewRelativeToEyeDirty = true;\n      this._inverseModelViewDirty = true;\n      this._modelViewProjectionDirty = true;\n      this._inverseModelViewProjectionDirty = true;\n      this._modelViewProjectionRelativeToEyeDirty = true;\n      this._modelViewInfiniteProjectionDirty = true;\n      this._normalDirty = true;\n      this._inverseNormalDirty = true;\n      this._normal3DDirty = true;\n      this._inverseNormal3DDirty = true;\n      this._encodedCameraPositionMCDirty = true;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModel: {\n    get: function () {\n      if (this._inverseModelDirty) {\n        this._inverseModelDirty = false;\n\n        Matrix4.inverse(this._model, this._inverseModel);\n      }\n\n      return this._inverseModel;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @private\n   */\n  inverseTransposeModel: {\n    get: function () {\n      const m = this._inverseTransposeModel;\n      if (this._inverseTransposeModelDirty) {\n        this._inverseTransposeModelDirty = false;\n\n        Matrix4.getMatrix3(this.inverseModel, m);\n        Matrix3.transpose(m, m);\n      }\n\n      return m;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  view: {\n    get: function () {\n      return this._view;\n    },\n  },\n\n  /**\n   * The 3D view matrix.  In 3D mode, this is identical to {@link UniformState#view},\n   * but in 2D and Columbus View it is a synthetic matrix based on the equivalent position\n   * of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  view3D: {\n    get: function () {\n      updateView3D(this);\n      return this._view3D;\n    },\n  },\n\n  /**\n   * The 3x3 rotation matrix of the current view matrix ({@link UniformState#view}).\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  viewRotation: {\n    get: function () {\n      updateView3D(this);\n      return this._viewRotation;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  viewRotation3D: {\n    get: function () {\n      updateView3D(this);\n      return this._viewRotation3D;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseView: {\n    get: function () {\n      return this._inverseView;\n    },\n  },\n\n  /**\n   * the 4x4 inverse-view matrix that transforms from eye to 3D world coordinates.  In 3D mode, this is\n   * identical to {@link UniformState#inverseView}, but in 2D and Columbus View it is a synthetic matrix\n   * based on the equivalent position of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseView3D: {\n    get: function () {\n      updateInverseView3D(this);\n      return this._inverseView3D;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseViewRotation: {\n    get: function () {\n      return this._inverseViewRotation;\n    },\n  },\n\n  /**\n   * The 3x3 rotation matrix of the current 3D inverse-view matrix ({@link UniformState#inverseView3D}).\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseViewRotation3D: {\n    get: function () {\n      updateInverseView3D(this);\n      return this._inverseViewRotation3D;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  projection: {\n    get: function () {\n      return this._projection;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseProjection: {\n    get: function () {\n      cleanInverseProjection(this);\n      return this._inverseProjection;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  infiniteProjection: {\n    get: function () {\n      return this._infiniteProjection;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelView: {\n    get: function () {\n      cleanModelView(this);\n      return this._modelView;\n    },\n  },\n\n  /**\n   * The 3D model-view matrix.  In 3D mode, this is equivalent to {@link UniformState#modelView}.  In 2D and\n   * Columbus View, however, it is a synthetic matrix based on the equivalent position of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelView3D: {\n    get: function () {\n      cleanModelView3D(this);\n      return this._modelView3D;\n    },\n  },\n\n  /**\n   * Model-view relative to eye matrix.\n   *\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewRelativeToEye: {\n    get: function () {\n      cleanModelViewRelativeToEye(this);\n      return this._modelViewRelativeToEye;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModelView: {\n    get: function () {\n      cleanInverseModelView(this);\n      return this._inverseModelView;\n    },\n  },\n\n  /**\n   * The inverse of the 3D model-view matrix.  In 3D mode, this is equivalent to {@link UniformState#inverseModelView}.\n   * In 2D and Columbus View, however, it is a synthetic matrix based on the equivalent position of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModelView3D: {\n    get: function () {\n      cleanInverseModelView3D(this);\n      return this._inverseModelView3D;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  viewProjection: {\n    get: function () {\n      cleanViewProjection(this);\n      return this._viewProjection;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseViewProjection: {\n    get: function () {\n      cleanInverseViewProjection(this);\n      return this._inverseViewProjection;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewProjection: {\n    get: function () {\n      cleanModelViewProjection(this);\n      return this._modelViewProjection;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModelViewProjection: {\n    get: function () {\n      cleanInverseModelViewProjection(this);\n      return this._inverseModelViewProjection;\n    },\n  },\n\n  /**\n   * Model-view-projection relative to eye matrix.\n   *\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewProjectionRelativeToEye: {\n    get: function () {\n      cleanModelViewProjectionRelativeToEye(this);\n      return this._modelViewProjectionRelativeToEye;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewInfiniteProjection: {\n    get: function () {\n      cleanModelViewInfiniteProjection(this);\n      return this._modelViewInfiniteProjection;\n    },\n  },\n\n  /**\n   * A 3x3 normal transformation matrix that transforms normal vectors in model coordinates to\n   * eye coordinates.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  normal: {\n    get: function () {\n      cleanNormal(this);\n      return this._normal;\n    },\n  },\n\n  /**\n   * A 3x3 normal transformation matrix that transforms normal vectors in 3D model\n   * coordinates to eye coordinates.  In 3D mode, this is identical to\n   * {@link UniformState#normal}, but in 2D and Columbus View it represents the normal transformation\n   * matrix as if the camera were at an equivalent location in 3D mode.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  normal3D: {\n    get: function () {\n      cleanNormal3D(this);\n      return this._normal3D;\n    },\n  },\n\n  /**\n   * An inverse 3x3 normal transformation matrix that transforms normal vectors in model coordinates\n   * to eye coordinates.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseNormal: {\n    get: function () {\n      cleanInverseNormal(this);\n      return this._inverseNormal;\n    },\n  },\n\n  /**\n   * An inverse 3x3 normal transformation matrix that transforms normal vectors in eye coordinates\n   * to 3D model coordinates.  In 3D mode, this is identical to\n   * {@link UniformState#inverseNormal}, but in 2D and Columbus View it represents the normal transformation\n   * matrix as if the camera were at an equivalent location in 3D mode.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseNormal3D: {\n    get: function () {\n      cleanInverseNormal3D(this);\n      return this._inverseNormal3D;\n    },\n  },\n\n  /**\n   * The near distance (<code>x</code>) and the far distance (<code>y</code>) of the frustum defined by the camera.\n   * This is the largest possible frustum, not an individual frustum used for multi-frustum rendering.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  entireFrustum: {\n    get: function () {\n      return this._entireFrustum;\n    },\n  },\n\n  /**\n   * The near distance (<code>x</code>) and the far distance (<code>y</code>) of the frustum defined by the camera.\n   * This is the individual frustum used for multi-frustum rendering.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  currentFrustum: {\n    get: function () {\n      return this._currentFrustum;\n    },\n  },\n\n  /**\n   * The distances to the frustum planes. The top, bottom, left and right distances are\n   * the x, y, z, and w components, respectively.\n   * @memberof UniformState.prototype\n   * @type {Cartesian4}\n   */\n  frustumPlanes: {\n    get: function () {\n      return this._frustumPlanes;\n    },\n  },\n\n  /**\n   * The far plane's distance from the near plane, plus 1.0.\n   *\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  farDepthFromNearPlusOne: {\n    get: function () {\n      return this._farDepthFromNearPlusOne;\n    },\n  },\n\n  /**\n   * The log2 of {@link UniformState#farDepthFromNearPlusOne}.\n   *\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  log2FarDepthFromNearPlusOne: {\n    get: function () {\n      return this._log2FarDepthFromNearPlusOne;\n    },\n  },\n\n  /**\n   * 1.0 divided by {@link UniformState#log2FarDepthFromNearPlusOne}.\n   *\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  oneOverLog2FarDepthFromNearPlusOne: {\n    get: function () {\n      return this._oneOverLog2FarDepthFromNearPlusOne;\n    },\n  },\n\n  /**\n   * The height in meters of the eye (camera) above or below the ellipsoid.\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  eyeHeight: {\n    get: function () {\n      return this._eyeHeight;\n    },\n  },\n\n  /**\n   * The height (<code>x</code>) and the height squared (<code>y</code>)\n   * in meters of the eye (camera) above the 2D world plane. This uniform is only valid\n   * when the {@link SceneMode} is <code>SCENE2D</code>.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  eyeHeight2D: {\n    get: function () {\n      return this._eyeHeight2D;\n    },\n  },\n\n  /**\n   * The ellipsoid surface normal at the camera position, in model coordinates.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  eyeEllipsoidNormalEC: {\n    get: function () {\n      return this._eyeEllipsoidNormalEC;\n    },\n  },\n\n  /**\n   * The ellipsoid radii of curvature at the camera position.\n   * The .x component is the prime vertical radius, .y is the meridional.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  eyeEllipsoidCurvature: {\n    get: function () {\n      return this._eyeEllipsoidCurvature;\n    },\n  },\n\n  /**\n   * A transform from model coordinates to an east-north-up coordinate system\n   * centered at the position on the ellipsoid below the camera\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelToEnu: {\n    get: function () {\n      return this._modelToEnu;\n    },\n  },\n\n  /**\n   * The inverse of {@link UniformState.prototype.modelToEnu}\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  enuToModel: {\n    get: function () {\n      return this._enuToModel;\n    },\n  },\n\n  /**\n   * The sun position in 3D world coordinates at the current scene time.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunPositionWC: {\n    get: function () {\n      return this._sunPositionWC;\n    },\n  },\n\n  /**\n   * The sun position in 2D world coordinates at the current scene time.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunPositionColumbusView: {\n    get: function () {\n      return this._sunPositionColumbusView;\n    },\n  },\n\n  /**\n   * A normalized vector to the sun in 3D world coordinates at the current scene time.  Even in 2D or\n   * Columbus View mode, this returns the direction to the sun in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunDirectionWC: {\n    get: function () {\n      return this._sunDirectionWC;\n    },\n  },\n\n  /**\n   * A normalized vector to the sun in eye coordinates at the current scene time.  In 3D mode, this\n   * returns the actual vector from the camera position to the sun position.  In 2D and Columbus View, it returns\n   * the vector from the equivalent 3D camera position to the position of the sun in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunDirectionEC: {\n    get: function () {\n      return this._sunDirectionEC;\n    },\n  },\n\n  /**\n   * A normalized vector to the moon in eye coordinates at the current scene time.  In 3D mode, this\n   * returns the actual vector from the camera position to the moon position.  In 2D and Columbus View, it returns\n   * the vector from the equivalent 3D camera position to the position of the moon in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  moonDirectionEC: {\n    get: function () {\n      return this._moonDirectionEC;\n    },\n  },\n\n  /**\n   * A normalized vector to the scene's light source in 3D world coordinates.  Even in 2D or\n   * Columbus View mode, this returns the direction to the light in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightDirectionWC: {\n    get: function () {\n      return this._lightDirectionWC;\n    },\n  },\n\n  /**\n   * A normalized vector to the scene's light source in eye coordinates.  In 3D mode, this\n   * returns the actual vector from the camera position to the light.  In 2D and Columbus View, it returns\n   * the vector from the equivalent 3D camera position in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightDirectionEC: {\n    get: function () {\n      return this._lightDirectionEC;\n    },\n  },\n\n  /**\n   * The color of light emitted by the scene's light source. This is equivalent to the light\n   * color multiplied by the light intensity limited to a maximum luminance of 1.0 suitable\n   * for non-HDR lighting.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightColor: {\n    get: function () {\n      return this._lightColor;\n    },\n  },\n\n  /**\n   * The high dynamic range color of light emitted by the scene's light source. This is equivalent to\n   * the light color multiplied by the light intensity suitable for HDR lighting.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightColorHdr: {\n    get: function () {\n      return this._lightColorHdr;\n    },\n  },\n\n  /**\n   * The high bits of the camera position.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  encodedCameraPositionMCHigh: {\n    get: function () {\n      cleanEncodedCameraPositionMC(this);\n      return this._encodedCameraPositionMC.high;\n    },\n  },\n\n  /**\n   * The low bits of the camera position.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  encodedCameraPositionMCLow: {\n    get: function () {\n      cleanEncodedCameraPositionMC(this);\n      return this._encodedCameraPositionMC.low;\n    },\n  },\n\n  /**\n   * A 3x3 matrix that transforms from True Equator Mean Equinox (TEME) axes to the\n   * pseudo-fixed axes at the Scene's current time.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  temeToPseudoFixedMatrix: {\n    get: function () {\n      return this._temeToPseudoFixed;\n    },\n  },\n\n  /**\n   * Gets the scaling factor for transforming from the canvas\n   * pixel space to canvas coordinate space.\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  pixelRatio: {\n    get: function () {\n      return this._pixelRatio;\n    },\n  },\n\n  /**\n   * A scalar used to mix a color with the fog color based on the distance to the camera.\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  fogDensity: {\n    get: function () {\n      return this._fogDensity;\n    },\n  },\n\n  /**\n   * A scalar used to mix a color with the fog color based on the distance to the camera.\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  fogVisualDensityScalar: {\n    get: function () {\n      return this._fogVisualDensityScalar;\n    },\n  },\n\n  /**\n   * A scalar used as a minimum value when brightening fog\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  fogMinimumBrightness: {\n    get: function () {\n      return this._fogMinimumBrightness;\n    },\n  },\n\n  /**\n   * A color shift to apply to the atmosphere color in HSB.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  atmosphereHsbShift: {\n    get: function () {\n      return this._atmosphereHsbShift;\n    },\n  },\n  /**\n   * The intensity of the light that is used for computing the atmosphere color\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  atmosphereLightIntensity: {\n    get: function () {\n      return this._atmosphereLightIntensity;\n    },\n  },\n  /**\n   * The Rayleigh scattering coefficient used in the atmospheric scattering equations for the sky atmosphere.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  atmosphereRayleighCoefficient: {\n    get: function () {\n      return this._atmosphereRayleighCoefficient;\n    },\n  },\n  /**\n   * The Rayleigh scale height used in the atmospheric scattering equations for the sky atmosphere, in meters.\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  atmosphereRayleighScaleHeight: {\n    get: function () {\n      return this._atmosphereRayleighScaleHeight;\n    },\n  },\n  /**\n   * The Mie scattering coefficient used in the atmospheric scattering equations for the sky atmosphere.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  atmosphereMieCoefficient: {\n    get: function () {\n      return this._atmosphereMieCoefficient;\n    },\n  },\n  /**\n   * The Mie scale height used in the atmospheric scattering equations for the sky atmosphere, in meters.\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  atmosphereMieScaleHeight: {\n    get: function () {\n      return this._atmosphereMieScaleHeight;\n    },\n  },\n  /**\n   * The anisotropy of the medium to consider for Mie scattering.\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  atmosphereMieAnisotropy: {\n    get: function () {\n      return this._atmosphereMieAnisotropy;\n    },\n  },\n  /**\n   * Which light source to use for dynamically lighting the atmosphere\n   *\n   * @memberof UniformState.prototype\n   * @type {DynamicAtmosphereLightingType}\n   */\n  atmosphereDynamicLighting: {\n    get: function () {\n      return this._atmosphereDynamicLighting;\n    },\n  },\n\n  /**\n   * A scalar that represents the geometric tolerance per meter\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  geometricToleranceOverMeter: {\n    get: function () {\n      return this._geometricToleranceOverMeter;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Pass}\n   */\n  pass: {\n    get: function () {\n      return this._pass;\n    },\n  },\n\n  /**\n   * The current background color\n   * @memberof UniformState.prototype\n   * @type {Color}\n   */\n  backgroundColor: {\n    get: function () {\n      return this._backgroundColor;\n    },\n  },\n\n  /**\n   * The look up texture used to find the BRDF for a material\n   * @memberof UniformState.prototype\n   * @type {Texture}\n   */\n  brdfLut: {\n    get: function () {\n      return this._brdfLut;\n    },\n  },\n\n  /**\n   * The environment map of the scene\n   * @memberof UniformState.prototype\n   * @type {CubeMap}\n   */\n  environmentMap: {\n    get: function () {\n      return this._environmentMap;\n    },\n  },\n\n  /**\n   * The spherical harmonic coefficients of the scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3[]}\n   */\n  sphericalHarmonicCoefficients: {\n    get: function () {\n      return this._sphericalHarmonicCoefficients;\n    },\n  },\n\n  /**\n   * The specular environment cube map of the scene.\n   * @memberof UniformState.prototype\n   * @type {Texture}\n   */\n  specularEnvironmentMaps: {\n    get: function () {\n      return this._specularEnvironmentMaps;\n    },\n  },\n\n  /**\n   * The maximum level-of-detail of the specular environment cube map of the scene.\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  specularEnvironmentMapsMaximumLOD: {\n    get: function () {\n      return this._specularEnvironmentMapsMaximumLOD;\n    },\n  },\n\n  /**\n   * The splitter position to use when rendering with a splitter. This will be in pixel coordinates relative to the canvas.\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  splitPosition: {\n    get: function () {\n      return this._splitPosition;\n    },\n  },\n\n  /**\n   * The distance from the camera at which to disable the depth test of billboards, labels and points\n   * to, for example, prevent clipping against terrain. When set to zero, the depth test should always\n   * be applied. When less than zero, the depth test should never be applied.\n   *\n   * @memberof UniformState.prototype\n   * @type {number}\n   */\n  minimumDisableDepthTestDistance: {\n    get: function () {\n      return this._minimumDisableDepthTestDistance;\n    },\n  },\n\n  /**\n   * The highlight color of unclassified 3D Tiles.\n   *\n   * @memberof UniformState.prototype\n   * @type {Color}\n   */\n  invertClassificationColor: {\n    get: function () {\n      return this._invertClassificationColor;\n    },\n  },\n\n  /**\n   * Whether or not the current projection is orthographic in 3D.\n   *\n   * @memberOf UniformState.prototype\n   * @type {boolean}\n   */\n  orthographicIn3D: {\n    get: function () {\n      return this._orthographicIn3D;\n    },\n  },\n\n  /**\n   * The current ellipsoid.\n   *\n   * @memberOf UniformState.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid ?? Ellipsoid.default;\n    },\n  },\n});\n\nfunction setView(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._view);\n  Matrix4.getMatrix3(matrix, uniformState._viewRotation);\n\n  uniformState._view3DDirty = true;\n  uniformState._inverseView3DDirty = true;\n  uniformState._modelViewDirty = true;\n  uniformState._modelView3DDirty = true;\n  uniformState._modelViewRelativeToEyeDirty = true;\n  uniformState._inverseModelViewDirty = true;\n  uniformState._inverseModelView3DDirty = true;\n  uniformState._viewProjectionDirty = true;\n  uniformState._inverseViewProjectionDirty = true;\n  uniformState._modelViewProjectionDirty = true;\n  uniformState._modelViewProjectionRelativeToEyeDirty = true;\n  uniformState._modelViewInfiniteProjectionDirty = true;\n  uniformState._normalDirty = true;\n  uniformState._inverseNormalDirty = true;\n  uniformState._normal3DDirty = true;\n  uniformState._inverseNormal3DDirty = true;\n}\n\nfunction setInverseView(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._inverseView);\n  Matrix4.getMatrix3(matrix, uniformState._inverseViewRotation);\n}\n\nfunction setProjection(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._projection);\n\n  uniformState._inverseProjectionDirty = true;\n  uniformState._viewProjectionDirty = true;\n  uniformState._inverseViewProjectionDirty = true;\n  uniformState._modelViewProjectionDirty = true;\n  uniformState._modelViewProjectionRelativeToEyeDirty = true;\n}\n\nfunction setInfiniteProjection(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._infiniteProjection);\n\n  uniformState._modelViewInfiniteProjectionDirty = true;\n}\n\nconst surfacePositionScratch = new Cartesian3();\nconst enuTransformScratch = new Matrix4();\n\nfunction setCamera(uniformState, camera) {\n  Cartesian3.clone(camera.positionWC, uniformState._cameraPosition);\n  Cartesian3.clone(camera.directionWC, uniformState._cameraDirection);\n  Cartesian3.clone(camera.rightWC, uniformState._cameraRight);\n  Cartesian3.clone(camera.upWC, uniformState._cameraUp);\n\n  const ellipsoid = uniformState._ellipsoid;\n  let surfacePosition;\n\n  const positionCartographic = camera.positionCartographic;\n  if (!defined(positionCartographic)) {\n    uniformState._eyeHeight = -ellipsoid.maximumRadius;\n    if (Cartesian3.magnitude(camera.positionWC) > 0.0) {\n      uniformState._eyeEllipsoidNormalEC = Cartesian3.normalize(\n        camera.positionWC,\n        uniformState._eyeEllipsoidNormalEC,\n      );\n    }\n    surfacePosition = ellipsoid.scaleToGeodeticSurface(\n      camera.positionWC,\n      surfacePositionScratch,\n    );\n  } else {\n    uniformState._eyeHeight = positionCartographic.height;\n    uniformState._eyeEllipsoidNormalEC =\n      ellipsoid.geodeticSurfaceNormalCartographic(\n        positionCartographic,\n        uniformState._eyeEllipsoidNormalEC,\n      );\n    surfacePosition = Cartesian3.fromRadians(\n      positionCartographic.longitude,\n      positionCartographic.latitude,\n      0.0,\n      ellipsoid,\n      surfacePositionScratch,\n    );\n  }\n\n  uniformState._encodedCameraPositionMCDirty = true;\n\n  if (!defined(surfacePosition)) {\n    return;\n  }\n\n  uniformState._eyeEllipsoidNormalEC = Matrix3.multiplyByVector(\n    uniformState._viewRotation,\n    uniformState._eyeEllipsoidNormalEC,\n    uniformState._eyeEllipsoidNormalEC,\n  );\n\n  const enuToWorld = Transforms.eastNorthUpToFixedFrame(\n    surfacePosition,\n    ellipsoid,\n    enuTransformScratch,\n  );\n  uniformState._enuToModel = Matrix4.multiplyTransformation(\n    uniformState.inverseModel,\n    enuToWorld,\n    uniformState._enuToModel,\n  );\n  uniformState._modelToEnu = Matrix4.inverseTransformation(\n    uniformState._enuToModel,\n    uniformState._modelToEnu,\n  );\n\n  if (\n    !CesiumMath.equalsEpsilon(\n      ellipsoid._radii.x,\n      ellipsoid._radii.y,\n      CesiumMath.EPSILON15,\n    )\n  ) {\n    // Ellipsoid curvature calculations assume radii.x === radii.y as is true for WGS84\n    return;\n  }\n\n  uniformState._eyeEllipsoidCurvature = ellipsoid.getLocalCurvature(\n    surfacePosition,\n    uniformState._eyeEllipsoidCurvature,\n  );\n}\n\nconst transformMatrix = new Matrix3();\nconst sunCartographicScratch = new Cartographic();\nfunction setSunAndMoonDirections(uniformState, frameState) {\n  Transforms.computeIcrfToCentralBodyFixedMatrix(\n    frameState.time,\n    transformMatrix,\n  );\n\n  let position =\n    Simon1994PlanetaryPositions.computeSunPositionInEarthInertialFrame(\n      frameState.time,\n      uniformState._sunPositionWC,\n    );\n  Matrix3.multiplyByVector(transformMatrix, position, position);\n\n  Cartesian3.normalize(position, uniformState._sunDirectionWC);\n\n  position = Matrix3.multiplyByVector(\n    uniformState.viewRotation3D,\n    position,\n    uniformState._sunDirectionEC,\n  );\n  Cartesian3.normalize(position, position);\n\n  position =\n    Simon1994PlanetaryPositions.computeMoonPositionInEarthInertialFrame(\n      frameState.time,\n      uniformState._moonDirectionEC,\n    );\n  Matrix3.multiplyByVector(transformMatrix, position, position);\n  Matrix3.multiplyByVector(uniformState.viewRotation3D, position, position);\n  Cartesian3.normalize(position, position);\n\n  const projection = frameState.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n  const sunCartographic = ellipsoid.cartesianToCartographic(\n    uniformState._sunPositionWC,\n    sunCartographicScratch,\n  );\n  projection.project(sunCartographic, uniformState._sunPositionColumbusView);\n}\n\n/**\n * Synchronizes the frustum's state with the camera state.  This is called\n * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms\n * are set to the right value.\n *\n * @param {object} camera The camera to synchronize with.\n */\nUniformState.prototype.updateCamera = function (camera) {\n  setView(this, camera.viewMatrix);\n  setInverseView(this, camera.inverseViewMatrix);\n  setCamera(this, camera);\n\n  this._entireFrustum.x = camera.frustum.near;\n  this._entireFrustum.y = camera.frustum.far;\n  this.updateFrustum(camera.frustum);\n\n  this._orthographicIn3D =\n    this._mode !== SceneMode.SCENE2D &&\n    camera.frustum instanceof OrthographicFrustum;\n};\n\n/**\n * Synchronizes the frustum's state with the uniform state.  This is called\n * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms\n * are set to the right value.\n *\n * @param {object} frustum The frustum to synchronize with.\n */\nUniformState.prototype.updateFrustum = function (frustum) {\n  // If any frustum parameters have changed, calling the frustum.projectionMatrix\n  // getter will recompute the projection before it is copied.\n  setProjection(this, frustum.projectionMatrix);\n\n  if (defined(frustum.infiniteProjectionMatrix)) {\n    setInfiniteProjection(this, frustum.infiniteProjectionMatrix);\n  }\n  this._currentFrustum.x = frustum.near;\n  this._currentFrustum.y = frustum.far;\n\n  this._farDepthFromNearPlusOne = frustum.far - frustum.near + 1.0;\n  this._log2FarDepthFromNearPlusOne = CesiumMath.log2(\n    this._farDepthFromNearPlusOne,\n  );\n  this._oneOverLog2FarDepthFromNearPlusOne =\n    1.0 / this._log2FarDepthFromNearPlusOne;\n\n  const offCenterFrustum = frustum.offCenterFrustum;\n  if (defined(offCenterFrustum)) {\n    frustum = offCenterFrustum;\n  }\n\n  this._frustumPlanes.x = frustum.top;\n  this._frustumPlanes.y = frustum.bottom;\n  this._frustumPlanes.z = frustum.left;\n  this._frustumPlanes.w = frustum.right;\n};\n\nUniformState.prototype.updatePass = function (pass) {\n  this._pass = pass;\n};\n\nconst EMPTY_ARRAY = [];\nconst defaultLight = new SunLight();\n\n/**\n * Synchronizes frame state with the uniform state.  This is called\n * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms\n * are set to the right value.\n *\n * @param {FrameState} frameState The frameState to synchronize with.\n */\nUniformState.prototype.update = function (frameState) {\n  this._mode = frameState.mode;\n  this._mapProjection = frameState.mapProjection;\n  this._ellipsoid = frameState.mapProjection.ellipsoid;\n  this._pixelRatio = frameState.pixelRatio;\n\n  const camera = frameState.camera;\n  this.updateCamera(camera);\n\n  if (frameState.mode === SceneMode.SCENE2D) {\n    this._frustum2DWidth = camera.frustum.right - camera.frustum.left;\n    this._eyeHeight2D.x = this._frustum2DWidth * 0.5;\n    this._eyeHeight2D.y = this._eyeHeight2D.x * this._eyeHeight2D.x;\n  } else {\n    this._frustum2DWidth = 0.0;\n    this._eyeHeight2D.x = 0.0;\n    this._eyeHeight2D.y = 0.0;\n  }\n\n  setSunAndMoonDirections(this, frameState);\n\n  const light = frameState.light ?? defaultLight;\n  if (light instanceof SunLight) {\n    this._lightDirectionWC = Cartesian3.clone(\n      this._sunDirectionWC,\n      this._lightDirectionWC,\n    );\n    this._lightDirectionEC = Cartesian3.clone(\n      this._sunDirectionEC,\n      this._lightDirectionEC,\n    );\n  } else {\n    this._lightDirectionWC = Cartesian3.normalize(\n      Cartesian3.negate(light.direction, this._lightDirectionWC),\n      this._lightDirectionWC,\n    );\n    this._lightDirectionEC = Matrix3.multiplyByVector(\n      this.viewRotation3D,\n      this._lightDirectionWC,\n      this._lightDirectionEC,\n    );\n  }\n\n  const lightColor = light.color;\n  let lightColorHdr = Cartesian3.fromElements(\n    lightColor.red,\n    lightColor.green,\n    lightColor.blue,\n    this._lightColorHdr,\n  );\n  lightColorHdr = Cartesian3.multiplyByScalar(\n    lightColorHdr,\n    light.intensity,\n    lightColorHdr,\n  );\n  const maximumComponent = Cartesian3.maximumComponent(lightColorHdr);\n  if (maximumComponent > 1.0) {\n    Cartesian3.divideByScalar(\n      lightColorHdr,\n      maximumComponent,\n      this._lightColor,\n    );\n  } else {\n    Cartesian3.clone(lightColorHdr, this._lightColor);\n  }\n\n  const brdfLutGenerator = frameState.brdfLutGenerator;\n  const brdfLut = defined(brdfLutGenerator)\n    ? brdfLutGenerator.colorTexture\n    : undefined;\n  this._brdfLut = brdfLut;\n\n  this._environmentMap =\n    frameState.environmentMap ?? frameState.context.defaultCubeMap;\n\n  // IE 11 doesn't optimize out uniforms that are #ifdef'd out. So undefined values for the spherical harmonic\n  // coefficients cause a crash.\n  this._sphericalHarmonicCoefficients =\n    frameState.sphericalHarmonicCoefficients ?? EMPTY_ARRAY;\n  this._specularEnvironmentMaps = frameState.specularEnvironmentMaps;\n  this._specularEnvironmentMapsMaximumLOD =\n    frameState.specularEnvironmentMapsMaximumLOD;\n\n  this._fogDensity = frameState.fog.density;\n  this._fogVisualDensityScalar = frameState.fog.visualDensityScalar;\n  this._fogMinimumBrightness = frameState.fog.minimumBrightness;\n\n  const atmosphere = frameState.atmosphere;\n  if (defined(atmosphere)) {\n    this._atmosphereHsbShift = Cartesian3.fromElements(\n      atmosphere.hueShift,\n      atmosphere.saturationShift,\n      atmosphere.brightnessShift,\n      this._atmosphereHsbShift,\n    );\n    this._atmosphereLightIntensity = atmosphere.lightIntensity;\n    this._atmosphereRayleighCoefficient = Cartesian3.clone(\n      atmosphere.rayleighCoefficient,\n      this._atmosphereRayleighCoefficient,\n    );\n    this._atmosphereRayleighScaleHeight = atmosphere.rayleighScaleHeight;\n    this._atmosphereMieCoefficient = Cartesian3.clone(\n      atmosphere.mieCoefficient,\n      this._atmosphereMieCoefficient,\n    );\n    this._atmosphereMieScaleHeight = atmosphere.mieScaleHeight;\n    this._atmosphereMieAnisotropy = atmosphere.mieAnisotropy;\n    this._atmosphereDynamicLighting = atmosphere.dynamicLighting;\n  }\n\n  this._invertClassificationColor = frameState.invertClassificationColor;\n\n  this._frameState = frameState;\n  this._temeToPseudoFixed = Transforms.computeTemeToPseudoFixedMatrix(\n    frameState.time,\n    this._temeToPseudoFixed,\n  );\n\n  // Convert the relative splitPosition to absolute pixel coordinates\n  this._splitPosition =\n    frameState.splitPosition * frameState.context.drawingBufferWidth;\n  const fov = camera.frustum.fov;\n  const viewport = this._viewport;\n  let pixelSizePerMeter;\n  if (defined(fov)) {\n    if (viewport.height > viewport.width) {\n      pixelSizePerMeter = (Math.tan(0.5 * fov) * 2.0) / viewport.height;\n    } else {\n      pixelSizePerMeter = (Math.tan(0.5 * fov) * 2.0) / viewport.width;\n    }\n  } else {\n    pixelSizePerMeter = 1.0 / Math.max(viewport.width, viewport.height);\n  }\n\n  this._geometricToleranceOverMeter =\n    pixelSizePerMeter * frameState.maximumScreenSpaceError;\n  Color.clone(frameState.backgroundColor, this._backgroundColor);\n\n  this._minimumDisableDepthTestDistance =\n    frameState.minimumDisableDepthTestDistance;\n  this._minimumDisableDepthTestDistance *=\n    this._minimumDisableDepthTestDistance;\n  if (this._minimumDisableDepthTestDistance === Number.POSITIVE_INFINITY) {\n    this._minimumDisableDepthTestDistance = -1.0;\n  }\n};\n\nfunction cleanViewport(uniformState) {\n  if (uniformState._viewportDirty) {\n    const v = uniformState._viewport;\n    Matrix4.computeOrthographicOffCenter(\n      v.x,\n      v.x + v.width,\n      v.y,\n      v.y + v.height,\n      0.0,\n      1.0,\n      uniformState._viewportOrthographicMatrix,\n    );\n    Matrix4.computeViewportTransformation(\n      v,\n      0.0,\n      1.0,\n      uniformState._viewportTransformation,\n    );\n    uniformState._viewportDirty = false;\n  }\n}\n\nfunction cleanInverseProjection(uniformState) {\n  if (uniformState._inverseProjectionDirty) {\n    uniformState._inverseProjectionDirty = false;\n\n    if (\n      uniformState._mode !== SceneMode.SCENE2D &&\n      uniformState._mode !== SceneMode.MORPHING &&\n      !uniformState._orthographicIn3D\n    ) {\n      Matrix4.inverse(\n        uniformState._projection,\n        uniformState._inverseProjection,\n      );\n    } else {\n      Matrix4.clone(Matrix4.ZERO, uniformState._inverseProjection);\n    }\n  }\n}\n\n// Derived\nfunction cleanModelView(uniformState) {\n  if (uniformState._modelViewDirty) {\n    uniformState._modelViewDirty = false;\n\n    Matrix4.multiplyTransformation(\n      uniformState._view,\n      uniformState._model,\n      uniformState._modelView,\n    );\n  }\n}\n\nfunction cleanModelView3D(uniformState) {\n  if (uniformState._modelView3DDirty) {\n    uniformState._modelView3DDirty = false;\n\n    Matrix4.multiplyTransformation(\n      uniformState.view3D,\n      uniformState._model,\n      uniformState._modelView3D,\n    );\n  }\n}\n\nfunction cleanInverseModelView(uniformState) {\n  if (uniformState._inverseModelViewDirty) {\n    uniformState._inverseModelViewDirty = false;\n\n    Matrix4.inverse(uniformState.modelView, uniformState._inverseModelView);\n  }\n}\n\nfunction cleanInverseModelView3D(uniformState) {\n  if (uniformState._inverseModelView3DDirty) {\n    uniformState._inverseModelView3DDirty = false;\n\n    Matrix4.inverse(uniformState.modelView3D, uniformState._inverseModelView3D);\n  }\n}\n\nfunction cleanViewProjection(uniformState) {\n  if (uniformState._viewProjectionDirty) {\n    uniformState._viewProjectionDirty = false;\n\n    Matrix4.multiply(\n      uniformState._projection,\n      uniformState._view,\n      uniformState._viewProjection,\n    );\n  }\n}\n\nfunction cleanInverseViewProjection(uniformState) {\n  if (uniformState._inverseViewProjectionDirty) {\n    uniformState._inverseViewProjectionDirty = false;\n\n    Matrix4.inverse(\n      uniformState.viewProjection,\n      uniformState._inverseViewProjection,\n    );\n  }\n}\n\nfunction cleanModelViewProjection(uniformState) {\n  if (uniformState._modelViewProjectionDirty) {\n    uniformState._modelViewProjectionDirty = false;\n\n    Matrix4.multiply(\n      uniformState._projection,\n      uniformState.modelView,\n      uniformState._modelViewProjection,\n    );\n  }\n}\n\nfunction cleanModelViewRelativeToEye(uniformState) {\n  if (uniformState._modelViewRelativeToEyeDirty) {\n    uniformState._modelViewRelativeToEyeDirty = false;\n\n    const mv = uniformState.modelView;\n    const mvRte = uniformState._modelViewRelativeToEye;\n    mvRte[0] = mv[0];\n    mvRte[1] = mv[1];\n    mvRte[2] = mv[2];\n    mvRte[3] = mv[3];\n    mvRte[4] = mv[4];\n    mvRte[5] = mv[5];\n    mvRte[6] = mv[6];\n    mvRte[7] = mv[7];\n    mvRte[8] = mv[8];\n    mvRte[9] = mv[9];\n    mvRte[10] = mv[10];\n    mvRte[11] = mv[11];\n    mvRte[12] = 0.0;\n    mvRte[13] = 0.0;\n    mvRte[14] = 0.0;\n    mvRte[15] = mv[15];\n  }\n}\n\nfunction cleanInverseModelViewProjection(uniformState) {\n  if (uniformState._inverseModelViewProjectionDirty) {\n    uniformState._inverseModelViewProjectionDirty = false;\n\n    Matrix4.inverse(\n      uniformState.modelViewProjection,\n      uniformState._inverseModelViewProjection,\n    );\n  }\n}\n\nfunction cleanModelViewProjectionRelativeToEye(uniformState) {\n  if (uniformState._modelViewProjectionRelativeToEyeDirty) {\n    uniformState._modelViewProjectionRelativeToEyeDirty = false;\n\n    Matrix4.multiply(\n      uniformState._projection,\n      uniformState.modelViewRelativeToEye,\n      uniformState._modelViewProjectionRelativeToEye,\n    );\n  }\n}\n\nfunction cleanModelViewInfiniteProjection(uniformState) {\n  if (uniformState._modelViewInfiniteProjectionDirty) {\n    uniformState._modelViewInfiniteProjectionDirty = false;\n\n    Matrix4.multiply(\n      uniformState._infiniteProjection,\n      uniformState.modelView,\n      uniformState._modelViewInfiniteProjection,\n    );\n  }\n}\n\nfunction cleanNormal(uniformState) {\n  if (uniformState._normalDirty) {\n    uniformState._normalDirty = false;\n\n    const m = uniformState._normal;\n    Matrix4.getMatrix3(uniformState.inverseModelView, m);\n    Matrix3.transpose(m, m);\n  }\n}\n\nfunction cleanNormal3D(uniformState) {\n  if (uniformState._normal3DDirty) {\n    uniformState._normal3DDirty = false;\n\n    const m = uniformState._normal3D;\n    Matrix4.getMatrix3(uniformState.inverseModelView3D, m);\n    Matrix3.transpose(m, m);\n  }\n}\n\nfunction cleanInverseNormal(uniformState) {\n  if (uniformState._inverseNormalDirty) {\n    uniformState._inverseNormalDirty = false;\n\n    const m = uniformState._inverseNormal;\n    Matrix4.getMatrix3(uniformState.modelView, m);\n    Matrix3.transpose(m, m);\n  }\n}\n\nfunction cleanInverseNormal3D(uniformState) {\n  if (uniformState._inverseNormal3DDirty) {\n    uniformState._inverseNormal3DDirty = false;\n\n    const m = uniformState._inverseNormal3D;\n    Matrix4.getMatrix3(uniformState.modelView3D, m);\n    Matrix3.transpose(m, m);\n  }\n}\n\nconst cameraPositionMC = new Cartesian3();\n\nfunction cleanEncodedCameraPositionMC(uniformState) {\n  if (uniformState._encodedCameraPositionMCDirty) {\n    uniformState._encodedCameraPositionMCDirty = false;\n\n    Matrix4.multiplyByPoint(\n      uniformState.inverseModel,\n      uniformState._cameraPosition,\n      cameraPositionMC,\n    );\n    EncodedCartesian3.fromCartesian(\n      cameraPositionMC,\n      uniformState._encodedCameraPositionMC,\n    );\n  }\n}\n\nconst view2Dto3DPScratch = new Cartesian3();\nconst view2Dto3DRScratch = new Cartesian3();\nconst view2Dto3DUScratch = new Cartesian3();\nconst view2Dto3DDScratch = new Cartesian3();\nconst view2Dto3DCartographicScratch = new Cartographic();\nconst view2Dto3DCartesian3Scratch = new Cartesian3();\nconst view2Dto3DMatrix4Scratch = new Matrix4();\n\nfunction view2Dto3D(\n  position2D,\n  direction2D,\n  right2D,\n  up2D,\n  frustum2DWidth,\n  mode,\n  projection,\n  result,\n) {\n  // The camera position and directions are expressed in the 2D coordinate system where the Y axis is to the East,\n  // the Z axis is to the North, and the X axis is out of the map.  Express them instead in the ENU axes where\n  // X is to the East, Y is to the North, and Z is out of the local horizontal plane.\n  const p = view2Dto3DPScratch;\n  p.x = position2D.y;\n  p.y = position2D.z;\n  p.z = position2D.x;\n\n  const r = view2Dto3DRScratch;\n  r.x = right2D.y;\n  r.y = right2D.z;\n  r.z = right2D.x;\n\n  const u = view2Dto3DUScratch;\n  u.x = up2D.y;\n  u.y = up2D.z;\n  u.z = up2D.x;\n\n  const d = view2Dto3DDScratch;\n  d.x = direction2D.y;\n  d.y = direction2D.z;\n  d.z = direction2D.x;\n\n  // In 2D, the camera height is always 12.7 million meters.\n  // The apparent height is equal to half the frustum width.\n  if (mode === SceneMode.SCENE2D) {\n    p.z = frustum2DWidth * 0.5;\n  }\n\n  // Compute the equivalent camera position in the real (3D) world.\n  // In 2D and Columbus View, the camera can travel outside the projection, and when it does so\n  // there's not really any corresponding location in the real world.  So clamp the unprojected\n  // longitude and latitude to their valid ranges.\n  const cartographic = projection.unproject(p, view2Dto3DCartographicScratch);\n  cartographic.longitude = CesiumMath.clamp(\n    cartographic.longitude,\n    -Math.PI,\n    Math.PI,\n  );\n  cartographic.latitude = CesiumMath.clamp(\n    cartographic.latitude,\n    -CesiumMath.PI_OVER_TWO,\n    CesiumMath.PI_OVER_TWO,\n  );\n  const ellipsoid = projection.ellipsoid;\n  const position3D = ellipsoid.cartographicToCartesian(\n    cartographic,\n    view2Dto3DCartesian3Scratch,\n  );\n\n  // Compute the rotation from the local ENU at the real world camera position to the fixed axes.\n  const enuToFixed = Transforms.eastNorthUpToFixedFrame(\n    position3D,\n    ellipsoid,\n    view2Dto3DMatrix4Scratch,\n  );\n\n  // Transform each camera direction to the fixed axes.\n  Matrix4.multiplyByPointAsVector(enuToFixed, r, r);\n  Matrix4.multiplyByPointAsVector(enuToFixed, u, u);\n  Matrix4.multiplyByPointAsVector(enuToFixed, d, d);\n\n  // Compute the view matrix based on the new fixed-frame camera position and directions.\n  if (!defined(result)) {\n    result = new Matrix4();\n  }\n\n  result[0] = r.x;\n  result[1] = u.x;\n  result[2] = -d.x;\n  result[3] = 0.0;\n  result[4] = r.y;\n  result[5] = u.y;\n  result[6] = -d.y;\n  result[7] = 0.0;\n  result[8] = r.z;\n  result[9] = u.z;\n  result[10] = -d.z;\n  result[11] = 0.0;\n  result[12] = -Cartesian3.dot(r, position3D);\n  result[13] = -Cartesian3.dot(u, position3D);\n  result[14] = Cartesian3.dot(d, position3D);\n  result[15] = 1.0;\n\n  return result;\n}\n\nfunction updateView3D(that) {\n  if (that._view3DDirty) {\n    if (that._mode === SceneMode.SCENE3D) {\n      Matrix4.clone(that._view, that._view3D);\n    } else {\n      view2Dto3D(\n        that._cameraPosition,\n        that._cameraDirection,\n        that._cameraRight,\n        that._cameraUp,\n        that._frustum2DWidth,\n        that._mode,\n        that._mapProjection,\n        that._view3D,\n      );\n    }\n    Matrix4.getMatrix3(that._view3D, that._viewRotation3D);\n    that._view3DDirty = false;\n  }\n}\n\nfunction updateInverseView3D(that) {\n  if (that._inverseView3DDirty) {\n    Matrix4.inverseTransformation(that.view3D, that._inverseView3D);\n    Matrix4.getMatrix3(that._inverseView3D, that._inverseViewRotation3D);\n    that._inverseView3DDirty = false;\n  }\n}\nexport default UniformState;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}