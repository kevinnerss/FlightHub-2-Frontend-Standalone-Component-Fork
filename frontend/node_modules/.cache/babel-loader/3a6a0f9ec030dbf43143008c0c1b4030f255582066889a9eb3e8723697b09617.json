{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-hex.js\";\nimport \"core-js/modules/esnext.uint8-array.to-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.to-hex.js\";\n/*\n Copyright (c) 2025 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright\n notice, this list of conditions and the following disclaimer in\n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* global TransformStream, Response */\n// deno-lint-ignore-file no-this-alias\n\nimport { MAX_32_BITS, MAX_16_BITS, MAX_8_BITS, COMPRESSION_METHOD_DEFLATE, COMPRESSION_METHOD_DEFLATE_64, COMPRESSION_METHOD_STORE, COMPRESSION_METHOD_AES, SPLIT_ZIP_FILE_SIGNATURE, LOCAL_FILE_HEADER_SIGNATURE, DATA_DESCRIPTOR_RECORD_SIGNATURE, CENTRAL_FILE_HEADER_SIGNATURE, END_OF_CENTRAL_DIR_SIGNATURE, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE, ZIP64_END_OF_CENTRAL_DIR_SIGNATURE, DATA_DESCRIPTOR_RECORD_LENGTH, DATA_DESCRIPTOR_RECORD_ZIP_64_LENGTH, DATA_DESCRIPTOR_RECORD_SIGNATURE_LENGTH, EXTRAFIELD_TYPE_AES, EXTRAFIELD_TYPE_ZIP64, EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP, EXTRAFIELD_TYPE_NTFS, EXTRAFIELD_TYPE_NTFS_TAG1, EXTRAFIELD_TYPE_USDZ, EXTRAFIELD_TYPE_INFOZIP, EXTRAFIELD_TYPE_UNIX, END_OF_CENTRAL_DIR_LENGTH, ZIP64_END_OF_CENTRAL_DIR_LENGTH, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH, ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH, BITFLAG_ENCRYPTED, BITFLAG_DATA_DESCRIPTOR, BITFLAG_LANG_ENCODING_FLAG, BITFLAG_LEVEL_FAST_MASK, BITFLAG_LEVEL_SUPER_FAST_MASK, BITFLAG_LEVEL_MAX_MASK, FILE_ATTR_MSDOS_DIR_MASK, FILE_ATTR_MSDOS_READONLY_MASK, FILE_ATTR_MSDOS_HIDDEN_MASK, FILE_ATTR_MSDOS_SYSTEM_MASK, FILE_ATTR_MSDOS_ARCHIVE_MASK, FILE_ATTR_UNIX_TYPE_DIR, FILE_ATTR_UNIX_EXECUTABLE_MASK, FILE_ATTR_UNIX_DEFAULT_MASK, FILE_ATTR_UNIX_SETUID_MASK, FILE_ATTR_UNIX_SETGID_MASK, FILE_ATTR_UNIX_STICKY_MASK, VERSION_DEFLATE, VERSION_ZIP64, VERSION_AES, DIRECTORY_SIGNATURE, HEADER_SIZE, HEADER_OFFSET_SIGNATURE, HEADER_OFFSET_COMPRESSED_SIZE, HEADER_OFFSET_UNCOMPRESSED_SIZE, MIN_DATE, MAX_DATE, UNDEFINED_VALUE, OBJECT_TYPE } from \"./constants.js\";\nimport { getConfiguration, getChunkSize } from \"./configuration.js\";\nimport { CODEC_DEFLATE, runWorker } from \"./codec-pool.js\";\nimport { initStream, GenericWriter, GenericReader } from \"./io.js\";\nimport { encodeText } from \"./util/encode-text.js\";\nimport { PROPERTY_NAME_LAST_MODIFICATION_DATE, PROPERTY_NAME_LAST_ACCESS_DATE, PROPERTY_NAME_CREATION_DATE, PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTES, PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTES, PROPERTY_NAME_MS_DOS_COMPATIBLE, PROPERTY_NAME_ZIP64, PROPERTY_NAME_ENCRYPTED, PROPERTY_NAME_VERSION, PROPERTY_NAME_VERSION_MADE_BY, PROPERTY_NAME_ZIPCRYPTO, PROPERTY_NAME_DIRECTORY, PROPERTY_NAME_EXECUTABLE, PROPERTY_NAME_COMPRESSION_METHOD, PROPERTY_NAME_SIGNATURE, PROPERTY_NAME_COMMENT, PROPERTY_NAME_UNCOMPRESSED_SIZE, PROPERTY_NAME_EXTRA_FIELD, PROPERTY_NAME_UID, PROPERTY_NAME_GID, PROPERTY_NAME_UNIX_MODE, PROPERTY_NAME_SETUID, PROPERTY_NAME_SETGID, PROPERTY_NAME_STICKY, PROPERTY_NAME_MSDOS_ATTRIBUTES, PROPERTY_NAME_MSDOS_ATTRIBUTES_RAW, Entry } from \"./zip-entry.js\";\nimport { OPTION_PASSWORD, OPTION_RAW_PASSWORD, OPTION_PASS_THROUGH, OPTION_SIGNAL, OPTION_USE_WEB_WORKERS, OPTION_USE_COMPRESSION_STREAM, OPTION_PREVENT_CLOSE, OPTION_ENCRYPTION_STRENGTH, OPTION_EXTENDED_TIMESTAMP, OPTION_KEEP_ORDER, OPTION_LEVEL, OPTION_BUFFERED_WRITE, OPTION_DATA_DESCRIPTOR_SIGNATURE, OPTION_USE_UNICODE_FILE_NAMES, OPTION_DATA_DESCRIPTOR, OPTION_SUPPORT_ZIP64_SPLIT_FILE, OPTION_ENCODE_TEXT, OPTION_OFFSET, OPTION_USDZ, OPTION_UNIX_EXTRA_FIELD_TYPE } from \"./options.js\";\nimport { ZipReader } from \"./zip-reader.js\";\nconst ERR_DUPLICATED_NAME = \"File already exists\";\nconst ERR_INVALID_COMMENT = \"Zip file comment exceeds 64KB\";\nconst ERR_INVALID_ENTRY_COMMENT = \"File entry comment exceeds 64KB\";\nconst ERR_INVALID_ENTRY_NAME = \"File entry name exceeds 64KB\";\nconst ERR_INVALID_VERSION = \"Version exceeds 65535\";\nconst ERR_INVALID_ENCRYPTION_STRENGTH = \"The strength must equal 1, 2, or 3\";\nconst ERR_INVALID_EXTRAFIELD_TYPE = \"Extra field type exceeds 65535\";\nconst ERR_INVALID_EXTRAFIELD_DATA = \"Extra field data exceeds 64KB\";\nconst ERR_UNSUPPORTED_FORMAT = \"Zip64 is not supported (make sure 'keepOrder' is set to 'true')\";\nconst ERR_UNDEFINED_UNCOMPRESSED_SIZE = \"Undefined uncompressed size\";\nconst ERR_ZIP_NOT_EMPTY = \"Zip file not empty\";\nconst ERR_INVALID_UID = \"Invalid uid (must be integer 0..2^32-1)\";\nconst ERR_INVALID_GID = \"Invalid gid (must be integer 0..2^32-1)\";\nconst ERR_INVALID_UNIX_MODE = \"Invalid UNIX mode (must be integer 0..65535)\";\nconst ERR_INVALID_UNIX_EXTRA_FIELD_TYPE = \"Invalid unixExtraFieldType (must be 'infozip' or 'unix')\";\nconst ERR_INVALID_MSDOS_ATTRIBUTES = \"Invalid msdosAttributesRaw (must be integer 0..255)\";\nconst ERR_INVALID_MSDOS_DATA = \"Invalid msdosAttributes (must be an object with boolean flags)\";\nconst EXTRAFIELD_DATA_AES = new Uint8Array([0x07, 0x00, 0x02, 0x00, 0x41, 0x45, 0x03, 0x00, 0x00]);\nconst INFOZIP_EXTRA_FIELD_TYPE = \"infozip\";\nconst UNIX_EXTRA_FIELD_TYPE = \"unix\";\nlet workers = 0;\nconst pendingEntries = [];\nclass ZipWriter {\n  constructor(writer, options = {}) {\n    writer = new GenericWriter(writer);\n    const addSplitZipSignature = writer.availableSize !== UNDEFINED_VALUE && writer.availableSize > 0 && writer.availableSize !== Infinity && writer.maxSize !== UNDEFINED_VALUE && writer.maxSize > 0 && writer.maxSize !== Infinity;\n    Object.assign(this, {\n      writer,\n      addSplitZipSignature,\n      options,\n      config: getConfiguration(),\n      files: new Map(),\n      filenames: new Set(),\n      offset: options[OPTION_OFFSET] === UNDEFINED_VALUE ? writer.size || writer.writable.size || 0 : options[OPTION_OFFSET],\n      pendingEntriesSize: 0,\n      pendingAddFileCalls: new Set(),\n      bufferedWrites: 0\n    });\n  }\n  async prependZip(reader) {\n    if (this.filenames.size) {\n      throw new Error(ERR_ZIP_NOT_EMPTY);\n    }\n    reader = new GenericReader(reader);\n    const zipReader = new ZipReader(reader.readable);\n    const entries = await zipReader.getEntries();\n    await zipReader.close();\n    await reader.readable.pipeTo(this.writer.writable, {\n      preventClose: true,\n      preventAbort: true\n    });\n    this.writer.size = this.offset = reader.size;\n    this.filenames = new Set(entries.map(entry => entry.filename));\n    this.files = new Map(entries.map(entry => {\n      const {\n        version,\n        compressionMethod,\n        lastModDate,\n        lastAccessDate,\n        creationDate,\n        rawFilename,\n        bitFlag,\n        encrypted,\n        uncompressedSize,\n        compressedSize,\n        diskOffset,\n        diskNumber,\n        zip64\n      } = entry;\n      let {\n        rawExtraFieldZip64,\n        rawExtraFieldAES,\n        rawExtraFieldExtendedTimestamp,\n        rawExtraFieldNTFS,\n        rawExtraFieldUnix,\n        rawExtraField\n      } = entry;\n      const {\n        level,\n        languageEncodingFlag,\n        dataDescriptor\n      } = bitFlag;\n      rawExtraFieldZip64 = rawExtraFieldZip64 || new Uint8Array();\n      rawExtraFieldAES = rawExtraFieldAES || new Uint8Array();\n      rawExtraFieldExtendedTimestamp = rawExtraFieldExtendedTimestamp || new Uint8Array();\n      rawExtraFieldNTFS = rawExtraFieldNTFS || new Uint8Array();\n      rawExtraFieldUnix = entry.rawExtraFieldUnix || new Uint8Array();\n      rawExtraField = rawExtraField || new Uint8Array();\n      const extraFieldLength = getLength(rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS, rawExtraFieldUnix, rawExtraField);\n      const zip64UncompressedSize = zip64 && uncompressedSize > MAX_32_BITS;\n      const zip64CompressedSize = zip64 && compressedSize > MAX_32_BITS;\n      const {\n        headerArray,\n        headerView\n      } = getHeaderArrayData({\n        version,\n        bitFlag: getBitFlag(level, languageEncodingFlag, dataDescriptor, encrypted, compressionMethod),\n        compressionMethod,\n        uncompressedSize,\n        compressedSize,\n        lastModDate,\n        rawFilename,\n        zip64CompressedSize,\n        zip64UncompressedSize,\n        extraFieldLength\n      });\n      Object.assign(entry, {\n        zip64UncompressedSize,\n        zip64CompressedSize,\n        zip64Offset: zip64 && this.offset - diskOffset > MAX_32_BITS,\n        zip64DiskNumberStart: zip64 && diskNumber > MAX_16_BITS,\n        rawExtraFieldZip64,\n        rawExtraFieldAES,\n        rawExtraFieldExtendedTimestamp,\n        rawExtraFieldNTFS,\n        rawExtraFieldUnix,\n        rawExtraField,\n        extendedTimestamp: rawExtraFieldExtendedTimestamp.length > 0 || rawExtraFieldNTFS.length > 0,\n        extraFieldExtendedTimestampFlag: 0x1 + (lastAccessDate ? 0x2 : 0) + (creationDate ? 0x4 : 0),\n        headerArray,\n        headerView\n      });\n      return [entry.filename, entry];\n    }));\n  }\n  async add(name = \"\", reader, options = {}) {\n    const zipWriter = this;\n    const {\n      pendingAddFileCalls,\n      config\n    } = zipWriter;\n    if (workers < config.maxWorkers) {\n      workers++;\n    } else {\n      await new Promise(resolve => pendingEntries.push(resolve));\n    }\n    let promiseAddFile;\n    try {\n      name = name.trim();\n      if (zipWriter.filenames.has(name)) {\n        throw new Error(ERR_DUPLICATED_NAME);\n      }\n      zipWriter.filenames.add(name);\n      promiseAddFile = addFile(zipWriter, name, reader, options);\n      pendingAddFileCalls.add(promiseAddFile);\n      return await promiseAddFile;\n    } catch (error) {\n      zipWriter.filenames.delete(name);\n      throw error;\n    } finally {\n      pendingAddFileCalls.delete(promiseAddFile);\n      const pendingEntry = pendingEntries.shift();\n      if (pendingEntry) {\n        pendingEntry();\n      } else {\n        workers--;\n      }\n    }\n  }\n  remove(entry) {\n    const {\n      filenames,\n      files\n    } = this;\n    if (typeof entry == \"string\") {\n      entry = files.get(entry);\n    }\n    if (entry && entry.filename !== UNDEFINED_VALUE) {\n      const {\n        filename\n      } = entry;\n      if (filenames.has(filename) && files.has(filename)) {\n        filenames.delete(filename);\n        files.delete(filename);\n        return true;\n      }\n    }\n    return false;\n  }\n  async close(comment = new Uint8Array(), options = {}) {\n    const zipWriter = this;\n    const {\n      pendingAddFileCalls,\n      writer\n    } = this;\n    const {\n      writable\n    } = writer;\n    while (pendingAddFileCalls.size) {\n      await Promise.allSettled(Array.from(pendingAddFileCalls));\n    }\n    await closeFile(zipWriter, comment, options);\n    const preventClose = getOptionValue(zipWriter, options, OPTION_PREVENT_CLOSE);\n    if (!preventClose) {\n      await writable.getWriter().close();\n    }\n    return writer.getData ? writer.getData() : writable;\n  }\n}\nclass ZipWriterStream {\n  constructor(options = {}) {\n    const {\n      readable,\n      writable\n    } = new TransformStream();\n    this.readable = readable;\n    this.zipWriter = new ZipWriter(writable, options);\n  }\n  transform(path) {\n    const {\n      readable,\n      writable\n    } = new TransformStream({\n      flush: () => {\n        this.zipWriter.close();\n      }\n    });\n    this.zipWriter.add(path, readable);\n    return {\n      readable: this.readable,\n      writable\n    };\n  }\n  writable(path) {\n    const {\n      readable,\n      writable\n    } = new TransformStream();\n    this.zipWriter.add(path, readable);\n    return writable;\n  }\n  close(comment = UNDEFINED_VALUE, options = {}) {\n    return this.zipWriter.close(comment, options);\n  }\n}\nexport { ZipWriter, ZipWriterStream, ERR_DUPLICATED_NAME, ERR_INVALID_COMMENT, ERR_INVALID_ENTRY_NAME, ERR_INVALID_ENTRY_COMMENT, ERR_INVALID_VERSION, ERR_INVALID_EXTRAFIELD_TYPE, ERR_INVALID_EXTRAFIELD_DATA, ERR_INVALID_ENCRYPTION_STRENGTH, ERR_UNSUPPORTED_FORMAT, ERR_UNDEFINED_UNCOMPRESSED_SIZE, ERR_ZIP_NOT_EMPTY };\nasync function addFile(zipWriter, name, reader, options) {\n  name = name.trim();\n  let msDosCompatible = getOptionValue(zipWriter, options, PROPERTY_NAME_MS_DOS_COMPATIBLE);\n  let versionMadeBy = getOptionValue(zipWriter, options, PROPERTY_NAME_VERSION_MADE_BY, msDosCompatible ? 20 : 768);\n  const executable = getOptionValue(zipWriter, options, PROPERTY_NAME_EXECUTABLE);\n  const uid = getOptionValue(zipWriter, options, PROPERTY_NAME_UID);\n  const gid = getOptionValue(zipWriter, options, PROPERTY_NAME_GID);\n  let unixMode = getOptionValue(zipWriter, options, PROPERTY_NAME_UNIX_MODE);\n  const unixExtraFieldType = getOptionValue(zipWriter, options, OPTION_UNIX_EXTRA_FIELD_TYPE);\n  let setuid = getOptionValue(zipWriter, options, PROPERTY_NAME_SETUID);\n  let setgid = getOptionValue(zipWriter, options, PROPERTY_NAME_SETGID);\n  let sticky = getOptionValue(zipWriter, options, PROPERTY_NAME_STICKY);\n  if (uid !== UNDEFINED_VALUE && (uid < 0 || uid > MAX_32_BITS)) {\n    throw new Error(ERR_INVALID_UID);\n  }\n  if (gid !== UNDEFINED_VALUE && (gid < 0 || gid > MAX_32_BITS)) {\n    throw new Error(ERR_INVALID_GID);\n  }\n  if (unixMode !== UNDEFINED_VALUE && (unixMode < 0 || unixMode > MAX_16_BITS)) {\n    throw new Error(ERR_INVALID_UNIX_MODE);\n  }\n  if (unixExtraFieldType !== UNDEFINED_VALUE && unixExtraFieldType !== INFOZIP_EXTRA_FIELD_TYPE && unixExtraFieldType !== UNIX_EXTRA_FIELD_TYPE) {\n    throw new Error(ERR_INVALID_UNIX_EXTRA_FIELD_TYPE);\n  }\n  let msdosAttributesRaw = getOptionValue(zipWriter, options, PROPERTY_NAME_MSDOS_ATTRIBUTES_RAW);\n  let msdosAttributes = getOptionValue(zipWriter, options, PROPERTY_NAME_MSDOS_ATTRIBUTES);\n  const hasUnixMetadata = uid !== UNDEFINED_VALUE || gid !== UNDEFINED_VALUE || unixMode !== UNDEFINED_VALUE || unixExtraFieldType;\n  const hasMsDosProvided = msdosAttributesRaw !== UNDEFINED_VALUE || msdosAttributes !== UNDEFINED_VALUE;\n  if (hasUnixMetadata) {\n    msDosCompatible = false;\n    versionMadeBy = versionMadeBy & MAX_16_BITS | 3 << 8;\n  } else if (hasMsDosProvided) {\n    msDosCompatible = true;\n    versionMadeBy = versionMadeBy & MAX_8_BITS;\n  }\n  if (msdosAttributesRaw !== UNDEFINED_VALUE && (msdosAttributesRaw < 0 || msdosAttributesRaw > MAX_8_BITS)) {\n    throw new Error(ERR_INVALID_MSDOS_ATTRIBUTES);\n  }\n  if (msdosAttributes && typeof msdosAttributes !== OBJECT_TYPE) {\n    throw new Error(ERR_INVALID_MSDOS_DATA);\n  }\n  if (versionMadeBy > MAX_16_BITS) {\n    throw new Error(ERR_INVALID_VERSION);\n  }\n  let externalFileAttributes = getOptionValue(zipWriter, options, PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTES, 0);\n  if (!options[PROPERTY_NAME_DIRECTORY] && name.endsWith(DIRECTORY_SIGNATURE)) {\n    options[PROPERTY_NAME_DIRECTORY] = true;\n  }\n  const directory = getOptionValue(zipWriter, options, PROPERTY_NAME_DIRECTORY);\n  if (directory) {\n    if (!name.endsWith(DIRECTORY_SIGNATURE)) {\n      name += DIRECTORY_SIGNATURE;\n    }\n    if (externalFileAttributes === 0) {\n      externalFileAttributes = FILE_ATTR_MSDOS_DIR_MASK;\n      if (!msDosCompatible) {\n        externalFileAttributes |= (FILE_ATTR_UNIX_TYPE_DIR | FILE_ATTR_UNIX_EXECUTABLE_MASK | FILE_ATTR_UNIX_DEFAULT_MASK) << 16;\n      }\n    }\n  } else if (!msDosCompatible && externalFileAttributes === 0) {\n    if (executable) {\n      externalFileAttributes = (FILE_ATTR_UNIX_EXECUTABLE_MASK | FILE_ATTR_UNIX_DEFAULT_MASK) << 16;\n    } else {\n      externalFileAttributes = FILE_ATTR_UNIX_DEFAULT_MASK << 16;\n    }\n  }\n  let unixExternalUpper;\n  if (!msDosCompatible) {\n    unixExternalUpper = externalFileAttributes >> 16 & MAX_16_BITS;\n    unixMode = unixMode === UNDEFINED_VALUE ? unixExternalUpper : unixMode & MAX_16_BITS;\n    if (setuid) {\n      unixMode |= FILE_ATTR_UNIX_SETUID_MASK;\n    } else {\n      setuid = Boolean(unixMode & FILE_ATTR_UNIX_SETUID_MASK);\n    }\n    if (setgid) {\n      unixMode |= FILE_ATTR_UNIX_SETGID_MASK;\n    } else {\n      setgid = Boolean(unixMode & FILE_ATTR_UNIX_SETGID_MASK);\n    }\n    if (sticky) {\n      unixMode |= FILE_ATTR_UNIX_STICKY_MASK;\n    } else {\n      sticky = Boolean(unixMode & FILE_ATTR_UNIX_STICKY_MASK);\n    }\n    if (directory) {\n      unixMode |= FILE_ATTR_UNIX_TYPE_DIR;\n    }\n    externalFileAttributes = (unixMode & MAX_16_BITS) << 16 | externalFileAttributes & MAX_8_BITS;\n  }\n  ({\n    msdosAttributesRaw,\n    msdosAttributes\n  } = normalizeMsdosAttributes(msdosAttributesRaw, msdosAttributes));\n  if (hasMsDosProvided) {\n    externalFileAttributes = externalFileAttributes & MAX_32_BITS | msdosAttributesRaw & MAX_8_BITS;\n  }\n  const encode = getOptionValue(zipWriter, options, OPTION_ENCODE_TEXT, encodeText);\n  let rawFilename = encode(name);\n  if (rawFilename === UNDEFINED_VALUE) {\n    rawFilename = encodeText(name);\n  }\n  if (getLength(rawFilename) > MAX_16_BITS) {\n    throw new Error(ERR_INVALID_ENTRY_NAME);\n  }\n  const comment = options[PROPERTY_NAME_COMMENT] || \"\";\n  let rawComment = encode(comment);\n  if (rawComment === UNDEFINED_VALUE) {\n    rawComment = encodeText(comment);\n  }\n  if (getLength(rawComment) > MAX_16_BITS) {\n    throw new Error(ERR_INVALID_ENTRY_COMMENT);\n  }\n  const version = getOptionValue(zipWriter, options, PROPERTY_NAME_VERSION, VERSION_DEFLATE);\n  if (version > MAX_16_BITS) {\n    throw new Error(ERR_INVALID_VERSION);\n  }\n  const lastModDate = getOptionValue(zipWriter, options, PROPERTY_NAME_LAST_MODIFICATION_DATE, new Date());\n  const lastAccessDate = getOptionValue(zipWriter, options, PROPERTY_NAME_LAST_ACCESS_DATE);\n  const creationDate = getOptionValue(zipWriter, options, PROPERTY_NAME_CREATION_DATE);\n  const internalFileAttributes = getOptionValue(zipWriter, options, PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTES, 0);\n  const passThrough = getOptionValue(zipWriter, options, OPTION_PASS_THROUGH);\n  let password, rawPassword;\n  if (!passThrough) {\n    password = getOptionValue(zipWriter, options, OPTION_PASSWORD);\n    rawPassword = getOptionValue(zipWriter, options, OPTION_RAW_PASSWORD);\n  }\n  const encryptionStrength = getOptionValue(zipWriter, options, OPTION_ENCRYPTION_STRENGTH, 3);\n  const zipCrypto = getOptionValue(zipWriter, options, PROPERTY_NAME_ZIPCRYPTO);\n  const extendedTimestamp = getOptionValue(zipWriter, options, OPTION_EXTENDED_TIMESTAMP, true);\n  const keepOrder = getOptionValue(zipWriter, options, OPTION_KEEP_ORDER, true);\n  const useWebWorkers = getOptionValue(zipWriter, options, OPTION_USE_WEB_WORKERS);\n  const bufferedWrite = getOptionValue(zipWriter, options, OPTION_BUFFERED_WRITE);\n  const dataDescriptorSignature = getOptionValue(zipWriter, options, OPTION_DATA_DESCRIPTOR_SIGNATURE, false);\n  const signal = getOptionValue(zipWriter, options, OPTION_SIGNAL);\n  const useUnicodeFileNames = getOptionValue(zipWriter, options, OPTION_USE_UNICODE_FILE_NAMES, true);\n  const compressionMethod = getOptionValue(zipWriter, options, PROPERTY_NAME_COMPRESSION_METHOD);\n  let level = getOptionValue(zipWriter, options, OPTION_LEVEL);\n  let useCompressionStream = getOptionValue(zipWriter, options, OPTION_USE_COMPRESSION_STREAM);\n  let dataDescriptor = getOptionValue(zipWriter, options, OPTION_DATA_DESCRIPTOR);\n  if (bufferedWrite && dataDescriptor === UNDEFINED_VALUE) {\n    dataDescriptor = false;\n  }\n  if (dataDescriptor === UNDEFINED_VALUE || zipCrypto) {\n    dataDescriptor = true;\n  }\n  if (level !== UNDEFINED_VALUE && level != 6) {\n    useCompressionStream = false;\n  }\n  if (!useCompressionStream && zipWriter.config.CompressionStream === UNDEFINED_VALUE && zipWriter.config.CompressionStreamZlib === UNDEFINED_VALUE) {\n    level = 0;\n  }\n  let zip64 = getOptionValue(zipWriter, options, PROPERTY_NAME_ZIP64);\n  if (!zipCrypto && (password !== UNDEFINED_VALUE || rawPassword !== UNDEFINED_VALUE) && !(encryptionStrength >= 1 && encryptionStrength <= 3)) {\n    throw new Error(ERR_INVALID_ENCRYPTION_STRENGTH);\n  }\n  let rawExtraField = new Uint8Array();\n  const extraField = options[PROPERTY_NAME_EXTRA_FIELD];\n  if (extraField) {\n    let extraFieldSize = 0;\n    let offset = 0;\n    extraField.forEach(data => extraFieldSize += 4 + getLength(data));\n    rawExtraField = new Uint8Array(extraFieldSize);\n    extraField.forEach((data, type) => {\n      if (type > MAX_16_BITS) {\n        throw new Error(ERR_INVALID_EXTRAFIELD_TYPE);\n      }\n      if (getLength(data) > MAX_16_BITS) {\n        throw new Error(ERR_INVALID_EXTRAFIELD_DATA);\n      }\n      arraySet(rawExtraField, new Uint16Array([type]), offset);\n      arraySet(rawExtraField, new Uint16Array([getLength(data)]), offset + 2);\n      arraySet(rawExtraField, data, offset + 4);\n      offset += 4 + getLength(data);\n    });\n  }\n  let maximumCompressedSize = 0;\n  let maximumEntrySize = 0;\n  let uncompressedSize = 0;\n  if (passThrough) {\n    uncompressedSize = options[PROPERTY_NAME_UNCOMPRESSED_SIZE];\n    if (uncompressedSize === UNDEFINED_VALUE) {\n      throw new Error(ERR_UNDEFINED_UNCOMPRESSED_SIZE);\n    }\n  }\n  const zip64Enabled = zip64 === true;\n  if (reader) {\n    reader = new GenericReader(reader);\n    await initStream(reader);\n    if (!passThrough) {\n      if (reader.size === UNDEFINED_VALUE) {\n        dataDescriptor = true;\n        if (zip64 || zip64 === UNDEFINED_VALUE) {\n          zip64 = true;\n          uncompressedSize = maximumCompressedSize = MAX_32_BITS + 1;\n        }\n      } else {\n        options.uncompressedSize = uncompressedSize = reader.size;\n        maximumCompressedSize = getMaximumCompressedSize(uncompressedSize);\n      }\n    } else {\n      options.uncompressedSize = uncompressedSize;\n      maximumCompressedSize = getMaximumCompressedSize(uncompressedSize);\n    }\n  }\n  const {\n    diskOffset,\n    diskNumber,\n    maxSize\n  } = zipWriter.writer;\n  const zip64UncompressedSize = zip64Enabled || uncompressedSize > MAX_32_BITS;\n  const zip64CompressedSize = zip64Enabled || maximumCompressedSize > MAX_32_BITS;\n  const zip64Offset = zip64Enabled || zipWriter.offset + zipWriter.pendingEntriesSize - diskOffset > MAX_32_BITS;\n  const supportZip64SplitFile = getOptionValue(zipWriter, options, OPTION_SUPPORT_ZIP64_SPLIT_FILE, true);\n  const zip64DiskNumberStart = supportZip64SplitFile && zip64Enabled || diskNumber + Math.ceil(zipWriter.pendingEntriesSize / maxSize) > MAX_16_BITS;\n  if (zip64Offset || zip64UncompressedSize || zip64CompressedSize || zip64DiskNumberStart) {\n    if (zip64 === false || !keepOrder) {\n      throw new Error(ERR_UNSUPPORTED_FORMAT);\n    } else {\n      zip64 = true;\n    }\n  }\n  zip64 = zip64 || false;\n  const encrypted = getOptionValue(zipWriter, options, PROPERTY_NAME_ENCRYPTED);\n  options = Object.assign({}, options, {\n    rawFilename,\n    rawComment,\n    version,\n    versionMadeBy,\n    lastModDate,\n    lastAccessDate,\n    creationDate,\n    rawExtraField,\n    zip64,\n    zip64UncompressedSize,\n    zip64CompressedSize,\n    zip64Offset,\n    zip64DiskNumberStart,\n    password,\n    rawPassword,\n    level,\n    useWebWorkers,\n    encryptionStrength,\n    extendedTimestamp,\n    zipCrypto,\n    bufferedWrite,\n    keepOrder,\n    useUnicodeFileNames,\n    dataDescriptor,\n    dataDescriptorSignature,\n    signal,\n    msDosCompatible,\n    internalFileAttribute: internalFileAttributes,\n    internalFileAttributes,\n    externalFileAttribute: externalFileAttributes,\n    externalFileAttributes,\n    useCompressionStream,\n    passThrough,\n    encrypted: Boolean(password && getLength(password) || rawPassword && getLength(rawPassword)) || passThrough && encrypted,\n    signature: options[PROPERTY_NAME_SIGNATURE],\n    compressionMethod,\n    uncompressedSize,\n    offset: zipWriter.offset - diskOffset,\n    diskNumberStart: diskNumber,\n    uid,\n    gid,\n    setuid,\n    setgid,\n    sticky,\n    unixMode,\n    msdosAttributesRaw,\n    msdosAttributes,\n    unixExternalUpper\n  });\n  const headerInfo = getHeaderInfo(options);\n  const dataDescriptorInfo = getDataDescriptorInfo(options);\n  const metadataSize = getLength(headerInfo.localHeaderArray, dataDescriptorInfo.dataDescriptorArray);\n  maximumEntrySize = metadataSize + maximumCompressedSize;\n  if (zipWriter.options[OPTION_USDZ]) {\n    maximumEntrySize += maximumEntrySize + 64;\n  }\n  zipWriter.pendingEntriesSize += maximumEntrySize;\n  let fileEntry;\n  try {\n    fileEntry = await getFileEntry(zipWriter, name, reader, {\n      headerInfo,\n      dataDescriptorInfo,\n      metadataSize\n    }, options);\n  } finally {\n    zipWriter.pendingEntriesSize -= maximumEntrySize;\n  }\n  Object.assign(fileEntry, {\n    name,\n    comment,\n    extraField\n  });\n  return new Entry(fileEntry);\n}\nasync function getFileEntry(zipWriter, name, reader, entryInfo, options) {\n  const {\n    files,\n    writer\n  } = zipWriter;\n  const {\n    keepOrder,\n    dataDescriptor,\n    signal\n  } = options;\n  const {\n    headerInfo\n  } = entryInfo;\n  const usdz = zipWriter.options[OPTION_USDZ];\n  const previousFileEntry = Array.from(files.values()).pop();\n  let fileEntry = {};\n  let bufferedWrite;\n  let releaseLockWriter;\n  let releaseLockCurrentFileEntry;\n  let writingBufferedEntryData;\n  let writingEntryData;\n  let fileWriter;\n  let blobPromise;\n  files.set(name, fileEntry);\n  try {\n    let lockPreviousFileEntry;\n    if (keepOrder) {\n      lockPreviousFileEntry = previousFileEntry && previousFileEntry.lock;\n      requestLockCurrentFileEntry();\n    }\n    if ((options.bufferedWrite || zipWriter.writerLocked || zipWriter.bufferedWrites && keepOrder || !dataDescriptor) && !usdz) {\n      fileWriter = new TransformStream();\n      fileWriter.size = 0;\n      bufferedWrite = true;\n      zipWriter.bufferedWrites++;\n      await initStream(writer);\n    } else {\n      fileWriter = writer;\n      await requestLockWriter();\n    }\n    await initStream(fileWriter);\n    const {\n      writable,\n      diskOffset\n    } = writer;\n    if (zipWriter.addSplitZipSignature) {\n      delete zipWriter.addSplitZipSignature;\n      const signatureArray = new Uint8Array(4);\n      const signatureArrayView = getDataView(signatureArray);\n      setUint32(signatureArrayView, 0, SPLIT_ZIP_FILE_SIGNATURE);\n      await writeData(writer, signatureArray);\n      zipWriter.offset += 4;\n    }\n    if (usdz) {\n      appendExtraFieldUSDZ(entryInfo, zipWriter.offset - diskOffset);\n    }\n    const {\n      localHeaderView,\n      localHeaderArray\n    } = headerInfo;\n    if (!bufferedWrite) {\n      await lockPreviousFileEntry;\n      await skipDiskIfNeeded(writable);\n    }\n    const {\n      diskNumber\n    } = writer;\n    writingEntryData = true;\n    fileEntry.diskNumberStart = diskNumber;\n    if (bufferedWrite) {\n      blobPromise = new Response(fileWriter.readable).blob();\n    } else {\n      await writeData(fileWriter, localHeaderArray);\n    }\n    fileEntry = await createFileEntry(reader, fileWriter, fileEntry, entryInfo, zipWriter.config, options);\n    const {\n      zip64\n    } = fileEntry;\n    writingEntryData = false;\n    files.set(name, fileEntry);\n    fileEntry.filename = name;\n    if (bufferedWrite) {\n      const [blob] = await Promise.all([blobPromise, fileWriter.writable.getWriter().close(), lockPreviousFileEntry]);\n      await requestLockWriter();\n      writingBufferedEntryData = true;\n      fileEntry.diskNumberStart = writer.diskNumber;\n      fileEntry.offset = zipWriter.offset - writer.diskOffset;\n      if (zip64) {\n        updateZip64ExtraField(fileEntry);\n      }\n      updateLocalHeader(fileEntry, localHeaderView, options);\n      await skipDiskIfNeeded(writable);\n      await writeData(writer, localHeaderArray);\n      await blob.stream().pipeTo(writable, {\n        preventClose: true,\n        preventAbort: true,\n        signal\n      });\n      writer.size += fileWriter.size;\n      writingBufferedEntryData = false;\n    } else {\n      fileEntry.offset = zipWriter.offset - diskOffset;\n      if (zip64) {\n        updateZip64ExtraField(fileEntry);\n      }\n    }\n    if (fileEntry.offset > MAX_32_BITS && !zip64) {\n      throw new Error(ERR_UNSUPPORTED_FORMAT);\n    }\n    zipWriter.offset += fileEntry.size;\n    return fileEntry;\n  } catch (error) {\n    if (bufferedWrite && writingBufferedEntryData || !bufferedWrite && writingEntryData) {\n      zipWriter.hasCorruptedEntries = true;\n      if (error) {\n        try {\n          error.corruptedEntry = true;\n        } catch {\n          // ignored\n        }\n      }\n      if (bufferedWrite) {\n        zipWriter.offset += fileWriter.size;\n      } else {\n        zipWriter.offset = fileWriter.size;\n      }\n    }\n    files.delete(name);\n    throw error;\n  } finally {\n    if (bufferedWrite) {\n      zipWriter.bufferedWrites--;\n    }\n    if (releaseLockCurrentFileEntry) {\n      releaseLockCurrentFileEntry();\n    }\n    if (releaseLockWriter) {\n      releaseLockWriter();\n    }\n  }\n  function requestLockCurrentFileEntry() {\n    fileEntry.lock = new Promise(resolve => releaseLockCurrentFileEntry = resolve);\n  }\n  async function requestLockWriter() {\n    zipWriter.writerLocked = true;\n    const {\n      lockWriter\n    } = zipWriter;\n    zipWriter.lockWriter = new Promise(resolve => releaseLockWriter = () => {\n      zipWriter.writerLocked = false;\n      resolve();\n    });\n    await lockWriter;\n  }\n  async function skipDiskIfNeeded(writable) {\n    if (getLength(headerInfo.localHeaderArray) > writer.availableSize) {\n      writer.availableSize = 0;\n      await writeData(writable, new Uint8Array());\n    }\n  }\n}\nasync function createFileEntry(reader, writer, {\n  diskNumberStart,\n  lock\n}, entryInfo, config, options) {\n  const {\n    headerInfo,\n    dataDescriptorInfo,\n    metadataSize\n  } = entryInfo;\n  const {\n    headerArray,\n    headerView,\n    lastModDate,\n    rawLastModDate,\n    encrypted,\n    compressed,\n    version,\n    compressionMethod,\n    rawExtraFieldZip64,\n    localExtraFieldZip64Length,\n    rawExtraFieldExtendedTimestamp,\n    extraFieldExtendedTimestampFlag,\n    rawExtraFieldNTFS,\n    rawExtraFieldUnix,\n    rawExtraFieldAES\n  } = headerInfo;\n  const {\n    dataDescriptorArray\n  } = dataDescriptorInfo;\n  const {\n    rawFilename,\n    lastAccessDate,\n    creationDate,\n    password,\n    rawPassword,\n    level,\n    zip64,\n    zip64UncompressedSize,\n    zip64CompressedSize,\n    zip64Offset,\n    zip64DiskNumberStart,\n    zipCrypto,\n    dataDescriptor,\n    directory,\n    executable,\n    versionMadeBy,\n    rawComment,\n    rawExtraField,\n    useWebWorkers,\n    onstart,\n    onprogress,\n    onend,\n    signal,\n    encryptionStrength,\n    extendedTimestamp,\n    msDosCompatible,\n    internalFileAttributes,\n    externalFileAttributes,\n    uid,\n    gid,\n    unixMode,\n    setuid,\n    setgid,\n    sticky,\n    unixExternalUpper,\n    msdosAttributesRaw,\n    msdosAttributes,\n    useCompressionStream,\n    passThrough\n  } = options;\n  const fileEntry = {\n    lock,\n    versionMadeBy,\n    zip64,\n    directory: Boolean(directory),\n    executable: Boolean(executable),\n    filenameUTF8: true,\n    rawFilename,\n    commentUTF8: true,\n    rawComment,\n    rawExtraFieldZip64,\n    localExtraFieldZip64Length,\n    rawExtraFieldExtendedTimestamp,\n    rawExtraFieldNTFS,\n    rawExtraFieldUnix,\n    rawExtraFieldAES,\n    rawExtraField,\n    extendedTimestamp,\n    msDosCompatible,\n    internalFileAttributes,\n    externalFileAttributes,\n    diskNumberStart,\n    uid,\n    gid,\n    unixMode,\n    setuid,\n    setgid,\n    sticky,\n    unixExternalUpper,\n    msdosAttributesRaw,\n    msdosAttributes\n  };\n  let {\n    signature,\n    uncompressedSize\n  } = options;\n  let compressedSize = 0;\n  if (!passThrough) {\n    uncompressedSize = 0;\n  }\n  const {\n    writable\n  } = writer;\n  if (reader) {\n    reader.chunkSize = getChunkSize(config);\n    const readable = reader.readable;\n    const size = reader.size;\n    const workerOptions = {\n      options: {\n        codecType: CODEC_DEFLATE,\n        level,\n        rawPassword,\n        password,\n        encryptionStrength,\n        zipCrypto: encrypted && zipCrypto,\n        passwordVerification: encrypted && zipCrypto && rawLastModDate >> 8 & MAX_8_BITS,\n        signed: !passThrough,\n        compressed: compressed && !passThrough,\n        encrypted: encrypted && !passThrough,\n        useWebWorkers,\n        useCompressionStream,\n        transferStreams: false\n      },\n      config,\n      streamOptions: {\n        signal,\n        size,\n        onstart,\n        onprogress,\n        onend\n      }\n    };\n    try {\n      const result = await runWorker({\n        readable,\n        writable\n      }, workerOptions);\n      compressedSize = result.outputSize;\n      writer.size += compressedSize;\n      if (!passThrough) {\n        uncompressedSize = result.inputSize;\n        signature = result.signature;\n      }\n    } catch (error) {\n      if (error.outputSize !== UNDEFINED_VALUE) {\n        writer.size += error.outputSize;\n      }\n      throw error;\n    }\n  }\n  setEntryInfo({\n    signature,\n    compressedSize,\n    uncompressedSize,\n    headerInfo,\n    dataDescriptorInfo\n  }, options);\n  if (dataDescriptor) {\n    await writeData(writer, dataDescriptorArray);\n  }\n  Object.assign(fileEntry, {\n    uncompressedSize,\n    compressedSize,\n    lastModDate,\n    rawLastModDate,\n    creationDate,\n    lastAccessDate,\n    encrypted,\n    zipCrypto,\n    size: metadataSize + compressedSize,\n    compressionMethod,\n    version,\n    headerArray,\n    headerView,\n    signature,\n    extraFieldExtendedTimestampFlag,\n    zip64UncompressedSize,\n    zip64CompressedSize,\n    zip64Offset,\n    zip64DiskNumberStart\n  });\n  return fileEntry;\n}\nfunction getHeaderInfo(options) {\n  const {\n    rawFilename,\n    lastModDate,\n    lastAccessDate,\n    creationDate,\n    level,\n    zip64,\n    zipCrypto,\n    useUnicodeFileNames,\n    dataDescriptor,\n    directory,\n    rawExtraField,\n    encryptionStrength,\n    extendedTimestamp,\n    passThrough,\n    encrypted,\n    zip64UncompressedSize,\n    zip64CompressedSize,\n    zip64Offset,\n    zip64DiskNumberStart,\n    uncompressedSize,\n    offset,\n    diskNumberStart\n  } = options;\n  let {\n    version,\n    compressionMethod\n  } = options;\n  const compressed = !directory && (level > 0 || level === UNDEFINED_VALUE && compressionMethod !== 0);\n  let rawExtraFieldZip64;\n  const uncompressedFile = passThrough || !compressed;\n  const zip64ExtraFieldComplete = zip64 && (options.bufferedWrite || !zip64UncompressedSize && !zip64CompressedSize || uncompressedFile);\n  if (zip64) {\n    let rawExtraFieldZip64Length = 4;\n    if (zip64UncompressedSize) {\n      rawExtraFieldZip64Length += 8;\n    }\n    if (zip64CompressedSize) {\n      rawExtraFieldZip64Length += 8;\n    }\n    if (zip64Offset) {\n      rawExtraFieldZip64Length += 8;\n    }\n    if (zip64DiskNumberStart) {\n      rawExtraFieldZip64Length += 4;\n    }\n    rawExtraFieldZip64 = new Uint8Array(rawExtraFieldZip64Length);\n    const rawExtraFieldZip64View = getDataView(rawExtraFieldZip64);\n    setUint16(rawExtraFieldZip64View, 0, EXTRAFIELD_TYPE_ZIP64);\n    setUint16(rawExtraFieldZip64View, 2, getLength(rawExtraFieldZip64) - 4);\n    if (zip64ExtraFieldComplete) {\n      const rawExtraFieldZip64View = getDataView(rawExtraFieldZip64);\n      let rawExtraFieldZip64Offset = 4;\n      if (zip64UncompressedSize) {\n        setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(uncompressedSize));\n        rawExtraFieldZip64Offset += 8;\n      }\n      if (zip64CompressedSize && uncompressedFile) {\n        setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(uncompressedSize));\n        rawExtraFieldZip64Offset += 8;\n      }\n      if (zip64Offset) {\n        setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(offset));\n        rawExtraFieldZip64Offset += 8;\n      }\n      if (zip64DiskNumberStart) {\n        setUint32(rawExtraFieldZip64View, rawExtraFieldZip64Offset, diskNumberStart);\n        rawExtraFieldZip64Offset += 4;\n      }\n    }\n  } else {\n    rawExtraFieldZip64 = new Uint8Array();\n  }\n  let rawExtraFieldAES;\n  if (encrypted && !zipCrypto) {\n    rawExtraFieldAES = new Uint8Array(getLength(EXTRAFIELD_DATA_AES) + 2);\n    const extraFieldAESView = getDataView(rawExtraFieldAES);\n    setUint16(extraFieldAESView, 0, EXTRAFIELD_TYPE_AES);\n    arraySet(rawExtraFieldAES, EXTRAFIELD_DATA_AES, 2);\n    setUint8(extraFieldAESView, 8, encryptionStrength);\n  } else {\n    rawExtraFieldAES = new Uint8Array();\n  }\n  let rawExtraFieldNTFS;\n  let rawExtraFieldExtendedTimestamp;\n  let extraFieldExtendedTimestampFlag;\n  if (extendedTimestamp) {\n    rawExtraFieldExtendedTimestamp = new Uint8Array(9 + (lastAccessDate ? 4 : 0) + (creationDate ? 4 : 0));\n    const extraFieldExtendedTimestampView = getDataView(rawExtraFieldExtendedTimestamp);\n    setUint16(extraFieldExtendedTimestampView, 0, EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);\n    setUint16(extraFieldExtendedTimestampView, 2, getLength(rawExtraFieldExtendedTimestamp) - 4);\n    extraFieldExtendedTimestampFlag = 0x1 + (lastAccessDate ? 0x2 : 0) + (creationDate ? 0x4 : 0);\n    setUint8(extraFieldExtendedTimestampView, 4, extraFieldExtendedTimestampFlag);\n    let offset = 5;\n    setUint32(extraFieldExtendedTimestampView, offset, Math.floor(lastModDate.getTime() / 1000));\n    offset += 4;\n    if (lastAccessDate) {\n      setUint32(extraFieldExtendedTimestampView, offset, Math.floor(lastAccessDate.getTime() / 1000));\n      offset += 4;\n    }\n    if (creationDate) {\n      setUint32(extraFieldExtendedTimestampView, offset, Math.floor(creationDate.getTime() / 1000));\n    }\n    try {\n      rawExtraFieldNTFS = new Uint8Array(36);\n      const extraFieldNTFSView = getDataView(rawExtraFieldNTFS);\n      const lastModTimeNTFS = getTimeNTFS(lastModDate);\n      setUint16(extraFieldNTFSView, 0, EXTRAFIELD_TYPE_NTFS);\n      setUint16(extraFieldNTFSView, 2, 32);\n      setUint16(extraFieldNTFSView, 8, EXTRAFIELD_TYPE_NTFS_TAG1);\n      setUint16(extraFieldNTFSView, 10, 24);\n      setBigUint64(extraFieldNTFSView, 12, lastModTimeNTFS);\n      setBigUint64(extraFieldNTFSView, 20, getTimeNTFS(lastAccessDate) || lastModTimeNTFS);\n      setBigUint64(extraFieldNTFSView, 28, getTimeNTFS(creationDate) || lastModTimeNTFS);\n    } catch {\n      rawExtraFieldNTFS = new Uint8Array();\n    }\n  } else {\n    rawExtraFieldNTFS = rawExtraFieldExtendedTimestamp = new Uint8Array();\n  }\n  let rawExtraFieldUnix;\n  try {\n    const {\n      uid,\n      gid,\n      unixMode,\n      setuid,\n      setgid,\n      sticky,\n      unixExtraFieldType\n    } = options;\n    if (unixExtraFieldType && (uid !== UNDEFINED_VALUE || gid !== UNDEFINED_VALUE || unixMode !== UNDEFINED_VALUE)) {\n      const uidBytes = packUnixId(uid);\n      const gidBytes = packUnixId(gid);\n      let modeArray = new Uint8Array();\n      if (unixExtraFieldType == UNIX_EXTRA_FIELD_TYPE && unixMode !== UNDEFINED_VALUE) {\n        let modeToWrite = unixMode & MAX_16_BITS;\n        if (setuid) {\n          modeToWrite |= FILE_ATTR_UNIX_SETUID_MASK;\n        }\n        if (setgid) {\n          modeToWrite |= FILE_ATTR_UNIX_SETGID_MASK;\n        }\n        if (sticky) {\n          modeToWrite |= FILE_ATTR_UNIX_STICKY_MASK;\n        }\n        modeArray = new Uint8Array(2);\n        const modeDataView = new DataView(modeArray.buffer);\n        modeDataView.setUint16(0, modeToWrite, true);\n      }\n      const payloadLength = 3 + uidBytes.length + gidBytes.length + modeArray.length;\n      rawExtraFieldUnix = new Uint8Array(4 + payloadLength);\n      const rawExtraFieldUnixView = getDataView(rawExtraFieldUnix);\n      setUint16(rawExtraFieldUnixView, 0, unixExtraFieldType == INFOZIP_EXTRA_FIELD_TYPE ? EXTRAFIELD_TYPE_INFOZIP : EXTRAFIELD_TYPE_UNIX);\n      setUint16(rawExtraFieldUnixView, 2, payloadLength);\n      setUint8(rawExtraFieldUnixView, 4, 1);\n      setUint8(rawExtraFieldUnixView, 5, uidBytes.length);\n      let offset = 6;\n      arraySet(rawExtraFieldUnix, uidBytes, offset);\n      offset += uidBytes.length;\n      setUint8(rawExtraFieldUnixView, offset, gidBytes.length);\n      offset++;\n      arraySet(rawExtraFieldUnix, gidBytes, offset);\n      offset += gidBytes.length;\n      arraySet(rawExtraFieldUnix, modeArray, offset);\n    } else {\n      rawExtraFieldUnix = new Uint8Array();\n    }\n  } catch {\n    rawExtraFieldUnix = new Uint8Array();\n  }\n  if (compressionMethod === UNDEFINED_VALUE) {\n    compressionMethod = compressed ? COMPRESSION_METHOD_DEFLATE : COMPRESSION_METHOD_STORE;\n  }\n  if (zip64) {\n    version = version > VERSION_ZIP64 ? version : VERSION_ZIP64;\n  }\n  if (encrypted && !zipCrypto) {\n    version = version > VERSION_AES ? version : VERSION_AES;\n    rawExtraFieldAES[9] = compressionMethod;\n    compressionMethod = COMPRESSION_METHOD_AES;\n  }\n  const localExtraFieldZip64Length = zip64ExtraFieldComplete ? getLength(rawExtraFieldZip64) : 0;\n  const extraFieldLength = localExtraFieldZip64Length + getLength(rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS, rawExtraFieldUnix, rawExtraField);\n  const {\n    headerArray,\n    headerView,\n    rawLastModDate\n  } = getHeaderArrayData({\n    version,\n    bitFlag: getBitFlag(level, useUnicodeFileNames, dataDescriptor, encrypted, compressionMethod),\n    compressionMethod,\n    uncompressedSize,\n    lastModDate: lastModDate < MIN_DATE ? MIN_DATE : lastModDate > MAX_DATE ? MAX_DATE : lastModDate,\n    rawFilename,\n    zip64CompressedSize,\n    zip64UncompressedSize,\n    extraFieldLength\n  });\n  let localHeaderOffset = HEADER_SIZE;\n  const localHeaderArray = new Uint8Array(localHeaderOffset + getLength(rawFilename) + extraFieldLength);\n  const localHeaderView = getDataView(localHeaderArray);\n  setUint32(localHeaderView, 0, LOCAL_FILE_HEADER_SIGNATURE);\n  arraySet(localHeaderArray, headerArray, 4);\n  arraySet(localHeaderArray, rawFilename, localHeaderOffset);\n  localHeaderOffset += getLength(rawFilename);\n  if (zip64ExtraFieldComplete) {\n    arraySet(localHeaderArray, rawExtraFieldZip64, localHeaderOffset);\n  }\n  localHeaderOffset += localExtraFieldZip64Length;\n  arraySet(localHeaderArray, rawExtraFieldAES, localHeaderOffset);\n  localHeaderOffset += getLength(rawExtraFieldAES);\n  arraySet(localHeaderArray, rawExtraFieldExtendedTimestamp, localHeaderOffset);\n  localHeaderOffset += getLength(rawExtraFieldExtendedTimestamp);\n  arraySet(localHeaderArray, rawExtraFieldNTFS, localHeaderOffset);\n  localHeaderOffset += getLength(rawExtraFieldNTFS);\n  arraySet(localHeaderArray, rawExtraFieldUnix, localHeaderOffset);\n  localHeaderOffset += getLength(rawExtraFieldUnix);\n  arraySet(localHeaderArray, rawExtraField, localHeaderOffset);\n  if (dataDescriptor) {\n    setUint32(localHeaderView, HEADER_OFFSET_COMPRESSED_SIZE + 4, 0);\n    setUint32(localHeaderView, HEADER_OFFSET_UNCOMPRESSED_SIZE + 4, 0);\n  }\n  return {\n    localHeaderArray,\n    localHeaderView,\n    headerArray,\n    headerView,\n    lastModDate,\n    rawLastModDate,\n    encrypted,\n    compressed,\n    version,\n    compressionMethod,\n    extraFieldExtendedTimestampFlag,\n    rawExtraFieldZip64,\n    localExtraFieldZip64Length,\n    rawExtraFieldExtendedTimestamp,\n    rawExtraFieldNTFS,\n    rawExtraFieldUnix,\n    rawExtraFieldAES,\n    extraFieldLength\n  };\n}\nfunction appendExtraFieldUSDZ(entryInfo, zipWriterOffset) {\n  const {\n    headerInfo\n  } = entryInfo;\n  let {\n    localHeaderArray,\n    extraFieldLength\n  } = headerInfo;\n  let localHeaderArrayView = getDataView(localHeaderArray);\n  let extraBytesLength = 64 - (zipWriterOffset + getLength(localHeaderArray)) % 64;\n  if (extraBytesLength < 4) {\n    extraBytesLength += 64;\n  }\n  const rawExtraFieldUSDZ = new Uint8Array(extraBytesLength);\n  const extraFieldUSDZView = getDataView(rawExtraFieldUSDZ);\n  setUint16(extraFieldUSDZView, 0, EXTRAFIELD_TYPE_USDZ);\n  setUint16(extraFieldUSDZView, 2, extraBytesLength - 2);\n  const previousLocalHeaderArray = localHeaderArray;\n  headerInfo.localHeaderArray = localHeaderArray = new Uint8Array(getLength(previousLocalHeaderArray) + extraBytesLength);\n  arraySet(localHeaderArray, previousLocalHeaderArray);\n  arraySet(localHeaderArray, rawExtraFieldUSDZ, getLength(previousLocalHeaderArray));\n  localHeaderArrayView = getDataView(localHeaderArray);\n  setUint16(localHeaderArrayView, 28, extraFieldLength + extraBytesLength);\n  entryInfo.metadataSize += extraBytesLength;\n}\nfunction packUnixId(id) {\n  if (id === UNDEFINED_VALUE) {\n    return new Uint8Array();\n  } else {\n    const dataArray = new Uint8Array(4);\n    const dataView = getDataView(dataArray);\n    dataView.setUint32(0, id, true);\n    let length = 4;\n    while (length > 1 && dataArray[length - 1] === 0) {\n      length--;\n    }\n    return dataArray.subarray(0, length);\n  }\n}\nfunction normalizeMsdosAttributes(msdosAttributesRaw, msdosAttributes) {\n  if (msdosAttributesRaw !== UNDEFINED_VALUE) {\n    msdosAttributesRaw = msdosAttributesRaw & MAX_8_BITS;\n  } else if (msdosAttributes !== UNDEFINED_VALUE) {\n    const {\n      readOnly,\n      hidden,\n      system,\n      directory: msdDir,\n      archive\n    } = msdosAttributes;\n    let raw = 0;\n    if (readOnly) raw |= FILE_ATTR_MSDOS_READONLY_MASK;\n    if (hidden) raw |= FILE_ATTR_MSDOS_HIDDEN_MASK;\n    if (system) raw |= FILE_ATTR_MSDOS_SYSTEM_MASK;\n    if (msdDir) raw |= FILE_ATTR_MSDOS_DIR_MASK;\n    if (archive) raw |= FILE_ATTR_MSDOS_ARCHIVE_MASK;\n    msdosAttributesRaw = raw & MAX_8_BITS;\n  }\n  if (msdosAttributes === UNDEFINED_VALUE) {\n    msdosAttributes = {\n      readOnly: Boolean(msdosAttributesRaw & FILE_ATTR_MSDOS_READONLY_MASK),\n      hidden: Boolean(msdosAttributesRaw & FILE_ATTR_MSDOS_HIDDEN_MASK),\n      system: Boolean(msdosAttributesRaw & FILE_ATTR_MSDOS_SYSTEM_MASK),\n      directory: Boolean(msdosAttributesRaw & FILE_ATTR_MSDOS_DIR_MASK),\n      archive: Boolean(msdosAttributesRaw & FILE_ATTR_MSDOS_ARCHIVE_MASK)\n    };\n  }\n  return {\n    msdosAttributesRaw,\n    msdosAttributes\n  };\n}\nfunction getDataDescriptorInfo({\n  zip64,\n  dataDescriptor,\n  dataDescriptorSignature\n}) {\n  let dataDescriptorArray = new Uint8Array();\n  let dataDescriptorView,\n    dataDescriptorOffset = 0;\n  let dataDescriptorLength = zip64 ? DATA_DESCRIPTOR_RECORD_ZIP_64_LENGTH : DATA_DESCRIPTOR_RECORD_LENGTH;\n  if (dataDescriptorSignature) {\n    dataDescriptorLength += DATA_DESCRIPTOR_RECORD_SIGNATURE_LENGTH;\n  }\n  if (dataDescriptor) {\n    dataDescriptorArray = new Uint8Array(dataDescriptorLength);\n    dataDescriptorView = getDataView(dataDescriptorArray);\n    if (dataDescriptorSignature) {\n      dataDescriptorOffset = DATA_DESCRIPTOR_RECORD_SIGNATURE_LENGTH;\n      setUint32(dataDescriptorView, 0, DATA_DESCRIPTOR_RECORD_SIGNATURE);\n    }\n  }\n  return {\n    dataDescriptorArray,\n    dataDescriptorView,\n    dataDescriptorOffset\n  };\n}\nfunction setEntryInfo({\n  signature,\n  compressedSize,\n  uncompressedSize,\n  headerInfo,\n  dataDescriptorInfo\n}, {\n  zip64,\n  zipCrypto,\n  dataDescriptor\n}) {\n  const {\n    headerView,\n    encrypted\n  } = headerInfo;\n  const {\n    dataDescriptorView,\n    dataDescriptorOffset\n  } = dataDescriptorInfo;\n  if ((!encrypted || zipCrypto) && signature !== UNDEFINED_VALUE) {\n    setUint32(headerView, HEADER_OFFSET_SIGNATURE, signature);\n    if (dataDescriptor) {\n      setUint32(dataDescriptorView, dataDescriptorOffset, signature);\n    }\n  }\n  if (zip64) {\n    if (dataDescriptor) {\n      setBigUint64(dataDescriptorView, dataDescriptorOffset + 4, BigInt(compressedSize));\n      setBigUint64(dataDescriptorView, dataDescriptorOffset + 12, BigInt(uncompressedSize));\n    }\n  } else {\n    setUint32(headerView, HEADER_OFFSET_COMPRESSED_SIZE, compressedSize);\n    setUint32(headerView, HEADER_OFFSET_UNCOMPRESSED_SIZE, uncompressedSize);\n    if (dataDescriptor) {\n      setUint32(dataDescriptorView, dataDescriptorOffset + 4, compressedSize);\n      setUint32(dataDescriptorView, dataDescriptorOffset + 8, uncompressedSize);\n    }\n  }\n}\nfunction updateLocalHeader({\n  rawFilename,\n  encrypted,\n  zip64,\n  localExtraFieldZip64Length,\n  signature,\n  compressedSize,\n  uncompressedSize,\n  offset,\n  diskNumberStart,\n  zip64UncompressedSize,\n  zip64CompressedSize,\n  zip64Offset,\n  zip64DiskNumberStart\n}, localHeaderView, {\n  dataDescriptor\n}) {\n  if (!dataDescriptor) {\n    if (!encrypted) {\n      setUint32(localHeaderView, HEADER_OFFSET_SIGNATURE + 4, signature);\n    }\n    if (!zip64) {\n      setUint32(localHeaderView, HEADER_OFFSET_COMPRESSED_SIZE + 4, compressedSize);\n      setUint32(localHeaderView, HEADER_OFFSET_UNCOMPRESSED_SIZE + 4, uncompressedSize);\n    }\n  }\n  if (zip64) {\n    if (localExtraFieldZip64Length) {\n      let localHeaderOffset = HEADER_SIZE + getLength(rawFilename) + 4;\n      if (zip64UncompressedSize) {\n        setBigUint64(localHeaderView, localHeaderOffset, BigInt(uncompressedSize));\n        localHeaderOffset += 8;\n      }\n      if (zip64CompressedSize) {\n        setBigUint64(localHeaderView, localHeaderOffset, BigInt(compressedSize));\n        localHeaderOffset += 8;\n      }\n      if (zip64Offset) {\n        setBigUint64(localHeaderView, localHeaderOffset, BigInt(offset));\n        localHeaderOffset += 8;\n      }\n      if (zip64DiskNumberStart) {\n        setUint32(localHeaderView, localHeaderOffset, diskNumberStart);\n      }\n    }\n  }\n}\nfunction updateZip64ExtraField({\n  compressedSize,\n  uncompressedSize,\n  offset,\n  diskNumberStart,\n  zip64UncompressedSize,\n  zip64CompressedSize,\n  zip64Offset,\n  zip64DiskNumberStart,\n  rawExtraFieldZip64\n}) {\n  const rawExtraFieldZip64View = getDataView(rawExtraFieldZip64);\n  let rawExtraFieldZip64Offset = 4;\n  if (zip64UncompressedSize) {\n    setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(uncompressedSize));\n    rawExtraFieldZip64Offset += 8;\n  }\n  if (zip64CompressedSize) {\n    setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(compressedSize));\n    rawExtraFieldZip64Offset += 8;\n  }\n  if (zip64Offset) {\n    setBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(offset));\n    rawExtraFieldZip64Offset += 8;\n  }\n  if (zip64DiskNumberStart) {\n    setUint32(rawExtraFieldZip64View, rawExtraFieldZip64Offset, diskNumberStart);\n  }\n}\nasync function closeFile(zipWriter, comment, options) {\n  const {\n    files,\n    writer\n  } = zipWriter;\n  const {\n    diskOffset\n  } = writer;\n  let {\n    diskNumber\n  } = writer;\n  let offset = 0;\n  let directoryDataLength = 0;\n  let directoryOffset = zipWriter.offset - diskOffset;\n  let filesLength = files.size;\n  for (const [, fileEntry] of files) {\n    const {\n      rawFilename,\n      rawExtraFieldZip64,\n      rawExtraFieldAES,\n      rawComment,\n      rawExtraFieldNTFS,\n      rawExtraFieldUnix,\n      rawExtraField,\n      extendedTimestamp,\n      extraFieldExtendedTimestampFlag,\n      lastModDate\n    } = fileEntry;\n    let rawExtraFieldTimestamp;\n    if (extendedTimestamp) {\n      rawExtraFieldTimestamp = new Uint8Array(9);\n      const extraFieldExtendedTimestampView = getDataView(rawExtraFieldTimestamp);\n      setUint16(extraFieldExtendedTimestampView, 0, EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);\n      setUint16(extraFieldExtendedTimestampView, 2, 5);\n      setUint8(extraFieldExtendedTimestampView, 4, extraFieldExtendedTimestampFlag);\n      setUint32(extraFieldExtendedTimestampView, 5, Math.floor(lastModDate.getTime() / 1000));\n    } else {\n      rawExtraFieldTimestamp = new Uint8Array();\n    }\n    fileEntry.rawExtraFieldExtendedTimestamp = rawExtraFieldTimestamp;\n    directoryDataLength += 46 + getLength(rawFilename, rawComment, rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldNTFS, rawExtraFieldUnix, rawExtraFieldTimestamp, rawExtraField);\n  }\n  const directoryArray = new Uint8Array(directoryDataLength);\n  const directoryView = getDataView(directoryArray);\n  await initStream(writer);\n  let directoryDiskOffset = 0;\n  for (const [indexFileEntry, fileEntry] of Array.from(files.values()).entries()) {\n    const {\n      offset: fileEntryOffset,\n      rawFilename,\n      rawExtraFieldZip64,\n      rawExtraFieldAES,\n      rawExtraFieldExtendedTimestamp,\n      rawExtraFieldNTFS,\n      rawExtraFieldUnix,\n      rawExtraField,\n      rawComment,\n      versionMadeBy,\n      headerArray,\n      headerView,\n      zip64,\n      zip64UncompressedSize,\n      zip64CompressedSize,\n      zip64DiskNumberStart,\n      zip64Offset,\n      internalFileAttributes,\n      externalFileAttributes,\n      diskNumberStart,\n      uncompressedSize,\n      compressedSize\n    } = fileEntry;\n    const extraFieldLength = getLength(rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS, rawExtraFieldUnix, rawExtraField);\n    setUint32(directoryView, offset, CENTRAL_FILE_HEADER_SIGNATURE);\n    setUint16(directoryView, offset + 4, versionMadeBy);\n    if (!zip64UncompressedSize) {\n      setUint32(headerView, HEADER_OFFSET_UNCOMPRESSED_SIZE, uncompressedSize);\n    }\n    if (!zip64CompressedSize) {\n      setUint32(headerView, HEADER_OFFSET_COMPRESSED_SIZE, compressedSize);\n    }\n    arraySet(directoryArray, headerArray, offset + 6);\n    let directoryOffset = offset + HEADER_SIZE;\n    setUint16(directoryView, directoryOffset, extraFieldLength);\n    directoryOffset += 2;\n    setUint16(directoryView, directoryOffset, getLength(rawComment));\n    directoryOffset += 2;\n    setUint16(directoryView, directoryOffset, zip64 && zip64DiskNumberStart ? MAX_16_BITS : diskNumberStart);\n    directoryOffset += 2;\n    setUint16(directoryView, directoryOffset, internalFileAttributes);\n    directoryOffset += 2;\n    if (externalFileAttributes) {\n      setUint32(directoryView, directoryOffset, externalFileAttributes);\n    }\n    directoryOffset += 4;\n    setUint32(directoryView, directoryOffset, zip64 && zip64Offset ? MAX_32_BITS : fileEntryOffset);\n    directoryOffset += 4;\n    arraySet(directoryArray, rawFilename, directoryOffset);\n    directoryOffset += getLength(rawFilename);\n    arraySet(directoryArray, rawExtraFieldZip64, directoryOffset);\n    directoryOffset += getLength(rawExtraFieldZip64);\n    arraySet(directoryArray, rawExtraFieldAES, directoryOffset);\n    directoryOffset += getLength(rawExtraFieldAES);\n    arraySet(directoryArray, rawExtraFieldExtendedTimestamp, directoryOffset);\n    directoryOffset += getLength(rawExtraFieldExtendedTimestamp);\n    arraySet(directoryArray, rawExtraFieldNTFS, directoryOffset);\n    directoryOffset += getLength(rawExtraFieldNTFS);\n    arraySet(directoryArray, rawExtraFieldUnix, directoryOffset);\n    directoryOffset += getLength(rawExtraFieldUnix);\n    arraySet(directoryArray, rawExtraField, directoryOffset);\n    directoryOffset += getLength(rawExtraField);\n    arraySet(directoryArray, rawComment, directoryOffset);\n    directoryOffset += getLength(rawComment);\n    if (offset - directoryDiskOffset > writer.availableSize) {\n      writer.availableSize = 0;\n      await writeData(writer, directoryArray.slice(directoryDiskOffset, offset));\n      directoryDiskOffset = offset;\n    }\n    offset = directoryOffset;\n    if (options.onprogress) {\n      try {\n        await options.onprogress(indexFileEntry + 1, files.size, new Entry(fileEntry));\n      } catch {\n        // ignored\n      }\n    }\n  }\n  await writeData(writer, directoryDiskOffset ? directoryArray.slice(directoryDiskOffset) : directoryArray);\n  let lastDiskNumber = writer.diskNumber;\n  const {\n    availableSize\n  } = writer;\n  if (availableSize < END_OF_CENTRAL_DIR_LENGTH) {\n    lastDiskNumber++;\n  }\n  let zip64 = getOptionValue(zipWriter, options, PROPERTY_NAME_ZIP64);\n  if (directoryOffset > MAX_32_BITS || directoryDataLength > MAX_32_BITS || filesLength > MAX_16_BITS || lastDiskNumber > MAX_16_BITS) {\n    if (zip64 === false) {\n      throw new Error(ERR_UNSUPPORTED_FORMAT);\n    } else {\n      zip64 = true;\n    }\n  }\n  const endOfdirectoryArray = new Uint8Array(zip64 ? ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH : END_OF_CENTRAL_DIR_LENGTH);\n  const endOfdirectoryView = getDataView(endOfdirectoryArray);\n  offset = 0;\n  if (zip64) {\n    setUint32(endOfdirectoryView, 0, ZIP64_END_OF_CENTRAL_DIR_SIGNATURE);\n    setBigUint64(endOfdirectoryView, 4, BigInt(44));\n    setUint16(endOfdirectoryView, 12, 45);\n    setUint16(endOfdirectoryView, 14, 45);\n    setUint32(endOfdirectoryView, 16, lastDiskNumber);\n    setUint32(endOfdirectoryView, 20, diskNumber);\n    setBigUint64(endOfdirectoryView, 24, BigInt(filesLength));\n    setBigUint64(endOfdirectoryView, 32, BigInt(filesLength));\n    setBigUint64(endOfdirectoryView, 40, BigInt(directoryDataLength));\n    setBigUint64(endOfdirectoryView, 48, BigInt(directoryOffset));\n    setUint32(endOfdirectoryView, 56, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE);\n    setBigUint64(endOfdirectoryView, 64, BigInt(directoryOffset) + BigInt(directoryDataLength));\n    setUint32(endOfdirectoryView, 72, lastDiskNumber + 1);\n    const supportZip64SplitFile = getOptionValue(zipWriter, options, OPTION_SUPPORT_ZIP64_SPLIT_FILE, true);\n    if (supportZip64SplitFile) {\n      lastDiskNumber = MAX_16_BITS;\n      diskNumber = MAX_16_BITS;\n    }\n    filesLength = MAX_16_BITS;\n    directoryOffset = MAX_32_BITS;\n    directoryDataLength = MAX_32_BITS;\n    offset += ZIP64_END_OF_CENTRAL_DIR_LENGTH + ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH;\n  }\n  setUint32(endOfdirectoryView, offset, END_OF_CENTRAL_DIR_SIGNATURE);\n  setUint16(endOfdirectoryView, offset + 4, lastDiskNumber);\n  setUint16(endOfdirectoryView, offset + 6, diskNumber);\n  setUint16(endOfdirectoryView, offset + 8, filesLength);\n  setUint16(endOfdirectoryView, offset + 10, filesLength);\n  setUint32(endOfdirectoryView, offset + 12, directoryDataLength);\n  setUint32(endOfdirectoryView, offset + 16, directoryOffset);\n  const commentLength = getLength(comment);\n  if (commentLength) {\n    if (commentLength <= MAX_16_BITS) {\n      setUint16(endOfdirectoryView, offset + 20, commentLength);\n    } else {\n      throw new Error(ERR_INVALID_COMMENT);\n    }\n  }\n  await writeData(writer, endOfdirectoryArray);\n  if (commentLength) {\n    await writeData(writer, comment);\n  }\n}\nasync function writeData(writer, array) {\n  const {\n    writable\n  } = writer;\n  const streamWriter = writable.getWriter();\n  try {\n    await streamWriter.ready;\n    writer.size += getLength(array);\n    await streamWriter.write(array);\n  } finally {\n    streamWriter.releaseLock();\n  }\n}\nfunction getTimeNTFS(date) {\n  if (date) {\n    return (BigInt(date.getTime()) + BigInt(11644473600000)) * BigInt(10000);\n  }\n}\nfunction getOptionValue(zipWriter, options, name, defaultValue) {\n  const result = options[name] === UNDEFINED_VALUE ? zipWriter.options[name] : options[name];\n  return result === UNDEFINED_VALUE ? defaultValue : result;\n}\nfunction getMaximumCompressedSize(uncompressedSize) {\n  return uncompressedSize + 5 * (Math.floor(uncompressedSize / 16383) + 1);\n}\nfunction setUint8(view, offset, value) {\n  view.setUint8(offset, value);\n}\nfunction setUint16(view, offset, value) {\n  view.setUint16(offset, value, true);\n}\nfunction setUint32(view, offset, value) {\n  view.setUint32(offset, value, true);\n}\nfunction setBigUint64(view, offset, value) {\n  view.setBigUint64(offset, value, true);\n}\nfunction arraySet(array, typedArray, offset) {\n  array.set(typedArray, offset);\n}\nfunction getDataView(array) {\n  return new DataView(array.buffer);\n}\nfunction getLength(...arrayLikes) {\n  let result = 0;\n  arrayLikes.forEach(arrayLike => arrayLike && (result += arrayLike.length));\n  return result;\n}\nfunction getHeaderArrayData({\n  version,\n  bitFlag,\n  compressionMethod,\n  uncompressedSize,\n  compressedSize,\n  lastModDate,\n  rawFilename,\n  zip64CompressedSize,\n  zip64UncompressedSize,\n  extraFieldLength\n}) {\n  const headerArray = new Uint8Array(HEADER_SIZE - 4);\n  const headerView = getDataView(headerArray);\n  setUint16(headerView, 0, version);\n  setUint16(headerView, 2, bitFlag);\n  setUint16(headerView, 4, compressionMethod);\n  const dateArray = new Uint32Array(1);\n  const dateView = getDataView(dateArray);\n  setUint16(dateView, 0, (lastModDate.getHours() << 6 | lastModDate.getMinutes()) << 5 | lastModDate.getSeconds() / 2);\n  setUint16(dateView, 2, (lastModDate.getFullYear() - 1980 << 4 | lastModDate.getMonth() + 1) << 5 | lastModDate.getDate());\n  const rawLastModDate = dateArray[0];\n  setUint32(headerView, 6, rawLastModDate);\n  if (zip64CompressedSize || compressedSize !== UNDEFINED_VALUE) {\n    setUint32(headerView, HEADER_OFFSET_COMPRESSED_SIZE, zip64CompressedSize ? MAX_32_BITS : compressedSize);\n  }\n  if (zip64UncompressedSize || uncompressedSize !== UNDEFINED_VALUE) {\n    setUint32(headerView, HEADER_OFFSET_UNCOMPRESSED_SIZE, zip64UncompressedSize ? MAX_32_BITS : uncompressedSize);\n  }\n  setUint16(headerView, 22, getLength(rawFilename));\n  setUint16(headerView, 24, extraFieldLength);\n  return {\n    headerArray,\n    headerView,\n    rawLastModDate\n  };\n}\nfunction getBitFlag(level, useUnicodeFileNames, dataDescriptor, encrypted, compressionMethod) {\n  let bitFlag = 0;\n  if (useUnicodeFileNames) {\n    bitFlag = bitFlag | BITFLAG_LANG_ENCODING_FLAG;\n  }\n  if (dataDescriptor) {\n    bitFlag = bitFlag | BITFLAG_DATA_DESCRIPTOR;\n  }\n  if (compressionMethod == COMPRESSION_METHOD_DEFLATE || compressionMethod == COMPRESSION_METHOD_DEFLATE_64) {\n    if (level >= 0 && level <= 3) {\n      bitFlag = bitFlag | BITFLAG_LEVEL_SUPER_FAST_MASK;\n    }\n    if (level > 3 && level <= 5) {\n      bitFlag = bitFlag | BITFLAG_LEVEL_FAST_MASK;\n    }\n    if (level == 9) {\n      bitFlag = bitFlag | BITFLAG_LEVEL_MAX_MASK;\n    }\n  }\n  if (encrypted) {\n    bitFlag = bitFlag | BITFLAG_ENCRYPTED;\n  }\n  return bitFlag;\n}","map":{"version":3,"names":["MAX_32_BITS","MAX_16_BITS","MAX_8_BITS","COMPRESSION_METHOD_DEFLATE","COMPRESSION_METHOD_DEFLATE_64","COMPRESSION_METHOD_STORE","COMPRESSION_METHOD_AES","SPLIT_ZIP_FILE_SIGNATURE","LOCAL_FILE_HEADER_SIGNATURE","DATA_DESCRIPTOR_RECORD_SIGNATURE","CENTRAL_FILE_HEADER_SIGNATURE","END_OF_CENTRAL_DIR_SIGNATURE","ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE","ZIP64_END_OF_CENTRAL_DIR_SIGNATURE","DATA_DESCRIPTOR_RECORD_LENGTH","DATA_DESCRIPTOR_RECORD_ZIP_64_LENGTH","DATA_DESCRIPTOR_RECORD_SIGNATURE_LENGTH","EXTRAFIELD_TYPE_AES","EXTRAFIELD_TYPE_ZIP64","EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP","EXTRAFIELD_TYPE_NTFS","EXTRAFIELD_TYPE_NTFS_TAG1","EXTRAFIELD_TYPE_USDZ","EXTRAFIELD_TYPE_INFOZIP","EXTRAFIELD_TYPE_UNIX","END_OF_CENTRAL_DIR_LENGTH","ZIP64_END_OF_CENTRAL_DIR_LENGTH","ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH","ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH","BITFLAG_ENCRYPTED","BITFLAG_DATA_DESCRIPTOR","BITFLAG_LANG_ENCODING_FLAG","BITFLAG_LEVEL_FAST_MASK","BITFLAG_LEVEL_SUPER_FAST_MASK","BITFLAG_LEVEL_MAX_MASK","FILE_ATTR_MSDOS_DIR_MASK","FILE_ATTR_MSDOS_READONLY_MASK","FILE_ATTR_MSDOS_HIDDEN_MASK","FILE_ATTR_MSDOS_SYSTEM_MASK","FILE_ATTR_MSDOS_ARCHIVE_MASK","FILE_ATTR_UNIX_TYPE_DIR","FILE_ATTR_UNIX_EXECUTABLE_MASK","FILE_ATTR_UNIX_DEFAULT_MASK","FILE_ATTR_UNIX_SETUID_MASK","FILE_ATTR_UNIX_SETGID_MASK","FILE_ATTR_UNIX_STICKY_MASK","VERSION_DEFLATE","VERSION_ZIP64","VERSION_AES","DIRECTORY_SIGNATURE","HEADER_SIZE","HEADER_OFFSET_SIGNATURE","HEADER_OFFSET_COMPRESSED_SIZE","HEADER_OFFSET_UNCOMPRESSED_SIZE","MIN_DATE","MAX_DATE","UNDEFINED_VALUE","OBJECT_TYPE","getConfiguration","getChunkSize","CODEC_DEFLATE","runWorker","initStream","GenericWriter","GenericReader","encodeText","PROPERTY_NAME_LAST_MODIFICATION_DATE","PROPERTY_NAME_LAST_ACCESS_DATE","PROPERTY_NAME_CREATION_DATE","PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTES","PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTES","PROPERTY_NAME_MS_DOS_COMPATIBLE","PROPERTY_NAME_ZIP64","PROPERTY_NAME_ENCRYPTED","PROPERTY_NAME_VERSION","PROPERTY_NAME_VERSION_MADE_BY","PROPERTY_NAME_ZIPCRYPTO","PROPERTY_NAME_DIRECTORY","PROPERTY_NAME_EXECUTABLE","PROPERTY_NAME_COMPRESSION_METHOD","PROPERTY_NAME_SIGNATURE","PROPERTY_NAME_COMMENT","PROPERTY_NAME_UNCOMPRESSED_SIZE","PROPERTY_NAME_EXTRA_FIELD","PROPERTY_NAME_UID","PROPERTY_NAME_GID","PROPERTY_NAME_UNIX_MODE","PROPERTY_NAME_SETUID","PROPERTY_NAME_SETGID","PROPERTY_NAME_STICKY","PROPERTY_NAME_MSDOS_ATTRIBUTES","PROPERTY_NAME_MSDOS_ATTRIBUTES_RAW","Entry","OPTION_PASSWORD","OPTION_RAW_PASSWORD","OPTION_PASS_THROUGH","OPTION_SIGNAL","OPTION_USE_WEB_WORKERS","OPTION_USE_COMPRESSION_STREAM","OPTION_PREVENT_CLOSE","OPTION_ENCRYPTION_STRENGTH","OPTION_EXTENDED_TIMESTAMP","OPTION_KEEP_ORDER","OPTION_LEVEL","OPTION_BUFFERED_WRITE","OPTION_DATA_DESCRIPTOR_SIGNATURE","OPTION_USE_UNICODE_FILE_NAMES","OPTION_DATA_DESCRIPTOR","OPTION_SUPPORT_ZIP64_SPLIT_FILE","OPTION_ENCODE_TEXT","OPTION_OFFSET","OPTION_USDZ","OPTION_UNIX_EXTRA_FIELD_TYPE","ZipReader","ERR_DUPLICATED_NAME","ERR_INVALID_COMMENT","ERR_INVALID_ENTRY_COMMENT","ERR_INVALID_ENTRY_NAME","ERR_INVALID_VERSION","ERR_INVALID_ENCRYPTION_STRENGTH","ERR_INVALID_EXTRAFIELD_TYPE","ERR_INVALID_EXTRAFIELD_DATA","ERR_UNSUPPORTED_FORMAT","ERR_UNDEFINED_UNCOMPRESSED_SIZE","ERR_ZIP_NOT_EMPTY","ERR_INVALID_UID","ERR_INVALID_GID","ERR_INVALID_UNIX_MODE","ERR_INVALID_UNIX_EXTRA_FIELD_TYPE","ERR_INVALID_MSDOS_ATTRIBUTES","ERR_INVALID_MSDOS_DATA","EXTRAFIELD_DATA_AES","Uint8Array","INFOZIP_EXTRA_FIELD_TYPE","UNIX_EXTRA_FIELD_TYPE","workers","pendingEntries","ZipWriter","constructor","writer","options","addSplitZipSignature","availableSize","Infinity","maxSize","Object","assign","config","files","Map","filenames","Set","offset","size","writable","pendingEntriesSize","pendingAddFileCalls","bufferedWrites","prependZip","reader","Error","zipReader","readable","entries","getEntries","close","pipeTo","preventClose","preventAbort","map","entry","filename","version","compressionMethod","lastModDate","lastAccessDate","creationDate","rawFilename","bitFlag","encrypted","uncompressedSize","compressedSize","diskOffset","diskNumber","zip64","rawExtraFieldZip64","rawExtraFieldAES","rawExtraFieldExtendedTimestamp","rawExtraFieldNTFS","rawExtraFieldUnix","rawExtraField","level","languageEncodingFlag","dataDescriptor","extraFieldLength","getLength","zip64UncompressedSize","zip64CompressedSize","headerArray","headerView","getHeaderArrayData","getBitFlag","zip64Offset","zip64DiskNumberStart","extendedTimestamp","length","extraFieldExtendedTimestampFlag","add","name","zipWriter","maxWorkers","Promise","resolve","push","promiseAddFile","trim","has","addFile","error","delete","pendingEntry","shift","remove","get","comment","allSettled","Array","from","closeFile","getOptionValue","getWriter","getData","ZipWriterStream","TransformStream","transform","path","flush","msDosCompatible","versionMadeBy","executable","uid","gid","unixMode","unixExtraFieldType","setuid","setgid","sticky","msdosAttributesRaw","msdosAttributes","hasUnixMetadata","hasMsDosProvided","externalFileAttributes","endsWith","directory","unixExternalUpper","Boolean","normalizeMsdosAttributes","encode","rawComment","Date","internalFileAttributes","passThrough","password","rawPassword","encryptionStrength","zipCrypto","keepOrder","useWebWorkers","bufferedWrite","dataDescriptorSignature","signal","useUnicodeFileNames","useCompressionStream","CompressionStream","CompressionStreamZlib","extraField","extraFieldSize","forEach","data","type","arraySet","Uint16Array","maximumCompressedSize","maximumEntrySize","zip64Enabled","getMaximumCompressedSize","supportZip64SplitFile","Math","ceil","internalFileAttribute","externalFileAttribute","signature","diskNumberStart","headerInfo","getHeaderInfo","dataDescriptorInfo","getDataDescriptorInfo","metadataSize","localHeaderArray","dataDescriptorArray","fileEntry","getFileEntry","entryInfo","usdz","previousFileEntry","values","pop","releaseLockWriter","releaseLockCurrentFileEntry","writingBufferedEntryData","writingEntryData","fileWriter","blobPromise","set","lockPreviousFileEntry","lock","requestLockCurrentFileEntry","writerLocked","requestLockWriter","signatureArray","signatureArrayView","getDataView","setUint32","writeData","appendExtraFieldUSDZ","localHeaderView","skipDiskIfNeeded","Response","blob","createFileEntry","all","updateZip64ExtraField","updateLocalHeader","stream","hasCorruptedEntries","corruptedEntry","lockWriter","rawLastModDate","compressed","localExtraFieldZip64Length","onstart","onprogress","onend","filenameUTF8","commentUTF8","chunkSize","workerOptions","codecType","passwordVerification","signed","transferStreams","streamOptions","result","outputSize","inputSize","setEntryInfo","uncompressedFile","zip64ExtraFieldComplete","rawExtraFieldZip64Length","rawExtraFieldZip64View","setUint16","rawExtraFieldZip64Offset","setBigUint64","BigInt","extraFieldAESView","setUint8","extraFieldExtendedTimestampView","floor","getTime","extraFieldNTFSView","lastModTimeNTFS","getTimeNTFS","uidBytes","packUnixId","gidBytes","modeArray","modeToWrite","modeDataView","DataView","buffer","payloadLength","rawExtraFieldUnixView","localHeaderOffset","zipWriterOffset","localHeaderArrayView","extraBytesLength","rawExtraFieldUSDZ","extraFieldUSDZView","previousLocalHeaderArray","id","dataArray","dataView","subarray","readOnly","hidden","system","msdDir","archive","raw","dataDescriptorView","dataDescriptorOffset","dataDescriptorLength","directoryDataLength","directoryOffset","filesLength","rawExtraFieldTimestamp","directoryArray","directoryView","directoryDiskOffset","indexFileEntry","fileEntryOffset","slice","lastDiskNumber","endOfdirectoryArray","endOfdirectoryView","commentLength","array","streamWriter","ready","write","releaseLock","date","defaultValue","view","value","typedArray","arrayLikes","arrayLike","dateArray","Uint32Array","dateView","getHours","getMinutes","getSeconds","getFullYear","getMonth","getDate"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@zip.js/zip.js/lib/core/zip-writer.js"],"sourcesContent":["/*\n Copyright (c) 2025 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright\n notice, this list of conditions and the following disclaimer in\n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* global TransformStream, Response */\n// deno-lint-ignore-file no-this-alias\n\nimport {\n\tMAX_32_BITS,\n\tMAX_16_BITS,\n\tMAX_8_BITS,\n\tCOMPRESSION_METHOD_DEFLATE,\n\tCOMPRESSION_METHOD_DEFLATE_64,\n\tCOMPRESSION_METHOD_STORE,\n\tCOMPRESSION_METHOD_AES,\n\tSPLIT_ZIP_FILE_SIGNATURE,\n\tLOCAL_FILE_HEADER_SIGNATURE,\n\tDATA_DESCRIPTOR_RECORD_SIGNATURE,\n\tCENTRAL_FILE_HEADER_SIGNATURE,\n\tEND_OF_CENTRAL_DIR_SIGNATURE,\n\tZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE,\n\tZIP64_END_OF_CENTRAL_DIR_SIGNATURE,\n\tDATA_DESCRIPTOR_RECORD_LENGTH,\n\tDATA_DESCRIPTOR_RECORD_ZIP_64_LENGTH,\n\tDATA_DESCRIPTOR_RECORD_SIGNATURE_LENGTH,\n\tEXTRAFIELD_TYPE_AES,\n\tEXTRAFIELD_TYPE_ZIP64,\n\tEXTRAFIELD_TYPE_EXTENDED_TIMESTAMP,\n\tEXTRAFIELD_TYPE_NTFS,\n\tEXTRAFIELD_TYPE_NTFS_TAG1,\n\tEXTRAFIELD_TYPE_USDZ,\n\tEXTRAFIELD_TYPE_INFOZIP,\n\tEXTRAFIELD_TYPE_UNIX,\n\tEND_OF_CENTRAL_DIR_LENGTH,\n\tZIP64_END_OF_CENTRAL_DIR_LENGTH,\n\tZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH,\n\tZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH,\n\tBITFLAG_ENCRYPTED,\n\tBITFLAG_DATA_DESCRIPTOR,\n\tBITFLAG_LANG_ENCODING_FLAG,\n\tBITFLAG_LEVEL_FAST_MASK,\n\tBITFLAG_LEVEL_SUPER_FAST_MASK,\n\tBITFLAG_LEVEL_MAX_MASK,\n\tFILE_ATTR_MSDOS_DIR_MASK,\n\tFILE_ATTR_MSDOS_READONLY_MASK,\n\tFILE_ATTR_MSDOS_HIDDEN_MASK,\n\tFILE_ATTR_MSDOS_SYSTEM_MASK,\n\tFILE_ATTR_MSDOS_ARCHIVE_MASK,\n\tFILE_ATTR_UNIX_TYPE_DIR,\n\tFILE_ATTR_UNIX_EXECUTABLE_MASK,\n\tFILE_ATTR_UNIX_DEFAULT_MASK,\n\tFILE_ATTR_UNIX_SETUID_MASK,\n\tFILE_ATTR_UNIX_SETGID_MASK,\n\tFILE_ATTR_UNIX_STICKY_MASK,\n\tVERSION_DEFLATE,\n\tVERSION_ZIP64,\n\tVERSION_AES,\n\tDIRECTORY_SIGNATURE,\n\tHEADER_SIZE,\n\tHEADER_OFFSET_SIGNATURE,\n\tHEADER_OFFSET_COMPRESSED_SIZE,\n\tHEADER_OFFSET_UNCOMPRESSED_SIZE,\n\tMIN_DATE,\n\tMAX_DATE,\n\tUNDEFINED_VALUE,\n\tOBJECT_TYPE\n} from \"./constants.js\";\nimport {\n\tgetConfiguration,\n\tgetChunkSize\n} from \"./configuration.js\";\nimport {\n\tCODEC_DEFLATE,\n\trunWorker\n} from \"./codec-pool.js\";\nimport {\n\tinitStream,\n\tGenericWriter,\n\tGenericReader\n} from \"./io.js\";\nimport { encodeText } from \"./util/encode-text.js\";\nimport {\n\tPROPERTY_NAME_LAST_MODIFICATION_DATE,\n\tPROPERTY_NAME_LAST_ACCESS_DATE,\n\tPROPERTY_NAME_CREATION_DATE,\n\tPROPERTY_NAME_INTERNAL_FILE_ATTRIBUTES,\n\tPROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTES,\n\tPROPERTY_NAME_MS_DOS_COMPATIBLE,\n\tPROPERTY_NAME_ZIP64,\n\tPROPERTY_NAME_ENCRYPTED,\n\tPROPERTY_NAME_VERSION,\n\tPROPERTY_NAME_VERSION_MADE_BY,\n\tPROPERTY_NAME_ZIPCRYPTO,\n\tPROPERTY_NAME_DIRECTORY,\n\tPROPERTY_NAME_EXECUTABLE,\n\tPROPERTY_NAME_COMPRESSION_METHOD,\n\tPROPERTY_NAME_SIGNATURE,\n\tPROPERTY_NAME_COMMENT,\n\tPROPERTY_NAME_UNCOMPRESSED_SIZE,\n\tPROPERTY_NAME_EXTRA_FIELD,\n\tPROPERTY_NAME_UID,\n\tPROPERTY_NAME_GID,\n\tPROPERTY_NAME_UNIX_MODE,\n\tPROPERTY_NAME_SETUID,\n\tPROPERTY_NAME_SETGID,\n\tPROPERTY_NAME_STICKY,\n\tPROPERTY_NAME_MSDOS_ATTRIBUTES,\n\tPROPERTY_NAME_MSDOS_ATTRIBUTES_RAW,\n\tEntry\n} from \"./zip-entry.js\";\nimport {\n\tOPTION_PASSWORD,\n\tOPTION_RAW_PASSWORD,\n\tOPTION_PASS_THROUGH,\n\tOPTION_SIGNAL,\n\tOPTION_USE_WEB_WORKERS,\n\tOPTION_USE_COMPRESSION_STREAM,\n\tOPTION_PREVENT_CLOSE,\n\tOPTION_ENCRYPTION_STRENGTH,\n\tOPTION_EXTENDED_TIMESTAMP,\n\tOPTION_KEEP_ORDER,\n\tOPTION_LEVEL,\n\tOPTION_BUFFERED_WRITE,\n\tOPTION_DATA_DESCRIPTOR_SIGNATURE,\n\tOPTION_USE_UNICODE_FILE_NAMES,\n\tOPTION_DATA_DESCRIPTOR,\n\tOPTION_SUPPORT_ZIP64_SPLIT_FILE,\n\tOPTION_ENCODE_TEXT,\n\tOPTION_OFFSET,\n\tOPTION_USDZ,\n\tOPTION_UNIX_EXTRA_FIELD_TYPE\n} from \"./options.js\";\nimport {\n\tZipReader\n} from \"./zip-reader.js\";\n\nconst ERR_DUPLICATED_NAME = \"File already exists\";\nconst ERR_INVALID_COMMENT = \"Zip file comment exceeds 64KB\";\nconst ERR_INVALID_ENTRY_COMMENT = \"File entry comment exceeds 64KB\";\nconst ERR_INVALID_ENTRY_NAME = \"File entry name exceeds 64KB\";\nconst ERR_INVALID_VERSION = \"Version exceeds 65535\";\nconst ERR_INVALID_ENCRYPTION_STRENGTH = \"The strength must equal 1, 2, or 3\";\nconst ERR_INVALID_EXTRAFIELD_TYPE = \"Extra field type exceeds 65535\";\nconst ERR_INVALID_EXTRAFIELD_DATA = \"Extra field data exceeds 64KB\";\nconst ERR_UNSUPPORTED_FORMAT = \"Zip64 is not supported (make sure 'keepOrder' is set to 'true')\";\nconst ERR_UNDEFINED_UNCOMPRESSED_SIZE = \"Undefined uncompressed size\";\nconst ERR_ZIP_NOT_EMPTY = \"Zip file not empty\";\nconst ERR_INVALID_UID = \"Invalid uid (must be integer 0..2^32-1)\";\nconst ERR_INVALID_GID = \"Invalid gid (must be integer 0..2^32-1)\";\nconst ERR_INVALID_UNIX_MODE = \"Invalid UNIX mode (must be integer 0..65535)\";\nconst ERR_INVALID_UNIX_EXTRA_FIELD_TYPE = \"Invalid unixExtraFieldType (must be 'infozip' or 'unix')\";\nconst ERR_INVALID_MSDOS_ATTRIBUTES = \"Invalid msdosAttributesRaw (must be integer 0..255)\";\nconst ERR_INVALID_MSDOS_DATA = \"Invalid msdosAttributes (must be an object with boolean flags)\";\n\nconst EXTRAFIELD_DATA_AES = new Uint8Array([0x07, 0x00, 0x02, 0x00, 0x41, 0x45, 0x03, 0x00, 0x00]);\nconst INFOZIP_EXTRA_FIELD_TYPE = \"infozip\";\nconst UNIX_EXTRA_FIELD_TYPE = \"unix\";\n\nlet workers = 0;\nconst pendingEntries = [];\n\nclass ZipWriter {\n\n\tconstructor(writer, options = {}) {\n\t\twriter = new GenericWriter(writer);\n\t\tconst addSplitZipSignature =\n\t\t\twriter.availableSize !== UNDEFINED_VALUE && writer.availableSize > 0 && writer.availableSize !== Infinity &&\n\t\t\twriter.maxSize !== UNDEFINED_VALUE && writer.maxSize > 0 && writer.maxSize !== Infinity;\n\t\tObject.assign(this, {\n\t\t\twriter,\n\t\t\taddSplitZipSignature,\n\t\t\toptions,\n\t\t\tconfig: getConfiguration(),\n\t\t\tfiles: new Map(),\n\t\t\tfilenames: new Set(),\n\t\t\toffset: options[OPTION_OFFSET] === UNDEFINED_VALUE ? writer.size || writer.writable.size || 0 : options[OPTION_OFFSET],\n\t\t\tpendingEntriesSize: 0,\n\t\t\tpendingAddFileCalls: new Set(),\n\t\t\tbufferedWrites: 0\n\t\t});\n\t}\n\n\tasync prependZip(reader) {\n\t\tif (this.filenames.size) {\n\t\t\tthrow new Error(ERR_ZIP_NOT_EMPTY);\n\t\t}\n\t\treader = new GenericReader(reader);\n\t\tconst zipReader = new ZipReader(reader.readable);\n\t\tconst entries = await zipReader.getEntries();\n\t\tawait zipReader.close();\n\t\tawait reader.readable.pipeTo(this.writer.writable, { preventClose: true, preventAbort: true });\n\t\tthis.writer.size = this.offset = reader.size;\n\t\tthis.filenames = new Set(entries.map(entry => entry.filename));\n\t\tthis.files = new Map(entries.map(entry => {\n\t\t\tconst {\n\t\t\t\tversion,\n\t\t\t\tcompressionMethod,\n\t\t\t\tlastModDate,\n\t\t\t\tlastAccessDate,\n\t\t\t\tcreationDate,\n\t\t\t\trawFilename,\n\t\t\t\tbitFlag,\n\t\t\t\tencrypted,\n\t\t\t\tuncompressedSize,\n\t\t\t\tcompressedSize,\n\t\t\t\tdiskOffset,\n\t\t\t\tdiskNumber,\n\t\t\t\tzip64\n\t\t\t} = entry;\n\t\t\tlet {\n\t\t\t\trawExtraFieldZip64,\n\t\t\t\trawExtraFieldAES,\n\t\t\t\trawExtraFieldExtendedTimestamp,\n\t\t\t\trawExtraFieldNTFS,\n\t\t\t\trawExtraFieldUnix,\n\t\t\t\trawExtraField,\n\t\t\t} = entry;\n\t\t\tconst { level, languageEncodingFlag, dataDescriptor } = bitFlag;\n\t\t\trawExtraFieldZip64 = rawExtraFieldZip64 || new Uint8Array();\n\t\t\trawExtraFieldAES = rawExtraFieldAES || new Uint8Array();\n\t\t\trawExtraFieldExtendedTimestamp = rawExtraFieldExtendedTimestamp || new Uint8Array();\n\t\t\trawExtraFieldNTFS = rawExtraFieldNTFS || new Uint8Array();\n\t\t\trawExtraFieldUnix = entry.rawExtraFieldUnix || new Uint8Array();\n\t\t\trawExtraField = rawExtraField || new Uint8Array();\n\t\t\tconst extraFieldLength = getLength(rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS, rawExtraFieldUnix, rawExtraField);\n\t\t\tconst zip64UncompressedSize = zip64 && uncompressedSize > MAX_32_BITS;\n\t\t\tconst zip64CompressedSize = zip64 && compressedSize > MAX_32_BITS;\n\t\t\tconst {\n\t\t\t\theaderArray,\n\t\t\t\theaderView\n\t\t\t} = getHeaderArrayData({\n\t\t\t\tversion,\n\t\t\t\tbitFlag: getBitFlag(level, languageEncodingFlag, dataDescriptor, encrypted, compressionMethod),\n\t\t\t\tcompressionMethod,\n\t\t\t\tuncompressedSize,\n\t\t\t\tcompressedSize,\n\t\t\t\tlastModDate,\n\t\t\t\trawFilename,\n\t\t\t\tzip64CompressedSize,\n\t\t\t\tzip64UncompressedSize,\n\t\t\t\textraFieldLength\n\t\t\t});\n\t\t\tObject.assign(entry, {\n\t\t\t\tzip64UncompressedSize,\n\t\t\t\tzip64CompressedSize,\n\t\t\t\tzip64Offset: zip64 && this.offset - diskOffset > MAX_32_BITS,\n\t\t\t\tzip64DiskNumberStart: zip64 && diskNumber > MAX_16_BITS,\n\t\t\t\trawExtraFieldZip64,\n\t\t\t\trawExtraFieldAES,\n\t\t\t\trawExtraFieldExtendedTimestamp,\n\t\t\t\trawExtraFieldNTFS,\n\t\t\t\trawExtraFieldUnix,\n\t\t\t\trawExtraField,\n\t\t\t\textendedTimestamp: rawExtraFieldExtendedTimestamp.length > 0 || rawExtraFieldNTFS.length > 0,\n\t\t\t\textraFieldExtendedTimestampFlag: 0x1 + (lastAccessDate ? 0x2 : 0) + (creationDate ? 0x4 : 0),\n\t\t\t\theaderArray,\n\t\t\t\theaderView\n\t\t\t});\n\t\t\treturn [entry.filename, entry];\n\t\t}));\n\t}\n\n\tasync add(name = \"\", reader, options = {}) {\n\t\tconst zipWriter = this;\n\t\tconst {\n\t\t\tpendingAddFileCalls,\n\t\t\tconfig\n\t\t} = zipWriter;\n\t\tif (workers < config.maxWorkers) {\n\t\t\tworkers++;\n\t\t} else {\n\t\t\tawait new Promise(resolve => pendingEntries.push(resolve));\n\t\t}\n\t\tlet promiseAddFile;\n\t\ttry {\n\t\t\tname = name.trim();\n\t\t\tif (zipWriter.filenames.has(name)) {\n\t\t\t\tthrow new Error(ERR_DUPLICATED_NAME);\n\t\t\t}\n\t\t\tzipWriter.filenames.add(name);\n\t\t\tpromiseAddFile = addFile(zipWriter, name, reader, options);\n\t\t\tpendingAddFileCalls.add(promiseAddFile);\n\t\t\treturn await promiseAddFile;\n\t\t} catch (error) {\n\t\t\tzipWriter.filenames.delete(name);\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tpendingAddFileCalls.delete(promiseAddFile);\n\t\t\tconst pendingEntry = pendingEntries.shift();\n\t\t\tif (pendingEntry) {\n\t\t\t\tpendingEntry();\n\t\t\t} else {\n\t\t\t\tworkers--;\n\t\t\t}\n\t\t}\n\t}\n\n\tremove(entry) {\n\t\tconst { filenames, files } = this;\n\t\tif (typeof entry == \"string\") {\n\t\t\tentry = files.get(entry);\n\t\t}\n\t\tif (entry && entry.filename !== UNDEFINED_VALUE) {\n\t\t\tconst { filename } = entry;\n\t\t\tif (filenames.has(filename) && files.has(filename)) {\n\t\t\t\tfilenames.delete(filename);\n\t\t\t\tfiles.delete(filename);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tasync close(comment = new Uint8Array(), options = {}) {\n\t\tconst zipWriter = this;\n\t\tconst { pendingAddFileCalls, writer } = this;\n\t\tconst { writable } = writer;\n\t\twhile (pendingAddFileCalls.size) {\n\t\t\tawait Promise.allSettled(Array.from(pendingAddFileCalls));\n\t\t}\n\t\tawait closeFile(zipWriter, comment, options);\n\t\tconst preventClose = getOptionValue(zipWriter, options, OPTION_PREVENT_CLOSE);\n\t\tif (!preventClose) {\n\t\t\tawait writable.getWriter().close();\n\t\t}\n\t\treturn writer.getData ? writer.getData() : writable;\n\t}\n}\n\nclass ZipWriterStream {\n\n\tconstructor(options = {}) {\n\t\tconst { readable, writable } = new TransformStream();\n\t\tthis.readable = readable;\n\t\tthis.zipWriter = new ZipWriter(writable, options);\n\t}\n\n\ttransform(path) {\n\t\tconst { readable, writable } = new TransformStream({\n\t\t\tflush: () => { this.zipWriter.close(); }\n\t\t});\n\t\tthis.zipWriter.add(path, readable);\n\t\treturn { readable: this.readable, writable };\n\t}\n\n\twritable(path) {\n\t\tconst { readable, writable } = new TransformStream();\n\t\tthis.zipWriter.add(path, readable);\n\t\treturn writable;\n\t}\n\n\tclose(comment = UNDEFINED_VALUE, options = {}) {\n\t\treturn this.zipWriter.close(comment, options);\n\t}\n}\n\nexport {\n\tZipWriter,\n\tZipWriterStream,\n\tERR_DUPLICATED_NAME,\n\tERR_INVALID_COMMENT,\n\tERR_INVALID_ENTRY_NAME,\n\tERR_INVALID_ENTRY_COMMENT,\n\tERR_INVALID_VERSION,\n\tERR_INVALID_EXTRAFIELD_TYPE,\n\tERR_INVALID_EXTRAFIELD_DATA,\n\tERR_INVALID_ENCRYPTION_STRENGTH,\n\tERR_UNSUPPORTED_FORMAT,\n\tERR_UNDEFINED_UNCOMPRESSED_SIZE,\n\tERR_ZIP_NOT_EMPTY\n};\n\nasync function addFile(zipWriter, name, reader, options) {\n\tname = name.trim();\n\tlet msDosCompatible = getOptionValue(zipWriter, options, PROPERTY_NAME_MS_DOS_COMPATIBLE);\n\tlet versionMadeBy = getOptionValue(zipWriter, options, PROPERTY_NAME_VERSION_MADE_BY, msDosCompatible ? 20 : 768);\n\tconst executable = getOptionValue(zipWriter, options, PROPERTY_NAME_EXECUTABLE);\n\tconst uid = getOptionValue(zipWriter, options, PROPERTY_NAME_UID);\n\tconst gid = getOptionValue(zipWriter, options, PROPERTY_NAME_GID);\n\tlet unixMode = getOptionValue(zipWriter, options, PROPERTY_NAME_UNIX_MODE);\n\tconst unixExtraFieldType = getOptionValue(zipWriter, options, OPTION_UNIX_EXTRA_FIELD_TYPE);\n\tlet setuid = getOptionValue(zipWriter, options, PROPERTY_NAME_SETUID);\n\tlet setgid = getOptionValue(zipWriter, options, PROPERTY_NAME_SETGID);\n\tlet sticky = getOptionValue(zipWriter, options, PROPERTY_NAME_STICKY);\n\tif (uid !== UNDEFINED_VALUE && (uid < 0 || uid > MAX_32_BITS)) {\n\t\tthrow new Error(ERR_INVALID_UID);\n\t}\n\tif (gid !== UNDEFINED_VALUE && (gid < 0 || gid > MAX_32_BITS)) {\n\t\tthrow new Error(ERR_INVALID_GID);\n\t}\n\tif (unixMode !== UNDEFINED_VALUE && (unixMode < 0 || unixMode > MAX_16_BITS)) {\n\t\tthrow new Error(ERR_INVALID_UNIX_MODE);\n\t}\n\tif (unixExtraFieldType !== UNDEFINED_VALUE && unixExtraFieldType !== INFOZIP_EXTRA_FIELD_TYPE && unixExtraFieldType !== UNIX_EXTRA_FIELD_TYPE) {\n\t\tthrow new Error(ERR_INVALID_UNIX_EXTRA_FIELD_TYPE);\n\t}\n\tlet msdosAttributesRaw = getOptionValue(zipWriter, options, PROPERTY_NAME_MSDOS_ATTRIBUTES_RAW);\n\tlet msdosAttributes = getOptionValue(zipWriter, options, PROPERTY_NAME_MSDOS_ATTRIBUTES);\n\tconst hasUnixMetadata = uid !== UNDEFINED_VALUE || gid !== UNDEFINED_VALUE || unixMode !== UNDEFINED_VALUE || unixExtraFieldType;\n\tconst hasMsDosProvided = msdosAttributesRaw !== UNDEFINED_VALUE || msdosAttributes !== UNDEFINED_VALUE;\n\tif (hasUnixMetadata) {\n\t\tmsDosCompatible = false;\n\t\tversionMadeBy = (versionMadeBy & MAX_16_BITS) | (3 << 8);\n\t} else if (hasMsDosProvided) {\n\t\tmsDosCompatible = true;\n\t\tversionMadeBy = (versionMadeBy & MAX_8_BITS);\n\t}\n\tif (msdosAttributesRaw !== UNDEFINED_VALUE && (msdosAttributesRaw < 0 || msdosAttributesRaw > MAX_8_BITS)) {\n\t\tthrow new Error(ERR_INVALID_MSDOS_ATTRIBUTES);\n\t}\n\tif (msdosAttributes && typeof msdosAttributes !== OBJECT_TYPE) {\n\t\tthrow new Error(ERR_INVALID_MSDOS_DATA);\n\t}\n\tif (versionMadeBy > MAX_16_BITS) {\n\t\tthrow new Error(ERR_INVALID_VERSION);\n\t}\n\tlet externalFileAttributes = getOptionValue(zipWriter, options, PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTES, 0);\n\tif (!options[PROPERTY_NAME_DIRECTORY] && name.endsWith(DIRECTORY_SIGNATURE)) {\n\t\toptions[PROPERTY_NAME_DIRECTORY] = true;\n\t}\n\tconst directory = getOptionValue(zipWriter, options, PROPERTY_NAME_DIRECTORY);\n\tif (directory) {\n\t\tif (!name.endsWith(DIRECTORY_SIGNATURE)) {\n\t\t\tname += DIRECTORY_SIGNATURE;\n\t\t}\n\t\tif (externalFileAttributes === 0) {\n\t\t\texternalFileAttributes = FILE_ATTR_MSDOS_DIR_MASK;\n\t\t\tif (!msDosCompatible) {\n\t\t\t\texternalFileAttributes |= (FILE_ATTR_UNIX_TYPE_DIR | FILE_ATTR_UNIX_EXECUTABLE_MASK | FILE_ATTR_UNIX_DEFAULT_MASK) << 16;\n\t\t\t}\n\t\t}\n\t} else if (!msDosCompatible && externalFileAttributes === 0) {\n\t\tif (executable) {\n\t\t\texternalFileAttributes = (FILE_ATTR_UNIX_EXECUTABLE_MASK | FILE_ATTR_UNIX_DEFAULT_MASK) << 16;\n\t\t} else {\n\t\t\texternalFileAttributes = FILE_ATTR_UNIX_DEFAULT_MASK << 16;\n\t\t}\n\t}\n\tlet unixExternalUpper;\n\tif (!msDosCompatible) {\n\t\tunixExternalUpper = (externalFileAttributes >> 16) & MAX_16_BITS;\n\t\tunixMode = unixMode === UNDEFINED_VALUE ? unixExternalUpper : (unixMode & MAX_16_BITS);\n\t\tif (setuid) {\n\t\t\tunixMode |= FILE_ATTR_UNIX_SETUID_MASK;\n\t\t} else {\n\t\t\tsetuid = Boolean(unixMode & FILE_ATTR_UNIX_SETUID_MASK);\n\t\t}\n\t\tif (setgid) {\n\t\t\tunixMode |= FILE_ATTR_UNIX_SETGID_MASK;\n\t\t} else {\n\t\t\tsetgid = Boolean(unixMode & FILE_ATTR_UNIX_SETGID_MASK);\n\t\t}\n\t\tif (sticky) {\n\t\t\tunixMode |= FILE_ATTR_UNIX_STICKY_MASK;\n\t\t} else {\n\t\t\tsticky = Boolean(unixMode & FILE_ATTR_UNIX_STICKY_MASK);\n\t\t}\n\t\tif (directory) {\n\t\t\tunixMode |= FILE_ATTR_UNIX_TYPE_DIR;\n\t\t}\n\t\texternalFileAttributes = ((unixMode & MAX_16_BITS) << 16) | (externalFileAttributes & MAX_8_BITS);\n\t}\n\t({ msdosAttributesRaw, msdosAttributes } = normalizeMsdosAttributes(msdosAttributesRaw, msdosAttributes));\n\tif (hasMsDosProvided) {\n\t\texternalFileAttributes = (externalFileAttributes & MAX_32_BITS) | (msdosAttributesRaw & MAX_8_BITS);\n\t}\n\tconst encode = getOptionValue(zipWriter, options, OPTION_ENCODE_TEXT, encodeText);\n\tlet rawFilename = encode(name);\n\tif (rawFilename === UNDEFINED_VALUE) {\n\t\trawFilename = encodeText(name);\n\t}\n\tif (getLength(rawFilename) > MAX_16_BITS) {\n\t\tthrow new Error(ERR_INVALID_ENTRY_NAME);\n\t}\n\tconst comment = options[PROPERTY_NAME_COMMENT] || \"\";\n\tlet rawComment = encode(comment);\n\tif (rawComment === UNDEFINED_VALUE) {\n\t\trawComment = encodeText(comment);\n\t}\n\tif (getLength(rawComment) > MAX_16_BITS) {\n\t\tthrow new Error(ERR_INVALID_ENTRY_COMMENT);\n\t}\n\tconst version = getOptionValue(zipWriter, options, PROPERTY_NAME_VERSION, VERSION_DEFLATE);\n\tif (version > MAX_16_BITS) {\n\t\tthrow new Error(ERR_INVALID_VERSION);\n\t}\n\tconst lastModDate = getOptionValue(zipWriter, options, PROPERTY_NAME_LAST_MODIFICATION_DATE, new Date());\n\tconst lastAccessDate = getOptionValue(zipWriter, options, PROPERTY_NAME_LAST_ACCESS_DATE);\n\tconst creationDate = getOptionValue(zipWriter, options, PROPERTY_NAME_CREATION_DATE);\n\tconst internalFileAttributes = getOptionValue(zipWriter, options, PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTES, 0);\n\tconst passThrough = getOptionValue(zipWriter, options, OPTION_PASS_THROUGH);\n\tlet password, rawPassword;\n\tif (!passThrough) {\n\t\tpassword = getOptionValue(zipWriter, options, OPTION_PASSWORD);\n\t\trawPassword = getOptionValue(zipWriter, options, OPTION_RAW_PASSWORD);\n\t}\n\tconst encryptionStrength = getOptionValue(zipWriter, options, OPTION_ENCRYPTION_STRENGTH, 3);\n\tconst zipCrypto = getOptionValue(zipWriter, options, PROPERTY_NAME_ZIPCRYPTO);\n\tconst extendedTimestamp = getOptionValue(zipWriter, options, OPTION_EXTENDED_TIMESTAMP, true);\n\tconst keepOrder = getOptionValue(zipWriter, options, OPTION_KEEP_ORDER, true);\n\tconst useWebWorkers = getOptionValue(zipWriter, options, OPTION_USE_WEB_WORKERS);\n\tconst bufferedWrite = getOptionValue(zipWriter, options, OPTION_BUFFERED_WRITE);\n\tconst dataDescriptorSignature = getOptionValue(zipWriter, options, OPTION_DATA_DESCRIPTOR_SIGNATURE, false);\n\tconst signal = getOptionValue(zipWriter, options, OPTION_SIGNAL);\n\tconst useUnicodeFileNames = getOptionValue(zipWriter, options, OPTION_USE_UNICODE_FILE_NAMES, true);\n\tconst compressionMethod = getOptionValue(zipWriter, options, PROPERTY_NAME_COMPRESSION_METHOD);\n\tlet level = getOptionValue(zipWriter, options, OPTION_LEVEL);\n\tlet useCompressionStream = getOptionValue(zipWriter, options, OPTION_USE_COMPRESSION_STREAM);\n\tlet dataDescriptor = getOptionValue(zipWriter, options, OPTION_DATA_DESCRIPTOR);\n\tif (bufferedWrite && dataDescriptor === UNDEFINED_VALUE) {\n\t\tdataDescriptor = false;\n\t}\n\tif (dataDescriptor === UNDEFINED_VALUE || zipCrypto) {\n\t\tdataDescriptor = true;\n\t}\n\tif (level !== UNDEFINED_VALUE && level != 6) {\n\t\tuseCompressionStream = false;\n\t}\n\tif (!useCompressionStream && (zipWriter.config.CompressionStream === UNDEFINED_VALUE && zipWriter.config.CompressionStreamZlib === UNDEFINED_VALUE)) {\n\t\tlevel = 0;\n\t}\n\tlet zip64 = getOptionValue(zipWriter, options, PROPERTY_NAME_ZIP64);\n\tif (!zipCrypto && (password !== UNDEFINED_VALUE || rawPassword !== UNDEFINED_VALUE) && !(encryptionStrength >= 1 && encryptionStrength <= 3)) {\n\t\tthrow new Error(ERR_INVALID_ENCRYPTION_STRENGTH);\n\t}\n\tlet rawExtraField = new Uint8Array();\n\tconst extraField = options[PROPERTY_NAME_EXTRA_FIELD];\n\tif (extraField) {\n\t\tlet extraFieldSize = 0;\n\t\tlet offset = 0;\n\t\textraField.forEach(data => extraFieldSize += 4 + getLength(data));\n\t\trawExtraField = new Uint8Array(extraFieldSize);\n\t\textraField.forEach((data, type) => {\n\t\t\tif (type > MAX_16_BITS) {\n\t\t\t\tthrow new Error(ERR_INVALID_EXTRAFIELD_TYPE);\n\t\t\t}\n\t\t\tif (getLength(data) > MAX_16_BITS) {\n\t\t\t\tthrow new Error(ERR_INVALID_EXTRAFIELD_DATA);\n\t\t\t}\n\t\t\tarraySet(rawExtraField, new Uint16Array([type]), offset);\n\t\t\tarraySet(rawExtraField, new Uint16Array([getLength(data)]), offset + 2);\n\t\t\tarraySet(rawExtraField, data, offset + 4);\n\t\t\toffset += 4 + getLength(data);\n\t\t});\n\t}\n\tlet maximumCompressedSize = 0;\n\tlet maximumEntrySize = 0;\n\tlet uncompressedSize = 0;\n\tif (passThrough) {\n\t\tuncompressedSize = options[PROPERTY_NAME_UNCOMPRESSED_SIZE];\n\t\tif (uncompressedSize === UNDEFINED_VALUE) {\n\t\t\tthrow new Error(ERR_UNDEFINED_UNCOMPRESSED_SIZE);\n\t\t}\n\t}\n\tconst zip64Enabled = zip64 === true;\n\tif (reader) {\n\t\treader = new GenericReader(reader);\n\t\tawait initStream(reader);\n\t\tif (!passThrough) {\n\t\t\tif (reader.size === UNDEFINED_VALUE) {\n\t\t\t\tdataDescriptor = true;\n\t\t\t\tif (zip64 || zip64 === UNDEFINED_VALUE) {\n\t\t\t\t\tzip64 = true;\n\t\t\t\t\tuncompressedSize = maximumCompressedSize = MAX_32_BITS + 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toptions.uncompressedSize = uncompressedSize = reader.size;\n\t\t\t\tmaximumCompressedSize = getMaximumCompressedSize(uncompressedSize);\n\t\t\t}\n\t\t} else {\n\t\t\toptions.uncompressedSize = uncompressedSize;\n\t\t\tmaximumCompressedSize = getMaximumCompressedSize(uncompressedSize);\n\t\t}\n\t}\n\tconst { diskOffset, diskNumber, maxSize } = zipWriter.writer;\n\tconst zip64UncompressedSize = zip64Enabled || uncompressedSize > MAX_32_BITS;\n\tconst zip64CompressedSize = zip64Enabled || maximumCompressedSize > MAX_32_BITS;\n\tconst zip64Offset = zip64Enabled || zipWriter.offset + zipWriter.pendingEntriesSize - diskOffset > MAX_32_BITS;\n\tconst supportZip64SplitFile = getOptionValue(zipWriter, options, OPTION_SUPPORT_ZIP64_SPLIT_FILE, true);\n\tconst zip64DiskNumberStart = (supportZip64SplitFile && zip64Enabled) || diskNumber + Math.ceil(zipWriter.pendingEntriesSize / maxSize) > MAX_16_BITS;\n\tif (zip64Offset || zip64UncompressedSize || zip64CompressedSize || zip64DiskNumberStart) {\n\t\tif (zip64 === false || !keepOrder) {\n\t\t\tthrow new Error(ERR_UNSUPPORTED_FORMAT);\n\t\t} else {\n\t\t\tzip64 = true;\n\t\t}\n\t}\n\tzip64 = zip64 || false;\n\tconst encrypted = getOptionValue(zipWriter, options, PROPERTY_NAME_ENCRYPTED);\n\toptions = Object.assign({}, options, {\n\t\trawFilename,\n\t\trawComment,\n\t\tversion,\n\t\tversionMadeBy,\n\t\tlastModDate,\n\t\tlastAccessDate,\n\t\tcreationDate,\n\t\trawExtraField,\n\t\tzip64,\n\t\tzip64UncompressedSize,\n\t\tzip64CompressedSize,\n\t\tzip64Offset,\n\t\tzip64DiskNumberStart,\n\t\tpassword,\n\t\trawPassword,\n\t\tlevel,\n\t\tuseWebWorkers,\n\t\tencryptionStrength,\n\t\textendedTimestamp,\n\t\tzipCrypto,\n\t\tbufferedWrite,\n\t\tkeepOrder,\n\t\tuseUnicodeFileNames,\n\t\tdataDescriptor,\n\t\tdataDescriptorSignature,\n\t\tsignal,\n\t\tmsDosCompatible,\n\t\tinternalFileAttribute: internalFileAttributes,\n\t\tinternalFileAttributes,\n\t\texternalFileAttribute: externalFileAttributes,\n\t\texternalFileAttributes,\n\t\tuseCompressionStream,\n\t\tpassThrough,\n\t\tencrypted: Boolean((password && getLength(password)) || (rawPassword && getLength(rawPassword))) || (passThrough && encrypted),\n\t\tsignature: options[PROPERTY_NAME_SIGNATURE],\n\t\tcompressionMethod,\n\t\tuncompressedSize,\n\t\toffset: zipWriter.offset - diskOffset,\n\t\tdiskNumberStart: diskNumber,\n\t\tuid,\n\t\tgid,\n\t\tsetuid,\n\t\tsetgid,\n\t\tsticky,\n\t\tunixMode,\n\t\tmsdosAttributesRaw,\n\t\tmsdosAttributes,\n\t\tunixExternalUpper\n\t});\n\tconst headerInfo = getHeaderInfo(options);\n\tconst dataDescriptorInfo = getDataDescriptorInfo(options);\n\tconst metadataSize = getLength(headerInfo.localHeaderArray, dataDescriptorInfo.dataDescriptorArray);\n\tmaximumEntrySize = metadataSize + maximumCompressedSize;\n\tif (zipWriter.options[OPTION_USDZ]) {\n\t\tmaximumEntrySize += maximumEntrySize + 64;\n\t}\n\tzipWriter.pendingEntriesSize += maximumEntrySize;\n\tlet fileEntry;\n\ttry {\n\t\tfileEntry = await getFileEntry(zipWriter, name, reader, { headerInfo, dataDescriptorInfo, metadataSize }, options);\n\t} finally {\n\t\tzipWriter.pendingEntriesSize -= maximumEntrySize;\n\t}\n\tObject.assign(fileEntry, { name, comment, extraField });\n\treturn new Entry(fileEntry);\n}\n\nasync function getFileEntry(zipWriter, name, reader, entryInfo, options) {\n\tconst {\n\t\tfiles,\n\t\twriter\n\t} = zipWriter;\n\tconst {\n\t\tkeepOrder,\n\t\tdataDescriptor,\n\t\tsignal\n\t} = options;\n\tconst {\n\t\theaderInfo\n\t} = entryInfo;\n\tconst usdz = zipWriter.options[OPTION_USDZ];\n\tconst previousFileEntry = Array.from(files.values()).pop();\n\tlet fileEntry = {};\n\tlet bufferedWrite;\n\tlet releaseLockWriter;\n\tlet releaseLockCurrentFileEntry;\n\tlet writingBufferedEntryData;\n\tlet writingEntryData;\n\tlet fileWriter;\n\tlet blobPromise;\n\tfiles.set(name, fileEntry);\n\ttry {\n\t\tlet lockPreviousFileEntry;\n\t\tif (keepOrder) {\n\t\t\tlockPreviousFileEntry = previousFileEntry && previousFileEntry.lock;\n\t\t\trequestLockCurrentFileEntry();\n\t\t}\n\t\tif ((options.bufferedWrite || zipWriter.writerLocked || (zipWriter.bufferedWrites && keepOrder) || !dataDescriptor) && !usdz) {\n\t\t\tfileWriter = new TransformStream();\n\t\t\tfileWriter.size = 0;\n\t\t\tbufferedWrite = true;\n\t\t\tzipWriter.bufferedWrites++;\n\t\t\tawait initStream(writer);\n\t\t} else {\n\t\t\tfileWriter = writer;\n\t\t\tawait requestLockWriter();\n\t\t}\n\t\tawait initStream(fileWriter);\n\t\tconst { writable, diskOffset } = writer;\n\t\tif (zipWriter.addSplitZipSignature) {\n\t\t\tdelete zipWriter.addSplitZipSignature;\n\t\t\tconst signatureArray = new Uint8Array(4);\n\t\t\tconst signatureArrayView = getDataView(signatureArray);\n\t\t\tsetUint32(signatureArrayView, 0, SPLIT_ZIP_FILE_SIGNATURE);\n\t\t\tawait writeData(writer, signatureArray);\n\t\t\tzipWriter.offset += 4;\n\t\t}\n\t\tif (usdz) {\n\t\t\tappendExtraFieldUSDZ(entryInfo, zipWriter.offset - diskOffset);\n\t\t}\n\t\tconst {\n\t\t\tlocalHeaderView,\n\t\t\tlocalHeaderArray\n\t\t} = headerInfo;\n\t\tif (!bufferedWrite) {\n\t\t\tawait lockPreviousFileEntry;\n\t\t\tawait skipDiskIfNeeded(writable);\n\t\t}\n\t\tconst { diskNumber } = writer;\n\t\twritingEntryData = true;\n\t\tfileEntry.diskNumberStart = diskNumber;\n\t\tif (bufferedWrite) {\n\t\t\tblobPromise = new Response(fileWriter.readable).blob();\n\t\t} else {\n\t\t\tawait writeData(fileWriter, localHeaderArray);\n\t\t}\n\t\tfileEntry = await createFileEntry(reader, fileWriter, fileEntry, entryInfo, zipWriter.config, options);\n\t\tconst { zip64 } = fileEntry;\n\t\twritingEntryData = false;\n\t\tfiles.set(name, fileEntry);\n\t\tfileEntry.filename = name;\n\t\tif (bufferedWrite) {\n\t\t\tconst [blob] = await Promise.all([blobPromise, fileWriter.writable.getWriter().close(), lockPreviousFileEntry]);\n\t\t\tawait requestLockWriter();\n\t\t\twritingBufferedEntryData = true;\n\t\t\tfileEntry.diskNumberStart = writer.diskNumber;\n\t\t\tfileEntry.offset = zipWriter.offset - writer.diskOffset;\n\t\t\tif (zip64) {\n\t\t\t\tupdateZip64ExtraField(fileEntry);\n\t\t\t}\n\t\t\tupdateLocalHeader(fileEntry, localHeaderView, options);\n\t\t\tawait skipDiskIfNeeded(writable);\n\t\t\tawait writeData(writer, localHeaderArray);\n\t\t\tawait blob.stream().pipeTo(writable, { preventClose: true, preventAbort: true, signal });\n\t\t\twriter.size += fileWriter.size;\n\t\t\twritingBufferedEntryData = false;\n\t\t} else {\n\t\t\tfileEntry.offset = zipWriter.offset - diskOffset;\n\t\t\tif (zip64) {\n\t\t\t\tupdateZip64ExtraField(fileEntry);\n\t\t\t}\n\t\t}\n\t\tif (fileEntry.offset > MAX_32_BITS && !zip64) {\n\t\t\tthrow new Error(ERR_UNSUPPORTED_FORMAT);\n\t\t}\n\t\tzipWriter.offset += fileEntry.size;\n\t\treturn fileEntry;\n\t} catch (error) {\n\t\tif ((bufferedWrite && writingBufferedEntryData) || (!bufferedWrite && writingEntryData)) {\n\t\t\tzipWriter.hasCorruptedEntries = true;\n\t\t\tif (error) {\n\t\t\t\ttry {\n\t\t\t\t\terror.corruptedEntry = true;\n\t\t\t\t} catch {\n\t\t\t\t\t// ignored\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bufferedWrite) {\n\t\t\t\tzipWriter.offset += fileWriter.size;\n\t\t\t} else {\n\t\t\t\tzipWriter.offset = fileWriter.size;\n\t\t\t}\n\t\t}\n\t\tfiles.delete(name);\n\t\tthrow error;\n\t} finally {\n\t\tif (bufferedWrite) {\n\t\t\tzipWriter.bufferedWrites--;\n\t\t}\n\t\tif (releaseLockCurrentFileEntry) {\n\t\t\treleaseLockCurrentFileEntry();\n\t\t}\n\t\tif (releaseLockWriter) {\n\t\t\treleaseLockWriter();\n\t\t}\n\t}\n\n\tfunction requestLockCurrentFileEntry() {\n\t\tfileEntry.lock = new Promise(resolve => releaseLockCurrentFileEntry = resolve);\n\t}\n\n\tasync function requestLockWriter() {\n\t\tzipWriter.writerLocked = true;\n\t\tconst { lockWriter } = zipWriter;\n\t\tzipWriter.lockWriter = new Promise(resolve => releaseLockWriter = () => {\n\t\t\tzipWriter.writerLocked = false;\n\t\t\tresolve();\n\t\t});\n\t\tawait lockWriter;\n\t}\n\n\tasync function skipDiskIfNeeded(writable) {\n\t\tif (getLength(headerInfo.localHeaderArray) > writer.availableSize) {\n\t\t\twriter.availableSize = 0;\n\t\t\tawait writeData(writable, new Uint8Array());\n\t\t}\n\t}\n}\n\nasync function createFileEntry(reader, writer, { diskNumberStart, lock }, entryInfo, config, options) {\n\tconst {\n\t\theaderInfo,\n\t\tdataDescriptorInfo,\n\t\tmetadataSize\n\t} = entryInfo;\n\tconst {\n\t\theaderArray,\n\t\theaderView,\n\t\tlastModDate,\n\t\trawLastModDate,\n\t\tencrypted,\n\t\tcompressed,\n\t\tversion,\n\t\tcompressionMethod,\n\t\trawExtraFieldZip64,\n\t\tlocalExtraFieldZip64Length,\n\t\trawExtraFieldExtendedTimestamp,\n\t\textraFieldExtendedTimestampFlag,\n\t\trawExtraFieldNTFS,\n\t\trawExtraFieldUnix,\n\t\trawExtraFieldAES,\n\t} = headerInfo;\n\tconst { dataDescriptorArray } = dataDescriptorInfo;\n\tconst {\n\t\trawFilename,\n\t\tlastAccessDate,\n\t\tcreationDate,\n\t\tpassword,\n\t\trawPassword,\n\t\tlevel,\n\t\tzip64,\n\t\tzip64UncompressedSize,\n\t\tzip64CompressedSize,\n\t\tzip64Offset,\n\t\tzip64DiskNumberStart,\n\t\tzipCrypto,\n\t\tdataDescriptor,\n\t\tdirectory,\n\t\texecutable,\n\t\tversionMadeBy,\n\t\trawComment,\n\t\trawExtraField,\n\t\tuseWebWorkers,\n\t\tonstart,\n\t\tonprogress,\n\t\tonend,\n\t\tsignal,\n\t\tencryptionStrength,\n\t\textendedTimestamp,\n\t\tmsDosCompatible,\n\t\tinternalFileAttributes,\n\t\texternalFileAttributes,\n\t\tuid,\n\t\tgid,\n\t\tunixMode,\n\t\tsetuid,\n\t\tsetgid,\n\t\tsticky,\n\t\tunixExternalUpper,\n\t\tmsdosAttributesRaw,\n\t\tmsdosAttributes,\n\t\tuseCompressionStream,\n\t\tpassThrough\n\t} = options;\n\tconst fileEntry = {\n\t\tlock,\n\t\tversionMadeBy,\n\t\tzip64,\n\t\tdirectory: Boolean(directory),\n\t\texecutable: Boolean(executable),\n\t\tfilenameUTF8: true,\n\t\trawFilename,\n\t\tcommentUTF8: true,\n\t\trawComment,\n\t\trawExtraFieldZip64,\n\t\tlocalExtraFieldZip64Length,\n\t\trawExtraFieldExtendedTimestamp,\n\t\trawExtraFieldNTFS,\n\t\trawExtraFieldUnix,\n\t\trawExtraFieldAES,\n\t\trawExtraField,\n\t\textendedTimestamp,\n\t\tmsDosCompatible,\n\t\tinternalFileAttributes,\n\t\texternalFileAttributes,\n\t\tdiskNumberStart,\n\t\tuid,\n\t\tgid,\n\t\tunixMode,\n\t\tsetuid,\n\t\tsetgid,\n\t\tsticky,\n\t\tunixExternalUpper,\n\t\tmsdosAttributesRaw,\n\t\tmsdosAttributes\n\t};\n\tlet {\n\t\tsignature,\n\t\tuncompressedSize\n\t} = options;\n\tlet compressedSize = 0;\n\tif (!passThrough) {\n\t\tuncompressedSize = 0;\n\t}\n\tconst { writable } = writer;\n\tif (reader) {\n\t\treader.chunkSize = getChunkSize(config);\n\t\tconst readable = reader.readable;\n\t\tconst size = reader.size;\n\t\tconst workerOptions = {\n\t\t\toptions: {\n\t\t\t\tcodecType: CODEC_DEFLATE,\n\t\t\t\tlevel,\n\t\t\t\trawPassword,\n\t\t\t\tpassword,\n\t\t\t\tencryptionStrength,\n\t\t\t\tzipCrypto: encrypted && zipCrypto,\n\t\t\t\tpasswordVerification: encrypted && zipCrypto && (rawLastModDate >> 8) & MAX_8_BITS,\n\t\t\t\tsigned: !passThrough,\n\t\t\t\tcompressed: compressed && !passThrough,\n\t\t\t\tencrypted: encrypted && !passThrough,\n\t\t\t\tuseWebWorkers,\n\t\t\t\tuseCompressionStream,\n\t\t\t\ttransferStreams: false\n\t\t\t},\n\t\t\tconfig,\n\t\t\tstreamOptions: { signal, size, onstart, onprogress, onend }\n\t\t};\n\t\ttry {\n\t\t\tconst result = await runWorker({ readable, writable }, workerOptions);\n\t\t\tcompressedSize = result.outputSize;\n\t\t\twriter.size += compressedSize;\n\t\t\tif (!passThrough) {\n\t\t\t\tuncompressedSize = result.inputSize;\n\t\t\t\tsignature = result.signature;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tif (error.outputSize !== UNDEFINED_VALUE) {\n\t\t\t\twriter.size += error.outputSize;\n\t\t\t}\n\t\t\tthrow error;\n\t\t}\n\n\t}\n\tsetEntryInfo({\n\t\tsignature,\n\t\tcompressedSize,\n\t\tuncompressedSize,\n\t\theaderInfo,\n\t\tdataDescriptorInfo\n\t}, options);\n\tif (dataDescriptor) {\n\t\tawait writeData(writer, dataDescriptorArray);\n\t}\n\tObject.assign(fileEntry, {\n\t\tuncompressedSize,\n\t\tcompressedSize,\n\t\tlastModDate,\n\t\trawLastModDate,\n\t\tcreationDate,\n\t\tlastAccessDate,\n\t\tencrypted,\n\t\tzipCrypto,\n\t\tsize: metadataSize + compressedSize,\n\t\tcompressionMethod,\n\t\tversion,\n\t\theaderArray,\n\t\theaderView,\n\t\tsignature,\n\t\textraFieldExtendedTimestampFlag,\n\t\tzip64UncompressedSize,\n\t\tzip64CompressedSize,\n\t\tzip64Offset,\n\t\tzip64DiskNumberStart\n\t});\n\treturn fileEntry;\n}\n\nfunction getHeaderInfo(options) {\n\tconst {\n\t\trawFilename,\n\t\tlastModDate,\n\t\tlastAccessDate,\n\t\tcreationDate,\n\t\tlevel,\n\t\tzip64,\n\t\tzipCrypto,\n\t\tuseUnicodeFileNames,\n\t\tdataDescriptor,\n\t\tdirectory,\n\t\trawExtraField,\n\t\tencryptionStrength,\n\t\textendedTimestamp,\n\t\tpassThrough,\n\t\tencrypted,\n\t\tzip64UncompressedSize,\n\t\tzip64CompressedSize,\n\t\tzip64Offset,\n\t\tzip64DiskNumberStart,\n\t\tuncompressedSize,\n\t\toffset,\n\t\tdiskNumberStart\n\t} = options;\n\tlet { version, compressionMethod } = options;\n\tconst compressed = !directory && (level > 0 || (level === UNDEFINED_VALUE && compressionMethod !== 0));\n\tlet rawExtraFieldZip64;\n\tconst uncompressedFile = passThrough || !compressed;\n\tconst zip64ExtraFieldComplete = zip64 && (options.bufferedWrite || ((!zip64UncompressedSize && !zip64CompressedSize) || uncompressedFile));\n\tif (zip64) {\n\t\tlet rawExtraFieldZip64Length = 4;\n\t\tif (zip64UncompressedSize) {\n\t\t\trawExtraFieldZip64Length += 8;\n\t\t}\n\t\tif (zip64CompressedSize) {\n\t\t\trawExtraFieldZip64Length += 8;\n\t\t}\n\t\tif (zip64Offset) {\n\t\t\trawExtraFieldZip64Length += 8;\n\t\t}\n\t\tif (zip64DiskNumberStart) {\n\t\t\trawExtraFieldZip64Length += 4;\n\t\t}\n\t\trawExtraFieldZip64 = new Uint8Array(rawExtraFieldZip64Length);\n\t\tconst rawExtraFieldZip64View = getDataView(rawExtraFieldZip64);\n\t\tsetUint16(rawExtraFieldZip64View, 0, EXTRAFIELD_TYPE_ZIP64);\n\t\tsetUint16(rawExtraFieldZip64View, 2, getLength(rawExtraFieldZip64) - 4);\n\t\tif (zip64ExtraFieldComplete) {\n\t\t\tconst rawExtraFieldZip64View = getDataView(rawExtraFieldZip64);\n\t\t\tlet rawExtraFieldZip64Offset = 4;\n\t\t\tif (zip64UncompressedSize) {\n\t\t\t\tsetBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(uncompressedSize));\n\t\t\t\trawExtraFieldZip64Offset += 8;\n\t\t\t}\n\t\t\tif (zip64CompressedSize && uncompressedFile) {\n\t\t\t\tsetBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(uncompressedSize));\n\t\t\t\trawExtraFieldZip64Offset += 8;\n\t\t\t}\n\t\t\tif (zip64Offset) {\n\t\t\t\tsetBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(offset));\n\t\t\t\trawExtraFieldZip64Offset += 8;\n\t\t\t}\n\t\t\tif (zip64DiskNumberStart) {\n\t\t\t\tsetUint32(rawExtraFieldZip64View, rawExtraFieldZip64Offset, diskNumberStart);\n\t\t\t\trawExtraFieldZip64Offset += 4;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trawExtraFieldZip64 = new Uint8Array();\n\t}\n\tlet rawExtraFieldAES;\n\tif (encrypted && !zipCrypto) {\n\t\trawExtraFieldAES = new Uint8Array(getLength(EXTRAFIELD_DATA_AES) + 2);\n\t\tconst extraFieldAESView = getDataView(rawExtraFieldAES);\n\t\tsetUint16(extraFieldAESView, 0, EXTRAFIELD_TYPE_AES);\n\t\tarraySet(rawExtraFieldAES, EXTRAFIELD_DATA_AES, 2);\n\t\tsetUint8(extraFieldAESView, 8, encryptionStrength);\n\t} else {\n\t\trawExtraFieldAES = new Uint8Array();\n\t}\n\tlet rawExtraFieldNTFS;\n\tlet rawExtraFieldExtendedTimestamp;\n\tlet extraFieldExtendedTimestampFlag;\n\tif (extendedTimestamp) {\n\t\trawExtraFieldExtendedTimestamp = new Uint8Array(9 + (lastAccessDate ? 4 : 0) + (creationDate ? 4 : 0));\n\t\tconst extraFieldExtendedTimestampView = getDataView(rawExtraFieldExtendedTimestamp);\n\t\tsetUint16(extraFieldExtendedTimestampView, 0, EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);\n\t\tsetUint16(extraFieldExtendedTimestampView, 2, getLength(rawExtraFieldExtendedTimestamp) - 4);\n\t\textraFieldExtendedTimestampFlag = 0x1 + (lastAccessDate ? 0x2 : 0) + (creationDate ? 0x4 : 0);\n\t\tsetUint8(extraFieldExtendedTimestampView, 4, extraFieldExtendedTimestampFlag);\n\t\tlet offset = 5;\n\t\tsetUint32(extraFieldExtendedTimestampView, offset, Math.floor(lastModDate.getTime() / 1000));\n\t\toffset += 4;\n\t\tif (lastAccessDate) {\n\t\t\tsetUint32(extraFieldExtendedTimestampView, offset, Math.floor(lastAccessDate.getTime() / 1000));\n\t\t\toffset += 4;\n\t\t}\n\t\tif (creationDate) {\n\t\t\tsetUint32(extraFieldExtendedTimestampView, offset, Math.floor(creationDate.getTime() / 1000));\n\t\t}\n\t\ttry {\n\t\t\trawExtraFieldNTFS = new Uint8Array(36);\n\t\t\tconst extraFieldNTFSView = getDataView(rawExtraFieldNTFS);\n\t\t\tconst lastModTimeNTFS = getTimeNTFS(lastModDate);\n\t\t\tsetUint16(extraFieldNTFSView, 0, EXTRAFIELD_TYPE_NTFS);\n\t\t\tsetUint16(extraFieldNTFSView, 2, 32);\n\t\t\tsetUint16(extraFieldNTFSView, 8, EXTRAFIELD_TYPE_NTFS_TAG1);\n\t\t\tsetUint16(extraFieldNTFSView, 10, 24);\n\t\t\tsetBigUint64(extraFieldNTFSView, 12, lastModTimeNTFS);\n\t\t\tsetBigUint64(extraFieldNTFSView, 20, getTimeNTFS(lastAccessDate) || lastModTimeNTFS);\n\t\t\tsetBigUint64(extraFieldNTFSView, 28, getTimeNTFS(creationDate) || lastModTimeNTFS);\n\t\t} catch {\n\t\t\trawExtraFieldNTFS = new Uint8Array();\n\t\t}\n\t} else {\n\t\trawExtraFieldNTFS = rawExtraFieldExtendedTimestamp = new Uint8Array();\n\t}\n\tlet rawExtraFieldUnix;\n\ttry {\n\t\tconst { uid, gid, unixMode, setuid, setgid, sticky, unixExtraFieldType } = options;\n\t\tif (unixExtraFieldType && (uid !== UNDEFINED_VALUE || gid !== UNDEFINED_VALUE || unixMode !== UNDEFINED_VALUE)) {\n\t\t\tconst uidBytes = packUnixId(uid);\n\t\t\tconst gidBytes = packUnixId(gid);\n\t\t\tlet modeArray = new Uint8Array();\n\t\t\tif (unixExtraFieldType == UNIX_EXTRA_FIELD_TYPE && unixMode !== UNDEFINED_VALUE) {\n\t\t\t\tlet modeToWrite = unixMode & MAX_16_BITS;\n\t\t\t\tif (setuid) {\n\t\t\t\t\tmodeToWrite |= FILE_ATTR_UNIX_SETUID_MASK;\n\t\t\t\t}\n\t\t\t\tif (setgid) {\n\t\t\t\t\tmodeToWrite |= FILE_ATTR_UNIX_SETGID_MASK;\n\t\t\t\t}\n\t\t\t\tif (sticky) {\n\t\t\t\t\tmodeToWrite |= FILE_ATTR_UNIX_STICKY_MASK;\n\t\t\t\t}\n\t\t\t\tmodeArray = new Uint8Array(2);\n\t\t\t\tconst modeDataView = new DataView(modeArray.buffer);\n\t\t\t\tmodeDataView.setUint16(0, modeToWrite, true);\n\t\t\t}\n\t\t\tconst payloadLength = 3 + uidBytes.length + gidBytes.length + modeArray.length;\n\t\t\trawExtraFieldUnix = new Uint8Array(4 + payloadLength);\n\t\t\tconst rawExtraFieldUnixView = getDataView(rawExtraFieldUnix);\n\t\t\tsetUint16(rawExtraFieldUnixView, 0, unixExtraFieldType == INFOZIP_EXTRA_FIELD_TYPE ? EXTRAFIELD_TYPE_INFOZIP : EXTRAFIELD_TYPE_UNIX);\n\t\t\tsetUint16(rawExtraFieldUnixView, 2, payloadLength);\n\t\t\tsetUint8(rawExtraFieldUnixView, 4, 1);\n\t\t\tsetUint8(rawExtraFieldUnixView, 5, uidBytes.length);\n\t\t\tlet offset = 6;\n\t\t\tarraySet(rawExtraFieldUnix, uidBytes, offset);\n\t\t\toffset += uidBytes.length;\n\t\t\tsetUint8(rawExtraFieldUnixView, offset, gidBytes.length);\n\t\t\toffset++;\n\t\t\tarraySet(rawExtraFieldUnix, gidBytes, offset);\n\t\t\toffset += gidBytes.length;\n\t\t\tarraySet(rawExtraFieldUnix, modeArray, offset);\n\t\t} else {\n\t\t\trawExtraFieldUnix = new Uint8Array();\n\t\t}\n\t} catch {\n\t\trawExtraFieldUnix = new Uint8Array();\n\t}\n\tif (compressionMethod === UNDEFINED_VALUE) {\n\t\tcompressionMethod = compressed ? COMPRESSION_METHOD_DEFLATE : COMPRESSION_METHOD_STORE;\n\t}\n\tif (zip64) {\n\t\tversion = version > VERSION_ZIP64 ? version : VERSION_ZIP64;\n\t}\n\tif (encrypted && !zipCrypto) {\n\t\tversion = version > VERSION_AES ? version : VERSION_AES;\n\t\trawExtraFieldAES[9] = compressionMethod;\n\t\tcompressionMethod = COMPRESSION_METHOD_AES;\n\t}\n\tconst localExtraFieldZip64Length = zip64ExtraFieldComplete ? getLength(rawExtraFieldZip64) : 0;\n\tconst extraFieldLength = localExtraFieldZip64Length + getLength(rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS, rawExtraFieldUnix, rawExtraField);\n\tconst {\n\t\theaderArray,\n\t\theaderView,\n\t\trawLastModDate\n\t} = getHeaderArrayData({\n\t\tversion,\n\t\tbitFlag: getBitFlag(level, useUnicodeFileNames, dataDescriptor, encrypted, compressionMethod),\n\t\tcompressionMethod,\n\t\tuncompressedSize,\n\t\tlastModDate: lastModDate < MIN_DATE ? MIN_DATE : lastModDate > MAX_DATE ? MAX_DATE : lastModDate,\n\t\trawFilename,\n\t\tzip64CompressedSize,\n\t\tzip64UncompressedSize,\n\t\textraFieldLength\n\t});\n\tlet localHeaderOffset = HEADER_SIZE;\n\tconst localHeaderArray = new Uint8Array(localHeaderOffset + getLength(rawFilename) + extraFieldLength);\n\tconst localHeaderView = getDataView(localHeaderArray);\n\tsetUint32(localHeaderView, 0, LOCAL_FILE_HEADER_SIGNATURE);\n\tarraySet(localHeaderArray, headerArray, 4);\n\tarraySet(localHeaderArray, rawFilename, localHeaderOffset);\n\tlocalHeaderOffset += getLength(rawFilename);\n\tif (zip64ExtraFieldComplete) {\n\t\tarraySet(localHeaderArray, rawExtraFieldZip64, localHeaderOffset);\n\t}\n\tlocalHeaderOffset += localExtraFieldZip64Length;\n\tarraySet(localHeaderArray, rawExtraFieldAES, localHeaderOffset);\n\tlocalHeaderOffset += getLength(rawExtraFieldAES);\n\tarraySet(localHeaderArray, rawExtraFieldExtendedTimestamp, localHeaderOffset);\n\tlocalHeaderOffset += getLength(rawExtraFieldExtendedTimestamp);\n\tarraySet(localHeaderArray, rawExtraFieldNTFS, localHeaderOffset);\n\tlocalHeaderOffset += getLength(rawExtraFieldNTFS);\n\tarraySet(localHeaderArray, rawExtraFieldUnix, localHeaderOffset);\n\tlocalHeaderOffset += getLength(rawExtraFieldUnix);\n\tarraySet(localHeaderArray, rawExtraField, localHeaderOffset);\n\tif (dataDescriptor) {\n\t\tsetUint32(localHeaderView, HEADER_OFFSET_COMPRESSED_SIZE + 4, 0);\n\t\tsetUint32(localHeaderView, HEADER_OFFSET_UNCOMPRESSED_SIZE + 4, 0);\n\t}\n\treturn {\n\t\tlocalHeaderArray,\n\t\tlocalHeaderView,\n\t\theaderArray,\n\t\theaderView,\n\t\tlastModDate,\n\t\trawLastModDate,\n\t\tencrypted,\n\t\tcompressed,\n\t\tversion,\n\t\tcompressionMethod,\n\t\textraFieldExtendedTimestampFlag,\n\t\trawExtraFieldZip64,\n\t\tlocalExtraFieldZip64Length,\n\t\trawExtraFieldExtendedTimestamp,\n\t\trawExtraFieldNTFS,\n\t\trawExtraFieldUnix,\n\t\trawExtraFieldAES,\n\t\textraFieldLength\n\t};\n}\n\nfunction appendExtraFieldUSDZ(entryInfo, zipWriterOffset) {\n\tconst { headerInfo } = entryInfo;\n\tlet { localHeaderArray, extraFieldLength } = headerInfo;\n\tlet localHeaderArrayView = getDataView(localHeaderArray);\n\tlet extraBytesLength = 64 - ((zipWriterOffset + getLength(localHeaderArray)) % 64);\n\tif (extraBytesLength < 4) {\n\t\textraBytesLength += 64;\n\t}\n\tconst rawExtraFieldUSDZ = new Uint8Array(extraBytesLength);\n\tconst extraFieldUSDZView = getDataView(rawExtraFieldUSDZ);\n\tsetUint16(extraFieldUSDZView, 0, EXTRAFIELD_TYPE_USDZ);\n\tsetUint16(extraFieldUSDZView, 2, extraBytesLength - 2);\n\tconst previousLocalHeaderArray = localHeaderArray;\n\theaderInfo.localHeaderArray = localHeaderArray = new Uint8Array(getLength(previousLocalHeaderArray) + extraBytesLength);\n\tarraySet(localHeaderArray, previousLocalHeaderArray);\n\tarraySet(localHeaderArray, rawExtraFieldUSDZ, getLength(previousLocalHeaderArray));\n\tlocalHeaderArrayView = getDataView(localHeaderArray);\n\tsetUint16(localHeaderArrayView, 28, extraFieldLength + extraBytesLength);\n\tentryInfo.metadataSize += extraBytesLength;\n}\n\nfunction packUnixId(id) {\n\tif (id === UNDEFINED_VALUE) {\n\t\treturn new Uint8Array();\n\t} else {\n\t\tconst dataArray = new Uint8Array(4);\n\t\tconst dataView = getDataView(dataArray);\n\t\tdataView.setUint32(0, id, true);\n\t\tlet length = 4;\n\t\twhile (length > 1 && dataArray[length - 1] === 0) {\n\t\t\tlength--;\n\t\t}\n\t\treturn dataArray.subarray(0, length);\n\t}\n}\n\nfunction normalizeMsdosAttributes(msdosAttributesRaw, msdosAttributes) {\n\tif (msdosAttributesRaw !== UNDEFINED_VALUE) {\n\t\tmsdosAttributesRaw = msdosAttributesRaw & MAX_8_BITS;\n\t} else if (msdosAttributes !== UNDEFINED_VALUE) {\n\t\tconst { readOnly, hidden, system, directory: msdDir, archive } = msdosAttributes;\n\t\tlet raw = 0;\n\t\tif (readOnly) raw |= FILE_ATTR_MSDOS_READONLY_MASK;\n\t\tif (hidden) raw |= FILE_ATTR_MSDOS_HIDDEN_MASK;\n\t\tif (system) raw |= FILE_ATTR_MSDOS_SYSTEM_MASK;\n\t\tif (msdDir) raw |= FILE_ATTR_MSDOS_DIR_MASK;\n\t\tif (archive) raw |= FILE_ATTR_MSDOS_ARCHIVE_MASK;\n\t\tmsdosAttributesRaw = raw & MAX_8_BITS;\n\t}\n\tif (msdosAttributes === UNDEFINED_VALUE) {\n\t\tmsdosAttributes = {\n\t\t\treadOnly: Boolean(msdosAttributesRaw & FILE_ATTR_MSDOS_READONLY_MASK),\n\t\t\thidden: Boolean(msdosAttributesRaw & FILE_ATTR_MSDOS_HIDDEN_MASK),\n\t\t\tsystem: Boolean(msdosAttributesRaw & FILE_ATTR_MSDOS_SYSTEM_MASK),\n\t\t\tdirectory: Boolean(msdosAttributesRaw & FILE_ATTR_MSDOS_DIR_MASK),\n\t\t\tarchive: Boolean(msdosAttributesRaw & FILE_ATTR_MSDOS_ARCHIVE_MASK)\n\t\t};\n\t}\n\treturn { msdosAttributesRaw, msdosAttributes };\n}\n\nfunction getDataDescriptorInfo({\n\tzip64,\n\tdataDescriptor,\n\tdataDescriptorSignature\n}) {\n\tlet dataDescriptorArray = new Uint8Array();\n\tlet dataDescriptorView, dataDescriptorOffset = 0;\n\tlet dataDescriptorLength = zip64 ? DATA_DESCRIPTOR_RECORD_ZIP_64_LENGTH : DATA_DESCRIPTOR_RECORD_LENGTH;\n\tif (dataDescriptorSignature) {\n\t\tdataDescriptorLength += DATA_DESCRIPTOR_RECORD_SIGNATURE_LENGTH;\n\t}\n\tif (dataDescriptor) {\n\t\tdataDescriptorArray = new Uint8Array(dataDescriptorLength);\n\t\tdataDescriptorView = getDataView(dataDescriptorArray);\n\t\tif (dataDescriptorSignature) {\n\t\t\tdataDescriptorOffset = DATA_DESCRIPTOR_RECORD_SIGNATURE_LENGTH;\n\t\t\tsetUint32(dataDescriptorView, 0, DATA_DESCRIPTOR_RECORD_SIGNATURE);\n\t\t}\n\t}\n\treturn {\n\t\tdataDescriptorArray,\n\t\tdataDescriptorView,\n\t\tdataDescriptorOffset\n\t};\n}\n\nfunction setEntryInfo({\n\tsignature,\n\tcompressedSize,\n\tuncompressedSize,\n\theaderInfo,\n\tdataDescriptorInfo\n}, {\n\tzip64,\n\tzipCrypto,\n\tdataDescriptor\n}) {\n\tconst {\n\t\theaderView,\n\t\tencrypted\n\t} = headerInfo;\n\tconst {\n\t\tdataDescriptorView,\n\t\tdataDescriptorOffset\n\t} = dataDescriptorInfo;\n\tif ((!encrypted || zipCrypto) && signature !== UNDEFINED_VALUE) {\n\t\tsetUint32(headerView, HEADER_OFFSET_SIGNATURE, signature);\n\t\tif (dataDescriptor) {\n\t\t\tsetUint32(dataDescriptorView, dataDescriptorOffset, signature);\n\t\t}\n\t}\n\tif (zip64) {\n\t\tif (dataDescriptor) {\n\t\t\tsetBigUint64(dataDescriptorView, dataDescriptorOffset + 4, BigInt(compressedSize));\n\t\t\tsetBigUint64(dataDescriptorView, dataDescriptorOffset + 12, BigInt(uncompressedSize));\n\t\t}\n\t} else {\n\t\tsetUint32(headerView, HEADER_OFFSET_COMPRESSED_SIZE, compressedSize);\n\t\tsetUint32(headerView, HEADER_OFFSET_UNCOMPRESSED_SIZE, uncompressedSize);\n\t\tif (dataDescriptor) {\n\t\t\tsetUint32(dataDescriptorView, dataDescriptorOffset + 4, compressedSize);\n\t\t\tsetUint32(dataDescriptorView, dataDescriptorOffset + 8, uncompressedSize);\n\t\t}\n\t}\n}\n\nfunction updateLocalHeader({\n\trawFilename,\n\tencrypted,\n\tzip64,\n\tlocalExtraFieldZip64Length,\n\tsignature,\n\tcompressedSize,\n\tuncompressedSize,\n\toffset,\n\tdiskNumberStart,\n\tzip64UncompressedSize,\n\tzip64CompressedSize,\n\tzip64Offset,\n\tzip64DiskNumberStart\n}, localHeaderView, { dataDescriptor }) {\n\tif (!dataDescriptor) {\n\t\tif (!encrypted) {\n\t\t\tsetUint32(localHeaderView, HEADER_OFFSET_SIGNATURE + 4, signature);\n\t\t}\n\t\tif (!zip64) {\n\t\t\tsetUint32(localHeaderView, HEADER_OFFSET_COMPRESSED_SIZE + 4, compressedSize);\n\t\t\tsetUint32(localHeaderView, HEADER_OFFSET_UNCOMPRESSED_SIZE + 4, uncompressedSize);\n\t\t}\n\t}\n\tif (zip64) {\n\t\tif (localExtraFieldZip64Length) {\n\t\t\tlet localHeaderOffset = HEADER_SIZE + getLength(rawFilename) + 4;\n\t\t\tif (zip64UncompressedSize) {\n\t\t\t\tsetBigUint64(localHeaderView, localHeaderOffset, BigInt(uncompressedSize));\n\t\t\t\tlocalHeaderOffset += 8;\n\t\t\t}\n\t\t\tif (zip64CompressedSize) {\n\t\t\t\tsetBigUint64(localHeaderView, localHeaderOffset, BigInt(compressedSize));\n\t\t\t\tlocalHeaderOffset += 8;\n\t\t\t}\n\t\t\tif (zip64Offset) {\n\t\t\t\tsetBigUint64(localHeaderView, localHeaderOffset, BigInt(offset));\n\t\t\t\tlocalHeaderOffset += 8;\n\t\t\t}\n\t\t\tif (zip64DiskNumberStart) {\n\t\t\t\tsetUint32(localHeaderView, localHeaderOffset, diskNumberStart);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction updateZip64ExtraField({\n\tcompressedSize,\n\tuncompressedSize,\n\toffset,\n\tdiskNumberStart,\n\tzip64UncompressedSize,\n\tzip64CompressedSize,\n\tzip64Offset,\n\tzip64DiskNumberStart,\n\trawExtraFieldZip64\n}) {\n\tconst rawExtraFieldZip64View = getDataView(rawExtraFieldZip64);\n\tlet rawExtraFieldZip64Offset = 4;\n\tif (zip64UncompressedSize) {\n\t\tsetBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(uncompressedSize));\n\t\trawExtraFieldZip64Offset += 8;\n\t}\n\tif (zip64CompressedSize) {\n\t\tsetBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(compressedSize));\n\t\trawExtraFieldZip64Offset += 8;\n\t}\n\tif (zip64Offset) {\n\t\tsetBigUint64(rawExtraFieldZip64View, rawExtraFieldZip64Offset, BigInt(offset));\n\t\trawExtraFieldZip64Offset += 8;\n\t}\n\tif (zip64DiskNumberStart) {\n\t\tsetUint32(rawExtraFieldZip64View, rawExtraFieldZip64Offset, diskNumberStart);\n\t}\n}\n\nasync function closeFile(zipWriter, comment, options) {\n\tconst { files, writer } = zipWriter;\n\tconst { diskOffset } = writer;\n\tlet { diskNumber } = writer;\n\tlet offset = 0;\n\tlet directoryDataLength = 0;\n\tlet directoryOffset = zipWriter.offset - diskOffset;\n\tlet filesLength = files.size;\n\tfor (const [, fileEntry] of files) {\n\t\tconst {\n\t\t\trawFilename,\n\t\t\trawExtraFieldZip64,\n\t\t\trawExtraFieldAES,\n\t\t\trawComment,\n\t\t\trawExtraFieldNTFS,\n\t\t\trawExtraFieldUnix,\n\t\t\trawExtraField,\n\t\t\textendedTimestamp,\n\t\t\textraFieldExtendedTimestampFlag,\n\t\t\tlastModDate\n\t\t} = fileEntry;\n\t\tlet rawExtraFieldTimestamp;\n\t\tif (extendedTimestamp) {\n\t\t\trawExtraFieldTimestamp = new Uint8Array(9);\n\t\t\tconst extraFieldExtendedTimestampView = getDataView(rawExtraFieldTimestamp);\n\t\t\tsetUint16(extraFieldExtendedTimestampView, 0, EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);\n\t\t\tsetUint16(extraFieldExtendedTimestampView, 2, 5);\n\t\t\tsetUint8(extraFieldExtendedTimestampView, 4, extraFieldExtendedTimestampFlag);\n\t\t\tsetUint32(extraFieldExtendedTimestampView, 5, Math.floor(lastModDate.getTime() / 1000));\n\t\t} else {\n\t\t\trawExtraFieldTimestamp = new Uint8Array();\n\t\t}\n\t\tfileEntry.rawExtraFieldExtendedTimestamp = rawExtraFieldTimestamp;\n\t\tdirectoryDataLength += 46 +\n\t\t\tgetLength(\n\t\t\t\trawFilename,\n\t\t\t\trawComment,\n\t\t\t\trawExtraFieldZip64,\n\t\t\t\trawExtraFieldAES,\n\t\t\t\trawExtraFieldNTFS,\n\t\t\t\trawExtraFieldUnix,\n\t\t\t\trawExtraFieldTimestamp,\n\t\t\t\trawExtraField);\n\t}\n\tconst directoryArray = new Uint8Array(directoryDataLength);\n\tconst directoryView = getDataView(directoryArray);\n\tawait initStream(writer);\n\tlet directoryDiskOffset = 0;\n\tfor (const [indexFileEntry, fileEntry] of Array.from(files.values()).entries()) {\n\t\tconst {\n\t\t\toffset: fileEntryOffset,\n\t\t\trawFilename,\n\t\t\trawExtraFieldZip64,\n\t\t\trawExtraFieldAES,\n\t\t\trawExtraFieldExtendedTimestamp,\n\t\t\trawExtraFieldNTFS,\n\t\t\trawExtraFieldUnix,\n\t\t\trawExtraField,\n\t\t\trawComment,\n\t\t\tversionMadeBy,\n\t\t\theaderArray,\n\t\t\theaderView,\n\t\t\tzip64,\n\t\t\tzip64UncompressedSize,\n\t\t\tzip64CompressedSize,\n\t\t\tzip64DiskNumberStart,\n\t\t\tzip64Offset,\n\t\t\tinternalFileAttributes,\n\t\t\texternalFileAttributes,\n\t\t\tdiskNumberStart,\n\t\t\tuncompressedSize,\n\t\t\tcompressedSize\n\t\t} = fileEntry;\n\t\tconst extraFieldLength = getLength(rawExtraFieldZip64, rawExtraFieldAES, rawExtraFieldExtendedTimestamp, rawExtraFieldNTFS, rawExtraFieldUnix, rawExtraField);\n\t\tsetUint32(directoryView, offset, CENTRAL_FILE_HEADER_SIGNATURE);\n\t\tsetUint16(directoryView, offset + 4, versionMadeBy);\n\t\tif (!zip64UncompressedSize) {\n\t\t\tsetUint32(headerView, HEADER_OFFSET_UNCOMPRESSED_SIZE, uncompressedSize);\n\t\t}\n\t\tif (!zip64CompressedSize) {\n\t\t\tsetUint32(headerView, HEADER_OFFSET_COMPRESSED_SIZE, compressedSize);\n\t\t}\n\t\tarraySet(directoryArray, headerArray, offset + 6);\n\t\tlet directoryOffset = offset + HEADER_SIZE;\n\t\tsetUint16(directoryView, directoryOffset, extraFieldLength);\n\t\tdirectoryOffset += 2;\n\t\tsetUint16(directoryView, directoryOffset, getLength(rawComment));\n\t\tdirectoryOffset += 2;\n\t\tsetUint16(directoryView, directoryOffset, zip64 && zip64DiskNumberStart ? MAX_16_BITS : diskNumberStart);\n\t\tdirectoryOffset += 2;\n\t\tsetUint16(directoryView, directoryOffset, internalFileAttributes);\n\t\tdirectoryOffset += 2;\n\t\tif (externalFileAttributes) {\n\t\t\tsetUint32(directoryView, directoryOffset, externalFileAttributes);\n\t\t}\n\t\tdirectoryOffset += 4;\n\t\tsetUint32(directoryView, directoryOffset, zip64 && zip64Offset ? MAX_32_BITS : fileEntryOffset);\n\t\tdirectoryOffset += 4;\n\t\tarraySet(directoryArray, rawFilename, directoryOffset);\n\t\tdirectoryOffset += getLength(rawFilename);\n\t\tarraySet(directoryArray, rawExtraFieldZip64, directoryOffset);\n\t\tdirectoryOffset += getLength(rawExtraFieldZip64);\n\t\tarraySet(directoryArray, rawExtraFieldAES, directoryOffset);\n\t\tdirectoryOffset += getLength(rawExtraFieldAES);\n\t\tarraySet(directoryArray, rawExtraFieldExtendedTimestamp, directoryOffset);\n\t\tdirectoryOffset += getLength(rawExtraFieldExtendedTimestamp);\n\t\tarraySet(directoryArray, rawExtraFieldNTFS, directoryOffset);\n\t\tdirectoryOffset += getLength(rawExtraFieldNTFS);\n\t\tarraySet(directoryArray, rawExtraFieldUnix, directoryOffset);\n\t\tdirectoryOffset += getLength(rawExtraFieldUnix);\n\t\tarraySet(directoryArray, rawExtraField, directoryOffset);\n\t\tdirectoryOffset += getLength(rawExtraField);\n\t\tarraySet(directoryArray, rawComment, directoryOffset);\n\t\tdirectoryOffset += getLength(rawComment);\n\t\tif (offset - directoryDiskOffset > writer.availableSize) {\n\t\t\twriter.availableSize = 0;\n\t\t\tawait writeData(writer, directoryArray.slice(directoryDiskOffset, offset));\n\t\t\tdirectoryDiskOffset = offset;\n\t\t}\n\t\toffset = directoryOffset;\n\t\tif (options.onprogress) {\n\t\t\ttry {\n\t\t\t\tawait options.onprogress(indexFileEntry + 1, files.size, new Entry(fileEntry));\n\t\t\t} catch {\n\t\t\t\t// ignored\n\t\t\t}\n\t\t}\n\t}\n\tawait writeData(writer, directoryDiskOffset ? directoryArray.slice(directoryDiskOffset) : directoryArray);\n\tlet lastDiskNumber = writer.diskNumber;\n\tconst { availableSize } = writer;\n\tif (availableSize < END_OF_CENTRAL_DIR_LENGTH) {\n\t\tlastDiskNumber++;\n\t}\n\tlet zip64 = getOptionValue(zipWriter, options, PROPERTY_NAME_ZIP64);\n\tif (directoryOffset > MAX_32_BITS || directoryDataLength > MAX_32_BITS || filesLength > MAX_16_BITS || lastDiskNumber > MAX_16_BITS) {\n\t\tif (zip64 === false) {\n\t\t\tthrow new Error(ERR_UNSUPPORTED_FORMAT);\n\t\t} else {\n\t\t\tzip64 = true;\n\t\t}\n\t}\n\tconst endOfdirectoryArray = new Uint8Array(zip64 ? ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH : END_OF_CENTRAL_DIR_LENGTH);\n\tconst endOfdirectoryView = getDataView(endOfdirectoryArray);\n\toffset = 0;\n\tif (zip64) {\n\t\tsetUint32(endOfdirectoryView, 0, ZIP64_END_OF_CENTRAL_DIR_SIGNATURE);\n\t\tsetBigUint64(endOfdirectoryView, 4, BigInt(44));\n\t\tsetUint16(endOfdirectoryView, 12, 45);\n\t\tsetUint16(endOfdirectoryView, 14, 45);\n\t\tsetUint32(endOfdirectoryView, 16, lastDiskNumber);\n\t\tsetUint32(endOfdirectoryView, 20, diskNumber);\n\t\tsetBigUint64(endOfdirectoryView, 24, BigInt(filesLength));\n\t\tsetBigUint64(endOfdirectoryView, 32, BigInt(filesLength));\n\t\tsetBigUint64(endOfdirectoryView, 40, BigInt(directoryDataLength));\n\t\tsetBigUint64(endOfdirectoryView, 48, BigInt(directoryOffset));\n\t\tsetUint32(endOfdirectoryView, 56, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE);\n\t\tsetBigUint64(endOfdirectoryView, 64, BigInt(directoryOffset) + BigInt(directoryDataLength));\n\t\tsetUint32(endOfdirectoryView, 72, lastDiskNumber + 1);\n\t\tconst supportZip64SplitFile = getOptionValue(zipWriter, options, OPTION_SUPPORT_ZIP64_SPLIT_FILE, true);\n\t\tif (supportZip64SplitFile) {\n\t\t\tlastDiskNumber = MAX_16_BITS;\n\t\t\tdiskNumber = MAX_16_BITS;\n\t\t}\n\t\tfilesLength = MAX_16_BITS;\n\t\tdirectoryOffset = MAX_32_BITS;\n\t\tdirectoryDataLength = MAX_32_BITS;\n\t\toffset += ZIP64_END_OF_CENTRAL_DIR_LENGTH + ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH;\n\t}\n\tsetUint32(endOfdirectoryView, offset, END_OF_CENTRAL_DIR_SIGNATURE);\n\tsetUint16(endOfdirectoryView, offset + 4, lastDiskNumber);\n\tsetUint16(endOfdirectoryView, offset + 6, diskNumber);\n\tsetUint16(endOfdirectoryView, offset + 8, filesLength);\n\tsetUint16(endOfdirectoryView, offset + 10, filesLength);\n\tsetUint32(endOfdirectoryView, offset + 12, directoryDataLength);\n\tsetUint32(endOfdirectoryView, offset + 16, directoryOffset);\n\tconst commentLength = getLength(comment);\n\tif (commentLength) {\n\t\tif (commentLength <= MAX_16_BITS) {\n\t\t\tsetUint16(endOfdirectoryView, offset + 20, commentLength);\n\t\t} else {\n\t\t\tthrow new Error(ERR_INVALID_COMMENT);\n\t\t}\n\t}\n\tawait writeData(writer, endOfdirectoryArray);\n\tif (commentLength) {\n\t\tawait writeData(writer, comment);\n\t}\n}\n\nasync function writeData(writer, array) {\n\tconst { writable } = writer;\n\tconst streamWriter = writable.getWriter();\n\ttry {\n\t\tawait streamWriter.ready;\n\t\twriter.size += getLength(array);\n\t\tawait streamWriter.write(array);\n\t} finally {\n\t\tstreamWriter.releaseLock();\n\t}\n}\n\nfunction getTimeNTFS(date) {\n\tif (date) {\n\t\treturn ((BigInt(date.getTime()) + BigInt(11644473600000)) * BigInt(10000));\n\t}\n}\n\nfunction getOptionValue(zipWriter, options, name, defaultValue) {\n\tconst result = options[name] === UNDEFINED_VALUE ? zipWriter.options[name] : options[name];\n\treturn result === UNDEFINED_VALUE ? defaultValue : result;\n}\n\nfunction getMaximumCompressedSize(uncompressedSize) {\n\treturn uncompressedSize + (5 * (Math.floor(uncompressedSize / 16383) + 1));\n}\n\nfunction setUint8(view, offset, value) {\n\tview.setUint8(offset, value);\n}\n\nfunction setUint16(view, offset, value) {\n\tview.setUint16(offset, value, true);\n}\n\nfunction setUint32(view, offset, value) {\n\tview.setUint32(offset, value, true);\n}\n\nfunction setBigUint64(view, offset, value) {\n\tview.setBigUint64(offset, value, true);\n}\n\nfunction arraySet(array, typedArray, offset) {\n\tarray.set(typedArray, offset);\n}\n\nfunction getDataView(array) {\n\treturn new DataView(array.buffer);\n}\n\nfunction getLength(...arrayLikes) {\n\tlet result = 0;\n\tarrayLikes.forEach(arrayLike => arrayLike && (result += arrayLike.length));\n\treturn result;\n}\n\nfunction getHeaderArrayData({\n\tversion,\n\tbitFlag,\n\tcompressionMethod,\n\tuncompressedSize,\n\tcompressedSize,\n\tlastModDate,\n\trawFilename,\n\tzip64CompressedSize,\n\tzip64UncompressedSize,\n\textraFieldLength\n}) {\n\tconst headerArray = new Uint8Array(HEADER_SIZE - 4);\n\tconst headerView = getDataView(headerArray);\n\tsetUint16(headerView, 0, version);\n\tsetUint16(headerView, 2, bitFlag);\n\tsetUint16(headerView, 4, compressionMethod);\n\tconst dateArray = new Uint32Array(1);\n\tconst dateView = getDataView(dateArray);\n\tsetUint16(dateView, 0, (((lastModDate.getHours() << 6) | lastModDate.getMinutes()) << 5) | lastModDate.getSeconds() / 2);\n\tsetUint16(dateView, 2, ((((lastModDate.getFullYear() - 1980) << 4) | (lastModDate.getMonth() + 1)) << 5) | lastModDate.getDate());\n\tconst rawLastModDate = dateArray[0];\n\tsetUint32(headerView, 6, rawLastModDate);\n\tif (zip64CompressedSize || compressedSize !== UNDEFINED_VALUE) {\n\t\tsetUint32(headerView, HEADER_OFFSET_COMPRESSED_SIZE, zip64CompressedSize ? MAX_32_BITS : compressedSize);\n\t}\n\tif (zip64UncompressedSize || uncompressedSize !== UNDEFINED_VALUE) {\n\t\tsetUint32(headerView, HEADER_OFFSET_UNCOMPRESSED_SIZE, zip64UncompressedSize ? MAX_32_BITS : uncompressedSize);\n\t}\n\tsetUint16(headerView, 22, getLength(rawFilename));\n\tsetUint16(headerView, 24, extraFieldLength);\n\treturn {\n\t\theaderArray,\n\t\theaderView,\n\t\trawLastModDate\n\t};\n}\n\nfunction getBitFlag(level, useUnicodeFileNames, dataDescriptor, encrypted, compressionMethod) {\n\tlet bitFlag = 0;\n\tif (useUnicodeFileNames) {\n\t\tbitFlag = bitFlag | BITFLAG_LANG_ENCODING_FLAG;\n\t}\n\tif (dataDescriptor) {\n\t\tbitFlag = bitFlag | BITFLAG_DATA_DESCRIPTOR;\n\t}\n\tif (compressionMethod == COMPRESSION_METHOD_DEFLATE || compressionMethod == COMPRESSION_METHOD_DEFLATE_64) {\n\t\tif (level >= 0 && level <= 3) {\n\t\t\tbitFlag = bitFlag | BITFLAG_LEVEL_SUPER_FAST_MASK;\n\t\t}\n\t\tif (level > 3 && level <= 5) {\n\t\t\tbitFlag = bitFlag | BITFLAG_LEVEL_FAST_MASK;\n\t\t}\n\t\tif (level == 9) {\n\t\t\tbitFlag = bitFlag | BITFLAG_LEVEL_MAX_MASK;\n\t\t}\n\t}\n\tif (encrypted) {\n\t\tbitFlag = bitFlag | BITFLAG_ENCRYPTED;\n\t}\n\treturn bitFlag;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}