{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Visibility from \"../Core/Visibility.js\";\nimport QuadtreeOccluders from \"./QuadtreeOccluders.js\";\nimport QuadtreeTile from \"./QuadtreeTile.js\";\nimport QuadtreeTileLoadState from \"./QuadtreeTileLoadState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport TileReplacementQueue from \"./TileReplacementQueue.js\";\nimport TileSelectionResult from \"./TileSelectionResult.js\";\n\n/**\n * Renders massive sets of data by utilizing level-of-detail and culling.  The globe surface is divided into\n * a quadtree of tiles with large, low-detail tiles at the root and small, high-detail tiles at the leaves.\n * The set of tiles to render is selected by projecting an estimate of the geometric error in a tile onto\n * the screen to estimate screen-space error, in pixels, which must be below a user-specified threshold.\n * The actual content of the tiles is arbitrary and is specified using a {@link QuadtreeTileProvider}.\n *\n * @alias QuadtreePrimitive\n * @constructor\n * @private\n *\n * @param {QuadtreeTileProvider} options.tileProvider The tile provider that loads, renders, and estimates\n *        the distance to individual tiles.\n * @param {number} [options.maximumScreenSpaceError=2] The maximum screen-space error, in pixels, that is allowed.\n *        A higher maximum error will render fewer tiles and improve performance, while a lower\n *        value will improve visual quality.\n * @param {number} [options.tileCacheSize=100] The maximum number of tiles that will be retained in the tile cache.\n *        Note that tiles will never be unloaded if they were used for rendering the last\n *        frame, so the actual number of resident tiles may be higher.  The value of\n *        this property will not affect visual quality.\n */\nfunction QuadtreePrimitive(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.tileProvider)) {\n    throw new DeveloperError(\"options.tileProvider is required.\");\n  }\n  if (defined(options.tileProvider.quadtree)) {\n    throw new DeveloperError(\"A QuadtreeTileProvider can only be used with a single QuadtreePrimitive\");\n  }\n  //>>includeEnd('debug');\n\n  this._tileProvider = options.tileProvider;\n  this._tileProvider.quadtree = this;\n  this._debug = {\n    enableDebugOutput: false,\n    maxDepth: 0,\n    maxDepthVisited: 0,\n    tilesVisited: 0,\n    tilesCulled: 0,\n    tilesRendered: 0,\n    tilesWaitingForChildren: 0,\n    lastMaxDepth: -1,\n    lastMaxDepthVisited: -1,\n    lastTilesVisited: -1,\n    lastTilesCulled: -1,\n    lastTilesRendered: -1,\n    lastTilesWaitingForChildren: -1,\n    suspendLodUpdate: false\n  };\n  const tilingScheme = this._tileProvider.tilingScheme;\n  const ellipsoid = tilingScheme.ellipsoid;\n  this._tilesToRender = [];\n  this._tileLoadQueueHigh = []; // high priority tiles are preventing refinement\n  this._tileLoadQueueMedium = []; // medium priority tiles are being rendered\n  this._tileLoadQueueLow = []; // low priority tiles were refined past or are non-visible parts of quads.\n  this._tileReplacementQueue = new TileReplacementQueue();\n  this._levelZeroTiles = undefined;\n  this._loadQueueTimeSlice = 5.0;\n  this._tilesInvalidated = false;\n  this._addHeightCallbacks = [];\n  this._removeHeightCallbacks = [];\n  this._tileToUpdateHeights = [];\n  this._lastTileIndex = 0;\n  this._updateHeightsTimeSlice = 2.0;\n\n  // If a culled tile contains _cameraPositionCartographic or _cameraReferenceFrameOriginCartographic, it will be marked\n  // TileSelectionResult.CULLED_BUT_NEEDED and added to the list of tiles to update heights,\n  // even though it is not rendered.\n  // These are updated each frame in `selectTilesForRendering`.\n  this._cameraPositionCartographic = undefined;\n  this._cameraReferenceFrameOriginCartographic = undefined;\n\n  /**\n   * Gets or sets the maximum screen-space error, in pixels, that is allowed.\n   * A higher maximum error will render fewer tiles and improve performance, while a lower\n   * value will improve visual quality.\n   * @type {number}\n   * @default 2\n   */\n  this.maximumScreenSpaceError = options.maximumScreenSpaceError ?? 2;\n\n  /**\n   * Gets or sets the maximum number of tiles that will be retained in the tile cache.\n   * Note that tiles will never be unloaded if they were used for rendering the last\n   * frame, so the actual number of resident tiles may be higher.  The value of\n   * this property will not affect visual quality.\n   * @type {number}\n   * @default 100\n   */\n  this.tileCacheSize = options.tileCacheSize ?? 100;\n\n  /**\n   * Gets or sets the number of loading descendant tiles that is considered \"too many\".\n   * If a tile has too many loading descendants, that tile will be loaded and rendered before any of\n   * its descendants are loaded and rendered. This means more feedback for the user that something\n   * is happening at the cost of a longer overall load time. Setting this to 0 will cause each\n   * tile level to be loaded successively, significantly increasing load time. Setting it to a large\n   * number (e.g. 1000) will minimize the number of tiles that are loaded but tend to make\n   * detail appear all at once after a long wait.\n   * @type {number}\n   * @default 20\n   */\n  this.loadingDescendantLimit = 20;\n\n  /**\n   * Gets or sets a value indicating whether the ancestors of rendered tiles should be preloaded.\n   * Setting this to true optimizes the zoom-out experience and provides more detail in\n   * newly-exposed areas when panning. The down side is that it requires loading more tiles.\n   * @type {boolean}\n   * @default true\n   */\n  this.preloadAncestors = true;\n\n  /**\n   * Gets or sets a value indicating whether the siblings of rendered tiles should be preloaded.\n   * Setting this to true causes tiles with the same parent as a rendered tile to be loaded, even\n   * if they are culled. Setting this to true may provide a better panning experience at the\n   * cost of loading more tiles.\n   * @type {boolean}\n   * @default false\n   */\n  this.preloadSiblings = false;\n  this._occluders = new QuadtreeOccluders({\n    ellipsoid: ellipsoid\n  });\n  this._tileLoadProgressEvent = new Event();\n  this._lastTileLoadQueueLength = 0;\n  this._lastSelectionFrameNumber = undefined;\n}\nObject.defineProperties(QuadtreePrimitive.prototype, {\n  /**\n   * Gets the provider of {@link QuadtreeTile} instances for this quadtree.\n   * @type {QuadtreeTile}\n   * @memberof QuadtreePrimitive.prototype\n   */\n  tileProvider: {\n    get: function () {\n      return this._tileProvider;\n    }\n  },\n  /**\n   * Gets an event that's raised when the length of the tile load queue has changed since the last render frame.  When the load queue is empty,\n   * all terrain and imagery for the current view have been loaded.  The event passes the new length of the tile load queue.\n   *\n   * @memberof QuadtreePrimitive.prototype\n   * @type {Event}\n   */\n  tileLoadProgressEvent: {\n    get: function () {\n      return this._tileLoadProgressEvent;\n    }\n  },\n  occluders: {\n    get: function () {\n      return this._occluders;\n    }\n  }\n});\n\n/**\n * Invalidates and frees all the tiles in the quadtree.  The tiles must be reloaded\n * before they can be displayed.\n *\n * @memberof QuadtreePrimitive\n */\nQuadtreePrimitive.prototype.invalidateAllTiles = function () {\n  this._tilesInvalidated = true;\n};\nfunction invalidateAllTiles(primitive) {\n  // Clear the replacement queue\n  const replacementQueue = primitive._tileReplacementQueue;\n  replacementQueue.head = undefined;\n  replacementQueue.tail = undefined;\n  replacementQueue.count = 0;\n  clearTileLoadQueue(primitive);\n\n  // Free and recreate the level zero tiles.\n  const levelZeroTiles = primitive._levelZeroTiles;\n  if (defined(levelZeroTiles)) {\n    for (let i = 0; i < levelZeroTiles.length; ++i) {\n      const tile = levelZeroTiles[i];\n      const customData = tile.customData;\n      const customDataLength = customData.length;\n      for (let j = 0; j < customDataLength; ++j) {\n        const data = customData[j];\n        data.level = 0;\n        primitive._addHeightCallbacks.push(data);\n      }\n      levelZeroTiles[i].freeResources();\n    }\n  }\n  primitive._levelZeroTiles = undefined;\n  primitive._tileProvider.cancelReprojections();\n}\n\n/**\n * Invokes a specified function for each {@link QuadtreeTile} that is partially\n * or completely loaded.\n *\n * @param {Function} tileFunction The function to invoke for each loaded tile.  The\n *        function is passed a reference to the tile as its only parameter.\n */\nQuadtreePrimitive.prototype.forEachLoadedTile = function (tileFunction) {\n  let tile = this._tileReplacementQueue.head;\n  while (defined(tile)) {\n    if (tile.state !== QuadtreeTileLoadState.START) {\n      tileFunction(tile);\n    }\n    tile = tile.replacementNext;\n  }\n};\n\n/**\n * Invokes a specified function for each {@link QuadtreeTile} that was rendered\n * in the most recent frame.\n *\n * @param {Function} tileFunction The function to invoke for each rendered tile.  The\n *        function is passed a reference to the tile as its only parameter.\n */\nQuadtreePrimitive.prototype.forEachRenderedTile = function (tileFunction) {\n  const tilesRendered = this._tilesToRender;\n  for (let i = 0, len = tilesRendered.length; i < len; ++i) {\n    tileFunction(tilesRendered[i]);\n  }\n};\n\n/**\n * Calls the callback when a new tile is rendered that contains the given cartographic. The only parameter\n * is the cartesian position on the tile.\n *\n * @param {Cartographic} cartographic The cartographic position.\n * @param {Function} callback The function to be called when a new tile is loaded containing the updated cartographic.\n * @returns {Function} The function to remove this callback from the quadtree.\n */\nQuadtreePrimitive.prototype.updateHeight = function (cartographic, callback) {\n  const primitive = this;\n  const object = {\n    positionOnEllipsoidSurface: undefined,\n    positionCartographic: cartographic,\n    level: -1,\n    callback: callback\n  };\n  object.removeFunc = function () {\n    const addedCallbacks = primitive._addHeightCallbacks;\n    const length = addedCallbacks.length;\n    for (let i = 0; i < length; ++i) {\n      if (addedCallbacks[i] === object) {\n        addedCallbacks.splice(i, 1);\n        break;\n      }\n    }\n    primitive._removeHeightCallbacks.push(object);\n    if (object.callback) {\n      object.callback = undefined;\n    }\n  };\n  primitive._addHeightCallbacks.push(object);\n  return object.removeFunc;\n};\n\n/**\n * Updates the tile provider imagery and continues to process the tile load queue.\n * @private\n */\nQuadtreePrimitive.prototype.update = function (frameState) {\n  if (defined(this._tileProvider.update)) {\n    this._tileProvider.update(frameState);\n  }\n};\nfunction clearTileLoadQueue(primitive) {\n  const debug = primitive._debug;\n  debug.maxDepth = 0;\n  debug.maxDepthVisited = 0;\n  debug.tilesVisited = 0;\n  debug.tilesCulled = 0;\n  debug.tilesRendered = 0;\n  debug.tilesWaitingForChildren = 0;\n  primitive._tileLoadQueueHigh.length = 0;\n  primitive._tileLoadQueueMedium.length = 0;\n  primitive._tileLoadQueueLow.length = 0;\n}\n\n/**\n * Initializes values for a new render frame and prepare the tile load queue.\n * @private\n */\nQuadtreePrimitive.prototype.beginFrame = function (frameState) {\n  const passes = frameState.passes;\n  if (!passes.render) {\n    return;\n  }\n  if (this._tilesInvalidated) {\n    invalidateAllTiles(this);\n    this._tilesInvalidated = false;\n  }\n\n  // Gets commands for any texture re-projections\n  this._tileProvider.initialize(frameState);\n  clearTileLoadQueue(this);\n  if (this._debug.suspendLodUpdate) {\n    return;\n  }\n  this._tileReplacementQueue.markStartOfRenderFrame();\n};\n\n/**\n * Selects new tiles to load based on the frame state and creates render commands.\n * @private\n */\nQuadtreePrimitive.prototype.render = function (frameState) {\n  const passes = frameState.passes;\n  const tileProvider = this._tileProvider;\n  if (passes.render) {\n    tileProvider.beginUpdate(frameState);\n    selectTilesForRendering(this, frameState);\n    createRenderCommandsForSelectedTiles(this, frameState);\n    tileProvider.endUpdate(frameState);\n  }\n  if (passes.pick && this._tilesToRender.length > 0) {\n    tileProvider.updateForPick(frameState);\n  }\n};\n\n/**\n * Checks if the load queue length has changed since the last time we raised a queue change event - if so, raises\n * a new change event at the end of the render cycle.\n * @private\n */\nfunction updateTileLoadProgress(primitive, frameState) {\n  const currentLoadQueueLength = primitive._tileLoadQueueHigh.length + primitive._tileLoadQueueMedium.length + primitive._tileLoadQueueLow.length;\n  if (currentLoadQueueLength !== primitive._lastTileLoadQueueLength || primitive._tilesInvalidated) {\n    const raiseEvent = Event.prototype.raiseEvent.bind(primitive._tileLoadProgressEvent, currentLoadQueueLength);\n    frameState.afterRender.push(() => {\n      raiseEvent();\n      return true;\n    });\n    primitive._lastTileLoadQueueLength = currentLoadQueueLength;\n  }\n  const debug = primitive._debug;\n  if (debug.enableDebugOutput && !debug.suspendLodUpdate) {\n    debug.maxDepth = primitive._tilesToRender.reduce(function (max, tile) {\n      return Math.max(max, tile.level);\n    }, -1);\n    debug.tilesRendered = primitive._tilesToRender.length;\n    if (debug.tilesVisited !== debug.lastTilesVisited || debug.tilesRendered !== debug.lastTilesRendered || debug.tilesCulled !== debug.lastTilesCulled || debug.maxDepth !== debug.lastMaxDepth || debug.tilesWaitingForChildren !== debug.lastTilesWaitingForChildren || debug.maxDepthVisited !== debug.lastMaxDepthVisited) {\n      console.log(`Visited ${debug.tilesVisited}, Rendered: ${debug.tilesRendered}, Culled: ${debug.tilesCulled}, Max Depth Rendered: ${debug.maxDepth}, Max Depth Visited: ${debug.maxDepthVisited}, Waiting for children: ${debug.tilesWaitingForChildren}`);\n      debug.lastTilesVisited = debug.tilesVisited;\n      debug.lastTilesRendered = debug.tilesRendered;\n      debug.lastTilesCulled = debug.tilesCulled;\n      debug.lastMaxDepth = debug.maxDepth;\n      debug.lastTilesWaitingForChildren = debug.tilesWaitingForChildren;\n      debug.lastMaxDepthVisited = debug.maxDepthVisited;\n    }\n  }\n}\n\n/**\n * Updates terrain heights.\n * @private\n */\nQuadtreePrimitive.prototype.endFrame = function (frameState) {\n  const passes = frameState.passes;\n  if (!passes.render || frameState.mode === SceneMode.MORPHING) {\n    // Only process the load queue for a single pass.\n    // Don't process the load queue or update heights during the morph flights.\n    return;\n  }\n\n  // Load/create resources for terrain and imagery. Prepare texture re-projections for the next frame.\n  processTileLoadQueue(this, frameState);\n  updateHeights(this, frameState);\n  updateTileLoadProgress(this, frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @memberof QuadtreePrimitive\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n *\n * @see QuadtreePrimitive#destroy\n */\nQuadtreePrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @memberof QuadtreePrimitive\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * primitive = primitive && primitive.destroy();\n *\n * @see QuadtreePrimitive#isDestroyed\n */\nQuadtreePrimitive.prototype.destroy = function () {\n  this._tileProvider = this._tileProvider && this._tileProvider.destroy();\n};\nlet comparisonPoint;\nconst centerScratch = new Cartographic();\nfunction compareDistanceToPoint(a, b) {\n  let center = Rectangle.center(a.rectangle, centerScratch);\n  const alon = center.longitude - comparisonPoint.longitude;\n  const alat = center.latitude - comparisonPoint.latitude;\n  center = Rectangle.center(b.rectangle, centerScratch);\n  const blon = center.longitude - comparisonPoint.longitude;\n  const blat = center.latitude - comparisonPoint.latitude;\n  return alon * alon + alat * alat - (blon * blon + blat * blat);\n}\nconst cameraOriginScratch = new Cartesian3();\nlet rootTraversalDetails = [];\nfunction selectTilesForRendering(primitive, frameState) {\n  const debug = primitive._debug;\n  if (debug.suspendLodUpdate) {\n    return;\n  }\n\n  // Clear the render list.\n  const tilesToRender = primitive._tilesToRender;\n  tilesToRender.length = 0;\n\n  // We can't render anything before the level zero tiles exist.\n  let i;\n  const tileProvider = primitive._tileProvider;\n  if (!defined(primitive._levelZeroTiles)) {\n    const tilingScheme = tileProvider.tilingScheme;\n    if (defined(tilingScheme)) {\n      const tilingScheme = tileProvider.tilingScheme;\n      primitive._levelZeroTiles = QuadtreeTile.createLevelZeroTiles(tilingScheme);\n      const numberOfRootTiles = primitive._levelZeroTiles.length;\n      if (rootTraversalDetails.length < numberOfRootTiles) {\n        rootTraversalDetails = new Array(numberOfRootTiles);\n        for (i = 0; i < numberOfRootTiles; ++i) {\n          if (rootTraversalDetails[i] === undefined) {\n            rootTraversalDetails[i] = new TraversalDetails();\n          }\n        }\n      }\n    } else {\n      return;\n    }\n  }\n  primitive._occluders.ellipsoid.cameraPosition = frameState.camera.positionWC;\n  let tile;\n  const levelZeroTiles = primitive._levelZeroTiles;\n  const occluders = levelZeroTiles.length > 1 ? primitive._occluders : undefined;\n\n  // Sort the level zero tiles by the distance from the center to the camera.\n  // The level zero tiles aren't necessarily a nice neat quad, so we can't use the\n  // quadtree ordering we use elsewhere in the tree\n  comparisonPoint = frameState.camera.positionCartographic;\n  levelZeroTiles.sort(compareDistanceToPoint);\n  const customDataAdded = primitive._addHeightCallbacks;\n  const customDataRemoved = primitive._removeHeightCallbacks;\n  const frameNumber = frameState.frameNumber;\n  let len;\n  if (customDataAdded.length > 0 || customDataRemoved.length > 0) {\n    for (i = 0, len = levelZeroTiles.length; i < len; ++i) {\n      tile = levelZeroTiles[i];\n      tile._updateCustomData(frameNumber, customDataAdded, customDataRemoved);\n    }\n    customDataAdded.length = 0;\n    customDataRemoved.length = 0;\n  }\n  const camera = frameState.camera;\n  primitive._cameraPositionCartographic = camera.positionCartographic;\n  const cameraFrameOrigin = Matrix4.getTranslation(camera.transform, cameraOriginScratch);\n  primitive._cameraReferenceFrameOriginCartographic = primitive.tileProvider.tilingScheme.ellipsoid.cartesianToCartographic(cameraFrameOrigin, primitive._cameraReferenceFrameOriginCartographic);\n\n  // Traverse in depth-first, near-to-far order.\n  for (i = 0, len = levelZeroTiles.length; i < len; ++i) {\n    tile = levelZeroTiles[i];\n    primitive._tileReplacementQueue.markTileRendered(tile);\n    if (!tile.renderable) {\n      queueTileLoad(primitive, primitive._tileLoadQueueHigh, tile, frameState);\n      ++debug.tilesWaitingForChildren;\n    } else {\n      visitIfVisible(primitive, tile, tileProvider, frameState, occluders, false, rootTraversalDetails[i]);\n    }\n  }\n  primitive._lastSelectionFrameNumber = frameNumber;\n}\nfunction queueTileLoad(primitive, queue, tile, frameState) {\n  if (!tile.needsLoading) {\n    return;\n  }\n  if (primitive.tileProvider.computeTileLoadPriority !== undefined) {\n    tile._loadPriority = primitive.tileProvider.computeTileLoadPriority(tile, frameState);\n  }\n  queue.push(tile);\n}\n\n/**\n * Tracks details of traversing a tile while selecting tiles for rendering.\n * @alias TraversalDetails\n * @constructor\n * @private\n */\nfunction TraversalDetails() {\n  /**\n   * True if all selected (i.e. not culled or refined) tiles in this tile's subtree\n   * are renderable. If the subtree is renderable, we'll render it; no drama.\n   */\n  this.allAreRenderable = true;\n\n  /**\n   * True if any tiles in this tile's subtree were rendered last frame. If any\n   * were, we must render the subtree rather than this tile, because rendering\n   * this tile would cause detail to vanish that was visible last frame, and\n   * that's no good.\n   */\n  this.anyWereRenderedLastFrame = false;\n\n  /**\n   * Counts the number of selected tiles in this tile's subtree that are\n   * not yet ready to be rendered because they need more loading. Note that\n   * this value will _not_ necessarily be zero when\n   * {@link TraversalDetails#allAreRenderable} is true, for subtle reasons.\n   * When {@link TraversalDetails#allAreRenderable} and\n   * {@link TraversalDetails#anyWereRenderedLastFrame} are both false, we\n   * will render this tile instead of any tiles in its subtree and\n   * the `allAreRenderable` value for this tile will reflect only whether _this_\n   * tile is renderable. The `notYetRenderableCount` value, however, will still\n   * reflect the total number of tiles that we are waiting on, including the\n   * ones that we're not rendering. `notYetRenderableCount` is only reset\n   * when a subtree is removed from the render queue because the\n   * `notYetRenderableCount` exceeds the\n   * {@link QuadtreePrimitive#loadingDescendantLimit}.\n   */\n  this.notYetRenderableCount = 0;\n}\nfunction TraversalQuadDetails() {\n  this.southwest = new TraversalDetails();\n  this.southeast = new TraversalDetails();\n  this.northwest = new TraversalDetails();\n  this.northeast = new TraversalDetails();\n}\nTraversalQuadDetails.prototype.combine = function (result) {\n  const southwest = this.southwest;\n  const southeast = this.southeast;\n  const northwest = this.northwest;\n  const northeast = this.northeast;\n  result.allAreRenderable = southwest.allAreRenderable && southeast.allAreRenderable && northwest.allAreRenderable && northeast.allAreRenderable;\n  result.anyWereRenderedLastFrame = southwest.anyWereRenderedLastFrame || southeast.anyWereRenderedLastFrame || northwest.anyWereRenderedLastFrame || northeast.anyWereRenderedLastFrame;\n  result.notYetRenderableCount = southwest.notYetRenderableCount + southeast.notYetRenderableCount + northwest.notYetRenderableCount + northeast.notYetRenderableCount;\n};\nconst traversalQuadsByLevel = new Array(31); // level 30 tiles are ~2cm wide at the equator, should be good enough.\nfor (let i = 0; i < traversalQuadsByLevel.length; ++i) {\n  traversalQuadsByLevel[i] = new TraversalQuadDetails();\n}\n\n/**\n * Visits a tile for possible rendering. When we call this function with a tile:\n *\n *    * the tile has been determined to be visible (possibly based on a bounding volume that is not very tight-fitting)\n *    * its parent tile does _not_ meet the SSE (unless ancestorMeetsSse=true, see comments below)\n *    * the tile may or may not be renderable\n *\n * @private\n *\n * @param {Primitive} primitive The QuadtreePrimitive.\n * @param {FrameState} frameState The frame state.\n * @param {QuadtreeTile} tile The tile to visit\n * @param {boolean} ancestorMeetsSse True if a tile higher in the tile tree already met the SSE and we're refining further only\n *                  to maintain detail while that higher tile loads.\n * @param {TraversalDetails} traveralDetails On return, populated with details of how the traversal of this tile went.\n */\nfunction visitTile(primitive, frameState, tile, ancestorMeetsSse, traversalDetails) {\n  const debug = primitive._debug;\n  ++debug.tilesVisited;\n  primitive._tileReplacementQueue.markTileRendered(tile);\n  tile._updateCustomData(frameState.frameNumber);\n  if (tile.level > debug.maxDepthVisited) {\n    debug.maxDepthVisited = tile.level;\n  }\n  const meetsSse = screenSpaceError(primitive, frameState, tile) < primitive.maximumScreenSpaceError;\n  const southwestChild = tile.southwestChild;\n  const southeastChild = tile.southeastChild;\n  const northwestChild = tile.northwestChild;\n  const northeastChild = tile.northeastChild;\n  const lastFrame = primitive._lastSelectionFrameNumber;\n  const lastFrameSelectionResult = tile._lastSelectionResultFrame === lastFrame ? tile._lastSelectionResult : TileSelectionResult.NONE;\n  const tileProvider = primitive.tileProvider;\n  if (meetsSse || ancestorMeetsSse) {\n    // This tile (or an ancestor) is the one we want to render this frame, but we'll do different things depending\n    // on the state of this tile and on what we did _last_ frame.\n\n    // We can render it if _any_ of the following are true:\n    // 1. We rendered it (or kicked it) last frame.\n    // 2. This tile was culled last frame, or it wasn't even visited because an ancestor was culled.\n    // 3. The tile is completely done loading.\n    // 4. a) Terrain is ready, and\n    //    b) All necessary imagery is ready. Necessary imagery is imagery that was rendered with this tile\n    //       or any descendants last frame. Such imagery is required because rendering this tile without\n    //       it would cause detail to disappear.\n    //\n    // Determining condition 4 is more expensive, so we check the others first.\n    //\n    // Note that even if we decide to render a tile here, it may later get \"kicked\" in favor of an ancestor.\n\n    const oneRenderedLastFrame = TileSelectionResult.originalResult(lastFrameSelectionResult) === TileSelectionResult.RENDERED;\n    const twoCulledOrNotVisited = TileSelectionResult.originalResult(lastFrameSelectionResult) === TileSelectionResult.CULLED || lastFrameSelectionResult === TileSelectionResult.NONE;\n    const threeCompletelyLoaded = tile.state === QuadtreeTileLoadState.DONE;\n    let renderable = oneRenderedLastFrame || twoCulledOrNotVisited || threeCompletelyLoaded;\n    if (!renderable) {\n      // Check the more expensive condition 4 above. This requires details of the thing\n      // we're rendering (e.g. the globe surface), so delegate it to the tile provider.\n      if (defined(tileProvider.canRenderWithoutLosingDetail)) {\n        renderable = tileProvider.canRenderWithoutLosingDetail(tile);\n      }\n    }\n    if (renderable) {\n      // Only load this tile if it (not just an ancestor) meets the SSE.\n      if (meetsSse) {\n        queueTileLoad(primitive, primitive._tileLoadQueueMedium, tile, frameState);\n      }\n      addTileToRenderList(primitive, tile);\n      traversalDetails.allAreRenderable = tile.renderable;\n      traversalDetails.anyWereRenderedLastFrame = lastFrameSelectionResult === TileSelectionResult.RENDERED;\n      traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;\n      tile._lastSelectionResultFrame = frameState.frameNumber;\n      tile._lastSelectionResult = TileSelectionResult.RENDERED;\n      if (!traversalDetails.anyWereRenderedLastFrame) {\n        // Tile is newly-rendered this frame, so update its heights.\n        primitive._tileToUpdateHeights.push(tile);\n      }\n      return;\n    }\n\n    // Otherwise, we can't render this tile (or its fill) because doing so would cause detail to disappear\n    // that was visible last frame. Instead, keep rendering any still-visible descendants that were rendered\n    // last frame and render fills for newly-visible descendants. E.g. if we were rendering level 15 last\n    // frame but this frame we want level 14 and the closest renderable level <= 14 is 0, rendering level\n    // zero would be pretty jarring so instead we keep rendering level 15 even though its SSE is better\n    // than required. So fall through to continue traversal...\n    ancestorMeetsSse = true;\n\n    // Load this blocker tile with high priority, but only if this tile (not just an ancestor) meets the SSE.\n    if (meetsSse) {\n      queueTileLoad(primitive, primitive._tileLoadQueueHigh, tile, frameState);\n    }\n  }\n  if (tileProvider.canRefine(tile)) {\n    const allAreUpsampled = southwestChild.upsampledFromParent && southeastChild.upsampledFromParent && northwestChild.upsampledFromParent && northeastChild.upsampledFromParent;\n    if (allAreUpsampled) {\n      // No point in rendering the children because they're all upsampled.  Render this tile instead.\n      addTileToRenderList(primitive, tile);\n\n      // Rendered tile that's not waiting on children loads with medium priority.\n      queueTileLoad(primitive, primitive._tileLoadQueueMedium, tile, frameState);\n\n      // Make sure we don't unload the children and forget they're upsampled.\n      primitive._tileReplacementQueue.markTileRendered(southwestChild);\n      primitive._tileReplacementQueue.markTileRendered(southeastChild);\n      primitive._tileReplacementQueue.markTileRendered(northwestChild);\n      primitive._tileReplacementQueue.markTileRendered(northeastChild);\n      traversalDetails.allAreRenderable = tile.renderable;\n      traversalDetails.anyWereRenderedLastFrame = lastFrameSelectionResult === TileSelectionResult.RENDERED;\n      traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;\n      tile._lastSelectionResultFrame = frameState.frameNumber;\n      tile._lastSelectionResult = TileSelectionResult.RENDERED;\n      if (!traversalDetails.anyWereRenderedLastFrame) {\n        // Tile is newly-rendered this frame, so update its heights.\n        primitive._tileToUpdateHeights.push(tile);\n      }\n      return;\n    }\n\n    // SSE is not good enough, so refine.\n    tile._lastSelectionResultFrame = frameState.frameNumber;\n    tile._lastSelectionResult = TileSelectionResult.REFINED;\n    const firstRenderedDescendantIndex = primitive._tilesToRender.length;\n    const loadIndexLow = primitive._tileLoadQueueLow.length;\n    const loadIndexMedium = primitive._tileLoadQueueMedium.length;\n    const loadIndexHigh = primitive._tileLoadQueueHigh.length;\n    const tilesToUpdateHeightsIndex = primitive._tileToUpdateHeights.length;\n\n    // No need to add the children to the load queue because they'll be added (if necessary) when they're visited.\n    visitVisibleChildrenNearToFar(primitive, southwestChild, southeastChild, northwestChild, northeastChild, frameState, ancestorMeetsSse, traversalDetails);\n\n    // If no descendant tiles were added to the render list by the function above, it means they were all\n    // culled even though this tile was deemed visible. That's pretty common.\n\n    if (firstRenderedDescendantIndex !== primitive._tilesToRender.length) {\n      // At least one descendant tile was added to the render list.\n      // The traversalDetails tell us what happened while visiting the children.\n\n      const allAreRenderable = traversalDetails.allAreRenderable;\n      const anyWereRenderedLastFrame = traversalDetails.anyWereRenderedLastFrame;\n      const notYetRenderableCount = traversalDetails.notYetRenderableCount;\n      let queuedForLoad = false;\n      if (!allAreRenderable && !anyWereRenderedLastFrame) {\n        // Some of our descendants aren't ready to render yet, and none were rendered last frame,\n        // so kick them all out of the render list and render this tile instead. Continue to load them though!\n\n        // Mark the rendered descendants and their ancestors - up to this tile - as kicked.\n        const renderList = primitive._tilesToRender;\n        for (let i = firstRenderedDescendantIndex; i < renderList.length; ++i) {\n          let workTile = renderList[i];\n          while (workTile !== undefined && workTile._lastSelectionResult !== TileSelectionResult.KICKED && workTile !== tile) {\n            workTile._lastSelectionResult = TileSelectionResult.kick(workTile._lastSelectionResult);\n            workTile = workTile.parent;\n          }\n        }\n\n        // Remove all descendants from the render list and add this tile.\n        primitive._tilesToRender.length = firstRenderedDescendantIndex;\n        primitive._tileToUpdateHeights.length = tilesToUpdateHeightsIndex;\n        addTileToRenderList(primitive, tile);\n        tile._lastSelectionResult = TileSelectionResult.RENDERED;\n\n        // If we're waiting on heaps of descendants, the above will take too long. So in that case,\n        // load this tile INSTEAD of loading any of the descendants, and tell the up-level we're only waiting\n        // on this tile. Keep doing this until we actually manage to render this tile.\n        const wasRenderedLastFrame = lastFrameSelectionResult === TileSelectionResult.RENDERED;\n        if (!wasRenderedLastFrame && notYetRenderableCount > primitive.loadingDescendantLimit) {\n          // Remove all descendants from the load queues.\n          primitive._tileLoadQueueLow.length = loadIndexLow;\n          primitive._tileLoadQueueMedium.length = loadIndexMedium;\n          primitive._tileLoadQueueHigh.length = loadIndexHigh;\n          queueTileLoad(primitive, primitive._tileLoadQueueMedium, tile, frameState);\n          traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;\n          queuedForLoad = true;\n        }\n        traversalDetails.allAreRenderable = tile.renderable;\n        traversalDetails.anyWereRenderedLastFrame = wasRenderedLastFrame;\n        if (!wasRenderedLastFrame) {\n          // Tile is newly-rendered this frame, so update its heights.\n          primitive._tileToUpdateHeights.push(tile);\n        }\n        ++debug.tilesWaitingForChildren;\n      }\n      if (primitive.preloadAncestors && !queuedForLoad) {\n        queueTileLoad(primitive, primitive._tileLoadQueueLow, tile, frameState);\n      }\n    }\n    return;\n  }\n  tile._lastSelectionResultFrame = frameState.frameNumber;\n  tile._lastSelectionResult = TileSelectionResult.RENDERED;\n\n  // We'd like to refine but can't because we have no availability data for this tile's children,\n  // so we have no idea if refinining would involve a load or an upsample. We'll have to finish\n  // loading this tile first in order to find that out, so load this refinement blocker with\n  // high priority.\n  addTileToRenderList(primitive, tile);\n  queueTileLoad(primitive, primitive._tileLoadQueueHigh, tile, frameState);\n  traversalDetails.allAreRenderable = tile.renderable;\n  traversalDetails.anyWereRenderedLastFrame = lastFrameSelectionResult === TileSelectionResult.RENDERED;\n  traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;\n}\nfunction visitVisibleChildrenNearToFar(primitive, southwest, southeast, northwest, northeast, frameState, ancestorMeetsSse, traversalDetails) {\n  const cameraPosition = frameState.camera.positionCartographic;\n  const tileProvider = primitive._tileProvider;\n  const occluders = primitive._occluders;\n  const quadDetails = traversalQuadsByLevel[southwest.level];\n  const southwestDetails = quadDetails.southwest;\n  const southeastDetails = quadDetails.southeast;\n  const northwestDetails = quadDetails.northwest;\n  const northeastDetails = quadDetails.northeast;\n  if (cameraPosition.longitude < southwest.rectangle.east) {\n    if (cameraPosition.latitude < southwest.rectangle.north) {\n      // Camera in southwest quadrant\n      visitIfVisible(primitive, southwest, tileProvider, frameState, occluders, ancestorMeetsSse, southwestDetails);\n      visitIfVisible(primitive, southeast, tileProvider, frameState, occluders, ancestorMeetsSse, southeastDetails);\n      visitIfVisible(primitive, northwest, tileProvider, frameState, occluders, ancestorMeetsSse, northwestDetails);\n      visitIfVisible(primitive, northeast, tileProvider, frameState, occluders, ancestorMeetsSse, northeastDetails);\n    } else {\n      // Camera in northwest quadrant\n      visitIfVisible(primitive, northwest, tileProvider, frameState, occluders, ancestorMeetsSse, northwestDetails);\n      visitIfVisible(primitive, southwest, tileProvider, frameState, occluders, ancestorMeetsSse, southwestDetails);\n      visitIfVisible(primitive, northeast, tileProvider, frameState, occluders, ancestorMeetsSse, northeastDetails);\n      visitIfVisible(primitive, southeast, tileProvider, frameState, occluders, ancestorMeetsSse, southeastDetails);\n    }\n  } else if (cameraPosition.latitude < southwest.rectangle.north) {\n    // Camera southeast quadrant\n    visitIfVisible(primitive, southeast, tileProvider, frameState, occluders, ancestorMeetsSse, southeastDetails);\n    visitIfVisible(primitive, southwest, tileProvider, frameState, occluders, ancestorMeetsSse, southwestDetails);\n    visitIfVisible(primitive, northeast, tileProvider, frameState, occluders, ancestorMeetsSse, northeastDetails);\n    visitIfVisible(primitive, northwest, tileProvider, frameState, occluders, ancestorMeetsSse, northwestDetails);\n  } else {\n    // Camera in northeast quadrant\n    visitIfVisible(primitive, northeast, tileProvider, frameState, occluders, ancestorMeetsSse, northeastDetails);\n    visitIfVisible(primitive, northwest, tileProvider, frameState, occluders, ancestorMeetsSse, northwestDetails);\n    visitIfVisible(primitive, southeast, tileProvider, frameState, occluders, ancestorMeetsSse, southeastDetails);\n    visitIfVisible(primitive, southwest, tileProvider, frameState, occluders, ancestorMeetsSse, southwestDetails);\n  }\n  quadDetails.combine(traversalDetails);\n}\nfunction containsNeededPosition(primitive, tile) {\n  const rectangle = tile.rectangle;\n  return defined(primitive._cameraPositionCartographic) && Rectangle.contains(rectangle, primitive._cameraPositionCartographic) || defined(primitive._cameraReferenceFrameOriginCartographic) && Rectangle.contains(rectangle, primitive._cameraReferenceFrameOriginCartographic);\n}\nfunction visitIfVisible(primitive, tile, tileProvider, frameState, occluders, ancestorMeetsSse, traversalDetails) {\n  if (tileProvider.computeTileVisibility(tile, frameState, occluders) !== Visibility.NONE) {\n    return visitTile(primitive, frameState, tile, ancestorMeetsSse, traversalDetails);\n  }\n  ++primitive._debug.tilesCulled;\n  primitive._tileReplacementQueue.markTileRendered(tile);\n  traversalDetails.allAreRenderable = true;\n  traversalDetails.anyWereRenderedLastFrame = false;\n  traversalDetails.notYetRenderableCount = 0;\n  if (containsNeededPosition(primitive, tile)) {\n    // Load the tile(s) that contains the camera's position and\n    // the origin of its reference frame with medium priority.\n    // But we only need to load until the terrain is available, no need to load imagery.\n    if (!defined(tile.data) || !defined(tile.data.vertexArray)) {\n      queueTileLoad(primitive, primitive._tileLoadQueueMedium, tile, frameState);\n    }\n    const lastFrame = primitive._lastSelectionFrameNumber;\n    const lastFrameSelectionResult = tile._lastSelectionResultFrame === lastFrame ? tile._lastSelectionResult : TileSelectionResult.NONE;\n    if (lastFrameSelectionResult !== TileSelectionResult.CULLED_BUT_NEEDED && lastFrameSelectionResult !== TileSelectionResult.RENDERED) {\n      primitive._tileToUpdateHeights.push(tile);\n    }\n    tile._lastSelectionResult = TileSelectionResult.CULLED_BUT_NEEDED;\n  } else if (primitive.preloadSiblings || tile.level === 0) {\n    // Load culled level zero tiles with low priority.\n    // For all other levels, only load culled tiles if preloadSiblings is enabled.\n    queueTileLoad(primitive, primitive._tileLoadQueueLow, tile, frameState);\n    tile._lastSelectionResult = TileSelectionResult.CULLED;\n  } else {\n    tile._lastSelectionResult = TileSelectionResult.CULLED;\n  }\n  tile._lastSelectionResultFrame = frameState.frameNumber;\n}\nfunction screenSpaceError(primitive, frameState, tile) {\n  if (frameState.mode === SceneMode.SCENE2D || frameState.camera.frustum instanceof OrthographicFrustum || frameState.camera.frustum instanceof OrthographicOffCenterFrustum) {\n    return screenSpaceError2D(primitive, frameState, tile);\n  }\n  const maxGeometricError = primitive._tileProvider.getLevelMaximumGeometricError(tile.level);\n  const distance = tile._distance;\n  const height = frameState.context.drawingBufferHeight;\n  const sseDenominator = frameState.camera.frustum.sseDenominator;\n  let error = maxGeometricError * height / (distance * sseDenominator);\n  if (frameState.fog.enabled) {\n    error -= CesiumMath.fog(distance, frameState.fog.density) * frameState.fog.sse;\n  }\n  error /= frameState.pixelRatio;\n  return error;\n}\nfunction screenSpaceError2D(primitive, frameState, tile) {\n  const camera = frameState.camera;\n  let frustum = camera.frustum;\n  const offCenterFrustum = frustum.offCenterFrustum;\n  if (defined(offCenterFrustum)) {\n    frustum = offCenterFrustum;\n  }\n  const context = frameState.context;\n  const width = context.drawingBufferWidth;\n  const height = context.drawingBufferHeight;\n  const maxGeometricError = primitive._tileProvider.getLevelMaximumGeometricError(tile.level);\n  const pixelSize = Math.max(frustum.top - frustum.bottom, frustum.right - frustum.left) / Math.max(width, height);\n  let error = maxGeometricError / pixelSize;\n  if (frameState.fog.enabled && frameState.mode !== SceneMode.SCENE2D) {\n    error -= CesiumMath.fog(tile._distance, frameState.fog.density) * frameState.fog.sse;\n  }\n  error /= frameState.pixelRatio;\n  return error;\n}\nfunction addTileToRenderList(primitive, tile) {\n  primitive._tilesToRender.push(tile);\n}\nfunction processTileLoadQueue(primitive, frameState) {\n  const tileLoadQueueHigh = primitive._tileLoadQueueHigh;\n  const tileLoadQueueMedium = primitive._tileLoadQueueMedium;\n  const tileLoadQueueLow = primitive._tileLoadQueueLow;\n  if (tileLoadQueueHigh.length === 0 && tileLoadQueueMedium.length === 0 && tileLoadQueueLow.length === 0) {\n    return;\n  }\n\n  // Remove any tiles that were not used this frame beyond the number\n  // we're allowed to keep.\n  primitive._tileReplacementQueue.trimTiles(primitive.tileCacheSize);\n  const endTime = getTimestamp() + primitive._loadQueueTimeSlice;\n  const tileProvider = primitive._tileProvider;\n  let didSomeLoading = processSinglePriorityLoadQueue(primitive, frameState, tileProvider, endTime, tileLoadQueueHigh, false);\n  didSomeLoading = processSinglePriorityLoadQueue(primitive, frameState, tileProvider, endTime, tileLoadQueueMedium, didSomeLoading);\n  processSinglePriorityLoadQueue(primitive, frameState, tileProvider, endTime, tileLoadQueueLow, didSomeLoading);\n}\nfunction sortByLoadPriority(a, b) {\n  return a._loadPriority - b._loadPriority;\n}\nfunction processSinglePriorityLoadQueue(primitive, frameState, tileProvider, endTime, loadQueue, didSomeLoading) {\n  if (tileProvider.computeTileLoadPriority !== undefined) {\n    loadQueue.sort(sortByLoadPriority);\n  }\n  for (let i = 0, len = loadQueue.length; i < len && (getTimestamp() < endTime || !didSomeLoading); ++i) {\n    const tile = loadQueue[i];\n    primitive._tileReplacementQueue.markTileRendered(tile);\n    tileProvider.loadTile(frameState, tile);\n    didSomeLoading = true;\n  }\n  return didSomeLoading;\n}\nconst scratchRay = new Ray();\nconst scratchCartographic = new Cartographic();\nconst scratchPosition = new Cartesian3();\nconst scratchArray = [];\nfunction updateHeights(primitive, frameState) {\n  if (!defined(primitive.tileProvider.tilingScheme)) {\n    return;\n  }\n  const tryNextFrame = scratchArray;\n  tryNextFrame.length = 0;\n  const tilesToUpdateHeights = primitive._tileToUpdateHeights;\n  const startTime = getTimestamp();\n  const timeSlice = primitive._updateHeightsTimeSlice;\n  const endTime = startTime + timeSlice;\n  const mode = frameState.mode;\n  const projection = frameState.mapProjection;\n  const ellipsoid = primitive.tileProvider.tilingScheme.ellipsoid;\n  let i;\n  while (tilesToUpdateHeights.length > 0) {\n    const tile = tilesToUpdateHeights[0];\n    if (!defined(tile.data) || !defined(tile.data.mesh)) {\n      // Tile isn't loaded enough yet, so try again next frame if this tile is still\n      // being rendered.\n      const selectionResult = tile._lastSelectionResultFrame === primitive._lastSelectionFrameNumber ? tile._lastSelectionResult : TileSelectionResult.NONE;\n      if (selectionResult === TileSelectionResult.RENDERED || selectionResult === TileSelectionResult.CULLED_BUT_NEEDED) {\n        tryNextFrame.push(tile);\n      }\n      // Ensure stale position cache is cleared\n      tile.clearPositionCache();\n      tilesToUpdateHeights.shift();\n      primitive._lastTileIndex = 0;\n      continue;\n    }\n    const customData = tile.customData;\n    const customDataLength = customData.length;\n    let timeSliceMax = false;\n    for (i = primitive._lastTileIndex; i < customDataLength; ++i) {\n      const data = customData[i];\n\n      // No need to run this code when the tile is upsampled, because the height will be the same as its parent.\n      const terrainData = tile.data.terrainData;\n      const upsampledGeometryFromParent = defined(terrainData) && terrainData.wasCreatedByUpsampling();\n      if (tile.level > data.level && !upsampledGeometryFromParent) {\n        let position;\n        // find cached entry\n        const cachedData = tile.getPositionCacheEntry(data.positionCartographic, primitive.maximumScreenSpaceError);\n        if (defined(cachedData)) {\n          // cache hit\n          position = cachedData;\n        } else {\n          if (!defined(data.positionOnEllipsoidSurface)) {\n            // cartesian has to be on the ellipsoid surface for `ellipsoid.geodeticSurfaceNormal`\n            data.positionOnEllipsoidSurface = Cartesian3.fromRadians(data.positionCartographic.longitude, data.positionCartographic.latitude, 0.0, ellipsoid);\n          }\n          if (mode === SceneMode.SCENE3D) {\n            const surfaceNormal = ellipsoid.geodeticSurfaceNormal(data.positionOnEllipsoidSurface, scratchRay.direction);\n\n            // compute origin point\n\n            // Try to find the intersection point between the surface normal and z-axis.\n            // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n            const rayOrigin = ellipsoid.getSurfaceNormalIntersectionWithZAxis(data.positionOnEllipsoidSurface, 11500.0, scratchRay.origin);\n\n            // Theoretically, not with Earth datums, the intersection point can be outside the ellipsoid\n            if (!defined(rayOrigin)) {\n              // intersection point is outside the ellipsoid, try other value\n              // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n              let minimumHeight = 0.0;\n              if (defined(tile.data.tileBoundingRegion)) {\n                minimumHeight = tile.data.tileBoundingRegion.minimumHeight;\n              }\n              const magnitude = Math.min(minimumHeight, -11500.0);\n\n              // multiply by the *positive* value of the magnitude\n              const vectorToMinimumPoint = Cartesian3.multiplyByScalar(surfaceNormal, Math.abs(magnitude) + 1, scratchPosition);\n              Cartesian3.subtract(data.positionOnEllipsoidSurface, vectorToMinimumPoint, scratchRay.origin);\n            }\n          } else {\n            Cartographic.clone(data.positionCartographic, scratchCartographic);\n\n            // minimum height for the terrain set, need to get this information from the terrain provider\n            scratchCartographic.height = -11500.0;\n            projection.project(scratchCartographic, scratchPosition);\n            Cartesian3.fromElements(scratchPosition.z, scratchPosition.x, scratchPosition.y, scratchPosition);\n            Cartesian3.clone(scratchPosition, scratchRay.origin);\n            Cartesian3.clone(Cartesian3.UNIT_X, scratchRay.direction);\n          }\n          position = tile.data.pick(scratchRay, mode, projection, false, scratchPosition);\n          if (defined(position)) {\n            // Store the computed position in the cache for future reuse\n            tile.setPositionCacheEntry(data.positionCartographic, primitive.maximumScreenSpaceError, position);\n          }\n        }\n        if (defined(position)) {\n          if (defined(data.callback)) {\n            const positionCarto = ellipsoid.cartesianToCartographic(position, scratchCartographic);\n            data.callback(positionCarto);\n          }\n          data.level = tile.level;\n        }\n      }\n      if (getTimestamp() >= endTime) {\n        timeSliceMax = true;\n        break;\n      }\n    }\n    if (timeSliceMax) {\n      primitive._lastTileIndex = i;\n      break;\n    } else {\n      primitive._lastTileIndex = 0;\n      tilesToUpdateHeights.shift();\n    }\n  }\n  for (i = 0; i < tryNextFrame.length; i++) {\n    tilesToUpdateHeights.push(tryNextFrame[i]);\n  }\n}\nfunction createRenderCommandsForSelectedTiles(primitive, frameState) {\n  const tileProvider = primitive._tileProvider;\n  const tilesToRender = primitive._tilesToRender;\n  for (let i = 0, len = tilesToRender.length; i < len; ++i) {\n    const tile = tilesToRender[i];\n    tileProvider.showTileThisFrame(tile, frameState);\n  }\n}\nexport default QuadtreePrimitive;","map":{"version":3,"names":["Cartesian3","Cartographic","defined","DeveloperError","Event","getTimestamp","CesiumMath","Matrix4","OrthographicFrustum","OrthographicOffCenterFrustum","Ray","Rectangle","Visibility","QuadtreeOccluders","QuadtreeTile","QuadtreeTileLoadState","SceneMode","TileReplacementQueue","TileSelectionResult","QuadtreePrimitive","options","tileProvider","quadtree","_tileProvider","_debug","enableDebugOutput","maxDepth","maxDepthVisited","tilesVisited","tilesCulled","tilesRendered","tilesWaitingForChildren","lastMaxDepth","lastMaxDepthVisited","lastTilesVisited","lastTilesCulled","lastTilesRendered","lastTilesWaitingForChildren","suspendLodUpdate","tilingScheme","ellipsoid","_tilesToRender","_tileLoadQueueHigh","_tileLoadQueueMedium","_tileLoadQueueLow","_tileReplacementQueue","_levelZeroTiles","undefined","_loadQueueTimeSlice","_tilesInvalidated","_addHeightCallbacks","_removeHeightCallbacks","_tileToUpdateHeights","_lastTileIndex","_updateHeightsTimeSlice","_cameraPositionCartographic","_cameraReferenceFrameOriginCartographic","maximumScreenSpaceError","tileCacheSize","loadingDescendantLimit","preloadAncestors","preloadSiblings","_occluders","_tileLoadProgressEvent","_lastTileLoadQueueLength","_lastSelectionFrameNumber","Object","defineProperties","prototype","get","tileLoadProgressEvent","occluders","invalidateAllTiles","primitive","replacementQueue","head","tail","count","clearTileLoadQueue","levelZeroTiles","i","length","tile","customData","customDataLength","j","data","level","push","freeResources","cancelReprojections","forEachLoadedTile","tileFunction","state","START","replacementNext","forEachRenderedTile","len","updateHeight","cartographic","callback","object","positionOnEllipsoidSurface","positionCartographic","removeFunc","addedCallbacks","splice","update","frameState","debug","beginFrame","passes","render","initialize","markStartOfRenderFrame","beginUpdate","selectTilesForRendering","createRenderCommandsForSelectedTiles","endUpdate","pick","updateForPick","updateTileLoadProgress","currentLoadQueueLength","raiseEvent","bind","afterRender","reduce","max","Math","console","log","endFrame","mode","MORPHING","processTileLoadQueue","updateHeights","isDestroyed","destroy","comparisonPoint","centerScratch","compareDistanceToPoint","a","b","center","rectangle","alon","longitude","alat","latitude","blon","blat","cameraOriginScratch","rootTraversalDetails","tilesToRender","createLevelZeroTiles","numberOfRootTiles","Array","TraversalDetails","cameraPosition","camera","positionWC","sort","customDataAdded","customDataRemoved","frameNumber","_updateCustomData","cameraFrameOrigin","getTranslation","transform","cartesianToCartographic","markTileRendered","renderable","queueTileLoad","visitIfVisible","queue","needsLoading","computeTileLoadPriority","_loadPriority","allAreRenderable","anyWereRenderedLastFrame","notYetRenderableCount","TraversalQuadDetails","southwest","southeast","northwest","northeast","combine","result","traversalQuadsByLevel","visitTile","ancestorMeetsSse","traversalDetails","meetsSse","screenSpaceError","southwestChild","southeastChild","northwestChild","northeastChild","lastFrame","lastFrameSelectionResult","_lastSelectionResultFrame","_lastSelectionResult","NONE","oneRenderedLastFrame","originalResult","RENDERED","twoCulledOrNotVisited","CULLED","threeCompletelyLoaded","DONE","canRenderWithoutLosingDetail","addTileToRenderList","canRefine","allAreUpsampled","upsampledFromParent","REFINED","firstRenderedDescendantIndex","loadIndexLow","loadIndexMedium","loadIndexHigh","tilesToUpdateHeightsIndex","visitVisibleChildrenNearToFar","queuedForLoad","renderList","workTile","KICKED","kick","parent","wasRenderedLastFrame","quadDetails","southwestDetails","southeastDetails","northwestDetails","northeastDetails","east","north","containsNeededPosition","contains","computeTileVisibility","vertexArray","CULLED_BUT_NEEDED","SCENE2D","frustum","screenSpaceError2D","maxGeometricError","getLevelMaximumGeometricError","distance","_distance","height","context","drawingBufferHeight","sseDenominator","error","fog","enabled","density","sse","pixelRatio","offCenterFrustum","width","drawingBufferWidth","pixelSize","top","bottom","right","left","tileLoadQueueHigh","tileLoadQueueMedium","tileLoadQueueLow","trimTiles","endTime","didSomeLoading","processSinglePriorityLoadQueue","sortByLoadPriority","loadQueue","loadTile","scratchRay","scratchCartographic","scratchPosition","scratchArray","tryNextFrame","tilesToUpdateHeights","startTime","timeSlice","projection","mapProjection","mesh","selectionResult","clearPositionCache","shift","timeSliceMax","terrainData","upsampledGeometryFromParent","wasCreatedByUpsampling","position","cachedData","getPositionCacheEntry","fromRadians","SCENE3D","surfaceNormal","geodeticSurfaceNormal","direction","rayOrigin","getSurfaceNormalIntersectionWithZAxis","origin","minimumHeight","tileBoundingRegion","magnitude","min","vectorToMinimumPoint","multiplyByScalar","abs","subtract","clone","project","fromElements","z","x","y","UNIT_X","setPositionCacheEntry","positionCarto","showTileThisFrame"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/QuadtreePrimitive.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Visibility from \"../Core/Visibility.js\";\nimport QuadtreeOccluders from \"./QuadtreeOccluders.js\";\nimport QuadtreeTile from \"./QuadtreeTile.js\";\nimport QuadtreeTileLoadState from \"./QuadtreeTileLoadState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport TileReplacementQueue from \"./TileReplacementQueue.js\";\nimport TileSelectionResult from \"./TileSelectionResult.js\";\n\n/**\n * Renders massive sets of data by utilizing level-of-detail and culling.  The globe surface is divided into\n * a quadtree of tiles with large, low-detail tiles at the root and small, high-detail tiles at the leaves.\n * The set of tiles to render is selected by projecting an estimate of the geometric error in a tile onto\n * the screen to estimate screen-space error, in pixels, which must be below a user-specified threshold.\n * The actual content of the tiles is arbitrary and is specified using a {@link QuadtreeTileProvider}.\n *\n * @alias QuadtreePrimitive\n * @constructor\n * @private\n *\n * @param {QuadtreeTileProvider} options.tileProvider The tile provider that loads, renders, and estimates\n *        the distance to individual tiles.\n * @param {number} [options.maximumScreenSpaceError=2] The maximum screen-space error, in pixels, that is allowed.\n *        A higher maximum error will render fewer tiles and improve performance, while a lower\n *        value will improve visual quality.\n * @param {number} [options.tileCacheSize=100] The maximum number of tiles that will be retained in the tile cache.\n *        Note that tiles will never be unloaded if they were used for rendering the last\n *        frame, so the actual number of resident tiles may be higher.  The value of\n *        this property will not affect visual quality.\n */\nfunction QuadtreePrimitive(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.tileProvider)) {\n    throw new DeveloperError(\"options.tileProvider is required.\");\n  }\n  if (defined(options.tileProvider.quadtree)) {\n    throw new DeveloperError(\n      \"A QuadtreeTileProvider can only be used with a single QuadtreePrimitive\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._tileProvider = options.tileProvider;\n  this._tileProvider.quadtree = this;\n\n  this._debug = {\n    enableDebugOutput: false,\n\n    maxDepth: 0,\n    maxDepthVisited: 0,\n    tilesVisited: 0,\n    tilesCulled: 0,\n    tilesRendered: 0,\n    tilesWaitingForChildren: 0,\n\n    lastMaxDepth: -1,\n    lastMaxDepthVisited: -1,\n    lastTilesVisited: -1,\n    lastTilesCulled: -1,\n    lastTilesRendered: -1,\n    lastTilesWaitingForChildren: -1,\n\n    suspendLodUpdate: false,\n  };\n\n  const tilingScheme = this._tileProvider.tilingScheme;\n  const ellipsoid = tilingScheme.ellipsoid;\n\n  this._tilesToRender = [];\n  this._tileLoadQueueHigh = []; // high priority tiles are preventing refinement\n  this._tileLoadQueueMedium = []; // medium priority tiles are being rendered\n  this._tileLoadQueueLow = []; // low priority tiles were refined past or are non-visible parts of quads.\n  this._tileReplacementQueue = new TileReplacementQueue();\n  this._levelZeroTiles = undefined;\n  this._loadQueueTimeSlice = 5.0;\n  this._tilesInvalidated = false;\n\n  this._addHeightCallbacks = [];\n  this._removeHeightCallbacks = [];\n\n  this._tileToUpdateHeights = [];\n  this._lastTileIndex = 0;\n  this._updateHeightsTimeSlice = 2.0;\n\n  // If a culled tile contains _cameraPositionCartographic or _cameraReferenceFrameOriginCartographic, it will be marked\n  // TileSelectionResult.CULLED_BUT_NEEDED and added to the list of tiles to update heights,\n  // even though it is not rendered.\n  // These are updated each frame in `selectTilesForRendering`.\n  this._cameraPositionCartographic = undefined;\n  this._cameraReferenceFrameOriginCartographic = undefined;\n\n  /**\n   * Gets or sets the maximum screen-space error, in pixels, that is allowed.\n   * A higher maximum error will render fewer tiles and improve performance, while a lower\n   * value will improve visual quality.\n   * @type {number}\n   * @default 2\n   */\n  this.maximumScreenSpaceError = options.maximumScreenSpaceError ?? 2;\n\n  /**\n   * Gets or sets the maximum number of tiles that will be retained in the tile cache.\n   * Note that tiles will never be unloaded if they were used for rendering the last\n   * frame, so the actual number of resident tiles may be higher.  The value of\n   * this property will not affect visual quality.\n   * @type {number}\n   * @default 100\n   */\n  this.tileCacheSize = options.tileCacheSize ?? 100;\n\n  /**\n   * Gets or sets the number of loading descendant tiles that is considered \"too many\".\n   * If a tile has too many loading descendants, that tile will be loaded and rendered before any of\n   * its descendants are loaded and rendered. This means more feedback for the user that something\n   * is happening at the cost of a longer overall load time. Setting this to 0 will cause each\n   * tile level to be loaded successively, significantly increasing load time. Setting it to a large\n   * number (e.g. 1000) will minimize the number of tiles that are loaded but tend to make\n   * detail appear all at once after a long wait.\n   * @type {number}\n   * @default 20\n   */\n  this.loadingDescendantLimit = 20;\n\n  /**\n   * Gets or sets a value indicating whether the ancestors of rendered tiles should be preloaded.\n   * Setting this to true optimizes the zoom-out experience and provides more detail in\n   * newly-exposed areas when panning. The down side is that it requires loading more tiles.\n   * @type {boolean}\n   * @default true\n   */\n  this.preloadAncestors = true;\n\n  /**\n   * Gets or sets a value indicating whether the siblings of rendered tiles should be preloaded.\n   * Setting this to true causes tiles with the same parent as a rendered tile to be loaded, even\n   * if they are culled. Setting this to true may provide a better panning experience at the\n   * cost of loading more tiles.\n   * @type {boolean}\n   * @default false\n   */\n  this.preloadSiblings = false;\n\n  this._occluders = new QuadtreeOccluders({\n    ellipsoid: ellipsoid,\n  });\n\n  this._tileLoadProgressEvent = new Event();\n  this._lastTileLoadQueueLength = 0;\n\n  this._lastSelectionFrameNumber = undefined;\n}\n\nObject.defineProperties(QuadtreePrimitive.prototype, {\n  /**\n   * Gets the provider of {@link QuadtreeTile} instances for this quadtree.\n   * @type {QuadtreeTile}\n   * @memberof QuadtreePrimitive.prototype\n   */\n  tileProvider: {\n    get: function () {\n      return this._tileProvider;\n    },\n  },\n  /**\n   * Gets an event that's raised when the length of the tile load queue has changed since the last render frame.  When the load queue is empty,\n   * all terrain and imagery for the current view have been loaded.  The event passes the new length of the tile load queue.\n   *\n   * @memberof QuadtreePrimitive.prototype\n   * @type {Event}\n   */\n  tileLoadProgressEvent: {\n    get: function () {\n      return this._tileLoadProgressEvent;\n    },\n  },\n\n  occluders: {\n    get: function () {\n      return this._occluders;\n    },\n  },\n});\n\n/**\n * Invalidates and frees all the tiles in the quadtree.  The tiles must be reloaded\n * before they can be displayed.\n *\n * @memberof QuadtreePrimitive\n */\nQuadtreePrimitive.prototype.invalidateAllTiles = function () {\n  this._tilesInvalidated = true;\n};\n\nfunction invalidateAllTiles(primitive) {\n  // Clear the replacement queue\n  const replacementQueue = primitive._tileReplacementQueue;\n  replacementQueue.head = undefined;\n  replacementQueue.tail = undefined;\n  replacementQueue.count = 0;\n\n  clearTileLoadQueue(primitive);\n\n  // Free and recreate the level zero tiles.\n  const levelZeroTiles = primitive._levelZeroTiles;\n  if (defined(levelZeroTiles)) {\n    for (let i = 0; i < levelZeroTiles.length; ++i) {\n      const tile = levelZeroTiles[i];\n      const customData = tile.customData;\n      const customDataLength = customData.length;\n\n      for (let j = 0; j < customDataLength; ++j) {\n        const data = customData[j];\n        data.level = 0;\n        primitive._addHeightCallbacks.push(data);\n      }\n\n      levelZeroTiles[i].freeResources();\n    }\n  }\n\n  primitive._levelZeroTiles = undefined;\n\n  primitive._tileProvider.cancelReprojections();\n}\n\n/**\n * Invokes a specified function for each {@link QuadtreeTile} that is partially\n * or completely loaded.\n *\n * @param {Function} tileFunction The function to invoke for each loaded tile.  The\n *        function is passed a reference to the tile as its only parameter.\n */\nQuadtreePrimitive.prototype.forEachLoadedTile = function (tileFunction) {\n  let tile = this._tileReplacementQueue.head;\n  while (defined(tile)) {\n    if (tile.state !== QuadtreeTileLoadState.START) {\n      tileFunction(tile);\n    }\n    tile = tile.replacementNext;\n  }\n};\n\n/**\n * Invokes a specified function for each {@link QuadtreeTile} that was rendered\n * in the most recent frame.\n *\n * @param {Function} tileFunction The function to invoke for each rendered tile.  The\n *        function is passed a reference to the tile as its only parameter.\n */\nQuadtreePrimitive.prototype.forEachRenderedTile = function (tileFunction) {\n  const tilesRendered = this._tilesToRender;\n  for (let i = 0, len = tilesRendered.length; i < len; ++i) {\n    tileFunction(tilesRendered[i]);\n  }\n};\n\n/**\n * Calls the callback when a new tile is rendered that contains the given cartographic. The only parameter\n * is the cartesian position on the tile.\n *\n * @param {Cartographic} cartographic The cartographic position.\n * @param {Function} callback The function to be called when a new tile is loaded containing the updated cartographic.\n * @returns {Function} The function to remove this callback from the quadtree.\n */\nQuadtreePrimitive.prototype.updateHeight = function (cartographic, callback) {\n  const primitive = this;\n  const object = {\n    positionOnEllipsoidSurface: undefined,\n    positionCartographic: cartographic,\n    level: -1,\n    callback: callback,\n  };\n\n  object.removeFunc = function () {\n    const addedCallbacks = primitive._addHeightCallbacks;\n    const length = addedCallbacks.length;\n    for (let i = 0; i < length; ++i) {\n      if (addedCallbacks[i] === object) {\n        addedCallbacks.splice(i, 1);\n        break;\n      }\n    }\n    primitive._removeHeightCallbacks.push(object);\n    if (object.callback) {\n      object.callback = undefined;\n    }\n  };\n\n  primitive._addHeightCallbacks.push(object);\n  return object.removeFunc;\n};\n\n/**\n * Updates the tile provider imagery and continues to process the tile load queue.\n * @private\n */\nQuadtreePrimitive.prototype.update = function (frameState) {\n  if (defined(this._tileProvider.update)) {\n    this._tileProvider.update(frameState);\n  }\n};\n\nfunction clearTileLoadQueue(primitive) {\n  const debug = primitive._debug;\n  debug.maxDepth = 0;\n  debug.maxDepthVisited = 0;\n  debug.tilesVisited = 0;\n  debug.tilesCulled = 0;\n  debug.tilesRendered = 0;\n  debug.tilesWaitingForChildren = 0;\n\n  primitive._tileLoadQueueHigh.length = 0;\n  primitive._tileLoadQueueMedium.length = 0;\n  primitive._tileLoadQueueLow.length = 0;\n}\n\n/**\n * Initializes values for a new render frame and prepare the tile load queue.\n * @private\n */\nQuadtreePrimitive.prototype.beginFrame = function (frameState) {\n  const passes = frameState.passes;\n  if (!passes.render) {\n    return;\n  }\n\n  if (this._tilesInvalidated) {\n    invalidateAllTiles(this);\n    this._tilesInvalidated = false;\n  }\n\n  // Gets commands for any texture re-projections\n  this._tileProvider.initialize(frameState);\n\n  clearTileLoadQueue(this);\n\n  if (this._debug.suspendLodUpdate) {\n    return;\n  }\n\n  this._tileReplacementQueue.markStartOfRenderFrame();\n};\n\n/**\n * Selects new tiles to load based on the frame state and creates render commands.\n * @private\n */\nQuadtreePrimitive.prototype.render = function (frameState) {\n  const passes = frameState.passes;\n  const tileProvider = this._tileProvider;\n\n  if (passes.render) {\n    tileProvider.beginUpdate(frameState);\n\n    selectTilesForRendering(this, frameState);\n    createRenderCommandsForSelectedTiles(this, frameState);\n\n    tileProvider.endUpdate(frameState);\n  }\n\n  if (passes.pick && this._tilesToRender.length > 0) {\n    tileProvider.updateForPick(frameState);\n  }\n};\n\n/**\n * Checks if the load queue length has changed since the last time we raised a queue change event - if so, raises\n * a new change event at the end of the render cycle.\n * @private\n */\nfunction updateTileLoadProgress(primitive, frameState) {\n  const currentLoadQueueLength =\n    primitive._tileLoadQueueHigh.length +\n    primitive._tileLoadQueueMedium.length +\n    primitive._tileLoadQueueLow.length;\n\n  if (\n    currentLoadQueueLength !== primitive._lastTileLoadQueueLength ||\n    primitive._tilesInvalidated\n  ) {\n    const raiseEvent = Event.prototype.raiseEvent.bind(\n      primitive._tileLoadProgressEvent,\n      currentLoadQueueLength,\n    );\n    frameState.afterRender.push(() => {\n      raiseEvent();\n      return true;\n    });\n    primitive._lastTileLoadQueueLength = currentLoadQueueLength;\n  }\n\n  const debug = primitive._debug;\n  if (debug.enableDebugOutput && !debug.suspendLodUpdate) {\n    debug.maxDepth = primitive._tilesToRender.reduce(function (max, tile) {\n      return Math.max(max, tile.level);\n    }, -1);\n    debug.tilesRendered = primitive._tilesToRender.length;\n\n    if (\n      debug.tilesVisited !== debug.lastTilesVisited ||\n      debug.tilesRendered !== debug.lastTilesRendered ||\n      debug.tilesCulled !== debug.lastTilesCulled ||\n      debug.maxDepth !== debug.lastMaxDepth ||\n      debug.tilesWaitingForChildren !== debug.lastTilesWaitingForChildren ||\n      debug.maxDepthVisited !== debug.lastMaxDepthVisited\n    ) {\n      console.log(\n        `Visited ${debug.tilesVisited}, Rendered: ${debug.tilesRendered}, Culled: ${debug.tilesCulled}, Max Depth Rendered: ${debug.maxDepth}, Max Depth Visited: ${debug.maxDepthVisited}, Waiting for children: ${debug.tilesWaitingForChildren}`,\n      );\n\n      debug.lastTilesVisited = debug.tilesVisited;\n      debug.lastTilesRendered = debug.tilesRendered;\n      debug.lastTilesCulled = debug.tilesCulled;\n      debug.lastMaxDepth = debug.maxDepth;\n      debug.lastTilesWaitingForChildren = debug.tilesWaitingForChildren;\n      debug.lastMaxDepthVisited = debug.maxDepthVisited;\n    }\n  }\n}\n\n/**\n * Updates terrain heights.\n * @private\n */\nQuadtreePrimitive.prototype.endFrame = function (frameState) {\n  const passes = frameState.passes;\n  if (!passes.render || frameState.mode === SceneMode.MORPHING) {\n    // Only process the load queue for a single pass.\n    // Don't process the load queue or update heights during the morph flights.\n    return;\n  }\n\n  // Load/create resources for terrain and imagery. Prepare texture re-projections for the next frame.\n  processTileLoadQueue(this, frameState);\n  updateHeights(this, frameState);\n  updateTileLoadProgress(this, frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @memberof QuadtreePrimitive\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n *\n * @see QuadtreePrimitive#destroy\n */\nQuadtreePrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @memberof QuadtreePrimitive\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * primitive = primitive && primitive.destroy();\n *\n * @see QuadtreePrimitive#isDestroyed\n */\nQuadtreePrimitive.prototype.destroy = function () {\n  this._tileProvider = this._tileProvider && this._tileProvider.destroy();\n};\n\nlet comparisonPoint;\nconst centerScratch = new Cartographic();\nfunction compareDistanceToPoint(a, b) {\n  let center = Rectangle.center(a.rectangle, centerScratch);\n  const alon = center.longitude - comparisonPoint.longitude;\n  const alat = center.latitude - comparisonPoint.latitude;\n\n  center = Rectangle.center(b.rectangle, centerScratch);\n  const blon = center.longitude - comparisonPoint.longitude;\n  const blat = center.latitude - comparisonPoint.latitude;\n\n  return alon * alon + alat * alat - (blon * blon + blat * blat);\n}\n\nconst cameraOriginScratch = new Cartesian3();\nlet rootTraversalDetails = [];\n\nfunction selectTilesForRendering(primitive, frameState) {\n  const debug = primitive._debug;\n  if (debug.suspendLodUpdate) {\n    return;\n  }\n\n  // Clear the render list.\n  const tilesToRender = primitive._tilesToRender;\n  tilesToRender.length = 0;\n\n  // We can't render anything before the level zero tiles exist.\n  let i;\n  const tileProvider = primitive._tileProvider;\n  if (!defined(primitive._levelZeroTiles)) {\n    const tilingScheme = tileProvider.tilingScheme;\n    if (defined(tilingScheme)) {\n      const tilingScheme = tileProvider.tilingScheme;\n      primitive._levelZeroTiles =\n        QuadtreeTile.createLevelZeroTiles(tilingScheme);\n      const numberOfRootTiles = primitive._levelZeroTiles.length;\n      if (rootTraversalDetails.length < numberOfRootTiles) {\n        rootTraversalDetails = new Array(numberOfRootTiles);\n        for (i = 0; i < numberOfRootTiles; ++i) {\n          if (rootTraversalDetails[i] === undefined) {\n            rootTraversalDetails[i] = new TraversalDetails();\n          }\n        }\n      }\n    } else {\n      return;\n    }\n  }\n\n  primitive._occluders.ellipsoid.cameraPosition = frameState.camera.positionWC;\n\n  let tile;\n  const levelZeroTiles = primitive._levelZeroTiles;\n  const occluders =\n    levelZeroTiles.length > 1 ? primitive._occluders : undefined;\n\n  // Sort the level zero tiles by the distance from the center to the camera.\n  // The level zero tiles aren't necessarily a nice neat quad, so we can't use the\n  // quadtree ordering we use elsewhere in the tree\n  comparisonPoint = frameState.camera.positionCartographic;\n  levelZeroTiles.sort(compareDistanceToPoint);\n\n  const customDataAdded = primitive._addHeightCallbacks;\n  const customDataRemoved = primitive._removeHeightCallbacks;\n  const frameNumber = frameState.frameNumber;\n\n  let len;\n  if (customDataAdded.length > 0 || customDataRemoved.length > 0) {\n    for (i = 0, len = levelZeroTiles.length; i < len; ++i) {\n      tile = levelZeroTiles[i];\n      tile._updateCustomData(frameNumber, customDataAdded, customDataRemoved);\n    }\n\n    customDataAdded.length = 0;\n    customDataRemoved.length = 0;\n  }\n\n  const camera = frameState.camera;\n\n  primitive._cameraPositionCartographic = camera.positionCartographic;\n  const cameraFrameOrigin = Matrix4.getTranslation(\n    camera.transform,\n    cameraOriginScratch,\n  );\n  primitive._cameraReferenceFrameOriginCartographic =\n    primitive.tileProvider.tilingScheme.ellipsoid.cartesianToCartographic(\n      cameraFrameOrigin,\n      primitive._cameraReferenceFrameOriginCartographic,\n    );\n\n  // Traverse in depth-first, near-to-far order.\n  for (i = 0, len = levelZeroTiles.length; i < len; ++i) {\n    tile = levelZeroTiles[i];\n    primitive._tileReplacementQueue.markTileRendered(tile);\n    if (!tile.renderable) {\n      queueTileLoad(primitive, primitive._tileLoadQueueHigh, tile, frameState);\n      ++debug.tilesWaitingForChildren;\n    } else {\n      visitIfVisible(\n        primitive,\n        tile,\n        tileProvider,\n        frameState,\n        occluders,\n        false,\n        rootTraversalDetails[i],\n      );\n    }\n  }\n\n  primitive._lastSelectionFrameNumber = frameNumber;\n}\n\nfunction queueTileLoad(primitive, queue, tile, frameState) {\n  if (!tile.needsLoading) {\n    return;\n  }\n\n  if (primitive.tileProvider.computeTileLoadPriority !== undefined) {\n    tile._loadPriority = primitive.tileProvider.computeTileLoadPriority(\n      tile,\n      frameState,\n    );\n  }\n  queue.push(tile);\n}\n\n/**\n * Tracks details of traversing a tile while selecting tiles for rendering.\n * @alias TraversalDetails\n * @constructor\n * @private\n */\nfunction TraversalDetails() {\n  /**\n   * True if all selected (i.e. not culled or refined) tiles in this tile's subtree\n   * are renderable. If the subtree is renderable, we'll render it; no drama.\n   */\n  this.allAreRenderable = true;\n\n  /**\n   * True if any tiles in this tile's subtree were rendered last frame. If any\n   * were, we must render the subtree rather than this tile, because rendering\n   * this tile would cause detail to vanish that was visible last frame, and\n   * that's no good.\n   */\n  this.anyWereRenderedLastFrame = false;\n\n  /**\n   * Counts the number of selected tiles in this tile's subtree that are\n   * not yet ready to be rendered because they need more loading. Note that\n   * this value will _not_ necessarily be zero when\n   * {@link TraversalDetails#allAreRenderable} is true, for subtle reasons.\n   * When {@link TraversalDetails#allAreRenderable} and\n   * {@link TraversalDetails#anyWereRenderedLastFrame} are both false, we\n   * will render this tile instead of any tiles in its subtree and\n   * the `allAreRenderable` value for this tile will reflect only whether _this_\n   * tile is renderable. The `notYetRenderableCount` value, however, will still\n   * reflect the total number of tiles that we are waiting on, including the\n   * ones that we're not rendering. `notYetRenderableCount` is only reset\n   * when a subtree is removed from the render queue because the\n   * `notYetRenderableCount` exceeds the\n   * {@link QuadtreePrimitive#loadingDescendantLimit}.\n   */\n  this.notYetRenderableCount = 0;\n}\n\nfunction TraversalQuadDetails() {\n  this.southwest = new TraversalDetails();\n  this.southeast = new TraversalDetails();\n  this.northwest = new TraversalDetails();\n  this.northeast = new TraversalDetails();\n}\n\nTraversalQuadDetails.prototype.combine = function (result) {\n  const southwest = this.southwest;\n  const southeast = this.southeast;\n  const northwest = this.northwest;\n  const northeast = this.northeast;\n\n  result.allAreRenderable =\n    southwest.allAreRenderable &&\n    southeast.allAreRenderable &&\n    northwest.allAreRenderable &&\n    northeast.allAreRenderable;\n  result.anyWereRenderedLastFrame =\n    southwest.anyWereRenderedLastFrame ||\n    southeast.anyWereRenderedLastFrame ||\n    northwest.anyWereRenderedLastFrame ||\n    northeast.anyWereRenderedLastFrame;\n  result.notYetRenderableCount =\n    southwest.notYetRenderableCount +\n    southeast.notYetRenderableCount +\n    northwest.notYetRenderableCount +\n    northeast.notYetRenderableCount;\n};\n\nconst traversalQuadsByLevel = new Array(31); // level 30 tiles are ~2cm wide at the equator, should be good enough.\nfor (let i = 0; i < traversalQuadsByLevel.length; ++i) {\n  traversalQuadsByLevel[i] = new TraversalQuadDetails();\n}\n\n/**\n * Visits a tile for possible rendering. When we call this function with a tile:\n *\n *    * the tile has been determined to be visible (possibly based on a bounding volume that is not very tight-fitting)\n *    * its parent tile does _not_ meet the SSE (unless ancestorMeetsSse=true, see comments below)\n *    * the tile may or may not be renderable\n *\n * @private\n *\n * @param {Primitive} primitive The QuadtreePrimitive.\n * @param {FrameState} frameState The frame state.\n * @param {QuadtreeTile} tile The tile to visit\n * @param {boolean} ancestorMeetsSse True if a tile higher in the tile tree already met the SSE and we're refining further only\n *                  to maintain detail while that higher tile loads.\n * @param {TraversalDetails} traveralDetails On return, populated with details of how the traversal of this tile went.\n */\nfunction visitTile(\n  primitive,\n  frameState,\n  tile,\n  ancestorMeetsSse,\n  traversalDetails,\n) {\n  const debug = primitive._debug;\n\n  ++debug.tilesVisited;\n\n  primitive._tileReplacementQueue.markTileRendered(tile);\n  tile._updateCustomData(frameState.frameNumber);\n\n  if (tile.level > debug.maxDepthVisited) {\n    debug.maxDepthVisited = tile.level;\n  }\n\n  const meetsSse =\n    screenSpaceError(primitive, frameState, tile) <\n    primitive.maximumScreenSpaceError;\n\n  const southwestChild = tile.southwestChild;\n  const southeastChild = tile.southeastChild;\n  const northwestChild = tile.northwestChild;\n  const northeastChild = tile.northeastChild;\n\n  const lastFrame = primitive._lastSelectionFrameNumber;\n  const lastFrameSelectionResult =\n    tile._lastSelectionResultFrame === lastFrame\n      ? tile._lastSelectionResult\n      : TileSelectionResult.NONE;\n\n  const tileProvider = primitive.tileProvider;\n\n  if (meetsSse || ancestorMeetsSse) {\n    // This tile (or an ancestor) is the one we want to render this frame, but we'll do different things depending\n    // on the state of this tile and on what we did _last_ frame.\n\n    // We can render it if _any_ of the following are true:\n    // 1. We rendered it (or kicked it) last frame.\n    // 2. This tile was culled last frame, or it wasn't even visited because an ancestor was culled.\n    // 3. The tile is completely done loading.\n    // 4. a) Terrain is ready, and\n    //    b) All necessary imagery is ready. Necessary imagery is imagery that was rendered with this tile\n    //       or any descendants last frame. Such imagery is required because rendering this tile without\n    //       it would cause detail to disappear.\n    //\n    // Determining condition 4 is more expensive, so we check the others first.\n    //\n    // Note that even if we decide to render a tile here, it may later get \"kicked\" in favor of an ancestor.\n\n    const oneRenderedLastFrame =\n      TileSelectionResult.originalResult(lastFrameSelectionResult) ===\n      TileSelectionResult.RENDERED;\n    const twoCulledOrNotVisited =\n      TileSelectionResult.originalResult(lastFrameSelectionResult) ===\n        TileSelectionResult.CULLED ||\n      lastFrameSelectionResult === TileSelectionResult.NONE;\n    const threeCompletelyLoaded = tile.state === QuadtreeTileLoadState.DONE;\n\n    let renderable =\n      oneRenderedLastFrame || twoCulledOrNotVisited || threeCompletelyLoaded;\n\n    if (!renderable) {\n      // Check the more expensive condition 4 above. This requires details of the thing\n      // we're rendering (e.g. the globe surface), so delegate it to the tile provider.\n      if (defined(tileProvider.canRenderWithoutLosingDetail)) {\n        renderable = tileProvider.canRenderWithoutLosingDetail(tile);\n      }\n    }\n\n    if (renderable) {\n      // Only load this tile if it (not just an ancestor) meets the SSE.\n      if (meetsSse) {\n        queueTileLoad(\n          primitive,\n          primitive._tileLoadQueueMedium,\n          tile,\n          frameState,\n        );\n      }\n      addTileToRenderList(primitive, tile);\n\n      traversalDetails.allAreRenderable = tile.renderable;\n      traversalDetails.anyWereRenderedLastFrame =\n        lastFrameSelectionResult === TileSelectionResult.RENDERED;\n      traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;\n\n      tile._lastSelectionResultFrame = frameState.frameNumber;\n      tile._lastSelectionResult = TileSelectionResult.RENDERED;\n\n      if (!traversalDetails.anyWereRenderedLastFrame) {\n        // Tile is newly-rendered this frame, so update its heights.\n        primitive._tileToUpdateHeights.push(tile);\n      }\n\n      return;\n    }\n\n    // Otherwise, we can't render this tile (or its fill) because doing so would cause detail to disappear\n    // that was visible last frame. Instead, keep rendering any still-visible descendants that were rendered\n    // last frame and render fills for newly-visible descendants. E.g. if we were rendering level 15 last\n    // frame but this frame we want level 14 and the closest renderable level <= 14 is 0, rendering level\n    // zero would be pretty jarring so instead we keep rendering level 15 even though its SSE is better\n    // than required. So fall through to continue traversal...\n    ancestorMeetsSse = true;\n\n    // Load this blocker tile with high priority, but only if this tile (not just an ancestor) meets the SSE.\n    if (meetsSse) {\n      queueTileLoad(primitive, primitive._tileLoadQueueHigh, tile, frameState);\n    }\n  }\n\n  if (tileProvider.canRefine(tile)) {\n    const allAreUpsampled =\n      southwestChild.upsampledFromParent &&\n      southeastChild.upsampledFromParent &&\n      northwestChild.upsampledFromParent &&\n      northeastChild.upsampledFromParent;\n\n    if (allAreUpsampled) {\n      // No point in rendering the children because they're all upsampled.  Render this tile instead.\n      addTileToRenderList(primitive, tile);\n\n      // Rendered tile that's not waiting on children loads with medium priority.\n      queueTileLoad(\n        primitive,\n        primitive._tileLoadQueueMedium,\n        tile,\n        frameState,\n      );\n\n      // Make sure we don't unload the children and forget they're upsampled.\n      primitive._tileReplacementQueue.markTileRendered(southwestChild);\n      primitive._tileReplacementQueue.markTileRendered(southeastChild);\n      primitive._tileReplacementQueue.markTileRendered(northwestChild);\n      primitive._tileReplacementQueue.markTileRendered(northeastChild);\n\n      traversalDetails.allAreRenderable = tile.renderable;\n      traversalDetails.anyWereRenderedLastFrame =\n        lastFrameSelectionResult === TileSelectionResult.RENDERED;\n      traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;\n\n      tile._lastSelectionResultFrame = frameState.frameNumber;\n      tile._lastSelectionResult = TileSelectionResult.RENDERED;\n\n      if (!traversalDetails.anyWereRenderedLastFrame) {\n        // Tile is newly-rendered this frame, so update its heights.\n        primitive._tileToUpdateHeights.push(tile);\n      }\n\n      return;\n    }\n\n    // SSE is not good enough, so refine.\n    tile._lastSelectionResultFrame = frameState.frameNumber;\n    tile._lastSelectionResult = TileSelectionResult.REFINED;\n\n    const firstRenderedDescendantIndex = primitive._tilesToRender.length;\n    const loadIndexLow = primitive._tileLoadQueueLow.length;\n    const loadIndexMedium = primitive._tileLoadQueueMedium.length;\n    const loadIndexHigh = primitive._tileLoadQueueHigh.length;\n    const tilesToUpdateHeightsIndex = primitive._tileToUpdateHeights.length;\n\n    // No need to add the children to the load queue because they'll be added (if necessary) when they're visited.\n    visitVisibleChildrenNearToFar(\n      primitive,\n      southwestChild,\n      southeastChild,\n      northwestChild,\n      northeastChild,\n      frameState,\n      ancestorMeetsSse,\n      traversalDetails,\n    );\n\n    // If no descendant tiles were added to the render list by the function above, it means they were all\n    // culled even though this tile was deemed visible. That's pretty common.\n\n    if (firstRenderedDescendantIndex !== primitive._tilesToRender.length) {\n      // At least one descendant tile was added to the render list.\n      // The traversalDetails tell us what happened while visiting the children.\n\n      const allAreRenderable = traversalDetails.allAreRenderable;\n      const anyWereRenderedLastFrame =\n        traversalDetails.anyWereRenderedLastFrame;\n      const notYetRenderableCount = traversalDetails.notYetRenderableCount;\n      let queuedForLoad = false;\n\n      if (!allAreRenderable && !anyWereRenderedLastFrame) {\n        // Some of our descendants aren't ready to render yet, and none were rendered last frame,\n        // so kick them all out of the render list and render this tile instead. Continue to load them though!\n\n        // Mark the rendered descendants and their ancestors - up to this tile - as kicked.\n        const renderList = primitive._tilesToRender;\n        for (let i = firstRenderedDescendantIndex; i < renderList.length; ++i) {\n          let workTile = renderList[i];\n          while (\n            workTile !== undefined &&\n            workTile._lastSelectionResult !== TileSelectionResult.KICKED &&\n            workTile !== tile\n          ) {\n            workTile._lastSelectionResult = TileSelectionResult.kick(\n              workTile._lastSelectionResult,\n            );\n            workTile = workTile.parent;\n          }\n        }\n\n        // Remove all descendants from the render list and add this tile.\n        primitive._tilesToRender.length = firstRenderedDescendantIndex;\n        primitive._tileToUpdateHeights.length = tilesToUpdateHeightsIndex;\n        addTileToRenderList(primitive, tile);\n\n        tile._lastSelectionResult = TileSelectionResult.RENDERED;\n\n        // If we're waiting on heaps of descendants, the above will take too long. So in that case,\n        // load this tile INSTEAD of loading any of the descendants, and tell the up-level we're only waiting\n        // on this tile. Keep doing this until we actually manage to render this tile.\n        const wasRenderedLastFrame =\n          lastFrameSelectionResult === TileSelectionResult.RENDERED;\n        if (\n          !wasRenderedLastFrame &&\n          notYetRenderableCount > primitive.loadingDescendantLimit\n        ) {\n          // Remove all descendants from the load queues.\n          primitive._tileLoadQueueLow.length = loadIndexLow;\n          primitive._tileLoadQueueMedium.length = loadIndexMedium;\n          primitive._tileLoadQueueHigh.length = loadIndexHigh;\n          queueTileLoad(\n            primitive,\n            primitive._tileLoadQueueMedium,\n            tile,\n            frameState,\n          );\n          traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;\n          queuedForLoad = true;\n        }\n\n        traversalDetails.allAreRenderable = tile.renderable;\n        traversalDetails.anyWereRenderedLastFrame = wasRenderedLastFrame;\n\n        if (!wasRenderedLastFrame) {\n          // Tile is newly-rendered this frame, so update its heights.\n          primitive._tileToUpdateHeights.push(tile);\n        }\n\n        ++debug.tilesWaitingForChildren;\n      }\n\n      if (primitive.preloadAncestors && !queuedForLoad) {\n        queueTileLoad(primitive, primitive._tileLoadQueueLow, tile, frameState);\n      }\n    }\n\n    return;\n  }\n\n  tile._lastSelectionResultFrame = frameState.frameNumber;\n  tile._lastSelectionResult = TileSelectionResult.RENDERED;\n\n  // We'd like to refine but can't because we have no availability data for this tile's children,\n  // so we have no idea if refinining would involve a load or an upsample. We'll have to finish\n  // loading this tile first in order to find that out, so load this refinement blocker with\n  // high priority.\n  addTileToRenderList(primitive, tile);\n  queueTileLoad(primitive, primitive._tileLoadQueueHigh, tile, frameState);\n\n  traversalDetails.allAreRenderable = tile.renderable;\n  traversalDetails.anyWereRenderedLastFrame =\n    lastFrameSelectionResult === TileSelectionResult.RENDERED;\n  traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;\n}\n\nfunction visitVisibleChildrenNearToFar(\n  primitive,\n  southwest,\n  southeast,\n  northwest,\n  northeast,\n  frameState,\n  ancestorMeetsSse,\n  traversalDetails,\n) {\n  const cameraPosition = frameState.camera.positionCartographic;\n  const tileProvider = primitive._tileProvider;\n  const occluders = primitive._occluders;\n\n  const quadDetails = traversalQuadsByLevel[southwest.level];\n  const southwestDetails = quadDetails.southwest;\n  const southeastDetails = quadDetails.southeast;\n  const northwestDetails = quadDetails.northwest;\n  const northeastDetails = quadDetails.northeast;\n\n  if (cameraPosition.longitude < southwest.rectangle.east) {\n    if (cameraPosition.latitude < southwest.rectangle.north) {\n      // Camera in southwest quadrant\n      visitIfVisible(\n        primitive,\n        southwest,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        southwestDetails,\n      );\n      visitIfVisible(\n        primitive,\n        southeast,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        southeastDetails,\n      );\n      visitIfVisible(\n        primitive,\n        northwest,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        northwestDetails,\n      );\n      visitIfVisible(\n        primitive,\n        northeast,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        northeastDetails,\n      );\n    } else {\n      // Camera in northwest quadrant\n      visitIfVisible(\n        primitive,\n        northwest,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        northwestDetails,\n      );\n      visitIfVisible(\n        primitive,\n        southwest,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        southwestDetails,\n      );\n      visitIfVisible(\n        primitive,\n        northeast,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        northeastDetails,\n      );\n      visitIfVisible(\n        primitive,\n        southeast,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        southeastDetails,\n      );\n    }\n  } else if (cameraPosition.latitude < southwest.rectangle.north) {\n    // Camera southeast quadrant\n    visitIfVisible(\n      primitive,\n      southeast,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      southeastDetails,\n    );\n    visitIfVisible(\n      primitive,\n      southwest,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      southwestDetails,\n    );\n    visitIfVisible(\n      primitive,\n      northeast,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      northeastDetails,\n    );\n    visitIfVisible(\n      primitive,\n      northwest,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      northwestDetails,\n    );\n  } else {\n    // Camera in northeast quadrant\n    visitIfVisible(\n      primitive,\n      northeast,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      northeastDetails,\n    );\n    visitIfVisible(\n      primitive,\n      northwest,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      northwestDetails,\n    );\n    visitIfVisible(\n      primitive,\n      southeast,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      southeastDetails,\n    );\n    visitIfVisible(\n      primitive,\n      southwest,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      southwestDetails,\n    );\n  }\n\n  quadDetails.combine(traversalDetails);\n}\n\nfunction containsNeededPosition(primitive, tile) {\n  const rectangle = tile.rectangle;\n  return (\n    (defined(primitive._cameraPositionCartographic) &&\n      Rectangle.contains(rectangle, primitive._cameraPositionCartographic)) ||\n    (defined(primitive._cameraReferenceFrameOriginCartographic) &&\n      Rectangle.contains(\n        rectangle,\n        primitive._cameraReferenceFrameOriginCartographic,\n      ))\n  );\n}\n\nfunction visitIfVisible(\n  primitive,\n  tile,\n  tileProvider,\n  frameState,\n  occluders,\n  ancestorMeetsSse,\n  traversalDetails,\n) {\n  if (\n    tileProvider.computeTileVisibility(tile, frameState, occluders) !==\n    Visibility.NONE\n  ) {\n    return visitTile(\n      primitive,\n      frameState,\n      tile,\n      ancestorMeetsSse,\n      traversalDetails,\n    );\n  }\n\n  ++primitive._debug.tilesCulled;\n  primitive._tileReplacementQueue.markTileRendered(tile);\n\n  traversalDetails.allAreRenderable = true;\n  traversalDetails.anyWereRenderedLastFrame = false;\n  traversalDetails.notYetRenderableCount = 0;\n\n  if (containsNeededPosition(primitive, tile)) {\n    // Load the tile(s) that contains the camera's position and\n    // the origin of its reference frame with medium priority.\n    // But we only need to load until the terrain is available, no need to load imagery.\n    if (!defined(tile.data) || !defined(tile.data.vertexArray)) {\n      queueTileLoad(\n        primitive,\n        primitive._tileLoadQueueMedium,\n        tile,\n        frameState,\n      );\n    }\n\n    const lastFrame = primitive._lastSelectionFrameNumber;\n    const lastFrameSelectionResult =\n      tile._lastSelectionResultFrame === lastFrame\n        ? tile._lastSelectionResult\n        : TileSelectionResult.NONE;\n    if (\n      lastFrameSelectionResult !== TileSelectionResult.CULLED_BUT_NEEDED &&\n      lastFrameSelectionResult !== TileSelectionResult.RENDERED\n    ) {\n      primitive._tileToUpdateHeights.push(tile);\n    }\n\n    tile._lastSelectionResult = TileSelectionResult.CULLED_BUT_NEEDED;\n  } else if (primitive.preloadSiblings || tile.level === 0) {\n    // Load culled level zero tiles with low priority.\n    // For all other levels, only load culled tiles if preloadSiblings is enabled.\n    queueTileLoad(primitive, primitive._tileLoadQueueLow, tile, frameState);\n    tile._lastSelectionResult = TileSelectionResult.CULLED;\n  } else {\n    tile._lastSelectionResult = TileSelectionResult.CULLED;\n  }\n\n  tile._lastSelectionResultFrame = frameState.frameNumber;\n}\n\nfunction screenSpaceError(primitive, frameState, tile) {\n  if (\n    frameState.mode === SceneMode.SCENE2D ||\n    frameState.camera.frustum instanceof OrthographicFrustum ||\n    frameState.camera.frustum instanceof OrthographicOffCenterFrustum\n  ) {\n    return screenSpaceError2D(primitive, frameState, tile);\n  }\n\n  const maxGeometricError =\n    primitive._tileProvider.getLevelMaximumGeometricError(tile.level);\n\n  const distance = tile._distance;\n  const height = frameState.context.drawingBufferHeight;\n  const sseDenominator = frameState.camera.frustum.sseDenominator;\n\n  let error = (maxGeometricError * height) / (distance * sseDenominator);\n\n  if (frameState.fog.enabled) {\n    error -=\n      CesiumMath.fog(distance, frameState.fog.density) * frameState.fog.sse;\n  }\n\n  error /= frameState.pixelRatio;\n\n  return error;\n}\n\nfunction screenSpaceError2D(primitive, frameState, tile) {\n  const camera = frameState.camera;\n  let frustum = camera.frustum;\n  const offCenterFrustum = frustum.offCenterFrustum;\n  if (defined(offCenterFrustum)) {\n    frustum = offCenterFrustum;\n  }\n\n  const context = frameState.context;\n  const width = context.drawingBufferWidth;\n  const height = context.drawingBufferHeight;\n\n  const maxGeometricError =\n    primitive._tileProvider.getLevelMaximumGeometricError(tile.level);\n  const pixelSize =\n    Math.max(frustum.top - frustum.bottom, frustum.right - frustum.left) /\n    Math.max(width, height);\n  let error = maxGeometricError / pixelSize;\n\n  if (frameState.fog.enabled && frameState.mode !== SceneMode.SCENE2D) {\n    error -=\n      CesiumMath.fog(tile._distance, frameState.fog.density) *\n      frameState.fog.sse;\n  }\n\n  error /= frameState.pixelRatio;\n\n  return error;\n}\n\nfunction addTileToRenderList(primitive, tile) {\n  primitive._tilesToRender.push(tile);\n}\n\nfunction processTileLoadQueue(primitive, frameState) {\n  const tileLoadQueueHigh = primitive._tileLoadQueueHigh;\n  const tileLoadQueueMedium = primitive._tileLoadQueueMedium;\n  const tileLoadQueueLow = primitive._tileLoadQueueLow;\n\n  if (\n    tileLoadQueueHigh.length === 0 &&\n    tileLoadQueueMedium.length === 0 &&\n    tileLoadQueueLow.length === 0\n  ) {\n    return;\n  }\n\n  // Remove any tiles that were not used this frame beyond the number\n  // we're allowed to keep.\n  primitive._tileReplacementQueue.trimTiles(primitive.tileCacheSize);\n\n  const endTime = getTimestamp() + primitive._loadQueueTimeSlice;\n  const tileProvider = primitive._tileProvider;\n\n  let didSomeLoading = processSinglePriorityLoadQueue(\n    primitive,\n    frameState,\n    tileProvider,\n    endTime,\n    tileLoadQueueHigh,\n    false,\n  );\n  didSomeLoading = processSinglePriorityLoadQueue(\n    primitive,\n    frameState,\n    tileProvider,\n    endTime,\n    tileLoadQueueMedium,\n    didSomeLoading,\n  );\n  processSinglePriorityLoadQueue(\n    primitive,\n    frameState,\n    tileProvider,\n    endTime,\n    tileLoadQueueLow,\n    didSomeLoading,\n  );\n}\n\nfunction sortByLoadPriority(a, b) {\n  return a._loadPriority - b._loadPriority;\n}\n\nfunction processSinglePriorityLoadQueue(\n  primitive,\n  frameState,\n  tileProvider,\n  endTime,\n  loadQueue,\n  didSomeLoading,\n) {\n  if (tileProvider.computeTileLoadPriority !== undefined) {\n    loadQueue.sort(sortByLoadPriority);\n  }\n\n  for (\n    let i = 0, len = loadQueue.length;\n    i < len && (getTimestamp() < endTime || !didSomeLoading);\n    ++i\n  ) {\n    const tile = loadQueue[i];\n    primitive._tileReplacementQueue.markTileRendered(tile);\n    tileProvider.loadTile(frameState, tile);\n    didSomeLoading = true;\n  }\n\n  return didSomeLoading;\n}\n\nconst scratchRay = new Ray();\nconst scratchCartographic = new Cartographic();\nconst scratchPosition = new Cartesian3();\nconst scratchArray = [];\n\nfunction updateHeights(primitive, frameState) {\n  if (!defined(primitive.tileProvider.tilingScheme)) {\n    return;\n  }\n\n  const tryNextFrame = scratchArray;\n  tryNextFrame.length = 0;\n  const tilesToUpdateHeights = primitive._tileToUpdateHeights;\n\n  const startTime = getTimestamp();\n  const timeSlice = primitive._updateHeightsTimeSlice;\n  const endTime = startTime + timeSlice;\n\n  const mode = frameState.mode;\n  const projection = frameState.mapProjection;\n  const ellipsoid = primitive.tileProvider.tilingScheme.ellipsoid;\n  let i;\n\n  while (tilesToUpdateHeights.length > 0) {\n    const tile = tilesToUpdateHeights[0];\n    if (!defined(tile.data) || !defined(tile.data.mesh)) {\n      // Tile isn't loaded enough yet, so try again next frame if this tile is still\n      // being rendered.\n      const selectionResult =\n        tile._lastSelectionResultFrame === primitive._lastSelectionFrameNumber\n          ? tile._lastSelectionResult\n          : TileSelectionResult.NONE;\n      if (\n        selectionResult === TileSelectionResult.RENDERED ||\n        selectionResult === TileSelectionResult.CULLED_BUT_NEEDED\n      ) {\n        tryNextFrame.push(tile);\n      }\n      // Ensure stale position cache is cleared\n      tile.clearPositionCache();\n      tilesToUpdateHeights.shift();\n      primitive._lastTileIndex = 0;\n      continue;\n    }\n    const customData = tile.customData;\n    const customDataLength = customData.length;\n\n    let timeSliceMax = false;\n    for (i = primitive._lastTileIndex; i < customDataLength; ++i) {\n      const data = customData[i];\n\n      // No need to run this code when the tile is upsampled, because the height will be the same as its parent.\n      const terrainData = tile.data.terrainData;\n      const upsampledGeometryFromParent =\n        defined(terrainData) && terrainData.wasCreatedByUpsampling();\n\n      if (tile.level > data.level && !upsampledGeometryFromParent) {\n        let position;\n        // find cached entry\n        const cachedData = tile.getPositionCacheEntry(\n          data.positionCartographic,\n          primitive.maximumScreenSpaceError,\n        );\n        if (defined(cachedData)) {\n          // cache hit\n          position = cachedData;\n        } else {\n          if (!defined(data.positionOnEllipsoidSurface)) {\n            // cartesian has to be on the ellipsoid surface for `ellipsoid.geodeticSurfaceNormal`\n            data.positionOnEllipsoidSurface = Cartesian3.fromRadians(\n              data.positionCartographic.longitude,\n              data.positionCartographic.latitude,\n              0.0,\n              ellipsoid,\n            );\n          }\n\n          if (mode === SceneMode.SCENE3D) {\n            const surfaceNormal = ellipsoid.geodeticSurfaceNormal(\n              data.positionOnEllipsoidSurface,\n              scratchRay.direction,\n            );\n\n            // compute origin point\n\n            // Try to find the intersection point between the surface normal and z-axis.\n            // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n            const rayOrigin = ellipsoid.getSurfaceNormalIntersectionWithZAxis(\n              data.positionOnEllipsoidSurface,\n              11500.0,\n              scratchRay.origin,\n            );\n\n            // Theoretically, not with Earth datums, the intersection point can be outside the ellipsoid\n            if (!defined(rayOrigin)) {\n              // intersection point is outside the ellipsoid, try other value\n              // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n              let minimumHeight = 0.0;\n              if (defined(tile.data.tileBoundingRegion)) {\n                minimumHeight = tile.data.tileBoundingRegion.minimumHeight;\n              }\n              const magnitude = Math.min(minimumHeight, -11500.0);\n\n              // multiply by the *positive* value of the magnitude\n              const vectorToMinimumPoint = Cartesian3.multiplyByScalar(\n                surfaceNormal,\n                Math.abs(magnitude) + 1,\n                scratchPosition,\n              );\n              Cartesian3.subtract(\n                data.positionOnEllipsoidSurface,\n                vectorToMinimumPoint,\n                scratchRay.origin,\n              );\n            }\n          } else {\n            Cartographic.clone(data.positionCartographic, scratchCartographic);\n\n            // minimum height for the terrain set, need to get this information from the terrain provider\n            scratchCartographic.height = -11500.0;\n            projection.project(scratchCartographic, scratchPosition);\n            Cartesian3.fromElements(\n              scratchPosition.z,\n              scratchPosition.x,\n              scratchPosition.y,\n              scratchPosition,\n            );\n            Cartesian3.clone(scratchPosition, scratchRay.origin);\n            Cartesian3.clone(Cartesian3.UNIT_X, scratchRay.direction);\n          }\n\n          position = tile.data.pick(\n            scratchRay,\n            mode,\n            projection,\n            false,\n            scratchPosition,\n          );\n\n          if (defined(position)) {\n            // Store the computed position in the cache for future reuse\n            tile.setPositionCacheEntry(\n              data.positionCartographic,\n              primitive.maximumScreenSpaceError,\n              position,\n            );\n          }\n        }\n        if (defined(position)) {\n          if (defined(data.callback)) {\n            const positionCarto = ellipsoid.cartesianToCartographic(\n              position,\n              scratchCartographic,\n            );\n            data.callback(positionCarto);\n          }\n          data.level = tile.level;\n        }\n      }\n\n      if (getTimestamp() >= endTime) {\n        timeSliceMax = true;\n        break;\n      }\n    }\n\n    if (timeSliceMax) {\n      primitive._lastTileIndex = i;\n      break;\n    } else {\n      primitive._lastTileIndex = 0;\n      tilesToUpdateHeights.shift();\n    }\n  }\n  for (i = 0; i < tryNextFrame.length; i++) {\n    tilesToUpdateHeights.push(tryNextFrame[i]);\n  }\n}\n\nfunction createRenderCommandsForSelectedTiles(primitive, frameState) {\n  const tileProvider = primitive._tileProvider;\n  const tilesToRender = primitive._tilesToRender;\n\n  for (let i = 0, len = tilesToRender.length; i < len; ++i) {\n    const tile = tilesToRender[i];\n    tileProvider.showTileThisFrame(tile, frameState);\n  }\n}\nexport default QuadtreePrimitive;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}