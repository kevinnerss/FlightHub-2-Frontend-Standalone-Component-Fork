{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport ModelComponents from \"./ModelComponents.js\";\nimport PrimitiveOutlineGenerator from \"./Model/PrimitiveOutlineGenerator.js\";\n\n/**\n * Simple struct for tracking whether an attribute will be loaded as a buffer\n * or typed array after post-processing.\n *\n * @alias PrimitiveLoadPlan.AttributeLoadPlan\n * @constructor\n *\n * @param {ModelComponents.Attribute} attribute The attribute to be updated\n *\n * @private\n */\nfunction AttributeLoadPlan(attribute) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"attribute\", attribute);\n  //>>includeEnd('debug');\n\n  /**\n   * The attribute to track.\n   *\n   * @type {ModelComponents.Attribute}\n   * @readonly\n   * @private\n   */\n  this.attribute = attribute;\n\n  /**\n   * Whether the attribute will be loaded as a GPU buffer by the time\n   * {@link PrimitiveLoadPlan#postProcess} is finished.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.loadBuffer = false;\n\n  /**\n   * Whether the attribute will be loaded as a packed typed array by the time\n   * {@link PrimitiveLoadPlan#postProcess} is finished.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.loadTypedArray = false;\n}\n\n/**\n * Simple struct for tracking whether an index buffer will be loaded as a buffer\n * or typed array after post-processing.\n *\n * @alias PrimitiveLoadPlan.IndicesLoadPlan\n * @constructor\n *\n * @param {ModelComponents.Indices} indices The indices to be updated\n *\n * @private\n */\nfunction IndicesLoadPlan(indices) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"indices\", indices);\n  //>>includeEnd('debug');\n\n  /**\n   * The indices to track.\n   *\n   * @type {ModelComponents.Indices}\n   * @readonly\n   * @private\n   */\n  this.indices = indices;\n\n  /**\n   * Whether the indices will be loaded as a GPU buffer by the time\n   * {@link PrimitiveLoadPlan#postProcess} is finished.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.loadBuffer = false;\n\n  /**\n   * Whether the indices will be loaded as a typed array copy of the GPU\n   * buffer by the time {@link PrimitiveLoadPlan#postProcess} is finished.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.loadTypedArray = false;\n}\n\n/**\n * Primitives may need post-processing steps after their attributes and indices\n * have loaded, such as generating outlines for the CESIUM_primitive_outline glTF\n * extension. This object tracks what indices and attributes need to be\n * post-processed.\n *\n * @alias PrimitiveLoadPlan\n * @constructor\n *\n * @param {ModelComponents.Primitive} primitive The primitive to track\n *\n * @private\n */\nfunction PrimitiveLoadPlan(primitive) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"primitive\", primitive);\n  //>>includeEnd('debug');\n\n  /**\n   * The primitive to track.\n   *\n   * @type {ModelComponents.Primitive}\n   * @readonly\n   * @private\n   */\n  this.primitive = primitive;\n\n  /**\n   * A flat list of attributes that need to be post-processed. This includes\n   * both regular attributes and morph target attributes.\n   *\n   * @type {PrimitiveLoadPlan.AttributeLoadPlan[]}\n   * @private\n   */\n  this.attributePlans = [];\n\n  /**\n   * Information about the triangle indices that need to be post-processed,\n   * if they exist.\n   *\n   * @type {PrimitiveLoadPlan.IndicesLoadPlan}\n   * @private\n   */\n  this.indicesPlan = undefined;\n\n  /**\n   * Set this true to indicate that the primitive has the\n   * CESIUM_primitive_outline extension and needs to be post-processed\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.needsOutlines = false;\n\n  /**\n   * The outline edge indices from the CESIUM_primitive_outline extension\n   *\n   * @type {number[]}\n   * @private\n   */\n  this.outlineIndices = undefined;\n\n  /**\n   * Set this true to indicate that the primitive has the\n   * KHR_gaussian_splatting and KHR_gaussian_splatting_compression_spz_2 extension and needs to be post-processed\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.needsGaussianSplats = false;\n}\n\n/**\n * Apply post-processing steps that may modify geometry such as generating\n * outline coordinates. If no post-processing steps are needed, this function\n * is a no-op.\n *\n * @param {Context} context The context for generating buffers on the GPU\n */\nPrimitiveLoadPlan.prototype.postProcess = function (context) {\n  // Handle CESIUM_primitive_outline. This modifies indices and attributes and\n  // also generates a new attribute for the outline coordinates. These steps\n  // are synchronous.\n  if (this.needsOutlines) {\n    generateOutlines(this);\n    generateBuffers(this, context);\n  }\n  if (this.needsGaussianSplats) {\n    setupGaussianSplatBuffers(this, context);\n  }\n};\nfunction generateOutlines(loadPlan) {\n  const primitive = loadPlan.primitive;\n  const indices = primitive.indices;\n  const vertexCount = primitive.attributes[0].count;\n  const generator = new PrimitiveOutlineGenerator({\n    triangleIndices: indices.typedArray,\n    outlineIndices: loadPlan.outlineIndices,\n    originalVertexCount: vertexCount\n  });\n\n  // The generator modifies/adds indices. In some uncommon cases it may have\n  // to upgrade to 16- or 32-bit indices so the datatype may change.\n  indices.typedArray = generator.updatedTriangleIndices;\n  indices.indexDatatype = IndexDatatype.fromTypedArray(indices.typedArray);\n\n  // The outline generator creates a new attribute for the outline coordinates\n  // that are used with a lookup texture.\n  const outlineCoordinates = makeOutlineCoordinatesAttribute(generator.outlineCoordinates);\n  const outlineCoordinatesPlan = new AttributeLoadPlan(outlineCoordinates);\n  outlineCoordinatesPlan.loadBuffer = true;\n  outlineCoordinatesPlan.loadTypedArray = false;\n  loadPlan.attributePlans.push(outlineCoordinatesPlan);\n  primitive.outlineCoordinates = outlineCoordinatesPlan.attribute;\n\n  // Some vertices may be copied due to the addition of the new attribute\n  // which may have multiple values at a vertex depending on the face\n  const attributePlans = loadPlan.attributePlans;\n  const attributesLength = loadPlan.attributePlans.length;\n  for (let i = 0; i < attributesLength; i++) {\n    const attribute = attributePlans[i].attribute;\n    attribute.typedArray = generator.updateAttribute(attribute.typedArray);\n  }\n}\nfunction makeOutlineCoordinatesAttribute(outlineCoordinatesTypedArray) {\n  const attribute = new ModelComponents.Attribute();\n  attribute.name = \"_OUTLINE_COORDINATES\";\n  attribute.typedArray = outlineCoordinatesTypedArray;\n  attribute.componentDatatype = ComponentDatatype.FLOAT;\n  attribute.type = AttributeType.VEC3;\n  attribute.normalized = false;\n  attribute.count = outlineCoordinatesTypedArray.length / 3;\n  return attribute;\n}\nfunction setupGaussianSplatBuffers(loadPlan, context) {\n  const attributePlans = loadPlan.attributePlans;\n  const attrLen = attributePlans.length;\n  for (let i = 0; i < attrLen; i++) {\n    const attributePlan = attributePlans[i];\n    attributePlan.loadBuffer = false;\n    attributePlan.loadTypedArray = true;\n  }\n}\nfunction generateBuffers(loadPlan, context) {\n  generateAttributeBuffers(loadPlan.attributePlans, context);\n  if (defined(loadPlan.indicesPlan)) {\n    generateIndexBuffers(loadPlan.indicesPlan, context);\n  }\n}\nfunction generateAttributeBuffers(attributePlans, context) {\n  const attributesLength = attributePlans.length;\n  for (let i = 0; i < attributesLength; i++) {\n    const attributePlan = attributePlans[i];\n    const attribute = attributePlan.attribute;\n    const typedArray = attribute.typedArray;\n    if (attributePlan.loadBuffer) {\n      const buffer = Buffer.createVertexBuffer({\n        typedArray: typedArray,\n        context: context,\n        usage: BufferUsage.STATIC_DRAW\n      });\n      buffer.vertexArrayDestroyable = false;\n      attribute.buffer = buffer;\n    }\n    if (!attributePlan.loadTypedArray) {\n      attribute.typedArray = undefined;\n    }\n  }\n}\nfunction generateIndexBuffers(indicesPlan, context) {\n  const indices = indicesPlan.indices;\n  if (indicesPlan.loadBuffer) {\n    const buffer = Buffer.createIndexBuffer({\n      typedArray: indices.typedArray,\n      context: context,\n      usage: BufferUsage.STATIC_DRAW,\n      indexDatatype: indices.indexDatatype\n    });\n    indices.buffer = buffer;\n    buffer.vertexArrayDestroyable = false;\n  }\n  if (!indicesPlan.loadTypedArray) {\n    indices.typedArray = undefined;\n  }\n}\nPrimitiveLoadPlan.AttributeLoadPlan = AttributeLoadPlan;\nPrimitiveLoadPlan.IndicesLoadPlan = IndicesLoadPlan;\nexport default PrimitiveLoadPlan;","map":{"version":3,"names":["Check","ComponentDatatype","defined","IndexDatatype","Buffer","BufferUsage","AttributeType","ModelComponents","PrimitiveOutlineGenerator","AttributeLoadPlan","attribute","typeOf","object","loadBuffer","loadTypedArray","IndicesLoadPlan","indices","PrimitiveLoadPlan","primitive","attributePlans","indicesPlan","undefined","needsOutlines","outlineIndices","needsGaussianSplats","prototype","postProcess","context","generateOutlines","generateBuffers","setupGaussianSplatBuffers","loadPlan","vertexCount","attributes","count","generator","triangleIndices","typedArray","originalVertexCount","updatedTriangleIndices","indexDatatype","fromTypedArray","outlineCoordinates","makeOutlineCoordinatesAttribute","outlineCoordinatesPlan","push","attributesLength","length","i","updateAttribute","outlineCoordinatesTypedArray","Attribute","name","componentDatatype","FLOAT","type","VEC3","normalized","attrLen","attributePlan","generateAttributeBuffers","generateIndexBuffers","buffer","createVertexBuffer","usage","STATIC_DRAW","vertexArrayDestroyable","createIndexBuffer"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/PrimitiveLoadPlan.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport ModelComponents from \"./ModelComponents.js\";\nimport PrimitiveOutlineGenerator from \"./Model/PrimitiveOutlineGenerator.js\";\n\n/**\n * Simple struct for tracking whether an attribute will be loaded as a buffer\n * or typed array after post-processing.\n *\n * @alias PrimitiveLoadPlan.AttributeLoadPlan\n * @constructor\n *\n * @param {ModelComponents.Attribute} attribute The attribute to be updated\n *\n * @private\n */\nfunction AttributeLoadPlan(attribute) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"attribute\", attribute);\n  //>>includeEnd('debug');\n\n  /**\n   * The attribute to track.\n   *\n   * @type {ModelComponents.Attribute}\n   * @readonly\n   * @private\n   */\n  this.attribute = attribute;\n\n  /**\n   * Whether the attribute will be loaded as a GPU buffer by the time\n   * {@link PrimitiveLoadPlan#postProcess} is finished.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.loadBuffer = false;\n\n  /**\n   * Whether the attribute will be loaded as a packed typed array by the time\n   * {@link PrimitiveLoadPlan#postProcess} is finished.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.loadTypedArray = false;\n}\n\n/**\n * Simple struct for tracking whether an index buffer will be loaded as a buffer\n * or typed array after post-processing.\n *\n * @alias PrimitiveLoadPlan.IndicesLoadPlan\n * @constructor\n *\n * @param {ModelComponents.Indices} indices The indices to be updated\n *\n * @private\n */\nfunction IndicesLoadPlan(indices) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"indices\", indices);\n  //>>includeEnd('debug');\n\n  /**\n   * The indices to track.\n   *\n   * @type {ModelComponents.Indices}\n   * @readonly\n   * @private\n   */\n  this.indices = indices;\n\n  /**\n   * Whether the indices will be loaded as a GPU buffer by the time\n   * {@link PrimitiveLoadPlan#postProcess} is finished.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.loadBuffer = false;\n\n  /**\n   * Whether the indices will be loaded as a typed array copy of the GPU\n   * buffer by the time {@link PrimitiveLoadPlan#postProcess} is finished.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.loadTypedArray = false;\n}\n\n/**\n * Primitives may need post-processing steps after their attributes and indices\n * have loaded, such as generating outlines for the CESIUM_primitive_outline glTF\n * extension. This object tracks what indices and attributes need to be\n * post-processed.\n *\n * @alias PrimitiveLoadPlan\n * @constructor\n *\n * @param {ModelComponents.Primitive} primitive The primitive to track\n *\n * @private\n */\nfunction PrimitiveLoadPlan(primitive) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"primitive\", primitive);\n  //>>includeEnd('debug');\n\n  /**\n   * The primitive to track.\n   *\n   * @type {ModelComponents.Primitive}\n   * @readonly\n   * @private\n   */\n  this.primitive = primitive;\n\n  /**\n   * A flat list of attributes that need to be post-processed. This includes\n   * both regular attributes and morph target attributes.\n   *\n   * @type {PrimitiveLoadPlan.AttributeLoadPlan[]}\n   * @private\n   */\n  this.attributePlans = [];\n\n  /**\n   * Information about the triangle indices that need to be post-processed,\n   * if they exist.\n   *\n   * @type {PrimitiveLoadPlan.IndicesLoadPlan}\n   * @private\n   */\n  this.indicesPlan = undefined;\n\n  /**\n   * Set this true to indicate that the primitive has the\n   * CESIUM_primitive_outline extension and needs to be post-processed\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.needsOutlines = false;\n\n  /**\n   * The outline edge indices from the CESIUM_primitive_outline extension\n   *\n   * @type {number[]}\n   * @private\n   */\n  this.outlineIndices = undefined;\n\n  /**\n   * Set this true to indicate that the primitive has the\n   * KHR_gaussian_splatting and KHR_gaussian_splatting_compression_spz_2 extension and needs to be post-processed\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.needsGaussianSplats = false;\n}\n\n/**\n * Apply post-processing steps that may modify geometry such as generating\n * outline coordinates. If no post-processing steps are needed, this function\n * is a no-op.\n *\n * @param {Context} context The context for generating buffers on the GPU\n */\nPrimitiveLoadPlan.prototype.postProcess = function (context) {\n  // Handle CESIUM_primitive_outline. This modifies indices and attributes and\n  // also generates a new attribute for the outline coordinates. These steps\n  // are synchronous.\n  if (this.needsOutlines) {\n    generateOutlines(this);\n    generateBuffers(this, context);\n  }\n\n  if (this.needsGaussianSplats) {\n    setupGaussianSplatBuffers(this, context);\n  }\n};\n\nfunction generateOutlines(loadPlan) {\n  const primitive = loadPlan.primitive;\n  const indices = primitive.indices;\n\n  const vertexCount = primitive.attributes[0].count;\n\n  const generator = new PrimitiveOutlineGenerator({\n    triangleIndices: indices.typedArray,\n    outlineIndices: loadPlan.outlineIndices,\n    originalVertexCount: vertexCount,\n  });\n\n  // The generator modifies/adds indices. In some uncommon cases it may have\n  // to upgrade to 16- or 32-bit indices so the datatype may change.\n  indices.typedArray = generator.updatedTriangleIndices;\n  indices.indexDatatype = IndexDatatype.fromTypedArray(indices.typedArray);\n\n  // The outline generator creates a new attribute for the outline coordinates\n  // that are used with a lookup texture.\n  const outlineCoordinates = makeOutlineCoordinatesAttribute(\n    generator.outlineCoordinates,\n  );\n  const outlineCoordinatesPlan = new AttributeLoadPlan(outlineCoordinates);\n  outlineCoordinatesPlan.loadBuffer = true;\n  outlineCoordinatesPlan.loadTypedArray = false;\n  loadPlan.attributePlans.push(outlineCoordinatesPlan);\n  primitive.outlineCoordinates = outlineCoordinatesPlan.attribute;\n\n  // Some vertices may be copied due to the addition of the new attribute\n  // which may have multiple values at a vertex depending on the face\n  const attributePlans = loadPlan.attributePlans;\n  const attributesLength = loadPlan.attributePlans.length;\n  for (let i = 0; i < attributesLength; i++) {\n    const attribute = attributePlans[i].attribute;\n    attribute.typedArray = generator.updateAttribute(attribute.typedArray);\n  }\n}\n\nfunction makeOutlineCoordinatesAttribute(outlineCoordinatesTypedArray) {\n  const attribute = new ModelComponents.Attribute();\n  attribute.name = \"_OUTLINE_COORDINATES\";\n  attribute.typedArray = outlineCoordinatesTypedArray;\n  attribute.componentDatatype = ComponentDatatype.FLOAT;\n  attribute.type = AttributeType.VEC3;\n  attribute.normalized = false;\n  attribute.count = outlineCoordinatesTypedArray.length / 3;\n\n  return attribute;\n}\n\nfunction setupGaussianSplatBuffers(loadPlan, context) {\n  const attributePlans = loadPlan.attributePlans;\n  const attrLen = attributePlans.length;\n  for (let i = 0; i < attrLen; i++) {\n    const attributePlan = attributePlans[i];\n    attributePlan.loadBuffer = false;\n    attributePlan.loadTypedArray = true;\n  }\n}\n\nfunction generateBuffers(loadPlan, context) {\n  generateAttributeBuffers(loadPlan.attributePlans, context);\n\n  if (defined(loadPlan.indicesPlan)) {\n    generateIndexBuffers(loadPlan.indicesPlan, context);\n  }\n}\n\nfunction generateAttributeBuffers(attributePlans, context) {\n  const attributesLength = attributePlans.length;\n  for (let i = 0; i < attributesLength; i++) {\n    const attributePlan = attributePlans[i];\n    const attribute = attributePlan.attribute;\n    const typedArray = attribute.typedArray;\n\n    if (attributePlan.loadBuffer) {\n      const buffer = Buffer.createVertexBuffer({\n        typedArray: typedArray,\n        context: context,\n        usage: BufferUsage.STATIC_DRAW,\n      });\n      buffer.vertexArrayDestroyable = false;\n      attribute.buffer = buffer;\n    }\n\n    if (!attributePlan.loadTypedArray) {\n      attribute.typedArray = undefined;\n    }\n  }\n}\n\nfunction generateIndexBuffers(indicesPlan, context) {\n  const indices = indicesPlan.indices;\n  if (indicesPlan.loadBuffer) {\n    const buffer = Buffer.createIndexBuffer({\n      typedArray: indices.typedArray,\n      context: context,\n      usage: BufferUsage.STATIC_DRAW,\n      indexDatatype: indices.indexDatatype,\n    });\n    indices.buffer = buffer;\n    buffer.vertexArrayDestroyable = false;\n  }\n\n  if (!indicesPlan.loadTypedArray) {\n    indices.typedArray = undefined;\n  }\n}\n\nPrimitiveLoadPlan.AttributeLoadPlan = AttributeLoadPlan;\nPrimitiveLoadPlan.IndicesLoadPlan = IndicesLoadPlan;\nexport default PrimitiveLoadPlan;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}