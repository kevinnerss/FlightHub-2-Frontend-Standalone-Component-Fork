{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport ClippingPlane from \"./ClippingPlane.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Event from \"../Core/Event.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Plane from \"../Core/Plane.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\n\n/**\n * Specifies a set of clipping planes defining rendering bounds for a {@link VoxelPrimitive}.\n *\n * @alias VoxelBoundsCollection\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {ClippingPlane[]} [options.planes=[]] An array of {@link ClippingPlane} objects used to selectively disable rendering on the outside of each plane.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix specifying an additional transform relative to the clipping planes original coordinate system.\n * @param {boolean} [options.unionClippingRegions=false] If true, a region will be clipped if it is on the outside of any plane in the collection. Otherwise, a region will only be clipped if it is on the outside of every plane.\n *\n * @private\n */\nfunction VoxelBoundsCollection(options) {\n  const {\n    planes,\n    modelMatrix = Matrix4.IDENTITY,\n    unionClippingRegions = false\n  } = options ?? Frozen.EMPTY_OBJECT;\n  this._planes = [];\n\n  /**\n   * The 4x4 transformation matrix specifying an additional transform relative to the clipping planes\n   * original coordinate system.\n   *\n   * @type {Matrix4}\n   * @default Matrix4.IDENTITY\n   */\n  this.modelMatrix = Matrix4.clone(modelMatrix);\n\n  /**\n   * An event triggered when a new clipping plane is added to the collection.  Event handlers\n   * are passed the new plane and the index at which it was added.\n   * @type {Event}\n   * @readonly\n   */\n  this.planeAdded = new Event();\n\n  /**\n   * An event triggered when a new clipping plane is removed from the collection.  Event handlers\n   * are passed the new plane and the index from which it was removed.\n   * @type {Event}\n   * @readonly\n   */\n  this.planeRemoved = new Event();\n  this._unionClippingRegions = unionClippingRegions;\n  this._testIntersection = unionClippingRegions ? unionIntersectFunction : defaultIntersectFunction;\n  this._float32View = undefined;\n  this._clippingPlanesTexture = undefined;\n\n  // Add each ClippingPlane object.\n  if (defined(planes)) {\n    for (let i = 0; i < planes.length; ++i) {\n      this.add(planes[i]);\n    }\n  }\n}\nfunction unionIntersectFunction(value) {\n  return value === Intersect.OUTSIDE;\n}\nfunction defaultIntersectFunction(value) {\n  return value === Intersect.INSIDE;\n}\nObject.defineProperties(VoxelBoundsCollection.prototype, {\n  /**\n   * Returns the number of planes in this collection.  This is commonly used with\n   * {@link VoxelBoundsCollection#get} to iterate over all the planes\n   * in the collection.\n   *\n   * @memberof VoxelBoundsCollection.prototype\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._planes.length;\n    }\n  },\n  /**\n   * If true, a region will be clipped if it is on the outside of any plane in the\n   * collection. Otherwise, a region will only be clipped if it is on the\n   * outside of every plane.\n   *\n   * @memberof VoxelBoundsCollection.prototype\n   * @type {boolean}\n   * @default false\n   */\n  unionClippingRegions: {\n    get: function () {\n      return this._unionClippingRegions;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"value\", value);\n      //>>includeEnd('debug');\n      if (this._unionClippingRegions === value) {\n        return;\n      }\n      this._unionClippingRegions = value;\n      this._testIntersection = value ? unionIntersectFunction : defaultIntersectFunction;\n    }\n  },\n  /**\n   * Returns a texture containing packed, untransformed clipping planes.\n   *\n   * @memberof VoxelBoundsCollection.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  texture: {\n    get: function () {\n      return this._clippingPlanesTexture;\n    }\n  },\n  /**\n   * Returns a Number encapsulating the state for this VoxelBoundsCollection.\n   *\n   * Clipping mode is encoded in the sign of the number, which is just the plane count.\n   * If this value changes, then shader regeneration is necessary.\n   *\n   * @memberof VoxelBoundsCollection.prototype\n   * @returns {number} A Number that describes the VoxelBoundsCollection's state.\n   * @readonly\n   * @private\n   */\n  clippingPlanesState: {\n    get: function () {\n      return this._unionClippingRegions ? this._planes.length : -this._planes.length;\n    }\n  }\n});\n\n/**\n * Adds the specified {@link ClippingPlane} to the collection to be used to selectively disable rendering\n * on the outside of each plane. Use {@link VoxelBoundsCollection#unionClippingRegions} to modify\n * how modify the clipping behavior of multiple planes.\n *\n * @param {ClippingPlane} plane The ClippingPlane to add to the collection.\n *\n * @see VoxelBoundsCollection#unionClippingRegions\n * @see VoxelBoundsCollection#remove\n * @see VoxelBoundsCollection#removeAll\n */\nVoxelBoundsCollection.prototype.add = function (plane) {\n  const newPlaneIndex = this._planes.length;\n  plane.index = newPlaneIndex;\n  this._planes.push(plane);\n  this.planeAdded.raiseEvent(plane, newPlaneIndex);\n};\n\n/**\n * Returns the plane in the collection at the specified index.  Indices are zero-based\n * and increase as planes are added.  Removing a plane shifts all planes after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link VoxelBoundsCollection#length} to iterate over all the planes\n * in the collection.\n *\n * @param {number} index The zero-based index of the plane.\n * @returns {ClippingPlane} The ClippingPlane at the specified index.\n *\n * @see VoxelBoundsCollection#length\n */\nVoxelBoundsCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  //>>includeEnd('debug');\n\n  return this._planes[index];\n};\nfunction indexOf(planes, plane) {\n  for (let i = 0; i < planes.length; ++i) {\n    if (Plane.equals(planes[i], plane)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Checks whether this collection contains a ClippingPlane equal to the given ClippingPlane.\n *\n * @param {ClippingPlane} [clippingPlane] The ClippingPlane to check for.\n * @returns {boolean} true if this collection contains the ClippingPlane, false otherwise.\n *\n * @see VoxelBoundsCollection#get\n */\nVoxelBoundsCollection.prototype.contains = function (clippingPlane) {\n  return indexOf(this._planes, clippingPlane) !== -1;\n};\n\n/**\n * Removes the first occurrence of the given ClippingPlane from the collection.\n *\n * @param {ClippingPlane} clippingPlane\n * @returns {boolean} <code>true</code> if the plane was removed; <code>false</code> if the plane was not found in the collection.\n *\n * @see VoxelBoundsCollection#add\n * @see VoxelBoundsCollection#contains\n * @see VoxelBoundsCollection#removeAll\n */\nVoxelBoundsCollection.prototype.remove = function (clippingPlane) {\n  const planes = this._planes;\n  const index = indexOf(planes, clippingPlane);\n  if (index === -1) {\n    return false;\n  }\n\n  // Unlink this VoxelBoundsCollection from the ClippingPlane\n  if (clippingPlane instanceof ClippingPlane) {\n    clippingPlane.onChangeCallback = undefined;\n    clippingPlane.index = -1;\n  }\n\n  // Shift and update indices\n  const length = planes.length - 1;\n  for (let i = index; i < length; ++i) {\n    const planeToKeep = planes[i + 1];\n    planes[i] = planeToKeep;\n    if (planeToKeep instanceof ClippingPlane) {\n      planeToKeep.index = i;\n    }\n  }\n  planes.length = length;\n  this.planeRemoved.raiseEvent(clippingPlane, index);\n  return true;\n};\n\n/**\n * Removes all planes from the collection.\n *\n * @see VoxelBoundsCollection#add\n * @see VoxelBoundsCollection#remove\n */\nVoxelBoundsCollection.prototype.removeAll = function () {\n  // Dereference this VoxelBoundsCollection from all ClippingPlanes\n  const planes = this._planes;\n  for (let i = 0; i < planes.length; ++i) {\n    const plane = planes[i];\n    if (plane instanceof ClippingPlane) {\n      plane.onChangeCallback = undefined;\n      plane.index = -1;\n    }\n    this.planeRemoved.raiseEvent(plane, i);\n  }\n  this._planes = [];\n};\nconst scratchPlane = new Plane(Cartesian3.fromElements(1.0, 0.0, 0.0), 0.0);\n\n// Pack starting at the beginning of the buffer to allow partial update\nfunction transformAndPackPlanes(clippingPlaneCollection, transform) {\n  const float32View = clippingPlaneCollection._float32View;\n  const planes = clippingPlaneCollection._planes;\n  let floatIndex = 0;\n  for (let i = 0; i < planes.length; ++i) {\n    const {\n      normal,\n      distance\n    } = transformPlane(planes[i], transform, scratchPlane);\n    float32View[floatIndex] = normal.x;\n    float32View[floatIndex + 1] = normal.y;\n    float32View[floatIndex + 2] = normal.z;\n    float32View[floatIndex + 3] = distance;\n    floatIndex += 4; // each plane is 4 floats\n  }\n}\nconst scratchPlaneCartesian4 = new Cartesian4();\nconst scratchTransformedNormal = new Cartesian3();\nfunction transformPlane(plane, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  const {\n    normal,\n    distance\n  } = plane;\n  const planeAsCartesian4 = Cartesian4.fromElements(normal.x, normal.y, normal.z, distance, scratchPlaneCartesian4);\n  let transformedPlane = Matrix4.multiplyByVector(transform, planeAsCartesian4, scratchPlaneCartesian4);\n\n  // Convert the transformed plane to Hessian Normal Form\n  const transformedNormal = Cartesian3.fromCartesian4(transformedPlane, scratchTransformedNormal);\n  transformedPlane = Cartesian4.divideByScalar(transformedPlane, Cartesian3.magnitude(transformedNormal), scratchPlaneCartesian4);\n  return Plane.fromCartesian4(transformedPlane, result);\n}\nfunction computeTextureResolution(pixelsNeeded, result) {\n  result.x = Math.min(pixelsNeeded, ContextLimits.maximumTextureSize);\n  result.y = Math.ceil(pixelsNeeded / result.x);\n  return result;\n}\nconst textureResolutionScratch = new Cartesian2();\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * build the resources for clipping planes.\n * <p>\n * Do not call this function directly.\n * </p>\n */\nVoxelBoundsCollection.prototype.update = function (frameState, transform) {\n  let clippingPlanesTexture = this._clippingPlanesTexture;\n\n  // Compute texture requirements for current planes\n  // In RGBA FLOAT, a plane is 4 floats packed to a single RGBA pixel.\n  const pixelsNeeded = this.length;\n  if (defined(clippingPlanesTexture)) {\n    const currentPixelCount = clippingPlanesTexture.width * clippingPlanesTexture.height;\n    // Recreate the texture to double current requirement if it isn't big enough or is 4 times larger than it needs to be.\n    // Optimization note: this isn't exactly the classic resizeable array algorithm\n    // * not necessarily checking for resize after each add/remove operation\n    // * random-access deletes instead of just pops\n    // * alloc ops likely more expensive than demonstrable via big-O analysis\n    if (currentPixelCount < pixelsNeeded || pixelsNeeded < 0.25 * currentPixelCount) {\n      clippingPlanesTexture.destroy();\n      clippingPlanesTexture = undefined;\n      this._clippingPlanesTexture = undefined;\n    }\n  }\n\n  // If there are no bound planes, there's nothing to update.\n  if (this.length === 0) {\n    return;\n  }\n  if (!defined(clippingPlanesTexture)) {\n    const requiredResolution = computeTextureResolution(pixelsNeeded, textureResolutionScratch);\n    // Allocate twice as much space as needed to avoid frequent texture reallocation.\n    // Allocate in the Y direction, since texture may be as wide as context texture support.\n    requiredResolution.y *= 2;\n    clippingPlanesTexture = new Texture({\n      context: frameState.context,\n      width: requiredResolution.x,\n      height: requiredResolution.y,\n      pixelFormat: PixelFormat.RGBA,\n      pixelDatatype: PixelDatatype.FLOAT,\n      sampler: Sampler.NEAREST,\n      flipY: false\n    });\n    this._float32View = new Float32Array(requiredResolution.x * requiredResolution.y * 4);\n    this._clippingPlanesTexture = clippingPlanesTexture;\n  }\n  const {\n    width,\n    height\n  } = clippingPlanesTexture;\n  transformAndPackPlanes(this, transform);\n  clippingPlanesTexture.copyFrom({\n    source: {\n      width: width,\n      height: height,\n      arrayBufferView: this._float32View\n    }\n  });\n};\n\n/**\n * Function for getting the clipping plane collection's texture resolution.\n * If the VoxelBoundsCollection hasn't been updated, returns the resolution that will be\n * allocated based on the current plane count.\n *\n * @param {VoxelBoundsCollection} clippingPlaneCollection The clipping plane collection\n * @param {Context} context The rendering context\n * @param {Cartesian2} result A Cartesian2 for the result.\n * @returns {Cartesian2} The required resolution.\n * @private\n */\nVoxelBoundsCollection.getTextureResolution = function (clippingPlaneCollection, context, result) {\n  const texture = clippingPlaneCollection.texture;\n  if (defined(texture)) {\n    result.x = texture.width;\n    result.y = texture.height;\n    return result;\n  }\n  const pixelsNeeded = clippingPlaneCollection.length;\n  const requiredResolution = computeTextureResolution(pixelsNeeded, result);\n\n  // Allocate twice as much space as needed to avoid frequent texture reallocation.\n  requiredResolution.y *= 2;\n  return requiredResolution;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see VoxelBoundsCollection#destroy\n */\nVoxelBoundsCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * voxelBounds = voxelBounds && voxelBounds.destroy();\n *\n * @see VoxelBoundsCollection#isDestroyed\n */\nVoxelBoundsCollection.prototype.destroy = function () {\n  this._clippingPlanesTexture = this._clippingPlanesTexture && this._clippingPlanesTexture.destroy();\n  return destroyObject(this);\n};\nexport default VoxelBoundsCollection;","map":{"version":3,"names":["Cartesian2","Cartesian3","Cartesian4","Check","ClippingPlane","ContextLimits","defined","destroyObject","Event","Frozen","Intersect","Matrix4","PixelFormat","PixelDatatype","Plane","Sampler","Texture","VoxelBoundsCollection","options","planes","modelMatrix","IDENTITY","unionClippingRegions","EMPTY_OBJECT","_planes","clone","planeAdded","planeRemoved","_unionClippingRegions","_testIntersection","unionIntersectFunction","defaultIntersectFunction","_float32View","undefined","_clippingPlanesTexture","i","length","add","value","OUTSIDE","INSIDE","Object","defineProperties","prototype","get","set","typeOf","bool","texture","clippingPlanesState","plane","newPlaneIndex","index","push","raiseEvent","number","indexOf","equals","contains","clippingPlane","remove","onChangeCallback","planeToKeep","removeAll","scratchPlane","fromElements","transformAndPackPlanes","clippingPlaneCollection","transform","float32View","floatIndex","normal","distance","transformPlane","x","y","z","scratchPlaneCartesian4","scratchTransformedNormal","result","object","planeAsCartesian4","transformedPlane","multiplyByVector","transformedNormal","fromCartesian4","divideByScalar","magnitude","computeTextureResolution","pixelsNeeded","Math","min","maximumTextureSize","ceil","textureResolutionScratch","update","frameState","clippingPlanesTexture","currentPixelCount","width","height","destroy","requiredResolution","context","pixelFormat","RGBA","pixelDatatype","FLOAT","sampler","NEAREST","flipY","Float32Array","copyFrom","source","arrayBufferView","getTextureResolution","isDestroyed"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/VoxelBoundsCollection.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport ClippingPlane from \"./ClippingPlane.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Event from \"../Core/Event.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Plane from \"../Core/Plane.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\n\n/**\n * Specifies a set of clipping planes defining rendering bounds for a {@link VoxelPrimitive}.\n *\n * @alias VoxelBoundsCollection\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {ClippingPlane[]} [options.planes=[]] An array of {@link ClippingPlane} objects used to selectively disable rendering on the outside of each plane.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix specifying an additional transform relative to the clipping planes original coordinate system.\n * @param {boolean} [options.unionClippingRegions=false] If true, a region will be clipped if it is on the outside of any plane in the collection. Otherwise, a region will only be clipped if it is on the outside of every plane.\n *\n * @private\n */\nfunction VoxelBoundsCollection(options) {\n  const {\n    planes,\n    modelMatrix = Matrix4.IDENTITY,\n    unionClippingRegions = false,\n  } = options ?? Frozen.EMPTY_OBJECT;\n\n  this._planes = [];\n\n  /**\n   * The 4x4 transformation matrix specifying an additional transform relative to the clipping planes\n   * original coordinate system.\n   *\n   * @type {Matrix4}\n   * @default Matrix4.IDENTITY\n   */\n  this.modelMatrix = Matrix4.clone(modelMatrix);\n\n  /**\n   * An event triggered when a new clipping plane is added to the collection.  Event handlers\n   * are passed the new plane and the index at which it was added.\n   * @type {Event}\n   * @readonly\n   */\n  this.planeAdded = new Event();\n\n  /**\n   * An event triggered when a new clipping plane is removed from the collection.  Event handlers\n   * are passed the new plane and the index from which it was removed.\n   * @type {Event}\n   * @readonly\n   */\n  this.planeRemoved = new Event();\n\n  this._unionClippingRegions = unionClippingRegions;\n  this._testIntersection = unionClippingRegions\n    ? unionIntersectFunction\n    : defaultIntersectFunction;\n\n  this._float32View = undefined;\n\n  this._clippingPlanesTexture = undefined;\n\n  // Add each ClippingPlane object.\n  if (defined(planes)) {\n    for (let i = 0; i < planes.length; ++i) {\n      this.add(planes[i]);\n    }\n  }\n}\n\nfunction unionIntersectFunction(value) {\n  return value === Intersect.OUTSIDE;\n}\n\nfunction defaultIntersectFunction(value) {\n  return value === Intersect.INSIDE;\n}\n\nObject.defineProperties(VoxelBoundsCollection.prototype, {\n  /**\n   * Returns the number of planes in this collection.  This is commonly used with\n   * {@link VoxelBoundsCollection#get} to iterate over all the planes\n   * in the collection.\n   *\n   * @memberof VoxelBoundsCollection.prototype\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._planes.length;\n    },\n  },\n\n  /**\n   * If true, a region will be clipped if it is on the outside of any plane in the\n   * collection. Otherwise, a region will only be clipped if it is on the\n   * outside of every plane.\n   *\n   * @memberof VoxelBoundsCollection.prototype\n   * @type {boolean}\n   * @default false\n   */\n  unionClippingRegions: {\n    get: function () {\n      return this._unionClippingRegions;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"value\", value);\n      //>>includeEnd('debug');\n      if (this._unionClippingRegions === value) {\n        return;\n      }\n      this._unionClippingRegions = value;\n      this._testIntersection = value\n        ? unionIntersectFunction\n        : defaultIntersectFunction;\n    },\n  },\n\n  /**\n   * Returns a texture containing packed, untransformed clipping planes.\n   *\n   * @memberof VoxelBoundsCollection.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  texture: {\n    get: function () {\n      return this._clippingPlanesTexture;\n    },\n  },\n\n  /**\n   * Returns a Number encapsulating the state for this VoxelBoundsCollection.\n   *\n   * Clipping mode is encoded in the sign of the number, which is just the plane count.\n   * If this value changes, then shader regeneration is necessary.\n   *\n   * @memberof VoxelBoundsCollection.prototype\n   * @returns {number} A Number that describes the VoxelBoundsCollection's state.\n   * @readonly\n   * @private\n   */\n  clippingPlanesState: {\n    get: function () {\n      return this._unionClippingRegions\n        ? this._planes.length\n        : -this._planes.length;\n    },\n  },\n});\n\n/**\n * Adds the specified {@link ClippingPlane} to the collection to be used to selectively disable rendering\n * on the outside of each plane. Use {@link VoxelBoundsCollection#unionClippingRegions} to modify\n * how modify the clipping behavior of multiple planes.\n *\n * @param {ClippingPlane} plane The ClippingPlane to add to the collection.\n *\n * @see VoxelBoundsCollection#unionClippingRegions\n * @see VoxelBoundsCollection#remove\n * @see VoxelBoundsCollection#removeAll\n */\nVoxelBoundsCollection.prototype.add = function (plane) {\n  const newPlaneIndex = this._planes.length;\n  plane.index = newPlaneIndex;\n  this._planes.push(plane);\n  this.planeAdded.raiseEvent(plane, newPlaneIndex);\n};\n\n/**\n * Returns the plane in the collection at the specified index.  Indices are zero-based\n * and increase as planes are added.  Removing a plane shifts all planes after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link VoxelBoundsCollection#length} to iterate over all the planes\n * in the collection.\n *\n * @param {number} index The zero-based index of the plane.\n * @returns {ClippingPlane} The ClippingPlane at the specified index.\n *\n * @see VoxelBoundsCollection#length\n */\nVoxelBoundsCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  //>>includeEnd('debug');\n\n  return this._planes[index];\n};\n\nfunction indexOf(planes, plane) {\n  for (let i = 0; i < planes.length; ++i) {\n    if (Plane.equals(planes[i], plane)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Checks whether this collection contains a ClippingPlane equal to the given ClippingPlane.\n *\n * @param {ClippingPlane} [clippingPlane] The ClippingPlane to check for.\n * @returns {boolean} true if this collection contains the ClippingPlane, false otherwise.\n *\n * @see VoxelBoundsCollection#get\n */\nVoxelBoundsCollection.prototype.contains = function (clippingPlane) {\n  return indexOf(this._planes, clippingPlane) !== -1;\n};\n\n/**\n * Removes the first occurrence of the given ClippingPlane from the collection.\n *\n * @param {ClippingPlane} clippingPlane\n * @returns {boolean} <code>true</code> if the plane was removed; <code>false</code> if the plane was not found in the collection.\n *\n * @see VoxelBoundsCollection#add\n * @see VoxelBoundsCollection#contains\n * @see VoxelBoundsCollection#removeAll\n */\nVoxelBoundsCollection.prototype.remove = function (clippingPlane) {\n  const planes = this._planes;\n  const index = indexOf(planes, clippingPlane);\n\n  if (index === -1) {\n    return false;\n  }\n\n  // Unlink this VoxelBoundsCollection from the ClippingPlane\n  if (clippingPlane instanceof ClippingPlane) {\n    clippingPlane.onChangeCallback = undefined;\n    clippingPlane.index = -1;\n  }\n\n  // Shift and update indices\n  const length = planes.length - 1;\n  for (let i = index; i < length; ++i) {\n    const planeToKeep = planes[i + 1];\n    planes[i] = planeToKeep;\n    if (planeToKeep instanceof ClippingPlane) {\n      planeToKeep.index = i;\n    }\n  }\n\n  planes.length = length;\n\n  this.planeRemoved.raiseEvent(clippingPlane, index);\n\n  return true;\n};\n\n/**\n * Removes all planes from the collection.\n *\n * @see VoxelBoundsCollection#add\n * @see VoxelBoundsCollection#remove\n */\nVoxelBoundsCollection.prototype.removeAll = function () {\n  // Dereference this VoxelBoundsCollection from all ClippingPlanes\n  const planes = this._planes;\n  for (let i = 0; i < planes.length; ++i) {\n    const plane = planes[i];\n    if (plane instanceof ClippingPlane) {\n      plane.onChangeCallback = undefined;\n      plane.index = -1;\n    }\n    this.planeRemoved.raiseEvent(plane, i);\n  }\n  this._planes = [];\n};\n\nconst scratchPlane = new Plane(Cartesian3.fromElements(1.0, 0.0, 0.0), 0.0);\n\n// Pack starting at the beginning of the buffer to allow partial update\nfunction transformAndPackPlanes(clippingPlaneCollection, transform) {\n  const float32View = clippingPlaneCollection._float32View;\n  const planes = clippingPlaneCollection._planes;\n\n  let floatIndex = 0;\n  for (let i = 0; i < planes.length; ++i) {\n    const { normal, distance } = transformPlane(\n      planes[i],\n      transform,\n      scratchPlane,\n    );\n\n    float32View[floatIndex] = normal.x;\n    float32View[floatIndex + 1] = normal.y;\n    float32View[floatIndex + 2] = normal.z;\n    float32View[floatIndex + 3] = distance;\n\n    floatIndex += 4; // each plane is 4 floats\n  }\n}\n\nconst scratchPlaneCartesian4 = new Cartesian4();\nconst scratchTransformedNormal = new Cartesian3();\n\nfunction transformPlane(plane, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  const { normal, distance } = plane;\n  const planeAsCartesian4 = Cartesian4.fromElements(\n    normal.x,\n    normal.y,\n    normal.z,\n    distance,\n    scratchPlaneCartesian4,\n  );\n  let transformedPlane = Matrix4.multiplyByVector(\n    transform,\n    planeAsCartesian4,\n    scratchPlaneCartesian4,\n  );\n\n  // Convert the transformed plane to Hessian Normal Form\n  const transformedNormal = Cartesian3.fromCartesian4(\n    transformedPlane,\n    scratchTransformedNormal,\n  );\n  transformedPlane = Cartesian4.divideByScalar(\n    transformedPlane,\n    Cartesian3.magnitude(transformedNormal),\n    scratchPlaneCartesian4,\n  );\n\n  return Plane.fromCartesian4(transformedPlane, result);\n}\n\nfunction computeTextureResolution(pixelsNeeded, result) {\n  result.x = Math.min(pixelsNeeded, ContextLimits.maximumTextureSize);\n  result.y = Math.ceil(pixelsNeeded / result.x);\n  return result;\n}\n\nconst textureResolutionScratch = new Cartesian2();\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * build the resources for clipping planes.\n * <p>\n * Do not call this function directly.\n * </p>\n */\nVoxelBoundsCollection.prototype.update = function (frameState, transform) {\n  let clippingPlanesTexture = this._clippingPlanesTexture;\n\n  // Compute texture requirements for current planes\n  // In RGBA FLOAT, a plane is 4 floats packed to a single RGBA pixel.\n  const pixelsNeeded = this.length;\n\n  if (defined(clippingPlanesTexture)) {\n    const currentPixelCount =\n      clippingPlanesTexture.width * clippingPlanesTexture.height;\n    // Recreate the texture to double current requirement if it isn't big enough or is 4 times larger than it needs to be.\n    // Optimization note: this isn't exactly the classic resizeable array algorithm\n    // * not necessarily checking for resize after each add/remove operation\n    // * random-access deletes instead of just pops\n    // * alloc ops likely more expensive than demonstrable via big-O analysis\n    if (\n      currentPixelCount < pixelsNeeded ||\n      pixelsNeeded < 0.25 * currentPixelCount\n    ) {\n      clippingPlanesTexture.destroy();\n      clippingPlanesTexture = undefined;\n      this._clippingPlanesTexture = undefined;\n    }\n  }\n\n  // If there are no bound planes, there's nothing to update.\n  if (this.length === 0) {\n    return;\n  }\n\n  if (!defined(clippingPlanesTexture)) {\n    const requiredResolution = computeTextureResolution(\n      pixelsNeeded,\n      textureResolutionScratch,\n    );\n    // Allocate twice as much space as needed to avoid frequent texture reallocation.\n    // Allocate in the Y direction, since texture may be as wide as context texture support.\n    requiredResolution.y *= 2;\n\n    clippingPlanesTexture = new Texture({\n      context: frameState.context,\n      width: requiredResolution.x,\n      height: requiredResolution.y,\n      pixelFormat: PixelFormat.RGBA,\n      pixelDatatype: PixelDatatype.FLOAT,\n      sampler: Sampler.NEAREST,\n      flipY: false,\n    });\n    this._float32View = new Float32Array(\n      requiredResolution.x * requiredResolution.y * 4,\n    );\n\n    this._clippingPlanesTexture = clippingPlanesTexture;\n  }\n\n  const { width, height } = clippingPlanesTexture;\n  transformAndPackPlanes(this, transform);\n  clippingPlanesTexture.copyFrom({\n    source: {\n      width: width,\n      height: height,\n      arrayBufferView: this._float32View,\n    },\n  });\n};\n\n/**\n * Function for getting the clipping plane collection's texture resolution.\n * If the VoxelBoundsCollection hasn't been updated, returns the resolution that will be\n * allocated based on the current plane count.\n *\n * @param {VoxelBoundsCollection} clippingPlaneCollection The clipping plane collection\n * @param {Context} context The rendering context\n * @param {Cartesian2} result A Cartesian2 for the result.\n * @returns {Cartesian2} The required resolution.\n * @private\n */\nVoxelBoundsCollection.getTextureResolution = function (\n  clippingPlaneCollection,\n  context,\n  result,\n) {\n  const texture = clippingPlaneCollection.texture;\n  if (defined(texture)) {\n    result.x = texture.width;\n    result.y = texture.height;\n    return result;\n  }\n\n  const pixelsNeeded = clippingPlaneCollection.length;\n  const requiredResolution = computeTextureResolution(pixelsNeeded, result);\n\n  // Allocate twice as much space as needed to avoid frequent texture reallocation.\n  requiredResolution.y *= 2;\n  return requiredResolution;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see VoxelBoundsCollection#destroy\n */\nVoxelBoundsCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * voxelBounds = voxelBounds && voxelBounds.destroy();\n *\n * @see VoxelBoundsCollection#isDestroyed\n */\nVoxelBoundsCollection.prototype.destroy = function () {\n  this._clippingPlanesTexture =\n    this._clippingPlanesTexture && this._clippingPlanesTexture.destroy();\n  return destroyObject(this);\n};\nexport default VoxelBoundsCollection;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}