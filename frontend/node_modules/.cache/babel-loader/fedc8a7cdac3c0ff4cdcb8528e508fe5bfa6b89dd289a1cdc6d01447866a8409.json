{"ast":null,"code":"import addAllToArray from \"../Core/addAllToArray.js\";\nimport defined from \"../Core/defined.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\n\n/**\n * Get an array of primitives for a given mesh. If the EXT_mesh_primitive_restart extension is present, use it to combine groups of primitives.\n * If the extension is not present or its spec is violated, return the original mesh.primitives.\n * @param {object} mesh A mesh from the glTF meshes array\n * @returns {object[]} An array of mesh primitives\n * @private\n */\nfunction getMeshPrimitives(mesh) {\n  const meshExtensions = mesh.extensions ?? Frozen.EMPTY_OBJECT;\n  const primitiveRestartExtension = meshExtensions.EXT_mesh_primitive_restart;\n  const meshPrimitives = mesh.primitives;\n  if (!defined(primitiveRestartExtension)) {\n    return meshPrimitives;\n  }\n\n  // Note: per the spec, any violation of the extension's specification should cause us to fall back to mesh.primitives, if detecting the violation is feasible.\n\n  // Start with a copy of mesh.primitives. For each group, replace the first primitive in the group with a primitive representing the entire group,\n  // and set the rest of the primitives in the group to `undefined`.\n  // This allows us to identify which remaining primitives do not use primitive restart, and any errors involving a primitive appearing in more than one group.\n  const primitives = [];\n  addAllToArray(primitives, meshPrimitives);\n  for (const group of primitiveRestartExtension.primitiveGroups) {\n    // Spec: the group must not be empty and all indices must be valid array indices into mesh.primitives.\n    const firstPrimitiveIndex = group.primitives[0];\n    if (!defined(firstPrimitiveIndex) || !meshPrimitives[firstPrimitiveIndex]) {\n      return meshPrimitives;\n    }\n    const primitive = {\n      ...meshPrimitives[firstPrimitiveIndex],\n      indices: group.indices\n    };\n\n    // Spec: primitive restart only supported for these topologies.\n    switch (primitive.mode) {\n      case WebGLConstants.TRIANGLE_FAN:\n      case WebGLConstants.TRIANGLE_STRIP:\n      case WebGLConstants.LINE_STRIP:\n      case WebGLConstants.LINE_LOOP:\n        break;\n      default:\n        return meshPrimitives;\n    }\n    for (const primitiveIndex of group.primitives) {\n      const thisPrimitive = primitives[primitiveIndex];\n\n      // Spec: all primitives must use indexed geometry and a given primitive may appear in at most one group.\n      // Spec: all primitives must have same topology.\n      if (!defined(thisPrimitive?.indices) || thisPrimitive.mode !== primitive.mode) {\n        return meshPrimitives;\n      }\n      primitives[primitiveIndex] = undefined;\n    }\n    primitives[firstPrimitiveIndex] = primitive;\n  }\n  return primitives.filter(defined);\n}\nexport default getMeshPrimitives;","map":{"version":3,"names":["addAllToArray","defined","Frozen","WebGLConstants","getMeshPrimitives","mesh","meshExtensions","extensions","EMPTY_OBJECT","primitiveRestartExtension","EXT_mesh_primitive_restart","meshPrimitives","primitives","group","primitiveGroups","firstPrimitiveIndex","primitive","indices","mode","TRIANGLE_FAN","TRIANGLE_STRIP","LINE_STRIP","LINE_LOOP","primitiveIndex","thisPrimitive","undefined","filter"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/getMeshPrimitives.js"],"sourcesContent":["import addAllToArray from \"../Core/addAllToArray.js\";\nimport defined from \"../Core/defined.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\n\n/**\n * Get an array of primitives for a given mesh. If the EXT_mesh_primitive_restart extension is present, use it to combine groups of primitives.\n * If the extension is not present or its spec is violated, return the original mesh.primitives.\n * @param {object} mesh A mesh from the glTF meshes array\n * @returns {object[]} An array of mesh primitives\n * @private\n */\nfunction getMeshPrimitives(mesh) {\n  const meshExtensions = mesh.extensions ?? Frozen.EMPTY_OBJECT;\n  const primitiveRestartExtension = meshExtensions.EXT_mesh_primitive_restart;\n  const meshPrimitives = mesh.primitives;\n\n  if (!defined(primitiveRestartExtension)) {\n    return meshPrimitives;\n  }\n\n  // Note: per the spec, any violation of the extension's specification should cause us to fall back to mesh.primitives, if detecting the violation is feasible.\n\n  // Start with a copy of mesh.primitives. For each group, replace the first primitive in the group with a primitive representing the entire group,\n  // and set the rest of the primitives in the group to `undefined`.\n  // This allows us to identify which remaining primitives do not use primitive restart, and any errors involving a primitive appearing in more than one group.\n  const primitives = [];\n  addAllToArray(primitives, meshPrimitives);\n  for (const group of primitiveRestartExtension.primitiveGroups) {\n    // Spec: the group must not be empty and all indices must be valid array indices into mesh.primitives.\n    const firstPrimitiveIndex = group.primitives[0];\n    if (!defined(firstPrimitiveIndex) || !meshPrimitives[firstPrimitiveIndex]) {\n      return meshPrimitives;\n    }\n\n    const primitive = {\n      ...meshPrimitives[firstPrimitiveIndex],\n      indices: group.indices,\n    };\n\n    // Spec: primitive restart only supported for these topologies.\n    switch (primitive.mode) {\n      case WebGLConstants.TRIANGLE_FAN:\n      case WebGLConstants.TRIANGLE_STRIP:\n      case WebGLConstants.LINE_STRIP:\n      case WebGLConstants.LINE_LOOP:\n        break;\n      default:\n        return meshPrimitives;\n    }\n\n    for (const primitiveIndex of group.primitives) {\n      const thisPrimitive = primitives[primitiveIndex];\n\n      // Spec: all primitives must use indexed geometry and a given primitive may appear in at most one group.\n      // Spec: all primitives must have same topology.\n      if (\n        !defined(thisPrimitive?.indices) ||\n        thisPrimitive.mode !== primitive.mode\n      ) {\n        return meshPrimitives;\n      }\n\n      primitives[primitiveIndex] = undefined;\n    }\n\n    primitives[firstPrimitiveIndex] = primitive;\n  }\n\n  return primitives.filter(defined);\n}\nexport default getMeshPrimitives;\n"],"mappings":"AAAA,OAAOA,aAAa,MAAM,0BAA0B;AACpD,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,MAAM,MAAM,mBAAmB;AACtC,OAAOC,cAAc,MAAM,2BAA2B;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,iBAAiBA,CAACC,IAAI,EAAE;EAC/B,MAAMC,cAAc,GAAGD,IAAI,CAACE,UAAU,IAAIL,MAAM,CAACM,YAAY;EAC7D,MAAMC,yBAAyB,GAAGH,cAAc,CAACI,0BAA0B;EAC3E,MAAMC,cAAc,GAAGN,IAAI,CAACO,UAAU;EAEtC,IAAI,CAACX,OAAO,CAACQ,yBAAyB,CAAC,EAAE;IACvC,OAAOE,cAAc;EACvB;;EAEA;;EAEA;EACA;EACA;EACA,MAAMC,UAAU,GAAG,EAAE;EACrBZ,aAAa,CAACY,UAAU,EAAED,cAAc,CAAC;EACzC,KAAK,MAAME,KAAK,IAAIJ,yBAAyB,CAACK,eAAe,EAAE;IAC7D;IACA,MAAMC,mBAAmB,GAAGF,KAAK,CAACD,UAAU,CAAC,CAAC,CAAC;IAC/C,IAAI,CAACX,OAAO,CAACc,mBAAmB,CAAC,IAAI,CAACJ,cAAc,CAACI,mBAAmB,CAAC,EAAE;MACzE,OAAOJ,cAAc;IACvB;IAEA,MAAMK,SAAS,GAAG;MAChB,GAAGL,cAAc,CAACI,mBAAmB,CAAC;MACtCE,OAAO,EAAEJ,KAAK,CAACI;IACjB,CAAC;;IAED;IACA,QAAQD,SAAS,CAACE,IAAI;MACpB,KAAKf,cAAc,CAACgB,YAAY;MAChC,KAAKhB,cAAc,CAACiB,cAAc;MAClC,KAAKjB,cAAc,CAACkB,UAAU;MAC9B,KAAKlB,cAAc,CAACmB,SAAS;QAC3B;MACF;QACE,OAAOX,cAAc;IACzB;IAEA,KAAK,MAAMY,cAAc,IAAIV,KAAK,CAACD,UAAU,EAAE;MAC7C,MAAMY,aAAa,GAAGZ,UAAU,CAACW,cAAc,CAAC;;MAEhD;MACA;MACA,IACE,CAACtB,OAAO,CAACuB,aAAa,EAAEP,OAAO,CAAC,IAChCO,aAAa,CAACN,IAAI,KAAKF,SAAS,CAACE,IAAI,EACrC;QACA,OAAOP,cAAc;MACvB;MAEAC,UAAU,CAACW,cAAc,CAAC,GAAGE,SAAS;IACxC;IAEAb,UAAU,CAACG,mBAAmB,CAAC,GAAGC,SAAS;EAC7C;EAEA,OAAOJ,UAAU,CAACc,MAAM,CAACzB,OAAO,CAAC;AACnC;AACA,eAAeG,iBAAiB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}