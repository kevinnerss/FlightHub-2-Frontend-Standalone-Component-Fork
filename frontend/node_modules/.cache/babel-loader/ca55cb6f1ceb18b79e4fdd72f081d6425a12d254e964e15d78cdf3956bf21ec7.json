{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\n\n/**\n * A cell from a {@link VoxelPrimitive}.\n * <p>\n * Provides access to properties associated with one cell of a voxel primitive.\n * </p>\n * <p>\n * Do not construct this directly.  Access it through picking using {@link Scene#pickVoxel}.\n * </p>\n *\n * @alias VoxelCell\n * @constructor\n *\n * @param {VoxelPrimitive} primitive The voxel primitive containing the cell\n * @param {number} tileIndex The index of the tile\n * @param {number} sampleIndex The index of the sample within the tile, containing metadata for this cell\n *\n * @example\n * // On left click, display all the properties for a voxel cell in the console log.\n * handler.setInputAction(function(movement) {\n *   const voxelCell = scene.pickVoxel(movement.position);\n *   if (voxelCell instanceof Cesium.VoxelCell) {\n *     const propertyIds = voxelCell.getPropertyIds();\n *     const length = propertyIds.length;\n *     for (let i = 0; i < length; ++i) {\n *       const propertyId = propertyIds[i];\n *       console.log(`{propertyId}: ${voxelCell.getProperty(propertyId)}`);\n *     }\n *   }\n * }, Cesium.ScreenSpaceEventType.LEFT_CLICK);\n *\n * @experimental This feature is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction VoxelCell(primitive, tileIndex, sampleIndex) {\n  this._primitive = primitive;\n  this._tileIndex = tileIndex;\n  this._sampleIndex = sampleIndex;\n  this._metadata = {};\n  this._orientedBoundingBox = new OrientedBoundingBox();\n}\n\n/**\n * Construct a VoxelCell, and update the metadata and bounding box using the properties\n * of a supplied keyframe node.\n *\n * @private\n * @param {VoxelPrimitive} primitive The voxel primitive containing the cell.\n * @param {number} tileIndex The index of the tile.\n * @param {number} sampleIndex The index of the sample within the tile, containing metadata for this cell.\n * @param {KeyframeNode} keyframeNode The keyframe node containing information about the tile.\n * @returns {VoxelCell}\n *\n * @experimental This feature is not final and is subject to change without Cesium's standard deprecation policy.\n */\nVoxelCell.fromKeyframeNode = function (primitive, tileIndex, sampleIndex, keyframeNode) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"primitive\", primitive);\n  Check.typeOf.number(\"tileIndex\", tileIndex);\n  Check.typeOf.number(\"sampleIndex\", sampleIndex);\n  Check.typeOf.object(\"keyframeNode\", keyframeNode);\n  //>>includeEnd('debug');\n\n  const voxelCell = new VoxelCell(primitive, tileIndex, sampleIndex);\n  const {\n    spatialNode,\n    content\n  } = keyframeNode;\n  voxelCell._metadata = getMetadataForSample(primitive, content, sampleIndex);\n  voxelCell._orientedBoundingBox = getOrientedBoundingBox(primitive, spatialNode, sampleIndex, voxelCell._orientedBoundingBox);\n  return voxelCell;\n};\n\n/**\n * @private\n * @param {VoxelPrimitive} primitive\n * @param {VoxelContent} content\n * @param {number} sampleIndex\n * @returns {object}\n */\nfunction getMetadataForSample(primitive, content, sampleIndex) {\n  if (!defined(content) || !defined(content.metadata)) {\n    return undefined;\n  }\n  const {\n    names,\n    types\n  } = primitive.provider;\n  const {\n    metadata\n  } = content;\n  const metadataMap = {};\n  for (let i = 0; i < names.length; i++) {\n    const name = names[i];\n    const componentCount = MetadataType.getComponentCount(types[i]);\n    const samples = metadata[i].slice(sampleIndex * componentCount, (sampleIndex + 1) * componentCount);\n    metadataMap[name] = samples;\n  }\n  return metadataMap;\n}\nconst tileCoordinateScratch = new Cartesian3();\nconst tileUvScratch = new Cartesian3();\n\n/**\n * @private\n * @param {VoxelPrimitive} primitive\n * @param {SpatialNode} spatialNode\n * @param {OrientedBoundingBox} result\n * @returns {OrientedBoundingBox}\n */\nfunction getOrientedBoundingBox(primitive, spatialNode, sampleIndex, result) {\n  // Convert the sample index into a 3D tile coordinate\n  // Note: dimensions from the spatialNode include padding\n  const paddedDimensions = spatialNode.dimensions;\n  const sliceSize = paddedDimensions.x * paddedDimensions.y;\n  const zIndex = Math.floor(sampleIndex / sliceSize);\n  const indexInSlice = sampleIndex - zIndex * sliceSize;\n  const yIndex = Math.floor(indexInSlice / paddedDimensions.x);\n  const xIndex = indexInSlice - yIndex * paddedDimensions.x;\n  const tileCoordinate = Cartesian3.fromElements(xIndex, yIndex, zIndex, tileCoordinateScratch);\n\n  // Remove padding, and convert to a fraction in [0, 1], where the limits are\n  // the unpadded bounds of the tile\n  const tileUv = Cartesian3.divideComponents(Cartesian3.subtract(tileCoordinate, primitive._paddingBefore, tileCoordinateScratch), primitive.dimensions, tileUvScratch);\n  const shape = primitive._shape;\n  return shape.computeOrientedBoundingBoxForSample(spatialNode, primitive.dimensions, tileUv, result);\n}\nObject.defineProperties(VoxelCell.prototype, {\n  /**\n   * Gets an object of the metadata values for this cell. The object's keys are the metadata names.\n   *\n   * @memberof VoxelCell.prototype\n   *\n   * @type {object}\n   *\n   * @readonly\n   * @private\n   */\n  metadata: {\n    get: function () {\n      return this._metadata;\n    }\n  },\n  /**\n   * All objects returned by {@link Scene#pick} have a <code>primitive</code> property. This returns\n   * the VoxelPrimitive containing the cell.\n   *\n   * @memberof VoxelCell.prototype\n   *\n   * @type {VoxelPrimitive}\n   *\n   * @readonly\n   */\n  primitive: {\n    get: function () {\n      return this._primitive;\n    }\n  },\n  /**\n   * Get the sample index of the cell.\n   *\n   * @memberof VoxelCell.prototype\n   *\n   * @type {number}\n   *\n   * @readonly\n   */\n  sampleIndex: {\n    get: function () {\n      return this._sampleIndex;\n    }\n  },\n  /**\n   * Get the index of the tile containing the cell.\n   *\n   * @memberof VoxelCell.prototype\n   *\n   * @type {number}\n   *\n   * @readonly\n   */\n  tileIndex: {\n    get: function () {\n      return this._tileIndex;\n    }\n  },\n  /**\n   * Get a copy of the oriented bounding box containing the cell.\n   *\n   * @memberof VoxelCell.prototype\n   *\n   * @type {OrientedBoundingBox}\n   *\n   * @readonly\n   */\n  orientedBoundingBox: {\n    get: function () {\n      return this._orientedBoundingBox.clone();\n    }\n  }\n});\n\n/**\n * Returns <code>true</code> if the feature contains this property.\n *\n * @param {string} name The case-sensitive name of the property.\n * @returns {boolean} Whether the feature contains this property.\n */\nVoxelCell.prototype.hasProperty = function (name) {\n  return defined(this._metadata[name]);\n};\n\n/**\n * Returns an array of metadata property names for the feature.\n *\n * @returns {string[]} The IDs of the feature's properties.\n */\nVoxelCell.prototype.getNames = function () {\n  return Object.keys(this._metadata);\n};\n\n/**\n * Returns a copy of the value of the metadata in the cell with the given name.\n *\n * @param {string} name The case-sensitive name of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the feature does not have this property.\n *\n * @example\n * // Display all the properties for a voxel cell in the console log.\n * const names = voxelCell.getNames();\n * for (let i = 0; i < names.length; ++i) {\n *   const name = names[i];\n *   console.log(`{name}: ${voxelCell.getProperty(name)}`);\n * }\n */\nVoxelCell.prototype.getProperty = function (name) {\n  return this._metadata[name];\n};\nexport default VoxelCell;","map":{"version":3,"names":["Cartesian3","Check","defined","MetadataType","OrientedBoundingBox","VoxelCell","primitive","tileIndex","sampleIndex","_primitive","_tileIndex","_sampleIndex","_metadata","_orientedBoundingBox","fromKeyframeNode","keyframeNode","typeOf","object","number","voxelCell","spatialNode","content","getMetadataForSample","getOrientedBoundingBox","metadata","undefined","names","types","provider","metadataMap","i","length","name","componentCount","getComponentCount","samples","slice","tileCoordinateScratch","tileUvScratch","result","paddedDimensions","dimensions","sliceSize","x","y","zIndex","Math","floor","indexInSlice","yIndex","xIndex","tileCoordinate","fromElements","tileUv","divideComponents","subtract","_paddingBefore","shape","_shape","computeOrientedBoundingBoxForSample","Object","defineProperties","prototype","get","orientedBoundingBox","clone","hasProperty","getNames","keys","getProperty"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/VoxelCell.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\n\n/**\n * A cell from a {@link VoxelPrimitive}.\n * <p>\n * Provides access to properties associated with one cell of a voxel primitive.\n * </p>\n * <p>\n * Do not construct this directly.  Access it through picking using {@link Scene#pickVoxel}.\n * </p>\n *\n * @alias VoxelCell\n * @constructor\n *\n * @param {VoxelPrimitive} primitive The voxel primitive containing the cell\n * @param {number} tileIndex The index of the tile\n * @param {number} sampleIndex The index of the sample within the tile, containing metadata for this cell\n *\n * @example\n * // On left click, display all the properties for a voxel cell in the console log.\n * handler.setInputAction(function(movement) {\n *   const voxelCell = scene.pickVoxel(movement.position);\n *   if (voxelCell instanceof Cesium.VoxelCell) {\n *     const propertyIds = voxelCell.getPropertyIds();\n *     const length = propertyIds.length;\n *     for (let i = 0; i < length; ++i) {\n *       const propertyId = propertyIds[i];\n *       console.log(`{propertyId}: ${voxelCell.getProperty(propertyId)}`);\n *     }\n *   }\n * }, Cesium.ScreenSpaceEventType.LEFT_CLICK);\n *\n * @experimental This feature is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction VoxelCell(primitive, tileIndex, sampleIndex) {\n  this._primitive = primitive;\n  this._tileIndex = tileIndex;\n  this._sampleIndex = sampleIndex;\n  this._metadata = {};\n  this._orientedBoundingBox = new OrientedBoundingBox();\n}\n\n/**\n * Construct a VoxelCell, and update the metadata and bounding box using the properties\n * of a supplied keyframe node.\n *\n * @private\n * @param {VoxelPrimitive} primitive The voxel primitive containing the cell.\n * @param {number} tileIndex The index of the tile.\n * @param {number} sampleIndex The index of the sample within the tile, containing metadata for this cell.\n * @param {KeyframeNode} keyframeNode The keyframe node containing information about the tile.\n * @returns {VoxelCell}\n *\n * @experimental This feature is not final and is subject to change without Cesium's standard deprecation policy.\n */\nVoxelCell.fromKeyframeNode = function (\n  primitive,\n  tileIndex,\n  sampleIndex,\n  keyframeNode,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"primitive\", primitive);\n  Check.typeOf.number(\"tileIndex\", tileIndex);\n  Check.typeOf.number(\"sampleIndex\", sampleIndex);\n  Check.typeOf.object(\"keyframeNode\", keyframeNode);\n  //>>includeEnd('debug');\n\n  const voxelCell = new VoxelCell(primitive, tileIndex, sampleIndex);\n  const { spatialNode, content } = keyframeNode;\n  voxelCell._metadata = getMetadataForSample(primitive, content, sampleIndex);\n  voxelCell._orientedBoundingBox = getOrientedBoundingBox(\n    primitive,\n    spatialNode,\n    sampleIndex,\n    voxelCell._orientedBoundingBox,\n  );\n  return voxelCell;\n};\n\n/**\n * @private\n * @param {VoxelPrimitive} primitive\n * @param {VoxelContent} content\n * @param {number} sampleIndex\n * @returns {object}\n */\nfunction getMetadataForSample(primitive, content, sampleIndex) {\n  if (!defined(content) || !defined(content.metadata)) {\n    return undefined;\n  }\n  const { names, types } = primitive.provider;\n  const { metadata } = content;\n  const metadataMap = {};\n  for (let i = 0; i < names.length; i++) {\n    const name = names[i];\n    const componentCount = MetadataType.getComponentCount(types[i]);\n    const samples = metadata[i].slice(\n      sampleIndex * componentCount,\n      (sampleIndex + 1) * componentCount,\n    );\n    metadataMap[name] = samples;\n  }\n  return metadataMap;\n}\n\nconst tileCoordinateScratch = new Cartesian3();\nconst tileUvScratch = new Cartesian3();\n\n/**\n * @private\n * @param {VoxelPrimitive} primitive\n * @param {SpatialNode} spatialNode\n * @param {OrientedBoundingBox} result\n * @returns {OrientedBoundingBox}\n */\nfunction getOrientedBoundingBox(primitive, spatialNode, sampleIndex, result) {\n  // Convert the sample index into a 3D tile coordinate\n  // Note: dimensions from the spatialNode include padding\n  const paddedDimensions = spatialNode.dimensions;\n  const sliceSize = paddedDimensions.x * paddedDimensions.y;\n  const zIndex = Math.floor(sampleIndex / sliceSize);\n  const indexInSlice = sampleIndex - zIndex * sliceSize;\n  const yIndex = Math.floor(indexInSlice / paddedDimensions.x);\n  const xIndex = indexInSlice - yIndex * paddedDimensions.x;\n  const tileCoordinate = Cartesian3.fromElements(\n    xIndex,\n    yIndex,\n    zIndex,\n    tileCoordinateScratch,\n  );\n\n  // Remove padding, and convert to a fraction in [0, 1], where the limits are\n  // the unpadded bounds of the tile\n  const tileUv = Cartesian3.divideComponents(\n    Cartesian3.subtract(\n      tileCoordinate,\n      primitive._paddingBefore,\n      tileCoordinateScratch,\n    ),\n    primitive.dimensions,\n    tileUvScratch,\n  );\n\n  const shape = primitive._shape;\n  return shape.computeOrientedBoundingBoxForSample(\n    spatialNode,\n    primitive.dimensions,\n    tileUv,\n    result,\n  );\n}\n\nObject.defineProperties(VoxelCell.prototype, {\n  /**\n   * Gets an object of the metadata values for this cell. The object's keys are the metadata names.\n   *\n   * @memberof VoxelCell.prototype\n   *\n   * @type {object}\n   *\n   * @readonly\n   * @private\n   */\n  metadata: {\n    get: function () {\n      return this._metadata;\n    },\n  },\n\n  /**\n   * All objects returned by {@link Scene#pick} have a <code>primitive</code> property. This returns\n   * the VoxelPrimitive containing the cell.\n   *\n   * @memberof VoxelCell.prototype\n   *\n   * @type {VoxelPrimitive}\n   *\n   * @readonly\n   */\n  primitive: {\n    get: function () {\n      return this._primitive;\n    },\n  },\n\n  /**\n   * Get the sample index of the cell.\n   *\n   * @memberof VoxelCell.prototype\n   *\n   * @type {number}\n   *\n   * @readonly\n   */\n  sampleIndex: {\n    get: function () {\n      return this._sampleIndex;\n    },\n  },\n\n  /**\n   * Get the index of the tile containing the cell.\n   *\n   * @memberof VoxelCell.prototype\n   *\n   * @type {number}\n   *\n   * @readonly\n   */\n  tileIndex: {\n    get: function () {\n      return this._tileIndex;\n    },\n  },\n\n  /**\n   * Get a copy of the oriented bounding box containing the cell.\n   *\n   * @memberof VoxelCell.prototype\n   *\n   * @type {OrientedBoundingBox}\n   *\n   * @readonly\n   */\n  orientedBoundingBox: {\n    get: function () {\n      return this._orientedBoundingBox.clone();\n    },\n  },\n});\n\n/**\n * Returns <code>true</code> if the feature contains this property.\n *\n * @param {string} name The case-sensitive name of the property.\n * @returns {boolean} Whether the feature contains this property.\n */\nVoxelCell.prototype.hasProperty = function (name) {\n  return defined(this._metadata[name]);\n};\n\n/**\n * Returns an array of metadata property names for the feature.\n *\n * @returns {string[]} The IDs of the feature's properties.\n */\nVoxelCell.prototype.getNames = function () {\n  return Object.keys(this._metadata);\n};\n\n/**\n * Returns a copy of the value of the metadata in the cell with the given name.\n *\n * @param {string} name The case-sensitive name of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the feature does not have this property.\n *\n * @example\n * // Display all the properties for a voxel cell in the console log.\n * const names = voxelCell.getNames();\n * for (let i = 0; i < names.length; ++i) {\n *   const name = names[i];\n *   console.log(`{name}: ${voxelCell.getProperty(name)}`);\n * }\n */\nVoxelCell.prototype.getProperty = function (name) {\n  return this._metadata[name];\n};\n\nexport default VoxelCell;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}