{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"float getSignedDistance(vec2 uv, highp sampler2D clippingDistance) {\\n\\\n    float signedDistance = texture(clippingDistance, uv).r;\\n\\\n    return (signedDistance - 0.5) * 2.0;\\n\\\n}\\n\\\n\\n\\\nvoid czm_clipPolygons(highp sampler2D clippingDistance, int extentsLength, vec2 clippingPosition, int regionIndex) {\\n\\\n    // Position is completely outside of polygons bounds\\n\\\n    vec2 rectUv = clippingPosition;\\n\\\n    if (regionIndex < 0 || rectUv.x <= 0.0 || rectUv.y <= 0.0 || rectUv.x >= 1.0 || rectUv.y >= 1.0) {\\n\\\n        #ifdef CLIPPING_INVERSE \\n\\\n            discard;\\n\\\n        #endif\\n\\\n        return;\\n\\\n    }\\n\\\n\\n\\\n    vec2 clippingDistanceTextureDimensions = vec2(textureSize(clippingDistance, 0));\\n\\\n    vec2 sampleOffset = max(1.0 / clippingDistanceTextureDimensions, vec2(0.005));\\n\\\n    float dimension = float(extentsLength);\\n\\\n    if (extentsLength > 2) {\\n\\\n       dimension = ceil(log2(float(extentsLength)));\\n\\\n    }\\n\\\n\\n\\\n    vec2 textureOffset = vec2(mod(float(regionIndex), dimension), floor(float(regionIndex) / dimension)) / dimension;\\n\\\n    vec2 uv = textureOffset + rectUv / dimension;\\n\\\n\\n\\\n    float signedDistance = getSignedDistance(uv, clippingDistance);\\n\\\n\\n\\\n    #ifdef CLIPPING_INVERSE\\n\\\n    if (signedDistance > 0.0)  {\\n\\\n        discard;\\n\\\n    }\\n\\\n    #else\\n\\\n    if (signedDistance < 0.0)  {\\n\\\n        discard;\\n\\\n    }\\n\\\n    #endif\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Shaders/Builtin/Functions/clipPolygons.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"float getSignedDistance(vec2 uv, highp sampler2D clippingDistance) {\\n\\\n    float signedDistance = texture(clippingDistance, uv).r;\\n\\\n    return (signedDistance - 0.5) * 2.0;\\n\\\n}\\n\\\n\\n\\\nvoid czm_clipPolygons(highp sampler2D clippingDistance, int extentsLength, vec2 clippingPosition, int regionIndex) {\\n\\\n    // Position is completely outside of polygons bounds\\n\\\n    vec2 rectUv = clippingPosition;\\n\\\n    if (regionIndex < 0 || rectUv.x <= 0.0 || rectUv.y <= 0.0 || rectUv.x >= 1.0 || rectUv.y >= 1.0) {\\n\\\n        #ifdef CLIPPING_INVERSE \\n\\\n            discard;\\n\\\n        #endif\\n\\\n        return;\\n\\\n    }\\n\\\n\\n\\\n    vec2 clippingDistanceTextureDimensions = vec2(textureSize(clippingDistance, 0));\\n\\\n    vec2 sampleOffset = max(1.0 / clippingDistanceTextureDimensions, vec2(0.005));\\n\\\n    float dimension = float(extentsLength);\\n\\\n    if (extentsLength > 2) {\\n\\\n       dimension = ceil(log2(float(extentsLength)));\\n\\\n    }\\n\\\n\\n\\\n    vec2 textureOffset = vec2(mod(float(regionIndex), dimension), floor(float(regionIndex) / dimension)) / dimension;\\n\\\n    vec2 uv = textureOffset + rectUv / dimension;\\n\\\n\\n\\\n    float signedDistance = getSignedDistance(uv, clippingDistance);\\n\\\n\\n\\\n    #ifdef CLIPPING_INVERSE\\n\\\n    if (signedDistance > 0.0)  {\\n\\\n        discard;\\n\\\n    }\\n\\\n    #else\\n\\\n    if (signedDistance < 0.0)  {\\n\\\n        discard;\\n\\\n    }\\n\\\n    #endif\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}