{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport { UrlMatch } from '../match/url-match';\nimport { assertNever } from '../utils';\nimport { httpSchemeRe, isDomainLabelChar, isDomainLabelStartChar, isPathChar, isSchemeChar, isSchemeStartChar, isUrlSuffixStartChar, isValidIpV4Address, isValidSchemeUrl, isValidTldMatch } from './uri-utils';\nimport { isEmailLocalPartChar, isEmailLocalPartStartChar, isValidEmail, mailtoSchemePrefixRe } from './email-utils';\nimport { EmailMatch } from '../match/email-match';\nimport { isHashtagTextChar, isValidHashtag } from './hashtag-utils';\nimport { HashtagMatch } from '../match/hashtag-match';\nimport { isMentionTextChar, isValidMention } from './mention-utils';\nimport { MentionMatch } from '../match/mention-match';\nimport { isPhoneNumberSeparatorChar, isPhoneNumberControlChar, isValidPhoneNumber } from './phone-number-utils';\nimport { PhoneMatch } from '../match/phone-match';\nimport { isAlphaNumericOrMarkChar, isCloseBraceChar, isDigitChar, isOpenBraceChar, isUrlSuffixNotAllowedAsFinalChar } from '../char-utils';\n// For debugging: search for and uncomment other \"For debugging\" lines\n// import CliTable from 'cli-table';\n/**\n * Context object containing all the state needed by the state machine functions.\n *\n * ## Historical note\n *\n * In v4.1.1, we used nested functions to handle the context via closures, but\n * this necessitated re-creating the functions for each call to `parseMatches()`,\n * which made them difficult for v8 to JIT optimize. In v4.1.2, we lifted all of\n * the functions to the top-level scope and passed the context object between\n * them, which allows the functions to be JIT compiled once and reused.\n */\nvar ParseMatchesContext = /** @class */function () {\n  function ParseMatchesContext(text, args) {\n    this.charIdx = 0; // Current character index being processed\n    this.matches = []; // Collection of matches found\n    this._stateMachines = []; // Array of active state machines\n    this.schemeUrlMachinesCount = 0; // part of an optimization to remove the need to go into a slow code block when unnecessary. Since it's been so long since the initial implementation, not sure that this can ever go above 1, but keeping it as a counter to be safe\n    this.text = text;\n    this.tagBuilder = args.tagBuilder;\n    this.stripPrefix = args.stripPrefix;\n    this.stripTrailingSlash = args.stripTrailingSlash;\n    this.decodePercentEncoding = args.decodePercentEncoding;\n    this.hashtagServiceName = args.hashtagServiceName;\n    this.mentionServiceName = args.mentionServiceName;\n  }\n  Object.defineProperty(ParseMatchesContext.prototype, \"stateMachines\", {\n    get: function () {\n      return this._stateMachines;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  ParseMatchesContext.prototype.addMachine = function (stateMachine) {\n    this._stateMachines.push(stateMachine);\n    if (isSchemeUrlStateMachine(stateMachine)) {\n      this.schemeUrlMachinesCount++;\n    }\n  };\n  ParseMatchesContext.prototype.removeMachine = function (stateMachine) {\n    // Performance note: this was originally implemented with Array.prototype.splice()\n    // and mutated the array in place. Switching to filter added ~280ops/sec\n    // on the benchmark, although likely at the expense of GC time. Perhaps\n    // in the future, we implement a rotating array so we never need to move\n    // or clean anything up\n    this._stateMachines = this._stateMachines.filter(function (m) {\n      return m !== stateMachine;\n    });\n    // If we've removed the URL state machine, set the flag to false.\n    // This flag is a quick test that helps us skip a slow section of\n    // code when there is already a URL state machine present.\n    if (isSchemeUrlStateMachine(stateMachine)) {\n      this.schemeUrlMachinesCount--;\n    }\n  };\n  ParseMatchesContext.prototype.hasSchemeUrlMachine = function () {\n    return this.schemeUrlMachinesCount > 0;\n  };\n  return ParseMatchesContext;\n}();\n/**\n * Parses URL, email, twitter, mention, and hashtag matches from the given\n * `text`.\n */\nexport function parseMatches(text, args) {\n  // Create the context object that will be passed to all state functions\n  var context = new ParseMatchesContext(text, args);\n  // For debugging: search for and uncomment other \"For debugging\" lines\n  // const table = new CliTable({\n  //     head: ['charIdx', 'char', 'code', 'type', 'states', 'startIdx', 'reached accept state'],\n  // });\n  for (; context.charIdx < context.text.length; context.charIdx++) {\n    var char = text.charAt(context.charIdx);\n    var charCode = text.charCodeAt(context.charIdx);\n    if (context.stateMachines.length === 0) {\n      stateNoMatch(context, char, charCode);\n    } else {\n      // Must loop through the state machines backwards for when one\n      // is removed\n      for (var stateIdx = context.stateMachines.length - 1; stateIdx >= 0; stateIdx--) {\n        var stateMachine = context.stateMachines[stateIdx];\n        switch (stateMachine.state) {\n          // Protocol-relative URL states\n          case 11 /* State.ProtocolRelativeSlash1 */:\n            stateProtocolRelativeSlash1(context, stateMachine, charCode);\n            break;\n          case 12 /* State.ProtocolRelativeSlash2 */:\n            stateProtocolRelativeSlash2(context, stateMachine, charCode);\n            break;\n          case 0 /* State.SchemeChar */:\n            stateSchemeChar(context, stateMachine, charCode);\n            break;\n          case 1 /* State.SchemeHyphen */:\n            stateSchemeHyphen(context, stateMachine, charCode);\n            break;\n          case 2 /* State.SchemeColon */:\n            stateSchemeColon(context, stateMachine, charCode);\n            break;\n          case 3 /* State.SchemeSlash1 */:\n            stateSchemeSlash1(context, stateMachine, charCode);\n            break;\n          case 4 /* State.SchemeSlash2 */:\n            stateSchemeSlash2(context, stateMachine, char, charCode);\n            break;\n          case 5 /* State.DomainLabelChar */:\n            stateDomainLabelChar(context, stateMachine, charCode);\n            break;\n          case 6 /* State.DomainHyphen */:\n            stateDomainHyphen(context, stateMachine, char, charCode);\n            break;\n          case 7 /* State.DomainDot */:\n            stateDomainDot(context, stateMachine, char, charCode);\n            break;\n          case 13 /* State.IpV4Digit */:\n            stateIpV4Digit(context, stateMachine, charCode);\n            break;\n          case 14 /* State.IpV4Dot */:\n            stateIpV4Dot(context, stateMachine, charCode);\n            break;\n          case 8 /* State.PortColon */:\n            statePortColon(context, stateMachine, charCode);\n            break;\n          case 9 /* State.PortNumber */:\n            statePortNumber(context, stateMachine, charCode);\n            break;\n          case 10 /* State.Path */:\n            statePath(context, stateMachine, charCode);\n            break;\n          // Email States\n          case 15 /* State.EmailMailto_M */:\n            stateEmailMailto_M(context, stateMachine, char, charCode);\n            break;\n          case 16 /* State.EmailMailto_A */:\n            stateEmailMailto_A(context, stateMachine, char, charCode);\n            break;\n          case 17 /* State.EmailMailto_I */:\n            stateEmailMailto_I(context, stateMachine, char, charCode);\n            break;\n          case 18 /* State.EmailMailto_L */:\n            stateEmailMailto_L(context, stateMachine, char, charCode);\n            break;\n          case 19 /* State.EmailMailto_T */:\n            stateEmailMailto_T(context, stateMachine, char, charCode);\n            break;\n          case 20 /* State.EmailMailto_O */:\n            stateEmailMailto_O(context, stateMachine, charCode);\n            break;\n          case 21 /* State.EmailMailto_Colon */:\n            stateEmailMailtoColon(context, stateMachine, charCode);\n            break;\n          case 22 /* State.EmailLocalPart */:\n            stateEmailLocalPart(context, stateMachine, charCode);\n            break;\n          case 23 /* State.EmailLocalPartDot */:\n            stateEmailLocalPartDot(context, stateMachine, charCode);\n            break;\n          case 24 /* State.EmailAtSign */:\n            stateEmailAtSign(context, stateMachine, charCode);\n            break;\n          case 25 /* State.EmailDomainChar */:\n            stateEmailDomainChar(context, stateMachine, charCode);\n            break;\n          case 26 /* State.EmailDomainHyphen */:\n            stateEmailDomainHyphen(context, stateMachine, charCode);\n            break;\n          case 27 /* State.EmailDomainDot */:\n            stateEmailDomainDot(context, stateMachine, charCode);\n            break;\n          // Hashtag states\n          case 28 /* State.HashtagHashChar */:\n            stateHashtagHashChar(context, stateMachine, charCode);\n            break;\n          case 29 /* State.HashtagTextChar */:\n            stateHashtagTextChar(context, stateMachine, charCode);\n            break;\n          // Mention states\n          case 30 /* State.MentionAtChar */:\n            stateMentionAtChar(context, stateMachine, charCode);\n            break;\n          case 31 /* State.MentionTextChar */:\n            stateMentionTextChar(context, stateMachine, charCode);\n            break;\n          // Phone number states\n          case 32 /* State.PhoneNumberOpenParen */:\n            statePhoneNumberOpenParen(context, stateMachine, char, charCode);\n            break;\n          case 33 /* State.PhoneNumberAreaCodeDigit1 */:\n            statePhoneNumberAreaCodeDigit1(context, stateMachine, charCode);\n            break;\n          case 34 /* State.PhoneNumberAreaCodeDigit2 */:\n            statePhoneNumberAreaCodeDigit2(context, stateMachine, charCode);\n            break;\n          case 35 /* State.PhoneNumberAreaCodeDigit3 */:\n            statePhoneNumberAreaCodeDigit3(context, stateMachine, charCode);\n            break;\n          case 36 /* State.PhoneNumberCloseParen */:\n            statePhoneNumberCloseParen(context, stateMachine, char, charCode);\n            break;\n          case 37 /* State.PhoneNumberPlus */:\n            statePhoneNumberPlus(context, stateMachine, char, charCode);\n            break;\n          case 38 /* State.PhoneNumberDigit */:\n            statePhoneNumberDigit(context, stateMachine, char, charCode);\n            break;\n          case 39 /* State.PhoneNumberSeparator */:\n            statePhoneNumberSeparator(context, stateMachine, char, charCode);\n            break;\n          case 40 /* State.PhoneNumberControlChar */:\n            statePhoneNumberControlChar(context, stateMachine, charCode);\n            break;\n          case 41 /* State.PhoneNumberPoundChar */:\n            statePhoneNumberPoundChar(context, stateMachine, charCode);\n            break;\n          /* istanbul ignore next */\n          default:\n            assertNever(stateMachine.state);\n        }\n      }\n      // Special case for handling a colon (or other non-alphanumeric)\n      // when preceded by another character, such as in the text:\n      //     Link 1:http://google.com\n      // In this case, the 'h' character after the colon wouldn't start a\n      // new scheme url because we'd be in a ipv4 or tld url and the colon\n      // would be interpreted as a port ':' char. Also, only start a new\n      // scheme url machine if there isn't currently one so we don't start\n      // new ones for colons inside a url\n      //\n      // TODO: The addition of this snippet (to fix the bug) in 4.0.1 lost\n      // us ~500 ops/sec on the benchmarks. Optimizing it with the\n      // hasSchemeUrlMachine() flag and optimizing the isSchemeStartChar()\n      // method for 4.1.3 got us back about ~400ops/sec. One potential way\n      // to improve this even ore is to add this snippet to individual\n      // state handler functions where it can occur to prevent running it\n      // on every loop interation.\n      if (!context.hasSchemeUrlMachine() && context.charIdx > 0 && isSchemeStartChar(charCode)) {\n        var prevCharCode = context.text.charCodeAt(context.charIdx - 1);\n        if (!isSchemeStartChar(prevCharCode)) {\n          context.addMachine(createSchemeUrlStateMachine(context.charIdx, 0 /* State.SchemeChar */));\n        }\n      }\n    }\n    // For debugging: search for and uncomment other \"For debugging\" lines\n    // table.push([\n    //     String(context.charIdx),\n    //     char,\n    //     `10: ${char.charCodeAt(0)}\\n0x: ${char.charCodeAt(0).toString(16)}\\nU+${char.codePointAt(0)}`,\n    //     context.stateMachines.map(machine => `${StateMachineType[machine.type]}${'matchType' in machine ? ` (${UrlStateMachineMatchType[machine.matchType]})` : ''}`).join('\\n') || '(none)',\n    //     context.stateMachines.map(machine => State[machine.state]).join('\\n') || '(none)',\n    //     context.stateMachines.map(m => m.startIdx).join('\\n'),\n    //     context.stateMachines.map(m => m.acceptStateReached).join('\\n'),\n    // ]);\n  }\n  // Capture any valid match at the end of the string\n  // Note: this loop must happen in reverse because\n  // captureMatchIfValidAndRemove() removes state machines from the array\n  // and we'll end up skipping every other one if we remove while looping\n  // forward\n  for (var i = context.stateMachines.length - 1; i >= 0; i--) {\n    context.stateMachines.forEach(function (stateMachine) {\n      return captureMatchIfValidAndRemove(context, stateMachine);\n    });\n  }\n  // For debugging: search for and uncomment other \"For debugging\" lines\n  // console.log(`\\nRead string:\\n  ${text}`);\n  // console.log(table.toString());\n  return context.matches;\n}\n/**\n * Handles the state when we're not in a URL/email/etc. (i.e. when no state machines exist)\n */\nfunction stateNoMatch(context, char, charCode) {\n  var charIdx = context.charIdx;\n  if (charCode === 35 /* Char.NumberSign */ /* '#' */) {\n    // Hash char, start a Hashtag match\n    context.addMachine(createHashtagStateMachine(charIdx, 28 /* State.HashtagHashChar */));\n  } else if (charCode === 64 /* Char.AtSign */ /* '@' */) {\n    // '@' char, start a Mention match\n    context.addMachine(createMentionStateMachine(charIdx, 30 /* State.MentionAtChar */));\n  } else if (charCode === 47 /* Char.Slash */ /* '/' */) {\n    // A slash could begin a protocol-relative URL\n    context.addMachine(createTldUrlStateMachine(charIdx, 11 /* State.ProtocolRelativeSlash1 */));\n  } else if (charCode === 43 /* Char.Plus */ /* '+' */) {\n    // A '+' char can start a Phone number\n    context.addMachine(createPhoneNumberStateMachine(charIdx, 37 /* State.PhoneNumberPlus */));\n  } else if (charCode === 40 /* Char.OpenParen */ /* '(' */) {\n    context.addMachine(createPhoneNumberStateMachine(charIdx, 32 /* State.PhoneNumberOpenParen */));\n  } else {\n    if (isDigitChar(charCode)) {\n      // A digit could start a phone number\n      context.addMachine(createPhoneNumberStateMachine(charIdx, 38 /* State.PhoneNumberDigit */));\n      // A digit could start an IP address\n      context.addMachine(createIpV4UrlStateMachine(charIdx, 13 /* State.IpV4Digit */));\n    }\n    if (isEmailLocalPartStartChar(charCode)) {\n      // Any email local part. An 'm' character in particular could\n      // start a 'mailto:' match\n      var startState = char.toLowerCase() === 'm' ? 15 /* State.EmailMailto_M */ : 22 /* State.EmailLocalPart */;\n      context.addMachine(createEmailStateMachine(charIdx, startState));\n    }\n    if (isSchemeStartChar(charCode)) {\n      // An uppercase or lowercase letter may start a scheme match\n      context.addMachine(createSchemeUrlStateMachine(charIdx, 0 /* State.SchemeChar */));\n    }\n    if (isAlphaNumericOrMarkChar(charCode)) {\n      // A unicode alpha character or digit could start a domain name\n      // label for a TLD match\n      context.addMachine(createTldUrlStateMachine(charIdx, 5 /* State.DomainLabelChar */));\n    }\n  }\n  // Anything else, remain in the \"non-url\" state by not creating any\n  // state machines\n}\n// Implements ABNF: ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\nfunction stateSchemeChar(context, stateMachine, charCode) {\n  if (charCode === 58 /* Char.Colon */ /* ':' */) {\n    stateMachine.state = 2 /* State.SchemeColon */;\n  } else if (charCode === 45 /* Char.Dash */ /* '-' */) {\n    stateMachine.state = 1 /* State.SchemeHyphen */;\n  } else if (isSchemeChar(charCode)) {\n    // Stay in SchemeChar state\n  } else {\n    // Any other character, not a scheme\n    context.removeMachine(stateMachine);\n  }\n}\nfunction stateSchemeHyphen(context, stateMachine, charCode) {\n  var charIdx = context.charIdx;\n  if (charCode === 45 /* Char.Dash */ /* '-' */) {\n    // Stay in SchemeHyphen state\n    // TODO: Should a colon following a dash be counted as the end of the scheme?\n    // } else if (char === ':') {\n    //     stateMachine.state = State.SchemeColon;\n  } else if (charCode === 47 /* Char.Slash */ /* '/' */) {\n    // Not a valid scheme match, but may be the start of a\n    // protocol-relative match (such as //google.com)\n    context.removeMachine(stateMachine);\n    context.addMachine(createTldUrlStateMachine(charIdx, 11 /* State.ProtocolRelativeSlash1 */));\n  } else if (isSchemeChar(charCode)) {\n    stateMachine.state = 0 /* State.SchemeChar */;\n  } else {\n    // Any other character, not a scheme\n    context.removeMachine(stateMachine);\n  }\n}\n// https://tools.ietf.org/html/rfc3986#appendix-A\nfunction stateSchemeColon(context, stateMachine, charCode) {\n  var charIdx = context.charIdx;\n  if (charCode === 47 /* Char.Slash */ /* '/' */) {\n    stateMachine.state = 3 /* State.SchemeSlash1 */;\n  } else if (charCode === 46 /* Char.Dot */ /* '.' */) {\n    // We've read something like 'hello:.' - don't capture\n    context.removeMachine(stateMachine);\n  } else if (isDomainLabelStartChar(charCode)) {\n    stateMachine.state = 5 /* State.DomainLabelChar */;\n    // It's possible that we read an \"introduction\" piece of text,\n    // and the character after the current colon actually starts an\n    // actual scheme. An example of this is:\n    //     \"The link:http://google.com\"\n    // Hence, start a new machine to capture this match if so\n    if (isSchemeStartChar(charCode)) {\n      context.addMachine(createSchemeUrlStateMachine(charIdx, 0 /* State.SchemeChar */));\n    }\n  } else {\n    context.removeMachine(stateMachine);\n  }\n}\n// https://tools.ietf.org/html/rfc3986#appendix-A\nfunction stateSchemeSlash1(context, stateMachine, charCode) {\n  if (charCode === 47 /* Char.Slash */ /* '/' */) {\n    stateMachine.state = 4 /* State.SchemeSlash2 */;\n  } else if (isPathChar(charCode)) {\n    stateMachine.state = 10 /* State.Path */;\n    stateMachine.acceptStateReached = true;\n  } else {\n    captureMatchIfValidAndRemove(context, stateMachine);\n  }\n}\nfunction stateSchemeSlash2(context, stateMachine, char, charCode) {\n  if (charCode === 47 /* Char.Slash */ /* '/' */) {\n    // 3rd slash, must be an absolute path (`path-absolute` in the\n    // ABNF), such as in \"file:///c:/windows/etc\". See\n    // https://tools.ietf.org/html/rfc3986#appendix-A\n    stateMachine.state = 10 /* State.Path */;\n    stateMachine.acceptStateReached = true;\n  } else if (isDomainLabelStartChar(charCode)) {\n    // start of \"authority\" section - see https://tools.ietf.org/html/rfc3986#appendix-A\n    stateMachine.state = 5 /* State.DomainLabelChar */;\n    stateMachine.acceptStateReached = true;\n  } else {\n    // not valid\n    context.removeMachine(stateMachine);\n  }\n}\n// Handles after we've read a '/' from the NonUrl state\nfunction stateProtocolRelativeSlash1(context, stateMachine, charCode) {\n  if (charCode === 47 /* Char.Slash */ /* '/' */) {\n    stateMachine.state = 12 /* State.ProtocolRelativeSlash2 */;\n  } else {\n    // Anything else, cannot be the start of a protocol-relative\n    // URL.\n    context.removeMachine(stateMachine);\n  }\n}\n// Handles after we've read a second '/', which could start a protocol-relative URL\nfunction stateProtocolRelativeSlash2(context, stateMachine, charCode) {\n  if (isDomainLabelStartChar(charCode)) {\n    stateMachine.state = 5 /* State.DomainLabelChar */;\n  } else {\n    // Anything else, not a URL\n    context.removeMachine(stateMachine);\n  }\n}\n// Handles when we have read a domain label character\nfunction stateDomainLabelChar(context, stateMachine, charCode) {\n  if (charCode === 46 /* Char.Dot */ /* '.' */) {\n    stateMachine.state = 7 /* State.DomainDot */;\n  } else if (charCode === 45 /* Char.Dash */ /* '-' */) {\n    stateMachine.state = 6 /* State.DomainHyphen */;\n  } else if (charCode === 58 /* Char.Colon */ /* ':' */) {\n    // Beginning of a port number, end the domain name\n    stateMachine.state = 8 /* State.PortColon */;\n  } else if (isUrlSuffixStartChar(charCode)) {\n    // '/', '?', or '#'\n    stateMachine.state = 10 /* State.Path */;\n  } else if (isDomainLabelChar(charCode)) {\n    // Stay in the DomainLabelChar state\n  } else {\n    // Anything else, end the domain name\n    captureMatchIfValidAndRemove(context, stateMachine);\n  }\n}\nfunction stateDomainHyphen(context, stateMachine, char, charCode) {\n  if (charCode === 45 /* Char.Dash */ /* '-' */) {\n    // Remain in the DomainHyphen state\n  } else if (charCode === 46 /* Char.Dot */ /* '.' */) {\n    // Not valid to have a '-.' in a domain label\n    captureMatchIfValidAndRemove(context, stateMachine);\n  } else if (isDomainLabelStartChar(charCode)) {\n    stateMachine.state = 5 /* State.DomainLabelChar */;\n  } else {\n    captureMatchIfValidAndRemove(context, stateMachine);\n  }\n}\nfunction stateDomainDot(context, stateMachine, char, charCode) {\n  if (charCode === 46 /* Char.Dot */ /* '.' */) {\n    // domain names cannot have multiple '.'s next to each other.\n    // It's possible we've already read a valid domain name though,\n    // and that the '..' sequence just forms an ellipsis at the end\n    // of a sentence\n    captureMatchIfValidAndRemove(context, stateMachine);\n  } else if (isDomainLabelStartChar(charCode)) {\n    stateMachine.state = 5 /* State.DomainLabelChar */;\n    stateMachine.acceptStateReached = true; // after hitting a dot, and then another domain label, we've reached an accept state\n  } else {\n    // Anything else, end the domain name\n    captureMatchIfValidAndRemove(context, stateMachine);\n  }\n}\nfunction stateIpV4Digit(context, stateMachine, charCode) {\n  if (charCode === 46 /* Char.Dot */ /* '.' */) {\n    stateMachine.state = 14 /* State.IpV4Dot */;\n  } else if (charCode === 58 /* Char.Colon */ /* ':' */) {\n    // Beginning of a port number\n    stateMachine.state = 8 /* State.PortColon */;\n  } else if (isDigitChar(charCode)) {\n    // stay in the IPv4 digit state\n  } else if (isUrlSuffixStartChar(charCode)) {\n    stateMachine.state = 10 /* State.Path */;\n  } else if (isAlphaNumericOrMarkChar(charCode)) {\n    // If we hit an alpha character, must not be an IPv4\n    // Example of this: 1.2.3.4abc\n    context.removeMachine(stateMachine);\n  } else {\n    captureMatchIfValidAndRemove(context, stateMachine);\n  }\n}\nfunction stateIpV4Dot(context, stateMachine, charCode) {\n  if (isDigitChar(charCode)) {\n    stateMachine.octetsEncountered++;\n    // Once we have encountered 4 octets, it's *potentially* a valid\n    // IPv4 address. Our IPv4 regex will confirm the match later\n    // though to make sure each octet is in the 0-255 range, and\n    // there's exactly 4 octets (not 5 or more)\n    if (stateMachine.octetsEncountered === 4) {\n      stateMachine.acceptStateReached = true;\n    }\n    stateMachine.state = 13 /* State.IpV4Digit */;\n  } else {\n    captureMatchIfValidAndRemove(context, stateMachine);\n  }\n}\nfunction statePortColon(context, stateMachine, charCode) {\n  if (isDigitChar(charCode)) {\n    stateMachine.state = 9 /* State.PortNumber */;\n  } else {\n    captureMatchIfValidAndRemove(context, stateMachine);\n  }\n}\nfunction statePortNumber(context, stateMachine, charCode) {\n  if (isDigitChar(charCode)) {\n    // Stay in port number state\n  } else if (isUrlSuffixStartChar(charCode)) {\n    // '/', '?', or '#'\n    stateMachine.state = 10 /* State.Path */;\n  } else {\n    captureMatchIfValidAndRemove(context, stateMachine);\n  }\n}\nfunction statePath(context, stateMachine, charCode) {\n  if (isPathChar(charCode)) {\n    // Stay in the path state\n  } else {\n    captureMatchIfValidAndRemove(context, stateMachine);\n  }\n}\n// Handles if we're reading a 'mailto:' prefix on the string\nfunction stateEmailMailto_M(context, stateMachine, char, charCode) {\n  if (char.toLowerCase() === 'a') {\n    stateMachine.state = 16 /* State.EmailMailto_A */;\n  } else {\n    stateEmailLocalPart(context, stateMachine, charCode);\n  }\n}\nfunction stateEmailMailto_A(context, stateMachine, char, charCode) {\n  if (char.toLowerCase() === 'i') {\n    stateMachine.state = 17 /* State.EmailMailto_I */;\n  } else {\n    stateEmailLocalPart(context, stateMachine, charCode);\n  }\n}\nfunction stateEmailMailto_I(context, stateMachine, char, charCode) {\n  if (char.toLowerCase() === 'l') {\n    stateMachine.state = 18 /* State.EmailMailto_L */;\n  } else {\n    stateEmailLocalPart(context, stateMachine, charCode);\n  }\n}\nfunction stateEmailMailto_L(context, stateMachine, char, charCode) {\n  if (char.toLowerCase() === 't') {\n    stateMachine.state = 19 /* State.EmailMailto_T */;\n  } else {\n    stateEmailLocalPart(context, stateMachine, charCode);\n  }\n}\nfunction stateEmailMailto_T(context, stateMachine, char, charCode) {\n  if (char.toLowerCase() === 'o') {\n    stateMachine.state = 20 /* State.EmailMailto_O */;\n  } else {\n    stateEmailLocalPart(context, stateMachine, charCode);\n  }\n}\nfunction stateEmailMailto_O(context, stateMachine, charCode) {\n  if (charCode === 58 /* Char.Colon */ /* ':' */) {\n    stateMachine.state = 21 /* State.EmailMailto_Colon */;\n  } else {\n    stateEmailLocalPart(context, stateMachine, charCode);\n  }\n}\nfunction stateEmailMailtoColon(context, stateMachine, charCode) {\n  if (isEmailLocalPartChar(charCode)) {\n    stateMachine.state = 22 /* State.EmailLocalPart */;\n  } else {\n    context.removeMachine(stateMachine);\n  }\n}\n// Handles the state when we're currently in the \"local part\" of an\n// email address (as opposed to the \"domain part\")\nfunction stateEmailLocalPart(context, stateMachine, charCode) {\n  if (charCode === 46 /* Char.Dot */ /* '.' */) {\n    stateMachine.state = 23 /* State.EmailLocalPartDot */;\n  } else if (charCode === 64 /* Char.AtSign */ /* '@' */) {\n    stateMachine.state = 24 /* State.EmailAtSign */;\n  } else if (isEmailLocalPartChar(charCode)) {\n    // stay in the \"local part\" of the email address\n    // Note: because stateEmailLocalPart() is called from the\n    // 'mailto' states (when the 'mailto' prefix itself has been\n    // broken), make sure to set the state to EmailLocalPart\n    stateMachine.state = 22 /* State.EmailLocalPart */;\n  } else {\n    // not an email address character\n    context.removeMachine(stateMachine);\n  }\n}\n// Handles the state where we've read a '.' character in the local part of\n// the email address (i.e. the part before the '@' character)\nfunction stateEmailLocalPartDot(context, stateMachine, charCode) {\n  if (charCode === 46 /* Char.Dot */ /* '.' */) {\n    // We read a second '.' in a row, not a valid email address\n    // local part\n    context.removeMachine(stateMachine);\n  } else if (charCode === 64 /* Char.AtSign */ /* '@' */) {\n    // We read the '@' character immediately after a dot ('.'), not\n    // an email address\n    context.removeMachine(stateMachine);\n  } else if (isEmailLocalPartChar(charCode)) {\n    stateMachine.state = 22 /* State.EmailLocalPart */;\n  } else {\n    // Anything else, not an email address\n    context.removeMachine(stateMachine);\n  }\n}\nfunction stateEmailAtSign(context, stateMachine, charCode) {\n  if (isDomainLabelStartChar(charCode)) {\n    stateMachine.state = 25 /* State.EmailDomainChar */;\n  } else {\n    // Anything else, not an email address\n    context.removeMachine(stateMachine);\n  }\n}\nfunction stateEmailDomainChar(context, stateMachine, charCode) {\n  if (charCode === 46 /* Char.Dot */ /* '.' */) {\n    stateMachine.state = 27 /* State.EmailDomainDot */;\n  } else if (charCode === 45 /* Char.Dash */ /* '-' */) {\n    stateMachine.state = 26 /* State.EmailDomainHyphen */;\n  } else if (isDomainLabelChar(charCode)) {\n    // Stay in the DomainChar state\n  } else {\n    // Anything else, we potentially matched if the criteria has\n    // been met\n    captureMatchIfValidAndRemove(context, stateMachine);\n  }\n}\nfunction stateEmailDomainHyphen(context, stateMachine, charCode) {\n  if (charCode === 45 /* Char.Dash */ /* '-' */ || charCode === 46 /* Char.Dot */ /* '.' */) {\n    // Not valid to have two hyphens (\"--\") or hypen+dot (\"-.\")\n    captureMatchIfValidAndRemove(context, stateMachine);\n  } else if (isDomainLabelChar(charCode)) {\n    stateMachine.state = 25 /* State.EmailDomainChar */;\n  } else {\n    // Anything else\n    captureMatchIfValidAndRemove(context, stateMachine);\n  }\n}\nfunction stateEmailDomainDot(context, stateMachine, charCode) {\n  if (charCode === 46 /* Char.Dot */ /* '.' */ || charCode === 45 /* Char.Dash */ /* '-' */) {\n    // not valid to have two dots (\"..\") or dot+hypen (\".-\")\n    captureMatchIfValidAndRemove(context, stateMachine);\n  } else if (isDomainLabelStartChar(charCode)) {\n    stateMachine.state = 25 /* State.EmailDomainChar */;\n    // After having read a '.' and then a valid domain character,\n    // we now know that the domain part of the email is valid, and\n    // we have found at least a partial EmailMatch (however, the\n    // email address may have additional characters from this point)\n    stateMachine.acceptStateReached = true;\n  } else {\n    // Anything else\n    captureMatchIfValidAndRemove(context, stateMachine);\n  }\n}\n// Handles the state when we've just encountered a '#' character\nfunction stateHashtagHashChar(context, stateMachine, charCode) {\n  if (isHashtagTextChar(charCode)) {\n    // '#' char with valid hash text char following\n    stateMachine.state = 29 /* State.HashtagTextChar */;\n    stateMachine.acceptStateReached = true;\n  } else {\n    context.removeMachine(stateMachine);\n  }\n}\n// Handles the state when we're currently in the hash tag's text chars\nfunction stateHashtagTextChar(context, stateMachine, charCode) {\n  if (isHashtagTextChar(charCode)) {\n    // Continue reading characters in the HashtagText state\n  } else {\n    captureMatchIfValidAndRemove(context, stateMachine);\n  }\n}\n// Handles the state when we've just encountered a '@' character\nfunction stateMentionAtChar(context, stateMachine, charCode) {\n  if (isMentionTextChar(charCode)) {\n    // '@' char with valid mention text char following\n    stateMachine.state = 31 /* State.MentionTextChar */;\n    stateMachine.acceptStateReached = true;\n  } else {\n    context.removeMachine(stateMachine);\n  }\n}\n// Handles the state when we're currently in the mention's text chars\nfunction stateMentionTextChar(context, stateMachine, charCode) {\n  if (isMentionTextChar(charCode)) {\n    // Continue reading characters in the HashtagText state\n  } else if (isAlphaNumericOrMarkChar(charCode)) {\n    // Char is invalid for a mention text char, not a valid match.\n    // Note that ascii alphanumeric chars are okay (which are tested\n    // in the previous 'if' statement, but others are not)\n    context.removeMachine(stateMachine);\n  } else {\n    captureMatchIfValidAndRemove(context, stateMachine);\n  }\n}\nfunction statePhoneNumberPlus(context, stateMachine, char, charCode) {\n  if (isDigitChar(charCode)) {\n    stateMachine.state = 38 /* State.PhoneNumberDigit */;\n  } else {\n    context.removeMachine(stateMachine);\n    // This character may start a new match. Add states for it\n    stateNoMatch(context, char, charCode);\n  }\n}\nfunction statePhoneNumberOpenParen(context, stateMachine, char, charCode) {\n  if (isDigitChar(charCode)) {\n    stateMachine.state = 33 /* State.PhoneNumberAreaCodeDigit1 */;\n  } else {\n    context.removeMachine(stateMachine);\n  }\n  // It's also possible that the paren was just an open brace for\n  // a piece of text. Start other machines\n  stateNoMatch(context, char, charCode);\n}\nfunction statePhoneNumberAreaCodeDigit1(context, stateMachine, charCode) {\n  if (isDigitChar(charCode)) {\n    stateMachine.state = 34 /* State.PhoneNumberAreaCodeDigit2 */;\n  } else {\n    context.removeMachine(stateMachine);\n  }\n}\nfunction statePhoneNumberAreaCodeDigit2(context, stateMachine, charCode) {\n  if (isDigitChar(charCode)) {\n    stateMachine.state = 35 /* State.PhoneNumberAreaCodeDigit3 */;\n  } else {\n    context.removeMachine(stateMachine);\n  }\n}\nfunction statePhoneNumberAreaCodeDigit3(context, stateMachine, charCode) {\n  if (charCode === 41 /* Char.CloseParen */ /* ')' */) {\n    stateMachine.state = 36 /* State.PhoneNumberCloseParen */;\n  } else {\n    context.removeMachine(stateMachine);\n  }\n}\nfunction statePhoneNumberCloseParen(context, stateMachine, char, charCode) {\n  if (isDigitChar(charCode)) {\n    stateMachine.state = 38 /* State.PhoneNumberDigit */;\n  } else if (isPhoneNumberSeparatorChar(charCode)) {\n    stateMachine.state = 39 /* State.PhoneNumberSeparator */;\n  } else {\n    context.removeMachine(stateMachine);\n  }\n}\nfunction statePhoneNumberDigit(context, stateMachine, char, charCode) {\n  var charIdx = context.charIdx;\n  // For now, if we've reached any digits, we'll say that the machine\n  // has reached its accept state. The phone regex will confirm the\n  // match later.\n  // Alternatively, we could count the number of digits to avoid\n  // invoking the phone number regex\n  stateMachine.acceptStateReached = true;\n  if (isPhoneNumberControlChar(charCode)) {\n    stateMachine.state = 40 /* State.PhoneNumberControlChar */;\n  } else if (charCode === 35 /* Char.NumberSign */ /* '#' */) {\n    stateMachine.state = 41 /* State.PhoneNumberPoundChar */;\n  } else if (isDigitChar(charCode)) {\n    // Stay in the phone number digit state\n  } else if (charCode === 40 /* Char.OpenParen */ /* '(' */) {\n    stateMachine.state = 32 /* State.PhoneNumberOpenParen */;\n  } else if (isPhoneNumberSeparatorChar(charCode)) {\n    stateMachine.state = 39 /* State.PhoneNumberSeparator */;\n  } else {\n    captureMatchIfValidAndRemove(context, stateMachine);\n    // The transition from a digit character to a letter can be the\n    // start of a new scheme URL match\n    if (isSchemeStartChar(charCode)) {\n      context.addMachine(createSchemeUrlStateMachine(charIdx, 0 /* State.SchemeChar */));\n    }\n  }\n}\nfunction statePhoneNumberSeparator(context, stateMachine, char, charCode) {\n  if (isDigitChar(charCode)) {\n    stateMachine.state = 38 /* State.PhoneNumberDigit */;\n  } else if (charCode === 40 /* Char.OpenParen */ /* '(' */) {\n    stateMachine.state = 32 /* State.PhoneNumberOpenParen */;\n  } else {\n    captureMatchIfValidAndRemove(context, stateMachine);\n    // This character may start a new match. Add states for it\n    stateNoMatch(context, char, charCode);\n  }\n}\n// The \";\" characters is \"wait\" in a phone number\n// The \",\" characters is \"pause\" in a phone number\nfunction statePhoneNumberControlChar(context, stateMachine, charCode) {\n  if (isPhoneNumberControlChar(charCode)) {\n    // Stay in the \"control char\" state\n  } else if (charCode === 35 /* Char.NumberSign */ /* '#' */) {\n    stateMachine.state = 41 /* State.PhoneNumberPoundChar */;\n  } else if (isDigitChar(charCode)) {\n    stateMachine.state = 38 /* State.PhoneNumberDigit */;\n  } else {\n    captureMatchIfValidAndRemove(context, stateMachine);\n  }\n}\n// The \"#\" characters is \"pound\" in a phone number\nfunction statePhoneNumberPoundChar(context, stateMachine, charCode) {\n  if (isPhoneNumberControlChar(charCode)) {\n    stateMachine.state = 40 /* State.PhoneNumberControlChar */;\n  } else if (isDigitChar(charCode)) {\n    // According to some of the older tests, if there's a digit\n    // after a '#' sign, the match is invalid. TODO: Revisit if this is true\n    context.removeMachine(stateMachine);\n  } else {\n    captureMatchIfValidAndRemove(context, stateMachine);\n  }\n}\n/*\n * Captures a match if it is valid (i.e. has a full domain name for a\n * TLD match). If a match is not valid, it is possible that we want to\n * keep reading characters in order to make a full match.\n */\nfunction captureMatchIfValidAndRemove(context, stateMachine) {\n  var matches = context.matches,\n    text = context.text,\n    charIdx = context.charIdx,\n    tagBuilder = context.tagBuilder,\n    stripPrefix = context.stripPrefix,\n    stripTrailingSlash = context.stripTrailingSlash,\n    decodePercentEncoding = context.decodePercentEncoding,\n    hashtagServiceName = context.hashtagServiceName,\n    mentionServiceName = context.mentionServiceName;\n  // Remove the state machine first. There are a number of code paths\n  // which return out of this function early, so make sure we have\n  // this done\n  context.removeMachine(stateMachine);\n  // Make sure the state machine being checked has actually reached an\n  // \"accept\" state. If it hasn't reach one, it can't be a match\n  if (!stateMachine.acceptStateReached) {\n    return;\n  }\n  var startIdx = stateMachine.startIdx;\n  var matchedText = text.slice(stateMachine.startIdx, charIdx);\n  // Handle any unbalanced braces (parens, square brackets, or curly\n  // brackets) inside the URL. This handles situations like:\n  //     The link (google.com)\n  // and\n  //     Check out this link here (en.wikipedia.org/wiki/IANA_(disambiguation))\n  //\n  // And also remove any punctuation chars at the end such as:\n  //     '?', ',', ':', '.', etc.\n  matchedText = excludeUnbalancedTrailingBracesAndPunctuation(matchedText);\n  switch (stateMachine.type) {\n    case 0 /* StateMachineType.Url */:\n      {\n        // We don't want to accidentally match a URL that is preceded by an\n        // '@' character, which would be an email address\n        var charBeforeUrlMatch = text.charCodeAt(stateMachine.startIdx - 1);\n        if (charBeforeUrlMatch === 64 /* Char.AtSign */ /* '@' */) {\n          return;\n        }\n        switch (stateMachine.matchType) {\n          case 0 /* UrlStateMachineMatchType.Scheme */:\n            {\n              // Autolinker accepts many characters in a url's scheme (like `fake://test.com`).\n              // However, in cases where a URL is missing whitespace before an obvious link,\n              // (for example: `nowhitespacehttp://www.test.com`), we only want the match to start\n              // at the http:// part. We will check if the match contains a common scheme and then\n              // shift the match to start from there.\n              var httpSchemeMatch = httpSchemeRe.exec(matchedText);\n              if (httpSchemeMatch) {\n                // If we found an overmatched URL, we want to find the index\n                // of where the match should start and shift the match to\n                // start from the beginning of the common scheme\n                startIdx = startIdx + httpSchemeMatch.index;\n                matchedText = matchedText.slice(httpSchemeMatch.index);\n              }\n              if (!isValidSchemeUrl(matchedText)) {\n                return; // not a valid match\n              }\n              break;\n            }\n          case 1 /* UrlStateMachineMatchType.Tld */:\n            {\n              if (!isValidTldMatch(matchedText)) {\n                return; // not a valid match\n              }\n              break;\n            }\n          case 2 /* UrlStateMachineMatchType.IpV4 */:\n            {\n              if (!isValidIpV4Address(matchedText)) {\n                return; // not a valid match\n              }\n              break;\n            }\n          /* istanbul ignore next */\n          default:\n            assertNever(stateMachine);\n        }\n        matches.push(new UrlMatch({\n          tagBuilder: tagBuilder,\n          matchedText: matchedText,\n          offset: startIdx,\n          urlMatchType: toUrlMatchType(stateMachine.matchType),\n          url: matchedText,\n          protocolRelativeMatch: matchedText.slice(0, 2) === '//',\n          // TODO: Do these settings need to be passed to the match,\n          // or should we handle them here in UrlMatcher?\n          stripPrefix: stripPrefix,\n          stripTrailingSlash: stripTrailingSlash,\n          decodePercentEncoding: decodePercentEncoding\n        }));\n        break;\n      }\n    case 1 /* StateMachineType.Email */:\n      {\n        // if the email address has a valid TLD, add it to the list of matches\n        if (isValidEmail(matchedText)) {\n          matches.push(new EmailMatch({\n            tagBuilder: tagBuilder,\n            matchedText: matchedText,\n            offset: startIdx,\n            email: matchedText.replace(mailtoSchemePrefixRe, '')\n          }));\n        }\n        break;\n      }\n    case 2 /* StateMachineType.Hashtag */:\n      {\n        if (isValidHashtag(matchedText)) {\n          matches.push(new HashtagMatch({\n            tagBuilder: tagBuilder,\n            matchedText: matchedText,\n            offset: startIdx,\n            serviceName: hashtagServiceName,\n            hashtag: matchedText.slice(1)\n          }));\n        }\n        break;\n      }\n    case 3 /* StateMachineType.Mention */:\n      {\n        if (isValidMention(matchedText, mentionServiceName)) {\n          matches.push(new MentionMatch({\n            tagBuilder: tagBuilder,\n            matchedText: matchedText,\n            offset: startIdx,\n            serviceName: mentionServiceName,\n            mention: matchedText.slice(1) // strip off the '@' character at the beginning\n          }));\n        }\n        break;\n      }\n    case 4 /* StateMachineType.Phone */:\n      {\n        // remove any trailing spaces that were considered as \"separator\"\n        // chars by the state machine\n        matchedText = matchedText.replace(/ +$/g, '');\n        if (isValidPhoneNumber(matchedText)) {\n          var cleanNumber = matchedText.replace(/[^0-9,;#]/g, ''); // strip out non-digit characters exclude comma semicolon and #\n          matches.push(new PhoneMatch({\n            tagBuilder: tagBuilder,\n            matchedText: matchedText,\n            offset: startIdx,\n            number: cleanNumber,\n            plusSign: matchedText.charAt(0) === '+'\n          }));\n        }\n        break;\n      }\n    /* istanbul ignore next */\n    default:\n      assertNever(stateMachine);\n  }\n}\n/**\n * Helper function to convert a UrlStateMachineMatchType value to its\n * UrlMatchType equivalent.\n */\nfunction toUrlMatchType(stateMachineMatchType) {\n  switch (stateMachineMatchType) {\n    case 0 /* UrlStateMachineMatchType.Scheme */:\n      return 'scheme';\n    case 1 /* UrlStateMachineMatchType.Tld */:\n      return 'tld';\n    case 2 /* UrlStateMachineMatchType.IpV4 */:\n      return 'ipV4';\n    /* istanbul ignore next */\n    default:\n      assertNever(stateMachineMatchType);\n  }\n}\nvar oppositeBrace = {\n  ')': '(',\n  '}': '{',\n  ']': '['\n};\n/**\n * Determines if a match found has unmatched closing parenthesis,\n * square brackets or curly brackets. If so, these unbalanced symbol(s) will be\n * removed from the URL match itself.\n *\n * A match may have an extra closing parenthesis/square brackets/curly brackets\n * at the end of the match because these are valid URL path characters. For\n * example, \"wikipedia.com/something_(disambiguation)\" should be auto-linked.\n *\n * However, an extra parenthesis *will* be included when the URL itself is\n * wrapped in parenthesis, such as in the case of:\n *\n *     \"(wikipedia.com/something_(disambiguation))\"\n *\n * In this case, the last closing parenthesis should *not* be part of the\n * URL itself, and this method will exclude it from the returned URL.\n *\n * For square brackets in URLs such as in PHP arrays, the same behavior as\n * parenthesis discussed above should happen:\n *\n *     \"[http://www.example.com/foo.php?bar[]=1&bar[]=2&bar[]=3]\"\n *\n * The very last closing square bracket should not be part of the URL itself,\n * and therefore this method will remove it.\n *\n * @param matchedText The full matched URL/email/hashtag/etc. from the state\n *   machine parser.\n * @return The updated matched text with extraneous suffix characters removed.\n */\nexport function excludeUnbalancedTrailingBracesAndPunctuation(matchedText) {\n  var braceCounts = {\n    '(': 0,\n    '{': 0,\n    '[': 0\n  };\n  for (var i = 0; i < matchedText.length; i++) {\n    var char = matchedText.charAt(i);\n    var charCode = matchedText.charCodeAt(i);\n    if (isOpenBraceChar(charCode)) {\n      braceCounts[char]++;\n    } else if (isCloseBraceChar(charCode)) {\n      braceCounts[oppositeBrace[char]]--;\n    }\n  }\n  var endIdx = matchedText.length - 1;\n  while (endIdx >= 0) {\n    var char = matchedText.charAt(endIdx);\n    var charCode = matchedText.charCodeAt(endIdx);\n    if (isCloseBraceChar(charCode)) {\n      var oppositeBraceChar = oppositeBrace[char];\n      if (braceCounts[oppositeBraceChar] < 0) {\n        braceCounts[oppositeBraceChar]++;\n        endIdx--;\n      } else {\n        break;\n      }\n    } else if (isUrlSuffixNotAllowedAsFinalChar(charCode)) {\n      // Walk back a punctuation char like '?', ',', ':', '.', etc.\n      endIdx--;\n    } else {\n      break;\n    }\n  }\n  return matchedText.slice(0, endIdx + 1);\n}\nfunction createSchemeUrlStateMachine(startIdx, state) {\n  return {\n    type: 0 /* StateMachineType.Url */,\n    startIdx: startIdx,\n    state: state,\n    acceptStateReached: false,\n    matchType: 0 /* UrlStateMachineMatchType.Scheme */\n  };\n}\nfunction createTldUrlStateMachine(startIdx, state) {\n  return {\n    type: 0 /* StateMachineType.Url */,\n    startIdx: startIdx,\n    state: state,\n    acceptStateReached: false,\n    matchType: 1 /* UrlStateMachineMatchType.Tld */\n  };\n}\nfunction createIpV4UrlStateMachine(startIdx, state) {\n  return {\n    type: 0 /* StateMachineType.Url */,\n    startIdx: startIdx,\n    state: state,\n    acceptStateReached: false,\n    matchType: 2 /* UrlStateMachineMatchType.IpV4 */,\n    octetsEncountered: 1 // starts at 1 because we create this machine when encountering the first octet\n  };\n}\nfunction createEmailStateMachine(startIdx, state) {\n  return {\n    type: 1 /* StateMachineType.Email */,\n    startIdx: startIdx,\n    state: state,\n    acceptStateReached: false\n  };\n}\nfunction createHashtagStateMachine(startIdx, state) {\n  return {\n    type: 2 /* StateMachineType.Hashtag */,\n    startIdx: startIdx,\n    state: state,\n    acceptStateReached: false\n  };\n}\nfunction createMentionStateMachine(startIdx, state) {\n  return {\n    type: 3 /* StateMachineType.Mention */,\n    startIdx: startIdx,\n    state: state,\n    acceptStateReached: false\n  };\n}\nfunction createPhoneNumberStateMachine(startIdx, state) {\n  return {\n    type: 4 /* StateMachineType.Phone */,\n    startIdx: startIdx,\n    state: state,\n    acceptStateReached: false\n  };\n}\nfunction isSchemeUrlStateMachine(machine) {\n  return machine.type === 0 /* StateMachineType.Url */ && machine.matchType === 0 /* UrlStateMachineMatchType.Scheme */;\n}","map":{"version":3,"names":["UrlMatch","assertNever","httpSchemeRe","isDomainLabelChar","isDomainLabelStartChar","isPathChar","isSchemeChar","isSchemeStartChar","isUrlSuffixStartChar","isValidIpV4Address","isValidSchemeUrl","isValidTldMatch","isEmailLocalPartChar","isEmailLocalPartStartChar","isValidEmail","mailtoSchemePrefixRe","EmailMatch","isHashtagTextChar","isValidHashtag","HashtagMatch","isMentionTextChar","isValidMention","MentionMatch","isPhoneNumberSeparatorChar","isPhoneNumberControlChar","isValidPhoneNumber","PhoneMatch","isAlphaNumericOrMarkChar","isCloseBraceChar","isDigitChar","isOpenBraceChar","isUrlSuffixNotAllowedAsFinalChar","ParseMatchesContext","text","args","charIdx","matches","_stateMachines","schemeUrlMachinesCount","tagBuilder","stripPrefix","stripTrailingSlash","decodePercentEncoding","hashtagServiceName","mentionServiceName","Object","defineProperty","prototype","get","addMachine","stateMachine","push","isSchemeUrlStateMachine","removeMachine","filter","m","hasSchemeUrlMachine","parseMatches","context","length","char","charAt","charCode","charCodeAt","stateMachines","stateNoMatch","stateIdx","state","stateProtocolRelativeSlash1","stateProtocolRelativeSlash2","stateSchemeChar","stateSchemeHyphen","stateSchemeColon","stateSchemeSlash1","stateSchemeSlash2","stateDomainLabelChar","stateDomainHyphen","stateDomainDot","stateIpV4Digit","stateIpV4Dot","statePortColon","statePortNumber","statePath","stateEmailMailto_M","stateEmailMailto_A","stateEmailMailto_I","stateEmailMailto_L","stateEmailMailto_T","stateEmailMailto_O","stateEmailMailtoColon","stateEmailLocalPart","stateEmailLocalPartDot","stateEmailAtSign","stateEmailDomainChar","stateEmailDomainHyphen","stateEmailDomainDot","stateHashtagHashChar","stateHashtagTextChar","stateMentionAtChar","stateMentionTextChar","statePhoneNumberOpenParen","statePhoneNumberAreaCodeDigit1","statePhoneNumberAreaCodeDigit2","statePhoneNumberAreaCodeDigit3","statePhoneNumberCloseParen","statePhoneNumberPlus","statePhoneNumberDigit","statePhoneNumberSeparator","statePhoneNumberControlChar","statePhoneNumberPoundChar","prevCharCode","createSchemeUrlStateMachine","i","forEach","captureMatchIfValidAndRemove","createHashtagStateMachine","createMentionStateMachine","createTldUrlStateMachine","createPhoneNumberStateMachine","createIpV4UrlStateMachine","startState","toLowerCase","createEmailStateMachine","acceptStateReached","octetsEncountered","startIdx","matchedText","slice","excludeUnbalancedTrailingBracesAndPunctuation","type","charBeforeUrlMatch","matchType","httpSchemeMatch","exec","index","offset","urlMatchType","toUrlMatchType","url","protocolRelativeMatch","email","replace","serviceName","hashtag","mention","cleanNumber","number","plusSign","stateMachineMatchType","oppositeBrace","braceCounts","endIdx","oppositeBraceChar","machine"],"sources":["../../../src/parser/parse-matches.ts"],"sourcesContent":["import { UrlMatch, UrlMatchType } from '../match/url-match';\nimport { Match } from '../match/match';\nimport { assertNever } from '../utils';\nimport {\n    httpSchemeRe,\n    isDomainLabelChar,\n    isDomainLabelStartChar,\n    isPathChar,\n    isSchemeChar,\n    isSchemeStartChar,\n    isUrlSuffixStartChar,\n    isValidIpV4Address,\n    isValidSchemeUrl,\n    isValidTldMatch,\n} from './uri-utils';\nimport {\n    isEmailLocalPartChar,\n    isEmailLocalPartStartChar,\n    isValidEmail,\n    mailtoSchemePrefixRe,\n} from './email-utils';\nimport { EmailMatch } from '../match/email-match';\nimport { HashtagService, isHashtagTextChar, isValidHashtag } from './hashtag-utils';\nimport { HashtagMatch } from '../match/hashtag-match';\nimport { isMentionTextChar, isValidMention, MentionService } from './mention-utils';\nimport { MentionMatch } from '../match/mention-match';\nimport {\n    isPhoneNumberSeparatorChar,\n    isPhoneNumberControlChar,\n    isValidPhoneNumber,\n} from './phone-number-utils';\nimport { PhoneMatch } from '../match/phone-match';\nimport { AnchorTagBuilder } from '../anchor-tag-builder';\nimport type { StripPrefixConfigObj } from '../autolinker';\nimport { Char } from '../char';\nimport {\n    isAlphaNumericOrMarkChar,\n    isCloseBraceChar,\n    isDigitChar,\n    isOpenBraceChar,\n    isUrlSuffixNotAllowedAsFinalChar,\n} from '../char-utils';\n\n// For debugging: search for and uncomment other \"For debugging\" lines\n// import CliTable from 'cli-table';\n\n/**\n * Context object containing all the state needed by the state machine functions.\n *\n * ## Historical note\n *\n * In v4.1.1, we used nested functions to handle the context via closures, but\n * this necessitated re-creating the functions for each call to `parseMatches()`,\n * which made them difficult for v8 to JIT optimize. In v4.1.2, we lifted all of\n * the functions to the top-level scope and passed the context object between\n * them, which allows the functions to be JIT compiled once and reused.\n */\nclass ParseMatchesContext {\n    public charIdx = 0; // Current character index being processed\n\n    public readonly text: string; // The input text being parsed\n    public readonly matches: Match[] = []; // Collection of matches found\n    public readonly tagBuilder: AnchorTagBuilder; // For building anchor tags\n    public readonly stripPrefix: Required<StripPrefixConfigObj>; // Strip prefix configuration\n    public readonly stripTrailingSlash: boolean; // Whether to strip trailing slashes\n    public readonly decodePercentEncoding: boolean; // Whether to decode percent encoding\n    public readonly hashtagServiceName: HashtagService; // Service name for hashtags\n    public readonly mentionServiceName: MentionService; // Service name for mentions\n\n    private _stateMachines: StateMachine[] = []; // Array of active state machines\n    private schemeUrlMachinesCount = 0; // part of an optimization to remove the need to go into a slow code block when unnecessary. Since it's been so long since the initial implementation, not sure that this can ever go above 1, but keeping it as a counter to be safe\n\n    constructor(text: string, args: ParseMatchesArgs) {\n        this.text = text;\n        this.tagBuilder = args.tagBuilder;\n        this.stripPrefix = args.stripPrefix;\n        this.stripTrailingSlash = args.stripTrailingSlash;\n        this.decodePercentEncoding = args.decodePercentEncoding;\n        this.hashtagServiceName = args.hashtagServiceName;\n        this.mentionServiceName = args.mentionServiceName;\n    }\n\n    public get stateMachines(): ReadonlyArray<StateMachine> {\n        return this._stateMachines;\n    }\n\n    public addMachine(stateMachine: StateMachine): void {\n        this._stateMachines.push(stateMachine);\n\n        if (isSchemeUrlStateMachine(stateMachine)) {\n            this.schemeUrlMachinesCount++;\n        }\n    }\n\n    public removeMachine(stateMachine: StateMachine): void {\n        // Performance note: this was originally implemented with Array.prototype.splice()\n        // and mutated the array in place. Switching to filter added ~280ops/sec\n        // on the benchmark, although likely at the expense of GC time. Perhaps\n        // in the future, we implement a rotating array so we never need to move\n        // or clean anything up\n        this._stateMachines = this._stateMachines.filter(m => m !== stateMachine);\n\n        // If we've removed the URL state machine, set the flag to false.\n        // This flag is a quick test that helps us skip a slow section of\n        // code when there is already a URL state machine present.\n        if (isSchemeUrlStateMachine(stateMachine)) {\n            this.schemeUrlMachinesCount--;\n        }\n    }\n\n    public hasSchemeUrlMachine(): boolean {\n        return this.schemeUrlMachinesCount > 0;\n    }\n}\n\n/**\n * Parses URL, email, twitter, mention, and hashtag matches from the given\n * `text`.\n */\nexport function parseMatches(text: string, args: ParseMatchesArgs): Match[] {\n    // Create the context object that will be passed to all state functions\n    const context = new ParseMatchesContext(text, args);\n\n    // For debugging: search for and uncomment other \"For debugging\" lines\n    // const table = new CliTable({\n    //     head: ['charIdx', 'char', 'code', 'type', 'states', 'startIdx', 'reached accept state'],\n    // });\n    for (; context.charIdx < context.text.length; context.charIdx++) {\n        const char = text.charAt(context.charIdx);\n        const charCode = text.charCodeAt(context.charIdx);\n\n        if (context.stateMachines.length === 0) {\n            stateNoMatch(context, char, charCode);\n        } else {\n            // Must loop through the state machines backwards for when one\n            // is removed\n            for (let stateIdx = context.stateMachines.length - 1; stateIdx >= 0; stateIdx--) {\n                const stateMachine = context.stateMachines[stateIdx];\n\n                switch (stateMachine.state) {\n                    // Protocol-relative URL states\n                    case State.ProtocolRelativeSlash1:\n                        stateProtocolRelativeSlash1(context, stateMachine, charCode);\n                        break;\n                    case State.ProtocolRelativeSlash2:\n                        stateProtocolRelativeSlash2(context, stateMachine, charCode);\n                        break;\n\n                    case State.SchemeChar:\n                        stateSchemeChar(context, stateMachine, charCode);\n                        break;\n                    case State.SchemeHyphen:\n                        stateSchemeHyphen(context, stateMachine, charCode);\n                        break;\n                    case State.SchemeColon:\n                        stateSchemeColon(context, stateMachine, charCode);\n                        break;\n                    case State.SchemeSlash1:\n                        stateSchemeSlash1(context, stateMachine, charCode);\n                        break;\n                    case State.SchemeSlash2:\n                        stateSchemeSlash2(context, stateMachine, char, charCode);\n                        break;\n\n                    case State.DomainLabelChar:\n                        stateDomainLabelChar(context, stateMachine, charCode);\n                        break;\n                    case State.DomainHyphen:\n                        stateDomainHyphen(context, stateMachine, char, charCode);\n                        break;\n                    case State.DomainDot:\n                        stateDomainDot(context, stateMachine, char, charCode);\n                        break;\n\n                    case State.IpV4Digit:\n                        stateIpV4Digit(context, stateMachine as IpV4UrlStateMachine, charCode);\n                        break;\n                    case State.IpV4Dot:\n                        stateIpV4Dot(context, stateMachine as IpV4UrlStateMachine, charCode);\n                        break;\n\n                    case State.PortColon:\n                        statePortColon(context, stateMachine, charCode);\n                        break;\n                    case State.PortNumber:\n                        statePortNumber(context, stateMachine, charCode);\n                        break;\n                    case State.Path:\n                        statePath(context, stateMachine, charCode);\n                        break;\n\n                    // Email States\n                    case State.EmailMailto_M:\n                        stateEmailMailto_M(context, stateMachine, char, charCode);\n                        break;\n                    case State.EmailMailto_A:\n                        stateEmailMailto_A(context, stateMachine, char, charCode);\n                        break;\n                    case State.EmailMailto_I:\n                        stateEmailMailto_I(context, stateMachine, char, charCode);\n                        break;\n                    case State.EmailMailto_L:\n                        stateEmailMailto_L(context, stateMachine, char, charCode);\n                        break;\n                    case State.EmailMailto_T:\n                        stateEmailMailto_T(context, stateMachine, char, charCode);\n                        break;\n                    case State.EmailMailto_O:\n                        stateEmailMailto_O(context, stateMachine, charCode);\n                        break;\n                    case State.EmailMailto_Colon:\n                        stateEmailMailtoColon(context, stateMachine, charCode);\n                        break;\n                    case State.EmailLocalPart:\n                        stateEmailLocalPart(context, stateMachine, charCode);\n                        break;\n                    case State.EmailLocalPartDot:\n                        stateEmailLocalPartDot(context, stateMachine, charCode);\n                        break;\n                    case State.EmailAtSign:\n                        stateEmailAtSign(context, stateMachine, charCode);\n                        break;\n                    case State.EmailDomainChar:\n                        stateEmailDomainChar(context, stateMachine, charCode);\n                        break;\n                    case State.EmailDomainHyphen:\n                        stateEmailDomainHyphen(context, stateMachine, charCode);\n                        break;\n                    case State.EmailDomainDot:\n                        stateEmailDomainDot(context, stateMachine, charCode);\n                        break;\n\n                    // Hashtag states\n                    case State.HashtagHashChar:\n                        stateHashtagHashChar(context, stateMachine, charCode);\n                        break;\n                    case State.HashtagTextChar:\n                        stateHashtagTextChar(context, stateMachine, charCode);\n                        break;\n\n                    // Mention states\n                    case State.MentionAtChar:\n                        stateMentionAtChar(context, stateMachine, charCode);\n                        break;\n                    case State.MentionTextChar:\n                        stateMentionTextChar(context, stateMachine, charCode);\n                        break;\n\n                    // Phone number states\n                    case State.PhoneNumberOpenParen:\n                        statePhoneNumberOpenParen(context, stateMachine, char, charCode);\n                        break;\n                    case State.PhoneNumberAreaCodeDigit1:\n                        statePhoneNumberAreaCodeDigit1(context, stateMachine, charCode);\n                        break;\n                    case State.PhoneNumberAreaCodeDigit2:\n                        statePhoneNumberAreaCodeDigit2(context, stateMachine, charCode);\n                        break;\n                    case State.PhoneNumberAreaCodeDigit3:\n                        statePhoneNumberAreaCodeDigit3(context, stateMachine, charCode);\n                        break;\n                    case State.PhoneNumberCloseParen:\n                        statePhoneNumberCloseParen(context, stateMachine, char, charCode);\n                        break;\n                    case State.PhoneNumberPlus:\n                        statePhoneNumberPlus(context, stateMachine, char, charCode);\n                        break;\n                    case State.PhoneNumberDigit:\n                        statePhoneNumberDigit(context, stateMachine, char, charCode);\n                        break;\n                    case State.PhoneNumberSeparator:\n                        statePhoneNumberSeparator(context, stateMachine, char, charCode);\n                        break;\n                    case State.PhoneNumberControlChar:\n                        statePhoneNumberControlChar(context, stateMachine, charCode);\n                        break;\n                    case State.PhoneNumberPoundChar:\n                        statePhoneNumberPoundChar(context, stateMachine, charCode);\n                        break;\n\n                    /* istanbul ignore next */\n                    default:\n                        assertNever(stateMachine.state);\n                }\n            }\n\n            // Special case for handling a colon (or other non-alphanumeric)\n            // when preceded by another character, such as in the text:\n            //     Link 1:http://google.com\n            // In this case, the 'h' character after the colon wouldn't start a\n            // new scheme url because we'd be in a ipv4 or tld url and the colon\n            // would be interpreted as a port ':' char. Also, only start a new\n            // scheme url machine if there isn't currently one so we don't start\n            // new ones for colons inside a url\n            //\n            // TODO: The addition of this snippet (to fix the bug) in 4.0.1 lost\n            // us ~500 ops/sec on the benchmarks. Optimizing it with the\n            // hasSchemeUrlMachine() flag and optimizing the isSchemeStartChar()\n            // method for 4.1.3 got us back about ~400ops/sec. One potential way\n            // to improve this even ore is to add this snippet to individual\n            // state handler functions where it can occur to prevent running it\n            // on every loop interation.\n            if (\n                !context.hasSchemeUrlMachine() &&\n                context.charIdx > 0 &&\n                isSchemeStartChar(charCode)\n            ) {\n                const prevCharCode = context.text.charCodeAt(context.charIdx - 1);\n                if (!isSchemeStartChar(prevCharCode)) {\n                    context.addMachine(\n                        createSchemeUrlStateMachine(context.charIdx, State.SchemeChar)\n                    );\n                }\n            }\n        }\n\n        // For debugging: search for and uncomment other \"For debugging\" lines\n        // table.push([\n        //     String(context.charIdx),\n        //     char,\n        //     `10: ${char.charCodeAt(0)}\\n0x: ${char.charCodeAt(0).toString(16)}\\nU+${char.codePointAt(0)}`,\n        //     context.stateMachines.map(machine => `${StateMachineType[machine.type]}${'matchType' in machine ? ` (${UrlStateMachineMatchType[machine.matchType]})` : ''}`).join('\\n') || '(none)',\n        //     context.stateMachines.map(machine => State[machine.state]).join('\\n') || '(none)',\n        //     context.stateMachines.map(m => m.startIdx).join('\\n'),\n        //     context.stateMachines.map(m => m.acceptStateReached).join('\\n'),\n        // ]);\n    }\n\n    // Capture any valid match at the end of the string\n    // Note: this loop must happen in reverse because\n    // captureMatchIfValidAndRemove() removes state machines from the array\n    // and we'll end up skipping every other one if we remove while looping\n    // forward\n    for (let i = context.stateMachines.length - 1; i >= 0; i--) {\n        context.stateMachines.forEach(stateMachine =>\n            captureMatchIfValidAndRemove(context, stateMachine)\n        );\n    }\n\n    // For debugging: search for and uncomment other \"For debugging\" lines\n    // console.log(`\\nRead string:\\n  ${text}`);\n    // console.log(table.toString());\n\n    return context.matches;\n}\n\n/**\n * Handles the state when we're not in a URL/email/etc. (i.e. when no state machines exist)\n */\nfunction stateNoMatch(context: ParseMatchesContext, char: string, charCode: number): void {\n    const { charIdx } = context;\n\n    if (charCode === Char.NumberSign /* '#' */) {\n        // Hash char, start a Hashtag match\n        context.addMachine(createHashtagStateMachine(charIdx, State.HashtagHashChar));\n    } else if (charCode === Char.AtSign /* '@' */) {\n        // '@' char, start a Mention match\n        context.addMachine(createMentionStateMachine(charIdx, State.MentionAtChar));\n    } else if (charCode === Char.Slash /* '/' */) {\n        // A slash could begin a protocol-relative URL\n        context.addMachine(createTldUrlStateMachine(charIdx, State.ProtocolRelativeSlash1));\n    } else if (charCode === Char.Plus /* '+' */) {\n        // A '+' char can start a Phone number\n        context.addMachine(createPhoneNumberStateMachine(charIdx, State.PhoneNumberPlus));\n    } else if (charCode === Char.OpenParen /* '(' */) {\n        context.addMachine(createPhoneNumberStateMachine(charIdx, State.PhoneNumberOpenParen));\n    } else {\n        if (isDigitChar(charCode)) {\n            // A digit could start a phone number\n            context.addMachine(createPhoneNumberStateMachine(charIdx, State.PhoneNumberDigit));\n\n            // A digit could start an IP address\n            context.addMachine(createIpV4UrlStateMachine(charIdx, State.IpV4Digit));\n        }\n\n        if (isEmailLocalPartStartChar(charCode)) {\n            // Any email local part. An 'm' character in particular could\n            // start a 'mailto:' match\n            const startState =\n                char.toLowerCase() === 'm' ? State.EmailMailto_M : State.EmailLocalPart;\n            context.addMachine(createEmailStateMachine(charIdx, startState));\n        }\n\n        if (isSchemeStartChar(charCode)) {\n            // An uppercase or lowercase letter may start a scheme match\n            context.addMachine(createSchemeUrlStateMachine(charIdx, State.SchemeChar));\n        }\n\n        if (isAlphaNumericOrMarkChar(charCode)) {\n            // A unicode alpha character or digit could start a domain name\n            // label for a TLD match\n            context.addMachine(createTldUrlStateMachine(charIdx, State.DomainLabelChar));\n        }\n    }\n\n    // Anything else, remain in the \"non-url\" state by not creating any\n    // state machines\n}\n\n// Implements ABNF: ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\nfunction stateSchemeChar(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (charCode === Char.Colon /* ':' */) {\n        stateMachine.state = State.SchemeColon;\n    } else if (charCode === Char.Dash /* '-' */) {\n        stateMachine.state = State.SchemeHyphen;\n    } else if (isSchemeChar(charCode)) {\n        // Stay in SchemeChar state\n    } else {\n        // Any other character, not a scheme\n        context.removeMachine(stateMachine);\n    }\n}\n\nfunction stateSchemeHyphen(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    const { charIdx } = context;\n\n    if (charCode === Char.Dash /* '-' */) {\n        // Stay in SchemeHyphen state\n        // TODO: Should a colon following a dash be counted as the end of the scheme?\n        // } else if (char === ':') {\n        //     stateMachine.state = State.SchemeColon;\n    } else if (charCode === Char.Slash /* '/' */) {\n        // Not a valid scheme match, but may be the start of a\n        // protocol-relative match (such as //google.com)\n        context.removeMachine(stateMachine);\n        context.addMachine(createTldUrlStateMachine(charIdx, State.ProtocolRelativeSlash1));\n    } else if (isSchemeChar(charCode)) {\n        stateMachine.state = State.SchemeChar;\n    } else {\n        // Any other character, not a scheme\n        context.removeMachine(stateMachine);\n    }\n}\n\n// https://tools.ietf.org/html/rfc3986#appendix-A\nfunction stateSchemeColon(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    const { charIdx } = context;\n\n    if (charCode === Char.Slash /* '/' */) {\n        stateMachine.state = State.SchemeSlash1;\n    } else if (charCode === Char.Dot /* '.' */) {\n        // We've read something like 'hello:.' - don't capture\n        context.removeMachine(stateMachine);\n    } else if (isDomainLabelStartChar(charCode)) {\n        stateMachine.state = State.DomainLabelChar;\n\n        // It's possible that we read an \"introduction\" piece of text,\n        // and the character after the current colon actually starts an\n        // actual scheme. An example of this is:\n        //     \"The link:http://google.com\"\n        // Hence, start a new machine to capture this match if so\n        if (isSchemeStartChar(charCode)) {\n            context.addMachine(createSchemeUrlStateMachine(charIdx, State.SchemeChar));\n        }\n    } else {\n        context.removeMachine(stateMachine);\n    }\n}\n\n// https://tools.ietf.org/html/rfc3986#appendix-A\nfunction stateSchemeSlash1(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (charCode === Char.Slash /* '/' */) {\n        stateMachine.state = State.SchemeSlash2;\n    } else if (isPathChar(charCode)) {\n        stateMachine.state = State.Path;\n        stateMachine.acceptStateReached = true;\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\nfunction stateSchemeSlash2(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (charCode === Char.Slash /* '/' */) {\n        // 3rd slash, must be an absolute path (`path-absolute` in the\n        // ABNF), such as in \"file:///c:/windows/etc\". See\n        // https://tools.ietf.org/html/rfc3986#appendix-A\n        stateMachine.state = State.Path;\n        stateMachine.acceptStateReached = true;\n    } else if (isDomainLabelStartChar(charCode)) {\n        // start of \"authority\" section - see https://tools.ietf.org/html/rfc3986#appendix-A\n        stateMachine.state = State.DomainLabelChar;\n        stateMachine.acceptStateReached = true;\n    } else {\n        // not valid\n        context.removeMachine(stateMachine);\n    }\n}\n\n// Handles after we've read a '/' from the NonUrl state\nfunction stateProtocolRelativeSlash1(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (charCode === Char.Slash /* '/' */) {\n        stateMachine.state = State.ProtocolRelativeSlash2;\n    } else {\n        // Anything else, cannot be the start of a protocol-relative\n        // URL.\n        context.removeMachine(stateMachine);\n    }\n}\n\n// Handles after we've read a second '/', which could start a protocol-relative URL\nfunction stateProtocolRelativeSlash2(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isDomainLabelStartChar(charCode)) {\n        stateMachine.state = State.DomainLabelChar;\n    } else {\n        // Anything else, not a URL\n        context.removeMachine(stateMachine);\n    }\n}\n\n// Handles when we have read a domain label character\nfunction stateDomainLabelChar(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (charCode === Char.Dot /* '.' */) {\n        stateMachine.state = State.DomainDot;\n    } else if (charCode === Char.Dash /* '-' */) {\n        stateMachine.state = State.DomainHyphen;\n    } else if (charCode === Char.Colon /* ':' */) {\n        // Beginning of a port number, end the domain name\n        stateMachine.state = State.PortColon;\n    } else if (isUrlSuffixStartChar(charCode)) {\n        // '/', '?', or '#'\n        stateMachine.state = State.Path;\n    } else if (isDomainLabelChar(charCode)) {\n        // Stay in the DomainLabelChar state\n    } else {\n        // Anything else, end the domain name\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\nfunction stateDomainHyphen(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (charCode === Char.Dash /* '-' */) {\n        // Remain in the DomainHyphen state\n    } else if (charCode === Char.Dot /* '.' */) {\n        // Not valid to have a '-.' in a domain label\n        captureMatchIfValidAndRemove(context, stateMachine);\n    } else if (isDomainLabelStartChar(charCode)) {\n        stateMachine.state = State.DomainLabelChar;\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\nfunction stateDomainDot(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (charCode === Char.Dot /* '.' */) {\n        // domain names cannot have multiple '.'s next to each other.\n        // It's possible we've already read a valid domain name though,\n        // and that the '..' sequence just forms an ellipsis at the end\n        // of a sentence\n        captureMatchIfValidAndRemove(context, stateMachine);\n    } else if (isDomainLabelStartChar(charCode)) {\n        stateMachine.state = State.DomainLabelChar;\n        stateMachine.acceptStateReached = true; // after hitting a dot, and then another domain label, we've reached an accept state\n    } else {\n        // Anything else, end the domain name\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\nfunction stateIpV4Digit(\n    context: ParseMatchesContext,\n    stateMachine: IpV4UrlStateMachine,\n    charCode: number\n) {\n    if (charCode === Char.Dot /* '.' */) {\n        stateMachine.state = State.IpV4Dot;\n    } else if (charCode === Char.Colon /* ':' */) {\n        // Beginning of a port number\n        stateMachine.state = State.PortColon;\n    } else if (isDigitChar(charCode)) {\n        // stay in the IPv4 digit state\n    } else if (isUrlSuffixStartChar(charCode)) {\n        stateMachine.state = State.Path;\n    } else if (isAlphaNumericOrMarkChar(charCode)) {\n        // If we hit an alpha character, must not be an IPv4\n        // Example of this: 1.2.3.4abc\n        context.removeMachine(stateMachine);\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\nfunction stateIpV4Dot(\n    context: ParseMatchesContext,\n    stateMachine: IpV4UrlStateMachine,\n    charCode: number\n) {\n    if (isDigitChar(charCode)) {\n        stateMachine.octetsEncountered++;\n\n        // Once we have encountered 4 octets, it's *potentially* a valid\n        // IPv4 address. Our IPv4 regex will confirm the match later\n        // though to make sure each octet is in the 0-255 range, and\n        // there's exactly 4 octets (not 5 or more)\n        if (stateMachine.octetsEncountered === 4) {\n            stateMachine.acceptStateReached = true;\n        }\n\n        stateMachine.state = State.IpV4Digit;\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\nfunction statePortColon(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isDigitChar(charCode)) {\n        stateMachine.state = State.PortNumber;\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\nfunction statePortNumber(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isDigitChar(charCode)) {\n        // Stay in port number state\n    } else if (isUrlSuffixStartChar(charCode)) {\n        // '/', '?', or '#'\n        stateMachine.state = State.Path;\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\nfunction statePath(context: ParseMatchesContext, stateMachine: StateMachine, charCode: number) {\n    if (isPathChar(charCode)) {\n        // Stay in the path state\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\n// Handles if we're reading a 'mailto:' prefix on the string\nfunction stateEmailMailto_M(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (char.toLowerCase() === 'a') {\n        stateMachine.state = State.EmailMailto_A;\n    } else {\n        stateEmailLocalPart(context, stateMachine, charCode);\n    }\n}\n\nfunction stateEmailMailto_A(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (char.toLowerCase() === 'i') {\n        stateMachine.state = State.EmailMailto_I;\n    } else {\n        stateEmailLocalPart(context, stateMachine, charCode);\n    }\n}\n\nfunction stateEmailMailto_I(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (char.toLowerCase() === 'l') {\n        stateMachine.state = State.EmailMailto_L;\n    } else {\n        stateEmailLocalPart(context, stateMachine, charCode);\n    }\n}\n\nfunction stateEmailMailto_L(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (char.toLowerCase() === 't') {\n        stateMachine.state = State.EmailMailto_T;\n    } else {\n        stateEmailLocalPart(context, stateMachine, charCode);\n    }\n}\n\nfunction stateEmailMailto_T(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (char.toLowerCase() === 'o') {\n        stateMachine.state = State.EmailMailto_O;\n    } else {\n        stateEmailLocalPart(context, stateMachine, charCode);\n    }\n}\n\nfunction stateEmailMailto_O(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (charCode === Char.Colon /* ':' */) {\n        stateMachine.state = State.EmailMailto_Colon;\n    } else {\n        stateEmailLocalPart(context, stateMachine, charCode);\n    }\n}\n\nfunction stateEmailMailtoColon(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isEmailLocalPartChar(charCode)) {\n        stateMachine.state = State.EmailLocalPart;\n    } else {\n        context.removeMachine(stateMachine);\n    }\n}\n\n// Handles the state when we're currently in the \"local part\" of an\n// email address (as opposed to the \"domain part\")\nfunction stateEmailLocalPart(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (charCode === Char.Dot /* '.' */) {\n        stateMachine.state = State.EmailLocalPartDot;\n    } else if (charCode === Char.AtSign /* '@' */) {\n        stateMachine.state = State.EmailAtSign;\n    } else if (isEmailLocalPartChar(charCode)) {\n        // stay in the \"local part\" of the email address\n        // Note: because stateEmailLocalPart() is called from the\n        // 'mailto' states (when the 'mailto' prefix itself has been\n        // broken), make sure to set the state to EmailLocalPart\n        stateMachine.state = State.EmailLocalPart;\n    } else {\n        // not an email address character\n        context.removeMachine(stateMachine);\n    }\n}\n\n// Handles the state where we've read a '.' character in the local part of\n// the email address (i.e. the part before the '@' character)\nfunction stateEmailLocalPartDot(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (charCode === Char.Dot /* '.' */) {\n        // We read a second '.' in a row, not a valid email address\n        // local part\n        context.removeMachine(stateMachine);\n    } else if (charCode === Char.AtSign /* '@' */) {\n        // We read the '@' character immediately after a dot ('.'), not\n        // an email address\n        context.removeMachine(stateMachine);\n    } else if (isEmailLocalPartChar(charCode)) {\n        stateMachine.state = State.EmailLocalPart;\n    } else {\n        // Anything else, not an email address\n        context.removeMachine(stateMachine);\n    }\n}\n\nfunction stateEmailAtSign(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isDomainLabelStartChar(charCode)) {\n        stateMachine.state = State.EmailDomainChar;\n    } else {\n        // Anything else, not an email address\n        context.removeMachine(stateMachine);\n    }\n}\n\nfunction stateEmailDomainChar(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (charCode === Char.Dot /* '.' */) {\n        stateMachine.state = State.EmailDomainDot;\n    } else if (charCode === Char.Dash /* '-' */) {\n        stateMachine.state = State.EmailDomainHyphen;\n    } else if (isDomainLabelChar(charCode)) {\n        // Stay in the DomainChar state\n    } else {\n        // Anything else, we potentially matched if the criteria has\n        // been met\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\nfunction stateEmailDomainHyphen(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (charCode === Char.Dash /* '-' */ || charCode === Char.Dot /* '.' */) {\n        // Not valid to have two hyphens (\"--\") or hypen+dot (\"-.\")\n        captureMatchIfValidAndRemove(context, stateMachine);\n    } else if (isDomainLabelChar(charCode)) {\n        stateMachine.state = State.EmailDomainChar;\n    } else {\n        // Anything else\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\nfunction stateEmailDomainDot(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (charCode === Char.Dot /* '.' */ || charCode === Char.Dash /* '-' */) {\n        // not valid to have two dots (\"..\") or dot+hypen (\".-\")\n        captureMatchIfValidAndRemove(context, stateMachine);\n    } else if (isDomainLabelStartChar(charCode)) {\n        stateMachine.state = State.EmailDomainChar;\n\n        // After having read a '.' and then a valid domain character,\n        // we now know that the domain part of the email is valid, and\n        // we have found at least a partial EmailMatch (however, the\n        // email address may have additional characters from this point)\n        stateMachine.acceptStateReached = true;\n    } else {\n        // Anything else\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\n// Handles the state when we've just encountered a '#' character\nfunction stateHashtagHashChar(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isHashtagTextChar(charCode)) {\n        // '#' char with valid hash text char following\n        stateMachine.state = State.HashtagTextChar;\n        stateMachine.acceptStateReached = true;\n    } else {\n        context.removeMachine(stateMachine);\n    }\n}\n\n// Handles the state when we're currently in the hash tag's text chars\nfunction stateHashtagTextChar(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isHashtagTextChar(charCode)) {\n        // Continue reading characters in the HashtagText state\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\n// Handles the state when we've just encountered a '@' character\nfunction stateMentionAtChar(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isMentionTextChar(charCode)) {\n        // '@' char with valid mention text char following\n        stateMachine.state = State.MentionTextChar;\n        stateMachine.acceptStateReached = true;\n    } else {\n        context.removeMachine(stateMachine);\n    }\n}\n\n// Handles the state when we're currently in the mention's text chars\nfunction stateMentionTextChar(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isMentionTextChar(charCode)) {\n        // Continue reading characters in the HashtagText state\n    } else if (isAlphaNumericOrMarkChar(charCode)) {\n        // Char is invalid for a mention text char, not a valid match.\n        // Note that ascii alphanumeric chars are okay (which are tested\n        // in the previous 'if' statement, but others are not)\n        context.removeMachine(stateMachine);\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\nfunction statePhoneNumberPlus(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (isDigitChar(charCode)) {\n        stateMachine.state = State.PhoneNumberDigit;\n    } else {\n        context.removeMachine(stateMachine);\n\n        // This character may start a new match. Add states for it\n        stateNoMatch(context, char, charCode);\n    }\n}\n\nfunction statePhoneNumberOpenParen(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (isDigitChar(charCode)) {\n        stateMachine.state = State.PhoneNumberAreaCodeDigit1;\n    } else {\n        context.removeMachine(stateMachine);\n    }\n\n    // It's also possible that the paren was just an open brace for\n    // a piece of text. Start other machines\n    stateNoMatch(context, char, charCode);\n}\n\nfunction statePhoneNumberAreaCodeDigit1(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isDigitChar(charCode)) {\n        stateMachine.state = State.PhoneNumberAreaCodeDigit2;\n    } else {\n        context.removeMachine(stateMachine);\n    }\n}\n\nfunction statePhoneNumberAreaCodeDigit2(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isDigitChar(charCode)) {\n        stateMachine.state = State.PhoneNumberAreaCodeDigit3;\n    } else {\n        context.removeMachine(stateMachine);\n    }\n}\n\nfunction statePhoneNumberAreaCodeDigit3(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (charCode === Char.CloseParen /* ')' */) {\n        stateMachine.state = State.PhoneNumberCloseParen;\n    } else {\n        context.removeMachine(stateMachine);\n    }\n}\n\nfunction statePhoneNumberCloseParen(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (isDigitChar(charCode)) {\n        stateMachine.state = State.PhoneNumberDigit;\n    } else if (isPhoneNumberSeparatorChar(charCode)) {\n        stateMachine.state = State.PhoneNumberSeparator;\n    } else {\n        context.removeMachine(stateMachine);\n    }\n}\n\nfunction statePhoneNumberDigit(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    const { charIdx } = context;\n\n    // For now, if we've reached any digits, we'll say that the machine\n    // has reached its accept state. The phone regex will confirm the\n    // match later.\n    // Alternatively, we could count the number of digits to avoid\n    // invoking the phone number regex\n    stateMachine.acceptStateReached = true;\n\n    if (isPhoneNumberControlChar(charCode)) {\n        stateMachine.state = State.PhoneNumberControlChar;\n    } else if (charCode === Char.NumberSign /* '#' */) {\n        stateMachine.state = State.PhoneNumberPoundChar;\n    } else if (isDigitChar(charCode)) {\n        // Stay in the phone number digit state\n    } else if (charCode === Char.OpenParen /* '(' */) {\n        stateMachine.state = State.PhoneNumberOpenParen;\n    } else if (isPhoneNumberSeparatorChar(charCode)) {\n        stateMachine.state = State.PhoneNumberSeparator;\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n\n        // The transition from a digit character to a letter can be the\n        // start of a new scheme URL match\n        if (isSchemeStartChar(charCode)) {\n            context.addMachine(createSchemeUrlStateMachine(charIdx, State.SchemeChar));\n        }\n    }\n}\n\nfunction statePhoneNumberSeparator(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    char: string,\n    charCode: number\n) {\n    if (isDigitChar(charCode)) {\n        stateMachine.state = State.PhoneNumberDigit;\n    } else if (charCode === Char.OpenParen /* '(' */) {\n        stateMachine.state = State.PhoneNumberOpenParen;\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n\n        // This character may start a new match. Add states for it\n        stateNoMatch(context, char, charCode);\n    }\n}\n\n// The \";\" characters is \"wait\" in a phone number\n// The \",\" characters is \"pause\" in a phone number\nfunction statePhoneNumberControlChar(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isPhoneNumberControlChar(charCode)) {\n        // Stay in the \"control char\" state\n    } else if (charCode === Char.NumberSign /* '#' */) {\n        stateMachine.state = State.PhoneNumberPoundChar;\n    } else if (isDigitChar(charCode)) {\n        stateMachine.state = State.PhoneNumberDigit;\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\n// The \"#\" characters is \"pound\" in a phone number\nfunction statePhoneNumberPoundChar(\n    context: ParseMatchesContext,\n    stateMachine: StateMachine,\n    charCode: number\n) {\n    if (isPhoneNumberControlChar(charCode)) {\n        stateMachine.state = State.PhoneNumberControlChar;\n    } else if (isDigitChar(charCode)) {\n        // According to some of the older tests, if there's a digit\n        // after a '#' sign, the match is invalid. TODO: Revisit if this is true\n        context.removeMachine(stateMachine);\n    } else {\n        captureMatchIfValidAndRemove(context, stateMachine);\n    }\n}\n\n/*\n * Captures a match if it is valid (i.e. has a full domain name for a\n * TLD match). If a match is not valid, it is possible that we want to\n * keep reading characters in order to make a full match.\n */\nfunction captureMatchIfValidAndRemove(context: ParseMatchesContext, stateMachine: StateMachine) {\n    const {\n        matches,\n        text,\n        charIdx,\n        tagBuilder,\n        stripPrefix,\n        stripTrailingSlash,\n        decodePercentEncoding,\n        hashtagServiceName,\n        mentionServiceName,\n    } = context;\n\n    // Remove the state machine first. There are a number of code paths\n    // which return out of this function early, so make sure we have\n    // this done\n    context.removeMachine(stateMachine);\n\n    // Make sure the state machine being checked has actually reached an\n    // \"accept\" state. If it hasn't reach one, it can't be a match\n    if (!stateMachine.acceptStateReached) {\n        return;\n    }\n\n    let startIdx = stateMachine.startIdx;\n    let matchedText = text.slice(stateMachine.startIdx, charIdx);\n\n    // Handle any unbalanced braces (parens, square brackets, or curly\n    // brackets) inside the URL. This handles situations like:\n    //     The link (google.com)\n    // and\n    //     Check out this link here (en.wikipedia.org/wiki/IANA_(disambiguation))\n    //\n    // And also remove any punctuation chars at the end such as:\n    //     '?', ',', ':', '.', etc.\n    matchedText = excludeUnbalancedTrailingBracesAndPunctuation(matchedText);\n\n    switch (stateMachine.type) {\n        case StateMachineType.Url: {\n            // We don't want to accidentally match a URL that is preceded by an\n            // '@' character, which would be an email address\n            const charBeforeUrlMatch = text.charCodeAt(stateMachine.startIdx - 1);\n            if (charBeforeUrlMatch === Char.AtSign /* '@' */) {\n                return;\n            }\n\n            switch (stateMachine.matchType) {\n                case UrlStateMachineMatchType.Scheme: {\n                    // Autolinker accepts many characters in a url's scheme (like `fake://test.com`).\n                    // However, in cases where a URL is missing whitespace before an obvious link,\n                    // (for example: `nowhitespacehttp://www.test.com`), we only want the match to start\n                    // at the http:// part. We will check if the match contains a common scheme and then\n                    // shift the match to start from there.\n                    const httpSchemeMatch = httpSchemeRe.exec(matchedText);\n                    if (httpSchemeMatch) {\n                        // If we found an overmatched URL, we want to find the index\n                        // of where the match should start and shift the match to\n                        // start from the beginning of the common scheme\n                        startIdx = startIdx + httpSchemeMatch.index;\n                        matchedText = matchedText.slice(httpSchemeMatch.index);\n                    }\n\n                    if (!isValidSchemeUrl(matchedText)) {\n                        return; // not a valid match\n                    }\n                    break;\n                }\n\n                case UrlStateMachineMatchType.Tld: {\n                    if (!isValidTldMatch(matchedText)) {\n                        return; // not a valid match\n                    }\n                    break;\n                }\n\n                case UrlStateMachineMatchType.IpV4: {\n                    if (!isValidIpV4Address(matchedText)) {\n                        return; // not a valid match\n                    }\n                    break;\n                }\n\n                /* istanbul ignore next */\n                default:\n                    assertNever(stateMachine);\n            }\n\n            matches.push(\n                new UrlMatch({\n                    tagBuilder: tagBuilder,\n                    matchedText: matchedText,\n                    offset: startIdx,\n                    urlMatchType: toUrlMatchType(stateMachine.matchType),\n                    url: matchedText,\n                    protocolRelativeMatch: matchedText.slice(0, 2) === '//',\n\n                    // TODO: Do these settings need to be passed to the match,\n                    // or should we handle them here in UrlMatcher?\n                    stripPrefix: stripPrefix,\n                    stripTrailingSlash: stripTrailingSlash,\n                    decodePercentEncoding: decodePercentEncoding,\n                })\n            );\n            break;\n        }\n\n        case StateMachineType.Email: {\n            // if the email address has a valid TLD, add it to the list of matches\n            if (isValidEmail(matchedText)) {\n                matches.push(\n                    new EmailMatch({\n                        tagBuilder: tagBuilder,\n                        matchedText: matchedText,\n                        offset: startIdx,\n                        email: matchedText.replace(mailtoSchemePrefixRe, ''),\n                    })\n                );\n            }\n            break;\n        }\n\n        case StateMachineType.Hashtag: {\n            if (isValidHashtag(matchedText)) {\n                matches.push(\n                    new HashtagMatch({\n                        tagBuilder,\n                        matchedText: matchedText,\n                        offset: startIdx,\n                        serviceName: hashtagServiceName,\n                        hashtag: matchedText.slice(1),\n                    })\n                );\n            }\n            break;\n        }\n\n        case StateMachineType.Mention: {\n            if (isValidMention(matchedText, mentionServiceName)) {\n                matches.push(\n                    new MentionMatch({\n                        tagBuilder: tagBuilder,\n                        matchedText: matchedText,\n                        offset: startIdx,\n                        serviceName: mentionServiceName,\n                        mention: matchedText.slice(1), // strip off the '@' character at the beginning\n                    })\n                );\n            }\n            break;\n        }\n\n        case StateMachineType.Phone: {\n            // remove any trailing spaces that were considered as \"separator\"\n            // chars by the state machine\n            matchedText = matchedText.replace(/ +$/g, '');\n\n            if (isValidPhoneNumber(matchedText)) {\n                const cleanNumber = matchedText.replace(/[^0-9,;#]/g, ''); // strip out non-digit characters exclude comma semicolon and #\n\n                matches.push(\n                    new PhoneMatch({\n                        tagBuilder: tagBuilder,\n                        matchedText: matchedText,\n                        offset: startIdx,\n                        number: cleanNumber,\n                        plusSign: matchedText.charAt(0) === '+',\n                    })\n                );\n            }\n            break;\n        }\n\n        /* istanbul ignore next */\n        default:\n            assertNever(stateMachine);\n    }\n}\n\nexport interface ParseMatchesArgs {\n    tagBuilder: AnchorTagBuilder;\n    stripPrefix: Required<StripPrefixConfigObj>;\n    stripTrailingSlash: boolean;\n    decodePercentEncoding: boolean;\n    hashtagServiceName: HashtagService;\n    mentionServiceName: MentionService;\n}\n\n/**\n * Helper function to convert a UrlStateMachineMatchType value to its\n * UrlMatchType equivalent.\n */\nfunction toUrlMatchType(stateMachineMatchType: UrlStateMachineMatchType): UrlMatchType {\n    switch (stateMachineMatchType) {\n        case UrlStateMachineMatchType.Scheme:\n            return 'scheme';\n        case UrlStateMachineMatchType.Tld:\n            return 'tld';\n        case UrlStateMachineMatchType.IpV4:\n            return 'ipV4';\n\n        /* istanbul ignore next */\n        default:\n            assertNever(stateMachineMatchType);\n    }\n}\n\nconst oppositeBrace: { [char: string]: string } = {\n    ')': '(',\n    '}': '{',\n    ']': '[',\n};\n\n/**\n * Determines if a match found has unmatched closing parenthesis,\n * square brackets or curly brackets. If so, these unbalanced symbol(s) will be\n * removed from the URL match itself.\n *\n * A match may have an extra closing parenthesis/square brackets/curly brackets\n * at the end of the match because these are valid URL path characters. For\n * example, \"wikipedia.com/something_(disambiguation)\" should be auto-linked.\n *\n * However, an extra parenthesis *will* be included when the URL itself is\n * wrapped in parenthesis, such as in the case of:\n *\n *     \"(wikipedia.com/something_(disambiguation))\"\n *\n * In this case, the last closing parenthesis should *not* be part of the\n * URL itself, and this method will exclude it from the returned URL.\n *\n * For square brackets in URLs such as in PHP arrays, the same behavior as\n * parenthesis discussed above should happen:\n *\n *     \"[http://www.example.com/foo.php?bar[]=1&bar[]=2&bar[]=3]\"\n *\n * The very last closing square bracket should not be part of the URL itself,\n * and therefore this method will remove it.\n *\n * @param matchedText The full matched URL/email/hashtag/etc. from the state\n *   machine parser.\n * @return The updated matched text with extraneous suffix characters removed.\n */\nexport function excludeUnbalancedTrailingBracesAndPunctuation(matchedText: string): string {\n    const braceCounts: { [char: string]: number } = {\n        '(': 0,\n        '{': 0,\n        '[': 0,\n    };\n\n    for (let i = 0; i < matchedText.length; i++) {\n        const char = matchedText.charAt(i);\n        const charCode = matchedText.charCodeAt(i);\n\n        if (isOpenBraceChar(charCode)) {\n            braceCounts[char]++;\n        } else if (isCloseBraceChar(charCode)) {\n            braceCounts[oppositeBrace[char]]--;\n        }\n    }\n\n    let endIdx = matchedText.length - 1;\n    while (endIdx >= 0) {\n        const char = matchedText.charAt(endIdx);\n        const charCode = matchedText.charCodeAt(endIdx);\n\n        if (isCloseBraceChar(charCode)) {\n            const oppositeBraceChar = oppositeBrace[char];\n\n            if (braceCounts[oppositeBraceChar] < 0) {\n                braceCounts[oppositeBraceChar]++;\n                endIdx--;\n            } else {\n                break;\n            }\n        } else if (isUrlSuffixNotAllowedAsFinalChar(charCode)) {\n            // Walk back a punctuation char like '?', ',', ':', '.', etc.\n            endIdx--;\n        } else {\n            break;\n        }\n    }\n\n    return matchedText.slice(0, endIdx + 1);\n}\n\n// States for the parser\n// For debugging: temporarily remove `const` from `const enum`\nconst enum State {\n    // Scheme states\n    SchemeChar = 0, // First char must be an ASCII letter. Subsequent characters can be: ALPHA / DIGIT / \"+\" / \"-\" / \".\"\n    SchemeHyphen, // Extra state used to figure out when we can start a new match after (such as if we have '-//' which starts a protocol-relative match)\n    SchemeColon, // Once we've reached the colon character after a scheme name\n    SchemeSlash1,\n    SchemeSlash2,\n\n    DomainLabelChar, // Note: Domain labels must begin with a letter or number (no hyphens), and can include unicode letters\n    DomainHyphen,\n    DomainDot,\n    PortColon,\n    PortNumber,\n    Path,\n\n    // Protocol-relative URL states\n    ProtocolRelativeSlash1,\n    ProtocolRelativeSlash2,\n\n    // IPv4 States\n    IpV4Digit,\n    IpV4Dot,\n\n    // Email Address States\n    EmailMailto_M, // if matching a 'mailto:' prefix\n    EmailMailto_A, // if matching a 'mailto:' prefix\n    EmailMailto_I, // if matching a 'mailto:' prefix\n    EmailMailto_L, // if matching a 'mailto:' prefix\n    EmailMailto_T, // if matching a 'mailto:' prefix\n    EmailMailto_O, // if matching a 'mailto:' prefix\n    EmailMailto_Colon,\n    EmailLocalPart,\n    EmailLocalPartDot,\n    EmailAtSign,\n    EmailDomainChar,\n    EmailDomainHyphen,\n    EmailDomainDot,\n\n    // Hashtag States\n    HashtagHashChar, // When we've encountered the '#' char\n    HashtagTextChar, // Inside a hashtag char\n\n    // Mention State\n    MentionAtChar,\n    MentionTextChar,\n\n    // Phone Number States\n    PhoneNumberOpenParen,\n    PhoneNumberAreaCodeDigit1, // a digit inside area code parens, such as the '1' in '(123)456-7890'\n    PhoneNumberAreaCodeDigit2, // a digit inside area code parens, such as the '2' in '(123)456-7890'\n    PhoneNumberAreaCodeDigit3, // a digit inside area code parens, such as the '3' in '(123)456-7890'\n    PhoneNumberCloseParen,\n    PhoneNumberPlus,\n    PhoneNumberDigit, // a digit outside of area code parens\n    PhoneNumberSeparator, // '-', '.' or ' '\n    PhoneNumberControlChar, // ',' for 1 second pause, ';' for \"wait\" for user to take action\n    PhoneNumberPoundChar, // '#' for pound character\n}\n\n// The type of state machine\n// For debugging: temporarily remove `const` from `const enum`\nconst enum StateMachineType {\n    Url = 0,\n    Email,\n    Hashtag,\n    Mention,\n    Phone,\n}\n\ntype StateMachine =\n    | UrlStateMachine\n    | EmailStateMachine\n    | MentionStateMachine\n    | HashtagStateMachine\n    | PhoneNumberStateMachine;\n\ninterface AbstractStateMachine {\n    startIdx: number; // the index of the first character in the match\n    state: State;\n    acceptStateReached: boolean;\n}\n\n// The type of URL state machine\n// For debugging: temporarily remove `const` from `const enum`\nconst enum UrlStateMachineMatchType {\n    Scheme = 0, // http://, https://, file://, etc. match\n    Tld, // Top-level Domain (TLD)\n    IpV4, // 192.168.0.1\n}\n\ninterface AbstractUrlStateMachine extends AbstractStateMachine {\n    readonly type: StateMachineType.Url;\n}\n\ntype UrlStateMachine = SchemeUrlStateMachine | TldUrlStateMachine | IpV4UrlStateMachine;\n\n/**\n * State machine with metadata for capturing TLD (top-level domain) URLs.\n */\ninterface SchemeUrlStateMachine extends AbstractUrlStateMachine {\n    readonly matchType: UrlStateMachineMatchType.Scheme;\n}\n\n/**\n * State machine with metadata for capturing TLD (top-level domain) URLs.\n */\ninterface TldUrlStateMachine extends AbstractUrlStateMachine {\n    readonly matchType: UrlStateMachineMatchType.Tld;\n}\n\n/**\n * State machine for capturing IPv4 addresses that are not prefixed with a\n * scheme (such as 'http://').\n */\ninterface IpV4UrlStateMachine extends AbstractUrlStateMachine {\n    readonly matchType: UrlStateMachineMatchType.IpV4;\n    octetsEncountered: number; // if we encounter a number of octets other than 4, it's not an IPv4 address\n}\n\n/**\n * State machine for capturing email addresses.\n */\ninterface EmailStateMachine extends AbstractStateMachine {\n    readonly type: StateMachineType.Email;\n}\n\n/**\n * State machine for capturing hashtags.\n */\ninterface HashtagStateMachine extends AbstractStateMachine {\n    readonly type: StateMachineType.Hashtag;\n}\n\n/**\n * State machine for capturing hashtags.\n */\ninterface MentionStateMachine extends AbstractStateMachine {\n    readonly type: StateMachineType.Mention;\n}\n\n/**\n * State machine for capturing phone numbers.\n *\n * Note: this doesn't actually capture phone numbers at the moment, but is used\n * to exclude phone number matches from URLs where the URL matcher would\n * otherwise potentially think a phone number is part of a domain label.\n */\ninterface PhoneNumberStateMachine extends AbstractStateMachine {\n    readonly type: StateMachineType.Phone;\n}\n\nfunction createSchemeUrlStateMachine(startIdx: number, state: State): SchemeUrlStateMachine {\n    return {\n        type: StateMachineType.Url,\n        startIdx,\n        state,\n        acceptStateReached: false,\n        matchType: UrlStateMachineMatchType.Scheme,\n    };\n}\n\nfunction createTldUrlStateMachine(startIdx: number, state: State): TldUrlStateMachine {\n    return {\n        type: StateMachineType.Url,\n        startIdx,\n        state,\n        acceptStateReached: false,\n        matchType: UrlStateMachineMatchType.Tld,\n    };\n}\n\nfunction createIpV4UrlStateMachine(startIdx: number, state: State): IpV4UrlStateMachine {\n    return {\n        type: StateMachineType.Url,\n        startIdx,\n        state,\n        acceptStateReached: false,\n        matchType: UrlStateMachineMatchType.IpV4,\n        octetsEncountered: 1, // starts at 1 because we create this machine when encountering the first octet\n    };\n}\n\nfunction createEmailStateMachine(startIdx: number, state: State): EmailStateMachine {\n    return {\n        type: StateMachineType.Email,\n        startIdx,\n        state,\n        acceptStateReached: false,\n    };\n}\n\nfunction createHashtagStateMachine(startIdx: number, state: State): HashtagStateMachine {\n    return {\n        type: StateMachineType.Hashtag,\n        startIdx,\n        state,\n        acceptStateReached: false,\n    };\n}\n\nfunction createMentionStateMachine(startIdx: number, state: State): MentionStateMachine {\n    return {\n        type: StateMachineType.Mention,\n        startIdx,\n        state,\n        acceptStateReached: false,\n    };\n}\n\nfunction createPhoneNumberStateMachine(startIdx: number, state: State): PhoneNumberStateMachine {\n    return {\n        type: StateMachineType.Phone,\n        startIdx,\n        state,\n        acceptStateReached: false,\n    };\n}\n\nfunction isSchemeUrlStateMachine(machine: StateMachine): machine is SchemeUrlStateMachine {\n    return (\n        machine.type === StateMachineType.Url &&\n        machine.matchType === UrlStateMachineMatchType.Scheme\n    );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}