{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport buildModuleUrl from \"../Core/buildModuleUrl.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport ReferenceFrame from \"../Core/ReferenceFrame.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TimeInterval from \"../Core/TimeInterval.js\";\nimport TimeIntervalCollection from \"../Core/TimeIntervalCollection.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport HorizontalOrigin from \"../Scene/HorizontalOrigin.js\";\nimport VerticalOrigin from \"../Scene/VerticalOrigin.js\";\nimport { configure, BlobReader, BlobWriter, TextReader, ZipWriter } from \"@zip.js/zip.js/lib/zip-core.js\";\nimport BillboardGraphics from \"./BillboardGraphics.js\";\nimport CompositePositionProperty from \"./CompositePositionProperty.js\";\nimport ModelGraphics from \"./ModelGraphics.js\";\nimport RectangleGraphics from \"./RectangleGraphics.js\";\nimport SampledPositionProperty from \"./SampledPositionProperty.js\";\nimport SampledProperty from \"./SampledProperty.js\";\nimport ScaledPositionProperty from \"./ScaledPositionProperty.js\";\nconst BILLBOARD_SIZE = 32;\nconst kmlNamespace = \"http://www.opengis.net/kml/2.2\";\nconst gxNamespace = \"http://www.google.com/kml/ext/2.2\";\nconst xmlnsNamespace = \"http://www.w3.org/2000/xmlns/\";\n\n//\n// Handles files external to the KML (eg. textures and models)\n//\nfunction ExternalFileHandler(modelCallback) {\n  this._files = {};\n  this._promises = [];\n  this._count = 0;\n  this._modelCallback = modelCallback;\n}\nconst imageTypeRegex = /^data:image\\/([^,;]+)/;\nExternalFileHandler.prototype.texture = function (texture) {\n  const that = this;\n  let filename;\n  if (typeof texture === \"string\" || texture instanceof Resource) {\n    texture = Resource.createIfNeeded(texture);\n    if (!texture.isDataUri) {\n      return texture.url;\n    }\n\n    // If its a data URI try and get the correct extension and then fetch the blob\n    const regexResult = texture.url.match(imageTypeRegex);\n    filename = `texture_${++this._count}`;\n    if (defined(regexResult)) {\n      filename += `.${regexResult[1]}`;\n    }\n    const promise = texture.fetchBlob().then(function (blob) {\n      that._files[filename] = blob;\n    });\n    this._promises.push(promise);\n    return filename;\n  }\n  if (texture instanceof HTMLCanvasElement) {\n    filename = `texture_${++this._count}.png`;\n    const promise = new Promise(resolve => {\n      texture.toBlob(function (blob) {\n        that._files[filename] = blob;\n        resolve();\n      });\n    });\n    this._promises.push(promise);\n    return filename;\n  }\n  return \"\";\n};\nfunction getModelBlobHander(that, filename) {\n  return function (blob) {\n    that._files[filename] = blob;\n  };\n}\nExternalFileHandler.prototype.model = function (model, time) {\n  const modelCallback = this._modelCallback;\n  if (!defined(modelCallback)) {\n    throw new RuntimeError(\"Encountered a model entity while exporting to KML, but no model callback was supplied.\");\n  }\n  const externalFiles = {};\n  const url = modelCallback(model, time, externalFiles);\n\n  // Iterate through external files and add them to our list once the promise resolves\n  for (const filename in externalFiles) {\n    if (externalFiles.hasOwnProperty(filename)) {\n      const promise = Promise.resolve(externalFiles[filename]);\n      this._promises.push(promise);\n      promise.then(getModelBlobHander(this, filename));\n    }\n  }\n  return url;\n};\nObject.defineProperties(ExternalFileHandler.prototype, {\n  promise: {\n    get: function () {\n      return Promise.all(this._promises);\n    }\n  },\n  files: {\n    get: function () {\n      return this._files;\n    }\n  }\n});\n\n//\n// Handles getting values from properties taking the desired time and default values into account\n//\nfunction ValueGetter(time) {\n  this._time = time;\n}\nValueGetter.prototype.get = function (property, defaultVal, result) {\n  let value;\n  if (defined(property)) {\n    value = defined(property.getValue) ? property.getValue(this._time, result) : property;\n  }\n  return value ?? defaultVal;\n};\nValueGetter.prototype.getColor = function (property, defaultVal) {\n  const result = this.get(property, defaultVal);\n  if (defined(result)) {\n    return colorToString(result);\n  }\n};\nValueGetter.prototype.getMaterialType = function (property) {\n  if (!defined(property)) {\n    return;\n  }\n  return property.getType(this._time);\n};\n\n//\n// Caches styles so we don't generate a ton of duplicate styles\n//\nfunction StyleCache() {\n  this._ids = {};\n  this._styles = {};\n  this._count = 0;\n}\nStyleCache.prototype.get = function (element) {\n  const ids = this._ids;\n  const key = element.innerHTML;\n  if (defined(ids[key])) {\n    return ids[key];\n  }\n  let styleId = `style-${++this._count}`;\n  element.setAttribute(\"id\", styleId);\n\n  // Store with #\n  styleId = `#${styleId}`;\n  ids[key] = styleId;\n  this._styles[key] = element;\n  return styleId;\n};\nStyleCache.prototype.save = function (parentElement) {\n  const styles = this._styles;\n  const firstElement = parentElement.childNodes[0];\n  for (const key in styles) {\n    if (styles.hasOwnProperty(key)) {\n      parentElement.insertBefore(styles[key], firstElement);\n    }\n  }\n};\n\n//\n// Manages the generation of IDs because an entity may have geometry and a Folder for children\n//\nfunction IdManager() {\n  this._ids = {};\n}\nIdManager.prototype.get = function (id) {\n  if (!defined(id)) {\n    return this.get(createGuid());\n  }\n  const ids = this._ids;\n  if (!defined(ids[id])) {\n    ids[id] = 0;\n    return id;\n  }\n  return `${id.toString()}-${++ids[id]}`;\n};\n\n/**\n * @typedef exportKmlResultKml\n * @type {object}\n * @property {string} kml The generated KML.\n * @property {Object<string, Blob>} externalFiles An object dictionary of external files\n */\n\n/**\n * @typedef exportKmlResultKmz\n * @type {object}\n * @property {Blob} kmz The generated kmz file.\n */\n\n/**\n * Exports an EntityCollection as a KML document. Only Point, Billboard, Model, Path, Polygon, Polyline geometries\n * will be exported. Note that there is not a 1 to 1 mapping of Entity properties to KML Feature properties. For\n * example, entity properties that are time dynamic but cannot be dynamic in KML are exported with their values at\n * options.time or the beginning of the EntityCollection's time interval if not specified. For time-dynamic properties\n * that are supported in KML, we use the samples if it is a {@link SampledProperty} otherwise we sample the value using\n * the options.sampleDuration. Point, Billboard, Model and Path geometries with time-dynamic positions will be exported\n * as gx:Track Features. Not all Materials are representable in KML, so for more advanced Materials just the primary\n * color is used. Canvas objects are exported as PNG images.\n *\n * @function exportKml\n *\n * @param {object} options An object with the following properties:\n * @param {EntityCollection} options.entities The EntityCollection to export as KML.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid for the output file.\n * @param {exportKmlModelCallback} [options.modelCallback] A callback that will be called with a {@link ModelGraphics} instance and should return the URI to use in the KML. Required if a model exists in the entity collection.\n * @param {JulianDate} [options.time=entities.computeAvailability().start] The time value to use to get properties that are not time varying in KML.\n * @param {TimeInterval} [options.defaultAvailability=entities.computeAvailability()] The interval that will be sampled if an entity doesn't have an availability.\n * @param {number} [options.sampleDuration=60] The number of seconds to sample properties that are varying in KML.\n * @param {boolean} [options.kmz=false] If true KML and external files will be compressed into a kmz file.\n *\n * @returns {Promise<exportKmlResultKml|exportKmlResultKmz>} A promise that resolved to an object containing the KML string and a dictionary of external file blobs, or a kmz file as a blob if options.kmz is true.\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Export%20KML.html|Cesium Sandcastle KML Export Demo}\n * @example\n * Cesium.exportKml({\n *      entities: entityCollection\n *  })\n *   .then(function(result) {\n *     // The XML string is in result.kml\n *\n *     const externalFiles = result.externalFiles\n *     for(const file in externalFiles) {\n *       // file is the name of the file used in the KML document as the href\n *       // externalFiles[file] is a blob with the contents of the file\n *     }\n *   });\n *\n */\nfunction exportKml(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const entities = options.entities;\n  const kmz = options.kmz ?? false;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entities)) {\n    throw new DeveloperError(\"entities is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // Get the state that is passed around during the recursion\n  // This is separated out for testing.\n  const state = exportKml._createState(options);\n\n  // Filter EntityCollection so we only have top level entities\n  const rootEntities = entities.values.filter(function (entity) {\n    return !defined(entity.parent);\n  });\n\n  // Add the <Document>\n  const kmlDoc = state.kmlDoc;\n  const kmlElement = kmlDoc.documentElement;\n  kmlElement.setAttributeNS(xmlnsNamespace, \"xmlns:gx\", gxNamespace);\n  const kmlDocumentElement = kmlDoc.createElement(\"Document\");\n  kmlElement.appendChild(kmlDocumentElement);\n\n  // Create the KML Hierarchy\n  recurseEntities(state, kmlDocumentElement, rootEntities);\n\n  // Write out the <Style> elements\n  state.styleCache.save(kmlDocumentElement);\n\n  // Once all the blobs have resolved return the KML string along with the blob collection\n  const externalFileHandler = state.externalFileHandler;\n  return externalFileHandler.promise.then(function () {\n    const serializer = new XMLSerializer();\n    const kmlString = serializer.serializeToString(state.kmlDoc);\n    if (kmz) {\n      return createKmz(kmlString, externalFileHandler.files);\n    }\n    return {\n      kml: kmlString,\n      externalFiles: externalFileHandler.files\n    };\n  });\n}\nasync function createKmz(kmlString, externalFiles) {\n  const zWorkerUri = buildModuleUrl(\"ThirdParty/Workers/zip-web-worker.js\");\n  const zWasmUri = buildModuleUrl(\"ThirdParty/zip-module.wasm\");\n  configure({\n    workerURI: zWorkerUri,\n    wasmURI: zWasmUri\n  });\n  const blobWriter = new BlobWriter(\"application/vnd.google-earth.kmz\");\n  const writer = new ZipWriter(blobWriter);\n\n  // We need to only write one file at a time so the zip doesn't get corrupted\n  await writer.add(\"doc.kml\", new TextReader(kmlString));\n  const keys = Object.keys(externalFiles);\n  await addExternalFilesToZip(writer, keys, externalFiles, 0);\n  await writer.close();\n  const blob = await blobWriter.getData();\n  return {\n    kmz: blob\n  };\n}\nasync function addExternalFilesToZip(writer, keys, externalFiles, index) {\n  if (keys.length === index) {\n    return;\n  }\n  const filename = keys[index];\n  await writer.add(filename, new BlobReader(externalFiles[filename]));\n  return addExternalFilesToZip(writer, keys, externalFiles, index + 1);\n}\nexportKml._createState = function (options) {\n  const entities = options.entities;\n  const styleCache = new StyleCache();\n\n  // Use the start time as the default because just in case they define\n  //  properties with an interval even if they don't change.\n  const entityAvailability = entities.computeAvailability();\n  const time = defined(options.time) ? options.time : entityAvailability.start;\n\n  // Figure out how we will sample dynamic position properties\n  let defaultAvailability = options.defaultAvailability ?? entityAvailability;\n  const sampleDuration = options.sampleDuration ?? 60;\n\n  // Make sure we don't have infinite availability if we need to sample\n  if (defaultAvailability.start === Iso8601.MINIMUM_VALUE) {\n    if (defaultAvailability.stop === Iso8601.MAXIMUM_VALUE) {\n      // Infinite, so just use the default\n      defaultAvailability = new TimeInterval();\n    } else {\n      // No start time, so just sample 10 times before the stop\n      JulianDate.addSeconds(defaultAvailability.stop, -10 * sampleDuration, defaultAvailability.start);\n    }\n  } else if (defaultAvailability.stop === Iso8601.MAXIMUM_VALUE) {\n    // No stop time, so just sample 10 times after the start\n    JulianDate.addSeconds(defaultAvailability.start, 10 * sampleDuration, defaultAvailability.stop);\n  }\n  const externalFileHandler = new ExternalFileHandler(options.modelCallback);\n  const kmlDoc = document.implementation.createDocument(kmlNamespace, \"kml\");\n  return {\n    kmlDoc: kmlDoc,\n    ellipsoid: options.ellipsoid ?? Ellipsoid.default,\n    idManager: new IdManager(),\n    styleCache: styleCache,\n    externalFileHandler: externalFileHandler,\n    time: time,\n    valueGetter: new ValueGetter(time),\n    sampleDuration: sampleDuration,\n    // Wrap it in a TimeIntervalCollection because that is what entity.availability is\n    defaultAvailability: new TimeIntervalCollection([defaultAvailability])\n  };\n};\nfunction recurseEntities(state, parentNode, entities) {\n  const kmlDoc = state.kmlDoc;\n  const styleCache = state.styleCache;\n  const valueGetter = state.valueGetter;\n  const idManager = state.idManager;\n  const count = entities.length;\n  let overlays;\n  let geometries;\n  let styles;\n  for (let i = 0; i < count; ++i) {\n    const entity = entities[i];\n    overlays = [];\n    geometries = [];\n    styles = [];\n    createPoint(state, entity, geometries, styles);\n    createLineString(state, entity.polyline, geometries, styles);\n    createPolygon(state, entity.rectangle, geometries, styles, overlays);\n    createPolygon(state, entity.polygon, geometries, styles, overlays);\n    createModel(state, entity, entity.model, geometries, styles);\n    let timeSpan;\n    const availability = entity.availability;\n    if (defined(availability)) {\n      timeSpan = kmlDoc.createElement(\"TimeSpan\");\n      if (!JulianDate.equals(availability.start, Iso8601.MINIMUM_VALUE)) {\n        timeSpan.appendChild(createBasicElementWithText(kmlDoc, \"begin\", JulianDate.toIso8601(availability.start)));\n      }\n      if (!JulianDate.equals(availability.stop, Iso8601.MAXIMUM_VALUE)) {\n        timeSpan.appendChild(createBasicElementWithText(kmlDoc, \"end\", JulianDate.toIso8601(availability.stop)));\n      }\n    }\n    for (let overlayIndex = 0; overlayIndex < overlays.length; ++overlayIndex) {\n      const overlay = overlays[overlayIndex];\n      overlay.setAttribute(\"id\", idManager.get(entity.id));\n      overlay.appendChild(createBasicElementWithText(kmlDoc, \"name\", entity.name));\n      overlay.appendChild(createBasicElementWithText(kmlDoc, \"visibility\", entity.show));\n      overlay.appendChild(createBasicElementWithText(kmlDoc, \"description\", entity.description));\n      if (defined(timeSpan)) {\n        overlay.appendChild(timeSpan);\n      }\n      parentNode.appendChild(overlay);\n    }\n    const geometryCount = geometries.length;\n    if (geometryCount > 0) {\n      const placemark = kmlDoc.createElement(\"Placemark\");\n      placemark.setAttribute(\"id\", idManager.get(entity.id));\n      let name = entity.name;\n      const labelGraphics = entity.label;\n      if (defined(labelGraphics)) {\n        const labelStyle = kmlDoc.createElement(\"LabelStyle\");\n\n        // KML only shows the name as a label, so just change the name if we need to show a label\n        const text = valueGetter.get(labelGraphics.text);\n        name = defined(text) && text.length > 0 ? text : name;\n        const color = valueGetter.getColor(labelGraphics.fillColor);\n        if (defined(color)) {\n          labelStyle.appendChild(createBasicElementWithText(kmlDoc, \"color\", color));\n          labelStyle.appendChild(createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"));\n        }\n        const scale = valueGetter.get(labelGraphics.scale);\n        if (defined(scale)) {\n          labelStyle.appendChild(createBasicElementWithText(kmlDoc, \"scale\", scale));\n        }\n        styles.push(labelStyle);\n      }\n      placemark.appendChild(createBasicElementWithText(kmlDoc, \"name\", name));\n      placemark.appendChild(createBasicElementWithText(kmlDoc, \"visibility\", entity.show));\n      placemark.appendChild(createBasicElementWithText(kmlDoc, \"description\", entity.description));\n      if (defined(timeSpan)) {\n        placemark.appendChild(timeSpan);\n      }\n      parentNode.appendChild(placemark);\n      const styleCount = styles.length;\n      if (styleCount > 0) {\n        const style = kmlDoc.createElement(\"Style\");\n        for (let styleIndex = 0; styleIndex < styleCount; ++styleIndex) {\n          style.appendChild(styles[styleIndex]);\n        }\n        placemark.appendChild(createBasicElementWithText(kmlDoc, \"styleUrl\", styleCache.get(style)));\n      }\n      if (geometries.length === 1) {\n        placemark.appendChild(geometries[0]);\n      } else if (geometries.length > 1) {\n        const multigeometry = kmlDoc.createElement(\"MultiGeometry\");\n        for (let geometryIndex = 0; geometryIndex < geometryCount; ++geometryIndex) {\n          multigeometry.appendChild(geometries[geometryIndex]);\n        }\n        placemark.appendChild(multigeometry);\n      }\n    }\n    const children = entity._children;\n    if (children.length > 0) {\n      const folderNode = kmlDoc.createElement(\"Folder\");\n      folderNode.setAttribute(\"id\", idManager.get(entity.id));\n      folderNode.appendChild(createBasicElementWithText(kmlDoc, \"name\", entity.name));\n      folderNode.appendChild(createBasicElementWithText(kmlDoc, \"visibility\", entity.show));\n      folderNode.appendChild(createBasicElementWithText(kmlDoc, \"description\", entity.description));\n      parentNode.appendChild(folderNode);\n      recurseEntities(state, folderNode, children);\n    }\n  }\n}\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartographic = new Cartographic();\nconst scratchJulianDate = new JulianDate();\nfunction createPoint(state, entity, geometries, styles) {\n  const kmlDoc = state.kmlDoc;\n  const ellipsoid = state.ellipsoid;\n  const valueGetter = state.valueGetter;\n  const pointGraphics = entity.billboard ?? entity.point;\n  if (!defined(pointGraphics) && !defined(entity.path)) {\n    return;\n  }\n\n  // If the point isn't constant then create gx:Track or gx:MultiTrack\n  const entityPositionProperty = entity.position;\n  if (!entityPositionProperty.isConstant) {\n    createTracks(state, entity, pointGraphics, geometries, styles);\n    return;\n  }\n  valueGetter.get(entityPositionProperty, undefined, scratchCartesian3);\n  const coordinates = createBasicElementWithText(kmlDoc, \"coordinates\", getCoordinates(scratchCartesian3, ellipsoid));\n  const pointGeometry = kmlDoc.createElement(\"Point\");\n\n  // Set altitude mode\n  const altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(getAltitudeMode(state, pointGraphics.heightReference));\n  pointGeometry.appendChild(altitudeMode);\n  pointGeometry.appendChild(coordinates);\n  geometries.push(pointGeometry);\n\n  // Create style\n  const iconStyle = pointGraphics instanceof BillboardGraphics ? createIconStyleFromBillboard(state, pointGraphics) : createIconStyleFromPoint(state, pointGraphics);\n  styles.push(iconStyle);\n}\nfunction createTracks(state, entity, pointGraphics, geometries, styles) {\n  const kmlDoc = state.kmlDoc;\n  const ellipsoid = state.ellipsoid;\n  const valueGetter = state.valueGetter;\n  let intervals;\n  const entityPositionProperty = entity.position;\n  let useEntityPositionProperty = true;\n  if (entityPositionProperty instanceof CompositePositionProperty) {\n    intervals = entityPositionProperty.intervals;\n    useEntityPositionProperty = false;\n  } else {\n    intervals = entity.availability ?? state.defaultAvailability;\n  }\n  const isModel = pointGraphics instanceof ModelGraphics;\n  let i, j, times;\n  const tracks = [];\n  for (i = 0; i < intervals.length; ++i) {\n    const interval = intervals.get(i);\n    let positionProperty = useEntityPositionProperty ? entityPositionProperty : interval.data;\n    const trackAltitudeMode = kmlDoc.createElement(\"altitudeMode\");\n    // This is something that KML importing uses to handle clampToGround,\n    //  so just extract the internal property and set the altitudeMode.\n    if (positionProperty instanceof ScaledPositionProperty) {\n      positionProperty = positionProperty._value;\n      trackAltitudeMode.appendChild(getAltitudeMode(state, HeightReference.CLAMP_TO_GROUND));\n    } else if (defined(pointGraphics)) {\n      trackAltitudeMode.appendChild(getAltitudeMode(state, pointGraphics.heightReference));\n    } else {\n      // Path graphics only, which has no height reference\n      trackAltitudeMode.appendChild(getAltitudeMode(state, HeightReference.NONE));\n    }\n    const positionTimes = [];\n    const positionValues = [];\n    if (positionProperty.isConstant) {\n      valueGetter.get(positionProperty, undefined, scratchCartesian3);\n      const constCoordinates = createBasicElementWithText(kmlDoc, \"coordinates\", getCoordinates(scratchCartesian3, ellipsoid));\n\n      // This interval is constant so add a track with the same position\n      positionTimes.push(JulianDate.toIso8601(interval.start));\n      positionValues.push(constCoordinates);\n      positionTimes.push(JulianDate.toIso8601(interval.stop));\n      positionValues.push(constCoordinates);\n    } else if (positionProperty instanceof SampledPositionProperty) {\n      times = positionProperty._property._times;\n      for (j = 0; j < times.length; ++j) {\n        positionTimes.push(JulianDate.toIso8601(times[j]));\n        positionProperty.getValueInReferenceFrame(times[j], ReferenceFrame.FIXED, scratchCartesian3);\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n      }\n    } else if (positionProperty instanceof SampledProperty) {\n      times = positionProperty._times;\n      const values = positionProperty._values;\n      for (j = 0; j < times.length; ++j) {\n        positionTimes.push(JulianDate.toIso8601(times[j]));\n        Cartesian3.fromArray(values, j * 3, scratchCartesian3);\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n      }\n    } else {\n      const duration = state.sampleDuration;\n      interval.start.clone(scratchJulianDate);\n      if (!interval.isStartIncluded) {\n        JulianDate.addSeconds(scratchJulianDate, duration, scratchJulianDate);\n      }\n      const stopDate = interval.stop;\n      while (JulianDate.lessThan(scratchJulianDate, stopDate)) {\n        positionProperty.getValue(scratchJulianDate, scratchCartesian3);\n        positionTimes.push(JulianDate.toIso8601(scratchJulianDate));\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n        JulianDate.addSeconds(scratchJulianDate, duration, scratchJulianDate);\n      }\n      if (interval.isStopIncluded && JulianDate.equals(scratchJulianDate, stopDate)) {\n        positionProperty.getValue(scratchJulianDate, scratchCartesian3);\n        positionTimes.push(JulianDate.toIso8601(scratchJulianDate));\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n      }\n    }\n    const trackGeometry = kmlDoc.createElementNS(gxNamespace, \"Track\");\n    trackGeometry.appendChild(trackAltitudeMode);\n    for (let k = 0; k < positionTimes.length; ++k) {\n      const when = createBasicElementWithText(kmlDoc, \"when\", positionTimes[k]);\n      const coord = createBasicElementWithText(kmlDoc, \"coord\", positionValues[k], gxNamespace);\n      trackGeometry.appendChild(when);\n      trackGeometry.appendChild(coord);\n    }\n    if (isModel) {\n      trackGeometry.appendChild(createModelGeometry(state, pointGraphics));\n    }\n    tracks.push(trackGeometry);\n  }\n\n  // If one track, then use it otherwise combine into a multitrack\n  if (tracks.length === 1) {\n    geometries.push(tracks[0]);\n  } else if (tracks.length > 1) {\n    const multiTrackGeometry = kmlDoc.createElementNS(gxNamespace, \"MultiTrack\");\n    for (i = 0; i < tracks.length; ++i) {\n      multiTrackGeometry.appendChild(tracks[i]);\n    }\n    geometries.push(multiTrackGeometry);\n  }\n\n  // Create style\n  if (defined(pointGraphics) && !isModel) {\n    const iconStyle = pointGraphics instanceof BillboardGraphics ? createIconStyleFromBillboard(state, pointGraphics) : createIconStyleFromPoint(state, pointGraphics);\n    styles.push(iconStyle);\n  }\n\n  // See if we have a line that needs to be drawn\n  const path = entity.path;\n  if (defined(path)) {\n    const width = valueGetter.get(path.width);\n    const material = path.material;\n    if (defined(material) || defined(width)) {\n      const lineStyle = kmlDoc.createElement(\"LineStyle\");\n      if (defined(width)) {\n        lineStyle.appendChild(createBasicElementWithText(kmlDoc, \"width\", width));\n      }\n      processMaterial(state, material, lineStyle);\n      styles.push(lineStyle);\n    }\n  }\n}\nfunction createIconStyleFromPoint(state, pointGraphics) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  const iconStyle = kmlDoc.createElement(\"IconStyle\");\n  const color = valueGetter.getColor(pointGraphics.color);\n  if (defined(color)) {\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"color\", color));\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"));\n  }\n  const pixelSize = valueGetter.get(pointGraphics.pixelSize);\n  if (defined(pixelSize)) {\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"scale\", pixelSize / BILLBOARD_SIZE));\n  }\n  return iconStyle;\n}\nfunction createIconStyleFromBillboard(state, billboardGraphics) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  const externalFileHandler = state.externalFileHandler;\n  const iconStyle = kmlDoc.createElement(\"IconStyle\");\n  let image = valueGetter.get(billboardGraphics.image);\n  if (defined(image)) {\n    image = externalFileHandler.texture(image);\n    const icon = kmlDoc.createElement(\"Icon\");\n    icon.appendChild(createBasicElementWithText(kmlDoc, \"href\", image));\n    const imageSubRegion = valueGetter.get(billboardGraphics.imageSubRegion);\n    if (defined(imageSubRegion)) {\n      icon.appendChild(createBasicElementWithText(kmlDoc, \"x\", imageSubRegion.x, gxNamespace));\n      icon.appendChild(createBasicElementWithText(kmlDoc, \"y\", imageSubRegion.y, gxNamespace));\n      icon.appendChild(createBasicElementWithText(kmlDoc, \"w\", imageSubRegion.width, gxNamespace));\n      icon.appendChild(createBasicElementWithText(kmlDoc, \"h\", imageSubRegion.height, gxNamespace));\n    }\n    iconStyle.appendChild(icon);\n  }\n  const color = valueGetter.getColor(billboardGraphics.color);\n  if (defined(color)) {\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"color\", color));\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"));\n  }\n  let scale = valueGetter.get(billboardGraphics.scale);\n  if (defined(scale)) {\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"scale\", scale));\n  }\n  const pixelOffset = valueGetter.get(billboardGraphics.pixelOffset);\n  if (defined(pixelOffset)) {\n    scale = scale ?? 1.0;\n    Cartesian2.divideByScalar(pixelOffset, scale, pixelOffset);\n    const width = valueGetter.get(billboardGraphics.width, BILLBOARD_SIZE);\n    const height = valueGetter.get(billboardGraphics.height, BILLBOARD_SIZE);\n\n    // KML Hotspots are from the bottom left, but we work from the top left\n\n    // Move to left\n    const horizontalOrigin = valueGetter.get(billboardGraphics.horizontalOrigin, HorizontalOrigin.CENTER);\n    if (horizontalOrigin === HorizontalOrigin.CENTER) {\n      pixelOffset.x -= width * 0.5;\n    } else if (horizontalOrigin === HorizontalOrigin.RIGHT) {\n      pixelOffset.x -= width;\n    }\n\n    // Move to bottom\n    const verticalOrigin = valueGetter.get(billboardGraphics.verticalOrigin, VerticalOrigin.CENTER);\n    if (verticalOrigin === VerticalOrigin.TOP) {\n      pixelOffset.y += height;\n    } else if (verticalOrigin === VerticalOrigin.CENTER) {\n      pixelOffset.y += height * 0.5;\n    }\n    const hotSpot = kmlDoc.createElement(\"hotSpot\");\n    hotSpot.setAttribute(\"x\", -pixelOffset.x);\n    hotSpot.setAttribute(\"y\", pixelOffset.y);\n    hotSpot.setAttribute(\"xunits\", \"pixels\");\n    hotSpot.setAttribute(\"yunits\", \"pixels\");\n    iconStyle.appendChild(hotSpot);\n  }\n\n  // We can only specify heading so if axis isn't Z, then we skip the rotation\n  // GE treats a heading of zero as no heading but can still point north using a 360 degree angle\n  let rotation = valueGetter.get(billboardGraphics.rotation);\n  const alignedAxis = valueGetter.get(billboardGraphics.alignedAxis);\n  if (defined(rotation) && Cartesian3.equals(Cartesian3.UNIT_Z, alignedAxis)) {\n    rotation = CesiumMath.toDegrees(-rotation);\n    if (rotation === 0) {\n      rotation = 360;\n    }\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"heading\", rotation));\n  }\n  return iconStyle;\n}\nfunction createLineString(state, polylineGraphics, geometries, styles) {\n  const kmlDoc = state.kmlDoc;\n  const ellipsoid = state.ellipsoid;\n  const valueGetter = state.valueGetter;\n  if (!defined(polylineGraphics)) {\n    return;\n  }\n  const lineStringGeometry = kmlDoc.createElement(\"LineString\");\n\n  // Set altitude mode\n  const altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  const clampToGround = valueGetter.get(polylineGraphics.clampToGround, false);\n  let altitudeModeText;\n  if (clampToGround) {\n    lineStringGeometry.appendChild(createBasicElementWithText(kmlDoc, \"tessellate\", true));\n    altitudeModeText = kmlDoc.createTextNode(\"clampToGround\");\n  } else {\n    altitudeModeText = kmlDoc.createTextNode(\"absolute\");\n  }\n  altitudeMode.appendChild(altitudeModeText);\n  lineStringGeometry.appendChild(altitudeMode);\n\n  // Set coordinates\n  const positionsProperty = polylineGraphics.positions;\n  const cartesians = valueGetter.get(positionsProperty);\n  const coordinates = createBasicElementWithText(kmlDoc, \"coordinates\", getCoordinates(cartesians, ellipsoid));\n  lineStringGeometry.appendChild(coordinates);\n\n  // Set draw order\n  const zIndex = valueGetter.get(polylineGraphics.zIndex);\n  if (clampToGround && defined(zIndex)) {\n    lineStringGeometry.appendChild(createBasicElementWithText(kmlDoc, \"drawOrder\", zIndex, gxNamespace));\n  }\n  geometries.push(lineStringGeometry);\n\n  // Create style\n  const lineStyle = kmlDoc.createElement(\"LineStyle\");\n  const width = valueGetter.get(polylineGraphics.width);\n  if (defined(width)) {\n    lineStyle.appendChild(createBasicElementWithText(kmlDoc, \"width\", width));\n  }\n  processMaterial(state, polylineGraphics.material, lineStyle);\n  styles.push(lineStyle);\n}\nfunction getRectangleBoundaries(state, rectangleGraphics, extrudedHeight) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  let height = valueGetter.get(rectangleGraphics.height, 0.0);\n  if (extrudedHeight > 0) {\n    // We extrude up and KML extrudes down, so if we extrude, set the polygon height to\n    // the extruded height so KML will look similar to Cesium\n    height = extrudedHeight;\n  }\n  const coordinatesProperty = rectangleGraphics.coordinates;\n  const rectangle = valueGetter.get(coordinatesProperty);\n  const coordinateStrings = [];\n  const cornerFunction = [Rectangle.northeast, Rectangle.southeast, Rectangle.southwest, Rectangle.northwest];\n  for (let i = 0; i < 4; ++i) {\n    cornerFunction[i](rectangle, scratchCartographic);\n    coordinateStrings.push(`${CesiumMath.toDegrees(scratchCartographic.longitude)},${CesiumMath.toDegrees(scratchCartographic.latitude)},${height}`);\n  }\n  const coordinates = createBasicElementWithText(kmlDoc, \"coordinates\", coordinateStrings.join(\" \"));\n  const outerBoundaryIs = kmlDoc.createElement(\"outerBoundaryIs\");\n  const linearRing = kmlDoc.createElement(\"LinearRing\");\n  linearRing.appendChild(coordinates);\n  outerBoundaryIs.appendChild(linearRing);\n  return [outerBoundaryIs];\n}\nfunction getLinearRing(state, positions, height, perPositionHeight) {\n  const kmlDoc = state.kmlDoc;\n  const ellipsoid = state.ellipsoid;\n  const coordinateStrings = [];\n  const positionCount = positions.length;\n  for (let i = 0; i < positionCount; ++i) {\n    Cartographic.fromCartesian(positions[i], ellipsoid, scratchCartographic);\n    coordinateStrings.push(`${CesiumMath.toDegrees(scratchCartographic.longitude)},${CesiumMath.toDegrees(scratchCartographic.latitude)},${perPositionHeight ? scratchCartographic.height : height}`);\n  }\n  const coordinates = createBasicElementWithText(kmlDoc, \"coordinates\", coordinateStrings.join(\" \"));\n  const linearRing = kmlDoc.createElement(\"LinearRing\");\n  linearRing.appendChild(coordinates);\n  return linearRing;\n}\nfunction getPolygonBoundaries(state, polygonGraphics, extrudedHeight) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  let height = valueGetter.get(polygonGraphics.height, 0.0);\n  const perPositionHeight = valueGetter.get(polygonGraphics.perPositionHeight, false);\n  if (!perPositionHeight && extrudedHeight > 0) {\n    // We extrude up and KML extrudes down, so if we extrude, set the polygon height to\n    // the extruded height so KML will look similar to Cesium\n    height = extrudedHeight;\n  }\n  const boundaries = [];\n  const hierarchyProperty = polygonGraphics.hierarchy;\n  const hierarchy = valueGetter.get(hierarchyProperty);\n\n  // Polygon hierarchy can sometimes just be an array of positions\n  const positions = Array.isArray(hierarchy) ? hierarchy : hierarchy.positions;\n\n  // Polygon boundaries\n  const outerBoundaryIs = kmlDoc.createElement(\"outerBoundaryIs\");\n  outerBoundaryIs.appendChild(getLinearRing(state, positions, height, perPositionHeight));\n  boundaries.push(outerBoundaryIs);\n\n  // Hole boundaries\n  const holes = hierarchy.holes;\n  if (defined(holes)) {\n    const holeCount = holes.length;\n    for (let i = 0; i < holeCount; ++i) {\n      const innerBoundaryIs = kmlDoc.createElement(\"innerBoundaryIs\");\n      innerBoundaryIs.appendChild(getLinearRing(state, holes[i].positions, height, perPositionHeight));\n      boundaries.push(innerBoundaryIs);\n    }\n  }\n  return boundaries;\n}\nfunction createPolygon(state, geometry, geometries, styles, overlays) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  if (!defined(geometry)) {\n    return;\n  }\n\n  // Detect textured quads and use ground overlays instead\n  const isRectangle = geometry instanceof RectangleGraphics;\n  if (isRectangle && valueGetter.getMaterialType(geometry.material) === \"Image\") {\n    createGroundOverlay(state, geometry, overlays);\n    return;\n  }\n  const polygonGeometry = kmlDoc.createElement(\"Polygon\");\n  const extrudedHeight = valueGetter.get(geometry.extrudedHeight, 0.0);\n  if (extrudedHeight > 0) {\n    polygonGeometry.appendChild(createBasicElementWithText(kmlDoc, \"extrude\", true));\n  }\n\n  // Set boundaries\n  const boundaries = isRectangle ? getRectangleBoundaries(state, geometry, extrudedHeight) : getPolygonBoundaries(state, geometry, extrudedHeight);\n  const boundaryCount = boundaries.length;\n  for (let i = 0; i < boundaryCount; ++i) {\n    polygonGeometry.appendChild(boundaries[i]);\n  }\n\n  // Set altitude mode\n  const altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(getAltitudeMode(state, geometry.heightReference));\n  polygonGeometry.appendChild(altitudeMode);\n  geometries.push(polygonGeometry);\n\n  // Create style\n  const polyStyle = kmlDoc.createElement(\"PolyStyle\");\n  const fill = valueGetter.get(geometry.fill, false);\n  if (fill) {\n    polyStyle.appendChild(createBasicElementWithText(kmlDoc, \"fill\", fill));\n  }\n  processMaterial(state, geometry.material, polyStyle);\n  const outline = valueGetter.get(geometry.outline, false);\n  if (outline) {\n    polyStyle.appendChild(createBasicElementWithText(kmlDoc, \"outline\", outline));\n\n    // Outline uses LineStyle\n    const lineStyle = kmlDoc.createElement(\"LineStyle\");\n    const outlineWidth = valueGetter.get(geometry.outlineWidth, 1.0);\n    lineStyle.appendChild(createBasicElementWithText(kmlDoc, \"width\", outlineWidth));\n    const outlineColor = valueGetter.getColor(geometry.outlineColor, Color.BLACK);\n    lineStyle.appendChild(createBasicElementWithText(kmlDoc, \"color\", outlineColor));\n    lineStyle.appendChild(createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"));\n    styles.push(lineStyle);\n  }\n  styles.push(polyStyle);\n}\nfunction createGroundOverlay(state, rectangleGraphics, overlays) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  const externalFileHandler = state.externalFileHandler;\n  const groundOverlay = kmlDoc.createElement(\"GroundOverlay\");\n\n  // Set altitude mode\n  const altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(getAltitudeMode(state, rectangleGraphics.heightReference));\n  groundOverlay.appendChild(altitudeMode);\n  const height = valueGetter.get(rectangleGraphics.height);\n  if (defined(height)) {\n    groundOverlay.appendChild(createBasicElementWithText(kmlDoc, \"altitude\", height));\n  }\n  const rectangle = valueGetter.get(rectangleGraphics.coordinates);\n  const latLonBox = kmlDoc.createElement(\"LatLonBox\");\n  latLonBox.appendChild(createBasicElementWithText(kmlDoc, \"north\", CesiumMath.toDegrees(rectangle.north)));\n  latLonBox.appendChild(createBasicElementWithText(kmlDoc, \"south\", CesiumMath.toDegrees(rectangle.south)));\n  latLonBox.appendChild(createBasicElementWithText(kmlDoc, \"east\", CesiumMath.toDegrees(rectangle.east)));\n  latLonBox.appendChild(createBasicElementWithText(kmlDoc, \"west\", CesiumMath.toDegrees(rectangle.west)));\n  groundOverlay.appendChild(latLonBox);\n\n  // We should only end up here if we have an ImageMaterialProperty\n  const material = valueGetter.get(rectangleGraphics.material);\n  const href = externalFileHandler.texture(material.image);\n  const icon = kmlDoc.createElement(\"Icon\");\n  icon.appendChild(createBasicElementWithText(kmlDoc, \"href\", href));\n  groundOverlay.appendChild(icon);\n  const color = material.color;\n  if (defined(color)) {\n    groundOverlay.appendChild(createBasicElementWithText(kmlDoc, \"color\", colorToString(material.color)));\n  }\n  overlays.push(groundOverlay);\n}\nfunction createModelGeometry(state, modelGraphics) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  const externalFileHandler = state.externalFileHandler;\n  const modelGeometry = kmlDoc.createElement(\"Model\");\n  const scale = valueGetter.get(modelGraphics.scale);\n  if (defined(scale)) {\n    const scaleElement = kmlDoc.createElement(\"scale\");\n    scaleElement.appendChild(createBasicElementWithText(kmlDoc, \"x\", scale));\n    scaleElement.appendChild(createBasicElementWithText(kmlDoc, \"y\", scale));\n    scaleElement.appendChild(createBasicElementWithText(kmlDoc, \"z\", scale));\n    modelGeometry.appendChild(scaleElement);\n  }\n  const link = kmlDoc.createElement(\"Link\");\n  const uri = externalFileHandler.model(modelGraphics, state.time);\n  link.appendChild(createBasicElementWithText(kmlDoc, \"href\", uri));\n  modelGeometry.appendChild(link);\n  return modelGeometry;\n}\nfunction createModel(state, entity, modelGraphics, geometries, styles) {\n  const kmlDoc = state.kmlDoc;\n  const ellipsoid = state.ellipsoid;\n  const valueGetter = state.valueGetter;\n  if (!defined(modelGraphics)) {\n    return;\n  }\n\n  // If the point isn't constant then create gx:Track or gx:MultiTrack\n  const entityPositionProperty = entity.position;\n  if (!entityPositionProperty.isConstant) {\n    createTracks(state, entity, modelGraphics, geometries, styles);\n    return;\n  }\n  const modelGeometry = createModelGeometry(state, modelGraphics);\n\n  // Set altitude mode\n  const altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(getAltitudeMode(state, modelGraphics.heightReference));\n  modelGeometry.appendChild(altitudeMode);\n  valueGetter.get(entityPositionProperty, undefined, scratchCartesian3);\n  Cartographic.fromCartesian(scratchCartesian3, ellipsoid, scratchCartographic);\n  const location = kmlDoc.createElement(\"Location\");\n  location.appendChild(createBasicElementWithText(kmlDoc, \"longitude\", CesiumMath.toDegrees(scratchCartographic.longitude)));\n  location.appendChild(createBasicElementWithText(kmlDoc, \"latitude\", CesiumMath.toDegrees(scratchCartographic.latitude)));\n  location.appendChild(createBasicElementWithText(kmlDoc, \"altitude\", scratchCartographic.height));\n  modelGeometry.appendChild(location);\n  geometries.push(modelGeometry);\n}\nfunction processMaterial(state, materialProperty, style) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  if (!defined(materialProperty)) {\n    return;\n  }\n  const material = valueGetter.get(materialProperty);\n  if (!defined(material)) {\n    return;\n  }\n  let color;\n  const type = valueGetter.getMaterialType(materialProperty);\n  let outlineColor;\n  let outlineWidth;\n  switch (type) {\n    case \"Image\":\n      // Image materials are only able to be represented on rectangles, so if we make it\n      //  here we can't texture a generic polygon or polyline in KML, so just use white.\n      color = colorToString(Color.WHITE);\n      break;\n    case \"Color\":\n    case \"Grid\":\n    case \"PolylineGlow\":\n    case \"PolylineArrow\":\n    case \"PolylineDash\":\n      color = colorToString(material.color);\n      break;\n    case \"PolylineOutline\":\n      color = colorToString(material.color);\n      outlineColor = colorToString(material.outlineColor);\n      outlineWidth = material.outlineWidth;\n      style.appendChild(createBasicElementWithText(kmlDoc, \"outerColor\", outlineColor, gxNamespace));\n      style.appendChild(createBasicElementWithText(kmlDoc, \"outerWidth\", outlineWidth, gxNamespace));\n      break;\n    case \"Stripe\":\n      color = colorToString(material.oddColor);\n      break;\n  }\n  if (defined(color)) {\n    style.appendChild(createBasicElementWithText(kmlDoc, \"color\", color));\n    style.appendChild(createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"));\n  }\n}\nfunction getAltitudeMode(state, heightReferenceProperty) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  const heightReference = valueGetter.get(heightReferenceProperty, HeightReference.NONE);\n  let altitudeModeText;\n  switch (heightReference) {\n    case HeightReference.NONE:\n      altitudeModeText = kmlDoc.createTextNode(\"absolute\");\n      break;\n    case HeightReference.CLAMP_TO_GROUND:\n      altitudeModeText = kmlDoc.createTextNode(\"clampToGround\");\n      break;\n    case HeightReference.RELATIVE_TO_GROUND:\n      altitudeModeText = kmlDoc.createTextNode(\"relativeToGround\");\n      break;\n  }\n  return altitudeModeText;\n}\nfunction getCoordinates(coordinates, ellipsoid) {\n  if (!Array.isArray(coordinates)) {\n    coordinates = [coordinates];\n  }\n  const count = coordinates.length;\n  const coordinateStrings = [];\n  for (let i = 0; i < count; ++i) {\n    Cartographic.fromCartesian(coordinates[i], ellipsoid, scratchCartographic);\n    coordinateStrings.push(`${CesiumMath.toDegrees(scratchCartographic.longitude)},${CesiumMath.toDegrees(scratchCartographic.latitude)},${scratchCartographic.height}`);\n  }\n  return coordinateStrings.join(\" \");\n}\nfunction createBasicElementWithText(kmlDoc, elementName, elementValue, namespace) {\n  elementValue = elementValue ?? \"\";\n  if (typeof elementValue === \"boolean\") {\n    elementValue = elementValue ? \"1\" : \"0\";\n  }\n\n  // Create element with optional namespace\n  const element = defined(namespace) ? kmlDoc.createElementNS(namespace, elementName) : kmlDoc.createElement(elementName);\n\n  // Wrap value in CDATA section if it contains HTML\n  const text = elementValue === \"string\" && elementValue.indexOf(\"<\") !== -1 ? kmlDoc.createCDATASection(elementValue) : kmlDoc.createTextNode(elementValue);\n  element.appendChild(text);\n  return element;\n}\nfunction colorToString(color) {\n  let result = \"\";\n  const bytes = color.toBytes();\n  for (let i = 3; i >= 0; --i) {\n    result += bytes[i] < 16 ? `0${bytes[i].toString(16)}` : bytes[i].toString(16);\n  }\n  return result;\n}\n\n/**\n * Since KML does not support glTF models, this callback is required to specify what URL to use for the model in the KML document.\n * It can also be used to add additional files to the <code>externalFiles</code> object, which is the list of files embedded in the exported KMZ,\n * or otherwise returned with the KML string when exporting.\n *\n * @callback exportKmlModelCallback\n *\n * @param {ModelGraphics} model The ModelGraphics instance for an Entity.\n * @param {JulianDate} time The time that any properties should use to get the value.\n * @param {object} externalFiles An object that maps a filename to a Blob or a Promise that resolves to a Blob.\n * @returns {string} The URL to use for the href in the KML document.\n */\nexport default exportKml;","map":{"version":3,"names":["buildModuleUrl","Cartesian2","Cartesian3","Cartographic","Color","createGuid","Frozen","defined","DeveloperError","Ellipsoid","Iso8601","JulianDate","CesiumMath","Rectangle","ReferenceFrame","Resource","RuntimeError","TimeInterval","TimeIntervalCollection","HeightReference","HorizontalOrigin","VerticalOrigin","configure","BlobReader","BlobWriter","TextReader","ZipWriter","BillboardGraphics","CompositePositionProperty","ModelGraphics","RectangleGraphics","SampledPositionProperty","SampledProperty","ScaledPositionProperty","BILLBOARD_SIZE","kmlNamespace","gxNamespace","xmlnsNamespace","ExternalFileHandler","modelCallback","_files","_promises","_count","_modelCallback","imageTypeRegex","prototype","texture","that","filename","createIfNeeded","isDataUri","url","regexResult","match","promise","fetchBlob","then","blob","push","HTMLCanvasElement","Promise","resolve","toBlob","getModelBlobHander","model","time","externalFiles","hasOwnProperty","Object","defineProperties","get","all","files","ValueGetter","_time","property","defaultVal","result","value","getValue","getColor","colorToString","getMaterialType","getType","StyleCache","_ids","_styles","element","ids","key","innerHTML","styleId","setAttribute","save","parentElement","styles","firstElement","childNodes","insertBefore","IdManager","id","toString","exportKml","options","EMPTY_OBJECT","entities","kmz","state","_createState","rootEntities","values","filter","entity","parent","kmlDoc","kmlElement","documentElement","setAttributeNS","kmlDocumentElement","createElement","appendChild","recurseEntities","styleCache","externalFileHandler","serializer","XMLSerializer","kmlString","serializeToString","createKmz","kml","zWorkerUri","zWasmUri","workerURI","wasmURI","blobWriter","writer","add","keys","addExternalFilesToZip","close","getData","index","length","entityAvailability","computeAvailability","start","defaultAvailability","sampleDuration","MINIMUM_VALUE","stop","MAXIMUM_VALUE","addSeconds","document","implementation","createDocument","ellipsoid","default","idManager","valueGetter","parentNode","count","overlays","geometries","i","createPoint","createLineString","polyline","createPolygon","rectangle","polygon","createModel","timeSpan","availability","equals","createBasicElementWithText","toIso8601","overlayIndex","overlay","name","show","description","geometryCount","placemark","labelGraphics","label","labelStyle","text","color","fillColor","scale","styleCount","style","styleIndex","multigeometry","geometryIndex","children","_children","folderNode","scratchCartesian3","scratchCartographic","scratchJulianDate","pointGraphics","billboard","point","path","entityPositionProperty","position","isConstant","createTracks","undefined","coordinates","getCoordinates","pointGeometry","altitudeMode","getAltitudeMode","heightReference","iconStyle","createIconStyleFromBillboard","createIconStyleFromPoint","intervals","useEntityPositionProperty","isModel","j","times","tracks","interval","positionProperty","data","trackAltitudeMode","_value","CLAMP_TO_GROUND","NONE","positionTimes","positionValues","constCoordinates","_property","_times","getValueInReferenceFrame","FIXED","_values","fromArray","duration","clone","isStartIncluded","stopDate","lessThan","isStopIncluded","trackGeometry","createElementNS","k","when","coord","createModelGeometry","multiTrackGeometry","width","material","lineStyle","processMaterial","pixelSize","billboardGraphics","image","icon","imageSubRegion","x","y","height","pixelOffset","divideByScalar","horizontalOrigin","CENTER","RIGHT","verticalOrigin","TOP","hotSpot","rotation","alignedAxis","UNIT_Z","toDegrees","polylineGraphics","lineStringGeometry","clampToGround","altitudeModeText","createTextNode","positionsProperty","positions","cartesians","zIndex","getRectangleBoundaries","rectangleGraphics","extrudedHeight","coordinatesProperty","coordinateStrings","cornerFunction","northeast","southeast","southwest","northwest","longitude","latitude","join","outerBoundaryIs","linearRing","getLinearRing","perPositionHeight","positionCount","fromCartesian","getPolygonBoundaries","polygonGraphics","boundaries","hierarchyProperty","hierarchy","Array","isArray","holes","holeCount","innerBoundaryIs","geometry","isRectangle","createGroundOverlay","polygonGeometry","boundaryCount","polyStyle","fill","outline","outlineWidth","outlineColor","BLACK","groundOverlay","latLonBox","north","south","east","west","href","modelGraphics","modelGeometry","scaleElement","link","uri","location","materialProperty","type","WHITE","oddColor","heightReferenceProperty","RELATIVE_TO_GROUND","elementName","elementValue","namespace","indexOf","createCDATASection","bytes","toBytes"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/DataSources/exportKml.js"],"sourcesContent":["import buildModuleUrl from \"../Core/buildModuleUrl.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport ReferenceFrame from \"../Core/ReferenceFrame.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TimeInterval from \"../Core/TimeInterval.js\";\nimport TimeIntervalCollection from \"../Core/TimeIntervalCollection.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport HorizontalOrigin from \"../Scene/HorizontalOrigin.js\";\nimport VerticalOrigin from \"../Scene/VerticalOrigin.js\";\nimport {\n  configure,\n  BlobReader,\n  BlobWriter,\n  TextReader,\n  ZipWriter,\n} from \"@zip.js/zip.js/lib/zip-core.js\";\nimport BillboardGraphics from \"./BillboardGraphics.js\";\nimport CompositePositionProperty from \"./CompositePositionProperty.js\";\nimport ModelGraphics from \"./ModelGraphics.js\";\nimport RectangleGraphics from \"./RectangleGraphics.js\";\nimport SampledPositionProperty from \"./SampledPositionProperty.js\";\nimport SampledProperty from \"./SampledProperty.js\";\nimport ScaledPositionProperty from \"./ScaledPositionProperty.js\";\n\nconst BILLBOARD_SIZE = 32;\nconst kmlNamespace = \"http://www.opengis.net/kml/2.2\";\nconst gxNamespace = \"http://www.google.com/kml/ext/2.2\";\nconst xmlnsNamespace = \"http://www.w3.org/2000/xmlns/\";\n\n//\n// Handles files external to the KML (eg. textures and models)\n//\nfunction ExternalFileHandler(modelCallback) {\n  this._files = {};\n  this._promises = [];\n  this._count = 0;\n  this._modelCallback = modelCallback;\n}\n\nconst imageTypeRegex = /^data:image\\/([^,;]+)/;\nExternalFileHandler.prototype.texture = function (texture) {\n  const that = this;\n  let filename;\n\n  if (typeof texture === \"string\" || texture instanceof Resource) {\n    texture = Resource.createIfNeeded(texture);\n    if (!texture.isDataUri) {\n      return texture.url;\n    }\n\n    // If its a data URI try and get the correct extension and then fetch the blob\n    const regexResult = texture.url.match(imageTypeRegex);\n    filename = `texture_${++this._count}`;\n    if (defined(regexResult)) {\n      filename += `.${regexResult[1]}`;\n    }\n\n    const promise = texture.fetchBlob().then(function (blob) {\n      that._files[filename] = blob;\n    });\n\n    this._promises.push(promise);\n\n    return filename;\n  }\n\n  if (texture instanceof HTMLCanvasElement) {\n    filename = `texture_${++this._count}.png`;\n    const promise = new Promise((resolve) => {\n      texture.toBlob(function (blob) {\n        that._files[filename] = blob;\n        resolve();\n      });\n    });\n    this._promises.push(promise);\n\n    return filename;\n  }\n\n  return \"\";\n};\n\nfunction getModelBlobHander(that, filename) {\n  return function (blob) {\n    that._files[filename] = blob;\n  };\n}\n\nExternalFileHandler.prototype.model = function (model, time) {\n  const modelCallback = this._modelCallback;\n  if (!defined(modelCallback)) {\n    throw new RuntimeError(\n      \"Encountered a model entity while exporting to KML, but no model callback was supplied.\",\n    );\n  }\n\n  const externalFiles = {};\n  const url = modelCallback(model, time, externalFiles);\n\n  // Iterate through external files and add them to our list once the promise resolves\n  for (const filename in externalFiles) {\n    if (externalFiles.hasOwnProperty(filename)) {\n      const promise = Promise.resolve(externalFiles[filename]);\n      this._promises.push(promise);\n\n      promise.then(getModelBlobHander(this, filename));\n    }\n  }\n\n  return url;\n};\n\nObject.defineProperties(ExternalFileHandler.prototype, {\n  promise: {\n    get: function () {\n      return Promise.all(this._promises);\n    },\n  },\n  files: {\n    get: function () {\n      return this._files;\n    },\n  },\n});\n\n//\n// Handles getting values from properties taking the desired time and default values into account\n//\nfunction ValueGetter(time) {\n  this._time = time;\n}\n\nValueGetter.prototype.get = function (property, defaultVal, result) {\n  let value;\n  if (defined(property)) {\n    value = defined(property.getValue)\n      ? property.getValue(this._time, result)\n      : property;\n  }\n\n  return value ?? defaultVal;\n};\n\nValueGetter.prototype.getColor = function (property, defaultVal) {\n  const result = this.get(property, defaultVal);\n  if (defined(result)) {\n    return colorToString(result);\n  }\n};\n\nValueGetter.prototype.getMaterialType = function (property) {\n  if (!defined(property)) {\n    return;\n  }\n\n  return property.getType(this._time);\n};\n\n//\n// Caches styles so we don't generate a ton of duplicate styles\n//\nfunction StyleCache() {\n  this._ids = {};\n  this._styles = {};\n  this._count = 0;\n}\n\nStyleCache.prototype.get = function (element) {\n  const ids = this._ids;\n  const key = element.innerHTML;\n  if (defined(ids[key])) {\n    return ids[key];\n  }\n\n  let styleId = `style-${++this._count}`;\n  element.setAttribute(\"id\", styleId);\n\n  // Store with #\n  styleId = `#${styleId}`;\n  ids[key] = styleId;\n  this._styles[key] = element;\n\n  return styleId;\n};\n\nStyleCache.prototype.save = function (parentElement) {\n  const styles = this._styles;\n\n  const firstElement = parentElement.childNodes[0];\n  for (const key in styles) {\n    if (styles.hasOwnProperty(key)) {\n      parentElement.insertBefore(styles[key], firstElement);\n    }\n  }\n};\n\n//\n// Manages the generation of IDs because an entity may have geometry and a Folder for children\n//\nfunction IdManager() {\n  this._ids = {};\n}\n\nIdManager.prototype.get = function (id) {\n  if (!defined(id)) {\n    return this.get(createGuid());\n  }\n\n  const ids = this._ids;\n  if (!defined(ids[id])) {\n    ids[id] = 0;\n    return id;\n  }\n\n  return `${id.toString()}-${++ids[id]}`;\n};\n\n/**\n * @typedef exportKmlResultKml\n * @type {object}\n * @property {string} kml The generated KML.\n * @property {Object<string, Blob>} externalFiles An object dictionary of external files\n */\n\n/**\n * @typedef exportKmlResultKmz\n * @type {object}\n * @property {Blob} kmz The generated kmz file.\n */\n\n/**\n * Exports an EntityCollection as a KML document. Only Point, Billboard, Model, Path, Polygon, Polyline geometries\n * will be exported. Note that there is not a 1 to 1 mapping of Entity properties to KML Feature properties. For\n * example, entity properties that are time dynamic but cannot be dynamic in KML are exported with their values at\n * options.time or the beginning of the EntityCollection's time interval if not specified. For time-dynamic properties\n * that are supported in KML, we use the samples if it is a {@link SampledProperty} otherwise we sample the value using\n * the options.sampleDuration. Point, Billboard, Model and Path geometries with time-dynamic positions will be exported\n * as gx:Track Features. Not all Materials are representable in KML, so for more advanced Materials just the primary\n * color is used. Canvas objects are exported as PNG images.\n *\n * @function exportKml\n *\n * @param {object} options An object with the following properties:\n * @param {EntityCollection} options.entities The EntityCollection to export as KML.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid for the output file.\n * @param {exportKmlModelCallback} [options.modelCallback] A callback that will be called with a {@link ModelGraphics} instance and should return the URI to use in the KML. Required if a model exists in the entity collection.\n * @param {JulianDate} [options.time=entities.computeAvailability().start] The time value to use to get properties that are not time varying in KML.\n * @param {TimeInterval} [options.defaultAvailability=entities.computeAvailability()] The interval that will be sampled if an entity doesn't have an availability.\n * @param {number} [options.sampleDuration=60] The number of seconds to sample properties that are varying in KML.\n * @param {boolean} [options.kmz=false] If true KML and external files will be compressed into a kmz file.\n *\n * @returns {Promise<exportKmlResultKml|exportKmlResultKmz>} A promise that resolved to an object containing the KML string and a dictionary of external file blobs, or a kmz file as a blob if options.kmz is true.\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Export%20KML.html|Cesium Sandcastle KML Export Demo}\n * @example\n * Cesium.exportKml({\n *      entities: entityCollection\n *  })\n *   .then(function(result) {\n *     // The XML string is in result.kml\n *\n *     const externalFiles = result.externalFiles\n *     for(const file in externalFiles) {\n *       // file is the name of the file used in the KML document as the href\n *       // externalFiles[file] is a blob with the contents of the file\n *     }\n *   });\n *\n */\nfunction exportKml(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const entities = options.entities;\n  const kmz = options.kmz ?? false;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entities)) {\n    throw new DeveloperError(\"entities is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // Get the state that is passed around during the recursion\n  // This is separated out for testing.\n  const state = exportKml._createState(options);\n\n  // Filter EntityCollection so we only have top level entities\n  const rootEntities = entities.values.filter(function (entity) {\n    return !defined(entity.parent);\n  });\n\n  // Add the <Document>\n  const kmlDoc = state.kmlDoc;\n  const kmlElement = kmlDoc.documentElement;\n  kmlElement.setAttributeNS(xmlnsNamespace, \"xmlns:gx\", gxNamespace);\n  const kmlDocumentElement = kmlDoc.createElement(\"Document\");\n  kmlElement.appendChild(kmlDocumentElement);\n\n  // Create the KML Hierarchy\n  recurseEntities(state, kmlDocumentElement, rootEntities);\n\n  // Write out the <Style> elements\n  state.styleCache.save(kmlDocumentElement);\n\n  // Once all the blobs have resolved return the KML string along with the blob collection\n  const externalFileHandler = state.externalFileHandler;\n  return externalFileHandler.promise.then(function () {\n    const serializer = new XMLSerializer();\n    const kmlString = serializer.serializeToString(state.kmlDoc);\n    if (kmz) {\n      return createKmz(kmlString, externalFileHandler.files);\n    }\n\n    return {\n      kml: kmlString,\n      externalFiles: externalFileHandler.files,\n    };\n  });\n}\n\nasync function createKmz(kmlString, externalFiles) {\n  const zWorkerUri = buildModuleUrl(\"ThirdParty/Workers/zip-web-worker.js\");\n  const zWasmUri = buildModuleUrl(\"ThirdParty/zip-module.wasm\");\n  configure({\n    workerURI: zWorkerUri,\n    wasmURI: zWasmUri,\n  });\n  const blobWriter = new BlobWriter(\"application/vnd.google-earth.kmz\");\n  const writer = new ZipWriter(blobWriter);\n\n  // We need to only write one file at a time so the zip doesn't get corrupted\n  await writer.add(\"doc.kml\", new TextReader(kmlString));\n  const keys = Object.keys(externalFiles);\n  await addExternalFilesToZip(writer, keys, externalFiles, 0);\n  await writer.close();\n  const blob = await blobWriter.getData();\n  return {\n    kmz: blob,\n  };\n}\n\nasync function addExternalFilesToZip(writer, keys, externalFiles, index) {\n  if (keys.length === index) {\n    return;\n  }\n  const filename = keys[index];\n  await writer.add(filename, new BlobReader(externalFiles[filename]));\n  return addExternalFilesToZip(writer, keys, externalFiles, index + 1);\n}\n\nexportKml._createState = function (options) {\n  const entities = options.entities;\n\n  const styleCache = new StyleCache();\n\n  // Use the start time as the default because just in case they define\n  //  properties with an interval even if they don't change.\n  const entityAvailability = entities.computeAvailability();\n  const time = defined(options.time) ? options.time : entityAvailability.start;\n\n  // Figure out how we will sample dynamic position properties\n  let defaultAvailability = options.defaultAvailability ?? entityAvailability;\n  const sampleDuration = options.sampleDuration ?? 60;\n\n  // Make sure we don't have infinite availability if we need to sample\n  if (defaultAvailability.start === Iso8601.MINIMUM_VALUE) {\n    if (defaultAvailability.stop === Iso8601.MAXIMUM_VALUE) {\n      // Infinite, so just use the default\n      defaultAvailability = new TimeInterval();\n    } else {\n      // No start time, so just sample 10 times before the stop\n      JulianDate.addSeconds(\n        defaultAvailability.stop,\n        -10 * sampleDuration,\n        defaultAvailability.start,\n      );\n    }\n  } else if (defaultAvailability.stop === Iso8601.MAXIMUM_VALUE) {\n    // No stop time, so just sample 10 times after the start\n    JulianDate.addSeconds(\n      defaultAvailability.start,\n      10 * sampleDuration,\n      defaultAvailability.stop,\n    );\n  }\n\n  const externalFileHandler = new ExternalFileHandler(options.modelCallback);\n\n  const kmlDoc = document.implementation.createDocument(kmlNamespace, \"kml\");\n  return {\n    kmlDoc: kmlDoc,\n    ellipsoid: options.ellipsoid ?? Ellipsoid.default,\n    idManager: new IdManager(),\n    styleCache: styleCache,\n    externalFileHandler: externalFileHandler,\n    time: time,\n    valueGetter: new ValueGetter(time),\n    sampleDuration: sampleDuration,\n    // Wrap it in a TimeIntervalCollection because that is what entity.availability is\n    defaultAvailability: new TimeIntervalCollection([defaultAvailability]),\n  };\n};\n\nfunction recurseEntities(state, parentNode, entities) {\n  const kmlDoc = state.kmlDoc;\n  const styleCache = state.styleCache;\n  const valueGetter = state.valueGetter;\n  const idManager = state.idManager;\n\n  const count = entities.length;\n  let overlays;\n  let geometries;\n  let styles;\n  for (let i = 0; i < count; ++i) {\n    const entity = entities[i];\n    overlays = [];\n    geometries = [];\n    styles = [];\n\n    createPoint(state, entity, geometries, styles);\n    createLineString(state, entity.polyline, geometries, styles);\n    createPolygon(state, entity.rectangle, geometries, styles, overlays);\n    createPolygon(state, entity.polygon, geometries, styles, overlays);\n    createModel(state, entity, entity.model, geometries, styles);\n\n    let timeSpan;\n    const availability = entity.availability;\n    if (defined(availability)) {\n      timeSpan = kmlDoc.createElement(\"TimeSpan\");\n\n      if (!JulianDate.equals(availability.start, Iso8601.MINIMUM_VALUE)) {\n        timeSpan.appendChild(\n          createBasicElementWithText(\n            kmlDoc,\n            \"begin\",\n            JulianDate.toIso8601(availability.start),\n          ),\n        );\n      }\n\n      if (!JulianDate.equals(availability.stop, Iso8601.MAXIMUM_VALUE)) {\n        timeSpan.appendChild(\n          createBasicElementWithText(\n            kmlDoc,\n            \"end\",\n            JulianDate.toIso8601(availability.stop),\n          ),\n        );\n      }\n    }\n\n    for (let overlayIndex = 0; overlayIndex < overlays.length; ++overlayIndex) {\n      const overlay = overlays[overlayIndex];\n\n      overlay.setAttribute(\"id\", idManager.get(entity.id));\n      overlay.appendChild(\n        createBasicElementWithText(kmlDoc, \"name\", entity.name),\n      );\n      overlay.appendChild(\n        createBasicElementWithText(kmlDoc, \"visibility\", entity.show),\n      );\n      overlay.appendChild(\n        createBasicElementWithText(kmlDoc, \"description\", entity.description),\n      );\n\n      if (defined(timeSpan)) {\n        overlay.appendChild(timeSpan);\n      }\n\n      parentNode.appendChild(overlay);\n    }\n\n    const geometryCount = geometries.length;\n    if (geometryCount > 0) {\n      const placemark = kmlDoc.createElement(\"Placemark\");\n      placemark.setAttribute(\"id\", idManager.get(entity.id));\n\n      let name = entity.name;\n      const labelGraphics = entity.label;\n      if (defined(labelGraphics)) {\n        const labelStyle = kmlDoc.createElement(\"LabelStyle\");\n\n        // KML only shows the name as a label, so just change the name if we need to show a label\n        const text = valueGetter.get(labelGraphics.text);\n        name = defined(text) && text.length > 0 ? text : name;\n\n        const color = valueGetter.getColor(labelGraphics.fillColor);\n        if (defined(color)) {\n          labelStyle.appendChild(\n            createBasicElementWithText(kmlDoc, \"color\", color),\n          );\n          labelStyle.appendChild(\n            createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"),\n          );\n        }\n\n        const scale = valueGetter.get(labelGraphics.scale);\n        if (defined(scale)) {\n          labelStyle.appendChild(\n            createBasicElementWithText(kmlDoc, \"scale\", scale),\n          );\n        }\n\n        styles.push(labelStyle);\n      }\n\n      placemark.appendChild(createBasicElementWithText(kmlDoc, \"name\", name));\n      placemark.appendChild(\n        createBasicElementWithText(kmlDoc, \"visibility\", entity.show),\n      );\n      placemark.appendChild(\n        createBasicElementWithText(kmlDoc, \"description\", entity.description),\n      );\n\n      if (defined(timeSpan)) {\n        placemark.appendChild(timeSpan);\n      }\n\n      parentNode.appendChild(placemark);\n\n      const styleCount = styles.length;\n      if (styleCount > 0) {\n        const style = kmlDoc.createElement(\"Style\");\n        for (let styleIndex = 0; styleIndex < styleCount; ++styleIndex) {\n          style.appendChild(styles[styleIndex]);\n        }\n\n        placemark.appendChild(\n          createBasicElementWithText(kmlDoc, \"styleUrl\", styleCache.get(style)),\n        );\n      }\n\n      if (geometries.length === 1) {\n        placemark.appendChild(geometries[0]);\n      } else if (geometries.length > 1) {\n        const multigeometry = kmlDoc.createElement(\"MultiGeometry\");\n        for (\n          let geometryIndex = 0;\n          geometryIndex < geometryCount;\n          ++geometryIndex\n        ) {\n          multigeometry.appendChild(geometries[geometryIndex]);\n        }\n        placemark.appendChild(multigeometry);\n      }\n    }\n\n    const children = entity._children;\n    if (children.length > 0) {\n      const folderNode = kmlDoc.createElement(\"Folder\");\n      folderNode.setAttribute(\"id\", idManager.get(entity.id));\n      folderNode.appendChild(\n        createBasicElementWithText(kmlDoc, \"name\", entity.name),\n      );\n      folderNode.appendChild(\n        createBasicElementWithText(kmlDoc, \"visibility\", entity.show),\n      );\n      folderNode.appendChild(\n        createBasicElementWithText(kmlDoc, \"description\", entity.description),\n      );\n\n      parentNode.appendChild(folderNode);\n\n      recurseEntities(state, folderNode, children);\n    }\n  }\n}\n\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartographic = new Cartographic();\nconst scratchJulianDate = new JulianDate();\n\nfunction createPoint(state, entity, geometries, styles) {\n  const kmlDoc = state.kmlDoc;\n  const ellipsoid = state.ellipsoid;\n  const valueGetter = state.valueGetter;\n\n  const pointGraphics = entity.billboard ?? entity.point;\n  if (!defined(pointGraphics) && !defined(entity.path)) {\n    return;\n  }\n\n  // If the point isn't constant then create gx:Track or gx:MultiTrack\n  const entityPositionProperty = entity.position;\n  if (!entityPositionProperty.isConstant) {\n    createTracks(state, entity, pointGraphics, geometries, styles);\n    return;\n  }\n\n  valueGetter.get(entityPositionProperty, undefined, scratchCartesian3);\n  const coordinates = createBasicElementWithText(\n    kmlDoc,\n    \"coordinates\",\n    getCoordinates(scratchCartesian3, ellipsoid),\n  );\n\n  const pointGeometry = kmlDoc.createElement(\"Point\");\n\n  // Set altitude mode\n  const altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(\n    getAltitudeMode(state, pointGraphics.heightReference),\n  );\n  pointGeometry.appendChild(altitudeMode);\n\n  pointGeometry.appendChild(coordinates);\n  geometries.push(pointGeometry);\n\n  // Create style\n  const iconStyle =\n    pointGraphics instanceof BillboardGraphics\n      ? createIconStyleFromBillboard(state, pointGraphics)\n      : createIconStyleFromPoint(state, pointGraphics);\n  styles.push(iconStyle);\n}\n\nfunction createTracks(state, entity, pointGraphics, geometries, styles) {\n  const kmlDoc = state.kmlDoc;\n  const ellipsoid = state.ellipsoid;\n  const valueGetter = state.valueGetter;\n\n  let intervals;\n  const entityPositionProperty = entity.position;\n  let useEntityPositionProperty = true;\n  if (entityPositionProperty instanceof CompositePositionProperty) {\n    intervals = entityPositionProperty.intervals;\n    useEntityPositionProperty = false;\n  } else {\n    intervals = entity.availability ?? state.defaultAvailability;\n  }\n\n  const isModel = pointGraphics instanceof ModelGraphics;\n\n  let i, j, times;\n  const tracks = [];\n  for (i = 0; i < intervals.length; ++i) {\n    const interval = intervals.get(i);\n    let positionProperty = useEntityPositionProperty\n      ? entityPositionProperty\n      : interval.data;\n\n    const trackAltitudeMode = kmlDoc.createElement(\"altitudeMode\");\n    // This is something that KML importing uses to handle clampToGround,\n    //  so just extract the internal property and set the altitudeMode.\n    if (positionProperty instanceof ScaledPositionProperty) {\n      positionProperty = positionProperty._value;\n      trackAltitudeMode.appendChild(\n        getAltitudeMode(state, HeightReference.CLAMP_TO_GROUND),\n      );\n    } else if (defined(pointGraphics)) {\n      trackAltitudeMode.appendChild(\n        getAltitudeMode(state, pointGraphics.heightReference),\n      );\n    } else {\n      // Path graphics only, which has no height reference\n      trackAltitudeMode.appendChild(\n        getAltitudeMode(state, HeightReference.NONE),\n      );\n    }\n\n    const positionTimes = [];\n    const positionValues = [];\n\n    if (positionProperty.isConstant) {\n      valueGetter.get(positionProperty, undefined, scratchCartesian3);\n      const constCoordinates = createBasicElementWithText(\n        kmlDoc,\n        \"coordinates\",\n        getCoordinates(scratchCartesian3, ellipsoid),\n      );\n\n      // This interval is constant so add a track with the same position\n      positionTimes.push(JulianDate.toIso8601(interval.start));\n      positionValues.push(constCoordinates);\n      positionTimes.push(JulianDate.toIso8601(interval.stop));\n      positionValues.push(constCoordinates);\n    } else if (positionProperty instanceof SampledPositionProperty) {\n      times = positionProperty._property._times;\n\n      for (j = 0; j < times.length; ++j) {\n        positionTimes.push(JulianDate.toIso8601(times[j]));\n        positionProperty.getValueInReferenceFrame(\n          times[j],\n          ReferenceFrame.FIXED,\n          scratchCartesian3,\n        );\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n      }\n    } else if (positionProperty instanceof SampledProperty) {\n      times = positionProperty._times;\n      const values = positionProperty._values;\n\n      for (j = 0; j < times.length; ++j) {\n        positionTimes.push(JulianDate.toIso8601(times[j]));\n        Cartesian3.fromArray(values, j * 3, scratchCartesian3);\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n      }\n    } else {\n      const duration = state.sampleDuration;\n      interval.start.clone(scratchJulianDate);\n      if (!interval.isStartIncluded) {\n        JulianDate.addSeconds(scratchJulianDate, duration, scratchJulianDate);\n      }\n\n      const stopDate = interval.stop;\n      while (JulianDate.lessThan(scratchJulianDate, stopDate)) {\n        positionProperty.getValue(scratchJulianDate, scratchCartesian3);\n\n        positionTimes.push(JulianDate.toIso8601(scratchJulianDate));\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n\n        JulianDate.addSeconds(scratchJulianDate, duration, scratchJulianDate);\n      }\n\n      if (\n        interval.isStopIncluded &&\n        JulianDate.equals(scratchJulianDate, stopDate)\n      ) {\n        positionProperty.getValue(scratchJulianDate, scratchCartesian3);\n\n        positionTimes.push(JulianDate.toIso8601(scratchJulianDate));\n        positionValues.push(getCoordinates(scratchCartesian3, ellipsoid));\n      }\n    }\n\n    const trackGeometry = kmlDoc.createElementNS(gxNamespace, \"Track\");\n    trackGeometry.appendChild(trackAltitudeMode);\n\n    for (let k = 0; k < positionTimes.length; ++k) {\n      const when = createBasicElementWithText(kmlDoc, \"when\", positionTimes[k]);\n      const coord = createBasicElementWithText(\n        kmlDoc,\n        \"coord\",\n        positionValues[k],\n        gxNamespace,\n      );\n\n      trackGeometry.appendChild(when);\n      trackGeometry.appendChild(coord);\n    }\n\n    if (isModel) {\n      trackGeometry.appendChild(createModelGeometry(state, pointGraphics));\n    }\n\n    tracks.push(trackGeometry);\n  }\n\n  // If one track, then use it otherwise combine into a multitrack\n  if (tracks.length === 1) {\n    geometries.push(tracks[0]);\n  } else if (tracks.length > 1) {\n    const multiTrackGeometry = kmlDoc.createElementNS(\n      gxNamespace,\n      \"MultiTrack\",\n    );\n\n    for (i = 0; i < tracks.length; ++i) {\n      multiTrackGeometry.appendChild(tracks[i]);\n    }\n\n    geometries.push(multiTrackGeometry);\n  }\n\n  // Create style\n  if (defined(pointGraphics) && !isModel) {\n    const iconStyle =\n      pointGraphics instanceof BillboardGraphics\n        ? createIconStyleFromBillboard(state, pointGraphics)\n        : createIconStyleFromPoint(state, pointGraphics);\n    styles.push(iconStyle);\n  }\n\n  // See if we have a line that needs to be drawn\n  const path = entity.path;\n  if (defined(path)) {\n    const width = valueGetter.get(path.width);\n    const material = path.material;\n    if (defined(material) || defined(width)) {\n      const lineStyle = kmlDoc.createElement(\"LineStyle\");\n      if (defined(width)) {\n        lineStyle.appendChild(\n          createBasicElementWithText(kmlDoc, \"width\", width),\n        );\n      }\n\n      processMaterial(state, material, lineStyle);\n      styles.push(lineStyle);\n    }\n  }\n}\n\nfunction createIconStyleFromPoint(state, pointGraphics) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n\n  const iconStyle = kmlDoc.createElement(\"IconStyle\");\n\n  const color = valueGetter.getColor(pointGraphics.color);\n  if (defined(color)) {\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"color\", color));\n    iconStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"),\n    );\n  }\n\n  const pixelSize = valueGetter.get(pointGraphics.pixelSize);\n  if (defined(pixelSize)) {\n    iconStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"scale\", pixelSize / BILLBOARD_SIZE),\n    );\n  }\n\n  return iconStyle;\n}\n\nfunction createIconStyleFromBillboard(state, billboardGraphics) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  const externalFileHandler = state.externalFileHandler;\n\n  const iconStyle = kmlDoc.createElement(\"IconStyle\");\n\n  let image = valueGetter.get(billboardGraphics.image);\n  if (defined(image)) {\n    image = externalFileHandler.texture(image);\n\n    const icon = kmlDoc.createElement(\"Icon\");\n    icon.appendChild(createBasicElementWithText(kmlDoc, \"href\", image));\n\n    const imageSubRegion = valueGetter.get(billboardGraphics.imageSubRegion);\n    if (defined(imageSubRegion)) {\n      icon.appendChild(\n        createBasicElementWithText(kmlDoc, \"x\", imageSubRegion.x, gxNamespace),\n      );\n      icon.appendChild(\n        createBasicElementWithText(kmlDoc, \"y\", imageSubRegion.y, gxNamespace),\n      );\n      icon.appendChild(\n        createBasicElementWithText(\n          kmlDoc,\n          \"w\",\n          imageSubRegion.width,\n          gxNamespace,\n        ),\n      );\n      icon.appendChild(\n        createBasicElementWithText(\n          kmlDoc,\n          \"h\",\n          imageSubRegion.height,\n          gxNamespace,\n        ),\n      );\n    }\n\n    iconStyle.appendChild(icon);\n  }\n\n  const color = valueGetter.getColor(billboardGraphics.color);\n  if (defined(color)) {\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"color\", color));\n    iconStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"),\n    );\n  }\n\n  let scale = valueGetter.get(billboardGraphics.scale);\n  if (defined(scale)) {\n    iconStyle.appendChild(createBasicElementWithText(kmlDoc, \"scale\", scale));\n  }\n\n  const pixelOffset = valueGetter.get(billboardGraphics.pixelOffset);\n  if (defined(pixelOffset)) {\n    scale = scale ?? 1.0;\n\n    Cartesian2.divideByScalar(pixelOffset, scale, pixelOffset);\n\n    const width = valueGetter.get(billboardGraphics.width, BILLBOARD_SIZE);\n    const height = valueGetter.get(billboardGraphics.height, BILLBOARD_SIZE);\n\n    // KML Hotspots are from the bottom left, but we work from the top left\n\n    // Move to left\n    const horizontalOrigin = valueGetter.get(\n      billboardGraphics.horizontalOrigin,\n      HorizontalOrigin.CENTER,\n    );\n    if (horizontalOrigin === HorizontalOrigin.CENTER) {\n      pixelOffset.x -= width * 0.5;\n    } else if (horizontalOrigin === HorizontalOrigin.RIGHT) {\n      pixelOffset.x -= width;\n    }\n\n    // Move to bottom\n    const verticalOrigin = valueGetter.get(\n      billboardGraphics.verticalOrigin,\n      VerticalOrigin.CENTER,\n    );\n    if (verticalOrigin === VerticalOrigin.TOP) {\n      pixelOffset.y += height;\n    } else if (verticalOrigin === VerticalOrigin.CENTER) {\n      pixelOffset.y += height * 0.5;\n    }\n\n    const hotSpot = kmlDoc.createElement(\"hotSpot\");\n    hotSpot.setAttribute(\"x\", -pixelOffset.x);\n    hotSpot.setAttribute(\"y\", pixelOffset.y);\n    hotSpot.setAttribute(\"xunits\", \"pixels\");\n    hotSpot.setAttribute(\"yunits\", \"pixels\");\n\n    iconStyle.appendChild(hotSpot);\n  }\n\n  // We can only specify heading so if axis isn't Z, then we skip the rotation\n  // GE treats a heading of zero as no heading but can still point north using a 360 degree angle\n  let rotation = valueGetter.get(billboardGraphics.rotation);\n  const alignedAxis = valueGetter.get(billboardGraphics.alignedAxis);\n  if (defined(rotation) && Cartesian3.equals(Cartesian3.UNIT_Z, alignedAxis)) {\n    rotation = CesiumMath.toDegrees(-rotation);\n    if (rotation === 0) {\n      rotation = 360;\n    }\n\n    iconStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"heading\", rotation),\n    );\n  }\n\n  return iconStyle;\n}\n\nfunction createLineString(state, polylineGraphics, geometries, styles) {\n  const kmlDoc = state.kmlDoc;\n  const ellipsoid = state.ellipsoid;\n  const valueGetter = state.valueGetter;\n\n  if (!defined(polylineGraphics)) {\n    return;\n  }\n\n  const lineStringGeometry = kmlDoc.createElement(\"LineString\");\n\n  // Set altitude mode\n  const altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  const clampToGround = valueGetter.get(polylineGraphics.clampToGround, false);\n  let altitudeModeText;\n  if (clampToGround) {\n    lineStringGeometry.appendChild(\n      createBasicElementWithText(kmlDoc, \"tessellate\", true),\n    );\n    altitudeModeText = kmlDoc.createTextNode(\"clampToGround\");\n  } else {\n    altitudeModeText = kmlDoc.createTextNode(\"absolute\");\n  }\n  altitudeMode.appendChild(altitudeModeText);\n  lineStringGeometry.appendChild(altitudeMode);\n\n  // Set coordinates\n  const positionsProperty = polylineGraphics.positions;\n  const cartesians = valueGetter.get(positionsProperty);\n  const coordinates = createBasicElementWithText(\n    kmlDoc,\n    \"coordinates\",\n    getCoordinates(cartesians, ellipsoid),\n  );\n  lineStringGeometry.appendChild(coordinates);\n\n  // Set draw order\n  const zIndex = valueGetter.get(polylineGraphics.zIndex);\n  if (clampToGround && defined(zIndex)) {\n    lineStringGeometry.appendChild(\n      createBasicElementWithText(kmlDoc, \"drawOrder\", zIndex, gxNamespace),\n    );\n  }\n\n  geometries.push(lineStringGeometry);\n\n  // Create style\n  const lineStyle = kmlDoc.createElement(\"LineStyle\");\n\n  const width = valueGetter.get(polylineGraphics.width);\n  if (defined(width)) {\n    lineStyle.appendChild(createBasicElementWithText(kmlDoc, \"width\", width));\n  }\n\n  processMaterial(state, polylineGraphics.material, lineStyle);\n\n  styles.push(lineStyle);\n}\n\nfunction getRectangleBoundaries(state, rectangleGraphics, extrudedHeight) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n\n  let height = valueGetter.get(rectangleGraphics.height, 0.0);\n\n  if (extrudedHeight > 0) {\n    // We extrude up and KML extrudes down, so if we extrude, set the polygon height to\n    // the extruded height so KML will look similar to Cesium\n    height = extrudedHeight;\n  }\n\n  const coordinatesProperty = rectangleGraphics.coordinates;\n  const rectangle = valueGetter.get(coordinatesProperty);\n\n  const coordinateStrings = [];\n  const cornerFunction = [\n    Rectangle.northeast,\n    Rectangle.southeast,\n    Rectangle.southwest,\n    Rectangle.northwest,\n  ];\n\n  for (let i = 0; i < 4; ++i) {\n    cornerFunction[i](rectangle, scratchCartographic);\n    coordinateStrings.push(\n      `${CesiumMath.toDegrees(\n        scratchCartographic.longitude,\n      )},${CesiumMath.toDegrees(scratchCartographic.latitude)},${height}`,\n    );\n  }\n\n  const coordinates = createBasicElementWithText(\n    kmlDoc,\n    \"coordinates\",\n    coordinateStrings.join(\" \"),\n  );\n\n  const outerBoundaryIs = kmlDoc.createElement(\"outerBoundaryIs\");\n  const linearRing = kmlDoc.createElement(\"LinearRing\");\n  linearRing.appendChild(coordinates);\n  outerBoundaryIs.appendChild(linearRing);\n\n  return [outerBoundaryIs];\n}\n\nfunction getLinearRing(state, positions, height, perPositionHeight) {\n  const kmlDoc = state.kmlDoc;\n  const ellipsoid = state.ellipsoid;\n\n  const coordinateStrings = [];\n  const positionCount = positions.length;\n  for (let i = 0; i < positionCount; ++i) {\n    Cartographic.fromCartesian(positions[i], ellipsoid, scratchCartographic);\n    coordinateStrings.push(\n      `${CesiumMath.toDegrees(\n        scratchCartographic.longitude,\n      )},${CesiumMath.toDegrees(scratchCartographic.latitude)},${\n        perPositionHeight ? scratchCartographic.height : height\n      }`,\n    );\n  }\n\n  const coordinates = createBasicElementWithText(\n    kmlDoc,\n    \"coordinates\",\n    coordinateStrings.join(\" \"),\n  );\n  const linearRing = kmlDoc.createElement(\"LinearRing\");\n  linearRing.appendChild(coordinates);\n\n  return linearRing;\n}\n\nfunction getPolygonBoundaries(state, polygonGraphics, extrudedHeight) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n\n  let height = valueGetter.get(polygonGraphics.height, 0.0);\n  const perPositionHeight = valueGetter.get(\n    polygonGraphics.perPositionHeight,\n    false,\n  );\n\n  if (!perPositionHeight && extrudedHeight > 0) {\n    // We extrude up and KML extrudes down, so if we extrude, set the polygon height to\n    // the extruded height so KML will look similar to Cesium\n    height = extrudedHeight;\n  }\n\n  const boundaries = [];\n  const hierarchyProperty = polygonGraphics.hierarchy;\n  const hierarchy = valueGetter.get(hierarchyProperty);\n\n  // Polygon hierarchy can sometimes just be an array of positions\n  const positions = Array.isArray(hierarchy) ? hierarchy : hierarchy.positions;\n\n  // Polygon boundaries\n  const outerBoundaryIs = kmlDoc.createElement(\"outerBoundaryIs\");\n  outerBoundaryIs.appendChild(\n    getLinearRing(state, positions, height, perPositionHeight),\n  );\n  boundaries.push(outerBoundaryIs);\n\n  // Hole boundaries\n  const holes = hierarchy.holes;\n  if (defined(holes)) {\n    const holeCount = holes.length;\n    for (let i = 0; i < holeCount; ++i) {\n      const innerBoundaryIs = kmlDoc.createElement(\"innerBoundaryIs\");\n      innerBoundaryIs.appendChild(\n        getLinearRing(state, holes[i].positions, height, perPositionHeight),\n      );\n      boundaries.push(innerBoundaryIs);\n    }\n  }\n\n  return boundaries;\n}\n\nfunction createPolygon(state, geometry, geometries, styles, overlays) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n\n  if (!defined(geometry)) {\n    return;\n  }\n\n  // Detect textured quads and use ground overlays instead\n  const isRectangle = geometry instanceof RectangleGraphics;\n  if (\n    isRectangle &&\n    valueGetter.getMaterialType(geometry.material) === \"Image\"\n  ) {\n    createGroundOverlay(state, geometry, overlays);\n    return;\n  }\n\n  const polygonGeometry = kmlDoc.createElement(\"Polygon\");\n\n  const extrudedHeight = valueGetter.get(geometry.extrudedHeight, 0.0);\n  if (extrudedHeight > 0) {\n    polygonGeometry.appendChild(\n      createBasicElementWithText(kmlDoc, \"extrude\", true),\n    );\n  }\n\n  // Set boundaries\n  const boundaries = isRectangle\n    ? getRectangleBoundaries(state, geometry, extrudedHeight)\n    : getPolygonBoundaries(state, geometry, extrudedHeight);\n\n  const boundaryCount = boundaries.length;\n  for (let i = 0; i < boundaryCount; ++i) {\n    polygonGeometry.appendChild(boundaries[i]);\n  }\n\n  // Set altitude mode\n  const altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(getAltitudeMode(state, geometry.heightReference));\n  polygonGeometry.appendChild(altitudeMode);\n\n  geometries.push(polygonGeometry);\n\n  // Create style\n  const polyStyle = kmlDoc.createElement(\"PolyStyle\");\n\n  const fill = valueGetter.get(geometry.fill, false);\n  if (fill) {\n    polyStyle.appendChild(createBasicElementWithText(kmlDoc, \"fill\", fill));\n  }\n\n  processMaterial(state, geometry.material, polyStyle);\n\n  const outline = valueGetter.get(geometry.outline, false);\n  if (outline) {\n    polyStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"outline\", outline),\n    );\n\n    // Outline uses LineStyle\n    const lineStyle = kmlDoc.createElement(\"LineStyle\");\n\n    const outlineWidth = valueGetter.get(geometry.outlineWidth, 1.0);\n    lineStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"width\", outlineWidth),\n    );\n\n    const outlineColor = valueGetter.getColor(\n      geometry.outlineColor,\n      Color.BLACK,\n    );\n    lineStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"color\", outlineColor),\n    );\n    lineStyle.appendChild(\n      createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"),\n    );\n\n    styles.push(lineStyle);\n  }\n\n  styles.push(polyStyle);\n}\n\nfunction createGroundOverlay(state, rectangleGraphics, overlays) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  const externalFileHandler = state.externalFileHandler;\n\n  const groundOverlay = kmlDoc.createElement(\"GroundOverlay\");\n\n  // Set altitude mode\n  const altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(\n    getAltitudeMode(state, rectangleGraphics.heightReference),\n  );\n  groundOverlay.appendChild(altitudeMode);\n\n  const height = valueGetter.get(rectangleGraphics.height);\n  if (defined(height)) {\n    groundOverlay.appendChild(\n      createBasicElementWithText(kmlDoc, \"altitude\", height),\n    );\n  }\n\n  const rectangle = valueGetter.get(rectangleGraphics.coordinates);\n  const latLonBox = kmlDoc.createElement(\"LatLonBox\");\n  latLonBox.appendChild(\n    createBasicElementWithText(\n      kmlDoc,\n      \"north\",\n      CesiumMath.toDegrees(rectangle.north),\n    ),\n  );\n  latLonBox.appendChild(\n    createBasicElementWithText(\n      kmlDoc,\n      \"south\",\n      CesiumMath.toDegrees(rectangle.south),\n    ),\n  );\n  latLonBox.appendChild(\n    createBasicElementWithText(\n      kmlDoc,\n      \"east\",\n      CesiumMath.toDegrees(rectangle.east),\n    ),\n  );\n  latLonBox.appendChild(\n    createBasicElementWithText(\n      kmlDoc,\n      \"west\",\n      CesiumMath.toDegrees(rectangle.west),\n    ),\n  );\n  groundOverlay.appendChild(latLonBox);\n\n  // We should only end up here if we have an ImageMaterialProperty\n  const material = valueGetter.get(rectangleGraphics.material);\n  const href = externalFileHandler.texture(material.image);\n  const icon = kmlDoc.createElement(\"Icon\");\n  icon.appendChild(createBasicElementWithText(kmlDoc, \"href\", href));\n  groundOverlay.appendChild(icon);\n\n  const color = material.color;\n  if (defined(color)) {\n    groundOverlay.appendChild(\n      createBasicElementWithText(\n        kmlDoc,\n        \"color\",\n        colorToString(material.color),\n      ),\n    );\n  }\n\n  overlays.push(groundOverlay);\n}\n\nfunction createModelGeometry(state, modelGraphics) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n  const externalFileHandler = state.externalFileHandler;\n\n  const modelGeometry = kmlDoc.createElement(\"Model\");\n\n  const scale = valueGetter.get(modelGraphics.scale);\n  if (defined(scale)) {\n    const scaleElement = kmlDoc.createElement(\"scale\");\n    scaleElement.appendChild(createBasicElementWithText(kmlDoc, \"x\", scale));\n    scaleElement.appendChild(createBasicElementWithText(kmlDoc, \"y\", scale));\n    scaleElement.appendChild(createBasicElementWithText(kmlDoc, \"z\", scale));\n    modelGeometry.appendChild(scaleElement);\n  }\n\n  const link = kmlDoc.createElement(\"Link\");\n  const uri = externalFileHandler.model(modelGraphics, state.time);\n\n  link.appendChild(createBasicElementWithText(kmlDoc, \"href\", uri));\n  modelGeometry.appendChild(link);\n\n  return modelGeometry;\n}\n\nfunction createModel(state, entity, modelGraphics, geometries, styles) {\n  const kmlDoc = state.kmlDoc;\n  const ellipsoid = state.ellipsoid;\n  const valueGetter = state.valueGetter;\n\n  if (!defined(modelGraphics)) {\n    return;\n  }\n\n  // If the point isn't constant then create gx:Track or gx:MultiTrack\n  const entityPositionProperty = entity.position;\n  if (!entityPositionProperty.isConstant) {\n    createTracks(state, entity, modelGraphics, geometries, styles);\n    return;\n  }\n\n  const modelGeometry = createModelGeometry(state, modelGraphics);\n\n  // Set altitude mode\n  const altitudeMode = kmlDoc.createElement(\"altitudeMode\");\n  altitudeMode.appendChild(\n    getAltitudeMode(state, modelGraphics.heightReference),\n  );\n  modelGeometry.appendChild(altitudeMode);\n\n  valueGetter.get(entityPositionProperty, undefined, scratchCartesian3);\n  Cartographic.fromCartesian(scratchCartesian3, ellipsoid, scratchCartographic);\n  const location = kmlDoc.createElement(\"Location\");\n  location.appendChild(\n    createBasicElementWithText(\n      kmlDoc,\n      \"longitude\",\n      CesiumMath.toDegrees(scratchCartographic.longitude),\n    ),\n  );\n  location.appendChild(\n    createBasicElementWithText(\n      kmlDoc,\n      \"latitude\",\n      CesiumMath.toDegrees(scratchCartographic.latitude),\n    ),\n  );\n  location.appendChild(\n    createBasicElementWithText(kmlDoc, \"altitude\", scratchCartographic.height),\n  );\n  modelGeometry.appendChild(location);\n\n  geometries.push(modelGeometry);\n}\n\nfunction processMaterial(state, materialProperty, style) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n\n  if (!defined(materialProperty)) {\n    return;\n  }\n\n  const material = valueGetter.get(materialProperty);\n  if (!defined(material)) {\n    return;\n  }\n\n  let color;\n  const type = valueGetter.getMaterialType(materialProperty);\n  let outlineColor;\n  let outlineWidth;\n  switch (type) {\n    case \"Image\":\n      // Image materials are only able to be represented on rectangles, so if we make it\n      //  here we can't texture a generic polygon or polyline in KML, so just use white.\n      color = colorToString(Color.WHITE);\n      break;\n    case \"Color\":\n    case \"Grid\":\n    case \"PolylineGlow\":\n    case \"PolylineArrow\":\n    case \"PolylineDash\":\n      color = colorToString(material.color);\n      break;\n    case \"PolylineOutline\":\n      color = colorToString(material.color);\n\n      outlineColor = colorToString(material.outlineColor);\n      outlineWidth = material.outlineWidth;\n      style.appendChild(\n        createBasicElementWithText(\n          kmlDoc,\n          \"outerColor\",\n          outlineColor,\n          gxNamespace,\n        ),\n      );\n      style.appendChild(\n        createBasicElementWithText(\n          kmlDoc,\n          \"outerWidth\",\n          outlineWidth,\n          gxNamespace,\n        ),\n      );\n      break;\n    case \"Stripe\":\n      color = colorToString(material.oddColor);\n      break;\n  }\n\n  if (defined(color)) {\n    style.appendChild(createBasicElementWithText(kmlDoc, \"color\", color));\n    style.appendChild(\n      createBasicElementWithText(kmlDoc, \"colorMode\", \"normal\"),\n    );\n  }\n}\n\nfunction getAltitudeMode(state, heightReferenceProperty) {\n  const kmlDoc = state.kmlDoc;\n  const valueGetter = state.valueGetter;\n\n  const heightReference = valueGetter.get(\n    heightReferenceProperty,\n    HeightReference.NONE,\n  );\n  let altitudeModeText;\n  switch (heightReference) {\n    case HeightReference.NONE:\n      altitudeModeText = kmlDoc.createTextNode(\"absolute\");\n      break;\n    case HeightReference.CLAMP_TO_GROUND:\n      altitudeModeText = kmlDoc.createTextNode(\"clampToGround\");\n      break;\n    case HeightReference.RELATIVE_TO_GROUND:\n      altitudeModeText = kmlDoc.createTextNode(\"relativeToGround\");\n      break;\n  }\n\n  return altitudeModeText;\n}\n\nfunction getCoordinates(coordinates, ellipsoid) {\n  if (!Array.isArray(coordinates)) {\n    coordinates = [coordinates];\n  }\n\n  const count = coordinates.length;\n  const coordinateStrings = [];\n  for (let i = 0; i < count; ++i) {\n    Cartographic.fromCartesian(coordinates[i], ellipsoid, scratchCartographic);\n    coordinateStrings.push(\n      `${CesiumMath.toDegrees(\n        scratchCartographic.longitude,\n      )},${CesiumMath.toDegrees(scratchCartographic.latitude)},${\n        scratchCartographic.height\n      }`,\n    );\n  }\n\n  return coordinateStrings.join(\" \");\n}\n\nfunction createBasicElementWithText(\n  kmlDoc,\n  elementName,\n  elementValue,\n  namespace,\n) {\n  elementValue = elementValue ?? \"\";\n\n  if (typeof elementValue === \"boolean\") {\n    elementValue = elementValue ? \"1\" : \"0\";\n  }\n\n  // Create element with optional namespace\n  const element = defined(namespace)\n    ? kmlDoc.createElementNS(namespace, elementName)\n    : kmlDoc.createElement(elementName);\n\n  // Wrap value in CDATA section if it contains HTML\n  const text =\n    elementValue === \"string\" && elementValue.indexOf(\"<\") !== -1\n      ? kmlDoc.createCDATASection(elementValue)\n      : kmlDoc.createTextNode(elementValue);\n\n  element.appendChild(text);\n\n  return element;\n}\n\nfunction colorToString(color) {\n  let result = \"\";\n  const bytes = color.toBytes();\n  for (let i = 3; i >= 0; --i) {\n    result +=\n      bytes[i] < 16 ? `0${bytes[i].toString(16)}` : bytes[i].toString(16);\n  }\n\n  return result;\n}\n\n/**\n * Since KML does not support glTF models, this callback is required to specify what URL to use for the model in the KML document.\n * It can also be used to add additional files to the <code>externalFiles</code> object, which is the list of files embedded in the exported KMZ,\n * or otherwise returned with the KML string when exporting.\n *\n * @callback exportKmlModelCallback\n *\n * @param {ModelGraphics} model The ModelGraphics instance for an Entity.\n * @param {JulianDate} time The time that any properties should use to get the value.\n * @param {object} externalFiles An object that maps a filename to a Blob or a Promise that resolves to a Blob.\n * @returns {string} The URL to use for the href in the KML document.\n */\nexport default exportKml;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}