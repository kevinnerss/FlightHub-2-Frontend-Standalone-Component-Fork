{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-hex.js\";\nimport \"core-js/modules/esnext.uint8-array.to-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.to-hex.js\";\nimport Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport deprecationWarning from \"../Core/deprecationWarning.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport JobType from \"./JobType.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\n\n/**\n * Loads an index buffer from a glTF accessor.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfIndexBufferLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {object} options Object with the following properties:\n * @param {ResourceCache} options.resourceCache The {@link ResourceCache} (to avoid circular dependencies).\n * @param {object} options.gltf The glTF JSON.\n * @param {number} options.accessorId The accessor ID corresponding to the index buffer.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {object} [options.primitive] The primitive containing the Draco extension.\n * @param {object} [options.draco] The Draco extension object.\n * @param {string} [options.cacheKey] The cache key of the resource.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {boolean} [options.loadBuffer=false] Load the index buffer as a GPU index buffer.\n * @param {boolean} [options.loadTypedArray=false] Load the index buffer as a typed array.\n * @private\n */\nfunction GltfIndexBufferLoader(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const resourceCache = options.resourceCache;\n  const gltf = options.gltf;\n  const accessorId = options.accessorId;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const primitive = options.primitive;\n  const draco = options.draco;\n  const cacheKey = options.cacheKey;\n  const asynchronous = options.asynchronous ?? true;\n  const loadBuffer = options.loadBuffer ?? false;\n  const loadTypedArray = options.loadTypedArray ?? false;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"options.resourceCache\", resourceCache);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.accessorId\", accessorId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  if (!loadBuffer && !loadTypedArray) {\n    throw new DeveloperError(\"At least one of loadBuffer and loadTypedArray must be true.\");\n  }\n  //>>includeEnd('debug');\n\n  const indexDatatype = gltf.accessors[accessorId].componentType;\n  this._resourceCache = resourceCache;\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._gltf = gltf;\n  this._accessorId = accessorId;\n  this._indexDatatype = indexDatatype;\n  this._primitive = primitive;\n  this._draco = draco;\n  this._cacheKey = cacheKey;\n  this._asynchronous = asynchronous;\n  this._loadBuffer = loadBuffer;\n  this._loadTypedArray = loadTypedArray;\n  this._bufferViewLoader = undefined;\n  this._dracoLoader = undefined;\n  this._typedArray = undefined;\n  this._buffer = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n}\nif (defined(Object.create)) {\n  GltfIndexBufferLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfIndexBufferLoader.prototype.constructor = GltfIndexBufferLoader;\n}\nObject.defineProperties(GltfIndexBufferLoader.prototype, {\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfIndexBufferLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    }\n  },\n  /**\n   * The index buffer. This is only defined when <code>loadBuffer</code> is true.\n   *\n   * @memberof GltfIndexBufferLoader.prototype\n   *\n   * @type {Buffer}\n   * @readonly\n   * @private\n   */\n  buffer: {\n    get: function () {\n      return this._buffer;\n    }\n  },\n  /**\n   * The typed array containing indices. This is only defined when <code>loadTypedArray</code> is true.\n   *\n   * @memberof GltfIndexBufferLoader.prototype\n   *\n   * @type {Uint8Array|Uint16Array|Uint32Array}\n   * @readonly\n   * @private\n   */\n  typedArray: {\n    get: function () {\n      return this._typedArray;\n    }\n  },\n  /**\n   * The index datatype after decode.\n   *\n   * @memberof GltfIndexBufferLoader.prototype\n   *\n   * @type {IndexDatatype}\n   * @readonly\n   * @private\n   */\n  indexDatatype: {\n    get: function () {\n      return this._indexDatatype;\n    }\n  }\n});\nconst scratchIndexBufferJob = new CreateIndexBufferJob();\n\n/**\n * Loads the resource.\n * @returns {Promise<GltfIndexBufferLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfIndexBufferLoader.prototype.load = async function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n  if (defined(this._draco)) {\n    this._promise = loadFromDraco(this);\n    return this._promise;\n  }\n  this._promise = loadFromBufferView(this);\n  return this._promise;\n};\nasync function loadFromDraco(indexBufferLoader) {\n  indexBufferLoader._state = ResourceLoaderState.LOADING;\n  const resourceCache = indexBufferLoader._resourceCache;\n  try {\n    const dracoLoader = resourceCache.getDracoLoader({\n      gltf: indexBufferLoader._gltf,\n      primitive: indexBufferLoader._primitive,\n      draco: indexBufferLoader._draco,\n      gltfResource: indexBufferLoader._gltfResource,\n      baseResource: indexBufferLoader._baseResource\n    });\n    indexBufferLoader._dracoLoader = dracoLoader;\n    await dracoLoader.load();\n    if (indexBufferLoader.isDestroyed()) {\n      return;\n    }\n\n    // Now wait for process() to run to finish loading\n    indexBufferLoader._state = ResourceLoaderState.LOADED;\n    return indexBufferLoader;\n  } catch (error) {\n    if (indexBufferLoader.isDestroyed()) {\n      return;\n    }\n    handleError(indexBufferLoader, error);\n  }\n}\nasync function loadFromBufferView(indexBufferLoader) {\n  const gltf = indexBufferLoader._gltf;\n  const accessorId = indexBufferLoader._accessorId;\n  const accessor = gltf.accessors[accessorId];\n  const bufferViewId = accessor.bufferView;\n  indexBufferLoader._state = ResourceLoaderState.LOADING;\n  const resourceCache = indexBufferLoader._resourceCache;\n  try {\n    const bufferViewLoader = resourceCache.getBufferViewLoader({\n      gltf: gltf,\n      bufferViewId: bufferViewId,\n      gltfResource: indexBufferLoader._gltfResource,\n      baseResource: indexBufferLoader._baseResource\n    });\n    indexBufferLoader._bufferViewLoader = bufferViewLoader;\n    await bufferViewLoader.load();\n    if (indexBufferLoader.isDestroyed()) {\n      return;\n    }\n    const bufferViewTypedArray = bufferViewLoader.typedArray;\n    indexBufferLoader._typedArray = createIndicesTypedArray(indexBufferLoader, bufferViewTypedArray);\n    indexBufferLoader._state = ResourceLoaderState.PROCESSING;\n    return indexBufferLoader;\n  } catch (error) {\n    if (indexBufferLoader.isDestroyed()) {\n      return;\n    }\n    handleError(indexBufferLoader, error);\n  }\n}\nfunction createIndicesTypedArray(indexBufferLoader, bufferViewTypedArray) {\n  const gltf = indexBufferLoader._gltf;\n  const accessorId = indexBufferLoader._accessorId;\n  const accessor = gltf.accessors[accessorId];\n  const count = accessor.count;\n  const indexDatatype = accessor.componentType;\n  const indexSize = IndexDatatype.getSizeInBytes(indexDatatype);\n  let arrayBuffer = bufferViewTypedArray.buffer;\n  let byteOffset = bufferViewTypedArray.byteOffset + accessor.byteOffset;\n  if (byteOffset % indexSize !== 0) {\n    const byteLength = count * indexSize;\n    const view = new Uint8Array(arrayBuffer, byteOffset, byteLength);\n    const copy = new Uint8Array(view);\n    arrayBuffer = copy.buffer;\n    byteOffset = 0;\n    deprecationWarning(\"index-buffer-unaligned\", `The index array is not aligned to a ${indexSize}-byte boundary.`);\n  }\n  let typedArray;\n  if (indexDatatype === IndexDatatype.UNSIGNED_BYTE) {\n    typedArray = new Uint8Array(arrayBuffer, byteOffset, count);\n  } else if (indexDatatype === IndexDatatype.UNSIGNED_SHORT) {\n    typedArray = new Uint16Array(arrayBuffer, byteOffset, count);\n  } else if (indexDatatype === IndexDatatype.UNSIGNED_INT) {\n    typedArray = new Uint32Array(arrayBuffer, byteOffset, count);\n  }\n  return typedArray;\n}\nfunction handleError(indexBufferLoader, error) {\n  indexBufferLoader.unload();\n  indexBufferLoader._state = ResourceLoaderState.FAILED;\n  const errorMessage = \"Failed to load index buffer\";\n  throw indexBufferLoader.getError(errorMessage, error);\n}\nfunction CreateIndexBufferJob() {\n  this.typedArray = undefined;\n  this.indexDatatype = undefined;\n  this.context = undefined;\n  this.buffer = undefined;\n}\nCreateIndexBufferJob.prototype.set = function (typedArray, indexDatatype, context) {\n  this.typedArray = typedArray;\n  this.indexDatatype = indexDatatype;\n  this.context = context;\n};\nCreateIndexBufferJob.prototype.execute = function () {\n  this.buffer = createIndexBuffer(this.typedArray, this.indexDatatype, this.context);\n};\nfunction createIndexBuffer(typedArray, indexDatatype, context) {\n  const buffer = Buffer.createIndexBuffer({\n    typedArray: typedArray,\n    context: context,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: indexDatatype\n  });\n  buffer.vertexArrayDestroyable = false;\n  return buffer;\n}\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfIndexBufferLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === ResourceLoaderState.READY) {\n    return true;\n  }\n  if (this._state !== ResourceLoaderState.LOADED && this._state !== ResourceLoaderState.PROCESSING) {\n    return false;\n  }\n  let typedArray = this._typedArray;\n  let indexDatatype = this._indexDatatype;\n  if (defined(this._dracoLoader)) {\n    try {\n      const ready = this._dracoLoader.process(frameState);\n      if (ready) {\n        const dracoLoader = this._dracoLoader;\n        typedArray = dracoLoader.decodedData.indices.typedArray;\n        this._typedArray = typedArray;\n        // The index datatype may be a smaller datatype after draco decode\n        indexDatatype = ComponentDatatype.fromTypedArray(typedArray);\n        this._indexDatatype = indexDatatype;\n      }\n    } catch (error) {\n      handleError(this, error);\n    }\n  }\n  if (!defined(typedArray)) {\n    // Buffer view hasn't been loaded yet\n    return false;\n  }\n  let buffer;\n  if (this._loadBuffer && this._asynchronous) {\n    const indexBufferJob = scratchIndexBufferJob;\n    indexBufferJob.set(typedArray, indexDatatype, frameState.context);\n    const jobScheduler = frameState.jobScheduler;\n    if (!jobScheduler.execute(indexBufferJob, JobType.BUFFER)) {\n      // Job scheduler is full. Try again next frame.\n      return false;\n    }\n    buffer = indexBufferJob.buffer;\n  } else if (this._loadBuffer) {\n    buffer = createIndexBuffer(typedArray, indexDatatype, frameState.context);\n  }\n\n  // Unload everything except the index buffer and/or typed array.\n  this.unload();\n  this._buffer = buffer;\n  this._typedArray = this._loadTypedArray ? typedArray : undefined;\n  this._state = ResourceLoaderState.READY;\n  this._resourceCache.statistics.addGeometryLoader(this);\n  return true;\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfIndexBufferLoader.prototype.unload = function () {\n  if (defined(this._buffer)) {\n    this._buffer.destroy();\n  }\n  const resourceCache = this._resourceCache;\n  if (defined(this._bufferViewLoader) && !this._bufferViewLoader.isDestroyed()) {\n    resourceCache.unload(this._bufferViewLoader);\n  }\n  if (defined(this._dracoLoader)) {\n    resourceCache.unload(this._dracoLoader);\n  }\n  this._bufferViewLoader = undefined;\n  this._dracoLoader = undefined;\n  this._typedArray = undefined;\n  this._buffer = undefined;\n  this._gltf = undefined;\n  this._primitive = undefined;\n};\nexport default GltfIndexBufferLoader;","map":{"version":3,"names":["Check","ComponentDatatype","Frozen","defined","deprecationWarning","DeveloperError","IndexDatatype","Buffer","BufferUsage","JobType","ResourceLoader","ResourceLoaderState","GltfIndexBufferLoader","options","EMPTY_OBJECT","resourceCache","gltf","accessorId","gltfResource","baseResource","primitive","draco","cacheKey","asynchronous","loadBuffer","loadTypedArray","typeOf","func","object","number","indexDatatype","accessors","componentType","_resourceCache","_gltfResource","_baseResource","_gltf","_accessorId","_indexDatatype","_primitive","_draco","_cacheKey","_asynchronous","_loadBuffer","_loadTypedArray","_bufferViewLoader","undefined","_dracoLoader","_typedArray","_buffer","_state","UNLOADED","_promise","Object","create","prototype","constructor","defineProperties","get","buffer","typedArray","scratchIndexBufferJob","CreateIndexBufferJob","load","loadFromDraco","loadFromBufferView","indexBufferLoader","LOADING","dracoLoader","getDracoLoader","isDestroyed","LOADED","error","handleError","accessor","bufferViewId","bufferView","bufferViewLoader","getBufferViewLoader","bufferViewTypedArray","createIndicesTypedArray","PROCESSING","count","indexSize","getSizeInBytes","arrayBuffer","byteOffset","byteLength","view","Uint8Array","copy","UNSIGNED_BYTE","UNSIGNED_SHORT","Uint16Array","UNSIGNED_INT","Uint32Array","unload","FAILED","errorMessage","getError","context","set","execute","createIndexBuffer","usage","STATIC_DRAW","vertexArrayDestroyable","process","frameState","READY","ready","decodedData","indices","fromTypedArray","indexBufferJob","jobScheduler","BUFFER","statistics","addGeometryLoader","destroy"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/GltfIndexBufferLoader.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport deprecationWarning from \"../Core/deprecationWarning.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport JobType from \"./JobType.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\n\n/**\n * Loads an index buffer from a glTF accessor.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfIndexBufferLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {object} options Object with the following properties:\n * @param {ResourceCache} options.resourceCache The {@link ResourceCache} (to avoid circular dependencies).\n * @param {object} options.gltf The glTF JSON.\n * @param {number} options.accessorId The accessor ID corresponding to the index buffer.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {object} [options.primitive] The primitive containing the Draco extension.\n * @param {object} [options.draco] The Draco extension object.\n * @param {string} [options.cacheKey] The cache key of the resource.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {boolean} [options.loadBuffer=false] Load the index buffer as a GPU index buffer.\n * @param {boolean} [options.loadTypedArray=false] Load the index buffer as a typed array.\n * @private\n */\nfunction GltfIndexBufferLoader(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const resourceCache = options.resourceCache;\n  const gltf = options.gltf;\n  const accessorId = options.accessorId;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const primitive = options.primitive;\n  const draco = options.draco;\n  const cacheKey = options.cacheKey;\n  const asynchronous = options.asynchronous ?? true;\n  const loadBuffer = options.loadBuffer ?? false;\n  const loadTypedArray = options.loadTypedArray ?? false;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"options.resourceCache\", resourceCache);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.accessorId\", accessorId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  if (!loadBuffer && !loadTypedArray) {\n    throw new DeveloperError(\n      \"At least one of loadBuffer and loadTypedArray must be true.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const indexDatatype = gltf.accessors[accessorId].componentType;\n\n  this._resourceCache = resourceCache;\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._gltf = gltf;\n  this._accessorId = accessorId;\n  this._indexDatatype = indexDatatype;\n  this._primitive = primitive;\n  this._draco = draco;\n  this._cacheKey = cacheKey;\n  this._asynchronous = asynchronous;\n  this._loadBuffer = loadBuffer;\n  this._loadTypedArray = loadTypedArray;\n  this._bufferViewLoader = undefined;\n  this._dracoLoader = undefined;\n  this._typedArray = undefined;\n  this._buffer = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n}\n\nif (defined(Object.create)) {\n  GltfIndexBufferLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfIndexBufferLoader.prototype.constructor = GltfIndexBufferLoader;\n}\n\nObject.defineProperties(GltfIndexBufferLoader.prototype, {\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfIndexBufferLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    },\n  },\n  /**\n   * The index buffer. This is only defined when <code>loadBuffer</code> is true.\n   *\n   * @memberof GltfIndexBufferLoader.prototype\n   *\n   * @type {Buffer}\n   * @readonly\n   * @private\n   */\n  buffer: {\n    get: function () {\n      return this._buffer;\n    },\n  },\n  /**\n   * The typed array containing indices. This is only defined when <code>loadTypedArray</code> is true.\n   *\n   * @memberof GltfIndexBufferLoader.prototype\n   *\n   * @type {Uint8Array|Uint16Array|Uint32Array}\n   * @readonly\n   * @private\n   */\n  typedArray: {\n    get: function () {\n      return this._typedArray;\n    },\n  },\n\n  /**\n   * The index datatype after decode.\n   *\n   * @memberof GltfIndexBufferLoader.prototype\n   *\n   * @type {IndexDatatype}\n   * @readonly\n   * @private\n   */\n  indexDatatype: {\n    get: function () {\n      return this._indexDatatype;\n    },\n  },\n});\n\nconst scratchIndexBufferJob = new CreateIndexBufferJob();\n\n/**\n * Loads the resource.\n * @returns {Promise<GltfIndexBufferLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfIndexBufferLoader.prototype.load = async function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n\n  if (defined(this._draco)) {\n    this._promise = loadFromDraco(this);\n    return this._promise;\n  }\n\n  this._promise = loadFromBufferView(this);\n  return this._promise;\n};\n\nasync function loadFromDraco(indexBufferLoader) {\n  indexBufferLoader._state = ResourceLoaderState.LOADING;\n  const resourceCache = indexBufferLoader._resourceCache;\n\n  try {\n    const dracoLoader = resourceCache.getDracoLoader({\n      gltf: indexBufferLoader._gltf,\n      primitive: indexBufferLoader._primitive,\n      draco: indexBufferLoader._draco,\n      gltfResource: indexBufferLoader._gltfResource,\n      baseResource: indexBufferLoader._baseResource,\n    });\n    indexBufferLoader._dracoLoader = dracoLoader;\n    await dracoLoader.load();\n\n    if (indexBufferLoader.isDestroyed()) {\n      return;\n    }\n\n    // Now wait for process() to run to finish loading\n    indexBufferLoader._state = ResourceLoaderState.LOADED;\n    return indexBufferLoader;\n  } catch (error) {\n    if (indexBufferLoader.isDestroyed()) {\n      return;\n    }\n\n    handleError(indexBufferLoader, error);\n  }\n}\n\nasync function loadFromBufferView(indexBufferLoader) {\n  const gltf = indexBufferLoader._gltf;\n  const accessorId = indexBufferLoader._accessorId;\n  const accessor = gltf.accessors[accessorId];\n  const bufferViewId = accessor.bufferView;\n\n  indexBufferLoader._state = ResourceLoaderState.LOADING;\n  const resourceCache = indexBufferLoader._resourceCache;\n  try {\n    const bufferViewLoader = resourceCache.getBufferViewLoader({\n      gltf: gltf,\n      bufferViewId: bufferViewId,\n      gltfResource: indexBufferLoader._gltfResource,\n      baseResource: indexBufferLoader._baseResource,\n    });\n    indexBufferLoader._bufferViewLoader = bufferViewLoader;\n\n    await bufferViewLoader.load();\n    if (indexBufferLoader.isDestroyed()) {\n      return;\n    }\n\n    const bufferViewTypedArray = bufferViewLoader.typedArray;\n    indexBufferLoader._typedArray = createIndicesTypedArray(\n      indexBufferLoader,\n      bufferViewTypedArray,\n    );\n    indexBufferLoader._state = ResourceLoaderState.PROCESSING;\n    return indexBufferLoader;\n  } catch (error) {\n    if (indexBufferLoader.isDestroyed()) {\n      return;\n    }\n\n    handleError(indexBufferLoader, error);\n  }\n}\n\nfunction createIndicesTypedArray(indexBufferLoader, bufferViewTypedArray) {\n  const gltf = indexBufferLoader._gltf;\n  const accessorId = indexBufferLoader._accessorId;\n  const accessor = gltf.accessors[accessorId];\n  const count = accessor.count;\n  const indexDatatype = accessor.componentType;\n  const indexSize = IndexDatatype.getSizeInBytes(indexDatatype);\n\n  let arrayBuffer = bufferViewTypedArray.buffer;\n  let byteOffset = bufferViewTypedArray.byteOffset + accessor.byteOffset;\n\n  if (byteOffset % indexSize !== 0) {\n    const byteLength = count * indexSize;\n    const view = new Uint8Array(arrayBuffer, byteOffset, byteLength);\n    const copy = new Uint8Array(view);\n    arrayBuffer = copy.buffer;\n    byteOffset = 0;\n    deprecationWarning(\n      \"index-buffer-unaligned\",\n      `The index array is not aligned to a ${indexSize}-byte boundary.`,\n    );\n  }\n\n  let typedArray;\n  if (indexDatatype === IndexDatatype.UNSIGNED_BYTE) {\n    typedArray = new Uint8Array(arrayBuffer, byteOffset, count);\n  } else if (indexDatatype === IndexDatatype.UNSIGNED_SHORT) {\n    typedArray = new Uint16Array(arrayBuffer, byteOffset, count);\n  } else if (indexDatatype === IndexDatatype.UNSIGNED_INT) {\n    typedArray = new Uint32Array(arrayBuffer, byteOffset, count);\n  }\n\n  return typedArray;\n}\n\nfunction handleError(indexBufferLoader, error) {\n  indexBufferLoader.unload();\n  indexBufferLoader._state = ResourceLoaderState.FAILED;\n  const errorMessage = \"Failed to load index buffer\";\n  throw indexBufferLoader.getError(errorMessage, error);\n}\n\nfunction CreateIndexBufferJob() {\n  this.typedArray = undefined;\n  this.indexDatatype = undefined;\n  this.context = undefined;\n  this.buffer = undefined;\n}\n\nCreateIndexBufferJob.prototype.set = function (\n  typedArray,\n  indexDatatype,\n  context,\n) {\n  this.typedArray = typedArray;\n  this.indexDatatype = indexDatatype;\n  this.context = context;\n};\n\nCreateIndexBufferJob.prototype.execute = function () {\n  this.buffer = createIndexBuffer(\n    this.typedArray,\n    this.indexDatatype,\n    this.context,\n  );\n};\n\nfunction createIndexBuffer(typedArray, indexDatatype, context) {\n  const buffer = Buffer.createIndexBuffer({\n    typedArray: typedArray,\n    context: context,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: indexDatatype,\n  });\n  buffer.vertexArrayDestroyable = false;\n  return buffer;\n}\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfIndexBufferLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === ResourceLoaderState.READY) {\n    return true;\n  }\n\n  if (\n    this._state !== ResourceLoaderState.LOADED &&\n    this._state !== ResourceLoaderState.PROCESSING\n  ) {\n    return false;\n  }\n\n  let typedArray = this._typedArray;\n  let indexDatatype = this._indexDatatype;\n\n  if (defined(this._dracoLoader)) {\n    try {\n      const ready = this._dracoLoader.process(frameState);\n      if (ready) {\n        const dracoLoader = this._dracoLoader;\n        typedArray = dracoLoader.decodedData.indices.typedArray;\n        this._typedArray = typedArray;\n        // The index datatype may be a smaller datatype after draco decode\n        indexDatatype = ComponentDatatype.fromTypedArray(typedArray);\n        this._indexDatatype = indexDatatype;\n      }\n    } catch (error) {\n      handleError(this, error);\n    }\n  }\n\n  if (!defined(typedArray)) {\n    // Buffer view hasn't been loaded yet\n    return false;\n  }\n\n  let buffer;\n  if (this._loadBuffer && this._asynchronous) {\n    const indexBufferJob = scratchIndexBufferJob;\n    indexBufferJob.set(typedArray, indexDatatype, frameState.context);\n    const jobScheduler = frameState.jobScheduler;\n    if (!jobScheduler.execute(indexBufferJob, JobType.BUFFER)) {\n      // Job scheduler is full. Try again next frame.\n      return false;\n    }\n    buffer = indexBufferJob.buffer;\n  } else if (this._loadBuffer) {\n    buffer = createIndexBuffer(typedArray, indexDatatype, frameState.context);\n  }\n\n  // Unload everything except the index buffer and/or typed array.\n  this.unload();\n\n  this._buffer = buffer;\n  this._typedArray = this._loadTypedArray ? typedArray : undefined;\n  this._state = ResourceLoaderState.READY;\n\n  this._resourceCache.statistics.addGeometryLoader(this);\n  return true;\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfIndexBufferLoader.prototype.unload = function () {\n  if (defined(this._buffer)) {\n    this._buffer.destroy();\n  }\n\n  const resourceCache = this._resourceCache;\n\n  if (\n    defined(this._bufferViewLoader) &&\n    !this._bufferViewLoader.isDestroyed()\n  ) {\n    resourceCache.unload(this._bufferViewLoader);\n  }\n\n  if (defined(this._dracoLoader)) {\n    resourceCache.unload(this._dracoLoader);\n  }\n\n  this._bufferViewLoader = undefined;\n  this._dracoLoader = undefined;\n  this._typedArray = undefined;\n  this._buffer = undefined;\n  this._gltf = undefined;\n  this._primitive = undefined;\n};\n\nexport default GltfIndexBufferLoader;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}