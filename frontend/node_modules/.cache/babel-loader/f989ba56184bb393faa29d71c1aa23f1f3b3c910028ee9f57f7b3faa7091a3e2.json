{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Check from \"../Core/Check.js\";\nimport ClippingPlane from \"./ClippingPlane.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport VoxelBoundsCollection from \"./VoxelBoundsCollection.js\";\n\n/**\n * A cylinder {@link VoxelShape}.\n *\n * @alias VoxelCylinderShape\n * @constructor\n *\n * @see VoxelShape\n * @see VoxelBoxShape\n * @see VoxelEllipsoidShape\n * @see VoxelShapeType\n *\n * @private\n */\nfunction VoxelCylinderShape() {\n  this._orientedBoundingBox = new OrientedBoundingBox();\n  this._boundingSphere = new BoundingSphere();\n  this._boundTransform = new Matrix4();\n  this._shapeTransform = new Matrix4();\n\n  /**\n   * The minimum bounds of the shape, corresponding to minimum radius, angle, and height.\n   * @type {Cartesian3}\n   * @private\n   */\n  this._minBounds = VoxelCylinderShape.DefaultMinBounds.clone();\n\n  /**\n   * The maximum bounds of the shape, corresponding to maximum radius, angle, and height.\n   * @type {Cartesian3}\n   * @private\n   */\n  this._maxBounds = VoxelCylinderShape.DefaultMaxBounds.clone();\n  const {\n    DefaultMinBounds,\n    DefaultMaxBounds\n  } = VoxelCylinderShape;\n  const boundPlanes = [new ClippingPlane(Cartesian3.negate(Cartesian3.UNIT_Z, new Cartesian3()), DefaultMinBounds.z), new ClippingPlane(Cartesian3.UNIT_Z, -DefaultMaxBounds.z)];\n  this._renderBoundPlanes = new VoxelBoundsCollection({\n    planes: boundPlanes\n  });\n  this._shaderUniforms = {\n    cameraShapePosition: new Cartesian3(),\n    cylinderEcToRadialTangentUp: new Matrix3(),\n    cylinderRenderRadiusMinMax: new Cartesian2(),\n    cylinderRenderAngleMinMax: new Cartesian2(),\n    cylinderLocalToShapeUvRadius: new Cartesian2(),\n    cylinderLocalToShapeUvAngle: new Cartesian2(),\n    cylinderLocalToShapeUvHeight: new Cartesian2(),\n    cylinderShapeUvAngleRangeOrigin: 0.0\n  };\n  this._shaderDefines = {\n    CYLINDER_HAS_SHAPE_BOUNDS_ANGLE: undefined,\n    CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN: undefined,\n    CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT: undefined,\n    CYLINDER_HAS_RENDER_BOUNDS_ANGLE: undefined,\n    CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO: undefined,\n    CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF: undefined,\n    CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF: undefined,\n    CYLINDER_INTERSECTION_INDEX_RADIUS_MAX: undefined,\n    CYLINDER_INTERSECTION_INDEX_RADIUS_MIN: undefined,\n    CYLINDER_INTERSECTION_INDEX_ANGLE: undefined\n  };\n  this._shaderMaximumIntersectionsLength = 0; // not known until update\n}\nObject.defineProperties(VoxelCylinderShape.prototype, {\n  /**\n   * An oriented bounding box containing the bounded shape.\n   *\n   * @memberof VoxelCylinderShape.prototype\n   * @type {OrientedBoundingBox}\n   * @readonly\n   * @private\n   */\n  orientedBoundingBox: {\n    get: function () {\n      return this._orientedBoundingBox;\n    }\n  },\n  /**\n   * A collection of planes used for the render bounds\n   * @memberof VoxelCylinderShape.prototype\n   * @type {VoxelBoundsCollection}\n   * @readonly\n   * @private\n   */\n  renderBoundPlanes: {\n    get: function () {\n      return this._renderBoundPlanes;\n    }\n  },\n  /**\n   * A bounding sphere containing the bounded shape.\n   *\n   * @memberof VoxelCylinderShape.prototype\n   * @type {BoundingSphere}\n   * @readonly\n   * @private\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    }\n  },\n  /**\n   * A transformation matrix containing the bounded shape.\n   *\n   * @memberof VoxelCylinderShape.prototype\n   * @type {Matrix4}\n   * @readonly\n   * @private\n   */\n  boundTransform: {\n    get: function () {\n      return this._boundTransform;\n    }\n  },\n  /**\n   * A transformation matrix containing the shape, ignoring the bounds.\n   *\n   * @memberof VoxelCylinderShape.prototype\n   * @type {Matrix4}\n   * @readonly\n   * @private\n   */\n  shapeTransform: {\n    get: function () {\n      return this._shapeTransform;\n    }\n  },\n  /**\n   * @memberof VoxelCylinderShape.prototype\n   * @type {Object<string, any>}\n   * @readonly\n   * @private\n   */\n  shaderUniforms: {\n    get: function () {\n      return this._shaderUniforms;\n    }\n  },\n  /**\n   * @memberof VoxelCylinderShape.prototype\n   * @type {Object<string, any>}\n   * @readonly\n   * @private\n   */\n  shaderDefines: {\n    get: function () {\n      return this._shaderDefines;\n    }\n  },\n  /**\n   * The maximum number of intersections against the shape for any ray direction.\n   * @memberof VoxelCylinderShape.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  shaderMaximumIntersectionsLength: {\n    get: function () {\n      return this._shaderMaximumIntersectionsLength;\n    }\n  }\n});\nconst scratchScale = new Cartesian3();\nconst scratchClipMinBounds = new Cartesian3();\nconst scratchClipMaxBounds = new Cartesian3();\nconst scratchRenderMinBounds = new Cartesian3();\nconst scratchRenderMaxBounds = new Cartesian3();\nconst scratchTransformPositionWorldToLocal = new Matrix4();\nconst scratchCameraPositionLocal = new Cartesian3();\nconst scratchCameraRadialPosition = new Cartesian2();\n\n/**\n * Update the shape's state.\n * @private\n * @param {Matrix4} modelMatrix The model matrix.\n * @param {Cartesian3} minBounds The minimum bounds.\n * @param {Cartesian3} maxBounds The maximum bounds.\n * @param {Cartesian3} [clipMinBounds] The minimum clip bounds.\n * @param {Cartesian3} [clipMaxBounds] The maximum clip bounds.\n * @returns {boolean} Whether the shape is visible.\n */\nVoxelCylinderShape.prototype.update = function (modelMatrix, minBounds, maxBounds, clipMinBounds, clipMaxBounds) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"modelMatrix\", modelMatrix);\n  Check.typeOf.object(\"minBounds\", minBounds);\n  Check.typeOf.object(\"maxBounds\", maxBounds);\n  //>>includeEnd('debug');\n\n  clipMinBounds = clipMinBounds ?? minBounds.clone(scratchClipMinBounds);\n  clipMaxBounds = clipMaxBounds ?? maxBounds.clone(scratchClipMaxBounds);\n  minBounds = Cartesian3.clone(minBounds, this._minBounds);\n  maxBounds = Cartesian3.clone(maxBounds, this._maxBounds);\n  const {\n    DefaultMinBounds,\n    DefaultMaxBounds\n  } = VoxelCylinderShape;\n  const defaultAngleRange = DefaultMaxBounds.y - DefaultMinBounds.y; // == 2 * PI\n  const defaultAngleRangeHalf = 0.5 * defaultAngleRange; // == PI\n\n  const epsilonZeroScale = CesiumMath.EPSILON10;\n  const epsilonAngle = CesiumMath.EPSILON10;\n\n  // Clamp the bounds to the valid range\n  minBounds.x = Math.max(0.0, minBounds.x);\n  // TODO: require maxBounds.x >= minBounds.x ?\n  maxBounds.x = Math.max(0.0, maxBounds.x);\n  minBounds.y = CesiumMath.negativePiToPi(minBounds.y);\n  maxBounds.y = CesiumMath.negativePiToPi(maxBounds.y);\n  clipMinBounds.y = CesiumMath.negativePiToPi(clipMinBounds.y);\n  clipMaxBounds.y = CesiumMath.negativePiToPi(clipMaxBounds.y);\n\n  // TODO: what does this do with partial volumes crossing the antimeridian?\n  // We could have minBounds.y = +PI/2 and maxBounds.y = -PI/2.\n  // Then clipMinBounds.y = +PI/4 and clipMaxBounds.y = -PI/4.\n  // This maximumByComponent would cancel the clipping.\n  const renderMinBounds = Cartesian3.maximumByComponent(minBounds, clipMinBounds, scratchRenderMinBounds);\n  const renderMaxBounds = Cartesian3.minimumByComponent(maxBounds, clipMaxBounds, scratchRenderMaxBounds);\n\n  // Exit early if the shape is not visible.\n  // Note that minAngle may be greater than maxAngle when crossing the 180th meridian.\n\n  // Cylinder is not visible if:\n  // - maxRadius is zero (line)\n  // - minRadius is greater than maxRadius\n  // - minHeight is greater than maxHeight\n  // - scale is 0 for any component (too annoying to reconstruct rotation matrix)\n  const scale = Matrix4.getScale(modelMatrix, scratchScale);\n  if (renderMaxBounds.x === 0.0 || renderMinBounds.x > renderMaxBounds.x || renderMinBounds.z > renderMaxBounds.z || CesiumMath.equalsEpsilon(scale.x, 0.0, undefined, epsilonZeroScale) || CesiumMath.equalsEpsilon(scale.y, 0.0, undefined, epsilonZeroScale) || CesiumMath.equalsEpsilon(scale.z, 0.0, undefined, epsilonZeroScale)) {\n    return false;\n  }\n\n  // Update the render bounds planes\n  const renderBoundPlanes = this._renderBoundPlanes;\n  renderBoundPlanes.get(0).distance = renderMinBounds.z;\n  renderBoundPlanes.get(1).distance = -renderMaxBounds.z;\n  this._shapeTransform = Matrix4.clone(modelMatrix, this._shapeTransform);\n  this._orientedBoundingBox = getCylinderChunkObb(renderMinBounds, renderMaxBounds, this._shapeTransform, this._orientedBoundingBox);\n  this._boundTransform = Matrix4.fromRotationTranslation(this._orientedBoundingBox.halfAxes, this._orientedBoundingBox.center, this._boundTransform);\n  this._boundingSphere = BoundingSphere.fromOrientedBoundingBox(this._orientedBoundingBox, this._boundingSphere);\n  const shapeIsAngleReversed = maxBounds.y < minBounds.y;\n  const shapeAngleRange = maxBounds.y - minBounds.y + shapeIsAngleReversed * defaultAngleRange;\n  const renderIsAngleReversed = renderMaxBounds.y < renderMinBounds.y;\n  const renderAngleRange = renderMaxBounds.y - renderMinBounds.y + renderIsAngleReversed * defaultAngleRange;\n  const renderIsAngleRegular = renderAngleRange >= defaultAngleRangeHalf - epsilonAngle && renderAngleRange < defaultAngleRange - epsilonAngle;\n  const renderIsAngleFlipped = renderAngleRange > epsilonAngle && renderAngleRange < defaultAngleRangeHalf - epsilonAngle;\n  const renderIsAngleRangeZero = renderAngleRange <= epsilonAngle;\n  const renderHasAngle = renderIsAngleRegular || renderIsAngleFlipped || renderIsAngleRangeZero;\n  const shaderUniforms = this._shaderUniforms;\n  const shaderDefines = this._shaderDefines;\n\n  // To keep things simple, clear the defines every time\n  for (const key in shaderDefines) {\n    if (shaderDefines.hasOwnProperty(key)) {\n      shaderDefines[key] = undefined;\n    }\n  }\n\n  // Keep track of how many intersections there are going to be.\n  let intersectionCount = 0;\n  shaderDefines[\"CYLINDER_INTERSECTION_INDEX_RADIUS_MAX\"] = intersectionCount;\n  intersectionCount += 1;\n  if (shapeAngleRange < defaultAngleRange - epsilonAngle) {\n    shaderDefines[\"CYLINDER_HAS_SHAPE_BOUNDS_ANGLE\"] = true;\n  }\n  if (renderMinBounds.x !== DefaultMinBounds.x) {\n    shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN\"] = true;\n    shaderDefines[\"CYLINDER_INTERSECTION_INDEX_RADIUS_MIN\"] = intersectionCount;\n    intersectionCount += 1;\n  }\n  shaderUniforms.cylinderRenderRadiusMinMax = Cartesian2.fromElements(renderMinBounds.x, renderMaxBounds.x, shaderUniforms.cylinderRenderRadiusMinMax);\n  if (renderMinBounds.x === renderMaxBounds.x) {\n    shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT\"] = true;\n  }\n  const radiusRange = maxBounds.x - minBounds.x;\n  let radialScale = 0.0;\n  let radialOffset = 1.0;\n  if (radiusRange !== 0.0) {\n    radialScale = 1.0 / radiusRange;\n    radialOffset = -minBounds.x * radialScale;\n  }\n  shaderUniforms.cylinderLocalToShapeUvRadius = Cartesian2.fromElements(radialScale, radialOffset, shaderUniforms.cylinderLocalToShapeUvRadius);\n  const heightRange = maxBounds.z - minBounds.z; // Default 2.0\n  let heightScale = 0.0;\n  let heightOffset = 1.0;\n  if (heightRange !== 0.0) {\n    heightScale = 1.0 / heightRange;\n    heightOffset = -minBounds.z * heightScale;\n  }\n  shaderUniforms.cylinderLocalToShapeUvHeight = Cartesian2.fromElements(heightScale, heightOffset, shaderUniforms.cylinderLocalToShapeUvHeight);\n  if (renderHasAngle) {\n    shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_ANGLE\"] = true;\n    shaderDefines[\"CYLINDER_INTERSECTION_INDEX_ANGLE\"] = intersectionCount;\n    if (renderIsAngleRegular) {\n      shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF\"] = true;\n      intersectionCount += 1;\n    } else if (renderIsAngleFlipped) {\n      shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF\"] = true;\n      intersectionCount += 2;\n    } else if (renderIsAngleRangeZero) {\n      shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO\"] = true;\n      intersectionCount += 2;\n    }\n    shaderUniforms.cylinderRenderAngleMinMax = Cartesian2.fromElements(renderMinBounds.y, renderMaxBounds.y, shaderUniforms.cylinderRenderAngleMinMax);\n  }\n  const uvMinAngle = (minBounds.y - DefaultMinBounds.y) / defaultAngleRange;\n  const uvMaxAngle = (maxBounds.y - DefaultMinBounds.y) / defaultAngleRange;\n  const uvAngleRangeZero = 1.0 - shapeAngleRange / defaultAngleRange;\n\n  // Translate the origin of UV angles (in [0,1]) to the center of the unoccupied space\n  const uvAngleRangeOrigin = (uvMaxAngle + 0.5 * uvAngleRangeZero) % 1.0;\n  shaderUniforms.cylinderShapeUvAngleRangeOrigin = uvAngleRangeOrigin;\n  if (shapeAngleRange <= epsilonAngle) {\n    shaderUniforms.cylinderLocalToShapeUvAngle = Cartesian2.fromElements(0.0, 1.0, shaderUniforms.cylinderLocalToShapeUvAngle);\n  } else {\n    const scale = defaultAngleRange / shapeAngleRange;\n    const shiftedMinAngle = uvMinAngle - uvAngleRangeOrigin;\n    const offset = -scale * (shiftedMinAngle - Math.floor(shiftedMinAngle));\n    shaderUniforms.cylinderLocalToShapeUvAngle = Cartesian2.fromElements(scale, offset, shaderUniforms.cylinderLocalToShapeUvAngle);\n  }\n  this._shaderMaximumIntersectionsLength = intersectionCount;\n  return true;\n};\nconst scratchRotateRtuToLocal = new Matrix3();\nconst scratchRtuRotation = new Matrix3();\nconst scratchTransformPositionViewToLocal = new Matrix4();\n\n/**\n * Update any view-dependent transforms.\n * @private\n * @param {FrameState} frameState The frame state.\n */\nVoxelCylinderShape.prototype.updateViewTransforms = function (frameState) {\n  const shaderUniforms = this._shaderUniforms;\n  // 1. Update camera position in cylindrical coordinates\n  const transformPositionWorldToLocal = Matrix4.inverse(this._shapeTransform, scratchTransformPositionWorldToLocal);\n  const cameraPositionLocal = Matrix4.multiplyByPoint(transformPositionWorldToLocal, frameState.camera.positionWC, scratchCameraPositionLocal);\n  shaderUniforms.cameraShapePosition = Cartesian3.fromElements(Cartesian2.magnitude(cameraPositionLocal), Math.atan2(cameraPositionLocal.y, cameraPositionLocal.x), cameraPositionLocal.z, shaderUniforms.cameraShapePosition);\n  // 2. Find radial, tangent, and up components at camera position\n  const cameraRadialDirection = Cartesian2.normalize(Cartesian2.fromCartesian3(cameraPositionLocal, scratchCameraRadialPosition), scratchCameraRadialPosition);\n  // As row vectors, the radial, tangent, and up vectors constitute a rotation matrix from local to RTU.\n  const rotateLocalToRtu = Matrix3.fromRowMajorArray([cameraRadialDirection.x, cameraRadialDirection.y, 0.0, -cameraRadialDirection.y, cameraRadialDirection.x, 0.0, 0.0, 0.0, 1.0], scratchRotateRtuToLocal);\n  // 3. Get rotation from eye to local coordinates\n  const transformPositionViewToWorld = frameState.context.uniformState.inverseView;\n  const transformPositionViewToLocal = Matrix4.multiplyTransformation(transformPositionWorldToLocal, transformPositionViewToWorld, scratchTransformPositionViewToLocal);\n  const transformDirectionViewToLocal = Matrix4.getMatrix3(transformPositionViewToLocal, scratchRtuRotation);\n  // 4. Multiply to get rotation from eye to RTU coordinates\n  shaderUniforms.cylinderEcToRadialTangentUp = Matrix3.multiply(rotateLocalToRtu, transformDirectionViewToLocal, shaderUniforms.cylinderEcToRadialTangentUp);\n};\n\n/**\n * Convert a UV coordinate to the shape's UV space.\n * @private\n * @param {Cartesian3} positionLocal The local coordinate to convert.\n * @param {Cartesian3} result The Cartesian3 to store the result in.\n * @returns {Cartesian3} The converted UV coordinate.\n */\nVoxelCylinderShape.prototype.convertLocalToShapeUvSpace = function (positionLocal, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"positionLocal\", positionLocal);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  let radius = Math.hypot(positionLocal.x, positionLocal.y);\n  let angle = Math.atan2(positionLocal.y, positionLocal.x);\n  let height = positionLocal.z;\n  const {\n    cylinderLocalToShapeUvRadius,\n    cylinderLocalToShapeUvAngle,\n    cylinderShapeUvAngleRangeOrigin,\n    cylinderLocalToShapeUvHeight\n  } = this._shaderUniforms;\n  radius = radius * cylinderLocalToShapeUvRadius.x + cylinderLocalToShapeUvRadius.y;\n\n  // Convert angle to a \"UV\" in [0,1] with 0 defined at the center of the unoccupied space.\n  angle = (angle + Math.PI) / (2.0 * Math.PI);\n  angle -= cylinderShapeUvAngleRangeOrigin;\n  angle = angle - Math.floor(angle);\n  // Scale and shift so [0,1] covers the occupied space.\n  angle = angle * cylinderLocalToShapeUvAngle.x + cylinderLocalToShapeUvAngle.y;\n  height = height * cylinderLocalToShapeUvHeight.x + cylinderLocalToShapeUvHeight.y;\n  return Cartesian3.fromElements(radius, angle, height, result);\n};\nconst scratchMinBounds = new Cartesian3();\nconst scratchMaxBounds = new Cartesian3();\n\n/**\n * Computes an oriented bounding box for a specified tile.\n * @private\n * @param {number} tileLevel The tile's level.\n * @param {number} tileX The tile's x coordinate.\n * @param {number} tileY The tile's y coordinate.\n * @param {number} tileZ The tile's z coordinate.\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified tile\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelCylinderShape.prototype.computeOrientedBoundingBoxForTile = function (tileLevel, tileX, tileY, tileZ, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"tileLevel\", tileLevel);\n  Check.typeOf.number(\"tileX\", tileX);\n  Check.typeOf.number(\"tileY\", tileY);\n  Check.typeOf.number(\"tileZ\", tileZ);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const minBounds = this._minBounds;\n  const maxBounds = this._maxBounds;\n  const sizeAtLevel = 1.0 / Math.pow(2.0, tileLevel);\n  const tileMinBounds = Cartesian3.fromElements(CesiumMath.lerp(minBounds.x, maxBounds.x, tileX * sizeAtLevel), CesiumMath.lerp(minBounds.y, maxBounds.y, tileY * sizeAtLevel), CesiumMath.lerp(minBounds.z, maxBounds.z, tileZ * sizeAtLevel), scratchMinBounds);\n  const tileMaxBounds = Cartesian3.fromElements(CesiumMath.lerp(minBounds.x, maxBounds.x, (tileX + 1) * sizeAtLevel), CesiumMath.lerp(minBounds.y, maxBounds.y, (tileY + 1) * sizeAtLevel), CesiumMath.lerp(minBounds.z, maxBounds.z, (tileZ + 1) * sizeAtLevel), scratchMaxBounds);\n  return getCylinderChunkObb(tileMinBounds, tileMaxBounds, this._shapeTransform, result);\n};\nconst sampleSizeScratch = new Cartesian3();\n\n/**\n * Computes an oriented bounding box for a specified sample within a specified tile.\n * @private\n * @param {SpatialNode} spatialNode The spatial node containing the sample\n * @param {Cartesian3} tileDimensions The size of the tile in number of samples, before padding\n * @param {Cartesian3} tileUv The sample coordinate within the tile\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified sample\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelCylinderShape.prototype.computeOrientedBoundingBoxForSample = function (spatialNode, tileDimensions, tileUv, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"spatialNode\", spatialNode);\n  Check.typeOf.object(\"tileDimensions\", tileDimensions);\n  Check.typeOf.object(\"tileUv\", tileUv);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const tileSizeAtLevel = 1.0 / Math.pow(2.0, spatialNode.level);\n  const sampleSize = Cartesian3.divideComponents(Cartesian3.ONE, tileDimensions, sampleSizeScratch);\n  const sampleSizeAtLevel = Cartesian3.multiplyByScalar(sampleSize, tileSizeAtLevel, sampleSizeScratch);\n  const minLerp = Cartesian3.multiplyByScalar(Cartesian3.fromElements(spatialNode.x + tileUv.x, spatialNode.y + tileUv.y, spatialNode.z + tileUv.z, scratchMinBounds), tileSizeAtLevel, scratchMinBounds);\n  const maxLerp = Cartesian3.add(minLerp, sampleSizeAtLevel, scratchMaxBounds);\n  const minBounds = this._minBounds;\n  const maxBounds = this._maxBounds;\n  const sampleMinBounds = Cartesian3.fromElements(CesiumMath.lerp(minBounds.x, maxBounds.x, minLerp.x), CesiumMath.lerp(minBounds.y, maxBounds.y, minLerp.y), CesiumMath.lerp(minBounds.z, maxBounds.z, minLerp.z), scratchMinBounds);\n  const sampleMaxBounds = Cartesian3.fromElements(CesiumMath.lerp(minBounds.x, maxBounds.x, maxLerp.x), CesiumMath.lerp(minBounds.y, maxBounds.y, maxLerp.y), CesiumMath.lerp(minBounds.z, maxBounds.z, maxLerp.z), scratchMaxBounds);\n  return getCylinderChunkObb(sampleMinBounds, sampleMaxBounds, this._shapeTransform, result);\n};\n\n/**\n * Defines the minimum bounds of the shape. Corresponds to minimum radius, angle, and height.\n *\n * @type {Cartesian3}\n * @constant\n * @readonly\n *\n * @private\n */\nVoxelCylinderShape.DefaultMinBounds = Object.freeze(new Cartesian3(0.0, -CesiumMath.PI, -1.0));\n\n/**\n * Defines the maximum bounds of the shape. Corresponds to maximum radius, angle, height.\n *\n * @type {Cartesian3}\n * @constant\n * @readonly\n *\n * @private\n */\nVoxelCylinderShape.DefaultMaxBounds = Object.freeze(new Cartesian3(1.0, +CesiumMath.PI, +1.0));\nconst maxTestAngles = 5;\nconst scratchTestAngles = new Array(maxTestAngles);\nconst scratchTranslation = new Cartesian3();\nconst scratchRotation = new Matrix3();\nconst scratchTranslationMatrix = new Matrix4();\nconst scratchRotationMatrix = new Matrix4();\nconst scratchScaleMatrix = new Matrix4();\nconst scratchMatrix = new Matrix4();\nconst scratchColumn0 = new Cartesian3();\nconst scratchColumn1 = new Cartesian3();\nconst scratchColumn2 = new Cartesian3();\nconst scratchCorners = new Array(8);\nfor (let i = 0; i < 8; i++) {\n  scratchCorners[i] = new Cartesian3();\n}\nfunction orthogonal(a, b, epsilon) {\n  return Math.abs(Cartesian4.dot(a, b)) < epsilon;\n}\nfunction isValidOrientedBoundingBoxTransformation(matrix) {\n  const column0 = Matrix4.getColumn(matrix, 0, scratchColumn0);\n  const column1 = Matrix4.getColumn(matrix, 1, scratchColumn1);\n  const column2 = Matrix4.getColumn(matrix, 2, scratchColumn2);\n  const epsilon = CesiumMath.EPSILON4;\n  return orthogonal(column0, column1, epsilon) && orthogonal(column1, column2, epsilon);\n}\nfunction computeLooseOrientedBoundingBox(matrix, result) {\n  const corners = scratchCorners;\n  Cartesian3.fromElements(-0.5, -0.5, -0.5, corners[0]);\n  Cartesian3.fromElements(-0.5, -0.5, 0.5, corners[1]);\n  Cartesian3.fromElements(-0.5, 0.5, -0.5, corners[2]);\n  Cartesian3.fromElements(-0.5, 0.5, 0.5, corners[3]);\n  Cartesian3.fromElements(0.5, -0.5, -0.5, corners[4]);\n  Cartesian3.fromElements(0.5, -0.5, 0.5, corners[5]);\n  Cartesian3.fromElements(0.5, 0.5, -0.5, corners[6]);\n  Cartesian3.fromElements(0.5, 0.5, 0.5, corners[7]);\n  for (let i = 0; i < 8; ++i) {\n    Matrix4.multiplyByPoint(matrix, corners[i], corners[i]);\n  }\n  return OrientedBoundingBox.fromPoints(corners, result);\n}\nconst scratchBoxScale = new Cartesian3();\n/**\n * Computes an {@link OrientedBoundingBox} for a subregion of the shape.\n *\n * @function\n *\n * @param {Cartesian3} chunkMinBounds The minimum bounds of the subregion.\n * @param {Cartesian3} chunkMaxBounds The maximum bounds of the subregion.\n * @param {Matrix4} matrix The matrix to transform the points.\n * @param {OrientedBoundingBox} result The object onto which to store the result.\n * @returns {OrientedBoundingBox} The oriented bounding box that contains this subregion.\n *\n * @private\n */\nfunction getCylinderChunkObb(chunkMinBounds, chunkMaxBounds, matrix, result) {\n  const radiusStart = chunkMinBounds.x;\n  const radiusEnd = chunkMaxBounds.x;\n  const angleStart = chunkMinBounds.y;\n  const angleEnd = chunkMaxBounds.y < angleStart ? chunkMaxBounds.y + CesiumMath.TWO_PI : chunkMaxBounds.y;\n  const heightStart = chunkMinBounds.z;\n  const heightEnd = chunkMaxBounds.z;\n  const angleRange = angleEnd - angleStart;\n  const angleMid = angleStart + angleRange * 0.5;\n  const testAngles = scratchTestAngles;\n  let testAngleCount = 0;\n  testAngles[testAngleCount++] = angleStart;\n  testAngles[testAngleCount++] = angleEnd;\n  testAngles[testAngleCount++] = angleMid;\n  if (angleRange > CesiumMath.PI) {\n    testAngles[testAngleCount++] = angleMid - CesiumMath.PI_OVER_TWO;\n    testAngles[testAngleCount++] = angleMid + CesiumMath.PI_OVER_TWO;\n  }\n\n  // Find bounding box in shape space relative to angleMid\n  let minX = Number.POSITIVE_INFINITY;\n  let minY = Number.POSITIVE_INFINITY;\n  let maxX = Number.NEGATIVE_INFINITY;\n  let maxY = Number.NEGATIVE_INFINITY;\n  for (let i = 0; i < testAngleCount; ++i) {\n    const angle = testAngles[i] - angleMid;\n    const cosAngle = Math.cos(angle);\n    const sinAngle = Math.sin(angle);\n    const x1 = cosAngle * radiusStart;\n    const y1 = sinAngle * radiusStart;\n    const x2 = cosAngle * radiusEnd;\n    const y2 = sinAngle * radiusEnd;\n    minX = Math.min(minX, x1, x2);\n    minY = Math.min(minY, y1, y2);\n    maxX = Math.max(maxX, x1, x2);\n    maxY = Math.max(maxY, y1, y2);\n  }\n  const extentX = maxX - minX;\n  const extentY = maxY - minY;\n  const extentZ = heightEnd - heightStart;\n  const centerX = (minX + maxX) * 0.5;\n  const centerY = (minY + maxY) * 0.5;\n  const centerZ = (heightStart + heightEnd) * 0.5;\n  const translation = Cartesian3.fromElements(centerX, centerY, centerZ, scratchTranslation);\n  const rotation = Matrix3.fromRotationZ(angleMid, scratchRotation);\n  const scale = Cartesian3.fromElements(extentX, extentY, extentZ, scratchBoxScale);\n  const scaleMatrix = Matrix4.fromScale(scale, scratchScaleMatrix);\n  const rotationMatrix = Matrix4.fromRotation(rotation, scratchRotationMatrix);\n  const translationMatrix = Matrix4.fromTranslation(translation, scratchTranslationMatrix);\n\n  // Shape space matrix = R * T * S\n  const localMatrix = Matrix4.multiplyTransformation(rotationMatrix, Matrix4.multiplyTransformation(translationMatrix, scaleMatrix, scratchMatrix), scratchMatrix);\n  const globalMatrix = Matrix4.multiplyTransformation(matrix, localMatrix, scratchMatrix);\n  if (!isValidOrientedBoundingBoxTransformation(globalMatrix)) {\n    return computeLooseOrientedBoundingBox(globalMatrix, result);\n  }\n  return OrientedBoundingBox.fromTransformation(globalMatrix, result);\n}\nexport default VoxelCylinderShape;","map":{"version":3,"names":["BoundingSphere","Cartesian2","Cartesian3","Cartesian4","CesiumMath","Check","ClippingPlane","Matrix3","Matrix4","OrientedBoundingBox","VoxelBoundsCollection","VoxelCylinderShape","_orientedBoundingBox","_boundingSphere","_boundTransform","_shapeTransform","_minBounds","DefaultMinBounds","clone","_maxBounds","DefaultMaxBounds","boundPlanes","negate","UNIT_Z","z","_renderBoundPlanes","planes","_shaderUniforms","cameraShapePosition","cylinderEcToRadialTangentUp","cylinderRenderRadiusMinMax","cylinderRenderAngleMinMax","cylinderLocalToShapeUvRadius","cylinderLocalToShapeUvAngle","cylinderLocalToShapeUvHeight","cylinderShapeUvAngleRangeOrigin","_shaderDefines","CYLINDER_HAS_SHAPE_BOUNDS_ANGLE","undefined","CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN","CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT","CYLINDER_HAS_RENDER_BOUNDS_ANGLE","CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO","CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF","CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF","CYLINDER_INTERSECTION_INDEX_RADIUS_MAX","CYLINDER_INTERSECTION_INDEX_RADIUS_MIN","CYLINDER_INTERSECTION_INDEX_ANGLE","_shaderMaximumIntersectionsLength","Object","defineProperties","prototype","orientedBoundingBox","get","renderBoundPlanes","boundingSphere","boundTransform","shapeTransform","shaderUniforms","shaderDefines","shaderMaximumIntersectionsLength","scratchScale","scratchClipMinBounds","scratchClipMaxBounds","scratchRenderMinBounds","scratchRenderMaxBounds","scratchTransformPositionWorldToLocal","scratchCameraPositionLocal","scratchCameraRadialPosition","update","modelMatrix","minBounds","maxBounds","clipMinBounds","clipMaxBounds","typeOf","object","defaultAngleRange","y","defaultAngleRangeHalf","epsilonZeroScale","EPSILON10","epsilonAngle","x","Math","max","negativePiToPi","renderMinBounds","maximumByComponent","renderMaxBounds","minimumByComponent","scale","getScale","equalsEpsilon","distance","getCylinderChunkObb","fromRotationTranslation","halfAxes","center","fromOrientedBoundingBox","shapeIsAngleReversed","shapeAngleRange","renderIsAngleReversed","renderAngleRange","renderIsAngleRegular","renderIsAngleFlipped","renderIsAngleRangeZero","renderHasAngle","key","hasOwnProperty","intersectionCount","fromElements","radiusRange","radialScale","radialOffset","heightRange","heightScale","heightOffset","uvMinAngle","uvMaxAngle","uvAngleRangeZero","uvAngleRangeOrigin","shiftedMinAngle","offset","floor","scratchRotateRtuToLocal","scratchRtuRotation","scratchTransformPositionViewToLocal","updateViewTransforms","frameState","transformPositionWorldToLocal","inverse","cameraPositionLocal","multiplyByPoint","camera","positionWC","magnitude","atan2","cameraRadialDirection","normalize","fromCartesian3","rotateLocalToRtu","fromRowMajorArray","transformPositionViewToWorld","context","uniformState","inverseView","transformPositionViewToLocal","multiplyTransformation","transformDirectionViewToLocal","getMatrix3","multiply","convertLocalToShapeUvSpace","positionLocal","result","radius","hypot","angle","height","PI","scratchMinBounds","scratchMaxBounds","computeOrientedBoundingBoxForTile","tileLevel","tileX","tileY","tileZ","number","sizeAtLevel","pow","tileMinBounds","lerp","tileMaxBounds","sampleSizeScratch","computeOrientedBoundingBoxForSample","spatialNode","tileDimensions","tileUv","tileSizeAtLevel","level","sampleSize","divideComponents","ONE","sampleSizeAtLevel","multiplyByScalar","minLerp","maxLerp","add","sampleMinBounds","sampleMaxBounds","freeze","maxTestAngles","scratchTestAngles","Array","scratchTranslation","scratchRotation","scratchTranslationMatrix","scratchRotationMatrix","scratchScaleMatrix","scratchMatrix","scratchColumn0","scratchColumn1","scratchColumn2","scratchCorners","i","orthogonal","a","b","epsilon","abs","dot","isValidOrientedBoundingBoxTransformation","matrix","column0","getColumn","column1","column2","EPSILON4","computeLooseOrientedBoundingBox","corners","fromPoints","scratchBoxScale","chunkMinBounds","chunkMaxBounds","radiusStart","radiusEnd","angleStart","angleEnd","TWO_PI","heightStart","heightEnd","angleRange","angleMid","testAngles","testAngleCount","PI_OVER_TWO","minX","Number","POSITIVE_INFINITY","minY","maxX","NEGATIVE_INFINITY","maxY","cosAngle","cos","sinAngle","sin","x1","y1","x2","y2","min","extentX","extentY","extentZ","centerX","centerY","centerZ","translation","rotation","fromRotationZ","scaleMatrix","fromScale","rotationMatrix","fromRotation","translationMatrix","fromTranslation","localMatrix","globalMatrix","fromTransformation"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/VoxelCylinderShape.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Check from \"../Core/Check.js\";\nimport ClippingPlane from \"./ClippingPlane.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport VoxelBoundsCollection from \"./VoxelBoundsCollection.js\";\n\n/**\n * A cylinder {@link VoxelShape}.\n *\n * @alias VoxelCylinderShape\n * @constructor\n *\n * @see VoxelShape\n * @see VoxelBoxShape\n * @see VoxelEllipsoidShape\n * @see VoxelShapeType\n *\n * @private\n */\nfunction VoxelCylinderShape() {\n  this._orientedBoundingBox = new OrientedBoundingBox();\n  this._boundingSphere = new BoundingSphere();\n  this._boundTransform = new Matrix4();\n  this._shapeTransform = new Matrix4();\n\n  /**\n   * The minimum bounds of the shape, corresponding to minimum radius, angle, and height.\n   * @type {Cartesian3}\n   * @private\n   */\n  this._minBounds = VoxelCylinderShape.DefaultMinBounds.clone();\n\n  /**\n   * The maximum bounds of the shape, corresponding to maximum radius, angle, and height.\n   * @type {Cartesian3}\n   * @private\n   */\n  this._maxBounds = VoxelCylinderShape.DefaultMaxBounds.clone();\n\n  const { DefaultMinBounds, DefaultMaxBounds } = VoxelCylinderShape;\n  const boundPlanes = [\n    new ClippingPlane(\n      Cartesian3.negate(Cartesian3.UNIT_Z, new Cartesian3()),\n      DefaultMinBounds.z,\n    ),\n    new ClippingPlane(Cartesian3.UNIT_Z, -DefaultMaxBounds.z),\n  ];\n\n  this._renderBoundPlanes = new VoxelBoundsCollection({ planes: boundPlanes });\n\n  this._shaderUniforms = {\n    cameraShapePosition: new Cartesian3(),\n    cylinderEcToRadialTangentUp: new Matrix3(),\n    cylinderRenderRadiusMinMax: new Cartesian2(),\n    cylinderRenderAngleMinMax: new Cartesian2(),\n    cylinderLocalToShapeUvRadius: new Cartesian2(),\n    cylinderLocalToShapeUvAngle: new Cartesian2(),\n    cylinderLocalToShapeUvHeight: new Cartesian2(),\n    cylinderShapeUvAngleRangeOrigin: 0.0,\n  };\n\n  this._shaderDefines = {\n    CYLINDER_HAS_SHAPE_BOUNDS_ANGLE: undefined,\n    CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN: undefined,\n    CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT: undefined,\n    CYLINDER_HAS_RENDER_BOUNDS_ANGLE: undefined,\n    CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO: undefined,\n    CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF: undefined,\n    CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF: undefined,\n    CYLINDER_INTERSECTION_INDEX_RADIUS_MAX: undefined,\n    CYLINDER_INTERSECTION_INDEX_RADIUS_MIN: undefined,\n    CYLINDER_INTERSECTION_INDEX_ANGLE: undefined,\n  };\n\n  this._shaderMaximumIntersectionsLength = 0; // not known until update\n}\n\nObject.defineProperties(VoxelCylinderShape.prototype, {\n  /**\n   * An oriented bounding box containing the bounded shape.\n   *\n   * @memberof VoxelCylinderShape.prototype\n   * @type {OrientedBoundingBox}\n   * @readonly\n   * @private\n   */\n  orientedBoundingBox: {\n    get: function () {\n      return this._orientedBoundingBox;\n    },\n  },\n\n  /**\n   * A collection of planes used for the render bounds\n   * @memberof VoxelCylinderShape.prototype\n   * @type {VoxelBoundsCollection}\n   * @readonly\n   * @private\n   */\n  renderBoundPlanes: {\n    get: function () {\n      return this._renderBoundPlanes;\n    },\n  },\n\n  /**\n   * A bounding sphere containing the bounded shape.\n   *\n   * @memberof VoxelCylinderShape.prototype\n   * @type {BoundingSphere}\n   * @readonly\n   * @private\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    },\n  },\n\n  /**\n   * A transformation matrix containing the bounded shape.\n   *\n   * @memberof VoxelCylinderShape.prototype\n   * @type {Matrix4}\n   * @readonly\n   * @private\n   */\n  boundTransform: {\n    get: function () {\n      return this._boundTransform;\n    },\n  },\n\n  /**\n   * A transformation matrix containing the shape, ignoring the bounds.\n   *\n   * @memberof VoxelCylinderShape.prototype\n   * @type {Matrix4}\n   * @readonly\n   * @private\n   */\n  shapeTransform: {\n    get: function () {\n      return this._shapeTransform;\n    },\n  },\n\n  /**\n   * @memberof VoxelCylinderShape.prototype\n   * @type {Object<string, any>}\n   * @readonly\n   * @private\n   */\n  shaderUniforms: {\n    get: function () {\n      return this._shaderUniforms;\n    },\n  },\n\n  /**\n   * @memberof VoxelCylinderShape.prototype\n   * @type {Object<string, any>}\n   * @readonly\n   * @private\n   */\n  shaderDefines: {\n    get: function () {\n      return this._shaderDefines;\n    },\n  },\n\n  /**\n   * The maximum number of intersections against the shape for any ray direction.\n   * @memberof VoxelCylinderShape.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  shaderMaximumIntersectionsLength: {\n    get: function () {\n      return this._shaderMaximumIntersectionsLength;\n    },\n  },\n});\n\nconst scratchScale = new Cartesian3();\nconst scratchClipMinBounds = new Cartesian3();\nconst scratchClipMaxBounds = new Cartesian3();\nconst scratchRenderMinBounds = new Cartesian3();\nconst scratchRenderMaxBounds = new Cartesian3();\nconst scratchTransformPositionWorldToLocal = new Matrix4();\nconst scratchCameraPositionLocal = new Cartesian3();\nconst scratchCameraRadialPosition = new Cartesian2();\n\n/**\n * Update the shape's state.\n * @private\n * @param {Matrix4} modelMatrix The model matrix.\n * @param {Cartesian3} minBounds The minimum bounds.\n * @param {Cartesian3} maxBounds The maximum bounds.\n * @param {Cartesian3} [clipMinBounds] The minimum clip bounds.\n * @param {Cartesian3} [clipMaxBounds] The maximum clip bounds.\n * @returns {boolean} Whether the shape is visible.\n */\nVoxelCylinderShape.prototype.update = function (\n  modelMatrix,\n  minBounds,\n  maxBounds,\n  clipMinBounds,\n  clipMaxBounds,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"modelMatrix\", modelMatrix);\n  Check.typeOf.object(\"minBounds\", minBounds);\n  Check.typeOf.object(\"maxBounds\", maxBounds);\n  //>>includeEnd('debug');\n\n  clipMinBounds = clipMinBounds ?? minBounds.clone(scratchClipMinBounds);\n  clipMaxBounds = clipMaxBounds ?? maxBounds.clone(scratchClipMaxBounds);\n\n  minBounds = Cartesian3.clone(minBounds, this._minBounds);\n  maxBounds = Cartesian3.clone(maxBounds, this._maxBounds);\n\n  const { DefaultMinBounds, DefaultMaxBounds } = VoxelCylinderShape;\n  const defaultAngleRange = DefaultMaxBounds.y - DefaultMinBounds.y; // == 2 * PI\n  const defaultAngleRangeHalf = 0.5 * defaultAngleRange; // == PI\n\n  const epsilonZeroScale = CesiumMath.EPSILON10;\n  const epsilonAngle = CesiumMath.EPSILON10;\n\n  // Clamp the bounds to the valid range\n  minBounds.x = Math.max(0.0, minBounds.x);\n  // TODO: require maxBounds.x >= minBounds.x ?\n  maxBounds.x = Math.max(0.0, maxBounds.x);\n  minBounds.y = CesiumMath.negativePiToPi(minBounds.y);\n  maxBounds.y = CesiumMath.negativePiToPi(maxBounds.y);\n\n  clipMinBounds.y = CesiumMath.negativePiToPi(clipMinBounds.y);\n  clipMaxBounds.y = CesiumMath.negativePiToPi(clipMaxBounds.y);\n\n  // TODO: what does this do with partial volumes crossing the antimeridian?\n  // We could have minBounds.y = +PI/2 and maxBounds.y = -PI/2.\n  // Then clipMinBounds.y = +PI/4 and clipMaxBounds.y = -PI/4.\n  // This maximumByComponent would cancel the clipping.\n  const renderMinBounds = Cartesian3.maximumByComponent(\n    minBounds,\n    clipMinBounds,\n    scratchRenderMinBounds,\n  );\n  const renderMaxBounds = Cartesian3.minimumByComponent(\n    maxBounds,\n    clipMaxBounds,\n    scratchRenderMaxBounds,\n  );\n\n  // Exit early if the shape is not visible.\n  // Note that minAngle may be greater than maxAngle when crossing the 180th meridian.\n\n  // Cylinder is not visible if:\n  // - maxRadius is zero (line)\n  // - minRadius is greater than maxRadius\n  // - minHeight is greater than maxHeight\n  // - scale is 0 for any component (too annoying to reconstruct rotation matrix)\n  const scale = Matrix4.getScale(modelMatrix, scratchScale);\n  if (\n    renderMaxBounds.x === 0.0 ||\n    renderMinBounds.x > renderMaxBounds.x ||\n    renderMinBounds.z > renderMaxBounds.z ||\n    CesiumMath.equalsEpsilon(scale.x, 0.0, undefined, epsilonZeroScale) ||\n    CesiumMath.equalsEpsilon(scale.y, 0.0, undefined, epsilonZeroScale) ||\n    CesiumMath.equalsEpsilon(scale.z, 0.0, undefined, epsilonZeroScale)\n  ) {\n    return false;\n  }\n\n  // Update the render bounds planes\n  const renderBoundPlanes = this._renderBoundPlanes;\n  renderBoundPlanes.get(0).distance = renderMinBounds.z;\n  renderBoundPlanes.get(1).distance = -renderMaxBounds.z;\n\n  this._shapeTransform = Matrix4.clone(modelMatrix, this._shapeTransform);\n\n  this._orientedBoundingBox = getCylinderChunkObb(\n    renderMinBounds,\n    renderMaxBounds,\n    this._shapeTransform,\n    this._orientedBoundingBox,\n  );\n\n  this._boundTransform = Matrix4.fromRotationTranslation(\n    this._orientedBoundingBox.halfAxes,\n    this._orientedBoundingBox.center,\n    this._boundTransform,\n  );\n\n  this._boundingSphere = BoundingSphere.fromOrientedBoundingBox(\n    this._orientedBoundingBox,\n    this._boundingSphere,\n  );\n\n  const shapeIsAngleReversed = maxBounds.y < minBounds.y;\n  const shapeAngleRange =\n    maxBounds.y - minBounds.y + shapeIsAngleReversed * defaultAngleRange;\n\n  const renderIsAngleReversed = renderMaxBounds.y < renderMinBounds.y;\n  const renderAngleRange =\n    renderMaxBounds.y -\n    renderMinBounds.y +\n    renderIsAngleReversed * defaultAngleRange;\n  const renderIsAngleRegular =\n    renderAngleRange >= defaultAngleRangeHalf - epsilonAngle &&\n    renderAngleRange < defaultAngleRange - epsilonAngle;\n  const renderIsAngleFlipped =\n    renderAngleRange > epsilonAngle &&\n    renderAngleRange < defaultAngleRangeHalf - epsilonAngle;\n  const renderIsAngleRangeZero = renderAngleRange <= epsilonAngle;\n  const renderHasAngle =\n    renderIsAngleRegular || renderIsAngleFlipped || renderIsAngleRangeZero;\n\n  const shaderUniforms = this._shaderUniforms;\n  const shaderDefines = this._shaderDefines;\n\n  // To keep things simple, clear the defines every time\n  for (const key in shaderDefines) {\n    if (shaderDefines.hasOwnProperty(key)) {\n      shaderDefines[key] = undefined;\n    }\n  }\n\n  // Keep track of how many intersections there are going to be.\n  let intersectionCount = 0;\n\n  shaderDefines[\"CYLINDER_INTERSECTION_INDEX_RADIUS_MAX\"] = intersectionCount;\n  intersectionCount += 1;\n\n  if (shapeAngleRange < defaultAngleRange - epsilonAngle) {\n    shaderDefines[\"CYLINDER_HAS_SHAPE_BOUNDS_ANGLE\"] = true;\n  }\n\n  if (renderMinBounds.x !== DefaultMinBounds.x) {\n    shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN\"] = true;\n    shaderDefines[\"CYLINDER_INTERSECTION_INDEX_RADIUS_MIN\"] = intersectionCount;\n    intersectionCount += 1;\n  }\n  shaderUniforms.cylinderRenderRadiusMinMax = Cartesian2.fromElements(\n    renderMinBounds.x,\n    renderMaxBounds.x,\n    shaderUniforms.cylinderRenderRadiusMinMax,\n  );\n\n  if (renderMinBounds.x === renderMaxBounds.x) {\n    shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT\"] = true;\n  }\n\n  const radiusRange = maxBounds.x - minBounds.x;\n  let radialScale = 0.0;\n  let radialOffset = 1.0;\n  if (radiusRange !== 0.0) {\n    radialScale = 1.0 / radiusRange;\n    radialOffset = -minBounds.x * radialScale;\n  }\n  shaderUniforms.cylinderLocalToShapeUvRadius = Cartesian2.fromElements(\n    radialScale,\n    radialOffset,\n    shaderUniforms.cylinderLocalToShapeUvRadius,\n  );\n\n  const heightRange = maxBounds.z - minBounds.z; // Default 2.0\n  let heightScale = 0.0;\n  let heightOffset = 1.0;\n  if (heightRange !== 0.0) {\n    heightScale = 1.0 / heightRange;\n    heightOffset = -minBounds.z * heightScale;\n  }\n  shaderUniforms.cylinderLocalToShapeUvHeight = Cartesian2.fromElements(\n    heightScale,\n    heightOffset,\n    shaderUniforms.cylinderLocalToShapeUvHeight,\n  );\n\n  if (renderHasAngle) {\n    shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_ANGLE\"] = true;\n    shaderDefines[\"CYLINDER_INTERSECTION_INDEX_ANGLE\"] = intersectionCount;\n\n    if (renderIsAngleRegular) {\n      shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF\"] = true;\n      intersectionCount += 1;\n    } else if (renderIsAngleFlipped) {\n      shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF\"] = true;\n      intersectionCount += 2;\n    } else if (renderIsAngleRangeZero) {\n      shaderDefines[\"CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO\"] = true;\n      intersectionCount += 2;\n    }\n\n    shaderUniforms.cylinderRenderAngleMinMax = Cartesian2.fromElements(\n      renderMinBounds.y,\n      renderMaxBounds.y,\n      shaderUniforms.cylinderRenderAngleMinMax,\n    );\n  }\n\n  const uvMinAngle = (minBounds.y - DefaultMinBounds.y) / defaultAngleRange;\n  const uvMaxAngle = (maxBounds.y - DefaultMinBounds.y) / defaultAngleRange;\n  const uvAngleRangeZero = 1.0 - shapeAngleRange / defaultAngleRange;\n\n  // Translate the origin of UV angles (in [0,1]) to the center of the unoccupied space\n  const uvAngleRangeOrigin = (uvMaxAngle + 0.5 * uvAngleRangeZero) % 1.0;\n  shaderUniforms.cylinderShapeUvAngleRangeOrigin = uvAngleRangeOrigin;\n\n  if (shapeAngleRange <= epsilonAngle) {\n    shaderUniforms.cylinderLocalToShapeUvAngle = Cartesian2.fromElements(\n      0.0,\n      1.0,\n      shaderUniforms.cylinderLocalToShapeUvAngle,\n    );\n  } else {\n    const scale = defaultAngleRange / shapeAngleRange;\n    const shiftedMinAngle = uvMinAngle - uvAngleRangeOrigin;\n    const offset = -scale * (shiftedMinAngle - Math.floor(shiftedMinAngle));\n    shaderUniforms.cylinderLocalToShapeUvAngle = Cartesian2.fromElements(\n      scale,\n      offset,\n      shaderUniforms.cylinderLocalToShapeUvAngle,\n    );\n  }\n\n  this._shaderMaximumIntersectionsLength = intersectionCount;\n\n  return true;\n};\n\nconst scratchRotateRtuToLocal = new Matrix3();\nconst scratchRtuRotation = new Matrix3();\nconst scratchTransformPositionViewToLocal = new Matrix4();\n\n/**\n * Update any view-dependent transforms.\n * @private\n * @param {FrameState} frameState The frame state.\n */\nVoxelCylinderShape.prototype.updateViewTransforms = function (frameState) {\n  const shaderUniforms = this._shaderUniforms;\n  // 1. Update camera position in cylindrical coordinates\n  const transformPositionWorldToLocal = Matrix4.inverse(\n    this._shapeTransform,\n    scratchTransformPositionWorldToLocal,\n  );\n  const cameraPositionLocal = Matrix4.multiplyByPoint(\n    transformPositionWorldToLocal,\n    frameState.camera.positionWC,\n    scratchCameraPositionLocal,\n  );\n  shaderUniforms.cameraShapePosition = Cartesian3.fromElements(\n    Cartesian2.magnitude(cameraPositionLocal),\n    Math.atan2(cameraPositionLocal.y, cameraPositionLocal.x),\n    cameraPositionLocal.z,\n    shaderUniforms.cameraShapePosition,\n  );\n  // 2. Find radial, tangent, and up components at camera position\n  const cameraRadialDirection = Cartesian2.normalize(\n    Cartesian2.fromCartesian3(cameraPositionLocal, scratchCameraRadialPosition),\n    scratchCameraRadialPosition,\n  );\n  // As row vectors, the radial, tangent, and up vectors constitute a rotation matrix from local to RTU.\n  const rotateLocalToRtu = Matrix3.fromRowMajorArray(\n    [\n      cameraRadialDirection.x,\n      cameraRadialDirection.y,\n      0.0,\n      -cameraRadialDirection.y,\n      cameraRadialDirection.x,\n      0.0,\n      0.0,\n      0.0,\n      1.0,\n    ],\n    scratchRotateRtuToLocal,\n  );\n  // 3. Get rotation from eye to local coordinates\n  const transformPositionViewToWorld =\n    frameState.context.uniformState.inverseView;\n  const transformPositionViewToLocal = Matrix4.multiplyTransformation(\n    transformPositionWorldToLocal,\n    transformPositionViewToWorld,\n    scratchTransformPositionViewToLocal,\n  );\n  const transformDirectionViewToLocal = Matrix4.getMatrix3(\n    transformPositionViewToLocal,\n    scratchRtuRotation,\n  );\n  // 4. Multiply to get rotation from eye to RTU coordinates\n  shaderUniforms.cylinderEcToRadialTangentUp = Matrix3.multiply(\n    rotateLocalToRtu,\n    transformDirectionViewToLocal,\n    shaderUniforms.cylinderEcToRadialTangentUp,\n  );\n};\n\n/**\n * Convert a UV coordinate to the shape's UV space.\n * @private\n * @param {Cartesian3} positionLocal The local coordinate to convert.\n * @param {Cartesian3} result The Cartesian3 to store the result in.\n * @returns {Cartesian3} The converted UV coordinate.\n */\nVoxelCylinderShape.prototype.convertLocalToShapeUvSpace = function (\n  positionLocal,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"positionLocal\", positionLocal);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  let radius = Math.hypot(positionLocal.x, positionLocal.y);\n  let angle = Math.atan2(positionLocal.y, positionLocal.x);\n  let height = positionLocal.z;\n\n  const {\n    cylinderLocalToShapeUvRadius,\n    cylinderLocalToShapeUvAngle,\n    cylinderShapeUvAngleRangeOrigin,\n    cylinderLocalToShapeUvHeight,\n  } = this._shaderUniforms;\n\n  radius =\n    radius * cylinderLocalToShapeUvRadius.x + cylinderLocalToShapeUvRadius.y;\n\n  // Convert angle to a \"UV\" in [0,1] with 0 defined at the center of the unoccupied space.\n  angle = (angle + Math.PI) / (2.0 * Math.PI);\n  angle -= cylinderShapeUvAngleRangeOrigin;\n  angle = angle - Math.floor(angle);\n  // Scale and shift so [0,1] covers the occupied space.\n  angle = angle * cylinderLocalToShapeUvAngle.x + cylinderLocalToShapeUvAngle.y;\n\n  height =\n    height * cylinderLocalToShapeUvHeight.x + cylinderLocalToShapeUvHeight.y;\n\n  return Cartesian3.fromElements(radius, angle, height, result);\n};\n\nconst scratchMinBounds = new Cartesian3();\nconst scratchMaxBounds = new Cartesian3();\n\n/**\n * Computes an oriented bounding box for a specified tile.\n * @private\n * @param {number} tileLevel The tile's level.\n * @param {number} tileX The tile's x coordinate.\n * @param {number} tileY The tile's y coordinate.\n * @param {number} tileZ The tile's z coordinate.\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified tile\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelCylinderShape.prototype.computeOrientedBoundingBoxForTile = function (\n  tileLevel,\n  tileX,\n  tileY,\n  tileZ,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"tileLevel\", tileLevel);\n  Check.typeOf.number(\"tileX\", tileX);\n  Check.typeOf.number(\"tileY\", tileY);\n  Check.typeOf.number(\"tileZ\", tileZ);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const minBounds = this._minBounds;\n  const maxBounds = this._maxBounds;\n\n  const sizeAtLevel = 1.0 / Math.pow(2.0, tileLevel);\n\n  const tileMinBounds = Cartesian3.fromElements(\n    CesiumMath.lerp(minBounds.x, maxBounds.x, tileX * sizeAtLevel),\n    CesiumMath.lerp(minBounds.y, maxBounds.y, tileY * sizeAtLevel),\n    CesiumMath.lerp(minBounds.z, maxBounds.z, tileZ * sizeAtLevel),\n    scratchMinBounds,\n  );\n  const tileMaxBounds = Cartesian3.fromElements(\n    CesiumMath.lerp(minBounds.x, maxBounds.x, (tileX + 1) * sizeAtLevel),\n    CesiumMath.lerp(minBounds.y, maxBounds.y, (tileY + 1) * sizeAtLevel),\n    CesiumMath.lerp(minBounds.z, maxBounds.z, (tileZ + 1) * sizeAtLevel),\n    scratchMaxBounds,\n  );\n\n  return getCylinderChunkObb(\n    tileMinBounds,\n    tileMaxBounds,\n    this._shapeTransform,\n    result,\n  );\n};\n\nconst sampleSizeScratch = new Cartesian3();\n\n/**\n * Computes an oriented bounding box for a specified sample within a specified tile.\n * @private\n * @param {SpatialNode} spatialNode The spatial node containing the sample\n * @param {Cartesian3} tileDimensions The size of the tile in number of samples, before padding\n * @param {Cartesian3} tileUv The sample coordinate within the tile\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified sample\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelCylinderShape.prototype.computeOrientedBoundingBoxForSample = function (\n  spatialNode,\n  tileDimensions,\n  tileUv,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"spatialNode\", spatialNode);\n  Check.typeOf.object(\"tileDimensions\", tileDimensions);\n  Check.typeOf.object(\"tileUv\", tileUv);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const tileSizeAtLevel = 1.0 / Math.pow(2.0, spatialNode.level);\n  const sampleSize = Cartesian3.divideComponents(\n    Cartesian3.ONE,\n    tileDimensions,\n    sampleSizeScratch,\n  );\n  const sampleSizeAtLevel = Cartesian3.multiplyByScalar(\n    sampleSize,\n    tileSizeAtLevel,\n    sampleSizeScratch,\n  );\n\n  const minLerp = Cartesian3.multiplyByScalar(\n    Cartesian3.fromElements(\n      spatialNode.x + tileUv.x,\n      spatialNode.y + tileUv.y,\n      spatialNode.z + tileUv.z,\n      scratchMinBounds,\n    ),\n    tileSizeAtLevel,\n    scratchMinBounds,\n  );\n  const maxLerp = Cartesian3.add(minLerp, sampleSizeAtLevel, scratchMaxBounds);\n\n  const minBounds = this._minBounds;\n  const maxBounds = this._maxBounds;\n\n  const sampleMinBounds = Cartesian3.fromElements(\n    CesiumMath.lerp(minBounds.x, maxBounds.x, minLerp.x),\n    CesiumMath.lerp(minBounds.y, maxBounds.y, minLerp.y),\n    CesiumMath.lerp(minBounds.z, maxBounds.z, minLerp.z),\n    scratchMinBounds,\n  );\n  const sampleMaxBounds = Cartesian3.fromElements(\n    CesiumMath.lerp(minBounds.x, maxBounds.x, maxLerp.x),\n    CesiumMath.lerp(minBounds.y, maxBounds.y, maxLerp.y),\n    CesiumMath.lerp(minBounds.z, maxBounds.z, maxLerp.z),\n    scratchMaxBounds,\n  );\n\n  return getCylinderChunkObb(\n    sampleMinBounds,\n    sampleMaxBounds,\n    this._shapeTransform,\n    result,\n  );\n};\n\n/**\n * Defines the minimum bounds of the shape. Corresponds to minimum radius, angle, and height.\n *\n * @type {Cartesian3}\n * @constant\n * @readonly\n *\n * @private\n */\nVoxelCylinderShape.DefaultMinBounds = Object.freeze(\n  new Cartesian3(0.0, -CesiumMath.PI, -1.0),\n);\n\n/**\n * Defines the maximum bounds of the shape. Corresponds to maximum radius, angle, height.\n *\n * @type {Cartesian3}\n * @constant\n * @readonly\n *\n * @private\n */\nVoxelCylinderShape.DefaultMaxBounds = Object.freeze(\n  new Cartesian3(1.0, +CesiumMath.PI, +1.0),\n);\n\nconst maxTestAngles = 5;\nconst scratchTestAngles = new Array(maxTestAngles);\nconst scratchTranslation = new Cartesian3();\nconst scratchRotation = new Matrix3();\nconst scratchTranslationMatrix = new Matrix4();\nconst scratchRotationMatrix = new Matrix4();\nconst scratchScaleMatrix = new Matrix4();\nconst scratchMatrix = new Matrix4();\nconst scratchColumn0 = new Cartesian3();\nconst scratchColumn1 = new Cartesian3();\nconst scratchColumn2 = new Cartesian3();\nconst scratchCorners = new Array(8);\nfor (let i = 0; i < 8; i++) {\n  scratchCorners[i] = new Cartesian3();\n}\n\nfunction orthogonal(a, b, epsilon) {\n  return Math.abs(Cartesian4.dot(a, b)) < epsilon;\n}\n\nfunction isValidOrientedBoundingBoxTransformation(matrix) {\n  const column0 = Matrix4.getColumn(matrix, 0, scratchColumn0);\n  const column1 = Matrix4.getColumn(matrix, 1, scratchColumn1);\n  const column2 = Matrix4.getColumn(matrix, 2, scratchColumn2);\n\n  const epsilon = CesiumMath.EPSILON4;\n\n  return (\n    orthogonal(column0, column1, epsilon) &&\n    orthogonal(column1, column2, epsilon)\n  );\n}\n\nfunction computeLooseOrientedBoundingBox(matrix, result) {\n  const corners = scratchCorners;\n  Cartesian3.fromElements(-0.5, -0.5, -0.5, corners[0]);\n  Cartesian3.fromElements(-0.5, -0.5, 0.5, corners[1]);\n  Cartesian3.fromElements(-0.5, 0.5, -0.5, corners[2]);\n  Cartesian3.fromElements(-0.5, 0.5, 0.5, corners[3]);\n  Cartesian3.fromElements(0.5, -0.5, -0.5, corners[4]);\n  Cartesian3.fromElements(0.5, -0.5, 0.5, corners[5]);\n  Cartesian3.fromElements(0.5, 0.5, -0.5, corners[6]);\n  Cartesian3.fromElements(0.5, 0.5, 0.5, corners[7]);\n\n  for (let i = 0; i < 8; ++i) {\n    Matrix4.multiplyByPoint(matrix, corners[i], corners[i]);\n  }\n\n  return OrientedBoundingBox.fromPoints(corners, result);\n}\n\nconst scratchBoxScale = new Cartesian3();\n/**\n * Computes an {@link OrientedBoundingBox} for a subregion of the shape.\n *\n * @function\n *\n * @param {Cartesian3} chunkMinBounds The minimum bounds of the subregion.\n * @param {Cartesian3} chunkMaxBounds The maximum bounds of the subregion.\n * @param {Matrix4} matrix The matrix to transform the points.\n * @param {OrientedBoundingBox} result The object onto which to store the result.\n * @returns {OrientedBoundingBox} The oriented bounding box that contains this subregion.\n *\n * @private\n */\nfunction getCylinderChunkObb(chunkMinBounds, chunkMaxBounds, matrix, result) {\n  const radiusStart = chunkMinBounds.x;\n  const radiusEnd = chunkMaxBounds.x;\n  const angleStart = chunkMinBounds.y;\n  const angleEnd =\n    chunkMaxBounds.y < angleStart\n      ? chunkMaxBounds.y + CesiumMath.TWO_PI\n      : chunkMaxBounds.y;\n  const heightStart = chunkMinBounds.z;\n  const heightEnd = chunkMaxBounds.z;\n\n  const angleRange = angleEnd - angleStart;\n  const angleMid = angleStart + angleRange * 0.5;\n\n  const testAngles = scratchTestAngles;\n  let testAngleCount = 0;\n\n  testAngles[testAngleCount++] = angleStart;\n  testAngles[testAngleCount++] = angleEnd;\n  testAngles[testAngleCount++] = angleMid;\n\n  if (angleRange > CesiumMath.PI) {\n    testAngles[testAngleCount++] = angleMid - CesiumMath.PI_OVER_TWO;\n    testAngles[testAngleCount++] = angleMid + CesiumMath.PI_OVER_TWO;\n  }\n\n  // Find bounding box in shape space relative to angleMid\n  let minX = Number.POSITIVE_INFINITY;\n  let minY = Number.POSITIVE_INFINITY;\n  let maxX = Number.NEGATIVE_INFINITY;\n  let maxY = Number.NEGATIVE_INFINITY;\n\n  for (let i = 0; i < testAngleCount; ++i) {\n    const angle = testAngles[i] - angleMid;\n    const cosAngle = Math.cos(angle);\n    const sinAngle = Math.sin(angle);\n    const x1 = cosAngle * radiusStart;\n    const y1 = sinAngle * radiusStart;\n    const x2 = cosAngle * radiusEnd;\n    const y2 = sinAngle * radiusEnd;\n\n    minX = Math.min(minX, x1, x2);\n    minY = Math.min(minY, y1, y2);\n    maxX = Math.max(maxX, x1, x2);\n    maxY = Math.max(maxY, y1, y2);\n  }\n\n  const extentX = maxX - minX;\n  const extentY = maxY - minY;\n  const extentZ = heightEnd - heightStart;\n\n  const centerX = (minX + maxX) * 0.5;\n  const centerY = (minY + maxY) * 0.5;\n  const centerZ = (heightStart + heightEnd) * 0.5;\n\n  const translation = Cartesian3.fromElements(\n    centerX,\n    centerY,\n    centerZ,\n    scratchTranslation,\n  );\n\n  const rotation = Matrix3.fromRotationZ(angleMid, scratchRotation);\n\n  const scale = Cartesian3.fromElements(\n    extentX,\n    extentY,\n    extentZ,\n    scratchBoxScale,\n  );\n\n  const scaleMatrix = Matrix4.fromScale(scale, scratchScaleMatrix);\n  const rotationMatrix = Matrix4.fromRotation(rotation, scratchRotationMatrix);\n  const translationMatrix = Matrix4.fromTranslation(\n    translation,\n    scratchTranslationMatrix,\n  );\n\n  // Shape space matrix = R * T * S\n  const localMatrix = Matrix4.multiplyTransformation(\n    rotationMatrix,\n    Matrix4.multiplyTransformation(\n      translationMatrix,\n      scaleMatrix,\n      scratchMatrix,\n    ),\n    scratchMatrix,\n  );\n\n  const globalMatrix = Matrix4.multiplyTransformation(\n    matrix,\n    localMatrix,\n    scratchMatrix,\n  );\n\n  if (!isValidOrientedBoundingBoxTransformation(globalMatrix)) {\n    return computeLooseOrientedBoundingBox(globalMatrix, result);\n  }\n\n  return OrientedBoundingBox.fromTransformation(globalMatrix, result);\n}\n\nexport default VoxelCylinderShape;\n"],"mappings":"AAAA,OAAOA,cAAc,MAAM,2BAA2B;AACtD,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,aAAa,MAAM,oBAAoB;AAC9C,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,mBAAmB,MAAM,gCAAgC;AAChE,OAAOC,qBAAqB,MAAM,4BAA4B;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,kBAAkBA,CAAA,EAAG;EAC5B,IAAI,CAACC,oBAAoB,GAAG,IAAIH,mBAAmB,CAAC,CAAC;EACrD,IAAI,CAACI,eAAe,GAAG,IAAIb,cAAc,CAAC,CAAC;EAC3C,IAAI,CAACc,eAAe,GAAG,IAAIN,OAAO,CAAC,CAAC;EACpC,IAAI,CAACO,eAAe,GAAG,IAAIP,OAAO,CAAC,CAAC;;EAEpC;AACF;AACA;AACA;AACA;EACE,IAAI,CAACQ,UAAU,GAAGL,kBAAkB,CAACM,gBAAgB,CAACC,KAAK,CAAC,CAAC;;EAE7D;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAGR,kBAAkB,CAACS,gBAAgB,CAACF,KAAK,CAAC,CAAC;EAE7D,MAAM;IAAED,gBAAgB;IAAEG;EAAiB,CAAC,GAAGT,kBAAkB;EACjE,MAAMU,WAAW,GAAG,CAClB,IAAIf,aAAa,CACfJ,UAAU,CAACoB,MAAM,CAACpB,UAAU,CAACqB,MAAM,EAAE,IAAIrB,UAAU,CAAC,CAAC,CAAC,EACtDe,gBAAgB,CAACO,CACnB,CAAC,EACD,IAAIlB,aAAa,CAACJ,UAAU,CAACqB,MAAM,EAAE,CAACH,gBAAgB,CAACI,CAAC,CAAC,CAC1D;EAED,IAAI,CAACC,kBAAkB,GAAG,IAAIf,qBAAqB,CAAC;IAAEgB,MAAM,EAAEL;EAAY,CAAC,CAAC;EAE5E,IAAI,CAACM,eAAe,GAAG;IACrBC,mBAAmB,EAAE,IAAI1B,UAAU,CAAC,CAAC;IACrC2B,2BAA2B,EAAE,IAAItB,OAAO,CAAC,CAAC;IAC1CuB,0BAA0B,EAAE,IAAI7B,UAAU,CAAC,CAAC;IAC5C8B,yBAAyB,EAAE,IAAI9B,UAAU,CAAC,CAAC;IAC3C+B,4BAA4B,EAAE,IAAI/B,UAAU,CAAC,CAAC;IAC9CgC,2BAA2B,EAAE,IAAIhC,UAAU,CAAC,CAAC;IAC7CiC,4BAA4B,EAAE,IAAIjC,UAAU,CAAC,CAAC;IAC9CkC,+BAA+B,EAAE;EACnC,CAAC;EAED,IAAI,CAACC,cAAc,GAAG;IACpBC,+BAA+B,EAAEC,SAAS;IAC1CC,qCAAqC,EAAED,SAAS;IAChDE,sCAAsC,EAAEF,SAAS;IACjDG,gCAAgC,EAAEH,SAAS;IAC3CI,iDAAiD,EAAEJ,SAAS;IAC5DK,iDAAiD,EAAEL,SAAS;IAC5DM,gDAAgD,EAAEN,SAAS;IAC3DO,sCAAsC,EAAEP,SAAS;IACjDQ,sCAAsC,EAAER,SAAS;IACjDS,iCAAiC,EAAET;EACrC,CAAC;EAED,IAAI,CAACU,iCAAiC,GAAG,CAAC,CAAC,CAAC;AAC9C;AAEAC,MAAM,CAACC,gBAAgB,CAACvC,kBAAkB,CAACwC,SAAS,EAAE;EACpD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,mBAAmB,EAAE;IACnBC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACzC,oBAAoB;IAClC;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACE0C,iBAAiB,EAAE;IACjBD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC5B,kBAAkB;IAChC;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE8B,cAAc,EAAE;IACdF,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACxC,eAAe;IAC7B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE2C,cAAc,EAAE;IACdH,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACvC,eAAe;IAC7B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE2C,cAAc,EAAE;IACdJ,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACtC,eAAe;IAC7B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACE2C,cAAc,EAAE;IACdL,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC1B,eAAe;IAC7B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACEgC,aAAa,EAAE;IACbN,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACjB,cAAc;IAC5B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEwB,gCAAgC,EAAE;IAChCP,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACL,iCAAiC;IAC/C;EACF;AACF,CAAC,CAAC;AAEF,MAAMa,YAAY,GAAG,IAAI3D,UAAU,CAAC,CAAC;AACrC,MAAM4D,oBAAoB,GAAG,IAAI5D,UAAU,CAAC,CAAC;AAC7C,MAAM6D,oBAAoB,GAAG,IAAI7D,UAAU,CAAC,CAAC;AAC7C,MAAM8D,sBAAsB,GAAG,IAAI9D,UAAU,CAAC,CAAC;AAC/C,MAAM+D,sBAAsB,GAAG,IAAI/D,UAAU,CAAC,CAAC;AAC/C,MAAMgE,oCAAoC,GAAG,IAAI1D,OAAO,CAAC,CAAC;AAC1D,MAAM2D,0BAA0B,GAAG,IAAIjE,UAAU,CAAC,CAAC;AACnD,MAAMkE,2BAA2B,GAAG,IAAInE,UAAU,CAAC,CAAC;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAU,kBAAkB,CAACwC,SAAS,CAACkB,MAAM,GAAG,UACpCC,WAAW,EACXC,SAAS,EACTC,SAAS,EACTC,aAAa,EACbC,aAAa,EACb;EACA;EACArE,KAAK,CAACsE,MAAM,CAACC,MAAM,CAAC,aAAa,EAAEN,WAAW,CAAC;EAC/CjE,KAAK,CAACsE,MAAM,CAACC,MAAM,CAAC,WAAW,EAAEL,SAAS,CAAC;EAC3ClE,KAAK,CAACsE,MAAM,CAACC,MAAM,CAAC,WAAW,EAAEJ,SAAS,CAAC;EAC3C;;EAEAC,aAAa,GAAGA,aAAa,IAAIF,SAAS,CAACrD,KAAK,CAAC4C,oBAAoB,CAAC;EACtEY,aAAa,GAAGA,aAAa,IAAIF,SAAS,CAACtD,KAAK,CAAC6C,oBAAoB,CAAC;EAEtEQ,SAAS,GAAGrE,UAAU,CAACgB,KAAK,CAACqD,SAAS,EAAE,IAAI,CAACvD,UAAU,CAAC;EACxDwD,SAAS,GAAGtE,UAAU,CAACgB,KAAK,CAACsD,SAAS,EAAE,IAAI,CAACrD,UAAU,CAAC;EAExD,MAAM;IAAEF,gBAAgB;IAAEG;EAAiB,CAAC,GAAGT,kBAAkB;EACjE,MAAMkE,iBAAiB,GAAGzD,gBAAgB,CAAC0D,CAAC,GAAG7D,gBAAgB,CAAC6D,CAAC,CAAC,CAAC;EACnE,MAAMC,qBAAqB,GAAG,GAAG,GAAGF,iBAAiB,CAAC,CAAC;;EAEvD,MAAMG,gBAAgB,GAAG5E,UAAU,CAAC6E,SAAS;EAC7C,MAAMC,YAAY,GAAG9E,UAAU,CAAC6E,SAAS;;EAEzC;EACAV,SAAS,CAACY,CAAC,GAAGC,IAAI,CAACC,GAAG,CAAC,GAAG,EAAEd,SAAS,CAACY,CAAC,CAAC;EACxC;EACAX,SAAS,CAACW,CAAC,GAAGC,IAAI,CAACC,GAAG,CAAC,GAAG,EAAEb,SAAS,CAACW,CAAC,CAAC;EACxCZ,SAAS,CAACO,CAAC,GAAG1E,UAAU,CAACkF,cAAc,CAACf,SAAS,CAACO,CAAC,CAAC;EACpDN,SAAS,CAACM,CAAC,GAAG1E,UAAU,CAACkF,cAAc,CAACd,SAAS,CAACM,CAAC,CAAC;EAEpDL,aAAa,CAACK,CAAC,GAAG1E,UAAU,CAACkF,cAAc,CAACb,aAAa,CAACK,CAAC,CAAC;EAC5DJ,aAAa,CAACI,CAAC,GAAG1E,UAAU,CAACkF,cAAc,CAACZ,aAAa,CAACI,CAAC,CAAC;;EAE5D;EACA;EACA;EACA;EACA,MAAMS,eAAe,GAAGrF,UAAU,CAACsF,kBAAkB,CACnDjB,SAAS,EACTE,aAAa,EACbT,sBACF,CAAC;EACD,MAAMyB,eAAe,GAAGvF,UAAU,CAACwF,kBAAkB,CACnDlB,SAAS,EACTE,aAAa,EACbT,sBACF,CAAC;;EAED;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA,MAAM0B,KAAK,GAAGnF,OAAO,CAACoF,QAAQ,CAACtB,WAAW,EAAET,YAAY,CAAC;EACzD,IACE4B,eAAe,CAACN,CAAC,KAAK,GAAG,IACzBI,eAAe,CAACJ,CAAC,GAAGM,eAAe,CAACN,CAAC,IACrCI,eAAe,CAAC/D,CAAC,GAAGiE,eAAe,CAACjE,CAAC,IACrCpB,UAAU,CAACyF,aAAa,CAACF,KAAK,CAACR,CAAC,EAAE,GAAG,EAAE7C,SAAS,EAAE0C,gBAAgB,CAAC,IACnE5E,UAAU,CAACyF,aAAa,CAACF,KAAK,CAACb,CAAC,EAAE,GAAG,EAAExC,SAAS,EAAE0C,gBAAgB,CAAC,IACnE5E,UAAU,CAACyF,aAAa,CAACF,KAAK,CAACnE,CAAC,EAAE,GAAG,EAAEc,SAAS,EAAE0C,gBAAgB,CAAC,EACnE;IACA,OAAO,KAAK;EACd;;EAEA;EACA,MAAM1B,iBAAiB,GAAG,IAAI,CAAC7B,kBAAkB;EACjD6B,iBAAiB,CAACD,GAAG,CAAC,CAAC,CAAC,CAACyC,QAAQ,GAAGP,eAAe,CAAC/D,CAAC;EACrD8B,iBAAiB,CAACD,GAAG,CAAC,CAAC,CAAC,CAACyC,QAAQ,GAAG,CAACL,eAAe,CAACjE,CAAC;EAEtD,IAAI,CAACT,eAAe,GAAGP,OAAO,CAACU,KAAK,CAACoD,WAAW,EAAE,IAAI,CAACvD,eAAe,CAAC;EAEvE,IAAI,CAACH,oBAAoB,GAAGmF,mBAAmB,CAC7CR,eAAe,EACfE,eAAe,EACf,IAAI,CAAC1E,eAAe,EACpB,IAAI,CAACH,oBACP,CAAC;EAED,IAAI,CAACE,eAAe,GAAGN,OAAO,CAACwF,uBAAuB,CACpD,IAAI,CAACpF,oBAAoB,CAACqF,QAAQ,EAClC,IAAI,CAACrF,oBAAoB,CAACsF,MAAM,EAChC,IAAI,CAACpF,eACP,CAAC;EAED,IAAI,CAACD,eAAe,GAAGb,cAAc,CAACmG,uBAAuB,CAC3D,IAAI,CAACvF,oBAAoB,EACzB,IAAI,CAACC,eACP,CAAC;EAED,MAAMuF,oBAAoB,GAAG5B,SAAS,CAACM,CAAC,GAAGP,SAAS,CAACO,CAAC;EACtD,MAAMuB,eAAe,GACnB7B,SAAS,CAACM,CAAC,GAAGP,SAAS,CAACO,CAAC,GAAGsB,oBAAoB,GAAGvB,iBAAiB;EAEtE,MAAMyB,qBAAqB,GAAGb,eAAe,CAACX,CAAC,GAAGS,eAAe,CAACT,CAAC;EACnE,MAAMyB,gBAAgB,GACpBd,eAAe,CAACX,CAAC,GACjBS,eAAe,CAACT,CAAC,GACjBwB,qBAAqB,GAAGzB,iBAAiB;EAC3C,MAAM2B,oBAAoB,GACxBD,gBAAgB,IAAIxB,qBAAqB,GAAGG,YAAY,IACxDqB,gBAAgB,GAAG1B,iBAAiB,GAAGK,YAAY;EACrD,MAAMuB,oBAAoB,GACxBF,gBAAgB,GAAGrB,YAAY,IAC/BqB,gBAAgB,GAAGxB,qBAAqB,GAAGG,YAAY;EACzD,MAAMwB,sBAAsB,GAAGH,gBAAgB,IAAIrB,YAAY;EAC/D,MAAMyB,cAAc,GAClBH,oBAAoB,IAAIC,oBAAoB,IAAIC,sBAAsB;EAExE,MAAMhD,cAAc,GAAG,IAAI,CAAC/B,eAAe;EAC3C,MAAMgC,aAAa,GAAG,IAAI,CAACvB,cAAc;;EAEzC;EACA,KAAK,MAAMwE,GAAG,IAAIjD,aAAa,EAAE;IAC/B,IAAIA,aAAa,CAACkD,cAAc,CAACD,GAAG,CAAC,EAAE;MACrCjD,aAAa,CAACiD,GAAG,CAAC,GAAGtE,SAAS;IAChC;EACF;;EAEA;EACA,IAAIwE,iBAAiB,GAAG,CAAC;EAEzBnD,aAAa,CAAC,wCAAwC,CAAC,GAAGmD,iBAAiB;EAC3EA,iBAAiB,IAAI,CAAC;EAEtB,IAAIT,eAAe,GAAGxB,iBAAiB,GAAGK,YAAY,EAAE;IACtDvB,aAAa,CAAC,iCAAiC,CAAC,GAAG,IAAI;EACzD;EAEA,IAAI4B,eAAe,CAACJ,CAAC,KAAKlE,gBAAgB,CAACkE,CAAC,EAAE;IAC5CxB,aAAa,CAAC,uCAAuC,CAAC,GAAG,IAAI;IAC7DA,aAAa,CAAC,wCAAwC,CAAC,GAAGmD,iBAAiB;IAC3EA,iBAAiB,IAAI,CAAC;EACxB;EACApD,cAAc,CAAC5B,0BAA0B,GAAG7B,UAAU,CAAC8G,YAAY,CACjExB,eAAe,CAACJ,CAAC,EACjBM,eAAe,CAACN,CAAC,EACjBzB,cAAc,CAAC5B,0BACjB,CAAC;EAED,IAAIyD,eAAe,CAACJ,CAAC,KAAKM,eAAe,CAACN,CAAC,EAAE;IAC3CxB,aAAa,CAAC,wCAAwC,CAAC,GAAG,IAAI;EAChE;EAEA,MAAMqD,WAAW,GAAGxC,SAAS,CAACW,CAAC,GAAGZ,SAAS,CAACY,CAAC;EAC7C,IAAI8B,WAAW,GAAG,GAAG;EACrB,IAAIC,YAAY,GAAG,GAAG;EACtB,IAAIF,WAAW,KAAK,GAAG,EAAE;IACvBC,WAAW,GAAG,GAAG,GAAGD,WAAW;IAC/BE,YAAY,GAAG,CAAC3C,SAAS,CAACY,CAAC,GAAG8B,WAAW;EAC3C;EACAvD,cAAc,CAAC1B,4BAA4B,GAAG/B,UAAU,CAAC8G,YAAY,CACnEE,WAAW,EACXC,YAAY,EACZxD,cAAc,CAAC1B,4BACjB,CAAC;EAED,MAAMmF,WAAW,GAAG3C,SAAS,CAAChD,CAAC,GAAG+C,SAAS,CAAC/C,CAAC,CAAC,CAAC;EAC/C,IAAI4F,WAAW,GAAG,GAAG;EACrB,IAAIC,YAAY,GAAG,GAAG;EACtB,IAAIF,WAAW,KAAK,GAAG,EAAE;IACvBC,WAAW,GAAG,GAAG,GAAGD,WAAW;IAC/BE,YAAY,GAAG,CAAC9C,SAAS,CAAC/C,CAAC,GAAG4F,WAAW;EAC3C;EACA1D,cAAc,CAACxB,4BAA4B,GAAGjC,UAAU,CAAC8G,YAAY,CACnEK,WAAW,EACXC,YAAY,EACZ3D,cAAc,CAACxB,4BACjB,CAAC;EAED,IAAIyE,cAAc,EAAE;IAClBhD,aAAa,CAAC,kCAAkC,CAAC,GAAG,IAAI;IACxDA,aAAa,CAAC,mCAAmC,CAAC,GAAGmD,iBAAiB;IAEtE,IAAIN,oBAAoB,EAAE;MACxB7C,aAAa,CAAC,mDAAmD,CAAC,GAAG,IAAI;MACzEmD,iBAAiB,IAAI,CAAC;IACxB,CAAC,MAAM,IAAIL,oBAAoB,EAAE;MAC/B9C,aAAa,CAAC,kDAAkD,CAAC,GAAG,IAAI;MACxEmD,iBAAiB,IAAI,CAAC;IACxB,CAAC,MAAM,IAAIJ,sBAAsB,EAAE;MACjC/C,aAAa,CAAC,mDAAmD,CAAC,GAAG,IAAI;MACzEmD,iBAAiB,IAAI,CAAC;IACxB;IAEApD,cAAc,CAAC3B,yBAAyB,GAAG9B,UAAU,CAAC8G,YAAY,CAChExB,eAAe,CAACT,CAAC,EACjBW,eAAe,CAACX,CAAC,EACjBpB,cAAc,CAAC3B,yBACjB,CAAC;EACH;EAEA,MAAMuF,UAAU,GAAG,CAAC/C,SAAS,CAACO,CAAC,GAAG7D,gBAAgB,CAAC6D,CAAC,IAAID,iBAAiB;EACzE,MAAM0C,UAAU,GAAG,CAAC/C,SAAS,CAACM,CAAC,GAAG7D,gBAAgB,CAAC6D,CAAC,IAAID,iBAAiB;EACzE,MAAM2C,gBAAgB,GAAG,GAAG,GAAGnB,eAAe,GAAGxB,iBAAiB;;EAElE;EACA,MAAM4C,kBAAkB,GAAG,CAACF,UAAU,GAAG,GAAG,GAAGC,gBAAgB,IAAI,GAAG;EACtE9D,cAAc,CAACvB,+BAA+B,GAAGsF,kBAAkB;EAEnE,IAAIpB,eAAe,IAAInB,YAAY,EAAE;IACnCxB,cAAc,CAACzB,2BAA2B,GAAGhC,UAAU,CAAC8G,YAAY,CAClE,GAAG,EACH,GAAG,EACHrD,cAAc,CAACzB,2BACjB,CAAC;EACH,CAAC,MAAM;IACL,MAAM0D,KAAK,GAAGd,iBAAiB,GAAGwB,eAAe;IACjD,MAAMqB,eAAe,GAAGJ,UAAU,GAAGG,kBAAkB;IACvD,MAAME,MAAM,GAAG,CAAChC,KAAK,IAAI+B,eAAe,GAAGtC,IAAI,CAACwC,KAAK,CAACF,eAAe,CAAC,CAAC;IACvEhE,cAAc,CAACzB,2BAA2B,GAAGhC,UAAU,CAAC8G,YAAY,CAClEpB,KAAK,EACLgC,MAAM,EACNjE,cAAc,CAACzB,2BACjB,CAAC;EACH;EAEA,IAAI,CAACe,iCAAiC,GAAG8D,iBAAiB;EAE1D,OAAO,IAAI;AACb,CAAC;AAED,MAAMe,uBAAuB,GAAG,IAAItH,OAAO,CAAC,CAAC;AAC7C,MAAMuH,kBAAkB,GAAG,IAAIvH,OAAO,CAAC,CAAC;AACxC,MAAMwH,mCAAmC,GAAG,IAAIvH,OAAO,CAAC,CAAC;;AAEzD;AACA;AACA;AACA;AACA;AACAG,kBAAkB,CAACwC,SAAS,CAAC6E,oBAAoB,GAAG,UAAUC,UAAU,EAAE;EACxE,MAAMvE,cAAc,GAAG,IAAI,CAAC/B,eAAe;EAC3C;EACA,MAAMuG,6BAA6B,GAAG1H,OAAO,CAAC2H,OAAO,CACnD,IAAI,CAACpH,eAAe,EACpBmD,oCACF,CAAC;EACD,MAAMkE,mBAAmB,GAAG5H,OAAO,CAAC6H,eAAe,CACjDH,6BAA6B,EAC7BD,UAAU,CAACK,MAAM,CAACC,UAAU,EAC5BpE,0BACF,CAAC;EACDT,cAAc,CAAC9B,mBAAmB,GAAG1B,UAAU,CAAC6G,YAAY,CAC1D9G,UAAU,CAACuI,SAAS,CAACJ,mBAAmB,CAAC,EACzChD,IAAI,CAACqD,KAAK,CAACL,mBAAmB,CAACtD,CAAC,EAAEsD,mBAAmB,CAACjD,CAAC,CAAC,EACxDiD,mBAAmB,CAAC5G,CAAC,EACrBkC,cAAc,CAAC9B,mBACjB,CAAC;EACD;EACA,MAAM8G,qBAAqB,GAAGzI,UAAU,CAAC0I,SAAS,CAChD1I,UAAU,CAAC2I,cAAc,CAACR,mBAAmB,EAAEhE,2BAA2B,CAAC,EAC3EA,2BACF,CAAC;EACD;EACA,MAAMyE,gBAAgB,GAAGtI,OAAO,CAACuI,iBAAiB,CAChD,CACEJ,qBAAqB,CAACvD,CAAC,EACvBuD,qBAAqB,CAAC5D,CAAC,EACvB,GAAG,EACH,CAAC4D,qBAAqB,CAAC5D,CAAC,EACxB4D,qBAAqB,CAACvD,CAAC,EACvB,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,CACJ,EACD0C,uBACF,CAAC;EACD;EACA,MAAMkB,4BAA4B,GAChCd,UAAU,CAACe,OAAO,CAACC,YAAY,CAACC,WAAW;EAC7C,MAAMC,4BAA4B,GAAG3I,OAAO,CAAC4I,sBAAsB,CACjElB,6BAA6B,EAC7Ba,4BAA4B,EAC5BhB,mCACF,CAAC;EACD,MAAMsB,6BAA6B,GAAG7I,OAAO,CAAC8I,UAAU,CACtDH,4BAA4B,EAC5BrB,kBACF,CAAC;EACD;EACApE,cAAc,CAAC7B,2BAA2B,GAAGtB,OAAO,CAACgJ,QAAQ,CAC3DV,gBAAgB,EAChBQ,6BAA6B,EAC7B3F,cAAc,CAAC7B,2BACjB,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAlB,kBAAkB,CAACwC,SAAS,CAACqG,0BAA0B,GAAG,UACxDC,aAAa,EACbC,MAAM,EACN;EACA;EACArJ,KAAK,CAACsE,MAAM,CAACC,MAAM,CAAC,eAAe,EAAE6E,aAAa,CAAC;EACnDpJ,KAAK,CAACsE,MAAM,CAACC,MAAM,CAAC,QAAQ,EAAE8E,MAAM,CAAC;EACrC;;EAEA,IAAIC,MAAM,GAAGvE,IAAI,CAACwE,KAAK,CAACH,aAAa,CAACtE,CAAC,EAAEsE,aAAa,CAAC3E,CAAC,CAAC;EACzD,IAAI+E,KAAK,GAAGzE,IAAI,CAACqD,KAAK,CAACgB,aAAa,CAAC3E,CAAC,EAAE2E,aAAa,CAACtE,CAAC,CAAC;EACxD,IAAI2E,MAAM,GAAGL,aAAa,CAACjI,CAAC;EAE5B,MAAM;IACJQ,4BAA4B;IAC5BC,2BAA2B;IAC3BE,+BAA+B;IAC/BD;EACF,CAAC,GAAG,IAAI,CAACP,eAAe;EAExBgI,MAAM,GACJA,MAAM,GAAG3H,4BAA4B,CAACmD,CAAC,GAAGnD,4BAA4B,CAAC8C,CAAC;;EAE1E;EACA+E,KAAK,GAAG,CAACA,KAAK,GAAGzE,IAAI,CAAC2E,EAAE,KAAK,GAAG,GAAG3E,IAAI,CAAC2E,EAAE,CAAC;EAC3CF,KAAK,IAAI1H,+BAA+B;EACxC0H,KAAK,GAAGA,KAAK,GAAGzE,IAAI,CAACwC,KAAK,CAACiC,KAAK,CAAC;EACjC;EACAA,KAAK,GAAGA,KAAK,GAAG5H,2BAA2B,CAACkD,CAAC,GAAGlD,2BAA2B,CAAC6C,CAAC;EAE7EgF,MAAM,GACJA,MAAM,GAAG5H,4BAA4B,CAACiD,CAAC,GAAGjD,4BAA4B,CAAC4C,CAAC;EAE1E,OAAO5E,UAAU,CAAC6G,YAAY,CAAC4C,MAAM,EAAEE,KAAK,EAAEC,MAAM,EAAEJ,MAAM,CAAC;AAC/D,CAAC;AAED,MAAMM,gBAAgB,GAAG,IAAI9J,UAAU,CAAC,CAAC;AACzC,MAAM+J,gBAAgB,GAAG,IAAI/J,UAAU,CAAC,CAAC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAS,kBAAkB,CAACwC,SAAS,CAAC+G,iCAAiC,GAAG,UAC/DC,SAAS,EACTC,KAAK,EACLC,KAAK,EACLC,KAAK,EACLZ,MAAM,EACN;EACA;EACArJ,KAAK,CAACsE,MAAM,CAAC4F,MAAM,CAAC,WAAW,EAAEJ,SAAS,CAAC;EAC3C9J,KAAK,CAACsE,MAAM,CAAC4F,MAAM,CAAC,OAAO,EAAEH,KAAK,CAAC;EACnC/J,KAAK,CAACsE,MAAM,CAAC4F,MAAM,CAAC,OAAO,EAAEF,KAAK,CAAC;EACnChK,KAAK,CAACsE,MAAM,CAAC4F,MAAM,CAAC,OAAO,EAAED,KAAK,CAAC;EACnCjK,KAAK,CAACsE,MAAM,CAACC,MAAM,CAAC,QAAQ,EAAE8E,MAAM,CAAC;EACrC;;EAEA,MAAMnF,SAAS,GAAG,IAAI,CAACvD,UAAU;EACjC,MAAMwD,SAAS,GAAG,IAAI,CAACrD,UAAU;EAEjC,MAAMqJ,WAAW,GAAG,GAAG,GAAGpF,IAAI,CAACqF,GAAG,CAAC,GAAG,EAAEN,SAAS,CAAC;EAElD,MAAMO,aAAa,GAAGxK,UAAU,CAAC6G,YAAY,CAC3C3G,UAAU,CAACuK,IAAI,CAACpG,SAAS,CAACY,CAAC,EAAEX,SAAS,CAACW,CAAC,EAAEiF,KAAK,GAAGI,WAAW,CAAC,EAC9DpK,UAAU,CAACuK,IAAI,CAACpG,SAAS,CAACO,CAAC,EAAEN,SAAS,CAACM,CAAC,EAAEuF,KAAK,GAAGG,WAAW,CAAC,EAC9DpK,UAAU,CAACuK,IAAI,CAACpG,SAAS,CAAC/C,CAAC,EAAEgD,SAAS,CAAChD,CAAC,EAAE8I,KAAK,GAAGE,WAAW,CAAC,EAC9DR,gBACF,CAAC;EACD,MAAMY,aAAa,GAAG1K,UAAU,CAAC6G,YAAY,CAC3C3G,UAAU,CAACuK,IAAI,CAACpG,SAAS,CAACY,CAAC,EAAEX,SAAS,CAACW,CAAC,EAAE,CAACiF,KAAK,GAAG,CAAC,IAAII,WAAW,CAAC,EACpEpK,UAAU,CAACuK,IAAI,CAACpG,SAAS,CAACO,CAAC,EAAEN,SAAS,CAACM,CAAC,EAAE,CAACuF,KAAK,GAAG,CAAC,IAAIG,WAAW,CAAC,EACpEpK,UAAU,CAACuK,IAAI,CAACpG,SAAS,CAAC/C,CAAC,EAAEgD,SAAS,CAAChD,CAAC,EAAE,CAAC8I,KAAK,GAAG,CAAC,IAAIE,WAAW,CAAC,EACpEP,gBACF,CAAC;EAED,OAAOlE,mBAAmB,CACxB2E,aAAa,EACbE,aAAa,EACb,IAAI,CAAC7J,eAAe,EACpB2I,MACF,CAAC;AACH,CAAC;AAED,MAAMmB,iBAAiB,GAAG,IAAI3K,UAAU,CAAC,CAAC;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAS,kBAAkB,CAACwC,SAAS,CAAC2H,mCAAmC,GAAG,UACjEC,WAAW,EACXC,cAAc,EACdC,MAAM,EACNvB,MAAM,EACN;EACA;EACArJ,KAAK,CAACsE,MAAM,CAACC,MAAM,CAAC,aAAa,EAAEmG,WAAW,CAAC;EAC/C1K,KAAK,CAACsE,MAAM,CAACC,MAAM,CAAC,gBAAgB,EAAEoG,cAAc,CAAC;EACrD3K,KAAK,CAACsE,MAAM,CAACC,MAAM,CAAC,QAAQ,EAAEqG,MAAM,CAAC;EACrC5K,KAAK,CAACsE,MAAM,CAACC,MAAM,CAAC,QAAQ,EAAE8E,MAAM,CAAC;EACrC;;EAEA,MAAMwB,eAAe,GAAG,GAAG,GAAG9F,IAAI,CAACqF,GAAG,CAAC,GAAG,EAAEM,WAAW,CAACI,KAAK,CAAC;EAC9D,MAAMC,UAAU,GAAGlL,UAAU,CAACmL,gBAAgB,CAC5CnL,UAAU,CAACoL,GAAG,EACdN,cAAc,EACdH,iBACF,CAAC;EACD,MAAMU,iBAAiB,GAAGrL,UAAU,CAACsL,gBAAgB,CACnDJ,UAAU,EACVF,eAAe,EACfL,iBACF,CAAC;EAED,MAAMY,OAAO,GAAGvL,UAAU,CAACsL,gBAAgB,CACzCtL,UAAU,CAAC6G,YAAY,CACrBgE,WAAW,CAAC5F,CAAC,GAAG8F,MAAM,CAAC9F,CAAC,EACxB4F,WAAW,CAACjG,CAAC,GAAGmG,MAAM,CAACnG,CAAC,EACxBiG,WAAW,CAACvJ,CAAC,GAAGyJ,MAAM,CAACzJ,CAAC,EACxBwI,gBACF,CAAC,EACDkB,eAAe,EACflB,gBACF,CAAC;EACD,MAAM0B,OAAO,GAAGxL,UAAU,CAACyL,GAAG,CAACF,OAAO,EAAEF,iBAAiB,EAAEtB,gBAAgB,CAAC;EAE5E,MAAM1F,SAAS,GAAG,IAAI,CAACvD,UAAU;EACjC,MAAMwD,SAAS,GAAG,IAAI,CAACrD,UAAU;EAEjC,MAAMyK,eAAe,GAAG1L,UAAU,CAAC6G,YAAY,CAC7C3G,UAAU,CAACuK,IAAI,CAACpG,SAAS,CAACY,CAAC,EAAEX,SAAS,CAACW,CAAC,EAAEsG,OAAO,CAACtG,CAAC,CAAC,EACpD/E,UAAU,CAACuK,IAAI,CAACpG,SAAS,CAACO,CAAC,EAAEN,SAAS,CAACM,CAAC,EAAE2G,OAAO,CAAC3G,CAAC,CAAC,EACpD1E,UAAU,CAACuK,IAAI,CAACpG,SAAS,CAAC/C,CAAC,EAAEgD,SAAS,CAAChD,CAAC,EAAEiK,OAAO,CAACjK,CAAC,CAAC,EACpDwI,gBACF,CAAC;EACD,MAAM6B,eAAe,GAAG3L,UAAU,CAAC6G,YAAY,CAC7C3G,UAAU,CAACuK,IAAI,CAACpG,SAAS,CAACY,CAAC,EAAEX,SAAS,CAACW,CAAC,EAAEuG,OAAO,CAACvG,CAAC,CAAC,EACpD/E,UAAU,CAACuK,IAAI,CAACpG,SAAS,CAACO,CAAC,EAAEN,SAAS,CAACM,CAAC,EAAE4G,OAAO,CAAC5G,CAAC,CAAC,EACpD1E,UAAU,CAACuK,IAAI,CAACpG,SAAS,CAAC/C,CAAC,EAAEgD,SAAS,CAAChD,CAAC,EAAEkK,OAAO,CAAClK,CAAC,CAAC,EACpDyI,gBACF,CAAC;EAED,OAAOlE,mBAAmB,CACxB6F,eAAe,EACfC,eAAe,EACf,IAAI,CAAC9K,eAAe,EACpB2I,MACF,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA/I,kBAAkB,CAACM,gBAAgB,GAAGgC,MAAM,CAAC6I,MAAM,CACjD,IAAI5L,UAAU,CAAC,GAAG,EAAE,CAACE,UAAU,CAAC2J,EAAE,EAAE,CAAC,GAAG,CAC1C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACApJ,kBAAkB,CAACS,gBAAgB,GAAG6B,MAAM,CAAC6I,MAAM,CACjD,IAAI5L,UAAU,CAAC,GAAG,EAAE,CAACE,UAAU,CAAC2J,EAAE,EAAE,CAAC,GAAG,CAC1C,CAAC;AAED,MAAMgC,aAAa,GAAG,CAAC;AACvB,MAAMC,iBAAiB,GAAG,IAAIC,KAAK,CAACF,aAAa,CAAC;AAClD,MAAMG,kBAAkB,GAAG,IAAIhM,UAAU,CAAC,CAAC;AAC3C,MAAMiM,eAAe,GAAG,IAAI5L,OAAO,CAAC,CAAC;AACrC,MAAM6L,wBAAwB,GAAG,IAAI5L,OAAO,CAAC,CAAC;AAC9C,MAAM6L,qBAAqB,GAAG,IAAI7L,OAAO,CAAC,CAAC;AAC3C,MAAM8L,kBAAkB,GAAG,IAAI9L,OAAO,CAAC,CAAC;AACxC,MAAM+L,aAAa,GAAG,IAAI/L,OAAO,CAAC,CAAC;AACnC,MAAMgM,cAAc,GAAG,IAAItM,UAAU,CAAC,CAAC;AACvC,MAAMuM,cAAc,GAAG,IAAIvM,UAAU,CAAC,CAAC;AACvC,MAAMwM,cAAc,GAAG,IAAIxM,UAAU,CAAC,CAAC;AACvC,MAAMyM,cAAc,GAAG,IAAIV,KAAK,CAAC,CAAC,CAAC;AACnC,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;EAC1BD,cAAc,CAACC,CAAC,CAAC,GAAG,IAAI1M,UAAU,CAAC,CAAC;AACtC;AAEA,SAAS2M,UAAUA,CAACC,CAAC,EAAEC,CAAC,EAAEC,OAAO,EAAE;EACjC,OAAO5H,IAAI,CAAC6H,GAAG,CAAC9M,UAAU,CAAC+M,GAAG,CAACJ,CAAC,EAAEC,CAAC,CAAC,CAAC,GAAGC,OAAO;AACjD;AAEA,SAASG,wCAAwCA,CAACC,MAAM,EAAE;EACxD,MAAMC,OAAO,GAAG7M,OAAO,CAAC8M,SAAS,CAACF,MAAM,EAAE,CAAC,EAAEZ,cAAc,CAAC;EAC5D,MAAMe,OAAO,GAAG/M,OAAO,CAAC8M,SAAS,CAACF,MAAM,EAAE,CAAC,EAAEX,cAAc,CAAC;EAC5D,MAAMe,OAAO,GAAGhN,OAAO,CAAC8M,SAAS,CAACF,MAAM,EAAE,CAAC,EAAEV,cAAc,CAAC;EAE5D,MAAMM,OAAO,GAAG5M,UAAU,CAACqN,QAAQ;EAEnC,OACEZ,UAAU,CAACQ,OAAO,EAAEE,OAAO,EAAEP,OAAO,CAAC,IACrCH,UAAU,CAACU,OAAO,EAAEC,OAAO,EAAER,OAAO,CAAC;AAEzC;AAEA,SAASU,+BAA+BA,CAACN,MAAM,EAAE1D,MAAM,EAAE;EACvD,MAAMiE,OAAO,GAAGhB,cAAc;EAC9BzM,UAAU,CAAC6G,YAAY,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE4G,OAAO,CAAC,CAAC,CAAC,CAAC;EACrDzN,UAAU,CAAC6G,YAAY,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE4G,OAAO,CAAC,CAAC,CAAC,CAAC;EACpDzN,UAAU,CAAC6G,YAAY,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,GAAG,EAAE4G,OAAO,CAAC,CAAC,CAAC,CAAC;EACpDzN,UAAU,CAAC6G,YAAY,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE4G,OAAO,CAAC,CAAC,CAAC,CAAC;EACnDzN,UAAU,CAAC6G,YAAY,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE4G,OAAO,CAAC,CAAC,CAAC,CAAC;EACpDzN,UAAU,CAAC6G,YAAY,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE4G,OAAO,CAAC,CAAC,CAAC,CAAC;EACnDzN,UAAU,CAAC6G,YAAY,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,GAAG,EAAE4G,OAAO,CAAC,CAAC,CAAC,CAAC;EACnDzN,UAAU,CAAC6G,YAAY,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE4G,OAAO,CAAC,CAAC,CAAC,CAAC;EAElD,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAE,EAAEA,CAAC,EAAE;IAC1BpM,OAAO,CAAC6H,eAAe,CAAC+E,MAAM,EAAEO,OAAO,CAACf,CAAC,CAAC,EAAEe,OAAO,CAACf,CAAC,CAAC,CAAC;EACzD;EAEA,OAAOnM,mBAAmB,CAACmN,UAAU,CAACD,OAAO,EAAEjE,MAAM,CAAC;AACxD;AAEA,MAAMmE,eAAe,GAAG,IAAI3N,UAAU,CAAC,CAAC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS6F,mBAAmBA,CAAC+H,cAAc,EAAEC,cAAc,EAAEX,MAAM,EAAE1D,MAAM,EAAE;EAC3E,MAAMsE,WAAW,GAAGF,cAAc,CAAC3I,CAAC;EACpC,MAAM8I,SAAS,GAAGF,cAAc,CAAC5I,CAAC;EAClC,MAAM+I,UAAU,GAAGJ,cAAc,CAAChJ,CAAC;EACnC,MAAMqJ,QAAQ,GACZJ,cAAc,CAACjJ,CAAC,GAAGoJ,UAAU,GACzBH,cAAc,CAACjJ,CAAC,GAAG1E,UAAU,CAACgO,MAAM,GACpCL,cAAc,CAACjJ,CAAC;EACtB,MAAMuJ,WAAW,GAAGP,cAAc,CAACtM,CAAC;EACpC,MAAM8M,SAAS,GAAGP,cAAc,CAACvM,CAAC;EAElC,MAAM+M,UAAU,GAAGJ,QAAQ,GAAGD,UAAU;EACxC,MAAMM,QAAQ,GAAGN,UAAU,GAAGK,UAAU,GAAG,GAAG;EAE9C,MAAME,UAAU,GAAGzC,iBAAiB;EACpC,IAAI0C,cAAc,GAAG,CAAC;EAEtBD,UAAU,CAACC,cAAc,EAAE,CAAC,GAAGR,UAAU;EACzCO,UAAU,CAACC,cAAc,EAAE,CAAC,GAAGP,QAAQ;EACvCM,UAAU,CAACC,cAAc,EAAE,CAAC,GAAGF,QAAQ;EAEvC,IAAID,UAAU,GAAGnO,UAAU,CAAC2J,EAAE,EAAE;IAC9B0E,UAAU,CAACC,cAAc,EAAE,CAAC,GAAGF,QAAQ,GAAGpO,UAAU,CAACuO,WAAW;IAChEF,UAAU,CAACC,cAAc,EAAE,CAAC,GAAGF,QAAQ,GAAGpO,UAAU,CAACuO,WAAW;EAClE;;EAEA;EACA,IAAIC,IAAI,GAAGC,MAAM,CAACC,iBAAiB;EACnC,IAAIC,IAAI,GAAGF,MAAM,CAACC,iBAAiB;EACnC,IAAIE,IAAI,GAAGH,MAAM,CAACI,iBAAiB;EACnC,IAAIC,IAAI,GAAGL,MAAM,CAACI,iBAAiB;EAEnC,KAAK,IAAIrC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8B,cAAc,EAAE,EAAE9B,CAAC,EAAE;IACvC,MAAM/C,KAAK,GAAG4E,UAAU,CAAC7B,CAAC,CAAC,GAAG4B,QAAQ;IACtC,MAAMW,QAAQ,GAAG/J,IAAI,CAACgK,GAAG,CAACvF,KAAK,CAAC;IAChC,MAAMwF,QAAQ,GAAGjK,IAAI,CAACkK,GAAG,CAACzF,KAAK,CAAC;IAChC,MAAM0F,EAAE,GAAGJ,QAAQ,GAAGnB,WAAW;IACjC,MAAMwB,EAAE,GAAGH,QAAQ,GAAGrB,WAAW;IACjC,MAAMyB,EAAE,GAAGN,QAAQ,GAAGlB,SAAS;IAC/B,MAAMyB,EAAE,GAAGL,QAAQ,GAAGpB,SAAS;IAE/BW,IAAI,GAAGxJ,IAAI,CAACuK,GAAG,CAACf,IAAI,EAAEW,EAAE,EAAEE,EAAE,CAAC;IAC7BV,IAAI,GAAG3J,IAAI,CAACuK,GAAG,CAACZ,IAAI,EAAES,EAAE,EAAEE,EAAE,CAAC;IAC7BV,IAAI,GAAG5J,IAAI,CAACC,GAAG,CAAC2J,IAAI,EAAEO,EAAE,EAAEE,EAAE,CAAC;IAC7BP,IAAI,GAAG9J,IAAI,CAACC,GAAG,CAAC6J,IAAI,EAAEM,EAAE,EAAEE,EAAE,CAAC;EAC/B;EAEA,MAAME,OAAO,GAAGZ,IAAI,GAAGJ,IAAI;EAC3B,MAAMiB,OAAO,GAAGX,IAAI,GAAGH,IAAI;EAC3B,MAAMe,OAAO,GAAGxB,SAAS,GAAGD,WAAW;EAEvC,MAAM0B,OAAO,GAAG,CAACnB,IAAI,GAAGI,IAAI,IAAI,GAAG;EACnC,MAAMgB,OAAO,GAAG,CAACjB,IAAI,GAAGG,IAAI,IAAI,GAAG;EACnC,MAAMe,OAAO,GAAG,CAAC5B,WAAW,GAAGC,SAAS,IAAI,GAAG;EAE/C,MAAM4B,WAAW,GAAGhQ,UAAU,CAAC6G,YAAY,CACzCgJ,OAAO,EACPC,OAAO,EACPC,OAAO,EACP/D,kBACF,CAAC;EAED,MAAMiE,QAAQ,GAAG5P,OAAO,CAAC6P,aAAa,CAAC5B,QAAQ,EAAErC,eAAe,CAAC;EAEjE,MAAMxG,KAAK,GAAGzF,UAAU,CAAC6G,YAAY,CACnC6I,OAAO,EACPC,OAAO,EACPC,OAAO,EACPjC,eACF,CAAC;EAED,MAAMwC,WAAW,GAAG7P,OAAO,CAAC8P,SAAS,CAAC3K,KAAK,EAAE2G,kBAAkB,CAAC;EAChE,MAAMiE,cAAc,GAAG/P,OAAO,CAACgQ,YAAY,CAACL,QAAQ,EAAE9D,qBAAqB,CAAC;EAC5E,MAAMoE,iBAAiB,GAAGjQ,OAAO,CAACkQ,eAAe,CAC/CR,WAAW,EACX9D,wBACF,CAAC;;EAED;EACA,MAAMuE,WAAW,GAAGnQ,OAAO,CAAC4I,sBAAsB,CAChDmH,cAAc,EACd/P,OAAO,CAAC4I,sBAAsB,CAC5BqH,iBAAiB,EACjBJ,WAAW,EACX9D,aACF,CAAC,EACDA,aACF,CAAC;EAED,MAAMqE,YAAY,GAAGpQ,OAAO,CAAC4I,sBAAsB,CACjDgE,MAAM,EACNuD,WAAW,EACXpE,aACF,CAAC;EAED,IAAI,CAACY,wCAAwC,CAACyD,YAAY,CAAC,EAAE;IAC3D,OAAOlD,+BAA+B,CAACkD,YAAY,EAAElH,MAAM,CAAC;EAC9D;EAEA,OAAOjJ,mBAAmB,CAACoQ,kBAAkB,CAACD,YAAY,EAAElH,MAAM,CAAC;AACrE;AAEA,eAAe/I,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}