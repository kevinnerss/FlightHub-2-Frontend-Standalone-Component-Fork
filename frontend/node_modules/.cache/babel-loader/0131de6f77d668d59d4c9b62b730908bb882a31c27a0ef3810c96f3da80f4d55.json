{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport GltfLoaderUtil from \"./GltfLoaderUtil.js\";\nimport JobType from \"./JobType.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\nimport resizeImageToNextPowerOfTwo from \"../Core/resizeImageToNextPowerOfTwo.js\";\n\n/**\n * Loads a glTF texture.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfTextureLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {object} options Object with the following properties:\n * @param {ResourceCache} options.resourceCache The {@link ResourceCache} (to avoid circular dependencies).\n * @param {object} options.gltf The glTF JSON.\n * @param {object} options.textureInfo The texture info object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {SupportedImageFormats} options.supportedImageFormats The supported image formats.\n * @param {string} [options.cacheKey] The cache key of the resource.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n *\n * @private\n */\nfunction GltfTextureLoader(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const resourceCache = options.resourceCache;\n  const gltf = options.gltf;\n  const textureInfo = options.textureInfo;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const supportedImageFormats = options.supportedImageFormats;\n  const cacheKey = options.cacheKey;\n  const asynchronous = options.asynchronous ?? true;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"options.resourceCache\", resourceCache);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.textureInfo\", textureInfo);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  Check.typeOf.object(\"options.supportedImageFormats\", supportedImageFormats);\n  //>>includeEnd('debug');\n\n  const textureId = textureInfo.index;\n\n  // imageId is guaranteed to be defined otherwise the GltfTextureLoader\n  // wouldn't have been created\n  const imageId = GltfLoaderUtil.getImageIdFromTexture({\n    gltf: gltf,\n    textureId: textureId,\n    supportedImageFormats: supportedImageFormats\n  });\n  this._resourceCache = resourceCache;\n  this._gltf = gltf;\n  this._textureInfo = textureInfo;\n  this._imageId = imageId;\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._cacheKey = cacheKey;\n  this._asynchronous = asynchronous;\n  this._imageLoader = undefined;\n  this._image = undefined;\n  this._mipLevels = undefined;\n  this._texture = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n}\nif (defined(Object.create)) {\n  GltfTextureLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfTextureLoader.prototype.constructor = GltfTextureLoader;\n}\nObject.defineProperties(GltfTextureLoader.prototype, {\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfTextureLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    }\n  },\n  /**\n   * The texture.\n   *\n   * @memberof GltfTextureLoader.prototype\n   *\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  texture: {\n    get: function () {\n      return this._texture;\n    }\n  }\n});\nconst scratchTextureJob = new CreateTextureJob();\nasync function loadResources(loader) {\n  const resourceCache = loader._resourceCache;\n  try {\n    const imageLoader = resourceCache.getImageLoader({\n      gltf: loader._gltf,\n      imageId: loader._imageId,\n      gltfResource: loader._gltfResource,\n      baseResource: loader._baseResource\n    });\n    loader._imageLoader = imageLoader;\n    await imageLoader.load();\n    if (loader.isDestroyed()) {\n      return;\n    }\n\n    // Now wait for process() to run to finish loading\n    loader._image = imageLoader.image;\n    loader._mipLevels = imageLoader.mipLevels;\n    loader._state = ResourceLoaderState.LOADED;\n    return loader;\n  } catch (error) {\n    if (loader.isDestroyed()) {\n      return;\n    }\n    loader.unload();\n    loader._state = ResourceLoaderState.FAILED;\n    const errorMessage = \"Failed to load texture\";\n    throw loader.getError(errorMessage, error);\n  }\n}\n\n/**\n * Loads the resource.\n * @returns {Promise<GltfDracoLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfTextureLoader.prototype.load = async function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n  this._state = ResourceLoaderState.LOADING;\n  this._promise = loadResources(this);\n  return this._promise;\n};\nfunction CreateTextureJob() {\n  this.gltf = undefined;\n  this.textureInfo = undefined;\n  this.textureId = undefined;\n  this.image = undefined;\n  this.context = undefined;\n  this.texture = undefined;\n}\nCreateTextureJob.prototype.set = function (gltf, textureInfo, textureId, image, mipLevels, context) {\n  this.gltf = gltf;\n  this.textureInfo = textureInfo;\n  this.textureId = textureId;\n  this.image = image;\n  this.mipLevels = mipLevels;\n  this.context = context;\n};\nCreateTextureJob.prototype.execute = function () {\n  this.texture = createTexture(this.gltf, this.textureInfo, this.textureId, this.image, this.mipLevels, this.context);\n};\nfunction createTexture(gltf, textureInfo, textureId, image, mipLevels, context) {\n  // internalFormat is only defined for CompressedTextureBuffer\n  const internalFormat = image.internalFormat;\n  let compressedTextureNoMipmap = false;\n  if (PixelFormat.isCompressedFormat(internalFormat) && !defined(mipLevels)) {\n    compressedTextureNoMipmap = true;\n  }\n  const sampler = GltfLoaderUtil.createSampler({\n    gltf: gltf,\n    textureInfo: textureInfo,\n    compressedTextureNoMipmap: compressedTextureNoMipmap\n  });\n  const minFilter = sampler.minificationFilter;\n  const wrapS = sampler.wrapS;\n  const wrapT = sampler.wrapT;\n  const samplerRequiresMipmap = minFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST || minFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR || minFilter === TextureMinificationFilter.LINEAR_MIPMAP_NEAREST || minFilter === TextureMinificationFilter.LINEAR_MIPMAP_LINEAR;\n\n  // generateMipmap is disallowed for compressed textures. Compressed textures\n  // can have mipmaps but they must come with the KTX2 instead of generated by\n  // WebGL. Also note from the KHR_texture_basisu spec:\n  //\n  //   When a texture refers to a sampler with mipmap minification or when the\n  //   sampler is undefined, the KTX2 image SHOULD contain a full mip pyramid.\n  //\n  const generateMipmap = !defined(internalFormat) && samplerRequiresMipmap;\n\n  // WebGL 1 requires power-of-two texture dimensions for mipmapping and REPEAT/MIRRORED_REPEAT wrap modes.\n  const requiresPowerOfTwo = generateMipmap || wrapS === TextureWrap.REPEAT || wrapS === TextureWrap.MIRRORED_REPEAT || wrapT === TextureWrap.REPEAT || wrapT === TextureWrap.MIRRORED_REPEAT;\n  const nonPowerOfTwo = !CesiumMath.isPowerOfTwo(image.width) || !CesiumMath.isPowerOfTwo(image.height);\n  const requiresResize = requiresPowerOfTwo && nonPowerOfTwo;\n  let texture;\n  if (defined(internalFormat)) {\n    if (!context.webgl2 && PixelFormat.isCompressedFormat(internalFormat) && nonPowerOfTwo && requiresPowerOfTwo) {\n      console.warn(\"Compressed texture uses REPEAT or MIRRORED_REPEAT texture wrap mode and dimensions are not powers of two. The texture may be rendered incorrectly.\");\n    }\n    texture = Texture.create({\n      id: textureId,\n      context: context,\n      source: {\n        arrayBufferView: image.bufferView,\n        // Only defined for CompressedTextureBuffer\n        mipLevels: mipLevels\n      },\n      width: image.width,\n      height: image.height,\n      pixelFormat: image.internalFormat,\n      // Only defined for CompressedTextureBuffer\n      sampler: sampler\n    });\n  } else {\n    if (requiresResize) {\n      image = resizeImageToNextPowerOfTwo(image);\n    }\n    texture = Texture.create({\n      id: textureId,\n      context: context,\n      source: image,\n      sampler: sampler,\n      flipY: false,\n      skipColorSpaceConversion: true\n    });\n  }\n  if (generateMipmap) {\n    texture.generateMipmap();\n  }\n  return texture;\n}\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @returns {boolean} true once all resourced are ready.\n * @private\n */\nGltfTextureLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === ResourceLoaderState.READY) {\n    return true;\n  }\n  if (this._state !== ResourceLoaderState.LOADED && this._state !== ResourceLoaderState.PROCESSING) {\n    return false;\n  }\n  if (defined(this._texture)) {\n    // Already created texture\n    return false;\n  }\n  if (!defined(this._image)) {\n    // Not ready to create texture\n    return false;\n  }\n  this._state = ResourceLoaderState.PROCESSING;\n  let texture;\n  if (this._asynchronous) {\n    const textureJob = scratchTextureJob;\n    textureJob.set(this._gltf, this._textureInfo, this._cacheKey, this._image, this._mipLevels, frameState.context);\n    const jobScheduler = frameState.jobScheduler;\n    if (!jobScheduler.execute(textureJob, JobType.TEXTURE)) {\n      // Job scheduler is full. Try again next frame.\n      return;\n    }\n    texture = textureJob.texture;\n  } else {\n    texture = createTexture(this._gltf, this._textureInfo, this._cacheKey, this._image, this._mipLevels, frameState.context);\n  }\n\n  // Unload everything except the texture\n  this.unload();\n  this._texture = texture;\n  this._state = ResourceLoaderState.READY;\n  this._resourceCache.statistics.addTextureLoader(this);\n  return true;\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfTextureLoader.prototype.unload = function () {\n  if (defined(this._texture)) {\n    this._texture.destroy();\n  }\n  if (defined(this._imageLoader) && !this._imageLoader.isDestroyed()) {\n    this._resourceCache.unload(this._imageLoader);\n  }\n  this._imageLoader = undefined;\n  this._image = undefined;\n  this._mipLevels = undefined;\n  this._texture = undefined;\n  this._gltf = undefined;\n};\nexport default GltfTextureLoader;","map":{"version":3,"names":["Check","CesiumMath","Frozen","defined","PixelFormat","Texture","TextureMinificationFilter","TextureWrap","GltfLoaderUtil","JobType","ResourceLoader","ResourceLoaderState","resizeImageToNextPowerOfTwo","GltfTextureLoader","options","EMPTY_OBJECT","resourceCache","gltf","textureInfo","gltfResource","baseResource","supportedImageFormats","cacheKey","asynchronous","typeOf","func","object","textureId","index","imageId","getImageIdFromTexture","_resourceCache","_gltf","_textureInfo","_imageId","_gltfResource","_baseResource","_cacheKey","_asynchronous","_imageLoader","undefined","_image","_mipLevels","_texture","_state","UNLOADED","_promise","Object","create","prototype","constructor","defineProperties","get","texture","scratchTextureJob","CreateTextureJob","loadResources","loader","imageLoader","getImageLoader","load","isDestroyed","image","mipLevels","LOADED","error","unload","FAILED","errorMessage","getError","LOADING","context","set","execute","createTexture","internalFormat","compressedTextureNoMipmap","isCompressedFormat","sampler","createSampler","minFilter","minificationFilter","wrapS","wrapT","samplerRequiresMipmap","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","generateMipmap","requiresPowerOfTwo","REPEAT","MIRRORED_REPEAT","nonPowerOfTwo","isPowerOfTwo","width","height","requiresResize","webgl2","console","warn","id","source","arrayBufferView","bufferView","pixelFormat","flipY","skipColorSpaceConversion","process","frameState","READY","PROCESSING","textureJob","jobScheduler","TEXTURE","statistics","addTextureLoader","destroy"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/GltfTextureLoader.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport GltfLoaderUtil from \"./GltfLoaderUtil.js\";\nimport JobType from \"./JobType.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\nimport resizeImageToNextPowerOfTwo from \"../Core/resizeImageToNextPowerOfTwo.js\";\n\n/**\n * Loads a glTF texture.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfTextureLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {object} options Object with the following properties:\n * @param {ResourceCache} options.resourceCache The {@link ResourceCache} (to avoid circular dependencies).\n * @param {object} options.gltf The glTF JSON.\n * @param {object} options.textureInfo The texture info object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {SupportedImageFormats} options.supportedImageFormats The supported image formats.\n * @param {string} [options.cacheKey] The cache key of the resource.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n *\n * @private\n */\nfunction GltfTextureLoader(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const resourceCache = options.resourceCache;\n  const gltf = options.gltf;\n  const textureInfo = options.textureInfo;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const supportedImageFormats = options.supportedImageFormats;\n  const cacheKey = options.cacheKey;\n  const asynchronous = options.asynchronous ?? true;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"options.resourceCache\", resourceCache);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.textureInfo\", textureInfo);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  Check.typeOf.object(\"options.supportedImageFormats\", supportedImageFormats);\n  //>>includeEnd('debug');\n\n  const textureId = textureInfo.index;\n\n  // imageId is guaranteed to be defined otherwise the GltfTextureLoader\n  // wouldn't have been created\n  const imageId = GltfLoaderUtil.getImageIdFromTexture({\n    gltf: gltf,\n    textureId: textureId,\n    supportedImageFormats: supportedImageFormats,\n  });\n\n  this._resourceCache = resourceCache;\n  this._gltf = gltf;\n  this._textureInfo = textureInfo;\n  this._imageId = imageId;\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._cacheKey = cacheKey;\n  this._asynchronous = asynchronous;\n  this._imageLoader = undefined;\n  this._image = undefined;\n  this._mipLevels = undefined;\n  this._texture = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n}\n\nif (defined(Object.create)) {\n  GltfTextureLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfTextureLoader.prototype.constructor = GltfTextureLoader;\n}\n\nObject.defineProperties(GltfTextureLoader.prototype, {\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfTextureLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    },\n  },\n  /**\n   * The texture.\n   *\n   * @memberof GltfTextureLoader.prototype\n   *\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  texture: {\n    get: function () {\n      return this._texture;\n    },\n  },\n});\n\nconst scratchTextureJob = new CreateTextureJob();\n\nasync function loadResources(loader) {\n  const resourceCache = loader._resourceCache;\n  try {\n    const imageLoader = resourceCache.getImageLoader({\n      gltf: loader._gltf,\n      imageId: loader._imageId,\n      gltfResource: loader._gltfResource,\n      baseResource: loader._baseResource,\n    });\n    loader._imageLoader = imageLoader;\n    await imageLoader.load();\n\n    if (loader.isDestroyed()) {\n      return;\n    }\n\n    // Now wait for process() to run to finish loading\n    loader._image = imageLoader.image;\n    loader._mipLevels = imageLoader.mipLevels;\n    loader._state = ResourceLoaderState.LOADED;\n\n    return loader;\n  } catch (error) {\n    if (loader.isDestroyed()) {\n      return;\n    }\n\n    loader.unload();\n    loader._state = ResourceLoaderState.FAILED;\n    const errorMessage = \"Failed to load texture\";\n    throw loader.getError(errorMessage, error);\n  }\n}\n\n/**\n * Loads the resource.\n * @returns {Promise<GltfDracoLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfTextureLoader.prototype.load = async function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n\n  this._state = ResourceLoaderState.LOADING;\n  this._promise = loadResources(this);\n  return this._promise;\n};\n\nfunction CreateTextureJob() {\n  this.gltf = undefined;\n  this.textureInfo = undefined;\n  this.textureId = undefined;\n  this.image = undefined;\n  this.context = undefined;\n  this.texture = undefined;\n}\n\nCreateTextureJob.prototype.set = function (\n  gltf,\n  textureInfo,\n  textureId,\n  image,\n  mipLevels,\n  context,\n) {\n  this.gltf = gltf;\n  this.textureInfo = textureInfo;\n  this.textureId = textureId;\n  this.image = image;\n  this.mipLevels = mipLevels;\n  this.context = context;\n};\n\nCreateTextureJob.prototype.execute = function () {\n  this.texture = createTexture(\n    this.gltf,\n    this.textureInfo,\n    this.textureId,\n    this.image,\n    this.mipLevels,\n    this.context,\n  );\n};\n\nfunction createTexture(\n  gltf,\n  textureInfo,\n  textureId,\n  image,\n  mipLevels,\n  context,\n) {\n  // internalFormat is only defined for CompressedTextureBuffer\n  const internalFormat = image.internalFormat;\n\n  let compressedTextureNoMipmap = false;\n  if (PixelFormat.isCompressedFormat(internalFormat) && !defined(mipLevels)) {\n    compressedTextureNoMipmap = true;\n  }\n\n  const sampler = GltfLoaderUtil.createSampler({\n    gltf: gltf,\n    textureInfo: textureInfo,\n    compressedTextureNoMipmap: compressedTextureNoMipmap,\n  });\n\n  const minFilter = sampler.minificationFilter;\n  const wrapS = sampler.wrapS;\n  const wrapT = sampler.wrapT;\n\n  const samplerRequiresMipmap =\n    minFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST ||\n    minFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR ||\n    minFilter === TextureMinificationFilter.LINEAR_MIPMAP_NEAREST ||\n    minFilter === TextureMinificationFilter.LINEAR_MIPMAP_LINEAR;\n\n  // generateMipmap is disallowed for compressed textures. Compressed textures\n  // can have mipmaps but they must come with the KTX2 instead of generated by\n  // WebGL. Also note from the KHR_texture_basisu spec:\n  //\n  //   When a texture refers to a sampler with mipmap minification or when the\n  //   sampler is undefined, the KTX2 image SHOULD contain a full mip pyramid.\n  //\n  const generateMipmap = !defined(internalFormat) && samplerRequiresMipmap;\n\n  // WebGL 1 requires power-of-two texture dimensions for mipmapping and REPEAT/MIRRORED_REPEAT wrap modes.\n  const requiresPowerOfTwo =\n    generateMipmap ||\n    wrapS === TextureWrap.REPEAT ||\n    wrapS === TextureWrap.MIRRORED_REPEAT ||\n    wrapT === TextureWrap.REPEAT ||\n    wrapT === TextureWrap.MIRRORED_REPEAT;\n\n  const nonPowerOfTwo =\n    !CesiumMath.isPowerOfTwo(image.width) ||\n    !CesiumMath.isPowerOfTwo(image.height);\n\n  const requiresResize = requiresPowerOfTwo && nonPowerOfTwo;\n\n  let texture;\n  if (defined(internalFormat)) {\n    if (\n      !context.webgl2 &&\n      PixelFormat.isCompressedFormat(internalFormat) &&\n      nonPowerOfTwo &&\n      requiresPowerOfTwo\n    ) {\n      console.warn(\n        \"Compressed texture uses REPEAT or MIRRORED_REPEAT texture wrap mode and dimensions are not powers of two. The texture may be rendered incorrectly.\",\n      );\n    }\n\n    texture = Texture.create({\n      id: textureId,\n      context: context,\n      source: {\n        arrayBufferView: image.bufferView, // Only defined for CompressedTextureBuffer\n        mipLevels: mipLevels,\n      },\n      width: image.width,\n      height: image.height,\n      pixelFormat: image.internalFormat, // Only defined for CompressedTextureBuffer\n      sampler: sampler,\n    });\n  } else {\n    if (requiresResize) {\n      image = resizeImageToNextPowerOfTwo(image);\n    }\n    texture = Texture.create({\n      id: textureId,\n      context: context,\n      source: image,\n      sampler: sampler,\n      flipY: false,\n      skipColorSpaceConversion: true,\n    });\n  }\n\n  if (generateMipmap) {\n    texture.generateMipmap();\n  }\n\n  return texture;\n}\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @returns {boolean} true once all resourced are ready.\n * @private\n */\nGltfTextureLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === ResourceLoaderState.READY) {\n    return true;\n  }\n\n  if (\n    this._state !== ResourceLoaderState.LOADED &&\n    this._state !== ResourceLoaderState.PROCESSING\n  ) {\n    return false;\n  }\n\n  if (defined(this._texture)) {\n    // Already created texture\n    return false;\n  }\n\n  if (!defined(this._image)) {\n    // Not ready to create texture\n    return false;\n  }\n\n  this._state = ResourceLoaderState.PROCESSING;\n\n  let texture;\n  if (this._asynchronous) {\n    const textureJob = scratchTextureJob;\n    textureJob.set(\n      this._gltf,\n      this._textureInfo,\n      this._cacheKey,\n      this._image,\n      this._mipLevels,\n      frameState.context,\n    );\n    const jobScheduler = frameState.jobScheduler;\n    if (!jobScheduler.execute(textureJob, JobType.TEXTURE)) {\n      // Job scheduler is full. Try again next frame.\n      return;\n    }\n    texture = textureJob.texture;\n  } else {\n    texture = createTexture(\n      this._gltf,\n      this._textureInfo,\n      this._cacheKey,\n      this._image,\n      this._mipLevels,\n      frameState.context,\n    );\n  }\n\n  // Unload everything except the texture\n  this.unload();\n\n  this._texture = texture;\n  this._state = ResourceLoaderState.READY;\n  this._resourceCache.statistics.addTextureLoader(this);\n  return true;\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfTextureLoader.prototype.unload = function () {\n  if (defined(this._texture)) {\n    this._texture.destroy();\n  }\n\n  if (defined(this._imageLoader) && !this._imageLoader.isDestroyed()) {\n    this._resourceCache.unload(this._imageLoader);\n  }\n\n  this._imageLoader = undefined;\n  this._image = undefined;\n  this._mipLevels = undefined;\n  this._texture = undefined;\n  this._gltf = undefined;\n};\n\nexport default GltfTextureLoader;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}