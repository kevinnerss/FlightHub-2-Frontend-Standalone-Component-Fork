{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport AssociativeArray from \"../Core/AssociativeArray.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport ReferenceFrame from \"../Core/ReferenceFrame.js\";\nimport TimeInterval from \"../Core/TimeInterval.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport PolylineCollection from \"../Scene/PolylineCollection.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport CallbackPositionProperty from \"./CallbackPositionProperty.js\";\nimport CompositePositionProperty from \"./CompositePositionProperty.js\";\nimport ConstantPositionProperty from \"./ConstantPositionProperty.js\";\nimport MaterialProperty from \"./MaterialProperty.js\";\nimport Property from \"./Property.js\";\nimport ReferenceProperty from \"./ReferenceProperty.js\";\nimport SampledPositionProperty from \"./SampledPositionProperty.js\";\nimport ScaledPositionProperty from \"./ScaledPositionProperty.js\";\nimport TimeIntervalCollectionPositionProperty from \"./TimeIntervalCollectionPositionProperty.js\";\nconst defaultResolution = 60.0;\nconst defaultWidth = 1.0;\nconst scratchTimeInterval = new TimeInterval();\nconst subSampleCompositePropertyScratch = new TimeInterval();\nconst subSampleIntervalPropertyScratch = new TimeInterval();\nfunction EntityData(entity) {\n  this.entity = entity;\n  this.polyline = undefined;\n  this.index = undefined;\n  this.updater = undefined;\n}\nfunction subSampleSampledProperty(property, start, stop, times, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n  let r = startingIndex;\n  //Always step exactly on start (but only use it if it exists.)\n  let tmp;\n  tmp = property.getValueInReferenceFrame(start, referenceFrame, result[r]);\n  if (defined(tmp)) {\n    result[r++] = tmp;\n  }\n  let steppedOnNow = !defined(updateTime) || JulianDate.lessThanOrEquals(updateTime, start) || JulianDate.greaterThanOrEquals(updateTime, stop);\n\n  //Iterate over all interval times and add the ones that fall in our\n  //time range.  Note that times can contain data outside of\n  //the intervals range.  This is by design for use with interpolation.\n  let t = 0;\n  const len = times.length;\n  let current = times[t];\n  const loopStop = stop;\n  let sampling = false;\n  let sampleStepsToTake;\n  let sampleStepsTaken;\n  let sampleStepSize;\n  while (t < len) {\n    if (!steppedOnNow && JulianDate.greaterThanOrEquals(current, updateTime)) {\n      tmp = property.getValueInReferenceFrame(updateTime, referenceFrame, result[r]);\n      if (defined(tmp)) {\n        result[r++] = tmp;\n      }\n      steppedOnNow = true;\n    }\n    if (JulianDate.greaterThan(current, start) && JulianDate.lessThan(current, loopStop) && !current.equals(updateTime)) {\n      tmp = property.getValueInReferenceFrame(current, referenceFrame, result[r]);\n      if (defined(tmp)) {\n        result[r++] = tmp;\n      }\n    }\n    if (t < len - 1) {\n      if (maximumStep > 0 && !sampling) {\n        const next = times[t + 1];\n        const secondsUntilNext = JulianDate.secondsDifference(next, current);\n        sampling = secondsUntilNext > maximumStep;\n        if (sampling) {\n          sampleStepsToTake = Math.ceil(secondsUntilNext / maximumStep);\n          sampleStepsTaken = 0;\n          sampleStepSize = secondsUntilNext / Math.max(sampleStepsToTake, 2);\n          sampleStepsToTake = Math.max(sampleStepsToTake - 1, 1);\n        }\n      }\n      if (sampling && sampleStepsTaken < sampleStepsToTake) {\n        current = JulianDate.addSeconds(current, sampleStepSize, new JulianDate());\n        sampleStepsTaken++;\n        continue;\n      }\n    }\n    sampling = false;\n    t++;\n    current = times[t];\n  }\n\n  //Always step exactly on stop (but only use it if it exists.)\n  tmp = property.getValueInReferenceFrame(stop, referenceFrame, result[r]);\n  if (defined(tmp)) {\n    result[r++] = tmp;\n  }\n  return r;\n}\nfunction subSampleCallbackPositionProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n  let tmp;\n  let i = 0;\n  let index = startingIndex;\n  let time = start;\n  let steppedOnNow = !defined(updateTime) || JulianDate.lessThanOrEquals(updateTime, start) || JulianDate.greaterThanOrEquals(updateTime, stop);\n  while (JulianDate.lessThan(time, stop)) {\n    if (!steppedOnNow && JulianDate.greaterThanOrEquals(time, updateTime)) {\n      steppedOnNow = true;\n      tmp = property.getValueInReferenceFrame(updateTime, referenceFrame, result[index]);\n      if (defined(tmp)) {\n        result[index] = tmp;\n        index++;\n      }\n    }\n    tmp = property.getValueInReferenceFrame(time, referenceFrame, result[index]);\n    if (defined(tmp)) {\n      result[index] = tmp;\n      index++;\n    }\n    i++;\n    time = JulianDate.addSeconds(start, maximumStep * i, new JulianDate());\n  }\n  //Always sample stop.\n  tmp = property.getValueInReferenceFrame(stop, referenceFrame, result[index]);\n  if (defined(tmp)) {\n    result[index] = tmp;\n    index++;\n  }\n  return index;\n}\nfunction subSampleGenericProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n  let tmp;\n  let i = 0;\n  let index = startingIndex;\n  let time = start;\n  const stepSize = Math.max(maximumStep, 60);\n  let steppedOnNow = !defined(updateTime) || JulianDate.lessThanOrEquals(updateTime, start) || JulianDate.greaterThanOrEquals(updateTime, stop);\n  while (JulianDate.lessThan(time, stop)) {\n    if (!steppedOnNow && JulianDate.greaterThanOrEquals(time, updateTime)) {\n      steppedOnNow = true;\n      tmp = property.getValueInReferenceFrame(updateTime, referenceFrame, result[index]);\n      if (defined(tmp)) {\n        result[index] = tmp;\n        index++;\n      }\n    }\n    tmp = property.getValueInReferenceFrame(time, referenceFrame, result[index]);\n    if (defined(tmp)) {\n      result[index] = tmp;\n      index++;\n    }\n    i++;\n    time = JulianDate.addSeconds(start, stepSize * i, new JulianDate());\n  }\n  //Always sample stop.\n  tmp = property.getValueInReferenceFrame(stop, referenceFrame, result[index]);\n  if (defined(tmp)) {\n    result[index] = tmp;\n    index++;\n  }\n  return index;\n}\nfunction subSampleIntervalProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n  subSampleIntervalPropertyScratch.start = start;\n  subSampleIntervalPropertyScratch.stop = stop;\n  let index = startingIndex;\n  const intervals = property.intervals;\n  for (let i = 0; i < intervals.length; i++) {\n    const interval = intervals.get(i);\n    if (!TimeInterval.intersect(interval, subSampleIntervalPropertyScratch, scratchTimeInterval).isEmpty) {\n      let time = interval.start;\n      if (!interval.isStartIncluded) {\n        if (interval.isStopIncluded) {\n          time = interval.stop;\n        } else {\n          time = JulianDate.addSeconds(interval.start, JulianDate.secondsDifference(interval.stop, interval.start) / 2, new JulianDate());\n        }\n      }\n      const tmp = property.getValueInReferenceFrame(time, referenceFrame, result[index]);\n      if (defined(tmp)) {\n        result[index] = tmp;\n        index++;\n      }\n    }\n  }\n  return index;\n}\nfunction subSampleConstantProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n  const tmp = property.getValueInReferenceFrame(start, referenceFrame, result[startingIndex]);\n  if (defined(tmp)) {\n    result[startingIndex++] = tmp;\n  }\n  return startingIndex;\n}\nfunction subSampleCompositeProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n  subSampleCompositePropertyScratch.start = start;\n  subSampleCompositePropertyScratch.stop = stop;\n  let index = startingIndex;\n  const intervals = property.intervals;\n  for (let i = 0; i < intervals.length; i++) {\n    const interval = intervals.get(i);\n    if (!TimeInterval.intersect(interval, subSampleCompositePropertyScratch, scratchTimeInterval).isEmpty) {\n      const intervalStart = interval.start;\n      const intervalStop = interval.stop;\n      let sampleStart = start;\n      if (JulianDate.greaterThan(intervalStart, sampleStart)) {\n        sampleStart = intervalStart;\n      }\n      let sampleStop = stop;\n      if (JulianDate.lessThan(intervalStop, sampleStop)) {\n        sampleStop = intervalStop;\n      }\n      index = reallySubSample(interval.data, sampleStart, sampleStop, updateTime, referenceFrame, maximumStep, index, result);\n    }\n  }\n  return index;\n}\nfunction reallySubSample(property, start, stop, updateTime, referenceFrame, maximumStep, index, result) {\n  //Unwrap any references until we have the actual property.\n  while (property instanceof ReferenceProperty) {\n    property = property.resolvedProperty;\n  }\n  if (property instanceof SampledPositionProperty) {\n    const times = property._property._times;\n    index = subSampleSampledProperty(property, start, stop, times, updateTime, referenceFrame, maximumStep, index, result);\n  } else if (property instanceof CallbackPositionProperty) {\n    index = subSampleCallbackPositionProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n  } else if (property instanceof CompositePositionProperty) {\n    index = subSampleCompositeProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n  } else if (property instanceof TimeIntervalCollectionPositionProperty) {\n    index = subSampleIntervalProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n  } else if (property instanceof ConstantPositionProperty || property instanceof ScaledPositionProperty && Property.isConstant(property)) {\n    index = subSampleConstantProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n  } else {\n    //Fallback to generic sampling.\n    index = subSampleGenericProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n  }\n  return index;\n}\nfunction subSample(property, start, stop, updateTime, referenceFrame, maximumStep, result) {\n  if (!defined(result)) {\n    result = [];\n  }\n  const length = reallySubSample(property, start, stop, updateTime, referenceFrame, maximumStep, 0, result);\n  result.length = length;\n  return result;\n}\nconst toFixedScratch = new Matrix3();\nfunction PolylineUpdater(scene, referenceFrame) {\n  this._unusedIndexes = [];\n  this._polylineCollection = new PolylineCollection();\n  this._scene = scene;\n  this._referenceFrame = referenceFrame;\n  scene.primitives.add(this._polylineCollection);\n}\nPolylineUpdater.prototype.update = function (time) {\n  if (this._referenceFrame === ReferenceFrame.INERTIAL) {\n    const toFixed = Transforms.computeIcrfToCentralBodyFixedMatrix(time, toFixedScratch);\n    Matrix4.fromRotationTranslation(toFixed, Cartesian3.ZERO, this._polylineCollection.modelMatrix);\n  }\n};\nPolylineUpdater.prototype.updateObject = function (time, item) {\n  const entity = item.entity;\n  const pathGraphics = entity._path;\n  const positionProperty = entity._position;\n  let sampleStart;\n  let sampleStop;\n  const showProperty = pathGraphics._show;\n  let polyline = item.polyline;\n  let show = entity.isShowing && entity.isAvailable(time) && (!defined(showProperty) || showProperty.getValue(time));\n\n  //While we want to show the path, there may not actually be anything to show\n  //depending on lead/trail settings.  Compute the interval of the path to\n  //show and check against actual availability.\n  if (show) {\n    const leadTime = Property.getValueOrUndefined(pathGraphics._leadTime, time);\n    const trailTime = Property.getValueOrUndefined(pathGraphics._trailTime, time);\n    const availability = entity._availability;\n    const hasAvailability = defined(availability);\n    const hasLeadTime = defined(leadTime);\n    const hasTrailTime = defined(trailTime);\n\n    //Objects need to have either defined availability or both a lead and trail time in order to\n    //draw a path (since we can't draw \"infinite\" paths.\n    show = hasAvailability || hasLeadTime && hasTrailTime;\n\n    //The final step is to compute the actual start/stop times of the path to show.\n    //If current time is outside of the availability interval, there's a chance that\n    //we won't have to draw anything anyway.\n    if (show) {\n      if (hasTrailTime) {\n        sampleStart = JulianDate.addSeconds(time, -trailTime, new JulianDate());\n      }\n      if (hasLeadTime) {\n        sampleStop = JulianDate.addSeconds(time, leadTime, new JulianDate());\n      }\n      if (hasAvailability) {\n        const start = availability.start;\n        const stop = availability.stop;\n        if (!hasTrailTime || JulianDate.greaterThan(start, sampleStart)) {\n          sampleStart = start;\n        }\n        if (!hasLeadTime || JulianDate.lessThan(stop, sampleStop)) {\n          sampleStop = stop;\n        }\n      }\n      show = JulianDate.lessThan(sampleStart, sampleStop);\n    }\n  }\n  if (!show) {\n    //don't bother creating or updating anything else\n    if (defined(polyline)) {\n      this._unusedIndexes.push(item.index);\n      item.polyline = undefined;\n      polyline.show = false;\n      item.index = undefined;\n    }\n    return;\n  }\n  if (!defined(polyline)) {\n    const unusedIndexes = this._unusedIndexes;\n    const length = unusedIndexes.length;\n    if (length > 0) {\n      const index = unusedIndexes.pop();\n      polyline = this._polylineCollection.get(index);\n      item.index = index;\n    } else {\n      item.index = this._polylineCollection.length;\n      polyline = this._polylineCollection.add();\n    }\n    polyline.id = entity;\n    item.polyline = polyline;\n  }\n  const resolution = Property.getValueOrDefault(pathGraphics._resolution, time, defaultResolution);\n  polyline.show = true;\n  polyline.positions = subSample(positionProperty, sampleStart, sampleStop, time, this._referenceFrame, resolution, polyline.positions.slice());\n  polyline.material = MaterialProperty.getValue(time, pathGraphics._material, polyline.material);\n  polyline.width = Property.getValueOrDefault(pathGraphics._width, time, defaultWidth);\n  polyline.distanceDisplayCondition = Property.getValueOrUndefined(pathGraphics._distanceDisplayCondition, time, polyline.distanceDisplayCondition);\n};\nPolylineUpdater.prototype.removeObject = function (item) {\n  const polyline = item.polyline;\n  if (defined(polyline)) {\n    this._unusedIndexes.push(item.index);\n    item.polyline = undefined;\n    polyline.show = false;\n    polyline.id = undefined;\n    item.index = undefined;\n  }\n};\nPolylineUpdater.prototype.destroy = function () {\n  this._scene.primitives.remove(this._polylineCollection);\n  return destroyObject(this);\n};\n\n/**\n * A {@link Visualizer} which maps {@link Entity#path} to a {@link Polyline}.\n * @alias PathVisualizer\n * @constructor\n *\n * @param {Scene} scene The scene the primitives will be rendered in.\n * @param {EntityCollection} entityCollection The entityCollection to visualize.\n */\nfunction PathVisualizer(scene, entityCollection) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  if (!defined(entityCollection)) {\n    throw new DeveloperError(\"entityCollection is required.\");\n  }\n  //>>includeEnd('debug');\n\n  entityCollection.collectionChanged.addEventListener(PathVisualizer.prototype._onCollectionChanged, this);\n  this._scene = scene;\n  this._updaters = {};\n  this._entityCollection = entityCollection;\n  this._items = new AssociativeArray();\n  this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n}\n\n/**\n * Updates all of the primitives created by this visualizer to match their\n * Entity counterpart at the given time.\n *\n * @param {JulianDate} time The time to update to.\n * @returns {boolean} This function always returns true.\n */\nPathVisualizer.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(time)) {\n    throw new DeveloperError(\"time is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const updaters = this._updaters;\n  for (const key in updaters) {\n    if (updaters.hasOwnProperty(key)) {\n      updaters[key].update(time);\n    }\n  }\n  const items = this._items.values;\n  if (items.length === 0 && defined(this._updaters) && Object.keys(this._updaters).length > 0) {\n    for (const u in updaters) {\n      if (updaters.hasOwnProperty(u)) {\n        updaters[u].destroy();\n      }\n    }\n    this._updaters = {};\n  }\n  for (let i = 0, len = items.length; i < len; i++) {\n    const item = items[i];\n    const entity = item.entity;\n    const positionProperty = entity._position;\n    const lastUpdater = item.updater;\n    let frameToVisualize = ReferenceFrame.FIXED;\n    if (this._scene.mode === SceneMode.SCENE3D) {\n      frameToVisualize = positionProperty.referenceFrame;\n    }\n    let currentUpdater = this._updaters[frameToVisualize];\n    if (lastUpdater === currentUpdater && defined(currentUpdater)) {\n      currentUpdater.updateObject(time, item);\n      continue;\n    }\n    if (defined(lastUpdater)) {\n      lastUpdater.removeObject(item);\n    }\n    if (!defined(currentUpdater)) {\n      currentUpdater = new PolylineUpdater(this._scene, frameToVisualize);\n      currentUpdater.update(time);\n      this._updaters[frameToVisualize] = currentUpdater;\n    }\n    item.updater = currentUpdater;\n    if (defined(currentUpdater)) {\n      currentUpdater.updateObject(time, item);\n    }\n  }\n  return true;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n */\nPathVisualizer.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes and destroys all primitives created by this instance.\n */\nPathVisualizer.prototype.destroy = function () {\n  this._entityCollection.collectionChanged.removeEventListener(PathVisualizer.prototype._onCollectionChanged, this);\n  const updaters = this._updaters;\n  for (const key in updaters) {\n    if (updaters.hasOwnProperty(key)) {\n      updaters[key].destroy();\n    }\n  }\n  return destroyObject(this);\n};\nPathVisualizer.prototype._onCollectionChanged = function (entityCollection, added, removed, changed) {\n  let i;\n  let entity;\n  let item;\n  const items = this._items;\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    if (defined(entity._path) && defined(entity._position)) {\n      items.set(entity.id, new EntityData(entity));\n    }\n  }\n  for (i = changed.length - 1; i > -1; i--) {\n    entity = changed[i];\n    if (defined(entity._path) && defined(entity._position)) {\n      if (!items.contains(entity.id)) {\n        items.set(entity.id, new EntityData(entity));\n      }\n    } else {\n      item = items.get(entity.id);\n      if (defined(item)) {\n        if (defined(item.updater)) {\n          item.updater.removeObject(item);\n        }\n        items.remove(entity.id);\n      }\n    }\n  }\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    item = items.get(entity.id);\n    if (defined(item)) {\n      if (defined(item.updater)) {\n        item.updater.removeObject(item);\n      }\n      items.remove(entity.id);\n    }\n  }\n};\n\n//for testing\nPathVisualizer._subSample = subSample;\nexport default PathVisualizer;","map":{"version":3,"names":["AssociativeArray","Cartesian3","defined","destroyObject","DeveloperError","JulianDate","Matrix3","Matrix4","ReferenceFrame","TimeInterval","Transforms","PolylineCollection","SceneMode","CallbackPositionProperty","CompositePositionProperty","ConstantPositionProperty","MaterialProperty","Property","ReferenceProperty","SampledPositionProperty","ScaledPositionProperty","TimeIntervalCollectionPositionProperty","defaultResolution","defaultWidth","scratchTimeInterval","subSampleCompositePropertyScratch","subSampleIntervalPropertyScratch","EntityData","entity","polyline","undefined","index","updater","subSampleSampledProperty","property","start","stop","times","updateTime","referenceFrame","maximumStep","startingIndex","result","r","tmp","getValueInReferenceFrame","steppedOnNow","lessThanOrEquals","greaterThanOrEquals","t","len","length","current","loopStop","sampling","sampleStepsToTake","sampleStepsTaken","sampleStepSize","greaterThan","lessThan","equals","next","secondsUntilNext","secondsDifference","Math","ceil","max","addSeconds","subSampleCallbackPositionProperty","i","time","subSampleGenericProperty","stepSize","subSampleIntervalProperty","intervals","interval","get","intersect","isEmpty","isStartIncluded","isStopIncluded","subSampleConstantProperty","subSampleCompositeProperty","intervalStart","intervalStop","sampleStart","sampleStop","reallySubSample","data","resolvedProperty","_property","_times","isConstant","subSample","toFixedScratch","PolylineUpdater","scene","_unusedIndexes","_polylineCollection","_scene","_referenceFrame","primitives","add","prototype","update","INERTIAL","toFixed","computeIcrfToCentralBodyFixedMatrix","fromRotationTranslation","ZERO","modelMatrix","updateObject","item","pathGraphics","_path","positionProperty","_position","showProperty","_show","show","isShowing","isAvailable","getValue","leadTime","getValueOrUndefined","_leadTime","trailTime","_trailTime","availability","_availability","hasAvailability","hasLeadTime","hasTrailTime","push","unusedIndexes","pop","id","resolution","getValueOrDefault","_resolution","positions","slice","material","_material","width","_width","distanceDisplayCondition","_distanceDisplayCondition","removeObject","destroy","remove","PathVisualizer","entityCollection","collectionChanged","addEventListener","_onCollectionChanged","_updaters","_entityCollection","_items","values","updaters","key","hasOwnProperty","items","Object","keys","u","lastUpdater","frameToVisualize","FIXED","mode","SCENE3D","currentUpdater","isDestroyed","removeEventListener","added","removed","changed","set","contains","_subSample"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/DataSources/PathVisualizer.js"],"sourcesContent":["import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport ReferenceFrame from \"../Core/ReferenceFrame.js\";\nimport TimeInterval from \"../Core/TimeInterval.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport PolylineCollection from \"../Scene/PolylineCollection.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport CallbackPositionProperty from \"./CallbackPositionProperty.js\";\nimport CompositePositionProperty from \"./CompositePositionProperty.js\";\nimport ConstantPositionProperty from \"./ConstantPositionProperty.js\";\nimport MaterialProperty from \"./MaterialProperty.js\";\nimport Property from \"./Property.js\";\nimport ReferenceProperty from \"./ReferenceProperty.js\";\nimport SampledPositionProperty from \"./SampledPositionProperty.js\";\nimport ScaledPositionProperty from \"./ScaledPositionProperty.js\";\nimport TimeIntervalCollectionPositionProperty from \"./TimeIntervalCollectionPositionProperty.js\";\n\nconst defaultResolution = 60.0;\nconst defaultWidth = 1.0;\n\nconst scratchTimeInterval = new TimeInterval();\nconst subSampleCompositePropertyScratch = new TimeInterval();\nconst subSampleIntervalPropertyScratch = new TimeInterval();\n\nfunction EntityData(entity) {\n  this.entity = entity;\n  this.polyline = undefined;\n  this.index = undefined;\n  this.updater = undefined;\n}\n\nfunction subSampleSampledProperty(\n  property,\n  start,\n  stop,\n  times,\n  updateTime,\n  referenceFrame,\n  maximumStep,\n  startingIndex,\n  result,\n) {\n  let r = startingIndex;\n  //Always step exactly on start (but only use it if it exists.)\n  let tmp;\n  tmp = property.getValueInReferenceFrame(start, referenceFrame, result[r]);\n  if (defined(tmp)) {\n    result[r++] = tmp;\n  }\n\n  let steppedOnNow =\n    !defined(updateTime) ||\n    JulianDate.lessThanOrEquals(updateTime, start) ||\n    JulianDate.greaterThanOrEquals(updateTime, stop);\n\n  //Iterate over all interval times and add the ones that fall in our\n  //time range.  Note that times can contain data outside of\n  //the intervals range.  This is by design for use with interpolation.\n  let t = 0;\n  const len = times.length;\n  let current = times[t];\n  const loopStop = stop;\n  let sampling = false;\n  let sampleStepsToTake;\n  let sampleStepsTaken;\n  let sampleStepSize;\n\n  while (t < len) {\n    if (!steppedOnNow && JulianDate.greaterThanOrEquals(current, updateTime)) {\n      tmp = property.getValueInReferenceFrame(\n        updateTime,\n        referenceFrame,\n        result[r],\n      );\n      if (defined(tmp)) {\n        result[r++] = tmp;\n      }\n      steppedOnNow = true;\n    }\n    if (\n      JulianDate.greaterThan(current, start) &&\n      JulianDate.lessThan(current, loopStop) &&\n      !current.equals(updateTime)\n    ) {\n      tmp = property.getValueInReferenceFrame(\n        current,\n        referenceFrame,\n        result[r],\n      );\n      if (defined(tmp)) {\n        result[r++] = tmp;\n      }\n    }\n\n    if (t < len - 1) {\n      if (maximumStep > 0 && !sampling) {\n        const next = times[t + 1];\n        const secondsUntilNext = JulianDate.secondsDifference(next, current);\n        sampling = secondsUntilNext > maximumStep;\n\n        if (sampling) {\n          sampleStepsToTake = Math.ceil(secondsUntilNext / maximumStep);\n          sampleStepsTaken = 0;\n          sampleStepSize = secondsUntilNext / Math.max(sampleStepsToTake, 2);\n          sampleStepsToTake = Math.max(sampleStepsToTake - 1, 1);\n        }\n      }\n\n      if (sampling && sampleStepsTaken < sampleStepsToTake) {\n        current = JulianDate.addSeconds(\n          current,\n          sampleStepSize,\n          new JulianDate(),\n        );\n        sampleStepsTaken++;\n        continue;\n      }\n    }\n    sampling = false;\n    t++;\n    current = times[t];\n  }\n\n  //Always step exactly on stop (but only use it if it exists.)\n  tmp = property.getValueInReferenceFrame(stop, referenceFrame, result[r]);\n  if (defined(tmp)) {\n    result[r++] = tmp;\n  }\n\n  return r;\n}\n\nfunction subSampleCallbackPositionProperty(\n  property,\n  start,\n  stop,\n  updateTime,\n  referenceFrame,\n  maximumStep,\n  startingIndex,\n  result,\n) {\n  let tmp;\n  let i = 0;\n  let index = startingIndex;\n  let time = start;\n  let steppedOnNow =\n    !defined(updateTime) ||\n    JulianDate.lessThanOrEquals(updateTime, start) ||\n    JulianDate.greaterThanOrEquals(updateTime, stop);\n  while (JulianDate.lessThan(time, stop)) {\n    if (!steppedOnNow && JulianDate.greaterThanOrEquals(time, updateTime)) {\n      steppedOnNow = true;\n      tmp = property.getValueInReferenceFrame(\n        updateTime,\n        referenceFrame,\n        result[index],\n      );\n      if (defined(tmp)) {\n        result[index] = tmp;\n        index++;\n      }\n    }\n    tmp = property.getValueInReferenceFrame(\n      time,\n      referenceFrame,\n      result[index],\n    );\n    if (defined(tmp)) {\n      result[index] = tmp;\n      index++;\n    }\n    i++;\n    time = JulianDate.addSeconds(start, maximumStep * i, new JulianDate());\n  }\n  //Always sample stop.\n  tmp = property.getValueInReferenceFrame(stop, referenceFrame, result[index]);\n  if (defined(tmp)) {\n    result[index] = tmp;\n    index++;\n  }\n  return index;\n}\n\nfunction subSampleGenericProperty(\n  property,\n  start,\n  stop,\n  updateTime,\n  referenceFrame,\n  maximumStep,\n  startingIndex,\n  result,\n) {\n  let tmp;\n  let i = 0;\n  let index = startingIndex;\n  let time = start;\n  const stepSize = Math.max(maximumStep, 60);\n  let steppedOnNow =\n    !defined(updateTime) ||\n    JulianDate.lessThanOrEquals(updateTime, start) ||\n    JulianDate.greaterThanOrEquals(updateTime, stop);\n  while (JulianDate.lessThan(time, stop)) {\n    if (!steppedOnNow && JulianDate.greaterThanOrEquals(time, updateTime)) {\n      steppedOnNow = true;\n      tmp = property.getValueInReferenceFrame(\n        updateTime,\n        referenceFrame,\n        result[index],\n      );\n      if (defined(tmp)) {\n        result[index] = tmp;\n        index++;\n      }\n    }\n    tmp = property.getValueInReferenceFrame(\n      time,\n      referenceFrame,\n      result[index],\n    );\n    if (defined(tmp)) {\n      result[index] = tmp;\n      index++;\n    }\n    i++;\n    time = JulianDate.addSeconds(start, stepSize * i, new JulianDate());\n  }\n  //Always sample stop.\n  tmp = property.getValueInReferenceFrame(stop, referenceFrame, result[index]);\n  if (defined(tmp)) {\n    result[index] = tmp;\n    index++;\n  }\n  return index;\n}\n\nfunction subSampleIntervalProperty(\n  property,\n  start,\n  stop,\n  updateTime,\n  referenceFrame,\n  maximumStep,\n  startingIndex,\n  result,\n) {\n  subSampleIntervalPropertyScratch.start = start;\n  subSampleIntervalPropertyScratch.stop = stop;\n\n  let index = startingIndex;\n  const intervals = property.intervals;\n  for (let i = 0; i < intervals.length; i++) {\n    const interval = intervals.get(i);\n    if (\n      !TimeInterval.intersect(\n        interval,\n        subSampleIntervalPropertyScratch,\n        scratchTimeInterval,\n      ).isEmpty\n    ) {\n      let time = interval.start;\n      if (!interval.isStartIncluded) {\n        if (interval.isStopIncluded) {\n          time = interval.stop;\n        } else {\n          time = JulianDate.addSeconds(\n            interval.start,\n            JulianDate.secondsDifference(interval.stop, interval.start) / 2,\n            new JulianDate(),\n          );\n        }\n      }\n      const tmp = property.getValueInReferenceFrame(\n        time,\n        referenceFrame,\n        result[index],\n      );\n      if (defined(tmp)) {\n        result[index] = tmp;\n        index++;\n      }\n    }\n  }\n  return index;\n}\n\nfunction subSampleConstantProperty(\n  property,\n  start,\n  stop,\n  updateTime,\n  referenceFrame,\n  maximumStep,\n  startingIndex,\n  result,\n) {\n  const tmp = property.getValueInReferenceFrame(\n    start,\n    referenceFrame,\n    result[startingIndex],\n  );\n  if (defined(tmp)) {\n    result[startingIndex++] = tmp;\n  }\n  return startingIndex;\n}\n\nfunction subSampleCompositeProperty(\n  property,\n  start,\n  stop,\n  updateTime,\n  referenceFrame,\n  maximumStep,\n  startingIndex,\n  result,\n) {\n  subSampleCompositePropertyScratch.start = start;\n  subSampleCompositePropertyScratch.stop = stop;\n\n  let index = startingIndex;\n  const intervals = property.intervals;\n  for (let i = 0; i < intervals.length; i++) {\n    const interval = intervals.get(i);\n    if (\n      !TimeInterval.intersect(\n        interval,\n        subSampleCompositePropertyScratch,\n        scratchTimeInterval,\n      ).isEmpty\n    ) {\n      const intervalStart = interval.start;\n      const intervalStop = interval.stop;\n\n      let sampleStart = start;\n      if (JulianDate.greaterThan(intervalStart, sampleStart)) {\n        sampleStart = intervalStart;\n      }\n\n      let sampleStop = stop;\n      if (JulianDate.lessThan(intervalStop, sampleStop)) {\n        sampleStop = intervalStop;\n      }\n\n      index = reallySubSample(\n        interval.data,\n        sampleStart,\n        sampleStop,\n        updateTime,\n        referenceFrame,\n        maximumStep,\n        index,\n        result,\n      );\n    }\n  }\n  return index;\n}\n\nfunction reallySubSample(\n  property,\n  start,\n  stop,\n  updateTime,\n  referenceFrame,\n  maximumStep,\n  index,\n  result,\n) {\n  //Unwrap any references until we have the actual property.\n  while (property instanceof ReferenceProperty) {\n    property = property.resolvedProperty;\n  }\n\n  if (property instanceof SampledPositionProperty) {\n    const times = property._property._times;\n    index = subSampleSampledProperty(\n      property,\n      start,\n      stop,\n      times,\n      updateTime,\n      referenceFrame,\n      maximumStep,\n      index,\n      result,\n    );\n  } else if (property instanceof CallbackPositionProperty) {\n    index = subSampleCallbackPositionProperty(\n      property,\n      start,\n      stop,\n      updateTime,\n      referenceFrame,\n      maximumStep,\n      index,\n      result,\n    );\n  } else if (property instanceof CompositePositionProperty) {\n    index = subSampleCompositeProperty(\n      property,\n      start,\n      stop,\n      updateTime,\n      referenceFrame,\n      maximumStep,\n      index,\n      result,\n    );\n  } else if (property instanceof TimeIntervalCollectionPositionProperty) {\n    index = subSampleIntervalProperty(\n      property,\n      start,\n      stop,\n      updateTime,\n      referenceFrame,\n      maximumStep,\n      index,\n      result,\n    );\n  } else if (\n    property instanceof ConstantPositionProperty ||\n    (property instanceof ScaledPositionProperty &&\n      Property.isConstant(property))\n  ) {\n    index = subSampleConstantProperty(\n      property,\n      start,\n      stop,\n      updateTime,\n      referenceFrame,\n      maximumStep,\n      index,\n      result,\n    );\n  } else {\n    //Fallback to generic sampling.\n    index = subSampleGenericProperty(\n      property,\n      start,\n      stop,\n      updateTime,\n      referenceFrame,\n      maximumStep,\n      index,\n      result,\n    );\n  }\n  return index;\n}\n\nfunction subSample(\n  property,\n  start,\n  stop,\n  updateTime,\n  referenceFrame,\n  maximumStep,\n  result,\n) {\n  if (!defined(result)) {\n    result = [];\n  }\n\n  const length = reallySubSample(\n    property,\n    start,\n    stop,\n    updateTime,\n    referenceFrame,\n    maximumStep,\n    0,\n    result,\n  );\n  result.length = length;\n  return result;\n}\n\nconst toFixedScratch = new Matrix3();\nfunction PolylineUpdater(scene, referenceFrame) {\n  this._unusedIndexes = [];\n  this._polylineCollection = new PolylineCollection();\n  this._scene = scene;\n  this._referenceFrame = referenceFrame;\n  scene.primitives.add(this._polylineCollection);\n}\n\nPolylineUpdater.prototype.update = function (time) {\n  if (this._referenceFrame === ReferenceFrame.INERTIAL) {\n    const toFixed = Transforms.computeIcrfToCentralBodyFixedMatrix(\n      time,\n      toFixedScratch,\n    );\n    Matrix4.fromRotationTranslation(\n      toFixed,\n      Cartesian3.ZERO,\n      this._polylineCollection.modelMatrix,\n    );\n  }\n};\n\nPolylineUpdater.prototype.updateObject = function (time, item) {\n  const entity = item.entity;\n  const pathGraphics = entity._path;\n  const positionProperty = entity._position;\n\n  let sampleStart;\n  let sampleStop;\n  const showProperty = pathGraphics._show;\n  let polyline = item.polyline;\n  let show =\n    entity.isShowing &&\n    entity.isAvailable(time) &&\n    (!defined(showProperty) || showProperty.getValue(time));\n\n  //While we want to show the path, there may not actually be anything to show\n  //depending on lead/trail settings.  Compute the interval of the path to\n  //show and check against actual availability.\n  if (show) {\n    const leadTime = Property.getValueOrUndefined(pathGraphics._leadTime, time);\n    const trailTime = Property.getValueOrUndefined(\n      pathGraphics._trailTime,\n      time,\n    );\n    const availability = entity._availability;\n    const hasAvailability = defined(availability);\n    const hasLeadTime = defined(leadTime);\n    const hasTrailTime = defined(trailTime);\n\n    //Objects need to have either defined availability or both a lead and trail time in order to\n    //draw a path (since we can't draw \"infinite\" paths.\n    show = hasAvailability || (hasLeadTime && hasTrailTime);\n\n    //The final step is to compute the actual start/stop times of the path to show.\n    //If current time is outside of the availability interval, there's a chance that\n    //we won't have to draw anything anyway.\n    if (show) {\n      if (hasTrailTime) {\n        sampleStart = JulianDate.addSeconds(time, -trailTime, new JulianDate());\n      }\n      if (hasLeadTime) {\n        sampleStop = JulianDate.addSeconds(time, leadTime, new JulianDate());\n      }\n\n      if (hasAvailability) {\n        const start = availability.start;\n        const stop = availability.stop;\n\n        if (!hasTrailTime || JulianDate.greaterThan(start, sampleStart)) {\n          sampleStart = start;\n        }\n\n        if (!hasLeadTime || JulianDate.lessThan(stop, sampleStop)) {\n          sampleStop = stop;\n        }\n      }\n      show = JulianDate.lessThan(sampleStart, sampleStop);\n    }\n  }\n\n  if (!show) {\n    //don't bother creating or updating anything else\n    if (defined(polyline)) {\n      this._unusedIndexes.push(item.index);\n      item.polyline = undefined;\n      polyline.show = false;\n      item.index = undefined;\n    }\n    return;\n  }\n\n  if (!defined(polyline)) {\n    const unusedIndexes = this._unusedIndexes;\n    const length = unusedIndexes.length;\n    if (length > 0) {\n      const index = unusedIndexes.pop();\n      polyline = this._polylineCollection.get(index);\n      item.index = index;\n    } else {\n      item.index = this._polylineCollection.length;\n      polyline = this._polylineCollection.add();\n    }\n    polyline.id = entity;\n    item.polyline = polyline;\n  }\n\n  const resolution = Property.getValueOrDefault(\n    pathGraphics._resolution,\n    time,\n    defaultResolution,\n  );\n\n  polyline.show = true;\n  polyline.positions = subSample(\n    positionProperty,\n    sampleStart,\n    sampleStop,\n    time,\n    this._referenceFrame,\n    resolution,\n    polyline.positions.slice(),\n  );\n  polyline.material = MaterialProperty.getValue(\n    time,\n    pathGraphics._material,\n    polyline.material,\n  );\n  polyline.width = Property.getValueOrDefault(\n    pathGraphics._width,\n    time,\n    defaultWidth,\n  );\n  polyline.distanceDisplayCondition = Property.getValueOrUndefined(\n    pathGraphics._distanceDisplayCondition,\n    time,\n    polyline.distanceDisplayCondition,\n  );\n};\n\nPolylineUpdater.prototype.removeObject = function (item) {\n  const polyline = item.polyline;\n  if (defined(polyline)) {\n    this._unusedIndexes.push(item.index);\n    item.polyline = undefined;\n    polyline.show = false;\n    polyline.id = undefined;\n    item.index = undefined;\n  }\n};\n\nPolylineUpdater.prototype.destroy = function () {\n  this._scene.primitives.remove(this._polylineCollection);\n  return destroyObject(this);\n};\n\n/**\n * A {@link Visualizer} which maps {@link Entity#path} to a {@link Polyline}.\n * @alias PathVisualizer\n * @constructor\n *\n * @param {Scene} scene The scene the primitives will be rendered in.\n * @param {EntityCollection} entityCollection The entityCollection to visualize.\n */\nfunction PathVisualizer(scene, entityCollection) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  if (!defined(entityCollection)) {\n    throw new DeveloperError(\"entityCollection is required.\");\n  }\n  //>>includeEnd('debug');\n\n  entityCollection.collectionChanged.addEventListener(\n    PathVisualizer.prototype._onCollectionChanged,\n    this,\n  );\n\n  this._scene = scene;\n  this._updaters = {};\n  this._entityCollection = entityCollection;\n  this._items = new AssociativeArray();\n\n  this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n}\n\n/**\n * Updates all of the primitives created by this visualizer to match their\n * Entity counterpart at the given time.\n *\n * @param {JulianDate} time The time to update to.\n * @returns {boolean} This function always returns true.\n */\nPathVisualizer.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(time)) {\n    throw new DeveloperError(\"time is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const updaters = this._updaters;\n  for (const key in updaters) {\n    if (updaters.hasOwnProperty(key)) {\n      updaters[key].update(time);\n    }\n  }\n\n  const items = this._items.values;\n  if (\n    items.length === 0 &&\n    defined(this._updaters) &&\n    Object.keys(this._updaters).length > 0\n  ) {\n    for (const u in updaters) {\n      if (updaters.hasOwnProperty(u)) {\n        updaters[u].destroy();\n      }\n    }\n    this._updaters = {};\n  }\n\n  for (let i = 0, len = items.length; i < len; i++) {\n    const item = items[i];\n    const entity = item.entity;\n    const positionProperty = entity._position;\n\n    const lastUpdater = item.updater;\n\n    let frameToVisualize = ReferenceFrame.FIXED;\n    if (this._scene.mode === SceneMode.SCENE3D) {\n      frameToVisualize = positionProperty.referenceFrame;\n    }\n\n    let currentUpdater = this._updaters[frameToVisualize];\n\n    if (lastUpdater === currentUpdater && defined(currentUpdater)) {\n      currentUpdater.updateObject(time, item);\n      continue;\n    }\n\n    if (defined(lastUpdater)) {\n      lastUpdater.removeObject(item);\n    }\n\n    if (!defined(currentUpdater)) {\n      currentUpdater = new PolylineUpdater(this._scene, frameToVisualize);\n      currentUpdater.update(time);\n      this._updaters[frameToVisualize] = currentUpdater;\n    }\n\n    item.updater = currentUpdater;\n    if (defined(currentUpdater)) {\n      currentUpdater.updateObject(time, item);\n    }\n  }\n  return true;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n */\nPathVisualizer.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes and destroys all primitives created by this instance.\n */\nPathVisualizer.prototype.destroy = function () {\n  this._entityCollection.collectionChanged.removeEventListener(\n    PathVisualizer.prototype._onCollectionChanged,\n    this,\n  );\n\n  const updaters = this._updaters;\n  for (const key in updaters) {\n    if (updaters.hasOwnProperty(key)) {\n      updaters[key].destroy();\n    }\n  }\n\n  return destroyObject(this);\n};\n\nPathVisualizer.prototype._onCollectionChanged = function (\n  entityCollection,\n  added,\n  removed,\n  changed,\n) {\n  let i;\n  let entity;\n  let item;\n  const items = this._items;\n\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    if (defined(entity._path) && defined(entity._position)) {\n      items.set(entity.id, new EntityData(entity));\n    }\n  }\n\n  for (i = changed.length - 1; i > -1; i--) {\n    entity = changed[i];\n    if (defined(entity._path) && defined(entity._position)) {\n      if (!items.contains(entity.id)) {\n        items.set(entity.id, new EntityData(entity));\n      }\n    } else {\n      item = items.get(entity.id);\n      if (defined(item)) {\n        if (defined(item.updater)) {\n          item.updater.removeObject(item);\n        }\n        items.remove(entity.id);\n      }\n    }\n  }\n\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    item = items.get(entity.id);\n    if (defined(item)) {\n      if (defined(item.updater)) {\n        item.updater.removeObject(item);\n      }\n      items.remove(entity.id);\n    }\n  }\n};\n\n//for testing\nPathVisualizer._subSample = subSample;\nexport default PathVisualizer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}