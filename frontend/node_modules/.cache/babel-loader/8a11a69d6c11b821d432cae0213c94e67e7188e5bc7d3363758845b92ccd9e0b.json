{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport defined from \"../Core/defined.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\n\n/**\n * This class implements an I3S Field which is custom data attached\n * to nodes\n * @alias I3SField\n * @internalConstructor\n * @privateParam {I3SNode} parent The parent of that geometry\n * @privateParam {object} storageInfo The structure containing the storage info of the field\n */\nfunction I3SField(parent, storageInfo) {\n  this._storageInfo = storageInfo;\n  this._parent = parent;\n  this._dataProvider = parent._dataProvider;\n  this._loadPromise = undefined;\n  const uri = `attributes/${storageInfo.key}/0`;\n  if (defined(this._parent._nodeIndex)) {\n    this._resource = this._parent._layer.resource.getDerivedResource({\n      url: `nodes/${this._parent._data.mesh.attribute.resource}/${uri}`\n    });\n  } else {\n    this._resource = this._parent.resource.getDerivedResource({\n      url: uri\n    });\n  }\n}\nObject.defineProperties(I3SField.prototype, {\n  /**\n   * Gets the resource for the fields\n   * @memberof I3SField.prototype\n   * @type {Resource}\n   * @readonly\n   */\n  resource: {\n    get: function () {\n      return this._resource;\n    }\n  },\n  /**\n   * Gets the header for this field.\n   * @memberof I3SField.prototype\n   * @type {object}\n   * @readonly\n   */\n  header: {\n    get: function () {\n      return this._header;\n    }\n  },\n  /**\n   * Gets the values for this field.\n   * @memberof I3SField.prototype\n   * @type {object}\n   * @readonly\n   */\n  values: {\n    get: function () {\n      if (defined(this._values)) {\n        // attribute data can be stored either as values or as object identifiers\n        if (defined(this._values.attributeValues)) {\n          return this._values.attributeValues;\n        }\n        if (defined(this._values.objectIds)) {\n          return this._values.objectIds;\n        }\n      }\n      return [];\n    }\n  },\n  /**\n   * Gets the name for the field.\n   * @memberof I3SField.prototype\n   * @type {string}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._storageInfo.name;\n    }\n  }\n});\nfunction getNumericTypeSize(type) {\n  if (type === \"UInt8\" || type === \"Int8\") {\n    return 1;\n  } else if (type === \"UInt16\" || type === \"Int16\") {\n    return 2;\n  } else if (type === \"UInt32\" || type === \"Int32\" || type === \"Oid32\" || type === \"Float32\") {\n    return 4;\n  } else if (type === \"UInt64\" || type === \"Int64\" || type === \"Float64\") {\n    return 8;\n  }\n\n  // Not a numeric type\n  return 0;\n}\nfunction getValueTypeSize(type) {\n  if (type === \"String\") {\n    return 1;\n  }\n  return getNumericTypeSize(type);\n}\nasync function load(field) {\n  const data = await field._dataProvider._loadBinary(field._resource);\n  const dataView = new DataView(data);\n  field._data = data;\n  field._validateHeader(dataView);\n  const headerSize = field._parseHeader(dataView);\n  const offset = field._getBodyOffset(headerSize);\n  field._validateBody(dataView, offset);\n  field._parseBody(dataView, offset);\n}\n\n/**\n * Loads the content.\n * @returns {Promise<void>} A promise that is resolved when the field data is loaded\n */\nI3SField.prototype.load = function () {\n  if (defined(this._loadPromise)) {\n    return this._loadPromise;\n  }\n  this._loadPromise = load(this).catch(function (error) {\n    console.error(error);\n  });\n  return this._loadPromise;\n};\n\n/**\n * @private\n */\nI3SField.prototype._parseValue = function (dataView, type, offset) {\n  let value;\n  if (type === \"UInt8\") {\n    value = dataView.getUint8(offset);\n    offset += 1;\n  } else if (type === \"Int8\") {\n    value = dataView.getInt8(offset);\n    offset += 1;\n  } else if (type === \"UInt16\") {\n    value = dataView.getUint16(offset, true);\n    offset += 2;\n  } else if (type === \"Int16\") {\n    value = dataView.getInt16(offset, true);\n    offset += 2;\n  } else if (type === \"UInt32\") {\n    value = dataView.getUint32(offset, true);\n    offset += 4;\n  } else if (type === \"Oid32\") {\n    value = dataView.getUint32(offset, true);\n    offset += 4;\n  } else if (type === \"Int32\") {\n    value = dataView.getInt32(offset, true);\n    offset += 4;\n  } else if (type === \"UInt64\") {\n    const left = dataView.getUint32(offset, true);\n    const right = dataView.getUint32(offset + 4, true);\n    value = left + Math.pow(2, 32) * right;\n    offset += 8;\n  } else if (type === \"Int64\") {\n    const left = dataView.getUint32(offset, true);\n    const right = dataView.getUint32(offset + 4, true);\n    if (right < Math.pow(2, 31)) {\n      // Positive number\n      value = left + Math.pow(2, 32) * right;\n    } else {\n      // Negative\n      value = left + Math.pow(2, 32) * (right - Math.pow(2, 32));\n    }\n    offset += 8;\n  } else if (type === \"Float32\") {\n    value = dataView.getFloat32(offset, true);\n    offset += 4;\n  } else if (type === \"Float64\") {\n    value = dataView.getFloat64(offset, true);\n    offset += 8;\n  } else if (type === \"String\") {\n    value = String.fromCharCode(dataView.getUint8(offset));\n    offset += 1;\n  }\n  return {\n    value: value,\n    offset: offset\n  };\n};\n\n/**\n * @private\n */\nI3SField.prototype._parseHeader = function (dataView) {\n  let offset = 0;\n  this._header = {};\n  for (let itemIndex = 0; itemIndex < this._storageInfo.header.length; itemIndex++) {\n    const item = this._storageInfo.header[itemIndex];\n    const parsedValue = this._parseValue(dataView, item.valueType, offset);\n    this._header[item.property] = parsedValue.value;\n    offset = parsedValue.offset;\n  }\n  return offset;\n};\n\n/**\n * @private\n */\nI3SField.prototype._parseBody = function (dataView, offset) {\n  this._values = {};\n  for (let itemIndex = 0; itemIndex < this._storageInfo.ordering.length; itemIndex++) {\n    const orderingValue = this._storageInfo.ordering[itemIndex];\n    // all strings in the ordering array correspond to the property name, except ObjectIds\n    const item = orderingValue === \"ObjectIds\" ? \"objectIds\" : orderingValue;\n    const desc = this._storageInfo[item];\n    if (defined(desc)) {\n      this._values[item] = [];\n      for (let index = 0; index < this._header.count; ++index) {\n        if (desc.valueType !== \"String\") {\n          const parsedValue = this._parseValue(dataView, desc.valueType, offset);\n          this._values[item].push(parsedValue.value);\n          offset = parsedValue.offset;\n        } else {\n          const stringLen = this._values.attributeByteCounts[index];\n          let stringContent = \"\";\n          for (let cIndex = 0; cIndex < stringLen; ++cIndex) {\n            const curParsedValue = this._parseValue(dataView, desc.valueType, offset);\n            if (curParsedValue.value.charCodeAt(0) !== 0) {\n              stringContent += curParsedValue.value;\n            }\n            offset = curParsedValue.offset;\n          }\n          // We skip the last character of the string since it's a null terminator\n          this._values[item].push(stringContent);\n        }\n      }\n    }\n  }\n};\n\n/**\n * @private\n */\nI3SField.prototype._getBodyOffset = function (headerSize) {\n  let valueSize = 0;\n  if (defined(this._storageInfo.attributeValues)) {\n    valueSize = getNumericTypeSize(this._storageInfo.attributeValues.valueType);\n  } else if (defined(this._storageInfo.objectIds)) {\n    valueSize = getNumericTypeSize(this._storageInfo.objectIds.valueType);\n  }\n  if (valueSize > 0) {\n    // Values will be padded to align the addresses with the data size\n    return Math.ceil(headerSize / valueSize) * valueSize;\n  }\n  return headerSize;\n};\n\n/**\n * @private\n */\nI3SField.prototype._validateHeader = function (dataView) {\n  let headerSize = 0;\n  for (let itemIndex = 0; itemIndex < this._storageInfo.header.length; itemIndex++) {\n    const item = this._storageInfo.header[itemIndex];\n    headerSize += getValueTypeSize(item.valueType);\n  }\n  if (dataView.byteLength < headerSize) {\n    throw new RuntimeError(`Invalid attribute buffer size (field: ${this.name}, header: ${headerSize}, actual: ${dataView.byteLength})`);\n  }\n};\n\n/**\n * @private\n */\nI3SField.prototype._validateBody = function (dataView, offset) {\n  if (!defined(this._header.count)) {\n    throw new RuntimeError(`Invalid attribute buffer (field: ${this.name}, count is missing)`);\n  }\n  let attributeByteCountsOffset;\n  for (let itemIndex = 0; itemIndex < this._storageInfo.ordering.length && offset < dataView.byteLength; itemIndex++) {\n    const orderingValue = this._storageInfo.ordering[itemIndex];\n    // all strings in the ordering array correspond to the property name, except ObjectIds\n    const item = orderingValue === \"ObjectIds\" ? \"objectIds\" : orderingValue;\n    const desc = this._storageInfo[item];\n    if (defined(desc)) {\n      if (desc.valueType !== \"String\") {\n        if (item === \"attributeByteCounts\") {\n          attributeByteCountsOffset = offset;\n        }\n        const valueSize = getNumericTypeSize(desc.valueType);\n        offset += valueSize * this._header.count;\n      } else {\n        if (!defined(attributeByteCountsOffset)) {\n          throw new RuntimeError(`Invalid attribute buffer (field: ${this.name}, attributeByteCounts is missing)`);\n        }\n        for (let index = 0; index < this._header.count && offset < dataView.byteLength; ++index) {\n          const parsedValue = this._parseValue(dataView, this._storageInfo.attributeByteCounts.valueType, attributeByteCountsOffset);\n          offset += parsedValue.value;\n          attributeByteCountsOffset = parsedValue.offset;\n        }\n      }\n    } else {\n      throw new RuntimeError(`Invalid attribute buffer (field: ${this.name}, ${item} is missing)`);\n    }\n  }\n  if (dataView.byteLength < offset) {\n    throw new RuntimeError(`Invalid attribute buffer size (field: ${this.name}, expected: ${offset}, actual: ${dataView.byteLength})`);\n  }\n};\nexport default I3SField;","map":{"version":3,"names":["defined","RuntimeError","I3SField","parent","storageInfo","_storageInfo","_parent","_dataProvider","_loadPromise","undefined","uri","key","_nodeIndex","_resource","_layer","resource","getDerivedResource","url","_data","mesh","attribute","Object","defineProperties","prototype","get","header","_header","values","_values","attributeValues","objectIds","name","getNumericTypeSize","type","getValueTypeSize","load","field","data","_loadBinary","dataView","DataView","_validateHeader","headerSize","_parseHeader","offset","_getBodyOffset","_validateBody","_parseBody","catch","error","console","_parseValue","value","getUint8","getInt8","getUint16","getInt16","getUint32","getInt32","left","right","Math","pow","getFloat32","getFloat64","String","fromCharCode","itemIndex","length","item","parsedValue","valueType","property","ordering","orderingValue","desc","index","count","push","stringLen","attributeByteCounts","stringContent","cIndex","curParsedValue","charCodeAt","valueSize","ceil","byteLength","attributeByteCountsOffset"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/I3SField.js"],"sourcesContent":["import defined from \"../Core/defined.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\n\n/**\n * This class implements an I3S Field which is custom data attached\n * to nodes\n * @alias I3SField\n * @internalConstructor\n * @privateParam {I3SNode} parent The parent of that geometry\n * @privateParam {object} storageInfo The structure containing the storage info of the field\n */\nfunction I3SField(parent, storageInfo) {\n  this._storageInfo = storageInfo;\n  this._parent = parent;\n  this._dataProvider = parent._dataProvider;\n  this._loadPromise = undefined;\n  const uri = `attributes/${storageInfo.key}/0`;\n\n  if (defined(this._parent._nodeIndex)) {\n    this._resource = this._parent._layer.resource.getDerivedResource({\n      url: `nodes/${this._parent._data.mesh.attribute.resource}/${uri}`,\n    });\n  } else {\n    this._resource = this._parent.resource.getDerivedResource({ url: uri });\n  }\n}\n\nObject.defineProperties(I3SField.prototype, {\n  /**\n   * Gets the resource for the fields\n   * @memberof I3SField.prototype\n   * @type {Resource}\n   * @readonly\n   */\n  resource: {\n    get: function () {\n      return this._resource;\n    },\n  },\n  /**\n   * Gets the header for this field.\n   * @memberof I3SField.prototype\n   * @type {object}\n   * @readonly\n   */\n  header: {\n    get: function () {\n      return this._header;\n    },\n  },\n  /**\n   * Gets the values for this field.\n   * @memberof I3SField.prototype\n   * @type {object}\n   * @readonly\n   */\n  values: {\n    get: function () {\n      if (defined(this._values)) {\n        // attribute data can be stored either as values or as object identifiers\n        if (defined(this._values.attributeValues)) {\n          return this._values.attributeValues;\n        }\n        if (defined(this._values.objectIds)) {\n          return this._values.objectIds;\n        }\n      }\n      return [];\n    },\n  },\n  /**\n   * Gets the name for the field.\n   * @memberof I3SField.prototype\n   * @type {string}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._storageInfo.name;\n    },\n  },\n});\n\nfunction getNumericTypeSize(type) {\n  if (type === \"UInt8\" || type === \"Int8\") {\n    return 1;\n  } else if (type === \"UInt16\" || type === \"Int16\") {\n    return 2;\n  } else if (\n    type === \"UInt32\" ||\n    type === \"Int32\" ||\n    type === \"Oid32\" ||\n    type === \"Float32\"\n  ) {\n    return 4;\n  } else if (type === \"UInt64\" || type === \"Int64\" || type === \"Float64\") {\n    return 8;\n  }\n\n  // Not a numeric type\n  return 0;\n}\n\nfunction getValueTypeSize(type) {\n  if (type === \"String\") {\n    return 1;\n  }\n  return getNumericTypeSize(type);\n}\n\nasync function load(field) {\n  const data = await field._dataProvider._loadBinary(field._resource);\n  const dataView = new DataView(data);\n  field._data = data;\n  field._validateHeader(dataView);\n  const headerSize = field._parseHeader(dataView);\n  const offset = field._getBodyOffset(headerSize);\n  field._validateBody(dataView, offset);\n  field._parseBody(dataView, offset);\n}\n\n/**\n * Loads the content.\n * @returns {Promise<void>} A promise that is resolved when the field data is loaded\n */\nI3SField.prototype.load = function () {\n  if (defined(this._loadPromise)) {\n    return this._loadPromise;\n  }\n\n  this._loadPromise = load(this).catch(function (error) {\n    console.error(error);\n  });\n  return this._loadPromise;\n};\n\n/**\n * @private\n */\nI3SField.prototype._parseValue = function (dataView, type, offset) {\n  let value;\n  if (type === \"UInt8\") {\n    value = dataView.getUint8(offset);\n    offset += 1;\n  } else if (type === \"Int8\") {\n    value = dataView.getInt8(offset);\n    offset += 1;\n  } else if (type === \"UInt16\") {\n    value = dataView.getUint16(offset, true);\n    offset += 2;\n  } else if (type === \"Int16\") {\n    value = dataView.getInt16(offset, true);\n    offset += 2;\n  } else if (type === \"UInt32\") {\n    value = dataView.getUint32(offset, true);\n    offset += 4;\n  } else if (type === \"Oid32\") {\n    value = dataView.getUint32(offset, true);\n    offset += 4;\n  } else if (type === \"Int32\") {\n    value = dataView.getInt32(offset, true);\n    offset += 4;\n  } else if (type === \"UInt64\") {\n    const left = dataView.getUint32(offset, true);\n    const right = dataView.getUint32(offset + 4, true);\n    value = left + Math.pow(2, 32) * right;\n    offset += 8;\n  } else if (type === \"Int64\") {\n    const left = dataView.getUint32(offset, true);\n    const right = dataView.getUint32(offset + 4, true);\n    if (right < Math.pow(2, 31)) {\n      // Positive number\n      value = left + Math.pow(2, 32) * right;\n    } else {\n      // Negative\n      value = left + Math.pow(2, 32) * (right - Math.pow(2, 32));\n    }\n\n    offset += 8;\n  } else if (type === \"Float32\") {\n    value = dataView.getFloat32(offset, true);\n    offset += 4;\n  } else if (type === \"Float64\") {\n    value = dataView.getFloat64(offset, true);\n    offset += 8;\n  } else if (type === \"String\") {\n    value = String.fromCharCode(dataView.getUint8(offset));\n    offset += 1;\n  }\n\n  return {\n    value: value,\n    offset: offset,\n  };\n};\n\n/**\n * @private\n */\nI3SField.prototype._parseHeader = function (dataView) {\n  let offset = 0;\n  this._header = {};\n  for (\n    let itemIndex = 0;\n    itemIndex < this._storageInfo.header.length;\n    itemIndex++\n  ) {\n    const item = this._storageInfo.header[itemIndex];\n    const parsedValue = this._parseValue(dataView, item.valueType, offset);\n    this._header[item.property] = parsedValue.value;\n    offset = parsedValue.offset;\n  }\n  return offset;\n};\n\n/**\n * @private\n */\nI3SField.prototype._parseBody = function (dataView, offset) {\n  this._values = {};\n  for (\n    let itemIndex = 0;\n    itemIndex < this._storageInfo.ordering.length;\n    itemIndex++\n  ) {\n    const orderingValue = this._storageInfo.ordering[itemIndex];\n    // all strings in the ordering array correspond to the property name, except ObjectIds\n    const item = orderingValue === \"ObjectIds\" ? \"objectIds\" : orderingValue;\n    const desc = this._storageInfo[item];\n    if (defined(desc)) {\n      this._values[item] = [];\n      for (let index = 0; index < this._header.count; ++index) {\n        if (desc.valueType !== \"String\") {\n          const parsedValue = this._parseValue(\n            dataView,\n            desc.valueType,\n            offset,\n          );\n          this._values[item].push(parsedValue.value);\n          offset = parsedValue.offset;\n        } else {\n          const stringLen = this._values.attributeByteCounts[index];\n          let stringContent = \"\";\n          for (let cIndex = 0; cIndex < stringLen; ++cIndex) {\n            const curParsedValue = this._parseValue(\n              dataView,\n              desc.valueType,\n              offset,\n            );\n            if (curParsedValue.value.charCodeAt(0) !== 0) {\n              stringContent += curParsedValue.value;\n            }\n            offset = curParsedValue.offset;\n          }\n          // We skip the last character of the string since it's a null terminator\n          this._values[item].push(stringContent);\n        }\n      }\n    }\n  }\n};\n\n/**\n * @private\n */\nI3SField.prototype._getBodyOffset = function (headerSize) {\n  let valueSize = 0;\n  if (defined(this._storageInfo.attributeValues)) {\n    valueSize = getNumericTypeSize(this._storageInfo.attributeValues.valueType);\n  } else if (defined(this._storageInfo.objectIds)) {\n    valueSize = getNumericTypeSize(this._storageInfo.objectIds.valueType);\n  }\n  if (valueSize > 0) {\n    // Values will be padded to align the addresses with the data size\n    return Math.ceil(headerSize / valueSize) * valueSize;\n  }\n  return headerSize;\n};\n\n/**\n * @private\n */\nI3SField.prototype._validateHeader = function (dataView) {\n  let headerSize = 0;\n  for (\n    let itemIndex = 0;\n    itemIndex < this._storageInfo.header.length;\n    itemIndex++\n  ) {\n    const item = this._storageInfo.header[itemIndex];\n    headerSize += getValueTypeSize(item.valueType);\n  }\n  if (dataView.byteLength < headerSize) {\n    throw new RuntimeError(\n      `Invalid attribute buffer size (field: ${this.name}, header: ${headerSize}, actual: ${dataView.byteLength})`,\n    );\n  }\n};\n\n/**\n * @private\n */\nI3SField.prototype._validateBody = function (dataView, offset) {\n  if (!defined(this._header.count)) {\n    throw new RuntimeError(\n      `Invalid attribute buffer (field: ${this.name}, count is missing)`,\n    );\n  }\n  let attributeByteCountsOffset;\n  for (\n    let itemIndex = 0;\n    itemIndex < this._storageInfo.ordering.length &&\n    offset < dataView.byteLength;\n    itemIndex++\n  ) {\n    const orderingValue = this._storageInfo.ordering[itemIndex];\n    // all strings in the ordering array correspond to the property name, except ObjectIds\n    const item = orderingValue === \"ObjectIds\" ? \"objectIds\" : orderingValue;\n    const desc = this._storageInfo[item];\n    if (defined(desc)) {\n      if (desc.valueType !== \"String\") {\n        if (item === \"attributeByteCounts\") {\n          attributeByteCountsOffset = offset;\n        }\n        const valueSize = getNumericTypeSize(desc.valueType);\n        offset += valueSize * this._header.count;\n      } else {\n        if (!defined(attributeByteCountsOffset)) {\n          throw new RuntimeError(\n            `Invalid attribute buffer (field: ${this.name}, attributeByteCounts is missing)`,\n          );\n        }\n        for (\n          let index = 0;\n          index < this._header.count && offset < dataView.byteLength;\n          ++index\n        ) {\n          const parsedValue = this._parseValue(\n            dataView,\n            this._storageInfo.attributeByteCounts.valueType,\n            attributeByteCountsOffset,\n          );\n          offset += parsedValue.value;\n          attributeByteCountsOffset = parsedValue.offset;\n        }\n      }\n    } else {\n      throw new RuntimeError(\n        `Invalid attribute buffer (field: ${this.name}, ${item} is missing)`,\n      );\n    }\n  }\n  if (dataView.byteLength < offset) {\n    throw new RuntimeError(\n      `Invalid attribute buffer size (field: ${this.name}, expected: ${offset}, actual: ${dataView.byteLength})`,\n    );\n  }\n};\n\nexport default I3SField;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}