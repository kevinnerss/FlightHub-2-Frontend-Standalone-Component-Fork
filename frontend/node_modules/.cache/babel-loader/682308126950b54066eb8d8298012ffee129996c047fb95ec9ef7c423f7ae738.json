{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Intersect from \"./Intersect.js\";\nimport Plane from \"./Plane.js\";\n\n/**\n * The culling volume defined by planes.\n *\n * @alias CullingVolume\n * @constructor\n *\n * @param {Cartesian4[]} [planes] An array of clipping planes.\n */\nfunction CullingVolume(planes) {\n  /**\n   * Each plane is represented by a Cartesian4 object, where the x, y, and z components\n   * define the unit vector normal to the plane, and the w component is the distance of the\n   * plane from the origin.\n   * @type {Cartesian4[]}\n   * @default []\n   */\n  this.planes = planes ?? [];\n}\nconst faces = [new Cartesian3(), new Cartesian3(), new Cartesian3()];\nCartesian3.clone(Cartesian3.UNIT_X, faces[0]);\nCartesian3.clone(Cartesian3.UNIT_Y, faces[1]);\nCartesian3.clone(Cartesian3.UNIT_Z, faces[2]);\nconst scratchPlaneCenter = new Cartesian3();\nconst scratchPlaneNormal = new Cartesian3();\nconst scratchPlane = new Plane(new Cartesian3(1.0, 0.0, 0.0), 0.0);\n\n/**\n * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.\n * The planes are aligned to the x, y, and z axes in world coordinates.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere used to create the culling volume.\n * @param {CullingVolume} [result] The object onto which to store the result.\n * @returns {CullingVolume} The culling volume created from the bounding sphere.\n */\nCullingVolume.fromBoundingSphere = function (boundingSphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new CullingVolume();\n  }\n  const length = faces.length;\n  const planes = result.planes;\n  planes.length = 2 * length;\n  const center = boundingSphere.center;\n  const radius = boundingSphere.radius;\n  let planeIndex = 0;\n  for (let i = 0; i < length; ++i) {\n    const faceNormal = faces[i];\n    let plane0 = planes[planeIndex];\n    let plane1 = planes[planeIndex + 1];\n    if (!defined(plane0)) {\n      plane0 = planes[planeIndex] = new Cartesian4();\n    }\n    if (!defined(plane1)) {\n      plane1 = planes[planeIndex + 1] = new Cartesian4();\n    }\n    Cartesian3.multiplyByScalar(faceNormal, -radius, scratchPlaneCenter);\n    Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);\n    plane0.x = faceNormal.x;\n    plane0.y = faceNormal.y;\n    plane0.z = faceNormal.z;\n    plane0.w = -Cartesian3.dot(faceNormal, scratchPlaneCenter);\n    Cartesian3.multiplyByScalar(faceNormal, radius, scratchPlaneCenter);\n    Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);\n    plane1.x = -faceNormal.x;\n    plane1.y = -faceNormal.y;\n    plane1.z = -faceNormal.z;\n    plane1.w = -Cartesian3.dot(Cartesian3.negate(faceNormal, scratchPlaneNormal), scratchPlaneCenter);\n    planeIndex += 2;\n  }\n  return result;\n};\n\n/**\n * Determines whether a bounding volume intersects the culling volume.\n *\n * @param {object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.\n * @returns {Intersect}  Intersect.OUTSIDE, Intersect.INTERSECTING, or Intersect.INSIDE.\n */\nCullingVolume.prototype.computeVisibility = function (boundingVolume) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingVolume)) {\n    throw new DeveloperError(\"boundingVolume is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const planes = this.planes;\n  let intersecting = false;\n  for (let k = 0, len = planes.length; k < len; ++k) {\n    const result = boundingVolume.intersectPlane(Plane.fromCartesian4(planes[k], scratchPlane));\n    if (result === Intersect.OUTSIDE) {\n      return Intersect.OUTSIDE;\n    } else if (result === Intersect.INTERSECTING) {\n      intersecting = true;\n    }\n  }\n  return intersecting ? Intersect.INTERSECTING : Intersect.INSIDE;\n};\n\n/**\n * Determines whether a bounding volume intersects the culling volume.\n *\n * @param {object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.\n * @param {number} parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling\n *                                 volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then\n *                                 the parent (and therefore this) volume is completely inside plane[planeIndex]\n *                                 and that plane check can be skipped.\n * @returns {number} A plane mask as described above (which can be applied to this boundingVolume's children).\n *\n * @private\n */\nCullingVolume.prototype.computeVisibilityWithPlaneMask = function (boundingVolume, parentPlaneMask) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingVolume)) {\n    throw new DeveloperError(\"boundingVolume is required.\");\n  }\n  if (!defined(parentPlaneMask)) {\n    throw new DeveloperError(\"parentPlaneMask is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (parentPlaneMask === CullingVolume.MASK_OUTSIDE || parentPlaneMask === CullingVolume.MASK_INSIDE) {\n    // parent is completely outside or completely inside, so this child is as well.\n    return parentPlaneMask;\n  }\n\n  // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n  // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n  let mask = CullingVolume.MASK_INSIDE;\n  const planes = this.planes;\n  for (let k = 0, len = planes.length; k < len; ++k) {\n    // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n    const flag = k < 31 ? 1 << k : 0;\n    if (k < 31 && (parentPlaneMask & flag) === 0) {\n      // boundingVolume is known to be INSIDE this plane.\n      continue;\n    }\n    const result = boundingVolume.intersectPlane(Plane.fromCartesian4(planes[k], scratchPlane));\n    if (result === Intersect.OUTSIDE) {\n      return CullingVolume.MASK_OUTSIDE;\n    } else if (result === Intersect.INTERSECTING) {\n      mask |= flag;\n    }\n  }\n  return mask;\n};\n\n/**\n * For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value\n * represents the case where the object bounding volume is entirely outside the culling volume.\n *\n * @type {number}\n * @private\n */\nCullingVolume.MASK_OUTSIDE = 0xffffffff;\n\n/**\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n * represents the case where the object bounding volume is entirely inside the culling volume.\n *\n * @type {number}\n * @private\n */\nCullingVolume.MASK_INSIDE = 0x00000000;\n\n/**\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n * represents the case where the object bounding volume (may) intersect all planes of the culling volume.\n *\n * @type {number}\n * @private\n */\nCullingVolume.MASK_INDETERMINATE = 0x7fffffff;\nexport default CullingVolume;","map":{"version":3,"names":["Cartesian3","Cartesian4","defined","DeveloperError","Intersect","Plane","CullingVolume","planes","faces","clone","UNIT_X","UNIT_Y","UNIT_Z","scratchPlaneCenter","scratchPlaneNormal","scratchPlane","fromBoundingSphere","boundingSphere","result","length","center","radius","planeIndex","i","faceNormal","plane0","plane1","multiplyByScalar","add","x","y","z","w","dot","negate","prototype","computeVisibility","boundingVolume","intersecting","k","len","intersectPlane","fromCartesian4","OUTSIDE","INTERSECTING","INSIDE","computeVisibilityWithPlaneMask","parentPlaneMask","MASK_OUTSIDE","MASK_INSIDE","mask","flag","MASK_INDETERMINATE"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/CullingVolume.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Intersect from \"./Intersect.js\";\nimport Plane from \"./Plane.js\";\n\n/**\n * The culling volume defined by planes.\n *\n * @alias CullingVolume\n * @constructor\n *\n * @param {Cartesian4[]} [planes] An array of clipping planes.\n */\nfunction CullingVolume(planes) {\n  /**\n   * Each plane is represented by a Cartesian4 object, where the x, y, and z components\n   * define the unit vector normal to the plane, and the w component is the distance of the\n   * plane from the origin.\n   * @type {Cartesian4[]}\n   * @default []\n   */\n  this.planes = planes ?? [];\n}\n\nconst faces = [new Cartesian3(), new Cartesian3(), new Cartesian3()];\nCartesian3.clone(Cartesian3.UNIT_X, faces[0]);\nCartesian3.clone(Cartesian3.UNIT_Y, faces[1]);\nCartesian3.clone(Cartesian3.UNIT_Z, faces[2]);\n\nconst scratchPlaneCenter = new Cartesian3();\nconst scratchPlaneNormal = new Cartesian3();\nconst scratchPlane = new Plane(new Cartesian3(1.0, 0.0, 0.0), 0.0);\n\n/**\n * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.\n * The planes are aligned to the x, y, and z axes in world coordinates.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere used to create the culling volume.\n * @param {CullingVolume} [result] The object onto which to store the result.\n * @returns {CullingVolume} The culling volume created from the bounding sphere.\n */\nCullingVolume.fromBoundingSphere = function (boundingSphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new CullingVolume();\n  }\n\n  const length = faces.length;\n  const planes = result.planes;\n  planes.length = 2 * length;\n\n  const center = boundingSphere.center;\n  const radius = boundingSphere.radius;\n\n  let planeIndex = 0;\n\n  for (let i = 0; i < length; ++i) {\n    const faceNormal = faces[i];\n\n    let plane0 = planes[planeIndex];\n    let plane1 = planes[planeIndex + 1];\n\n    if (!defined(plane0)) {\n      plane0 = planes[planeIndex] = new Cartesian4();\n    }\n    if (!defined(plane1)) {\n      plane1 = planes[planeIndex + 1] = new Cartesian4();\n    }\n\n    Cartesian3.multiplyByScalar(faceNormal, -radius, scratchPlaneCenter);\n    Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);\n\n    plane0.x = faceNormal.x;\n    plane0.y = faceNormal.y;\n    plane0.z = faceNormal.z;\n    plane0.w = -Cartesian3.dot(faceNormal, scratchPlaneCenter);\n\n    Cartesian3.multiplyByScalar(faceNormal, radius, scratchPlaneCenter);\n    Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);\n\n    plane1.x = -faceNormal.x;\n    plane1.y = -faceNormal.y;\n    plane1.z = -faceNormal.z;\n    plane1.w = -Cartesian3.dot(\n      Cartesian3.negate(faceNormal, scratchPlaneNormal),\n      scratchPlaneCenter,\n    );\n\n    planeIndex += 2;\n  }\n\n  return result;\n};\n\n/**\n * Determines whether a bounding volume intersects the culling volume.\n *\n * @param {object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.\n * @returns {Intersect}  Intersect.OUTSIDE, Intersect.INTERSECTING, or Intersect.INSIDE.\n */\nCullingVolume.prototype.computeVisibility = function (boundingVolume) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingVolume)) {\n    throw new DeveloperError(\"boundingVolume is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const planes = this.planes;\n  let intersecting = false;\n  for (let k = 0, len = planes.length; k < len; ++k) {\n    const result = boundingVolume.intersectPlane(\n      Plane.fromCartesian4(planes[k], scratchPlane),\n    );\n    if (result === Intersect.OUTSIDE) {\n      return Intersect.OUTSIDE;\n    } else if (result === Intersect.INTERSECTING) {\n      intersecting = true;\n    }\n  }\n\n  return intersecting ? Intersect.INTERSECTING : Intersect.INSIDE;\n};\n\n/**\n * Determines whether a bounding volume intersects the culling volume.\n *\n * @param {object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.\n * @param {number} parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling\n *                                 volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then\n *                                 the parent (and therefore this) volume is completely inside plane[planeIndex]\n *                                 and that plane check can be skipped.\n * @returns {number} A plane mask as described above (which can be applied to this boundingVolume's children).\n *\n * @private\n */\nCullingVolume.prototype.computeVisibilityWithPlaneMask = function (\n  boundingVolume,\n  parentPlaneMask,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingVolume)) {\n    throw new DeveloperError(\"boundingVolume is required.\");\n  }\n  if (!defined(parentPlaneMask)) {\n    throw new DeveloperError(\"parentPlaneMask is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (\n    parentPlaneMask === CullingVolume.MASK_OUTSIDE ||\n    parentPlaneMask === CullingVolume.MASK_INSIDE\n  ) {\n    // parent is completely outside or completely inside, so this child is as well.\n    return parentPlaneMask;\n  }\n\n  // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n  // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n  let mask = CullingVolume.MASK_INSIDE;\n\n  const planes = this.planes;\n  for (let k = 0, len = planes.length; k < len; ++k) {\n    // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n    const flag = k < 31 ? 1 << k : 0;\n    if (k < 31 && (parentPlaneMask & flag) === 0) {\n      // boundingVolume is known to be INSIDE this plane.\n      continue;\n    }\n\n    const result = boundingVolume.intersectPlane(\n      Plane.fromCartesian4(planes[k], scratchPlane),\n    );\n    if (result === Intersect.OUTSIDE) {\n      return CullingVolume.MASK_OUTSIDE;\n    } else if (result === Intersect.INTERSECTING) {\n      mask |= flag;\n    }\n  }\n\n  return mask;\n};\n\n/**\n * For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value\n * represents the case where the object bounding volume is entirely outside the culling volume.\n *\n * @type {number}\n * @private\n */\nCullingVolume.MASK_OUTSIDE = 0xffffffff;\n\n/**\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n * represents the case where the object bounding volume is entirely inside the culling volume.\n *\n * @type {number}\n * @private\n */\nCullingVolume.MASK_INSIDE = 0x00000000;\n\n/**\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n * represents the case where the object bounding volume (may) intersect all planes of the culling volume.\n *\n * @type {number}\n * @private\n */\nCullingVolume.MASK_INDETERMINATE = 0x7fffffff;\nexport default CullingVolume;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}