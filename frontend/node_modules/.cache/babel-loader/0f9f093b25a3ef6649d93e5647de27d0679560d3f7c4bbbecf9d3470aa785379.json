{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"// See IntersectionUtils.glsl for the definitions of Ray, NO_HIT, Intersections,\\n\\\n// RayShapeIntersection, setSurfaceIntersection, setShapeIntersection,\\n\\\n// intersectIntersections\\n\\\n// See IntersectLongitude.glsl for the definitions of intersectHalfPlane,\\n\\\n// intersectFlippedWedge, intersectRegularWedge\\n\\\n\\n\\\n/* Cylinder defines (set in Scene/VoxelCylinderShape.js)\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_ANGLE\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO\\n\\\n\\n\\\n#define CYLINDER_INTERSECTION_INDEX_RADIUS_MAX\\n\\\n#define CYLINDER_INTERSECTION_INDEX_RADIUS_MIN\\n\\\n#define CYLINDER_INTERSECTION_INDEX_ANGLE\\n\\\n*/\\n\\\n\\n\\\n// Cylinder uniforms\\n\\\nuniform vec2 u_cylinderRenderRadiusMinMax;\\n\\\n#if defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE)\\n\\\n    uniform vec2 u_cylinderRenderAngleMinMax;\\n\\\n#endif\\n\\\n\\n\\\nuniform sampler2D u_renderBoundPlanesTexture;\\n\\\n\\n\\\nRayShapeIntersection intersectBoundPlanes(in Ray ray) {\\n\\\n    vec4 lastEntry = vec4(ray.dir, -INF_HIT);\\n\\\n    vec4 firstExit = vec4(-ray.dir, +INF_HIT);\\n\\\n    for (int i = 0; i < 2; i++) {\\n\\\n        vec4 boundPlane = getBoundPlane(u_renderBoundPlanesTexture, i);\\n\\\n        vec4 intersection = intersectPlane(ray, boundPlane);\\n\\\n        if (dot(ray.dir, boundPlane.xyz) < 0.0) {\\n\\\n            lastEntry = intersection.w > lastEntry.w ? intersection : lastEntry;\\n\\\n        } else {\\n\\\n            firstExit = intersection.w < firstExit.w ? intersection: firstExit;\\n\\\n        }\\n\\\n    }\\n\\\n\\n\\\n    if (lastEntry.w < firstExit.w) {\\n\\\n        return RayShapeIntersection(lastEntry, firstExit);\\n\\\n    } else {\\n\\\n        return RayShapeIntersection(vec4(-ray.dir, NO_HIT), vec4(ray.dir, NO_HIT));\\n\\\n    }\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Find the intersection of a ray with a right cylindrical surface of a given radius\\n\\\n * about the z-axis.\\n\\\n */\\n\\\nRayShapeIntersection intersectCylinder(in Ray ray, in float radius, in bool convex)\\n\\\n{\\n\\\n    vec2 position = ray.pos.xy;\\n\\\n    vec2 direction = ray.dir.xy;\\n\\\n\\n\\\n    float a = dot(direction, direction);\\n\\\n    float b = dot(position, direction);\\n\\\n    float c = dot(position, position) - radius * radius;\\n\\\n    float determinant = b * b - a * c;\\n\\\n\\n\\\n    if (determinant < 0.0) {\\n\\\n        vec4 miss = vec4(normalize(ray.dir), NO_HIT);\\n\\\n        return RayShapeIntersection(miss, miss);\\n\\\n    }\\n\\\n\\n\\\n    determinant = sqrt(determinant);\\n\\\n    float t1 = (-b - determinant) / a;\\n\\\n    float t2 = (-b + determinant) / a;\\n\\\n    float signFlip = convex ? 1.0 : -1.0;\\n\\\n    vec3 normal1 = vec3((position + t1 * direction) * signFlip, 0.0);\\n\\\n    vec3 normal2 = vec3((position + t2 * direction) * signFlip, 0.0);\\n\\\n    // Return normals in eye coordinates\\n\\\n    vec4 intersect1 = vec4(normalize(czm_normal * normal1), t1);\\n\\\n    vec4 intersect2 = vec4(normalize(czm_normal * normal2), t2);\\n\\\n\\n\\\n    return RayShapeIntersection(intersect1, intersect2);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Find the intersection of a ray with a right cylindrical solid of given\\n\\\n * radius and height bounds. NOTE: The shape is assumed to be convex.\\n\\\n */\\n\\\nRayShapeIntersection intersectBoundedCylinder(in Ray ray, in Ray rayEC, in float radius)\\n\\\n{\\n\\\n    RayShapeIntersection cylinderIntersection = intersectCylinder(ray, radius, true);\\n\\\n    RayShapeIntersection heightBoundsIntersection = intersectBoundPlanes(rayEC);\\n\\\n    return intersectIntersections(ray, cylinderIntersection, heightBoundsIntersection);\\n\\\n}\\n\\\n\\n\\\nvoid intersectShape(in Ray ray, in Ray rayEC, inout Intersections ix)\\n\\\n{\\n\\\n    RayShapeIntersection outerIntersect = intersectBoundedCylinder(ray, rayEC, u_cylinderRenderRadiusMinMax.y);\\n\\\n\\n\\\n    setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_RADIUS_MAX, outerIntersect);\\n\\\n\\n\\\n    if (outerIntersect.entry.w == NO_HIT) {\\n\\\n        return;\\n\\\n    }\\n\\\n\\n\\\n    #if defined(CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT)\\n\\\n        // When the cylinder is perfectly thin it's necessary to sandwich the\\n\\\n        // inner cylinder intersection inside the outer cylinder intersection.\\n\\\n\\n\\\n        // Without this special case,\\n\\\n        // [outerMin, outerMax, innerMin, innerMax] will bubble sort to\\n\\\n        // [outerMin, innerMin, outerMax, innerMax] which will cause the back\\n\\\n        // side of the cylinder to be invisible because it will think the ray\\n\\\n        // is still inside the inner (negative) cylinder after exiting the\\n\\\n        // outer (positive) cylinder.\\n\\\n\\n\\\n        // With this special case,\\n\\\n        // [outerMin, innerMin, innerMax, outerMax] will bubble sort to\\n\\\n        // [outerMin, innerMin, innerMax, outerMax] which will work correctly.\\n\\\n\\n\\\n        // Note: If initializeIntersections() changes its sorting function\\n\\\n        // from bubble sort to something else, this code may need to change.\\n\\\n        RayShapeIntersection innerIntersect = intersectCylinder(ray, 1.0, false);\\n\\\n        setSurfaceIntersection(ix, 0, outerIntersect.entry, true, true);  // positive, enter\\n\\\n        setSurfaceIntersection(ix, 1, innerIntersect.entry, false, true); // negative, enter\\n\\\n        setSurfaceIntersection(ix, 2, innerIntersect.exit, false, false); // negative, exit\\n\\\n        setSurfaceIntersection(ix, 3, outerIntersect.exit, true, false);  // positive, exit\\n\\\n    #elif defined(CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN)\\n\\\n        RayShapeIntersection innerIntersect = intersectCylinder(ray, u_cylinderRenderRadiusMinMax.x, false);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_RADIUS_MIN, innerIntersect);\\n\\\n    #endif\\n\\\n\\n\\\n    #if defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF)\\n\\\n        RayShapeIntersection wedgeIntersect = intersectRegularWedge(ray, u_cylinderRenderAngleMinMax);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE, wedgeIntersect);\\n\\\n    #elif defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF)\\n\\\n        RayShapeIntersection wedgeIntersects[2];\\n\\\n        intersectFlippedWedge(ray, u_cylinderRenderAngleMinMax, wedgeIntersects);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 0, wedgeIntersects[0]);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 1, wedgeIntersects[1]);\\n\\\n    #elif defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO)\\n\\\n        RayShapeIntersection wedgeIntersects[2];\\n\\\n        intersectHalfPlane(ray, u_cylinderRenderAngleMinMax.x, wedgeIntersects);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 0, wedgeIntersects[0]);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 1, wedgeIntersects[1]);\\n\\\n    #endif\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Shaders/Voxels/IntersectCylinder.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"// See IntersectionUtils.glsl for the definitions of Ray, NO_HIT, Intersections,\\n\\\n// RayShapeIntersection, setSurfaceIntersection, setShapeIntersection,\\n\\\n// intersectIntersections\\n\\\n// See IntersectLongitude.glsl for the definitions of intersectHalfPlane,\\n\\\n// intersectFlippedWedge, intersectRegularWedge\\n\\\n\\n\\\n/* Cylinder defines (set in Scene/VoxelCylinderShape.js)\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_ANGLE\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF\\n\\\n#define CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO\\n\\\n\\n\\\n#define CYLINDER_INTERSECTION_INDEX_RADIUS_MAX\\n\\\n#define CYLINDER_INTERSECTION_INDEX_RADIUS_MIN\\n\\\n#define CYLINDER_INTERSECTION_INDEX_ANGLE\\n\\\n*/\\n\\\n\\n\\\n// Cylinder uniforms\\n\\\nuniform vec2 u_cylinderRenderRadiusMinMax;\\n\\\n#if defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE)\\n\\\n    uniform vec2 u_cylinderRenderAngleMinMax;\\n\\\n#endif\\n\\\n\\n\\\nuniform sampler2D u_renderBoundPlanesTexture;\\n\\\n\\n\\\nRayShapeIntersection intersectBoundPlanes(in Ray ray) {\\n\\\n    vec4 lastEntry = vec4(ray.dir, -INF_HIT);\\n\\\n    vec4 firstExit = vec4(-ray.dir, +INF_HIT);\\n\\\n    for (int i = 0; i < 2; i++) {\\n\\\n        vec4 boundPlane = getBoundPlane(u_renderBoundPlanesTexture, i);\\n\\\n        vec4 intersection = intersectPlane(ray, boundPlane);\\n\\\n        if (dot(ray.dir, boundPlane.xyz) < 0.0) {\\n\\\n            lastEntry = intersection.w > lastEntry.w ? intersection : lastEntry;\\n\\\n        } else {\\n\\\n            firstExit = intersection.w < firstExit.w ? intersection: firstExit;\\n\\\n        }\\n\\\n    }\\n\\\n\\n\\\n    if (lastEntry.w < firstExit.w) {\\n\\\n        return RayShapeIntersection(lastEntry, firstExit);\\n\\\n    } else {\\n\\\n        return RayShapeIntersection(vec4(-ray.dir, NO_HIT), vec4(ray.dir, NO_HIT));\\n\\\n    }\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Find the intersection of a ray with a right cylindrical surface of a given radius\\n\\\n * about the z-axis.\\n\\\n */\\n\\\nRayShapeIntersection intersectCylinder(in Ray ray, in float radius, in bool convex)\\n\\\n{\\n\\\n    vec2 position = ray.pos.xy;\\n\\\n    vec2 direction = ray.dir.xy;\\n\\\n\\n\\\n    float a = dot(direction, direction);\\n\\\n    float b = dot(position, direction);\\n\\\n    float c = dot(position, position) - radius * radius;\\n\\\n    float determinant = b * b - a * c;\\n\\\n\\n\\\n    if (determinant < 0.0) {\\n\\\n        vec4 miss = vec4(normalize(ray.dir), NO_HIT);\\n\\\n        return RayShapeIntersection(miss, miss);\\n\\\n    }\\n\\\n\\n\\\n    determinant = sqrt(determinant);\\n\\\n    float t1 = (-b - determinant) / a;\\n\\\n    float t2 = (-b + determinant) / a;\\n\\\n    float signFlip = convex ? 1.0 : -1.0;\\n\\\n    vec3 normal1 = vec3((position + t1 * direction) * signFlip, 0.0);\\n\\\n    vec3 normal2 = vec3((position + t2 * direction) * signFlip, 0.0);\\n\\\n    // Return normals in eye coordinates\\n\\\n    vec4 intersect1 = vec4(normalize(czm_normal * normal1), t1);\\n\\\n    vec4 intersect2 = vec4(normalize(czm_normal * normal2), t2);\\n\\\n\\n\\\n    return RayShapeIntersection(intersect1, intersect2);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Find the intersection of a ray with a right cylindrical solid of given\\n\\\n * radius and height bounds. NOTE: The shape is assumed to be convex.\\n\\\n */\\n\\\nRayShapeIntersection intersectBoundedCylinder(in Ray ray, in Ray rayEC, in float radius)\\n\\\n{\\n\\\n    RayShapeIntersection cylinderIntersection = intersectCylinder(ray, radius, true);\\n\\\n    RayShapeIntersection heightBoundsIntersection = intersectBoundPlanes(rayEC);\\n\\\n    return intersectIntersections(ray, cylinderIntersection, heightBoundsIntersection);\\n\\\n}\\n\\\n\\n\\\nvoid intersectShape(in Ray ray, in Ray rayEC, inout Intersections ix)\\n\\\n{\\n\\\n    RayShapeIntersection outerIntersect = intersectBoundedCylinder(ray, rayEC, u_cylinderRenderRadiusMinMax.y);\\n\\\n\\n\\\n    setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_RADIUS_MAX, outerIntersect);\\n\\\n\\n\\\n    if (outerIntersect.entry.w == NO_HIT) {\\n\\\n        return;\\n\\\n    }\\n\\\n\\n\\\n    #if defined(CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT)\\n\\\n        // When the cylinder is perfectly thin it's necessary to sandwich the\\n\\\n        // inner cylinder intersection inside the outer cylinder intersection.\\n\\\n\\n\\\n        // Without this special case,\\n\\\n        // [outerMin, outerMax, innerMin, innerMax] will bubble sort to\\n\\\n        // [outerMin, innerMin, outerMax, innerMax] which will cause the back\\n\\\n        // side of the cylinder to be invisible because it will think the ray\\n\\\n        // is still inside the inner (negative) cylinder after exiting the\\n\\\n        // outer (positive) cylinder.\\n\\\n\\n\\\n        // With this special case,\\n\\\n        // [outerMin, innerMin, innerMax, outerMax] will bubble sort to\\n\\\n        // [outerMin, innerMin, innerMax, outerMax] which will work correctly.\\n\\\n\\n\\\n        // Note: If initializeIntersections() changes its sorting function\\n\\\n        // from bubble sort to something else, this code may need to change.\\n\\\n        RayShapeIntersection innerIntersect = intersectCylinder(ray, 1.0, false);\\n\\\n        setSurfaceIntersection(ix, 0, outerIntersect.entry, true, true);  // positive, enter\\n\\\n        setSurfaceIntersection(ix, 1, innerIntersect.entry, false, true); // negative, enter\\n\\\n        setSurfaceIntersection(ix, 2, innerIntersect.exit, false, false); // negative, exit\\n\\\n        setSurfaceIntersection(ix, 3, outerIntersect.exit, true, false);  // positive, exit\\n\\\n    #elif defined(CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN)\\n\\\n        RayShapeIntersection innerIntersect = intersectCylinder(ray, u_cylinderRenderRadiusMinMax.x, false);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_RADIUS_MIN, innerIntersect);\\n\\\n    #endif\\n\\\n\\n\\\n    #if defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF)\\n\\\n        RayShapeIntersection wedgeIntersect = intersectRegularWedge(ray, u_cylinderRenderAngleMinMax);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE, wedgeIntersect);\\n\\\n    #elif defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF)\\n\\\n        RayShapeIntersection wedgeIntersects[2];\\n\\\n        intersectFlippedWedge(ray, u_cylinderRenderAngleMinMax, wedgeIntersects);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 0, wedgeIntersects[0]);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 1, wedgeIntersects[1]);\\n\\\n    #elif defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO)\\n\\\n        RayShapeIntersection wedgeIntersects[2];\\n\\\n        intersectHalfPlane(ray, u_cylinderRenderAngleMinMax.x, wedgeIntersects);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 0, wedgeIntersects[0]);\\n\\\n        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 1, wedgeIntersects[1]);\\n\\\n    #endif\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}