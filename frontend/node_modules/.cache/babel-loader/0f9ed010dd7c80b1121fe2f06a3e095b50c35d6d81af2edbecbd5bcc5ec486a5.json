{"ast":null,"code":"import Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 2D Cartesian point.\n * @alias Cartesian2\n * @constructor\n *\n * @param {number} [x=0.0] The X component.\n * @param {number} [y=0.0] The Y component.\n *\n * @see Cartesian3\n * @see Cartesian4\n * @see Packable\n */\nfunction Cartesian2(x, y) {\n  /**\n   * The X component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.x = x ?? 0.0;\n\n  /**\n   * The Y component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.y = y ?? 0.0;\n}\n\n/**\n * Creates a Cartesian2 instance from x and y coordinates.\n *\n * @param {number} x The x coordinate.\n * @param {number} y The y coordinate.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromElements = function (x, y, result) {\n  if (!defined(result)) {\n    return new Cartesian2(x, y);\n  }\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian2 instance.\n *\n * @param {Cartesian2} cartesian The Cartesian to duplicate.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian2.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Cartesian2(cartesian.x, cartesian.y);\n  }\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  return result;\n};\n\n/**\n * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the\n * x and y properties of the Cartesian3 and drops z.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian3 instance to create a Cartesian2 instance from.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromCartesian3 = Cartesian2.clone;\n\n/**\n * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the\n * x and y properties of the Cartesian4 and drops z and w.\n * @function\n *\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian2 instance from.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromCartesian4 = Cartesian2.clone;\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nCartesian2.packedLength = 2;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian2} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCartesian2.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n  array[startingIndex++] = value.x;\n  array[startingIndex] = value.y;\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian2} [result] The object into which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex];\n  return result;\n};\n\n/**\n * Flattens an array of Cartesian2s into an array of components.\n *\n * @param {Cartesian2[]} array The array of cartesians to pack.\n * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 2 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 2) elements.\n * @returns {number[]} The packed array.\n */\nCartesian2.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 2;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new DeveloperError(\"If result is a typed array, it must have exactly array.length * 2 elements\");\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n  for (let i = 0; i < length; ++i) {\n    Cartesian2.pack(array[i], result, i * 2);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into an array of Cartesian2s.\n *\n * @param {number[]} array The array of components to unpack.\n * @param {Cartesian2[]} [result] The array onto which to store the result.\n * @returns {Cartesian2[]} The unpacked array.\n */\nCartesian2.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 2);\n  if (array.length % 2 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 2.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n  for (let i = 0; i < length; i += 2) {\n    const index = i / 2;\n    result[index] = Cartesian2.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian2 from two consecutive elements in an array.\n * @function\n *\n * @param {number[]} array The array whose two consecutive elements correspond to the x and y components, respectively.\n * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian2 with (1.0, 2.0)\n * const v = [1.0, 2.0];\n * const p = Cesium.Cartesian2.fromArray(v);\n *\n * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 2.0];\n * const p2 = Cesium.Cartesian2.fromArray(v2, 2);\n */\nCartesian2.fromArray = Cartesian2.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The cartesian to use.\n * @returns {number} The value of the maximum component.\n */\nCartesian2.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The cartesian to use.\n * @returns {number} The value of the minimum component.\n */\nCartesian2.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian2} first A cartesian to compare.\n * @param {Cartesian2} second A cartesian to compare.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} A cartesian with the minimum components.\n */\nCartesian2.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian2} first A cartesian to compare.\n * @param {Cartesian2} second A cartesian to compare.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} A cartesian with the maximum components.\n */\nCartesian2.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  return result;\n};\n\n/**\n * Constrain a value to lie between two values.\n *\n * @param {Cartesian2} value The value to clamp.\n * @param {Cartesian2} min The minimum bound.\n * @param {Cartesian2} max The maximum bound.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} The clamped value such that min <= result <= max.\n */\nCartesian2.clamp = function (value, min, max, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.typeOf.object(\"min\", min);\n  Check.typeOf.object(\"max\", max);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = CesiumMath.clamp(value.x, min.x, max.x);\n  const y = CesiumMath.clamp(value.y, min.y, max.y);\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian2} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {number} The squared magnitude.\n */\nCartesian2.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return cartesian.x * cartesian.x + cartesian.y * cartesian.y;\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian2} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {number} The magnitude.\n */\nCartesian2.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));\n};\nconst distanceScratch = new Cartesian2();\n\n/**\n * Computes the distance between two points.\n *\n * @param {Cartesian2} left The first point to compute the distance from.\n * @param {Cartesian2} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(2.0, 0.0));\n */\nCartesian2.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.subtract(left, right, distanceScratch);\n  return Cartesian2.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian2#distance}.\n *\n * @param {Cartesian2} left The first point to compute the distance from.\n * @param {Cartesian2} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(3.0, 0.0));\n */\nCartesian2.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.subtract(left, right, distanceScratch);\n  return Cartesian2.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian to be normalized.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const magnitude = Cartesian2.magnitude(cartesian);\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(result.x) || isNaN(result.y)) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {number} The dot product.\n */\nCartesian2.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y;\n};\n\n/**\n * Computes the magnitude of the cross product that would result from implicitly setting the Z coordinate of the input vectors to 0\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {number} The cross product.\n */\nCartesian2.cross = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.y - left.y * right.x;\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian2} cartesian The Cartesian to be scaled.\n * @param {number} scalar The scalar to multiply with.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian2} cartesian The Cartesian to be divided.\n * @param {number} scalar The scalar to divide by.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian to be negated.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  return result;\n};\nconst lerpScratch = new Cartesian2();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian2} start The value corresponding to t at 0.0.\n * @param {Cartesian2} end The value corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian2.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian2.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian2.add(lerpScratch, result, result);\n};\nconst angleBetweenScratch = new Cartesian2();\nconst angleBetweenScratch2 = new Cartesian2();\n/**\n * Returns the angle, in radians, between the provided Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {number} The angle between the Cartesians.\n */\nCartesian2.angleBetween = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.normalize(left, angleBetweenScratch);\n  Cartesian2.normalize(right, angleBetweenScratch2);\n  return CesiumMath.acosClamped(Cartesian2.dot(angleBetweenScratch, angleBetweenScratch2));\n};\nconst mostOrthogonalAxisScratch = new Cartesian2();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The most orthogonal axis.\n */\nCartesian2.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const f = Cartesian2.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian2.abs(f, f);\n  if (f.x <= f.y) {\n    result = Cartesian2.clone(Cartesian2.UNIT_X, result);\n  } else {\n    result = Cartesian2.clone(Cartesian2.UNIT_Y, result);\n  }\n  return result;\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian2} [left] The first Cartesian.\n * @param {Cartesian2} [right] The second Cartesian.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian2.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && left.x === right.x && left.y === right.y;\n};\n\n/**\n * @private\n */\nCartesian2.equalsArray = function (cartesian, array, offset) {\n  return cartesian.x === array[offset] && cartesian.y === array[offset + 1];\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian2} [left] The first Cartesian.\n * @param {Cartesian2} [right] The second Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian2.equalsEpsilon = function (left, right, relativeEpsilon, absoluteEpsilon) {\n  return left === right || defined(left) && defined(right) && CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon);\n};\n\n/**\n * An immutable Cartesian2 instance initialized to (0.0, 0.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.ZERO = Object.freeze(new Cartesian2(0.0, 0.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (1.0, 1.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.ONE = Object.freeze(new Cartesian2(1.0, 1.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (1.0, 0.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.UNIT_X = Object.freeze(new Cartesian2(1.0, 0.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (0.0, 1.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.UNIT_Y = Object.freeze(new Cartesian2(0.0, 1.0));\n\n/**\n * Duplicates this Cartesian2 instance.\n *\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.prototype.clone = function (result) {\n  return Cartesian2.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian2} [right] The right hand side Cartesian.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian2.prototype.equals = function (right) {\n  return Cartesian2.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian2} [right] The right hand side Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian2.prototype.equalsEpsilon = function (right, relativeEpsilon, absoluteEpsilon) {\n  return Cartesian2.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y)'.\n *\n * @returns {string} A string representing the provided Cartesian in the format '(x, y)'.\n */\nCartesian2.prototype.toString = function () {\n  return `(${this.x}, ${this.y})`;\n};\nexport default Cartesian2;","map":{"version":3,"names":["Check","defined","DeveloperError","CesiumMath","Cartesian2","x","y","fromElements","result","clone","cartesian","undefined","fromCartesian3","fromCartesian4","packedLength","pack","value","array","startingIndex","typeOf","object","unpack","packArray","length","resultLength","Array","isArray","i","unpackArray","number","greaterThanOrEquals","index","fromArray","maximumComponent","Math","max","minimumComponent","min","minimumByComponent","first","second","maximumByComponent","clamp","magnitudeSquared","magnitude","sqrt","distanceScratch","distance","left","right","subtract","distanceSquared","normalize","isNaN","dot","cross","multiplyComponents","divideComponents","add","multiplyByScalar","scalar","divideByScalar","negate","abs","lerpScratch","lerp","start","end","t","angleBetweenScratch","angleBetweenScratch2","angleBetween","acosClamped","mostOrthogonalAxisScratch","mostOrthogonalAxis","f","UNIT_X","UNIT_Y","equals","equalsArray","offset","equalsEpsilon","relativeEpsilon","absoluteEpsilon","ZERO","Object","freeze","ONE","prototype","toString"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/Cartesian2.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 2D Cartesian point.\n * @alias Cartesian2\n * @constructor\n *\n * @param {number} [x=0.0] The X component.\n * @param {number} [y=0.0] The Y component.\n *\n * @see Cartesian3\n * @see Cartesian4\n * @see Packable\n */\nfunction Cartesian2(x, y) {\n  /**\n   * The X component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.x = x ?? 0.0;\n\n  /**\n   * The Y component.\n   * @type {number}\n   * @default 0.0\n   */\n  this.y = y ?? 0.0;\n}\n\n/**\n * Creates a Cartesian2 instance from x and y coordinates.\n *\n * @param {number} x The x coordinate.\n * @param {number} y The y coordinate.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromElements = function (x, y, result) {\n  if (!defined(result)) {\n    return new Cartesian2(x, y);\n  }\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian2 instance.\n *\n * @param {Cartesian2} cartesian The Cartesian to duplicate.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian2.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Cartesian2(cartesian.x, cartesian.y);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  return result;\n};\n\n/**\n * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the\n * x and y properties of the Cartesian3 and drops z.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian3 instance to create a Cartesian2 instance from.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromCartesian3 = Cartesian2.clone;\n\n/**\n * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the\n * x and y properties of the Cartesian4 and drops z and w.\n * @function\n *\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian2 instance from.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromCartesian4 = Cartesian2.clone;\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nCartesian2.packedLength = 2;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian2} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nCartesian2.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  array[startingIndex++] = value.x;\n  array[startingIndex] = value.y;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian2} [result] The object into which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex];\n  return result;\n};\n\n/**\n * Flattens an array of Cartesian2s into an array of components.\n *\n * @param {Cartesian2[]} array The array of cartesians to pack.\n * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 2 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 2) elements.\n * @returns {number[]} The packed array.\n */\nCartesian2.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 2;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 2 elements\",\n    );\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    Cartesian2.pack(array[i], result, i * 2);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into an array of Cartesian2s.\n *\n * @param {number[]} array The array of components to unpack.\n * @param {Cartesian2[]} [result] The array onto which to store the result.\n * @returns {Cartesian2[]} The unpacked array.\n */\nCartesian2.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 2);\n  if (array.length % 2 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 2.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (let i = 0; i < length; i += 2) {\n    const index = i / 2;\n    result[index] = Cartesian2.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian2 from two consecutive elements in an array.\n * @function\n *\n * @param {number[]} array The array whose two consecutive elements correspond to the x and y components, respectively.\n * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian2 with (1.0, 2.0)\n * const v = [1.0, 2.0];\n * const p = Cesium.Cartesian2.fromArray(v);\n *\n * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 2.0];\n * const p2 = Cesium.Cartesian2.fromArray(v2, 2);\n */\nCartesian2.fromArray = Cartesian2.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The cartesian to use.\n * @returns {number} The value of the maximum component.\n */\nCartesian2.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The cartesian to use.\n * @returns {number} The value of the minimum component.\n */\nCartesian2.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian2} first A cartesian to compare.\n * @param {Cartesian2} second A cartesian to compare.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} A cartesian with the minimum components.\n */\nCartesian2.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian2} first A cartesian to compare.\n * @param {Cartesian2} second A cartesian to compare.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} A cartesian with the maximum components.\n */\nCartesian2.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  return result;\n};\n\n/**\n * Constrain a value to lie between two values.\n *\n * @param {Cartesian2} value The value to clamp.\n * @param {Cartesian2} min The minimum bound.\n * @param {Cartesian2} max The maximum bound.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} The clamped value such that min <= result <= max.\n */\nCartesian2.clamp = function (value, min, max, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.typeOf.object(\"min\", min);\n  Check.typeOf.object(\"max\", max);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = CesiumMath.clamp(value.x, min.x, max.x);\n  const y = CesiumMath.clamp(value.y, min.y, max.y);\n\n  result.x = x;\n  result.y = y;\n\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian2} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {number} The squared magnitude.\n */\nCartesian2.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return cartesian.x * cartesian.x + cartesian.y * cartesian.y;\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian2} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {number} The magnitude.\n */\nCartesian2.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));\n};\n\nconst distanceScratch = new Cartesian2();\n\n/**\n * Computes the distance between two points.\n *\n * @param {Cartesian2} left The first point to compute the distance from.\n * @param {Cartesian2} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(2.0, 0.0));\n */\nCartesian2.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.subtract(left, right, distanceScratch);\n  return Cartesian2.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian2#distance}.\n *\n * @param {Cartesian2} left The first point to compute the distance from.\n * @param {Cartesian2} right The second point to compute the distance to.\n * @returns {number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(3.0, 0.0));\n */\nCartesian2.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.subtract(left, right, distanceScratch);\n  return Cartesian2.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian to be normalized.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const magnitude = Cartesian2.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(result.x) || isNaN(result.y)) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {number} The dot product.\n */\nCartesian2.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y;\n};\n\n/**\n * Computes the magnitude of the cross product that would result from implicitly setting the Z coordinate of the input vectors to 0\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {number} The cross product.\n */\nCartesian2.cross = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.y - left.y * right.x;\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian2} cartesian The Cartesian to be scaled.\n * @param {number} scalar The scalar to multiply with.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian2} cartesian The Cartesian to be divided.\n * @param {number} scalar The scalar to divide by.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian to be negated.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  return result;\n};\n\nconst lerpScratch = new Cartesian2();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian2} start The value corresponding to t at 0.0.\n * @param {Cartesian2} end The value corresponding to t at 1.0.\n * @param {number} t The point along t at which to interpolate.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian2.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian2.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian2.add(lerpScratch, result, result);\n};\n\nconst angleBetweenScratch = new Cartesian2();\nconst angleBetweenScratch2 = new Cartesian2();\n/**\n * Returns the angle, in radians, between the provided Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {number} The angle between the Cartesians.\n */\nCartesian2.angleBetween = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.normalize(left, angleBetweenScratch);\n  Cartesian2.normalize(right, angleBetweenScratch2);\n  return CesiumMath.acosClamped(\n    Cartesian2.dot(angleBetweenScratch, angleBetweenScratch2),\n  );\n};\n\nconst mostOrthogonalAxisScratch = new Cartesian2();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The most orthogonal axis.\n */\nCartesian2.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const f = Cartesian2.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian2.abs(f, f);\n\n  if (f.x <= f.y) {\n    result = Cartesian2.clone(Cartesian2.UNIT_X, result);\n  } else {\n    result = Cartesian2.clone(Cartesian2.UNIT_Y, result);\n  }\n\n  return result;\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian2} [left] The first Cartesian.\n * @param {Cartesian2} [right] The second Cartesian.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian2.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y)\n  );\n};\n\n/**\n * @private\n */\nCartesian2.equalsArray = function (cartesian, array, offset) {\n  return cartesian.x === array[offset] && cartesian.y === array[offset + 1];\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian2} [left] The first Cartesian.\n * @param {Cartesian2} [right] The second Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian2.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      CesiumMath.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon,\n      ))\n  );\n};\n\n/**\n * An immutable Cartesian2 instance initialized to (0.0, 0.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.ZERO = Object.freeze(new Cartesian2(0.0, 0.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (1.0, 1.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.ONE = Object.freeze(new Cartesian2(1.0, 1.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (1.0, 0.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.UNIT_X = Object.freeze(new Cartesian2(1.0, 0.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (0.0, 1.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.UNIT_Y = Object.freeze(new Cartesian2(0.0, 1.0));\n\n/**\n * Duplicates this Cartesian2 instance.\n *\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.prototype.clone = function (result) {\n  return Cartesian2.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian2} [right] The right hand side Cartesian.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian2.prototype.equals = function (right) {\n  return Cartesian2.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian2} [right] The right hand side Cartesian.\n * @param {number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian2.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon,\n) {\n  return Cartesian2.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon,\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y)'.\n *\n * @returns {string} A string representing the provided Cartesian in the format '(x, y)'.\n */\nCartesian2.prototype.toString = function () {\n  return `(${this.x}, ${this.y})`;\n};\nexport default Cartesian2;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}