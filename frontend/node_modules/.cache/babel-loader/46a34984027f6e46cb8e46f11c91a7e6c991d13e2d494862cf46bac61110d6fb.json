{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Plane from \"../Core/Plane.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport RectangleOutlineGeometry from \"../Core/RectangleOutlineGeometry.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * A tile bounding volume specified as a longitude/latitude/height region.\n * @alias TileBoundingRegion\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Rectangle} options.rectangle The rectangle specifying the longitude and latitude range of the region.\n * @param {number} [options.minimumHeight=0.0] The minimum height of the region.\n * @param {number} [options.maximumHeight=0.0] The maximum height of the region.\n * @param {Ellipsoid} [options.ellipsoid=Cesium.Ellipsoid.WGS84] The ellipsoid.\n * @param {boolean} [options.computeBoundingVolumes=true] True to compute the {@link TileBoundingRegion#boundingVolume} and\n *                  {@link TileBoundingVolume#boundingSphere}. If false, these properties will be undefined.\n *\n * @private\n */\nfunction TileBoundingRegion(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.rectangle\", options.rectangle);\n  //>>includeEnd('debug');\n\n  this.rectangle = Rectangle.clone(options.rectangle);\n  this.minimumHeight = options.minimumHeight ?? 0.0;\n  this.maximumHeight = options.maximumHeight ?? 0.0;\n\n  /**\n   * The world coordinates of the southwest corner of the tile's rectangle.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.southwestCornerCartesian = new Cartesian3();\n\n  /**\n   * The world coordinates of the northeast corner of the tile's rectangle.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.northeastCornerCartesian = new Cartesian3();\n\n  /**\n   * A normal that, along with southwestCornerCartesian, defines a plane at the western edge of\n   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.westNormal = new Cartesian3();\n\n  /**\n   * A normal that, along with southwestCornerCartesian, defines a plane at the southern edge of\n   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.\n   * Because points of constant latitude do not necessary lie in a plane, positions below this\n   * plane are not necessarily inside the tile, but they are close.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.southNormal = new Cartesian3();\n\n  /**\n   * A normal that, along with northeastCornerCartesian, defines a plane at the eastern edge of\n   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.eastNormal = new Cartesian3();\n\n  /**\n   * A normal that, along with northeastCornerCartesian, defines a plane at the eastern edge of\n   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.\n   * Because points of constant latitude do not necessary lie in a plane, positions below this\n   * plane are not necessarily inside the tile, but they are close.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.northNormal = new Cartesian3();\n  const ellipsoid = options.ellipsoid ?? Ellipsoid.WGS84;\n  computeBox(this, options.rectangle, ellipsoid);\n  this._orientedBoundingBox = undefined;\n  this._boundingSphere = undefined;\n  if (options.computeBoundingVolumes ?? true) {\n    this.computeBoundingVolumes(ellipsoid);\n  }\n}\nObject.defineProperties(TileBoundingRegion.prototype, {\n  /**\n   * The underlying bounding volume\n   *\n   * @memberof TileBoundingRegion.prototype\n   *\n   * @type {object}\n   * @readonly\n   */\n  boundingVolume: {\n    get: function () {\n      return this._orientedBoundingBox;\n    }\n  },\n  /**\n   * The underlying bounding sphere\n   *\n   * @memberof TileBoundingRegion.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    }\n  }\n});\nTileBoundingRegion.prototype.computeBoundingVolumes = function (ellipsoid) {\n  // An oriented bounding box that encloses this tile's region.  This is used to calculate tile visibility.\n  this._orientedBoundingBox = OrientedBoundingBox.fromRectangle(this.rectangle, this.minimumHeight, this.maximumHeight, ellipsoid);\n  this._boundingSphere = BoundingSphere.fromOrientedBoundingBox(this._orientedBoundingBox);\n};\nconst cartesian3Scratch = new Cartesian3();\nconst cartesian3Scratch2 = new Cartesian3();\nconst cartesian3Scratch3 = new Cartesian3();\nconst westNormalScratch = new Cartesian3();\nconst eastWestNormalScratch = new Cartesian3();\nconst westernMidpointScratch = new Cartesian3();\nconst easternMidpointScratch = new Cartesian3();\nconst cartographicScratch = new Cartographic();\nconst planeScratch = new Plane(Cartesian3.UNIT_X, 0.0);\nconst rayScratch = new Ray();\nfunction computeBox(tileBB, rectangle, ellipsoid) {\n  ellipsoid.cartographicToCartesian(Rectangle.southwest(rectangle), tileBB.southwestCornerCartesian);\n  ellipsoid.cartographicToCartesian(Rectangle.northeast(rectangle), tileBB.northeastCornerCartesian);\n\n  // The middle latitude on the western edge.\n  cartographicScratch.longitude = rectangle.west;\n  cartographicScratch.latitude = (rectangle.south + rectangle.north) * 0.5;\n  cartographicScratch.height = 0.0;\n  const westernMidpointCartesian = ellipsoid.cartographicToCartesian(cartographicScratch, westernMidpointScratch);\n\n  // Compute the normal of the plane on the western edge of the tile.\n  const westNormal = Cartesian3.cross(westernMidpointCartesian, Cartesian3.UNIT_Z, westNormalScratch);\n  Cartesian3.normalize(westNormal, tileBB.westNormal);\n\n  // The middle latitude on the eastern edge.\n  cartographicScratch.longitude = rectangle.east;\n  const easternMidpointCartesian = ellipsoid.cartographicToCartesian(cartographicScratch, easternMidpointScratch);\n\n  // Compute the normal of the plane on the eastern edge of the tile.\n  const eastNormal = Cartesian3.cross(Cartesian3.UNIT_Z, easternMidpointCartesian, cartesian3Scratch);\n  Cartesian3.normalize(eastNormal, tileBB.eastNormal);\n  let westVector = Cartesian3.subtract(westernMidpointCartesian, easternMidpointCartesian, cartesian3Scratch);\n  if (Cartesian3.magnitude(westVector) === 0.0) {\n    westVector = Cartesian3.clone(westNormal, westVector);\n  }\n  const eastWestNormal = Cartesian3.normalize(westVector, eastWestNormalScratch);\n\n  // Compute the normal of the plane bounding the southern edge of the tile.\n  const south = rectangle.south;\n  let southSurfaceNormal;\n  if (south > 0.0) {\n    // Compute a plane that doesn't cut through the tile.\n    cartographicScratch.longitude = (rectangle.west + rectangle.east) * 0.5;\n    cartographicScratch.latitude = south;\n    const southCenterCartesian = ellipsoid.cartographicToCartesian(cartographicScratch, rayScratch.origin);\n    Cartesian3.clone(eastWestNormal, rayScratch.direction);\n    const westPlane = Plane.fromPointNormal(tileBB.southwestCornerCartesian, tileBB.westNormal, planeScratch);\n    // Find a point that is on the west and the south planes\n    IntersectionTests.rayPlane(rayScratch, westPlane, tileBB.southwestCornerCartesian);\n    southSurfaceNormal = ellipsoid.geodeticSurfaceNormal(southCenterCartesian, cartesian3Scratch2);\n  } else {\n    southSurfaceNormal = ellipsoid.geodeticSurfaceNormalCartographic(Rectangle.southeast(rectangle), cartesian3Scratch2);\n  }\n  const southNormal = Cartesian3.cross(southSurfaceNormal, westVector, cartesian3Scratch3);\n  Cartesian3.normalize(southNormal, tileBB.southNormal);\n\n  // Compute the normal of the plane bounding the northern edge of the tile.\n  const north = rectangle.north;\n  let northSurfaceNormal;\n  if (north < 0.0) {\n    // Compute a plane that doesn't cut through the tile.\n    cartographicScratch.longitude = (rectangle.west + rectangle.east) * 0.5;\n    cartographicScratch.latitude = north;\n    const northCenterCartesian = ellipsoid.cartographicToCartesian(cartographicScratch, rayScratch.origin);\n    Cartesian3.negate(eastWestNormal, rayScratch.direction);\n    const eastPlane = Plane.fromPointNormal(tileBB.northeastCornerCartesian, tileBB.eastNormal, planeScratch);\n    // Find a point that is on the east and the north planes\n    IntersectionTests.rayPlane(rayScratch, eastPlane, tileBB.northeastCornerCartesian);\n    northSurfaceNormal = ellipsoid.geodeticSurfaceNormal(northCenterCartesian, cartesian3Scratch2);\n  } else {\n    northSurfaceNormal = ellipsoid.geodeticSurfaceNormalCartographic(Rectangle.northwest(rectangle), cartesian3Scratch2);\n  }\n  const northNormal = Cartesian3.cross(westVector, northSurfaceNormal, cartesian3Scratch3);\n  Cartesian3.normalize(northNormal, tileBB.northNormal);\n}\nconst southwestCornerScratch = new Cartesian3();\nconst northeastCornerScratch = new Cartesian3();\nconst negativeUnitY = new Cartesian3(0.0, -1.0, 0.0);\nconst negativeUnitZ = new Cartesian3(0.0, 0.0, -1.0);\nconst vectorScratch = new Cartesian3();\nfunction distanceToCameraRegion(tileBB, frameState) {\n  const camera = frameState.camera;\n  const cameraCartesianPosition = camera.positionWC;\n  const cameraCartographicPosition = camera.positionCartographic;\n  let result = 0.0;\n  if (!Rectangle.contains(tileBB.rectangle, cameraCartographicPosition)) {\n    let southwestCornerCartesian = tileBB.southwestCornerCartesian;\n    let northeastCornerCartesian = tileBB.northeastCornerCartesian;\n    let westNormal = tileBB.westNormal;\n    let southNormal = tileBB.southNormal;\n    let eastNormal = tileBB.eastNormal;\n    let northNormal = tileBB.northNormal;\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      southwestCornerCartesian = frameState.mapProjection.project(Rectangle.southwest(tileBB.rectangle), southwestCornerScratch);\n      southwestCornerCartesian.z = southwestCornerCartesian.y;\n      southwestCornerCartesian.y = southwestCornerCartesian.x;\n      southwestCornerCartesian.x = 0.0;\n      northeastCornerCartesian = frameState.mapProjection.project(Rectangle.northeast(tileBB.rectangle), northeastCornerScratch);\n      northeastCornerCartesian.z = northeastCornerCartesian.y;\n      northeastCornerCartesian.y = northeastCornerCartesian.x;\n      northeastCornerCartesian.x = 0.0;\n      westNormal = negativeUnitY;\n      eastNormal = Cartesian3.UNIT_Y;\n      southNormal = negativeUnitZ;\n      northNormal = Cartesian3.UNIT_Z;\n    }\n    const vectorFromSouthwestCorner = Cartesian3.subtract(cameraCartesianPosition, southwestCornerCartesian, vectorScratch);\n    const distanceToWestPlane = Cartesian3.dot(vectorFromSouthwestCorner, westNormal);\n    const distanceToSouthPlane = Cartesian3.dot(vectorFromSouthwestCorner, southNormal);\n    const vectorFromNortheastCorner = Cartesian3.subtract(cameraCartesianPosition, northeastCornerCartesian, vectorScratch);\n    const distanceToEastPlane = Cartesian3.dot(vectorFromNortheastCorner, eastNormal);\n    const distanceToNorthPlane = Cartesian3.dot(vectorFromNortheastCorner, northNormal);\n    if (distanceToWestPlane > 0.0) {\n      result += distanceToWestPlane * distanceToWestPlane;\n    } else if (distanceToEastPlane > 0.0) {\n      result += distanceToEastPlane * distanceToEastPlane;\n    }\n    if (distanceToSouthPlane > 0.0) {\n      result += distanceToSouthPlane * distanceToSouthPlane;\n    } else if (distanceToNorthPlane > 0.0) {\n      result += distanceToNorthPlane * distanceToNorthPlane;\n    }\n  }\n  let cameraHeight;\n  let minimumHeight;\n  let maximumHeight;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    cameraHeight = cameraCartographicPosition.height;\n    minimumHeight = tileBB.minimumHeight;\n    maximumHeight = tileBB.maximumHeight;\n  } else {\n    cameraHeight = cameraCartesianPosition.x;\n    minimumHeight = 0.0;\n    maximumHeight = 0.0;\n  }\n  if (cameraHeight > maximumHeight) {\n    const distanceAboveTop = cameraHeight - maximumHeight;\n    result += distanceAboveTop * distanceAboveTop;\n  } else if (cameraHeight < minimumHeight) {\n    const distanceBelowBottom = minimumHeight - cameraHeight;\n    result += distanceBelowBottom * distanceBelowBottom;\n  }\n  return Math.sqrt(result);\n}\n\n/**\n * Gets the distance from the camera to the closest point on the tile.  This is used for level of detail selection.\n *\n * @param {FrameState} frameState The state information of the current rendering frame.\n * @returns {number} The distance from the camera to the closest point on the tile, in meters.\n */\nTileBoundingRegion.prototype.distanceToCamera = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  const regionResult = distanceToCameraRegion(this, frameState);\n  if (frameState.mode === SceneMode.SCENE3D && defined(this._orientedBoundingBox)) {\n    const obbResult = Math.sqrt(this._orientedBoundingBox.distanceSquaredTo(frameState.camera.positionWC));\n    return Math.max(regionResult, obbResult);\n  }\n  return regionResult;\n};\n\n/**\n * Determines which side of a plane this box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nTileBoundingRegion.prototype.intersectPlane = function (plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"plane\", plane);\n  //>>includeEnd('debug');\n  return this._orientedBoundingBox.intersectPlane(plane);\n};\n\n/**\n * Creates a debug primitive that shows the outline of the tile bounding region.\n *\n * @param {Color} color The desired color of the primitive's mesh\n * @return {Primitive}\n *\n * @private\n */\nTileBoundingRegion.prototype.createDebugVolume = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"color\", color);\n  //>>includeEnd('debug');\n\n  const modelMatrix = new Matrix4.clone(Matrix4.IDENTITY);\n  const geometry = new RectangleOutlineGeometry({\n    rectangle: this.rectangle,\n    height: this.minimumHeight,\n    extrudedHeight: this.maximumHeight\n  });\n  const instance = new GeometryInstance({\n    geometry: geometry,\n    id: \"outline\",\n    modelMatrix: modelMatrix,\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color)\n    }\n  });\n  return new Primitive({\n    geometryInstances: instance,\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true\n    }),\n    asynchronous: false\n  });\n};\nexport default TileBoundingRegion;","map":{"version":3,"names":["BoundingSphere","Cartesian3","Cartographic","Check","ColorGeometryInstanceAttribute","defined","Ellipsoid","GeometryInstance","IntersectionTests","Matrix4","OrientedBoundingBox","Plane","Ray","Rectangle","RectangleOutlineGeometry","PerInstanceColorAppearance","Primitive","SceneMode","TileBoundingRegion","options","typeOf","object","rectangle","clone","minimumHeight","maximumHeight","southwestCornerCartesian","northeastCornerCartesian","westNormal","southNormal","eastNormal","northNormal","ellipsoid","WGS84","computeBox","_orientedBoundingBox","undefined","_boundingSphere","computeBoundingVolumes","Object","defineProperties","prototype","boundingVolume","get","boundingSphere","fromRectangle","fromOrientedBoundingBox","cartesian3Scratch","cartesian3Scratch2","cartesian3Scratch3","westNormalScratch","eastWestNormalScratch","westernMidpointScratch","easternMidpointScratch","cartographicScratch","planeScratch","UNIT_X","rayScratch","tileBB","cartographicToCartesian","southwest","northeast","longitude","west","latitude","south","north","height","westernMidpointCartesian","cross","UNIT_Z","normalize","east","easternMidpointCartesian","westVector","subtract","magnitude","eastWestNormal","southSurfaceNormal","southCenterCartesian","origin","direction","westPlane","fromPointNormal","rayPlane","geodeticSurfaceNormal","geodeticSurfaceNormalCartographic","southeast","northSurfaceNormal","northCenterCartesian","negate","eastPlane","northwest","southwestCornerScratch","northeastCornerScratch","negativeUnitY","negativeUnitZ","vectorScratch","distanceToCameraRegion","frameState","camera","cameraCartesianPosition","positionWC","cameraCartographicPosition","positionCartographic","result","contains","mode","SCENE3D","mapProjection","project","z","y","x","UNIT_Y","vectorFromSouthwestCorner","distanceToWestPlane","dot","distanceToSouthPlane","vectorFromNortheastCorner","distanceToEastPlane","distanceToNorthPlane","cameraHeight","distanceAboveTop","distanceBelowBottom","Math","sqrt","distanceToCamera","regionResult","obbResult","distanceSquaredTo","max","intersectPlane","plane","createDebugVolume","color","modelMatrix","IDENTITY","geometry","extrudedHeight","instance","id","attributes","fromColor","geometryInstances","appearance","translucent","flat","asynchronous"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/TileBoundingRegion.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Plane from \"../Core/Plane.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport RectangleOutlineGeometry from \"../Core/RectangleOutlineGeometry.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * A tile bounding volume specified as a longitude/latitude/height region.\n * @alias TileBoundingRegion\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Rectangle} options.rectangle The rectangle specifying the longitude and latitude range of the region.\n * @param {number} [options.minimumHeight=0.0] The minimum height of the region.\n * @param {number} [options.maximumHeight=0.0] The maximum height of the region.\n * @param {Ellipsoid} [options.ellipsoid=Cesium.Ellipsoid.WGS84] The ellipsoid.\n * @param {boolean} [options.computeBoundingVolumes=true] True to compute the {@link TileBoundingRegion#boundingVolume} and\n *                  {@link TileBoundingVolume#boundingSphere}. If false, these properties will be undefined.\n *\n * @private\n */\nfunction TileBoundingRegion(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.rectangle\", options.rectangle);\n  //>>includeEnd('debug');\n\n  this.rectangle = Rectangle.clone(options.rectangle);\n  this.minimumHeight = options.minimumHeight ?? 0.0;\n  this.maximumHeight = options.maximumHeight ?? 0.0;\n\n  /**\n   * The world coordinates of the southwest corner of the tile's rectangle.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.southwestCornerCartesian = new Cartesian3();\n\n  /**\n   * The world coordinates of the northeast corner of the tile's rectangle.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.northeastCornerCartesian = new Cartesian3();\n\n  /**\n   * A normal that, along with southwestCornerCartesian, defines a plane at the western edge of\n   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.westNormal = new Cartesian3();\n\n  /**\n   * A normal that, along with southwestCornerCartesian, defines a plane at the southern edge of\n   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.\n   * Because points of constant latitude do not necessary lie in a plane, positions below this\n   * plane are not necessarily inside the tile, but they are close.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.southNormal = new Cartesian3();\n\n  /**\n   * A normal that, along with northeastCornerCartesian, defines a plane at the eastern edge of\n   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.eastNormal = new Cartesian3();\n\n  /**\n   * A normal that, along with northeastCornerCartesian, defines a plane at the eastern edge of\n   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.\n   * Because points of constant latitude do not necessary lie in a plane, positions below this\n   * plane are not necessarily inside the tile, but they are close.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.northNormal = new Cartesian3();\n\n  const ellipsoid = options.ellipsoid ?? Ellipsoid.WGS84;\n  computeBox(this, options.rectangle, ellipsoid);\n\n  this._orientedBoundingBox = undefined;\n  this._boundingSphere = undefined;\n\n  if (options.computeBoundingVolumes ?? true) {\n    this.computeBoundingVolumes(ellipsoid);\n  }\n}\n\nObject.defineProperties(TileBoundingRegion.prototype, {\n  /**\n   * The underlying bounding volume\n   *\n   * @memberof TileBoundingRegion.prototype\n   *\n   * @type {object}\n   * @readonly\n   */\n  boundingVolume: {\n    get: function () {\n      return this._orientedBoundingBox;\n    },\n  },\n  /**\n   * The underlying bounding sphere\n   *\n   * @memberof TileBoundingRegion.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    },\n  },\n});\n\nTileBoundingRegion.prototype.computeBoundingVolumes = function (ellipsoid) {\n  // An oriented bounding box that encloses this tile's region.  This is used to calculate tile visibility.\n  this._orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n    this.rectangle,\n    this.minimumHeight,\n    this.maximumHeight,\n    ellipsoid,\n  );\n\n  this._boundingSphere = BoundingSphere.fromOrientedBoundingBox(\n    this._orientedBoundingBox,\n  );\n};\n\nconst cartesian3Scratch = new Cartesian3();\nconst cartesian3Scratch2 = new Cartesian3();\nconst cartesian3Scratch3 = new Cartesian3();\nconst westNormalScratch = new Cartesian3();\nconst eastWestNormalScratch = new Cartesian3();\nconst westernMidpointScratch = new Cartesian3();\nconst easternMidpointScratch = new Cartesian3();\nconst cartographicScratch = new Cartographic();\nconst planeScratch = new Plane(Cartesian3.UNIT_X, 0.0);\nconst rayScratch = new Ray();\n\nfunction computeBox(tileBB, rectangle, ellipsoid) {\n  ellipsoid.cartographicToCartesian(\n    Rectangle.southwest(rectangle),\n    tileBB.southwestCornerCartesian,\n  );\n  ellipsoid.cartographicToCartesian(\n    Rectangle.northeast(rectangle),\n    tileBB.northeastCornerCartesian,\n  );\n\n  // The middle latitude on the western edge.\n  cartographicScratch.longitude = rectangle.west;\n  cartographicScratch.latitude = (rectangle.south + rectangle.north) * 0.5;\n  cartographicScratch.height = 0.0;\n  const westernMidpointCartesian = ellipsoid.cartographicToCartesian(\n    cartographicScratch,\n    westernMidpointScratch,\n  );\n\n  // Compute the normal of the plane on the western edge of the tile.\n  const westNormal = Cartesian3.cross(\n    westernMidpointCartesian,\n    Cartesian3.UNIT_Z,\n    westNormalScratch,\n  );\n  Cartesian3.normalize(westNormal, tileBB.westNormal);\n\n  // The middle latitude on the eastern edge.\n  cartographicScratch.longitude = rectangle.east;\n  const easternMidpointCartesian = ellipsoid.cartographicToCartesian(\n    cartographicScratch,\n    easternMidpointScratch,\n  );\n\n  // Compute the normal of the plane on the eastern edge of the tile.\n  const eastNormal = Cartesian3.cross(\n    Cartesian3.UNIT_Z,\n    easternMidpointCartesian,\n    cartesian3Scratch,\n  );\n  Cartesian3.normalize(eastNormal, tileBB.eastNormal);\n\n  let westVector = Cartesian3.subtract(\n    westernMidpointCartesian,\n    easternMidpointCartesian,\n    cartesian3Scratch,\n  );\n\n  if (Cartesian3.magnitude(westVector) === 0.0) {\n    westVector = Cartesian3.clone(westNormal, westVector);\n  }\n\n  const eastWestNormal = Cartesian3.normalize(\n    westVector,\n    eastWestNormalScratch,\n  );\n\n  // Compute the normal of the plane bounding the southern edge of the tile.\n  const south = rectangle.south;\n  let southSurfaceNormal;\n\n  if (south > 0.0) {\n    // Compute a plane that doesn't cut through the tile.\n    cartographicScratch.longitude = (rectangle.west + rectangle.east) * 0.5;\n    cartographicScratch.latitude = south;\n    const southCenterCartesian = ellipsoid.cartographicToCartesian(\n      cartographicScratch,\n      rayScratch.origin,\n    );\n    Cartesian3.clone(eastWestNormal, rayScratch.direction);\n    const westPlane = Plane.fromPointNormal(\n      tileBB.southwestCornerCartesian,\n      tileBB.westNormal,\n      planeScratch,\n    );\n    // Find a point that is on the west and the south planes\n    IntersectionTests.rayPlane(\n      rayScratch,\n      westPlane,\n      tileBB.southwestCornerCartesian,\n    );\n    southSurfaceNormal = ellipsoid.geodeticSurfaceNormal(\n      southCenterCartesian,\n      cartesian3Scratch2,\n    );\n  } else {\n    southSurfaceNormal = ellipsoid.geodeticSurfaceNormalCartographic(\n      Rectangle.southeast(rectangle),\n      cartesian3Scratch2,\n    );\n  }\n  const southNormal = Cartesian3.cross(\n    southSurfaceNormal,\n    westVector,\n    cartesian3Scratch3,\n  );\n  Cartesian3.normalize(southNormal, tileBB.southNormal);\n\n  // Compute the normal of the plane bounding the northern edge of the tile.\n  const north = rectangle.north;\n  let northSurfaceNormal;\n\n  if (north < 0.0) {\n    // Compute a plane that doesn't cut through the tile.\n    cartographicScratch.longitude = (rectangle.west + rectangle.east) * 0.5;\n    cartographicScratch.latitude = north;\n    const northCenterCartesian = ellipsoid.cartographicToCartesian(\n      cartographicScratch,\n      rayScratch.origin,\n    );\n    Cartesian3.negate(eastWestNormal, rayScratch.direction);\n    const eastPlane = Plane.fromPointNormal(\n      tileBB.northeastCornerCartesian,\n      tileBB.eastNormal,\n      planeScratch,\n    );\n    // Find a point that is on the east and the north planes\n    IntersectionTests.rayPlane(\n      rayScratch,\n      eastPlane,\n      tileBB.northeastCornerCartesian,\n    );\n    northSurfaceNormal = ellipsoid.geodeticSurfaceNormal(\n      northCenterCartesian,\n      cartesian3Scratch2,\n    );\n  } else {\n    northSurfaceNormal = ellipsoid.geodeticSurfaceNormalCartographic(\n      Rectangle.northwest(rectangle),\n      cartesian3Scratch2,\n    );\n  }\n  const northNormal = Cartesian3.cross(\n    westVector,\n    northSurfaceNormal,\n    cartesian3Scratch3,\n  );\n  Cartesian3.normalize(northNormal, tileBB.northNormal);\n}\n\nconst southwestCornerScratch = new Cartesian3();\nconst northeastCornerScratch = new Cartesian3();\nconst negativeUnitY = new Cartesian3(0.0, -1.0, 0.0);\nconst negativeUnitZ = new Cartesian3(0.0, 0.0, -1.0);\nconst vectorScratch = new Cartesian3();\n\nfunction distanceToCameraRegion(tileBB, frameState) {\n  const camera = frameState.camera;\n  const cameraCartesianPosition = camera.positionWC;\n  const cameraCartographicPosition = camera.positionCartographic;\n\n  let result = 0.0;\n  if (!Rectangle.contains(tileBB.rectangle, cameraCartographicPosition)) {\n    let southwestCornerCartesian = tileBB.southwestCornerCartesian;\n    let northeastCornerCartesian = tileBB.northeastCornerCartesian;\n    let westNormal = tileBB.westNormal;\n    let southNormal = tileBB.southNormal;\n    let eastNormal = tileBB.eastNormal;\n    let northNormal = tileBB.northNormal;\n\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      southwestCornerCartesian = frameState.mapProjection.project(\n        Rectangle.southwest(tileBB.rectangle),\n        southwestCornerScratch,\n      );\n      southwestCornerCartesian.z = southwestCornerCartesian.y;\n      southwestCornerCartesian.y = southwestCornerCartesian.x;\n      southwestCornerCartesian.x = 0.0;\n      northeastCornerCartesian = frameState.mapProjection.project(\n        Rectangle.northeast(tileBB.rectangle),\n        northeastCornerScratch,\n      );\n      northeastCornerCartesian.z = northeastCornerCartesian.y;\n      northeastCornerCartesian.y = northeastCornerCartesian.x;\n      northeastCornerCartesian.x = 0.0;\n      westNormal = negativeUnitY;\n      eastNormal = Cartesian3.UNIT_Y;\n      southNormal = negativeUnitZ;\n      northNormal = Cartesian3.UNIT_Z;\n    }\n\n    const vectorFromSouthwestCorner = Cartesian3.subtract(\n      cameraCartesianPosition,\n      southwestCornerCartesian,\n      vectorScratch,\n    );\n    const distanceToWestPlane = Cartesian3.dot(\n      vectorFromSouthwestCorner,\n      westNormal,\n    );\n    const distanceToSouthPlane = Cartesian3.dot(\n      vectorFromSouthwestCorner,\n      southNormal,\n    );\n\n    const vectorFromNortheastCorner = Cartesian3.subtract(\n      cameraCartesianPosition,\n      northeastCornerCartesian,\n      vectorScratch,\n    );\n    const distanceToEastPlane = Cartesian3.dot(\n      vectorFromNortheastCorner,\n      eastNormal,\n    );\n    const distanceToNorthPlane = Cartesian3.dot(\n      vectorFromNortheastCorner,\n      northNormal,\n    );\n\n    if (distanceToWestPlane > 0.0) {\n      result += distanceToWestPlane * distanceToWestPlane;\n    } else if (distanceToEastPlane > 0.0) {\n      result += distanceToEastPlane * distanceToEastPlane;\n    }\n\n    if (distanceToSouthPlane > 0.0) {\n      result += distanceToSouthPlane * distanceToSouthPlane;\n    } else if (distanceToNorthPlane > 0.0) {\n      result += distanceToNorthPlane * distanceToNorthPlane;\n    }\n  }\n\n  let cameraHeight;\n  let minimumHeight;\n  let maximumHeight;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    cameraHeight = cameraCartographicPosition.height;\n    minimumHeight = tileBB.minimumHeight;\n    maximumHeight = tileBB.maximumHeight;\n  } else {\n    cameraHeight = cameraCartesianPosition.x;\n    minimumHeight = 0.0;\n    maximumHeight = 0.0;\n  }\n\n  if (cameraHeight > maximumHeight) {\n    const distanceAboveTop = cameraHeight - maximumHeight;\n    result += distanceAboveTop * distanceAboveTop;\n  } else if (cameraHeight < minimumHeight) {\n    const distanceBelowBottom = minimumHeight - cameraHeight;\n    result += distanceBelowBottom * distanceBelowBottom;\n  }\n\n  return Math.sqrt(result);\n}\n\n/**\n * Gets the distance from the camera to the closest point on the tile.  This is used for level of detail selection.\n *\n * @param {FrameState} frameState The state information of the current rendering frame.\n * @returns {number} The distance from the camera to the closest point on the tile, in meters.\n */\nTileBoundingRegion.prototype.distanceToCamera = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  const regionResult = distanceToCameraRegion(this, frameState);\n  if (\n    frameState.mode === SceneMode.SCENE3D &&\n    defined(this._orientedBoundingBox)\n  ) {\n    const obbResult = Math.sqrt(\n      this._orientedBoundingBox.distanceSquaredTo(frameState.camera.positionWC),\n    );\n    return Math.max(regionResult, obbResult);\n  }\n  return regionResult;\n};\n\n/**\n * Determines which side of a plane this box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nTileBoundingRegion.prototype.intersectPlane = function (plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"plane\", plane);\n  //>>includeEnd('debug');\n  return this._orientedBoundingBox.intersectPlane(plane);\n};\n\n/**\n * Creates a debug primitive that shows the outline of the tile bounding region.\n *\n * @param {Color} color The desired color of the primitive's mesh\n * @return {Primitive}\n *\n * @private\n */\nTileBoundingRegion.prototype.createDebugVolume = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"color\", color);\n  //>>includeEnd('debug');\n\n  const modelMatrix = new Matrix4.clone(Matrix4.IDENTITY);\n  const geometry = new RectangleOutlineGeometry({\n    rectangle: this.rectangle,\n    height: this.minimumHeight,\n    extrudedHeight: this.maximumHeight,\n  });\n  const instance = new GeometryInstance({\n    geometry: geometry,\n    id: \"outline\",\n    modelMatrix: modelMatrix,\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color),\n    },\n  });\n\n  return new Primitive({\n    geometryInstances: instance,\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true,\n    }),\n    asynchronous: false,\n  });\n};\nexport default TileBoundingRegion;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}