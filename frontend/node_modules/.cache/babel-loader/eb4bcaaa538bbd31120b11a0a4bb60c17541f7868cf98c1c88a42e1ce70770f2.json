{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Check from \"../Core/Check.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nconst textureResolutionScratch = new Cartesian2();\n/**\n * Gets the GLSL functions needed to retrieve clipping planes from a ClippingPlaneCollection's texture.\n *\n * @param {ClippingPlaneCollection} clippingPlaneCollection ClippingPlaneCollection with a defined texture.\n * @param {Context} context The current rendering context.\n * @returns {string} A string containing GLSL functions for retrieving clipping planes.\n * @private\n */\nfunction getClippingFunction(clippingPlaneCollection, context) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"clippingPlaneCollection\", clippingPlaneCollection);\n  Check.typeOf.object(\"context\", context);\n  //>>includeEnd('debug');\n  const unionClippingRegions = clippingPlaneCollection.unionClippingRegions;\n  const clippingPlanesLength = clippingPlaneCollection.length;\n  const usingFloatTexture = ClippingPlaneCollection.useFloatTexture(context);\n  const textureResolution = ClippingPlaneCollection.getTextureResolution(clippingPlaneCollection, context, textureResolutionScratch);\n  const width = textureResolution.x;\n  const height = textureResolution.y;\n  let functions = usingFloatTexture ? getClippingPlaneFloat(width, height) : getClippingPlaneUint8(width, height);\n  functions += \"\\n\";\n  functions += unionClippingRegions ? clippingFunctionUnion(clippingPlanesLength) : clippingFunctionIntersect(clippingPlanesLength);\n  return functions;\n}\nfunction clippingFunctionUnion(clippingPlanesLength) {\n  return `float clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix)\n{\n    vec4 position = czm_windowToEyeCoordinates(fragCoord);\n    vec3 clipNormal = vec3(0.0);\n    vec3 clipPosition = vec3(0.0);\n    float clipAmount;\n    float pixelWidth = czm_metersPerPixel(position);\n    bool breakAndDiscard = false;\n    for (int i = 0; i < ${clippingPlanesLength}; ++i)\n    {\n        vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix);\n        clipNormal = clippingPlane.xyz;\n        clipPosition = -clippingPlane.w * clipNormal;\n        float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth;\n        clipAmount = czm_branchFreeTernary(i == 0, amount, min(amount, clipAmount));\n        if (amount <= 0.0)\n        {\n            breakAndDiscard = true;\n            // HLSL compiler bug if we discard here: https://bugs.chromium.org/p/angleproject/issues/detail?id=1945#c6\n            break;\n         }\n    }\n    if (breakAndDiscard) {\n        discard;\n    }\n    return clipAmount;\n}\n`;\n}\nfunction clippingFunctionIntersect(clippingPlanesLength) {\n  return `float clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix)\n{\n    bool clipped = true;\n    vec4 position = czm_windowToEyeCoordinates(fragCoord);\n    vec3 clipNormal = vec3(0.0);\n    vec3 clipPosition = vec3(0.0);\n    float clipAmount = 0.0;\n    float pixelWidth = czm_metersPerPixel(position);\n    for (int i = 0; i < ${clippingPlanesLength}; ++i)\n    {\n        vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix);\n        clipNormal = clippingPlane.xyz;\n        clipPosition = -clippingPlane.w * clipNormal;\n        float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth;\n        clipAmount = max(amount, clipAmount);\n        clipped = clipped && (amount <= 0.0);\n    }\n    if (clipped)\n    {\n        discard;\n    }\n    return clipAmount;\n }\n`;\n}\nfunction getClippingPlaneFloat(width, height) {\n  const pixelWidth = 1.0 / width;\n  const pixelHeight = 1.0 / height;\n  let pixelWidthString = `${pixelWidth}`;\n  if (pixelWidthString.indexOf(\".\") === -1) {\n    pixelWidthString += \".0\";\n  }\n  let pixelHeightString = `${pixelHeight}`;\n  if (pixelHeightString.indexOf(\".\") === -1) {\n    pixelHeightString += \".0\";\n  }\n  return `vec4 getClippingPlane(highp sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform)\n{\n    int pixY = clippingPlaneNumber / ${width};\n    int pixX = clippingPlaneNumber - (pixY * ${width});\n    // Sample from center of pixel\n    float u = (float(pixX) + 0.5) * ${pixelWidthString};\n    float v = (float(pixY) + 0.5) * ${pixelHeightString};\n    vec4 plane = texture(packedClippingPlanes, vec2(u, v));\n    return czm_transformPlane(plane, transform);\n}\n`;\n}\nfunction getClippingPlaneUint8(width, height) {\n  const pixelWidth = 1.0 / width;\n  const pixelHeight = 1.0 / height;\n  let pixelWidthString = `${pixelWidth}`;\n  if (pixelWidthString.indexOf(\".\") === -1) {\n    pixelWidthString += \".0\";\n  }\n  let pixelHeightString = `${pixelHeight}`;\n  if (pixelHeightString.indexOf(\".\") === -1) {\n    pixelHeightString += \".0\";\n  }\n  return `vec4 getClippingPlane(highp sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform)\n{\n    int clippingPlaneStartIndex = clippingPlaneNumber * 2;\n    int pixY = clippingPlaneStartIndex / ${width};\n    int pixX = clippingPlaneStartIndex - (pixY * ${width});\n    // Sample from center of pixel\n    float u = (float(pixX) + 0.5) * ${pixelWidthString};\n    float v = (float(pixY) + 0.5) * ${pixelHeightString};\n    vec4 oct32 = texture(packedClippingPlanes, vec2(u, v)) * 255.0;\n    vec2 oct = vec2(oct32.x * 256.0 + oct32.y, oct32.z * 256.0 + oct32.w);\n    vec4 plane;\n    plane.xyz = czm_octDecode(oct, 65535.0);\n    plane.w = czm_unpackFloat(texture(packedClippingPlanes, vec2(u + ${pixelWidthString}, v)));\n    return czm_transformPlane(plane, transform);\n}\n`;\n}\nexport default getClippingFunction;","map":{"version":3,"names":["Cartesian2","Check","ClippingPlaneCollection","textureResolutionScratch","getClippingFunction","clippingPlaneCollection","context","typeOf","object","unionClippingRegions","clippingPlanesLength","length","usingFloatTexture","useFloatTexture","textureResolution","getTextureResolution","width","x","height","y","functions","getClippingPlaneFloat","getClippingPlaneUint8","clippingFunctionUnion","clippingFunctionIntersect","pixelWidth","pixelHeight","pixelWidthString","indexOf","pixelHeightString"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/getClippingFunction.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Check from \"../Core/Check.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\n\nconst textureResolutionScratch = new Cartesian2();\n/**\n * Gets the GLSL functions needed to retrieve clipping planes from a ClippingPlaneCollection's texture.\n *\n * @param {ClippingPlaneCollection} clippingPlaneCollection ClippingPlaneCollection with a defined texture.\n * @param {Context} context The current rendering context.\n * @returns {string} A string containing GLSL functions for retrieving clipping planes.\n * @private\n */\nfunction getClippingFunction(clippingPlaneCollection, context) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"clippingPlaneCollection\", clippingPlaneCollection);\n  Check.typeOf.object(\"context\", context);\n  //>>includeEnd('debug');\n  const unionClippingRegions = clippingPlaneCollection.unionClippingRegions;\n  const clippingPlanesLength = clippingPlaneCollection.length;\n  const usingFloatTexture = ClippingPlaneCollection.useFloatTexture(context);\n  const textureResolution = ClippingPlaneCollection.getTextureResolution(\n    clippingPlaneCollection,\n    context,\n    textureResolutionScratch,\n  );\n  const width = textureResolution.x;\n  const height = textureResolution.y;\n\n  let functions = usingFloatTexture\n    ? getClippingPlaneFloat(width, height)\n    : getClippingPlaneUint8(width, height);\n  functions += \"\\n\";\n  functions += unionClippingRegions\n    ? clippingFunctionUnion(clippingPlanesLength)\n    : clippingFunctionIntersect(clippingPlanesLength);\n  return functions;\n}\n\nfunction clippingFunctionUnion(clippingPlanesLength) {\n  return `float clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix)\n{\n    vec4 position = czm_windowToEyeCoordinates(fragCoord);\n    vec3 clipNormal = vec3(0.0);\n    vec3 clipPosition = vec3(0.0);\n    float clipAmount;\n    float pixelWidth = czm_metersPerPixel(position);\n    bool breakAndDiscard = false;\n    for (int i = 0; i < ${clippingPlanesLength}; ++i)\n    {\n        vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix);\n        clipNormal = clippingPlane.xyz;\n        clipPosition = -clippingPlane.w * clipNormal;\n        float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth;\n        clipAmount = czm_branchFreeTernary(i == 0, amount, min(amount, clipAmount));\n        if (amount <= 0.0)\n        {\n            breakAndDiscard = true;\n            // HLSL compiler bug if we discard here: https://bugs.chromium.org/p/angleproject/issues/detail?id=1945#c6\n            break;\n         }\n    }\n    if (breakAndDiscard) {\n        discard;\n    }\n    return clipAmount;\n}\n`;\n}\n\nfunction clippingFunctionIntersect(clippingPlanesLength) {\n  return `float clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix)\n{\n    bool clipped = true;\n    vec4 position = czm_windowToEyeCoordinates(fragCoord);\n    vec3 clipNormal = vec3(0.0);\n    vec3 clipPosition = vec3(0.0);\n    float clipAmount = 0.0;\n    float pixelWidth = czm_metersPerPixel(position);\n    for (int i = 0; i < ${clippingPlanesLength}; ++i)\n    {\n        vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix);\n        clipNormal = clippingPlane.xyz;\n        clipPosition = -clippingPlane.w * clipNormal;\n        float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth;\n        clipAmount = max(amount, clipAmount);\n        clipped = clipped && (amount <= 0.0);\n    }\n    if (clipped)\n    {\n        discard;\n    }\n    return clipAmount;\n }\n`;\n}\n\nfunction getClippingPlaneFloat(width, height) {\n  const pixelWidth = 1.0 / width;\n  const pixelHeight = 1.0 / height;\n\n  let pixelWidthString = `${pixelWidth}`;\n  if (pixelWidthString.indexOf(\".\") === -1) {\n    pixelWidthString += \".0\";\n  }\n  let pixelHeightString = `${pixelHeight}`;\n  if (pixelHeightString.indexOf(\".\") === -1) {\n    pixelHeightString += \".0\";\n  }\n\n  return `vec4 getClippingPlane(highp sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform)\n{\n    int pixY = clippingPlaneNumber / ${width};\n    int pixX = clippingPlaneNumber - (pixY * ${width});\n    // Sample from center of pixel\n    float u = (float(pixX) + 0.5) * ${pixelWidthString};\n    float v = (float(pixY) + 0.5) * ${pixelHeightString};\n    vec4 plane = texture(packedClippingPlanes, vec2(u, v));\n    return czm_transformPlane(plane, transform);\n}\n`;\n}\n\nfunction getClippingPlaneUint8(width, height) {\n  const pixelWidth = 1.0 / width;\n  const pixelHeight = 1.0 / height;\n\n  let pixelWidthString = `${pixelWidth}`;\n  if (pixelWidthString.indexOf(\".\") === -1) {\n    pixelWidthString += \".0\";\n  }\n  let pixelHeightString = `${pixelHeight}`;\n  if (pixelHeightString.indexOf(\".\") === -1) {\n    pixelHeightString += \".0\";\n  }\n\n  return `vec4 getClippingPlane(highp sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform)\n{\n    int clippingPlaneStartIndex = clippingPlaneNumber * 2;\n    int pixY = clippingPlaneStartIndex / ${width};\n    int pixX = clippingPlaneStartIndex - (pixY * ${width});\n    // Sample from center of pixel\n    float u = (float(pixX) + 0.5) * ${pixelWidthString};\n    float v = (float(pixY) + 0.5) * ${pixelHeightString};\n    vec4 oct32 = texture(packedClippingPlanes, vec2(u, v)) * 255.0;\n    vec2 oct = vec2(oct32.x * 256.0 + oct32.y, oct32.z * 256.0 + oct32.w);\n    vec4 plane;\n    plane.xyz = czm_octDecode(oct, 65535.0);\n    plane.w = czm_unpackFloat(texture(packedClippingPlanes, vec2(u + ${pixelWidthString}, v)));\n    return czm_transformPlane(plane, transform);\n}\n`;\n}\nexport default getClippingFunction;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}