{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport getBinaryAccessor from \"./getBinaryAccessor.js\";\nimport Cesium3DTileBatchTable from \"./Cesium3DTileBatchTable.js\";\n\n/**\n * Object for handling the <code>3DTILES_batch_table_hierarchy</code> extension\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.extension The <code>3DTILES_batch_table_hierarchy</code> extension object.\n * @param {Uint8Array} [options.binaryBody] The binary body of the batch table\n *\n * @alias BatchTableHierarchy\n * @constructor\n *\n * @private\n */\nfunction BatchTableHierarchy(options) {\n  this._classes = undefined;\n  this._classIds = undefined;\n  this._classIndexes = undefined;\n  this._parentCounts = undefined;\n  this._parentIndexes = undefined;\n  this._parentIds = undefined;\n\n  // Total memory used by the typed arrays\n  this._byteLength = 0;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.extension\", options.extension);\n  //>>includeEnd('debug');\n\n  initialize(this, options.extension, options.binaryBody);\n\n  //>>includeStart('debug', pragmas.debug);\n  validateHierarchy(this);\n  //>>includeEnd('debug');\n}\nObject.defineProperties(BatchTableHierarchy.prototype, {\n  byteLength: {\n    get: function () {\n      return this._byteLength;\n    }\n  }\n});\n\n/**\n * Parse the batch table hierarchy from the\n * <code>3DTILES_batch_table_hierarchy</code> extension.\n *\n * @param {BatchTableHierarchy} hierarchy The hierarchy instance\n * @param {object} hierarchyJson The JSON of the extension\n * @param {Uint8Array} [binaryBody] The binary body of the batch table for accessing binary properties\n * @private\n */\nfunction initialize(hierarchy, hierarchyJson, binaryBody) {\n  let i;\n  let classId;\n  let binaryAccessor;\n  const instancesLength = hierarchyJson.instancesLength;\n  const classes = hierarchyJson.classes;\n  let classIds = hierarchyJson.classIds;\n  let parentCounts = hierarchyJson.parentCounts;\n  let parentIds = hierarchyJson.parentIds;\n  let parentIdsLength = instancesLength;\n  let byteLength = 0;\n  if (defined(classIds.byteOffset)) {\n    classIds.componentType = classIds.componentType ?? ComponentDatatype.UNSIGNED_SHORT;\n    classIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(classIds);\n    classIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + classIds.byteOffset, instancesLength);\n    byteLength += classIds.byteLength;\n  }\n  let parentIndexes;\n  if (defined(parentCounts)) {\n    if (defined(parentCounts.byteOffset)) {\n      parentCounts.componentType = parentCounts.componentType ?? ComponentDatatype.UNSIGNED_SHORT;\n      parentCounts.type = AttributeType.SCALAR;\n      binaryAccessor = getBinaryAccessor(parentCounts);\n      parentCounts = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentCounts.byteOffset, instancesLength);\n      byteLength += parentCounts.byteLength;\n    }\n    parentIndexes = new Uint16Array(instancesLength);\n    parentIdsLength = 0;\n    for (i = 0; i < instancesLength; ++i) {\n      parentIndexes[i] = parentIdsLength;\n      parentIdsLength += parentCounts[i];\n    }\n    byteLength += parentIndexes.byteLength;\n  }\n  if (defined(parentIds) && defined(parentIds.byteOffset)) {\n    parentIds.componentType = parentIds.componentType ?? ComponentDatatype.UNSIGNED_SHORT;\n    parentIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(parentIds);\n    parentIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentIds.byteOffset, parentIdsLength);\n    byteLength += parentIds.byteLength;\n  }\n  const classesLength = classes.length;\n  for (i = 0; i < classesLength; ++i) {\n    const classInstancesLength = classes[i].length;\n    const properties = classes[i].instances;\n    const binaryProperties = Cesium3DTileBatchTable.getBinaryProperties(classInstancesLength, properties, binaryBody);\n    byteLength += countBinaryPropertyMemory(binaryProperties);\n    classes[i].instances = combine(binaryProperties, properties);\n  }\n  const classCounts = new Array(classesLength).fill(0);\n  const classIndexes = new Uint16Array(instancesLength);\n  for (i = 0; i < instancesLength; ++i) {\n    classId = classIds[i];\n    classIndexes[i] = classCounts[classId];\n    ++classCounts[classId];\n  }\n  byteLength += classIndexes.byteLength;\n  hierarchy._classes = classes;\n  hierarchy._classIds = classIds;\n  hierarchy._classIndexes = classIndexes;\n  hierarchy._parentCounts = parentCounts;\n  hierarchy._parentIndexes = parentIndexes;\n  hierarchy._parentIds = parentIds;\n  hierarchy._byteLength = byteLength;\n}\nfunction countBinaryPropertyMemory(binaryProperties) {\n  let byteLength = 0;\n  for (const name in binaryProperties) {\n    if (binaryProperties.hasOwnProperty(name)) {\n      byteLength += binaryProperties[name].typedArray.byteLength;\n    }\n  }\n  return byteLength;\n}\n\n//>>includeStart('debug', pragmas.debug);\nconst scratchValidateStack = [];\nfunction validateHierarchy(hierarchy) {\n  const stack = scratchValidateStack;\n  stack.length = 0;\n  const classIds = hierarchy._classIds;\n  const instancesLength = classIds.length;\n  for (let i = 0; i < instancesLength; ++i) {\n    validateInstance(hierarchy, i, stack);\n  }\n}\nfunction validateInstance(hierarchy, instanceIndex, stack) {\n  const parentCounts = hierarchy._parentCounts;\n  const parentIds = hierarchy._parentIds;\n  const parentIndexes = hierarchy._parentIndexes;\n  const classIds = hierarchy._classIds;\n  const instancesLength = classIds.length;\n  if (!defined(parentIds)) {\n    // No need to validate if there are no parents\n    return;\n  }\n  if (instanceIndex >= instancesLength) {\n    throw new DeveloperError(`Parent index ${instanceIndex} exceeds the total number of instances: ${instancesLength}`);\n  }\n  if (stack.indexOf(instanceIndex) > -1) {\n    throw new DeveloperError(\"Circular dependency detected in the batch table hierarchy.\");\n  }\n  stack.push(instanceIndex);\n  const parentCount = defined(parentCounts) ? parentCounts[instanceIndex] : 1;\n  const parentIndex = defined(parentCounts) ? parentIndexes[instanceIndex] : instanceIndex;\n  for (let i = 0; i < parentCount; ++i) {\n    const parentId = parentIds[parentIndex + i];\n    // Stop the traversal when the instance has no parent (its parentId equals itself), else continue the traversal.\n    if (parentId !== instanceIndex) {\n      validateInstance(hierarchy, parentId, stack);\n    }\n  }\n  stack.pop(instanceIndex);\n}\n//>>includeEnd('debug');\n\n// The size of this array equals the maximum instance count among all loaded tiles, which has the potential to be large.\nconst scratchVisited = [];\nconst scratchStack = [];\nlet marker = 0;\nfunction traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback) {\n  const classIds = hierarchy._classIds;\n  const parentCounts = hierarchy._parentCounts;\n  const parentIds = hierarchy._parentIds;\n  const parentIndexes = hierarchy._parentIndexes;\n  const instancesLength = classIds.length;\n\n  // Ignore instances that have already been visited. This occurs in diamond inheritance situations.\n  // Use a marker value to indicate that an instance has been visited, which increments with each run.\n  // This is more efficient than clearing the visited array every time.\n  const visited = scratchVisited;\n  visited.length = Math.max(visited.length, instancesLength);\n  const visitedMarker = ++marker;\n  const stack = scratchStack;\n  stack.length = 0;\n  stack.push(instanceIndex);\n  while (stack.length > 0) {\n    instanceIndex = stack.pop();\n    if (visited[instanceIndex] === visitedMarker) {\n      // This instance has already been visited, stop traversal\n      continue;\n    }\n    visited[instanceIndex] = visitedMarker;\n    const result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n    const parentCount = parentCounts[instanceIndex];\n    const parentIndex = parentIndexes[instanceIndex];\n    for (let i = 0; i < parentCount; ++i) {\n      const parentId = parentIds[parentIndex + i];\n      // Stop the traversal when the instance has no parent (its parentId equals itself)\n      // else add the parent to the stack to continue the traversal.\n      if (parentId !== instanceIndex) {\n        stack.push(parentId);\n      }\n    }\n  }\n}\nfunction traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback) {\n  let hasParent = true;\n  while (hasParent) {\n    const result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n    const parentId = hierarchy._parentIds[instanceIndex];\n    hasParent = parentId !== instanceIndex;\n    instanceIndex = parentId;\n  }\n}\nfunction traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {\n  // Traverse over the hierarchy and process each instance with the endConditionCallback.\n  // When the endConditionCallback returns a value, the traversal stops and that value is returned.\n  const parentCounts = hierarchy._parentCounts;\n  const parentIds = hierarchy._parentIds;\n  if (!defined(parentIds)) {\n    return endConditionCallback(hierarchy, instanceIndex);\n  } else if (defined(parentCounts)) {\n    return traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback);\n  }\n  return traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback);\n}\n\n/**\n * Returns whether the feature has this property.\n *\n * @param {number} batchId the batch ID of the feature\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {boolean} Whether the feature has this property.\n * @private\n */\nBatchTableHierarchy.prototype.hasProperty = function (batchId, propertyId) {\n  const result = traverseHierarchy(this, batchId, function (hierarchy, instanceIndex) {\n    const classId = hierarchy._classIds[instanceIndex];\n    const instances = hierarchy._classes[classId].instances;\n    if (defined(instances[propertyId])) {\n      return true;\n    }\n  });\n  return defined(result);\n};\n\n/**\n * Returns whether any feature has this property.\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {boolean} Whether any feature has this property.\n * @private\n */\nBatchTableHierarchy.prototype.propertyExists = function (propertyId) {\n  const classes = this._classes;\n  const classesLength = classes.length;\n  for (let i = 0; i < classesLength; ++i) {\n    const instances = classes[i].instances;\n    if (defined(instances[propertyId])) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns an array of property IDs.\n *\n * @param {number} batchId the batch ID of the feature\n * @param {number} index The index of the entity.\n * @param {string[]} [results] An array into which to store the results.\n * @returns {string[]} The property IDs.\n * @private\n */\nBatchTableHierarchy.prototype.getPropertyIds = function (batchId, results) {\n  results = defined(results) ? results : [];\n  results.length = 0;\n  traverseHierarchy(this, batchId, function (hierarchy, instanceIndex) {\n    const classId = hierarchy._classIds[instanceIndex];\n    const instances = hierarchy._classes[classId].instances;\n    for (const name in instances) {\n      if (instances.hasOwnProperty(name)) {\n        if (results.indexOf(name) === -1) {\n          results.push(name);\n        }\n      }\n    }\n  });\n  return results;\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n *\n * @param {number} batchId the batch ID of the feature\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the feature does not have this property.\n * @private\n */\nBatchTableHierarchy.prototype.getProperty = function (batchId, propertyId) {\n  return traverseHierarchy(this, batchId, function (hierarchy, instanceIndex) {\n    const classId = hierarchy._classIds[instanceIndex];\n    const instanceClass = hierarchy._classes[classId];\n    const indexInClass = hierarchy._classIndexes[instanceIndex];\n    const propertyValues = instanceClass.instances[propertyId];\n    if (defined(propertyValues)) {\n      if (defined(propertyValues.typedArray)) {\n        return getBinaryProperty(propertyValues, indexInClass);\n      }\n      return clone(propertyValues[indexInClass], true);\n    }\n  });\n};\nfunction getBinaryProperty(binaryProperty, index) {\n  const typedArray = binaryProperty.typedArray;\n  const componentCount = binaryProperty.componentCount;\n  if (componentCount === 1) {\n    return typedArray[index];\n  }\n  return binaryProperty.type.unpack(typedArray, index * componentCount);\n}\n\n/**\n * Sets the value of the property with the given ID. Only properties of the\n * instance may be set; parent properties may not be set.\n *\n * @param {number} batchId The batchId of the feature\n * @param {string} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n *\n * @exception {DeveloperError} when setting an inherited property\n * @private\n */\nBatchTableHierarchy.prototype.setProperty = function (batchId, propertyId, value) {\n  const result = traverseHierarchy(this, batchId, function (hierarchy, instanceIndex) {\n    const classId = hierarchy._classIds[instanceIndex];\n    const instanceClass = hierarchy._classes[classId];\n    const indexInClass = hierarchy._classIndexes[instanceIndex];\n    const propertyValues = instanceClass.instances[propertyId];\n    if (defined(propertyValues)) {\n      //>>includeStart('debug', pragmas.debug);\n      if (instanceIndex !== batchId) {\n        throw new DeveloperError(`Inherited property \"${propertyId}\" is read-only.`);\n      }\n      //>>includeEnd('debug');\n      if (defined(propertyValues.typedArray)) {\n        setBinaryProperty(propertyValues, indexInClass, value);\n      } else {\n        propertyValues[indexInClass] = clone(value, true);\n      }\n      return true;\n    }\n  });\n  return defined(result);\n};\nfunction setBinaryProperty(binaryProperty, index, value) {\n  const typedArray = binaryProperty.typedArray;\n  const componentCount = binaryProperty.componentCount;\n  if (componentCount === 1) {\n    typedArray[index] = value;\n  } else {\n    binaryProperty.type.pack(value, typedArray, index * componentCount);\n  }\n}\n\n/**\n * Check if a feature belongs to a class with the given name\n *\n * @param {number} batchId The batch ID of the feature\n * @param {string} className The name of the class\n * @return {boolean} <code>true</code> if the feature belongs to the class given by className, or <code>false</code> otherwise\n * @private\n */\nBatchTableHierarchy.prototype.isClass = function (batchId, className) {\n  // PERFORMANCE_IDEA : cache results in the ancestor classes to speed up this check if this area becomes a hotspot\n  // PERFORMANCE_IDEA : treat class names as integers for faster comparisons\n  const result = traverseHierarchy(this, batchId, function (hierarchy, instanceIndex) {\n    const classId = hierarchy._classIds[instanceIndex];\n    const instanceClass = hierarchy._classes[classId];\n    if (instanceClass.name === className) {\n      return true;\n    }\n  });\n  return defined(result);\n};\n\n/**\n * Get the name of the class a given feature belongs to\n *\n * @param {number} batchId The batch ID of the feature\n * @return {string} The name of the class this feature belongs to\n */\nBatchTableHierarchy.prototype.getClassName = function (batchId) {\n  const classId = this._classIds[batchId];\n  const instanceClass = this._classes[classId];\n  return instanceClass.name;\n};\nexport default BatchTableHierarchy;","map":{"version":3,"names":["AttributeType","Check","clone","combine","ComponentDatatype","defined","DeveloperError","getBinaryAccessor","Cesium3DTileBatchTable","BatchTableHierarchy","options","_classes","undefined","_classIds","_classIndexes","_parentCounts","_parentIndexes","_parentIds","_byteLength","typeOf","object","extension","initialize","binaryBody","validateHierarchy","Object","defineProperties","prototype","byteLength","get","hierarchy","hierarchyJson","i","classId","binaryAccessor","instancesLength","classes","classIds","parentCounts","parentIds","parentIdsLength","byteOffset","componentType","UNSIGNED_SHORT","type","SCALAR","createArrayBufferView","buffer","parentIndexes","Uint16Array","classesLength","length","classInstancesLength","properties","instances","binaryProperties","getBinaryProperties","countBinaryPropertyMemory","classCounts","Array","fill","classIndexes","name","hasOwnProperty","typedArray","scratchValidateStack","stack","validateInstance","instanceIndex","indexOf","push","parentCount","parentIndex","parentId","pop","scratchVisited","scratchStack","marker","traverseHierarchyMultipleParents","endConditionCallback","visited","Math","max","visitedMarker","result","traverseHierarchySingleParent","hasParent","traverseHierarchy","hasProperty","batchId","propertyId","propertyExists","getPropertyIds","results","getProperty","instanceClass","indexInClass","propertyValues","getBinaryProperty","binaryProperty","index","componentCount","unpack","setProperty","value","setBinaryProperty","pack","isClass","className","getClassName"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/BatchTableHierarchy.js"],"sourcesContent":["import AttributeType from \"./AttributeType.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport getBinaryAccessor from \"./getBinaryAccessor.js\";\nimport Cesium3DTileBatchTable from \"./Cesium3DTileBatchTable.js\";\n\n/**\n * Object for handling the <code>3DTILES_batch_table_hierarchy</code> extension\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.extension The <code>3DTILES_batch_table_hierarchy</code> extension object.\n * @param {Uint8Array} [options.binaryBody] The binary body of the batch table\n *\n * @alias BatchTableHierarchy\n * @constructor\n *\n * @private\n */\nfunction BatchTableHierarchy(options) {\n  this._classes = undefined;\n  this._classIds = undefined;\n  this._classIndexes = undefined;\n  this._parentCounts = undefined;\n  this._parentIndexes = undefined;\n  this._parentIds = undefined;\n\n  // Total memory used by the typed arrays\n  this._byteLength = 0;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.extension\", options.extension);\n  //>>includeEnd('debug');\n\n  initialize(this, options.extension, options.binaryBody);\n\n  //>>includeStart('debug', pragmas.debug);\n  validateHierarchy(this);\n  //>>includeEnd('debug');\n}\n\nObject.defineProperties(BatchTableHierarchy.prototype, {\n  byteLength: {\n    get: function () {\n      return this._byteLength;\n    },\n  },\n});\n\n/**\n * Parse the batch table hierarchy from the\n * <code>3DTILES_batch_table_hierarchy</code> extension.\n *\n * @param {BatchTableHierarchy} hierarchy The hierarchy instance\n * @param {object} hierarchyJson The JSON of the extension\n * @param {Uint8Array} [binaryBody] The binary body of the batch table for accessing binary properties\n * @private\n */\nfunction initialize(hierarchy, hierarchyJson, binaryBody) {\n  let i;\n  let classId;\n  let binaryAccessor;\n\n  const instancesLength = hierarchyJson.instancesLength;\n  const classes = hierarchyJson.classes;\n  let classIds = hierarchyJson.classIds;\n  let parentCounts = hierarchyJson.parentCounts;\n  let parentIds = hierarchyJson.parentIds;\n  let parentIdsLength = instancesLength;\n  let byteLength = 0;\n\n  if (defined(classIds.byteOffset)) {\n    classIds.componentType =\n      classIds.componentType ?? ComponentDatatype.UNSIGNED_SHORT;\n    classIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(classIds);\n    classIds = binaryAccessor.createArrayBufferView(\n      binaryBody.buffer,\n      binaryBody.byteOffset + classIds.byteOffset,\n      instancesLength,\n    );\n    byteLength += classIds.byteLength;\n  }\n\n  let parentIndexes;\n  if (defined(parentCounts)) {\n    if (defined(parentCounts.byteOffset)) {\n      parentCounts.componentType =\n        parentCounts.componentType ?? ComponentDatatype.UNSIGNED_SHORT;\n      parentCounts.type = AttributeType.SCALAR;\n      binaryAccessor = getBinaryAccessor(parentCounts);\n      parentCounts = binaryAccessor.createArrayBufferView(\n        binaryBody.buffer,\n        binaryBody.byteOffset + parentCounts.byteOffset,\n        instancesLength,\n      );\n      byteLength += parentCounts.byteLength;\n    }\n    parentIndexes = new Uint16Array(instancesLength);\n    parentIdsLength = 0;\n    for (i = 0; i < instancesLength; ++i) {\n      parentIndexes[i] = parentIdsLength;\n      parentIdsLength += parentCounts[i];\n    }\n\n    byteLength += parentIndexes.byteLength;\n  }\n\n  if (defined(parentIds) && defined(parentIds.byteOffset)) {\n    parentIds.componentType =\n      parentIds.componentType ?? ComponentDatatype.UNSIGNED_SHORT;\n    parentIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(parentIds);\n    parentIds = binaryAccessor.createArrayBufferView(\n      binaryBody.buffer,\n      binaryBody.byteOffset + parentIds.byteOffset,\n      parentIdsLength,\n    );\n\n    byteLength += parentIds.byteLength;\n  }\n\n  const classesLength = classes.length;\n  for (i = 0; i < classesLength; ++i) {\n    const classInstancesLength = classes[i].length;\n    const properties = classes[i].instances;\n    const binaryProperties = Cesium3DTileBatchTable.getBinaryProperties(\n      classInstancesLength,\n      properties,\n      binaryBody,\n    );\n    byteLength += countBinaryPropertyMemory(binaryProperties);\n    classes[i].instances = combine(binaryProperties, properties);\n  }\n\n  const classCounts = new Array(classesLength).fill(0);\n  const classIndexes = new Uint16Array(instancesLength);\n  for (i = 0; i < instancesLength; ++i) {\n    classId = classIds[i];\n    classIndexes[i] = classCounts[classId];\n    ++classCounts[classId];\n  }\n  byteLength += classIndexes.byteLength;\n\n  hierarchy._classes = classes;\n  hierarchy._classIds = classIds;\n  hierarchy._classIndexes = classIndexes;\n  hierarchy._parentCounts = parentCounts;\n  hierarchy._parentIndexes = parentIndexes;\n  hierarchy._parentIds = parentIds;\n  hierarchy._byteLength = byteLength;\n}\n\nfunction countBinaryPropertyMemory(binaryProperties) {\n  let byteLength = 0;\n  for (const name in binaryProperties) {\n    if (binaryProperties.hasOwnProperty(name)) {\n      byteLength += binaryProperties[name].typedArray.byteLength;\n    }\n  }\n  return byteLength;\n}\n\n//>>includeStart('debug', pragmas.debug);\nconst scratchValidateStack = [];\nfunction validateHierarchy(hierarchy) {\n  const stack = scratchValidateStack;\n  stack.length = 0;\n\n  const classIds = hierarchy._classIds;\n  const instancesLength = classIds.length;\n\n  for (let i = 0; i < instancesLength; ++i) {\n    validateInstance(hierarchy, i, stack);\n  }\n}\n\nfunction validateInstance(hierarchy, instanceIndex, stack) {\n  const parentCounts = hierarchy._parentCounts;\n  const parentIds = hierarchy._parentIds;\n  const parentIndexes = hierarchy._parentIndexes;\n  const classIds = hierarchy._classIds;\n  const instancesLength = classIds.length;\n\n  if (!defined(parentIds)) {\n    // No need to validate if there are no parents\n    return;\n  }\n\n  if (instanceIndex >= instancesLength) {\n    throw new DeveloperError(\n      `Parent index ${instanceIndex} exceeds the total number of instances: ${instancesLength}`,\n    );\n  }\n  if (stack.indexOf(instanceIndex) > -1) {\n    throw new DeveloperError(\n      \"Circular dependency detected in the batch table hierarchy.\",\n    );\n  }\n\n  stack.push(instanceIndex);\n  const parentCount = defined(parentCounts) ? parentCounts[instanceIndex] : 1;\n  const parentIndex = defined(parentCounts)\n    ? parentIndexes[instanceIndex]\n    : instanceIndex;\n  for (let i = 0; i < parentCount; ++i) {\n    const parentId = parentIds[parentIndex + i];\n    // Stop the traversal when the instance has no parent (its parentId equals itself), else continue the traversal.\n    if (parentId !== instanceIndex) {\n      validateInstance(hierarchy, parentId, stack);\n    }\n  }\n  stack.pop(instanceIndex);\n}\n//>>includeEnd('debug');\n\n// The size of this array equals the maximum instance count among all loaded tiles, which has the potential to be large.\nconst scratchVisited = [];\nconst scratchStack = [];\nlet marker = 0;\nfunction traverseHierarchyMultipleParents(\n  hierarchy,\n  instanceIndex,\n  endConditionCallback,\n) {\n  const classIds = hierarchy._classIds;\n  const parentCounts = hierarchy._parentCounts;\n  const parentIds = hierarchy._parentIds;\n  const parentIndexes = hierarchy._parentIndexes;\n  const instancesLength = classIds.length;\n\n  // Ignore instances that have already been visited. This occurs in diamond inheritance situations.\n  // Use a marker value to indicate that an instance has been visited, which increments with each run.\n  // This is more efficient than clearing the visited array every time.\n  const visited = scratchVisited;\n  visited.length = Math.max(visited.length, instancesLength);\n  const visitedMarker = ++marker;\n\n  const stack = scratchStack;\n  stack.length = 0;\n  stack.push(instanceIndex);\n\n  while (stack.length > 0) {\n    instanceIndex = stack.pop();\n    if (visited[instanceIndex] === visitedMarker) {\n      // This instance has already been visited, stop traversal\n      continue;\n    }\n    visited[instanceIndex] = visitedMarker;\n    const result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n    const parentCount = parentCounts[instanceIndex];\n    const parentIndex = parentIndexes[instanceIndex];\n    for (let i = 0; i < parentCount; ++i) {\n      const parentId = parentIds[parentIndex + i];\n      // Stop the traversal when the instance has no parent (its parentId equals itself)\n      // else add the parent to the stack to continue the traversal.\n      if (parentId !== instanceIndex) {\n        stack.push(parentId);\n      }\n    }\n  }\n}\n\nfunction traverseHierarchySingleParent(\n  hierarchy,\n  instanceIndex,\n  endConditionCallback,\n) {\n  let hasParent = true;\n  while (hasParent) {\n    const result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n    const parentId = hierarchy._parentIds[instanceIndex];\n    hasParent = parentId !== instanceIndex;\n    instanceIndex = parentId;\n  }\n}\n\nfunction traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {\n  // Traverse over the hierarchy and process each instance with the endConditionCallback.\n  // When the endConditionCallback returns a value, the traversal stops and that value is returned.\n  const parentCounts = hierarchy._parentCounts;\n  const parentIds = hierarchy._parentIds;\n  if (!defined(parentIds)) {\n    return endConditionCallback(hierarchy, instanceIndex);\n  } else if (defined(parentCounts)) {\n    return traverseHierarchyMultipleParents(\n      hierarchy,\n      instanceIndex,\n      endConditionCallback,\n    );\n  }\n  return traverseHierarchySingleParent(\n    hierarchy,\n    instanceIndex,\n    endConditionCallback,\n  );\n}\n\n/**\n * Returns whether the feature has this property.\n *\n * @param {number} batchId the batch ID of the feature\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {boolean} Whether the feature has this property.\n * @private\n */\nBatchTableHierarchy.prototype.hasProperty = function (batchId, propertyId) {\n  const result = traverseHierarchy(\n    this,\n    batchId,\n    function (hierarchy, instanceIndex) {\n      const classId = hierarchy._classIds[instanceIndex];\n      const instances = hierarchy._classes[classId].instances;\n      if (defined(instances[propertyId])) {\n        return true;\n      }\n    },\n  );\n  return defined(result);\n};\n\n/**\n * Returns whether any feature has this property.\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {boolean} Whether any feature has this property.\n * @private\n */\nBatchTableHierarchy.prototype.propertyExists = function (propertyId) {\n  const classes = this._classes;\n  const classesLength = classes.length;\n  for (let i = 0; i < classesLength; ++i) {\n    const instances = classes[i].instances;\n    if (defined(instances[propertyId])) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns an array of property IDs.\n *\n * @param {number} batchId the batch ID of the feature\n * @param {number} index The index of the entity.\n * @param {string[]} [results] An array into which to store the results.\n * @returns {string[]} The property IDs.\n * @private\n */\nBatchTableHierarchy.prototype.getPropertyIds = function (batchId, results) {\n  results = defined(results) ? results : [];\n  results.length = 0;\n\n  traverseHierarchy(this, batchId, function (hierarchy, instanceIndex) {\n    const classId = hierarchy._classIds[instanceIndex];\n    const instances = hierarchy._classes[classId].instances;\n    for (const name in instances) {\n      if (instances.hasOwnProperty(name)) {\n        if (results.indexOf(name) === -1) {\n          results.push(name);\n        }\n      }\n    }\n  });\n\n  return results;\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n *\n * @param {number} batchId the batch ID of the feature\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the feature does not have this property.\n * @private\n */\nBatchTableHierarchy.prototype.getProperty = function (batchId, propertyId) {\n  return traverseHierarchy(this, batchId, function (hierarchy, instanceIndex) {\n    const classId = hierarchy._classIds[instanceIndex];\n    const instanceClass = hierarchy._classes[classId];\n    const indexInClass = hierarchy._classIndexes[instanceIndex];\n    const propertyValues = instanceClass.instances[propertyId];\n    if (defined(propertyValues)) {\n      if (defined(propertyValues.typedArray)) {\n        return getBinaryProperty(propertyValues, indexInClass);\n      }\n      return clone(propertyValues[indexInClass], true);\n    }\n  });\n};\n\nfunction getBinaryProperty(binaryProperty, index) {\n  const typedArray = binaryProperty.typedArray;\n  const componentCount = binaryProperty.componentCount;\n  if (componentCount === 1) {\n    return typedArray[index];\n  }\n  return binaryProperty.type.unpack(typedArray, index * componentCount);\n}\n\n/**\n * Sets the value of the property with the given ID. Only properties of the\n * instance may be set; parent properties may not be set.\n *\n * @param {number} batchId The batchId of the feature\n * @param {string} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n *\n * @exception {DeveloperError} when setting an inherited property\n * @private\n */\nBatchTableHierarchy.prototype.setProperty = function (\n  batchId,\n  propertyId,\n  value,\n) {\n  const result = traverseHierarchy(\n    this,\n    batchId,\n    function (hierarchy, instanceIndex) {\n      const classId = hierarchy._classIds[instanceIndex];\n      const instanceClass = hierarchy._classes[classId];\n      const indexInClass = hierarchy._classIndexes[instanceIndex];\n      const propertyValues = instanceClass.instances[propertyId];\n      if (defined(propertyValues)) {\n        //>>includeStart('debug', pragmas.debug);\n        if (instanceIndex !== batchId) {\n          throw new DeveloperError(\n            `Inherited property \"${propertyId}\" is read-only.`,\n          );\n        }\n        //>>includeEnd('debug');\n        if (defined(propertyValues.typedArray)) {\n          setBinaryProperty(propertyValues, indexInClass, value);\n        } else {\n          propertyValues[indexInClass] = clone(value, true);\n        }\n        return true;\n      }\n    },\n  );\n  return defined(result);\n};\n\nfunction setBinaryProperty(binaryProperty, index, value) {\n  const typedArray = binaryProperty.typedArray;\n  const componentCount = binaryProperty.componentCount;\n  if (componentCount === 1) {\n    typedArray[index] = value;\n  } else {\n    binaryProperty.type.pack(value, typedArray, index * componentCount);\n  }\n}\n\n/**\n * Check if a feature belongs to a class with the given name\n *\n * @param {number} batchId The batch ID of the feature\n * @param {string} className The name of the class\n * @return {boolean} <code>true</code> if the feature belongs to the class given by className, or <code>false</code> otherwise\n * @private\n */\nBatchTableHierarchy.prototype.isClass = function (batchId, className) {\n  // PERFORMANCE_IDEA : cache results in the ancestor classes to speed up this check if this area becomes a hotspot\n  // PERFORMANCE_IDEA : treat class names as integers for faster comparisons\n  const result = traverseHierarchy(\n    this,\n    batchId,\n    function (hierarchy, instanceIndex) {\n      const classId = hierarchy._classIds[instanceIndex];\n      const instanceClass = hierarchy._classes[classId];\n      if (instanceClass.name === className) {\n        return true;\n      }\n    },\n  );\n  return defined(result);\n};\n\n/**\n * Get the name of the class a given feature belongs to\n *\n * @param {number} batchId The batch ID of the feature\n * @return {string} The name of the class this feature belongs to\n */\nBatchTableHierarchy.prototype.getClassName = function (batchId) {\n  const classId = this._classIds[batchId];\n  const instanceClass = this._classes[classId];\n  return instanceClass.name;\n};\n\nexport default BatchTableHierarchy;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}