{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport CesiumMath from \"./Math.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Quaternion from \"./Quaternion.js\";\n\n/**\n * Creates a curve parameterized and evaluated by time. This type describes an interface\n * and is not intended to be instantiated directly.\n *\n * @alias Spline\n * @constructor\n *\n * @see CatmullRomSpline\n * @see LinearSpline\n * @see HermiteSpline\n * @see QuaternionSpline\n * @see MorphWeightSpline\n */\nfunction Spline() {\n  /**\n   * An array of times for the control points.\n   * @type {number[]}\n   * @default undefined\n   */\n  this.times = undefined;\n\n  /**\n   * An array of control points.\n   * @type {Cartesian3[]|Quaternion[]}\n   * @default undefined\n   */\n  this.points = undefined;\n  DeveloperError.throwInstantiationError();\n}\n\n/**\n * Gets the type of the point. This helps a spline determine how to interpolate\n * and return its values.\n *\n * @param {number|Cartesian3|Quaternion} point\n * @returns {*} The type of the point.\n *\n * @exception {DeveloperError} value must be a Cartesian3, Quaternion, or number.\n *\n * @private\n */\nSpline.getPointType = function (point) {\n  if (typeof point === \"number\") {\n    return Number;\n  }\n  if (point instanceof Cartesian3) {\n    return Cartesian3;\n  }\n  if (point instanceof Quaternion) {\n    return Quaternion;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\"point must be a Cartesian3, Quaternion, or number.\");\n  //>>includeEnd('debug');\n};\n\n/**\n * Evaluates the curve at a given time.\n * @function\n *\n * @param {number} time The time at which to evaluate the curve.\n * @param {Cartesian3|Quaternion|number[]} [result] The object onto which to store the result.\n * @returns {Cartesian3|Quaternion|number[]} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nSpline.prototype.evaluate = DeveloperError.throwInstantiationError;\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n *\n * @param {number} time The time.\n * @param {number} startIndex The index from which to start the search.\n * @returns {number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nSpline.prototype.findTimeInterval = function (time, startIndex) {\n  const times = this.times;\n  const length = times.length;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"time\", time);\n  if (time < times[0] || time > times[length - 1]) {\n    throw new DeveloperError(\"time is out of range.\");\n  }\n  //>>includeEnd('debug');\n\n  // Take advantage of temporal coherence by checking current, next and previous intervals\n  // for containment of time.\n  startIndex = startIndex ?? 0;\n  if (time >= times[startIndex]) {\n    if (startIndex + 1 < length && time < times[startIndex + 1]) {\n      return startIndex;\n    } else if (startIndex + 2 < length && time < times[startIndex + 2]) {\n      return startIndex + 1;\n    }\n  } else if (startIndex - 1 >= 0 && time >= times[startIndex - 1]) {\n    return startIndex - 1;\n  }\n\n  // The above failed so do a linear search. For the use cases so far, the\n  // length of the list is less than 10. In the future, if there is a bottle neck,\n  // it might be here.\n\n  let i;\n  if (time > times[startIndex]) {\n    for (i = startIndex; i < length - 1; ++i) {\n      if (time >= times[i] && time < times[i + 1]) {\n        break;\n      }\n    }\n  } else {\n    for (i = startIndex - 1; i >= 0; --i) {\n      if (time >= times[i] && time < times[i + 1]) {\n        break;\n      }\n    }\n  }\n  if (i === length - 1) {\n    i = length - 2;\n  }\n  return i;\n};\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, wrapped around the animation period.\n */\nSpline.prototype.wrapTime = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"time\", time);\n  //>>includeEnd('debug');\n\n  const times = this.times;\n  const timeEnd = times[times.length - 1];\n  const timeStart = times[0];\n  const timeStretch = timeEnd - timeStart;\n  let divs;\n  if (time < timeStart) {\n    divs = Math.floor((timeStart - time) / timeStretch) + 1;\n    time += divs * timeStretch;\n  }\n  if (time > timeEnd) {\n    divs = Math.floor((time - timeEnd) / timeStretch) + 1;\n    time -= divs * timeStretch;\n  }\n  return time;\n};\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, clamped to the animation period.\n */\nSpline.prototype.clampTime = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"time\", time);\n  //>>includeEnd('debug');\n\n  const times = this.times;\n  return CesiumMath.clamp(time, times[0], times[times.length - 1]);\n};\nexport default Spline;","map":{"version":3,"names":["Cartesian3","Check","CesiumMath","DeveloperError","Quaternion","Spline","times","undefined","points","throwInstantiationError","getPointType","point","Number","prototype","evaluate","findTimeInterval","time","startIndex","length","typeOf","number","i","wrapTime","timeEnd","timeStart","timeStretch","divs","Math","floor","clampTime","clamp"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/Spline.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport CesiumMath from \"./Math.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Quaternion from \"./Quaternion.js\";\n\n/**\n * Creates a curve parameterized and evaluated by time. This type describes an interface\n * and is not intended to be instantiated directly.\n *\n * @alias Spline\n * @constructor\n *\n * @see CatmullRomSpline\n * @see LinearSpline\n * @see HermiteSpline\n * @see QuaternionSpline\n * @see MorphWeightSpline\n */\nfunction Spline() {\n  /**\n   * An array of times for the control points.\n   * @type {number[]}\n   * @default undefined\n   */\n  this.times = undefined;\n\n  /**\n   * An array of control points.\n   * @type {Cartesian3[]|Quaternion[]}\n   * @default undefined\n   */\n  this.points = undefined;\n\n  DeveloperError.throwInstantiationError();\n}\n\n/**\n * Gets the type of the point. This helps a spline determine how to interpolate\n * and return its values.\n *\n * @param {number|Cartesian3|Quaternion} point\n * @returns {*} The type of the point.\n *\n * @exception {DeveloperError} value must be a Cartesian3, Quaternion, or number.\n *\n * @private\n */\nSpline.getPointType = function (point) {\n  if (typeof point === \"number\") {\n    return Number;\n  }\n  if (point instanceof Cartesian3) {\n    return Cartesian3;\n  }\n  if (point instanceof Quaternion) {\n    return Quaternion;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\n    \"point must be a Cartesian3, Quaternion, or number.\",\n  );\n  //>>includeEnd('debug');\n};\n\n/**\n * Evaluates the curve at a given time.\n * @function\n *\n * @param {number} time The time at which to evaluate the curve.\n * @param {Cartesian3|Quaternion|number[]} [result] The object onto which to store the result.\n * @returns {Cartesian3|Quaternion|number[]} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nSpline.prototype.evaluate = DeveloperError.throwInstantiationError;\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n *\n * @param {number} time The time.\n * @param {number} startIndex The index from which to start the search.\n * @returns {number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nSpline.prototype.findTimeInterval = function (time, startIndex) {\n  const times = this.times;\n  const length = times.length;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"time\", time);\n  if (time < times[0] || time > times[length - 1]) {\n    throw new DeveloperError(\"time is out of range.\");\n  }\n  //>>includeEnd('debug');\n\n  // Take advantage of temporal coherence by checking current, next and previous intervals\n  // for containment of time.\n  startIndex = startIndex ?? 0;\n\n  if (time >= times[startIndex]) {\n    if (startIndex + 1 < length && time < times[startIndex + 1]) {\n      return startIndex;\n    } else if (startIndex + 2 < length && time < times[startIndex + 2]) {\n      return startIndex + 1;\n    }\n  } else if (startIndex - 1 >= 0 && time >= times[startIndex - 1]) {\n    return startIndex - 1;\n  }\n\n  // The above failed so do a linear search. For the use cases so far, the\n  // length of the list is less than 10. In the future, if there is a bottle neck,\n  // it might be here.\n\n  let i;\n  if (time > times[startIndex]) {\n    for (i = startIndex; i < length - 1; ++i) {\n      if (time >= times[i] && time < times[i + 1]) {\n        break;\n      }\n    }\n  } else {\n    for (i = startIndex - 1; i >= 0; --i) {\n      if (time >= times[i] && time < times[i + 1]) {\n        break;\n      }\n    }\n  }\n\n  if (i === length - 1) {\n    i = length - 2;\n  }\n\n  return i;\n};\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, wrapped around the animation period.\n */\nSpline.prototype.wrapTime = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"time\", time);\n  //>>includeEnd('debug');\n\n  const times = this.times;\n  const timeEnd = times[times.length - 1];\n  const timeStart = times[0];\n  const timeStretch = timeEnd - timeStart;\n  let divs;\n  if (time < timeStart) {\n    divs = Math.floor((timeStart - time) / timeStretch) + 1;\n    time += divs * timeStretch;\n  }\n  if (time > timeEnd) {\n    divs = Math.floor((time - timeEnd) / timeStretch) + 1;\n    time -= divs * timeStretch;\n  }\n  return time;\n};\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, clamped to the animation period.\n */\nSpline.prototype.clampTime = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"time\", time);\n  //>>includeEnd('debug');\n\n  const times = this.times;\n  return CesiumMath.clamp(time, times[0], times[times.length - 1]);\n};\n\nexport default Spline;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}