{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-hex.js\";\nimport \"core-js/modules/esnext.uint8-array.to-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.to-hex.js\";\nimport Check from \"../Core/Check.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport JobType from \"./JobType.js\";\nimport ModelComponents from \"./ModelComponents.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\nimport CesiumMath from \"../Core/Math.js\";\n\n/**\n * Loads a vertex buffer from a glTF buffer view.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfVertexBufferLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {object} options Object with the following properties:\n * @param {ResourceCache} options.resourceCache The {@link ResourceCache} (to avoid circular dependencies).\n * @param {object} options.gltf The glTF JSON.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {number} [options.bufferViewId] The bufferView ID corresponding to the vertex buffer.\n * @param {object} [options.primitive] The primitive containing the Draco extension.\n * @param {object} [options.draco] The Draco extension object.\n * @param {string} [options.attributeSemantic] The attribute semantic, e.g. POSITION or NORMAL.\n * @param {number} [options.accessorId] The accessor id.\n * @param {string} [options.cacheKey] The cache key of the resource.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {boolean} [options.loadBuffer=false] Load vertex buffer as a GPU vertex buffer.\n * @param {boolean} [options.loadTypedArray=false] Load vertex buffer as a typed array.\n *\n * @exception {DeveloperError} One of options.bufferViewId and options.draco must be defined.\n * @exception {DeveloperError} When options.draco is defined options.attributeSemantic must also be defined.\n * @exception {DeveloperError} When options.draco is defined options.accessorId must also be defined.\n *\n * @private\n */\nfunction GltfVertexBufferLoader(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const resourceCache = options.resourceCache;\n  const gltf = options.gltf;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const bufferViewId = options.bufferViewId;\n  const primitive = options.primitive;\n  const draco = options.draco;\n  const attributeSemantic = options.attributeSemantic;\n  const accessorId = options.accessorId;\n  const cacheKey = options.cacheKey;\n  const spz = options.spz;\n  const asynchronous = options.asynchronous ?? true;\n  const loadBuffer = options.loadBuffer ?? false;\n  const loadTypedArray = options.loadTypedArray ?? false;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"options.resourceCache\", resourceCache);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  if (!loadBuffer && !loadTypedArray) {\n    throw new DeveloperError(\"At least one of loadBuffer and loadTypedArray must be true.\");\n  }\n  const hasBufferViewId = defined(bufferViewId);\n  const hasPrimitive = defined(primitive);\n  const hasDraco = hasDracoCompression(draco, attributeSemantic);\n  const hasAttributeSemantic = defined(attributeSemantic);\n  const hasAccessorId = defined(accessorId);\n  const hasSpz = defined(spz);\n  if (hasBufferViewId === (hasDraco !== hasSpz)) {\n    throw new DeveloperError(\"One of options.bufferViewId, options.draco, or options.spz must be defined.\");\n  }\n  if (hasDraco && !hasAttributeSemantic) {\n    throw new DeveloperError(\"When options.draco is defined options.attributeSemantic must also be defined.\");\n  }\n  if (hasDraco && !hasAccessorId) {\n    throw new DeveloperError(\"When options.draco is defined options.accessorId must also be defined.\");\n  }\n  if (hasDraco && !hasPrimitive) {\n    throw new DeveloperError(\"When options.draco is defined options.primitive must also be defined.\");\n  }\n  if (hasDraco) {\n    Check.typeOf.object(\"options.primitive\", primitive);\n    Check.typeOf.object(\"options.draco\", draco);\n    Check.typeOf.string(\"options.attributeSemantic\", attributeSemantic);\n    Check.typeOf.number(\"options.accessorId\", accessorId);\n  }\n\n  //>>includeEnd('debug');\n\n  this._resourceCache = resourceCache;\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._gltf = gltf;\n  this._bufferViewId = bufferViewId;\n  this._primitive = primitive;\n  this._draco = draco;\n  this._spz = spz;\n  this._attributeSemantic = attributeSemantic;\n  this._accessorId = accessorId;\n  this._cacheKey = cacheKey;\n  this._asynchronous = asynchronous;\n  this._loadBuffer = loadBuffer;\n  this._loadTypedArray = loadTypedArray;\n  this._bufferViewLoader = undefined;\n  this._dracoLoader = undefined;\n  this._quantization = undefined;\n  this._typedArray = undefined;\n  this._buffer = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n}\nif (defined(Object.create)) {\n  GltfVertexBufferLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfVertexBufferLoader.prototype.constructor = GltfVertexBufferLoader;\n}\nObject.defineProperties(GltfVertexBufferLoader.prototype, {\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfVertexBufferLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    }\n  },\n  /**\n   * The vertex buffer. This is only defined when <code>loadAsTypedArray</code> is false.\n   *\n   * @memberof GltfVertexBufferLoader.prototype\n   *\n   * @type {Buffer}\n   * @readonly\n   * @private\n   */\n  buffer: {\n    get: function () {\n      return this._buffer;\n    }\n  },\n  /**\n   * The typed array containing vertex buffer data. This is only defined when <code>loadAsTypedArray</code> is true.\n   *\n   * @memberof GltfVertexBufferLoader.prototype\n   *\n   * @type {Uint8Array}\n   * @readonly\n   * @private\n   */\n  typedArray: {\n    get: function () {\n      return this._typedArray;\n    }\n  },\n  /**\n   * Information about the quantized vertex attribute after Draco decode.\n   *\n   * @memberof GltfVertexBufferLoader.prototype\n   *\n   * @type {ModelComponents.Quantization}\n   * @readonly\n   * @private\n   */\n  quantization: {\n    get: function () {\n      return this._quantization;\n    }\n  }\n});\nfunction hasDracoCompression(draco, semantic) {\n  return defined(draco) && defined(draco.attributes) && defined(draco.attributes[semantic]);\n}\n\n/**\n * Loads the resource.\n * @returns {Promise<GltfVertexBufferLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfVertexBufferLoader.prototype.load = async function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n  if (defined(this._spz)) {\n    this._promise = loadFromSpz(this);\n    return this._promise;\n  }\n  if (hasDracoCompression(this._draco, this._attributeSemantic)) {\n    this._promise = loadFromDraco(this);\n    return this._promise;\n  }\n  this._promise = loadFromBufferView(this);\n  return this._promise;\n};\nfunction getQuantizationInformation(dracoQuantization, componentDatatype, componentCount, type) {\n  const quantizationBits = dracoQuantization.quantizationBits;\n  const normalizationRange = (1 << quantizationBits) - 1;\n  const normalizationDivisor = 1.0 / normalizationRange;\n  const quantization = new ModelComponents.Quantization();\n  quantization.componentDatatype = componentDatatype;\n  quantization.octEncoded = dracoQuantization.octEncoded;\n  quantization.octEncodedZXY = true;\n  quantization.type = type;\n  if (quantization.octEncoded) {\n    quantization.type = AttributeType.VEC2;\n    quantization.normalizationRange = normalizationRange;\n  } else {\n    const MathType = AttributeType.getMathType(type);\n    if (MathType === Number) {\n      const dimensions = dracoQuantization.range;\n      quantization.quantizedVolumeOffset = dracoQuantization.minValues[0];\n      quantization.quantizedVolumeDimensions = dimensions;\n      quantization.normalizationRange = normalizationRange;\n      quantization.quantizedVolumeStepSize = dimensions * normalizationDivisor;\n    } else {\n      quantization.quantizedVolumeOffset = MathType.unpack(dracoQuantization.minValues);\n      quantization.normalizationRange = MathType.unpack(new Array(componentCount).fill(normalizationRange));\n      const packedDimensions = new Array(componentCount).fill(dracoQuantization.range);\n      quantization.quantizedVolumeDimensions = MathType.unpack(packedDimensions);\n\n      // Computing the step size\n      const packedSteps = packedDimensions.map(function (dimension) {\n        return dimension * normalizationDivisor;\n      });\n      quantization.quantizedVolumeStepSize = MathType.unpack(packedSteps);\n    }\n  }\n  return quantization;\n}\nasync function loadFromSpz(vertexBufferLoader) {\n  vertexBufferLoader._state = ResourceLoaderState.LOADING;\n  const resourceCache = vertexBufferLoader._resourceCache;\n  try {\n    const spzLoader = resourceCache.getSpzLoader({\n      gltf: vertexBufferLoader._gltf,\n      primitive: vertexBufferLoader._primitive,\n      spz: vertexBufferLoader._spz,\n      gltfResource: vertexBufferLoader._gltfResource,\n      baseResource: vertexBufferLoader._baseResource\n    });\n    vertexBufferLoader._spzLoader = spzLoader;\n    await spzLoader.load();\n    if (vertexBufferLoader.isDestroyed()) {\n      return;\n    }\n    vertexBufferLoader._state = ResourceLoaderState.LOADED;\n    return vertexBufferLoader;\n  } catch {\n    if (vertexBufferLoader.isDestroyed()) {\n      return;\n    }\n  }\n}\nfunction getShAttributePrefix(attribute) {\n  const prefix = attribute.startsWith(\"KHR_gaussian_splatting:\") ? \"KHR_gaussian_splatting:\" : \"_\";\n  return `${prefix}SH_DEGREE_`;\n}\nfunction extractSHDegreeAndCoef(attribute) {\n  const prefix = getShAttributePrefix(attribute);\n  const separator = \"_COEF_\";\n  const lStart = prefix.length;\n  const coefIndex = attribute.indexOf(separator, lStart);\n  const l = parseInt(attribute.slice(lStart, coefIndex), 10);\n  const n = parseInt(attribute.slice(coefIndex + separator.length), 10);\n  return {\n    l,\n    n\n  };\n}\nfunction processSpz(vertexBufferLoader) {\n  vertexBufferLoader._state = ResourceLoaderState.PROCESSING;\n  const spzLoader = vertexBufferLoader._spzLoader;\n  const gcloudData = spzLoader.decodedData.gcloud;\n  if (vertexBufferLoader._attributeSemantic === \"POSITION\") {\n    vertexBufferLoader._typedArray = gcloudData.positions;\n  } else if (vertexBufferLoader._attributeSemantic === \"KHR_gaussian_splatting:SCALE\" || vertexBufferLoader._attributeSemantic === \"_SCALE\") {\n    vertexBufferLoader._typedArray = gcloudData.scales;\n  } else if (vertexBufferLoader._attributeSemantic === \"KHR_gaussian_splatting:ROTATION\" || vertexBufferLoader._attributeSemantic === \"_ROTATION\") {\n    vertexBufferLoader._typedArray = gcloudData.rotations;\n  } else if (vertexBufferLoader._attributeSemantic === \"COLOR_0\") {\n    const colors = gcloudData.colors;\n    const alphas = gcloudData.alphas;\n    vertexBufferLoader._typedArray = new Uint8Array(colors.length / 3 * 4);\n    for (let i = 0; i < colors.length / 3; i++) {\n      vertexBufferLoader._typedArray[i * 4] = CesiumMath.clamp(colors[i * 3] * 255.0, 0.0, 255.0);\n      vertexBufferLoader._typedArray[i * 4 + 1] = CesiumMath.clamp(colors[i * 3 + 1] * 255.0, 0.0, 255.0);\n      vertexBufferLoader._typedArray[i * 4 + 2] = CesiumMath.clamp(colors[i * 3 + 2] * 255.0, 0.0, 255.0);\n      vertexBufferLoader._typedArray[i * 4 + 3] = CesiumMath.clamp(alphas[i] * 255.0, 0.0, 255.0);\n    }\n  } else if (vertexBufferLoader._attributeSemantic.includes(\"SH_DEGREE_\")) {\n    const {\n      l,\n      n\n    } = extractSHDegreeAndCoef(vertexBufferLoader._attributeSemantic);\n    const sphericalHarmonicDegree = gcloudData.shDegree;\n    let stride = 0;\n    const base = [0, 9, 24];\n    switch (sphericalHarmonicDegree) {\n      case 1:\n        stride = 9;\n        break;\n      case 2:\n        stride = 24;\n        break;\n      case 3:\n        stride = 45;\n        break;\n    }\n    const count = gcloudData.numPoints;\n    const sh = gcloudData.sh;\n    vertexBufferLoader._typedArray = new Float32Array(count * 3);\n    for (let i = 0; i < count; i++) {\n      const idx = i * stride + base[l - 1] + n * 3;\n      vertexBufferLoader._typedArray[i * 3] = sh[idx];\n      vertexBufferLoader._typedArray[i * 3 + 1] = sh[idx + 1];\n      vertexBufferLoader._typedArray[i * 3 + 2] = sh[idx + 2];\n    }\n  }\n}\nasync function loadFromDraco(vertexBufferLoader) {\n  vertexBufferLoader._state = ResourceLoaderState.LOADING;\n  const resourceCache = vertexBufferLoader._resourceCache;\n  try {\n    const dracoLoader = resourceCache.getDracoLoader({\n      gltf: vertexBufferLoader._gltf,\n      primitive: vertexBufferLoader._primitive,\n      draco: vertexBufferLoader._draco,\n      gltfResource: vertexBufferLoader._gltfResource,\n      baseResource: vertexBufferLoader._baseResource\n    });\n    vertexBufferLoader._dracoLoader = dracoLoader;\n    await dracoLoader.load();\n    if (vertexBufferLoader.isDestroyed()) {\n      return;\n    }\n\n    // Now wait for process() to run to finish loading\n    vertexBufferLoader._state = ResourceLoaderState.LOADED;\n    return vertexBufferLoader;\n  } catch {\n    if (vertexBufferLoader.isDestroyed()) {\n      return;\n    }\n    handleError(vertexBufferLoader);\n  }\n}\nfunction processDraco(vertexBufferLoader) {\n  vertexBufferLoader._state = ResourceLoaderState.PROCESSING;\n  const dracoLoader = vertexBufferLoader._dracoLoader;\n\n  // Get the typed array and quantization information\n  const decodedVertexAttributes = dracoLoader.decodedData.vertexAttributes;\n  const attributeSemantic = vertexBufferLoader._attributeSemantic;\n  const dracoAttribute = decodedVertexAttributes[attributeSemantic];\n  const accessorId = vertexBufferLoader._accessorId;\n  const accessor = vertexBufferLoader._gltf.accessors[accessorId];\n  const type = accessor.type;\n  const typedArray = dracoAttribute.array;\n  const dracoQuantization = dracoAttribute.data.quantization;\n  if (defined(dracoQuantization)) {\n    vertexBufferLoader._quantization = getQuantizationInformation(dracoQuantization, dracoAttribute.data.componentDatatype, dracoAttribute.data.componentsPerAttribute, type);\n  }\n  vertexBufferLoader._typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n}\nasync function loadFromBufferView(vertexBufferLoader) {\n  vertexBufferLoader._state = ResourceLoaderState.LOADING;\n  const resourceCache = vertexBufferLoader._resourceCache;\n  try {\n    const bufferViewLoader = resourceCache.getBufferViewLoader({\n      gltf: vertexBufferLoader._gltf,\n      bufferViewId: vertexBufferLoader._bufferViewId,\n      gltfResource: vertexBufferLoader._gltfResource,\n      baseResource: vertexBufferLoader._baseResource\n    });\n    vertexBufferLoader._bufferViewLoader = bufferViewLoader;\n    await bufferViewLoader.load();\n    if (vertexBufferLoader.isDestroyed()) {\n      return;\n    }\n    vertexBufferLoader._typedArray = bufferViewLoader.typedArray;\n    vertexBufferLoader._state = ResourceLoaderState.PROCESSING;\n    return vertexBufferLoader;\n  } catch (error) {\n    if (vertexBufferLoader.isDestroyed()) {\n      return;\n    }\n    handleError(vertexBufferLoader, error);\n  }\n}\nfunction handleError(vertexBufferLoader, error) {\n  vertexBufferLoader.unload();\n  vertexBufferLoader._state = ResourceLoaderState.FAILED;\n  const errorMessage = \"Failed to load vertex buffer\";\n  throw vertexBufferLoader.getError(errorMessage, error);\n}\nfunction CreateVertexBufferJob() {\n  this.typedArray = undefined;\n  this.context = undefined;\n  this.buffer = undefined;\n}\nCreateVertexBufferJob.prototype.set = function (typedArray, context) {\n  this.typedArray = typedArray;\n  this.context = context;\n};\nCreateVertexBufferJob.prototype.execute = function () {\n  this.buffer = createVertexBuffer(this.typedArray, this.context);\n};\nfunction createVertexBuffer(typedArray, context) {\n  const buffer = Buffer.createVertexBuffer({\n    typedArray: typedArray,\n    context: context,\n    usage: BufferUsage.STATIC_DRAW\n  });\n  buffer.vertexArrayDestroyable = false;\n  return buffer;\n}\nconst scratchVertexBufferJob = new CreateVertexBufferJob();\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfVertexBufferLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === ResourceLoaderState.READY) {\n    return true;\n  }\n  if (this._state !== ResourceLoaderState.LOADED && this._state !== ResourceLoaderState.PROCESSING) {\n    return false;\n  }\n  if (defined(this._dracoLoader)) {\n    try {\n      const ready = this._dracoLoader.process(frameState);\n      if (!ready) {\n        return false;\n      }\n    } catch (error) {\n      handleError(this, error);\n    }\n    processDraco(this);\n  }\n  if (defined(this._spzLoader)) {\n    try {\n      const ready = this._spzLoader.process(frameState);\n      if (!ready) {\n        return false;\n      }\n    } catch (error) {\n      handleError(this, error);\n    }\n    processSpz(this);\n  }\n  let buffer;\n  const typedArray = this._typedArray;\n  if (this._loadBuffer && this._asynchronous) {\n    const vertexBufferJob = scratchVertexBufferJob;\n    vertexBufferJob.set(typedArray, frameState.context);\n    const jobScheduler = frameState.jobScheduler;\n    if (!jobScheduler.execute(vertexBufferJob, JobType.BUFFER)) {\n      // Job scheduler is full. Try again next frame.\n      return false;\n    }\n    buffer = vertexBufferJob.buffer;\n  } else if (this._loadBuffer) {\n    buffer = createVertexBuffer(typedArray, frameState.context);\n  }\n\n  // Unload everything except the vertex buffer\n  this.unload();\n  this._buffer = buffer;\n  this._typedArray = this._loadTypedArray ? typedArray : undefined;\n  this._state = ResourceLoaderState.READY;\n  this._resourceCache.statistics.addGeometryLoader(this);\n  return true;\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfVertexBufferLoader.prototype.unload = function () {\n  if (defined(this._buffer)) {\n    this._buffer.destroy();\n  }\n  const resourceCache = this._resourceCache;\n  if (defined(this._bufferViewLoader) && !this._bufferViewLoader.isDestroyed()) {\n    resourceCache.unload(this._bufferViewLoader);\n  }\n  if (defined(this._dracoLoader)) {\n    resourceCache.unload(this._dracoLoader);\n  }\n  if (defined(this._spzLoader)) {\n    resourceCache.unload(this._spzLoader);\n  }\n  this._bufferViewLoader = undefined;\n  this._dracoLoader = undefined;\n  this._spzLoader = undefined;\n  this._typedArray = undefined;\n  this._buffer = undefined;\n  this._gltf = undefined;\n  this._primitive = undefined;\n};\nexport default GltfVertexBufferLoader;","map":{"version":3,"names":["Check","Frozen","defined","DeveloperError","Buffer","BufferUsage","AttributeType","JobType","ModelComponents","ResourceLoader","ResourceLoaderState","CesiumMath","GltfVertexBufferLoader","options","EMPTY_OBJECT","resourceCache","gltf","gltfResource","baseResource","bufferViewId","primitive","draco","attributeSemantic","accessorId","cacheKey","spz","asynchronous","loadBuffer","loadTypedArray","typeOf","func","object","hasBufferViewId","hasPrimitive","hasDraco","hasDracoCompression","hasAttributeSemantic","hasAccessorId","hasSpz","string","number","_resourceCache","_gltfResource","_baseResource","_gltf","_bufferViewId","_primitive","_draco","_spz","_attributeSemantic","_accessorId","_cacheKey","_asynchronous","_loadBuffer","_loadTypedArray","_bufferViewLoader","undefined","_dracoLoader","_quantization","_typedArray","_buffer","_state","UNLOADED","_promise","Object","create","prototype","constructor","defineProperties","get","buffer","typedArray","quantization","semantic","attributes","load","loadFromSpz","loadFromDraco","loadFromBufferView","getQuantizationInformation","dracoQuantization","componentDatatype","componentCount","type","quantizationBits","normalizationRange","normalizationDivisor","Quantization","octEncoded","octEncodedZXY","VEC2","MathType","getMathType","Number","dimensions","range","quantizedVolumeOffset","minValues","quantizedVolumeDimensions","quantizedVolumeStepSize","unpack","Array","fill","packedDimensions","packedSteps","map","dimension","vertexBufferLoader","LOADING","spzLoader","getSpzLoader","_spzLoader","isDestroyed","LOADED","getShAttributePrefix","attribute","prefix","startsWith","extractSHDegreeAndCoef","separator","lStart","length","coefIndex","indexOf","l","parseInt","slice","n","processSpz","PROCESSING","gcloudData","decodedData","gcloud","positions","scales","rotations","colors","alphas","Uint8Array","i","clamp","includes","sphericalHarmonicDegree","shDegree","stride","base","count","numPoints","sh","Float32Array","idx","dracoLoader","getDracoLoader","handleError","processDraco","decodedVertexAttributes","vertexAttributes","dracoAttribute","accessor","accessors","array","data","componentsPerAttribute","byteOffset","byteLength","bufferViewLoader","getBufferViewLoader","error","unload","FAILED","errorMessage","getError","CreateVertexBufferJob","context","set","execute","createVertexBuffer","usage","STATIC_DRAW","vertexArrayDestroyable","scratchVertexBufferJob","process","frameState","READY","ready","vertexBufferJob","jobScheduler","BUFFER","statistics","addGeometryLoader","destroy"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/GltfVertexBufferLoader.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport JobType from \"./JobType.js\";\nimport ModelComponents from \"./ModelComponents.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\nimport CesiumMath from \"../Core/Math.js\";\n\n/**\n * Loads a vertex buffer from a glTF buffer view.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfVertexBufferLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {object} options Object with the following properties:\n * @param {ResourceCache} options.resourceCache The {@link ResourceCache} (to avoid circular dependencies).\n * @param {object} options.gltf The glTF JSON.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {number} [options.bufferViewId] The bufferView ID corresponding to the vertex buffer.\n * @param {object} [options.primitive] The primitive containing the Draco extension.\n * @param {object} [options.draco] The Draco extension object.\n * @param {string} [options.attributeSemantic] The attribute semantic, e.g. POSITION or NORMAL.\n * @param {number} [options.accessorId] The accessor id.\n * @param {string} [options.cacheKey] The cache key of the resource.\n * @param {boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {boolean} [options.loadBuffer=false] Load vertex buffer as a GPU vertex buffer.\n * @param {boolean} [options.loadTypedArray=false] Load vertex buffer as a typed array.\n *\n * @exception {DeveloperError} One of options.bufferViewId and options.draco must be defined.\n * @exception {DeveloperError} When options.draco is defined options.attributeSemantic must also be defined.\n * @exception {DeveloperError} When options.draco is defined options.accessorId must also be defined.\n *\n * @private\n */\nfunction GltfVertexBufferLoader(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const resourceCache = options.resourceCache;\n  const gltf = options.gltf;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const bufferViewId = options.bufferViewId;\n  const primitive = options.primitive;\n  const draco = options.draco;\n  const attributeSemantic = options.attributeSemantic;\n  const accessorId = options.accessorId;\n  const cacheKey = options.cacheKey;\n  const spz = options.spz;\n  const asynchronous = options.asynchronous ?? true;\n  const loadBuffer = options.loadBuffer ?? false;\n  const loadTypedArray = options.loadTypedArray ?? false;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"options.resourceCache\", resourceCache);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  if (!loadBuffer && !loadTypedArray) {\n    throw new DeveloperError(\n      \"At least one of loadBuffer and loadTypedArray must be true.\",\n    );\n  }\n\n  const hasBufferViewId = defined(bufferViewId);\n  const hasPrimitive = defined(primitive);\n  const hasDraco = hasDracoCompression(draco, attributeSemantic);\n  const hasAttributeSemantic = defined(attributeSemantic);\n  const hasAccessorId = defined(accessorId);\n  const hasSpz = defined(spz);\n  if (hasBufferViewId === (hasDraco !== hasSpz)) {\n    throw new DeveloperError(\n      \"One of options.bufferViewId, options.draco, or options.spz must be defined.\",\n    );\n  }\n\n  if (hasDraco && !hasAttributeSemantic) {\n    throw new DeveloperError(\n      \"When options.draco is defined options.attributeSemantic must also be defined.\",\n    );\n  }\n\n  if (hasDraco && !hasAccessorId) {\n    throw new DeveloperError(\n      \"When options.draco is defined options.accessorId must also be defined.\",\n    );\n  }\n\n  if (hasDraco && !hasPrimitive) {\n    throw new DeveloperError(\n      \"When options.draco is defined options.primitive must also be defined.\",\n    );\n  }\n\n  if (hasDraco) {\n    Check.typeOf.object(\"options.primitive\", primitive);\n    Check.typeOf.object(\"options.draco\", draco);\n    Check.typeOf.string(\"options.attributeSemantic\", attributeSemantic);\n    Check.typeOf.number(\"options.accessorId\", accessorId);\n  }\n\n  //>>includeEnd('debug');\n\n  this._resourceCache = resourceCache;\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._gltf = gltf;\n  this._bufferViewId = bufferViewId;\n  this._primitive = primitive;\n  this._draco = draco;\n  this._spz = spz;\n  this._attributeSemantic = attributeSemantic;\n  this._accessorId = accessorId;\n  this._cacheKey = cacheKey;\n  this._asynchronous = asynchronous;\n  this._loadBuffer = loadBuffer;\n  this._loadTypedArray = loadTypedArray;\n  this._bufferViewLoader = undefined;\n  this._dracoLoader = undefined;\n  this._quantization = undefined;\n  this._typedArray = undefined;\n  this._buffer = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n}\n\nif (defined(Object.create)) {\n  GltfVertexBufferLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfVertexBufferLoader.prototype.constructor = GltfVertexBufferLoader;\n}\n\nObject.defineProperties(GltfVertexBufferLoader.prototype, {\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfVertexBufferLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    },\n  },\n  /**\n   * The vertex buffer. This is only defined when <code>loadAsTypedArray</code> is false.\n   *\n   * @memberof GltfVertexBufferLoader.prototype\n   *\n   * @type {Buffer}\n   * @readonly\n   * @private\n   */\n  buffer: {\n    get: function () {\n      return this._buffer;\n    },\n  },\n  /**\n   * The typed array containing vertex buffer data. This is only defined when <code>loadAsTypedArray</code> is true.\n   *\n   * @memberof GltfVertexBufferLoader.prototype\n   *\n   * @type {Uint8Array}\n   * @readonly\n   * @private\n   */\n  typedArray: {\n    get: function () {\n      return this._typedArray;\n    },\n  },\n  /**\n   * Information about the quantized vertex attribute after Draco decode.\n   *\n   * @memberof GltfVertexBufferLoader.prototype\n   *\n   * @type {ModelComponents.Quantization}\n   * @readonly\n   * @private\n   */\n  quantization: {\n    get: function () {\n      return this._quantization;\n    },\n  },\n});\n\nfunction hasDracoCompression(draco, semantic) {\n  return (\n    defined(draco) &&\n    defined(draco.attributes) &&\n    defined(draco.attributes[semantic])\n  );\n}\n\n/**\n * Loads the resource.\n * @returns {Promise<GltfVertexBufferLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfVertexBufferLoader.prototype.load = async function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n\n  if (defined(this._spz)) {\n    this._promise = loadFromSpz(this);\n    return this._promise;\n  }\n\n  if (hasDracoCompression(this._draco, this._attributeSemantic)) {\n    this._promise = loadFromDraco(this);\n    return this._promise;\n  }\n\n  this._promise = loadFromBufferView(this);\n  return this._promise;\n};\n\nfunction getQuantizationInformation(\n  dracoQuantization,\n  componentDatatype,\n  componentCount,\n  type,\n) {\n  const quantizationBits = dracoQuantization.quantizationBits;\n  const normalizationRange = (1 << quantizationBits) - 1;\n  const normalizationDivisor = 1.0 / normalizationRange;\n\n  const quantization = new ModelComponents.Quantization();\n  quantization.componentDatatype = componentDatatype;\n  quantization.octEncoded = dracoQuantization.octEncoded;\n  quantization.octEncodedZXY = true;\n  quantization.type = type;\n\n  if (quantization.octEncoded) {\n    quantization.type = AttributeType.VEC2;\n    quantization.normalizationRange = normalizationRange;\n  } else {\n    const MathType = AttributeType.getMathType(type);\n    if (MathType === Number) {\n      const dimensions = dracoQuantization.range;\n      quantization.quantizedVolumeOffset = dracoQuantization.minValues[0];\n      quantization.quantizedVolumeDimensions = dimensions;\n      quantization.normalizationRange = normalizationRange;\n      quantization.quantizedVolumeStepSize = dimensions * normalizationDivisor;\n    } else {\n      quantization.quantizedVolumeOffset = MathType.unpack(\n        dracoQuantization.minValues,\n      );\n      quantization.normalizationRange = MathType.unpack(\n        new Array(componentCount).fill(normalizationRange),\n      );\n      const packedDimensions = new Array(componentCount).fill(\n        dracoQuantization.range,\n      );\n      quantization.quantizedVolumeDimensions =\n        MathType.unpack(packedDimensions);\n\n      // Computing the step size\n      const packedSteps = packedDimensions.map(function (dimension) {\n        return dimension * normalizationDivisor;\n      });\n      quantization.quantizedVolumeStepSize = MathType.unpack(packedSteps);\n    }\n  }\n\n  return quantization;\n}\n\nasync function loadFromSpz(vertexBufferLoader) {\n  vertexBufferLoader._state = ResourceLoaderState.LOADING;\n  const resourceCache = vertexBufferLoader._resourceCache;\n  try {\n    const spzLoader = resourceCache.getSpzLoader({\n      gltf: vertexBufferLoader._gltf,\n      primitive: vertexBufferLoader._primitive,\n      spz: vertexBufferLoader._spz,\n      gltfResource: vertexBufferLoader._gltfResource,\n      baseResource: vertexBufferLoader._baseResource,\n    });\n    vertexBufferLoader._spzLoader = spzLoader;\n    await spzLoader.load();\n\n    if (vertexBufferLoader.isDestroyed()) {\n      return;\n    }\n\n    vertexBufferLoader._state = ResourceLoaderState.LOADED;\n    return vertexBufferLoader;\n  } catch {\n    if (vertexBufferLoader.isDestroyed()) {\n      return;\n    }\n  }\n}\n\nfunction getShAttributePrefix(attribute) {\n  const prefix = attribute.startsWith(\"KHR_gaussian_splatting:\")\n    ? \"KHR_gaussian_splatting:\"\n    : \"_\";\n  return `${prefix}SH_DEGREE_`;\n}\n\nfunction extractSHDegreeAndCoef(attribute) {\n  const prefix = getShAttributePrefix(attribute);\n  const separator = \"_COEF_\";\n\n  const lStart = prefix.length;\n  const coefIndex = attribute.indexOf(separator, lStart);\n\n  const l = parseInt(attribute.slice(lStart, coefIndex), 10);\n  const n = parseInt(attribute.slice(coefIndex + separator.length), 10);\n\n  return { l, n };\n}\n\nfunction processSpz(vertexBufferLoader) {\n  vertexBufferLoader._state = ResourceLoaderState.PROCESSING;\n  const spzLoader = vertexBufferLoader._spzLoader;\n\n  const gcloudData = spzLoader.decodedData.gcloud;\n\n  if (vertexBufferLoader._attributeSemantic === \"POSITION\") {\n    vertexBufferLoader._typedArray = gcloudData.positions;\n  } else if (\n    vertexBufferLoader._attributeSemantic === \"KHR_gaussian_splatting:SCALE\" ||\n    vertexBufferLoader._attributeSemantic === \"_SCALE\"\n  ) {\n    vertexBufferLoader._typedArray = gcloudData.scales;\n  } else if (\n    vertexBufferLoader._attributeSemantic ===\n      \"KHR_gaussian_splatting:ROTATION\" ||\n    vertexBufferLoader._attributeSemantic === \"_ROTATION\"\n  ) {\n    vertexBufferLoader._typedArray = gcloudData.rotations;\n  } else if (vertexBufferLoader._attributeSemantic === \"COLOR_0\") {\n    const colors = gcloudData.colors;\n    const alphas = gcloudData.alphas;\n    vertexBufferLoader._typedArray = new Uint8Array((colors.length / 3) * 4);\n    for (let i = 0; i < colors.length / 3; i++) {\n      vertexBufferLoader._typedArray[i * 4] = CesiumMath.clamp(\n        colors[i * 3] * 255.0,\n        0.0,\n        255.0,\n      );\n      vertexBufferLoader._typedArray[i * 4 + 1] = CesiumMath.clamp(\n        colors[i * 3 + 1] * 255.0,\n        0.0,\n        255.0,\n      );\n      vertexBufferLoader._typedArray[i * 4 + 2] = CesiumMath.clamp(\n        colors[i * 3 + 2] * 255.0,\n        0.0,\n        255.0,\n      );\n      vertexBufferLoader._typedArray[i * 4 + 3] = CesiumMath.clamp(\n        alphas[i] * 255.0,\n        0.0,\n        255.0,\n      );\n    }\n  } else if (vertexBufferLoader._attributeSemantic.includes(\"SH_DEGREE_\")) {\n    const { l, n } = extractSHDegreeAndCoef(\n      vertexBufferLoader._attributeSemantic,\n    );\n    const sphericalHarmonicDegree = gcloudData.shDegree;\n    let stride = 0;\n    const base = [0, 9, 24];\n    switch (sphericalHarmonicDegree) {\n      case 1:\n        stride = 9;\n        break;\n      case 2:\n        stride = 24;\n        break;\n      case 3:\n        stride = 45;\n        break;\n    }\n    const count = gcloudData.numPoints;\n    const sh = gcloudData.sh;\n    vertexBufferLoader._typedArray = new Float32Array(count * 3);\n    for (let i = 0; i < count; i++) {\n      const idx = i * stride + base[l - 1] + n * 3;\n      vertexBufferLoader._typedArray[i * 3] = sh[idx];\n      vertexBufferLoader._typedArray[i * 3 + 1] = sh[idx + 1];\n      vertexBufferLoader._typedArray[i * 3 + 2] = sh[idx + 2];\n    }\n  }\n}\n\nasync function loadFromDraco(vertexBufferLoader) {\n  vertexBufferLoader._state = ResourceLoaderState.LOADING;\n  const resourceCache = vertexBufferLoader._resourceCache;\n  try {\n    const dracoLoader = resourceCache.getDracoLoader({\n      gltf: vertexBufferLoader._gltf,\n      primitive: vertexBufferLoader._primitive,\n      draco: vertexBufferLoader._draco,\n      gltfResource: vertexBufferLoader._gltfResource,\n      baseResource: vertexBufferLoader._baseResource,\n    });\n    vertexBufferLoader._dracoLoader = dracoLoader;\n    await dracoLoader.load();\n\n    if (vertexBufferLoader.isDestroyed()) {\n      return;\n    }\n\n    // Now wait for process() to run to finish loading\n    vertexBufferLoader._state = ResourceLoaderState.LOADED;\n    return vertexBufferLoader;\n  } catch {\n    if (vertexBufferLoader.isDestroyed()) {\n      return;\n    }\n\n    handleError(vertexBufferLoader);\n  }\n}\n\nfunction processDraco(vertexBufferLoader) {\n  vertexBufferLoader._state = ResourceLoaderState.PROCESSING;\n  const dracoLoader = vertexBufferLoader._dracoLoader;\n\n  // Get the typed array and quantization information\n  const decodedVertexAttributes = dracoLoader.decodedData.vertexAttributes;\n  const attributeSemantic = vertexBufferLoader._attributeSemantic;\n  const dracoAttribute = decodedVertexAttributes[attributeSemantic];\n  const accessorId = vertexBufferLoader._accessorId;\n  const accessor = vertexBufferLoader._gltf.accessors[accessorId];\n  const type = accessor.type;\n  const typedArray = dracoAttribute.array;\n  const dracoQuantization = dracoAttribute.data.quantization;\n  if (defined(dracoQuantization)) {\n    vertexBufferLoader._quantization = getQuantizationInformation(\n      dracoQuantization,\n      dracoAttribute.data.componentDatatype,\n      dracoAttribute.data.componentsPerAttribute,\n      type,\n    );\n  }\n\n  vertexBufferLoader._typedArray = new Uint8Array(\n    typedArray.buffer,\n    typedArray.byteOffset,\n    typedArray.byteLength,\n  );\n}\n\nasync function loadFromBufferView(vertexBufferLoader) {\n  vertexBufferLoader._state = ResourceLoaderState.LOADING;\n  const resourceCache = vertexBufferLoader._resourceCache;\n  try {\n    const bufferViewLoader = resourceCache.getBufferViewLoader({\n      gltf: vertexBufferLoader._gltf,\n      bufferViewId: vertexBufferLoader._bufferViewId,\n      gltfResource: vertexBufferLoader._gltfResource,\n      baseResource: vertexBufferLoader._baseResource,\n    });\n    vertexBufferLoader._bufferViewLoader = bufferViewLoader;\n    await bufferViewLoader.load();\n\n    if (vertexBufferLoader.isDestroyed()) {\n      return;\n    }\n\n    vertexBufferLoader._typedArray = bufferViewLoader.typedArray;\n    vertexBufferLoader._state = ResourceLoaderState.PROCESSING;\n    return vertexBufferLoader;\n  } catch (error) {\n    if (vertexBufferLoader.isDestroyed()) {\n      return;\n    }\n\n    handleError(vertexBufferLoader, error);\n  }\n}\n\nfunction handleError(vertexBufferLoader, error) {\n  vertexBufferLoader.unload();\n  vertexBufferLoader._state = ResourceLoaderState.FAILED;\n  const errorMessage = \"Failed to load vertex buffer\";\n  throw vertexBufferLoader.getError(errorMessage, error);\n}\n\nfunction CreateVertexBufferJob() {\n  this.typedArray = undefined;\n  this.context = undefined;\n  this.buffer = undefined;\n}\n\nCreateVertexBufferJob.prototype.set = function (typedArray, context) {\n  this.typedArray = typedArray;\n  this.context = context;\n};\n\nCreateVertexBufferJob.prototype.execute = function () {\n  this.buffer = createVertexBuffer(this.typedArray, this.context);\n};\n\nfunction createVertexBuffer(typedArray, context) {\n  const buffer = Buffer.createVertexBuffer({\n    typedArray: typedArray,\n    context: context,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  buffer.vertexArrayDestroyable = false;\n  return buffer;\n}\n\nconst scratchVertexBufferJob = new CreateVertexBufferJob();\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfVertexBufferLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === ResourceLoaderState.READY) {\n    return true;\n  }\n\n  if (\n    this._state !== ResourceLoaderState.LOADED &&\n    this._state !== ResourceLoaderState.PROCESSING\n  ) {\n    return false;\n  }\n\n  if (defined(this._dracoLoader)) {\n    try {\n      const ready = this._dracoLoader.process(frameState);\n      if (!ready) {\n        return false;\n      }\n    } catch (error) {\n      handleError(this, error);\n    }\n\n    processDraco(this);\n  }\n\n  if (defined(this._spzLoader)) {\n    try {\n      const ready = this._spzLoader.process(frameState);\n      if (!ready) {\n        return false;\n      }\n    } catch (error) {\n      handleError(this, error);\n    }\n\n    processSpz(this);\n  }\n\n  let buffer;\n  const typedArray = this._typedArray;\n  if (this._loadBuffer && this._asynchronous) {\n    const vertexBufferJob = scratchVertexBufferJob;\n    vertexBufferJob.set(typedArray, frameState.context);\n    const jobScheduler = frameState.jobScheduler;\n    if (!jobScheduler.execute(vertexBufferJob, JobType.BUFFER)) {\n      // Job scheduler is full. Try again next frame.\n      return false;\n    }\n    buffer = vertexBufferJob.buffer;\n  } else if (this._loadBuffer) {\n    buffer = createVertexBuffer(typedArray, frameState.context);\n  }\n\n  // Unload everything except the vertex buffer\n  this.unload();\n\n  this._buffer = buffer;\n  this._typedArray = this._loadTypedArray ? typedArray : undefined;\n  this._state = ResourceLoaderState.READY;\n  this._resourceCache.statistics.addGeometryLoader(this);\n  return true;\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfVertexBufferLoader.prototype.unload = function () {\n  if (defined(this._buffer)) {\n    this._buffer.destroy();\n  }\n\n  const resourceCache = this._resourceCache;\n\n  if (\n    defined(this._bufferViewLoader) &&\n    !this._bufferViewLoader.isDestroyed()\n  ) {\n    resourceCache.unload(this._bufferViewLoader);\n  }\n\n  if (defined(this._dracoLoader)) {\n    resourceCache.unload(this._dracoLoader);\n  }\n\n  if (defined(this._spzLoader)) {\n    resourceCache.unload(this._spzLoader);\n  }\n\n  this._bufferViewLoader = undefined;\n  this._dracoLoader = undefined;\n  this._spzLoader = undefined;\n  this._typedArray = undefined;\n  this._buffer = undefined;\n  this._gltf = undefined;\n  this._primitive = undefined;\n};\n\nexport default GltfVertexBufferLoader;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}