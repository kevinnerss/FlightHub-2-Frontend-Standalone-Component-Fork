{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Check from \"../Core/Check.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport VoxelBoundsCollection from \"./VoxelBoundsCollection.js\";\nimport ClippingPlane from \"./ClippingPlane.js\";\n\n/**\n * A box {@link VoxelShape}.\n *\n * @alias VoxelBoxShape\n * @constructor\n *\n * @see VoxelShape\n * @see VoxelEllipsoidShape\n * @see VoxelCylinderShape\n * @see VoxelShapeType\n *\n * @private\n */\nfunction VoxelBoxShape() {\n  this._orientedBoundingBox = new OrientedBoundingBox();\n  this._boundingSphere = new BoundingSphere();\n  this._boundTransform = new Matrix4();\n  this._shapeTransform = new Matrix4();\n\n  /**\n   * The minimum bounds of the shape.\n   * @type {Cartesian3}\n   * @private\n   */\n  this._minBounds = VoxelBoxShape.DefaultMinBounds.clone();\n\n  /**\n   * The maximum bounds of the shape.\n   * @type {Cartesian3}\n   * @private\n   */\n  this._maxBounds = VoxelBoxShape.DefaultMaxBounds.clone();\n\n  /**\n   * The minimum render bounds of the shape.\n   * @type {Cartesian3}\n   * @private\n   */\n  this._renderMinBounds = VoxelBoxShape.DefaultMinBounds.clone();\n\n  /**\n   * The maximum render bounds of the shape.\n   * @type {Cartesian3}\n   * @private\n   */\n  this._renderMaxBounds = VoxelBoxShape.DefaultMaxBounds.clone();\n  const {\n    DefaultMinBounds,\n    DefaultMaxBounds\n  } = VoxelBoxShape;\n  const boundPlanes = [new ClippingPlane(Cartesian3.negate(Cartesian3.UNIT_X, new Cartesian3()), DefaultMinBounds.x), new ClippingPlane(Cartesian3.negate(Cartesian3.UNIT_Y, new Cartesian3()), DefaultMinBounds.y), new ClippingPlane(Cartesian3.negate(Cartesian3.UNIT_Z, new Cartesian3()), DefaultMinBounds.z), new ClippingPlane(Cartesian3.UNIT_X, -DefaultMaxBounds.x), new ClippingPlane(Cartesian3.UNIT_Y, -DefaultMaxBounds.y), new ClippingPlane(Cartesian3.UNIT_Z, -DefaultMaxBounds.z)];\n  this._renderBoundPlanes = new VoxelBoundsCollection({\n    planes: boundPlanes\n  });\n  this._shaderUniforms = {\n    boxEcToXyz: new Matrix3(),\n    boxLocalToShapeUvScale: new Cartesian3(),\n    boxLocalToShapeUvTranslate: new Cartesian3()\n  };\n  this._shaderDefines = {\n    BOX_INTERSECTION_INDEX: undefined\n  };\n  this._shaderMaximumIntersectionsLength = 0; // not known until update\n}\nObject.defineProperties(VoxelBoxShape.prototype, {\n  /**\n   * An oriented bounding box containing the bounded shape.\n   *\n   * @memberof VoxelBoxShape.prototype\n   * @type {OrientedBoundingBox}\n   * @readonly\n   * @private\n   */\n  orientedBoundingBox: {\n    get: function () {\n      return this._orientedBoundingBox;\n    }\n  },\n  /**\n   * A collection of planes used for the render bounds\n   * @memberof VoxelBoxShape.prototype\n   * @type {VoxelBoundsCollection}\n   * @readonly\n   * @private\n   */\n  renderBoundPlanes: {\n    get: function () {\n      return this._renderBoundPlanes;\n    }\n  },\n  /**\n   * A bounding sphere containing the bounded shape.\n   *\n   * @memberof VoxelBoxShape.prototype\n   * @type {BoundingSphere}\n   * @readonly\n   * @private\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    }\n  },\n  /**\n   * A transformation matrix containing the bounded shape.\n   *\n   * @memberof VoxelBoxShape.prototype\n   * @type {Matrix4}\n   * @readonly\n   * @private\n   */\n  boundTransform: {\n    get: function () {\n      return this._boundTransform;\n    }\n  },\n  /**\n   * A transformation matrix containing the shape, ignoring the bounds.\n   *\n   * @memberof VoxelBoxShape.prototype\n   * @type {Matrix4}\n   * @readonly\n   * @private\n   */\n  shapeTransform: {\n    get: function () {\n      return this._shapeTransform;\n    }\n  },\n  /**\n   * @memberof VoxelBoxShape.prototype\n   * @type {Object<string, any>}\n   * @readonly\n   * @private\n   */\n  shaderUniforms: {\n    get: function () {\n      return this._shaderUniforms;\n    }\n  },\n  /**\n   * @memberof VoxelBoxShape.prototype\n   * @type {Object<string, any>}\n   * @readonly\n   * @private\n   */\n  shaderDefines: {\n    get: function () {\n      return this._shaderDefines;\n    }\n  },\n  /**\n   * The maximum number of intersections against the shape for any ray direction.\n   * @memberof VoxelBoxShape.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  shaderMaximumIntersectionsLength: {\n    get: function () {\n      return this._shaderMaximumIntersectionsLength;\n    }\n  }\n});\nconst scratchCenter = new Cartesian3();\nconst scratchScale = new Cartesian3();\nconst scratchRotation = new Matrix3();\nconst scratchClipMinBounds = new Cartesian3();\nconst scratchClipMaxBounds = new Cartesian3();\n\n/**\n * Update the shape's state.\n * @private\n * @param {Matrix4} modelMatrix The model matrix.\n * @param {Cartesian3} minBounds The minimum bounds.\n * @param {Cartesian3} maxBounds The maximum bounds.\n * @param {Cartesian3} [clipMinBounds] The minimum clip bounds.\n * @param {Cartesian3} [clipMaxBounds] The maximum clip bounds.\n * @returns {boolean} Whether the shape is visible.\n */\nVoxelBoxShape.prototype.update = function (modelMatrix, minBounds, maxBounds, clipMinBounds, clipMaxBounds) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"modelMatrix\", modelMatrix);\n  Check.typeOf.object(\"minBounds\", minBounds);\n  Check.typeOf.object(\"maxBounds\", maxBounds);\n  //>>includeEnd('debug');\n\n  clipMinBounds = clipMinBounds ?? minBounds.clone(scratchClipMinBounds);\n  clipMaxBounds = clipMaxBounds ?? maxBounds.clone(scratchClipMaxBounds);\n  minBounds = Cartesian3.clone(minBounds, this._minBounds);\n  maxBounds = Cartesian3.clone(maxBounds, this._maxBounds);\n  const renderMinBounds = Cartesian3.clamp(minBounds, clipMinBounds, clipMaxBounds, this._renderMinBounds);\n  const renderMaxBounds = Cartesian3.clamp(maxBounds, clipMinBounds, clipMaxBounds, this._renderMaxBounds);\n\n  // Box is not visible if:\n  // - any of the min render bounds exceed the max render bounds\n  // - two or more of the min bounds equal the max bounds (line / point)\n  // - scale is 0 for any component (too annoying to reconstruct rotation matrix)\n  const scale = Matrix4.getScale(modelMatrix, scratchScale);\n  if (renderMinBounds.x > renderMaxBounds.x || renderMinBounds.y > renderMaxBounds.y || renderMinBounds.z > renderMaxBounds.z || (renderMinBounds.x === renderMaxBounds.x) + (renderMinBounds.y === renderMaxBounds.y) + (renderMinBounds.z === renderMaxBounds.z) >= 2 || scale.x === 0.0 || scale.y === 0.0 || scale.z === 0.0) {\n    return false;\n  }\n\n  // Update the render bounds planes\n  const renderBoundPlanes = this._renderBoundPlanes;\n  renderBoundPlanes.get(0).distance = renderMinBounds.x;\n  renderBoundPlanes.get(1).distance = renderMinBounds.y;\n  renderBoundPlanes.get(2).distance = renderMinBounds.z;\n  renderBoundPlanes.get(3).distance = -renderMaxBounds.x;\n  renderBoundPlanes.get(4).distance = -renderMaxBounds.y;\n  renderBoundPlanes.get(5).distance = -renderMaxBounds.z;\n  this._shapeTransform = Matrix4.clone(modelMatrix, this._shapeTransform);\n  this._orientedBoundingBox = getBoxChunkObb(renderMinBounds, renderMaxBounds, this._shapeTransform, this._orientedBoundingBox);\n\n  // All of the box bounds go from -1 to +1, so the model matrix scale can be\n  // used as the oriented bounding box half axes.\n  this._boundTransform = Matrix4.fromRotationTranslation(this._orientedBoundingBox.halfAxes, this._orientedBoundingBox.center, this._boundTransform);\n  this._boundingSphere = BoundingSphere.fromOrientedBoundingBox(this._orientedBoundingBox, this._boundingSphere);\n  const shaderUniforms = this._shaderUniforms;\n  const shaderDefines = this._shaderDefines;\n\n  // To keep things simple, clear the defines every time\n  for (const key in shaderDefines) {\n    if (shaderDefines.hasOwnProperty(key)) {\n      shaderDefines[key] = undefined;\n    }\n  }\n\n  // Keep track of how many intersections there are going to be.\n  let intersectionCount = 0;\n  shaderDefines[\"BOX_INTERSECTION_INDEX\"] = intersectionCount;\n  intersectionCount += 1;\n\n  // Compute scale and translation to transform from UV space to bounded UV space\n  const min = minBounds;\n  const max = maxBounds;\n  const boxLocalToShapeUvScale = Cartesian3.fromElements(boundScale(min.x, max.x), boundScale(min.y, max.y), boundScale(min.z, max.z), shaderUniforms.boxLocalToShapeUvScale);\n  shaderUniforms.boxLocalToShapeUvTranslate = Cartesian3.negate(Cartesian3.multiplyComponents(boxLocalToShapeUvScale, min, shaderUniforms.boxLocalToShapeUvTranslate), shaderUniforms.boxLocalToShapeUvTranslate);\n  this._shaderMaximumIntersectionsLength = intersectionCount;\n  return true;\n};\nfunction boundScale(minBound, maxBound) {\n  return CesiumMath.equalsEpsilon(minBound, maxBound, CesiumMath.EPSILON7) ? 1.0 : 1.0 / (maxBound - minBound);\n}\nconst scratchTransformPositionWorldToLocal = new Matrix4();\n/**\n * Update any view-dependent transforms.\n * @private\n * @param {FrameState} frameState The frame state.\n */\nVoxelBoxShape.prototype.updateViewTransforms = function (frameState) {\n  const shaderUniforms = this._shaderUniforms;\n  const transformPositionWorldToLocal = Matrix4.inverse(this._shapeTransform, scratchTransformPositionWorldToLocal);\n  const transformDirectionWorldToLocal = Matrix4.getMatrix3(transformPositionWorldToLocal, shaderUniforms.boxEcToXyz);\n  const rotateViewToWorld = frameState.context.uniformState.inverseViewRotation;\n  Matrix3.multiply(transformDirectionWorldToLocal, rotateViewToWorld, shaderUniforms.boxEcToXyz);\n};\n\n/**\n * Convert a local coordinate to the shape's UV space.\n * @private\n * @param {Cartesian3} positionLocal The local coordinate to convert.\n * @param {Cartesian3} result The Cartesian3 to store the result in.\n * @returns {Cartesian3} The converted UV coordinate.\n */\nVoxelBoxShape.prototype.convertLocalToShapeUvSpace = function (positionLocal, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"positionLocal\", positionLocal);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const {\n    boxLocalToShapeUvScale,\n    boxLocalToShapeUvTranslate\n  } = this._shaderUniforms;\n  return Cartesian3.add(Cartesian3.multiplyComponents(positionLocal, boxLocalToShapeUvScale, result), boxLocalToShapeUvTranslate, result);\n};\nconst scratchTileMinBounds = new Cartesian3();\nconst scratchTileMaxBounds = new Cartesian3();\n\n/**\n * Computes an oriented bounding box for a specified tile.\n * @private\n * @param {number} tileLevel The tile's level.\n * @param {number} tileX The tile's x coordinate.\n * @param {number} tileY The tile's y coordinate.\n * @param {number} tileZ The tile's z coordinate.\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified tile\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelBoxShape.prototype.computeOrientedBoundingBoxForTile = function (tileLevel, tileX, tileY, tileZ, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"tileLevel\", tileLevel);\n  Check.typeOf.number(\"tileX\", tileX);\n  Check.typeOf.number(\"tileY\", tileY);\n  Check.typeOf.number(\"tileZ\", tileZ);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const minBounds = this._minBounds;\n  const maxBounds = this._maxBounds;\n  const sizeAtLevel = 1.0 / Math.pow(2, tileLevel);\n  const tileMinBounds = Cartesian3.fromElements(CesiumMath.lerp(minBounds.x, maxBounds.x, sizeAtLevel * tileX), CesiumMath.lerp(minBounds.y, maxBounds.y, sizeAtLevel * tileY), CesiumMath.lerp(minBounds.z, maxBounds.z, sizeAtLevel * tileZ), scratchTileMinBounds);\n  const tileMaxBounds = Cartesian3.fromElements(CesiumMath.lerp(minBounds.x, maxBounds.x, sizeAtLevel * (tileX + 1)), CesiumMath.lerp(minBounds.y, maxBounds.y, sizeAtLevel * (tileY + 1)), CesiumMath.lerp(minBounds.z, maxBounds.z, sizeAtLevel * (tileZ + 1)), scratchTileMaxBounds);\n  return getBoxChunkObb(tileMinBounds, tileMaxBounds, this._shapeTransform, result);\n};\nconst sampleSizeScratch = new Cartesian3();\n\n/**\n * Computes an oriented bounding box for a specified sample within a specified tile.\n * @private\n * @param {SpatialNode} spatialNode The spatial node containing the sample\n * @param {Cartesian3} tileDimensions The size of the tile in number of samples, before padding\n * @param {Cartesian3} tileUv The sample coordinate within the tile\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified sample\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelBoxShape.prototype.computeOrientedBoundingBoxForSample = function (spatialNode, tileDimensions, tileUv, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"spatialNode\", spatialNode);\n  Check.typeOf.object(\"tileDimensions\", tileDimensions);\n  Check.typeOf.object(\"tileUv\", tileUv);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const tileSizeAtLevel = 1.0 / Math.pow(2, spatialNode.level);\n  const sampleSize = Cartesian3.divideComponents(Cartesian3.ONE, tileDimensions, sampleSizeScratch);\n  const sampleSizeAtLevel = Cartesian3.multiplyByScalar(sampleSize, tileSizeAtLevel, sampleSizeScratch);\n  const minLerp = Cartesian3.multiplyByScalar(Cartesian3.fromElements(spatialNode.x + tileUv.x, spatialNode.y + tileUv.y, spatialNode.z + tileUv.z, scratchTileMinBounds), tileSizeAtLevel, scratchTileMinBounds);\n  const maxLerp = Cartesian3.add(minLerp, sampleSizeAtLevel, scratchTileMaxBounds);\n  const minBounds = this._minBounds;\n  const maxBounds = this._maxBounds;\n  const sampleMinBounds = Cartesian3.fromElements(CesiumMath.lerp(minBounds.x, maxBounds.x, minLerp.x), CesiumMath.lerp(minBounds.y, maxBounds.y, minLerp.y), CesiumMath.lerp(minBounds.z, maxBounds.z, minLerp.z), scratchTileMinBounds);\n  const sampleMaxBounds = Cartesian3.fromElements(CesiumMath.lerp(minBounds.x, maxBounds.x, maxLerp.x), CesiumMath.lerp(minBounds.y, maxBounds.y, maxLerp.y), CesiumMath.lerp(minBounds.z, maxBounds.z, maxLerp.z), scratchTileMaxBounds);\n  return getBoxChunkObb(sampleMinBounds, sampleMaxBounds, this._shapeTransform, result);\n};\n\n/**\n * Defines the minimum bounds of the shape. Corresponds to minimum X, Y, Z.\n * @private\n * @type {Cartesian3}\n * @constant\n * @readonly\n */\nVoxelBoxShape.DefaultMinBounds = Object.freeze(new Cartesian3(-1.0, -1.0, -1.0));\n\n/**\n * Defines the maximum bounds of the shape. Corresponds to maximum X, Y, Z.\n * @private\n * @type {Cartesian3}\n * @constant\n * @readonly\n */\nVoxelBoxShape.DefaultMaxBounds = Object.freeze(new Cartesian3(+1.0, +1.0, +1.0));\nconst scratchBoxScale = new Cartesian3();\n/**\n * Computes an {@link OrientedBoundingBox} for a subregion of the shape.\n *\n * @function\n *\n * @param {Cartesian3} minimumBounds The minimum bounds, in the local coordinates of the shape.\n * @param {Cartesian3} maximumBounds The maximum bounds, in the local coordinates of the shape.\n * @param {Matrix4} matrix The matrix to transform the points.\n * @param {OrientedBoundingBox} result The object onto which to store the result.\n * @returns {OrientedBoundingBox} The oriented bounding box that contains this subregion.\n *\n * @private\n */\nfunction getBoxChunkObb(minimumBounds, maximumBounds, matrix, result) {\n  const defaultMinBounds = VoxelBoxShape.DefaultMinBounds;\n  const defaultMaxBounds = VoxelBoxShape.DefaultMaxBounds;\n  const isDefaultBounds = Cartesian3.equals(minimumBounds, defaultMinBounds) && Cartesian3.equals(maximumBounds, defaultMaxBounds);\n  if (isDefaultBounds) {\n    result.center = Matrix4.getTranslation(matrix, result.center);\n    result.halfAxes = Matrix4.getMatrix3(matrix, result.halfAxes);\n  } else {\n    let scale = Matrix4.getScale(matrix, scratchBoxScale);\n    const localCenter = Cartesian3.midpoint(minimumBounds, maximumBounds, scratchCenter);\n    result.center = Matrix4.multiplyByPoint(matrix, localCenter, result.center);\n    scale = Cartesian3.fromElements(scale.x * 0.5 * (maximumBounds.x - minimumBounds.x), scale.y * 0.5 * (maximumBounds.y - minimumBounds.y), scale.z * 0.5 * (maximumBounds.z - minimumBounds.z), scratchBoxScale);\n    const rotation = Matrix4.getRotation(matrix, scratchRotation);\n    result.halfAxes = Matrix3.setScale(rotation, scale, result.halfAxes);\n  }\n  return result;\n}\nexport default VoxelBoxShape;","map":{"version":3,"names":["BoundingSphere","Cartesian3","CesiumMath","Check","Matrix3","Matrix4","OrientedBoundingBox","VoxelBoundsCollection","ClippingPlane","VoxelBoxShape","_orientedBoundingBox","_boundingSphere","_boundTransform","_shapeTransform","_minBounds","DefaultMinBounds","clone","_maxBounds","DefaultMaxBounds","_renderMinBounds","_renderMaxBounds","boundPlanes","negate","UNIT_X","x","UNIT_Y","y","UNIT_Z","z","_renderBoundPlanes","planes","_shaderUniforms","boxEcToXyz","boxLocalToShapeUvScale","boxLocalToShapeUvTranslate","_shaderDefines","BOX_INTERSECTION_INDEX","undefined","_shaderMaximumIntersectionsLength","Object","defineProperties","prototype","orientedBoundingBox","get","renderBoundPlanes","boundingSphere","boundTransform","shapeTransform","shaderUniforms","shaderDefines","shaderMaximumIntersectionsLength","scratchCenter","scratchScale","scratchRotation","scratchClipMinBounds","scratchClipMaxBounds","update","modelMatrix","minBounds","maxBounds","clipMinBounds","clipMaxBounds","typeOf","object","renderMinBounds","clamp","renderMaxBounds","scale","getScale","distance","getBoxChunkObb","fromRotationTranslation","halfAxes","center","fromOrientedBoundingBox","key","hasOwnProperty","intersectionCount","min","max","fromElements","boundScale","multiplyComponents","minBound","maxBound","equalsEpsilon","EPSILON7","scratchTransformPositionWorldToLocal","updateViewTransforms","frameState","transformPositionWorldToLocal","inverse","transformDirectionWorldToLocal","getMatrix3","rotateViewToWorld","context","uniformState","inverseViewRotation","multiply","convertLocalToShapeUvSpace","positionLocal","result","add","scratchTileMinBounds","scratchTileMaxBounds","computeOrientedBoundingBoxForTile","tileLevel","tileX","tileY","tileZ","number","sizeAtLevel","Math","pow","tileMinBounds","lerp","tileMaxBounds","sampleSizeScratch","computeOrientedBoundingBoxForSample","spatialNode","tileDimensions","tileUv","tileSizeAtLevel","level","sampleSize","divideComponents","ONE","sampleSizeAtLevel","multiplyByScalar","minLerp","maxLerp","sampleMinBounds","sampleMaxBounds","freeze","scratchBoxScale","minimumBounds","maximumBounds","matrix","defaultMinBounds","defaultMaxBounds","isDefaultBounds","equals","getTranslation","localCenter","midpoint","multiplyByPoint","rotation","getRotation","setScale"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/VoxelBoxShape.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Check from \"../Core/Check.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport VoxelBoundsCollection from \"./VoxelBoundsCollection.js\";\nimport ClippingPlane from \"./ClippingPlane.js\";\n\n/**\n * A box {@link VoxelShape}.\n *\n * @alias VoxelBoxShape\n * @constructor\n *\n * @see VoxelShape\n * @see VoxelEllipsoidShape\n * @see VoxelCylinderShape\n * @see VoxelShapeType\n *\n * @private\n */\nfunction VoxelBoxShape() {\n  this._orientedBoundingBox = new OrientedBoundingBox();\n  this._boundingSphere = new BoundingSphere();\n  this._boundTransform = new Matrix4();\n  this._shapeTransform = new Matrix4();\n\n  /**\n   * The minimum bounds of the shape.\n   * @type {Cartesian3}\n   * @private\n   */\n  this._minBounds = VoxelBoxShape.DefaultMinBounds.clone();\n\n  /**\n   * The maximum bounds of the shape.\n   * @type {Cartesian3}\n   * @private\n   */\n  this._maxBounds = VoxelBoxShape.DefaultMaxBounds.clone();\n\n  /**\n   * The minimum render bounds of the shape.\n   * @type {Cartesian3}\n   * @private\n   */\n  this._renderMinBounds = VoxelBoxShape.DefaultMinBounds.clone();\n\n  /**\n   * The maximum render bounds of the shape.\n   * @type {Cartesian3}\n   * @private\n   */\n  this._renderMaxBounds = VoxelBoxShape.DefaultMaxBounds.clone();\n\n  const { DefaultMinBounds, DefaultMaxBounds } = VoxelBoxShape;\n  const boundPlanes = [\n    new ClippingPlane(\n      Cartesian3.negate(Cartesian3.UNIT_X, new Cartesian3()),\n      DefaultMinBounds.x,\n    ),\n    new ClippingPlane(\n      Cartesian3.negate(Cartesian3.UNIT_Y, new Cartesian3()),\n      DefaultMinBounds.y,\n    ),\n    new ClippingPlane(\n      Cartesian3.negate(Cartesian3.UNIT_Z, new Cartesian3()),\n      DefaultMinBounds.z,\n    ),\n    new ClippingPlane(Cartesian3.UNIT_X, -DefaultMaxBounds.x),\n    new ClippingPlane(Cartesian3.UNIT_Y, -DefaultMaxBounds.y),\n    new ClippingPlane(Cartesian3.UNIT_Z, -DefaultMaxBounds.z),\n  ];\n\n  this._renderBoundPlanes = new VoxelBoundsCollection({ planes: boundPlanes });\n\n  this._shaderUniforms = {\n    boxEcToXyz: new Matrix3(),\n    boxLocalToShapeUvScale: new Cartesian3(),\n    boxLocalToShapeUvTranslate: new Cartesian3(),\n  };\n\n  this._shaderDefines = {\n    BOX_INTERSECTION_INDEX: undefined,\n  };\n\n  this._shaderMaximumIntersectionsLength = 0; // not known until update\n}\n\nObject.defineProperties(VoxelBoxShape.prototype, {\n  /**\n   * An oriented bounding box containing the bounded shape.\n   *\n   * @memberof VoxelBoxShape.prototype\n   * @type {OrientedBoundingBox}\n   * @readonly\n   * @private\n   */\n  orientedBoundingBox: {\n    get: function () {\n      return this._orientedBoundingBox;\n    },\n  },\n\n  /**\n   * A collection of planes used for the render bounds\n   * @memberof VoxelBoxShape.prototype\n   * @type {VoxelBoundsCollection}\n   * @readonly\n   * @private\n   */\n  renderBoundPlanes: {\n    get: function () {\n      return this._renderBoundPlanes;\n    },\n  },\n\n  /**\n   * A bounding sphere containing the bounded shape.\n   *\n   * @memberof VoxelBoxShape.prototype\n   * @type {BoundingSphere}\n   * @readonly\n   * @private\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    },\n  },\n\n  /**\n   * A transformation matrix containing the bounded shape.\n   *\n   * @memberof VoxelBoxShape.prototype\n   * @type {Matrix4}\n   * @readonly\n   * @private\n   */\n  boundTransform: {\n    get: function () {\n      return this._boundTransform;\n    },\n  },\n\n  /**\n   * A transformation matrix containing the shape, ignoring the bounds.\n   *\n   * @memberof VoxelBoxShape.prototype\n   * @type {Matrix4}\n   * @readonly\n   * @private\n   */\n  shapeTransform: {\n    get: function () {\n      return this._shapeTransform;\n    },\n  },\n\n  /**\n   * @memberof VoxelBoxShape.prototype\n   * @type {Object<string, any>}\n   * @readonly\n   * @private\n   */\n  shaderUniforms: {\n    get: function () {\n      return this._shaderUniforms;\n    },\n  },\n\n  /**\n   * @memberof VoxelBoxShape.prototype\n   * @type {Object<string, any>}\n   * @readonly\n   * @private\n   */\n  shaderDefines: {\n    get: function () {\n      return this._shaderDefines;\n    },\n  },\n\n  /**\n   * The maximum number of intersections against the shape for any ray direction.\n   * @memberof VoxelBoxShape.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  shaderMaximumIntersectionsLength: {\n    get: function () {\n      return this._shaderMaximumIntersectionsLength;\n    },\n  },\n});\n\nconst scratchCenter = new Cartesian3();\nconst scratchScale = new Cartesian3();\nconst scratchRotation = new Matrix3();\nconst scratchClipMinBounds = new Cartesian3();\nconst scratchClipMaxBounds = new Cartesian3();\n\n/**\n * Update the shape's state.\n * @private\n * @param {Matrix4} modelMatrix The model matrix.\n * @param {Cartesian3} minBounds The minimum bounds.\n * @param {Cartesian3} maxBounds The maximum bounds.\n * @param {Cartesian3} [clipMinBounds] The minimum clip bounds.\n * @param {Cartesian3} [clipMaxBounds] The maximum clip bounds.\n * @returns {boolean} Whether the shape is visible.\n */\nVoxelBoxShape.prototype.update = function (\n  modelMatrix,\n  minBounds,\n  maxBounds,\n  clipMinBounds,\n  clipMaxBounds,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"modelMatrix\", modelMatrix);\n  Check.typeOf.object(\"minBounds\", minBounds);\n  Check.typeOf.object(\"maxBounds\", maxBounds);\n  //>>includeEnd('debug');\n\n  clipMinBounds = clipMinBounds ?? minBounds.clone(scratchClipMinBounds);\n  clipMaxBounds = clipMaxBounds ?? maxBounds.clone(scratchClipMaxBounds);\n\n  minBounds = Cartesian3.clone(minBounds, this._minBounds);\n  maxBounds = Cartesian3.clone(maxBounds, this._maxBounds);\n\n  const renderMinBounds = Cartesian3.clamp(\n    minBounds,\n    clipMinBounds,\n    clipMaxBounds,\n    this._renderMinBounds,\n  );\n  const renderMaxBounds = Cartesian3.clamp(\n    maxBounds,\n    clipMinBounds,\n    clipMaxBounds,\n    this._renderMaxBounds,\n  );\n\n  // Box is not visible if:\n  // - any of the min render bounds exceed the max render bounds\n  // - two or more of the min bounds equal the max bounds (line / point)\n  // - scale is 0 for any component (too annoying to reconstruct rotation matrix)\n  const scale = Matrix4.getScale(modelMatrix, scratchScale);\n  if (\n    renderMinBounds.x > renderMaxBounds.x ||\n    renderMinBounds.y > renderMaxBounds.y ||\n    renderMinBounds.z > renderMaxBounds.z ||\n    (renderMinBounds.x === renderMaxBounds.x) +\n      (renderMinBounds.y === renderMaxBounds.y) +\n      (renderMinBounds.z === renderMaxBounds.z) >=\n      2 ||\n    scale.x === 0.0 ||\n    scale.y === 0.0 ||\n    scale.z === 0.0\n  ) {\n    return false;\n  }\n\n  // Update the render bounds planes\n  const renderBoundPlanes = this._renderBoundPlanes;\n  renderBoundPlanes.get(0).distance = renderMinBounds.x;\n  renderBoundPlanes.get(1).distance = renderMinBounds.y;\n  renderBoundPlanes.get(2).distance = renderMinBounds.z;\n  renderBoundPlanes.get(3).distance = -renderMaxBounds.x;\n  renderBoundPlanes.get(4).distance = -renderMaxBounds.y;\n  renderBoundPlanes.get(5).distance = -renderMaxBounds.z;\n\n  this._shapeTransform = Matrix4.clone(modelMatrix, this._shapeTransform);\n\n  this._orientedBoundingBox = getBoxChunkObb(\n    renderMinBounds,\n    renderMaxBounds,\n    this._shapeTransform,\n    this._orientedBoundingBox,\n  );\n\n  // All of the box bounds go from -1 to +1, so the model matrix scale can be\n  // used as the oriented bounding box half axes.\n  this._boundTransform = Matrix4.fromRotationTranslation(\n    this._orientedBoundingBox.halfAxes,\n    this._orientedBoundingBox.center,\n    this._boundTransform,\n  );\n\n  this._boundingSphere = BoundingSphere.fromOrientedBoundingBox(\n    this._orientedBoundingBox,\n    this._boundingSphere,\n  );\n\n  const shaderUniforms = this._shaderUniforms;\n  const shaderDefines = this._shaderDefines;\n\n  // To keep things simple, clear the defines every time\n  for (const key in shaderDefines) {\n    if (shaderDefines.hasOwnProperty(key)) {\n      shaderDefines[key] = undefined;\n    }\n  }\n\n  // Keep track of how many intersections there are going to be.\n  let intersectionCount = 0;\n\n  shaderDefines[\"BOX_INTERSECTION_INDEX\"] = intersectionCount;\n  intersectionCount += 1;\n\n  // Compute scale and translation to transform from UV space to bounded UV space\n  const min = minBounds;\n  const max = maxBounds;\n  const boxLocalToShapeUvScale = Cartesian3.fromElements(\n    boundScale(min.x, max.x),\n    boundScale(min.y, max.y),\n    boundScale(min.z, max.z),\n    shaderUniforms.boxLocalToShapeUvScale,\n  );\n  shaderUniforms.boxLocalToShapeUvTranslate = Cartesian3.negate(\n    Cartesian3.multiplyComponents(\n      boxLocalToShapeUvScale,\n      min,\n      shaderUniforms.boxLocalToShapeUvTranslate,\n    ),\n    shaderUniforms.boxLocalToShapeUvTranslate,\n  );\n\n  this._shaderMaximumIntersectionsLength = intersectionCount;\n\n  return true;\n};\n\nfunction boundScale(minBound, maxBound) {\n  return CesiumMath.equalsEpsilon(minBound, maxBound, CesiumMath.EPSILON7)\n    ? 1.0\n    : 1.0 / (maxBound - minBound);\n}\n\nconst scratchTransformPositionWorldToLocal = new Matrix4();\n/**\n * Update any view-dependent transforms.\n * @private\n * @param {FrameState} frameState The frame state.\n */\nVoxelBoxShape.prototype.updateViewTransforms = function (frameState) {\n  const shaderUniforms = this._shaderUniforms;\n  const transformPositionWorldToLocal = Matrix4.inverse(\n    this._shapeTransform,\n    scratchTransformPositionWorldToLocal,\n  );\n  const transformDirectionWorldToLocal = Matrix4.getMatrix3(\n    transformPositionWorldToLocal,\n    shaderUniforms.boxEcToXyz,\n  );\n  const rotateViewToWorld = frameState.context.uniformState.inverseViewRotation;\n  Matrix3.multiply(\n    transformDirectionWorldToLocal,\n    rotateViewToWorld,\n    shaderUniforms.boxEcToXyz,\n  );\n};\n\n/**\n * Convert a local coordinate to the shape's UV space.\n * @private\n * @param {Cartesian3} positionLocal The local coordinate to convert.\n * @param {Cartesian3} result The Cartesian3 to store the result in.\n * @returns {Cartesian3} The converted UV coordinate.\n */\nVoxelBoxShape.prototype.convertLocalToShapeUvSpace = function (\n  positionLocal,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"positionLocal\", positionLocal);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const { boxLocalToShapeUvScale, boxLocalToShapeUvTranslate } =\n    this._shaderUniforms;\n\n  return Cartesian3.add(\n    Cartesian3.multiplyComponents(\n      positionLocal,\n      boxLocalToShapeUvScale,\n      result,\n    ),\n    boxLocalToShapeUvTranslate,\n    result,\n  );\n};\n\nconst scratchTileMinBounds = new Cartesian3();\nconst scratchTileMaxBounds = new Cartesian3();\n\n/**\n * Computes an oriented bounding box for a specified tile.\n * @private\n * @param {number} tileLevel The tile's level.\n * @param {number} tileX The tile's x coordinate.\n * @param {number} tileY The tile's y coordinate.\n * @param {number} tileZ The tile's z coordinate.\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified tile\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelBoxShape.prototype.computeOrientedBoundingBoxForTile = function (\n  tileLevel,\n  tileX,\n  tileY,\n  tileZ,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"tileLevel\", tileLevel);\n  Check.typeOf.number(\"tileX\", tileX);\n  Check.typeOf.number(\"tileY\", tileY);\n  Check.typeOf.number(\"tileZ\", tileZ);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const minBounds = this._minBounds;\n  const maxBounds = this._maxBounds;\n  const sizeAtLevel = 1.0 / Math.pow(2, tileLevel);\n\n  const tileMinBounds = Cartesian3.fromElements(\n    CesiumMath.lerp(minBounds.x, maxBounds.x, sizeAtLevel * tileX),\n    CesiumMath.lerp(minBounds.y, maxBounds.y, sizeAtLevel * tileY),\n    CesiumMath.lerp(minBounds.z, maxBounds.z, sizeAtLevel * tileZ),\n    scratchTileMinBounds,\n  );\n\n  const tileMaxBounds = Cartesian3.fromElements(\n    CesiumMath.lerp(minBounds.x, maxBounds.x, sizeAtLevel * (tileX + 1)),\n    CesiumMath.lerp(minBounds.y, maxBounds.y, sizeAtLevel * (tileY + 1)),\n    CesiumMath.lerp(minBounds.z, maxBounds.z, sizeAtLevel * (tileZ + 1)),\n    scratchTileMaxBounds,\n  );\n\n  return getBoxChunkObb(\n    tileMinBounds,\n    tileMaxBounds,\n    this._shapeTransform,\n    result,\n  );\n};\n\nconst sampleSizeScratch = new Cartesian3();\n\n/**\n * Computes an oriented bounding box for a specified sample within a specified tile.\n * @private\n * @param {SpatialNode} spatialNode The spatial node containing the sample\n * @param {Cartesian3} tileDimensions The size of the tile in number of samples, before padding\n * @param {Cartesian3} tileUv The sample coordinate within the tile\n * @param {OrientedBoundingBox} result The oriented bounding box that will be set to enclose the specified sample\n * @returns {OrientedBoundingBox} The oriented bounding box.\n */\nVoxelBoxShape.prototype.computeOrientedBoundingBoxForSample = function (\n  spatialNode,\n  tileDimensions,\n  tileUv,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"spatialNode\", spatialNode);\n  Check.typeOf.object(\"tileDimensions\", tileDimensions);\n  Check.typeOf.object(\"tileUv\", tileUv);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const tileSizeAtLevel = 1.0 / Math.pow(2, spatialNode.level);\n  const sampleSize = Cartesian3.divideComponents(\n    Cartesian3.ONE,\n    tileDimensions,\n    sampleSizeScratch,\n  );\n  const sampleSizeAtLevel = Cartesian3.multiplyByScalar(\n    sampleSize,\n    tileSizeAtLevel,\n    sampleSizeScratch,\n  );\n\n  const minLerp = Cartesian3.multiplyByScalar(\n    Cartesian3.fromElements(\n      spatialNode.x + tileUv.x,\n      spatialNode.y + tileUv.y,\n      spatialNode.z + tileUv.z,\n      scratchTileMinBounds,\n    ),\n    tileSizeAtLevel,\n    scratchTileMinBounds,\n  );\n  const maxLerp = Cartesian3.add(\n    minLerp,\n    sampleSizeAtLevel,\n    scratchTileMaxBounds,\n  );\n\n  const minBounds = this._minBounds;\n  const maxBounds = this._maxBounds;\n  const sampleMinBounds = Cartesian3.fromElements(\n    CesiumMath.lerp(minBounds.x, maxBounds.x, minLerp.x),\n    CesiumMath.lerp(minBounds.y, maxBounds.y, minLerp.y),\n    CesiumMath.lerp(minBounds.z, maxBounds.z, minLerp.z),\n    scratchTileMinBounds,\n  );\n  const sampleMaxBounds = Cartesian3.fromElements(\n    CesiumMath.lerp(minBounds.x, maxBounds.x, maxLerp.x),\n    CesiumMath.lerp(minBounds.y, maxBounds.y, maxLerp.y),\n    CesiumMath.lerp(minBounds.z, maxBounds.z, maxLerp.z),\n    scratchTileMaxBounds,\n  );\n\n  return getBoxChunkObb(\n    sampleMinBounds,\n    sampleMaxBounds,\n    this._shapeTransform,\n    result,\n  );\n};\n\n/**\n * Defines the minimum bounds of the shape. Corresponds to minimum X, Y, Z.\n * @private\n * @type {Cartesian3}\n * @constant\n * @readonly\n */\nVoxelBoxShape.DefaultMinBounds = Object.freeze(\n  new Cartesian3(-1.0, -1.0, -1.0),\n);\n\n/**\n * Defines the maximum bounds of the shape. Corresponds to maximum X, Y, Z.\n * @private\n * @type {Cartesian3}\n * @constant\n * @readonly\n */\nVoxelBoxShape.DefaultMaxBounds = Object.freeze(\n  new Cartesian3(+1.0, +1.0, +1.0),\n);\n\nconst scratchBoxScale = new Cartesian3();\n/**\n * Computes an {@link OrientedBoundingBox} for a subregion of the shape.\n *\n * @function\n *\n * @param {Cartesian3} minimumBounds The minimum bounds, in the local coordinates of the shape.\n * @param {Cartesian3} maximumBounds The maximum bounds, in the local coordinates of the shape.\n * @param {Matrix4} matrix The matrix to transform the points.\n * @param {OrientedBoundingBox} result The object onto which to store the result.\n * @returns {OrientedBoundingBox} The oriented bounding box that contains this subregion.\n *\n * @private\n */\nfunction getBoxChunkObb(minimumBounds, maximumBounds, matrix, result) {\n  const defaultMinBounds = VoxelBoxShape.DefaultMinBounds;\n  const defaultMaxBounds = VoxelBoxShape.DefaultMaxBounds;\n\n  const isDefaultBounds =\n    Cartesian3.equals(minimumBounds, defaultMinBounds) &&\n    Cartesian3.equals(maximumBounds, defaultMaxBounds);\n\n  if (isDefaultBounds) {\n    result.center = Matrix4.getTranslation(matrix, result.center);\n    result.halfAxes = Matrix4.getMatrix3(matrix, result.halfAxes);\n  } else {\n    let scale = Matrix4.getScale(matrix, scratchBoxScale);\n    const localCenter = Cartesian3.midpoint(\n      minimumBounds,\n      maximumBounds,\n      scratchCenter,\n    );\n    result.center = Matrix4.multiplyByPoint(matrix, localCenter, result.center);\n    scale = Cartesian3.fromElements(\n      scale.x * 0.5 * (maximumBounds.x - minimumBounds.x),\n      scale.y * 0.5 * (maximumBounds.y - minimumBounds.y),\n      scale.z * 0.5 * (maximumBounds.z - minimumBounds.z),\n      scratchBoxScale,\n    );\n    const rotation = Matrix4.getRotation(matrix, scratchRotation);\n    result.halfAxes = Matrix3.setScale(rotation, scale, result.halfAxes);\n  }\n\n  return result;\n}\n\nexport default VoxelBoxShape;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}