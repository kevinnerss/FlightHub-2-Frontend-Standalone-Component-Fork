{"ast":null,"code":"import BlendingState from \"./BlendingState.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport CullFace from \"./CullFace.js\";\nimport defined from \"../Core/defined.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport processVoxelProperties from \"./processVoxelProperties.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderDestination from \"../Renderer/ShaderDestination.js\";\nimport VoxelBoundsCollection from \"./VoxelBoundsCollection.js\";\nimport VoxelRenderResources from \"./VoxelRenderResources.js\";\nconst textureResolutionScratch = new Cartesian2();\n\n/**\n * @function\n *\n * @param {VoxelPrimitive} primitive\n * @param {Context} context\n *\n * @private\n */\nfunction buildVoxelDrawCommands(primitive, context) {\n  const renderResources = new VoxelRenderResources(primitive);\n  processVoxelProperties(renderResources, primitive);\n  const {\n    shaderBuilder,\n    clippingPlanes,\n    clippingPlanesLength,\n    renderBoundPlanes,\n    renderBoundPlanesLength\n  } = renderResources;\n  if (clippingPlanesLength > 0) {\n    const functionId = \"getClippingPlane\";\n    const functionSignature = `vec4 ${functionId}(highp sampler2D packedPlanes, int planeNumber)`;\n    const textureResolution = ClippingPlaneCollection.getTextureResolution(clippingPlanes, context, textureResolutionScratch);\n    const functionBody = getPlaneFunctionBody(textureResolution);\n    shaderBuilder.addFunction(functionId, functionSignature, ShaderDestination.FRAGMENT);\n    shaderBuilder.addFunctionLines(functionId, [functionBody]);\n  }\n  if (renderBoundPlanesLength > 0) {\n    const functionId = \"getBoundPlane\";\n    const functionSignature = `vec4 ${functionId}(highp sampler2D packedPlanes, int planeNumber)`;\n    const textureResolution = VoxelBoundsCollection.getTextureResolution(renderBoundPlanes, context, textureResolutionScratch);\n    const functionBody = getPlaneFunctionBody(textureResolution);\n    shaderBuilder.addFunction(functionId, functionSignature, ShaderDestination.FRAGMENT);\n    shaderBuilder.addFunctionLines(functionId, [functionBody]);\n  }\n\n  // Compile shaders\n  const shaderBuilderPick = shaderBuilder.clone();\n  shaderBuilderPick.addDefine(\"PICKING\", undefined, ShaderDestination.FRAGMENT);\n  const shaderBuilderPickVoxel = shaderBuilder.clone();\n  shaderBuilderPickVoxel.addDefine(\"PICKING_VOXEL\", undefined, ShaderDestination.FRAGMENT);\n  const shaderProgram = shaderBuilder.buildShaderProgram(context);\n  const shaderProgramPick = shaderBuilderPick.buildShaderProgram(context);\n  const shaderProgramPickVoxel = shaderBuilderPickVoxel.buildShaderProgram(context);\n  const renderState = RenderState.fromCache({\n    cull: {\n      enabled: true,\n      face: CullFace.BACK\n    },\n    depthTest: {\n      enabled: false\n    },\n    depthMask: false,\n    // internally the shader does premultiplied alpha, so it makes sense to blend that way too\n    blending: BlendingState.PRE_MULTIPLIED_ALPHA_BLEND\n  });\n\n  // Create the draw commands\n  const viewportQuadVertexArray = context.getViewportQuadVertexArray();\n  const depthTest = primitive._depthTest;\n  const drawCommand = new DrawCommand({\n    vertexArray: viewportQuadVertexArray,\n    primitiveType: PrimitiveType.TRIANGLES,\n    renderState: renderState,\n    shaderProgram: shaderProgram,\n    uniformMap: renderResources.uniformMap,\n    modelMatrix: primitive._compoundModelMatrix,\n    pass: Pass.VOXELS,\n    executeInClosestFrustum: true,\n    owner: this,\n    cull: depthTest,\n    // don't cull or occlude if depth testing is off\n    occlude: depthTest // don't cull or occlude if depth testing is off\n  });\n\n  // Create the pick draw command\n  const drawCommandPick = DrawCommand.shallowClone(drawCommand, new DrawCommand());\n  drawCommandPick.shaderProgram = shaderProgramPick;\n  drawCommandPick.pickOnly = true;\n\n  // Create the pick voxels draw command\n  const drawCommandPickVoxel = DrawCommand.shallowClone(drawCommand, new DrawCommand());\n  drawCommandPickVoxel.shaderProgram = shaderProgramPickVoxel;\n  drawCommandPickVoxel.pickOnly = true;\n\n  // Delete the old shader programs\n  if (defined(primitive._drawCommand)) {\n    const command = primitive._drawCommand;\n    command.shaderProgram = command.shaderProgram && command.shaderProgram.destroy();\n  }\n  if (defined(primitive._drawCommandPick)) {\n    const command = primitive._drawCommandPick;\n    command.shaderProgram = command.shaderProgram && command.shaderProgram.destroy();\n  }\n  if (defined(primitive._drawCommandPickVoxel)) {\n    const command = primitive._drawCommandPickVoxel;\n    command.shaderProgram = command.shaderProgram && command.shaderProgram.destroy();\n  }\n  primitive._drawCommand = drawCommand;\n  primitive._drawCommandPick = drawCommandPick;\n  primitive._drawCommandPickVoxel = drawCommandPickVoxel;\n}\nfunction getPlaneFunctionBody(textureResolution) {\n  const width = textureResolution.x;\n  const height = textureResolution.y;\n  const pixelWidth = 1.0 / width;\n  const pixelHeight = 1.0 / height;\n  let pixelWidthString = `${pixelWidth}`;\n  if (pixelWidthString.indexOf(\".\") === -1) {\n    pixelWidthString += \".0\";\n  }\n  let pixelHeightString = `${pixelHeight}`;\n  if (pixelHeightString.indexOf(\".\") === -1) {\n    pixelHeightString += \".0\";\n  }\n  return `int pixY = planeNumber / ${width};\n    int pixX = planeNumber - (pixY * ${width});\n    // Sample from center of pixel\n    float u = (float(pixX) + 0.5) * ${pixelWidthString};\n    float v = (float(pixY) + 0.5) * ${pixelHeightString};\n    return texture(packedPlanes, vec2(u, v));`;\n}\nexport default buildVoxelDrawCommands;","map":{"version":3,"names":["BlendingState","Cartesian2","ClippingPlaneCollection","CullFace","defined","DrawCommand","Pass","PrimitiveType","processVoxelProperties","RenderState","ShaderDestination","VoxelBoundsCollection","VoxelRenderResources","textureResolutionScratch","buildVoxelDrawCommands","primitive","context","renderResources","shaderBuilder","clippingPlanes","clippingPlanesLength","renderBoundPlanes","renderBoundPlanesLength","functionId","functionSignature","textureResolution","getTextureResolution","functionBody","getPlaneFunctionBody","addFunction","FRAGMENT","addFunctionLines","shaderBuilderPick","clone","addDefine","undefined","shaderBuilderPickVoxel","shaderProgram","buildShaderProgram","shaderProgramPick","shaderProgramPickVoxel","renderState","fromCache","cull","enabled","face","BACK","depthTest","depthMask","blending","PRE_MULTIPLIED_ALPHA_BLEND","viewportQuadVertexArray","getViewportQuadVertexArray","_depthTest","drawCommand","vertexArray","primitiveType","TRIANGLES","uniformMap","modelMatrix","_compoundModelMatrix","pass","VOXELS","executeInClosestFrustum","owner","occlude","drawCommandPick","shallowClone","pickOnly","drawCommandPickVoxel","_drawCommand","command","destroy","_drawCommandPick","_drawCommandPickVoxel","width","x","height","y","pixelWidth","pixelHeight","pixelWidthString","indexOf","pixelHeightString"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/buildVoxelDrawCommands.js"],"sourcesContent":["import BlendingState from \"./BlendingState.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport CullFace from \"./CullFace.js\";\nimport defined from \"../Core/defined.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport processVoxelProperties from \"./processVoxelProperties.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderDestination from \"../Renderer/ShaderDestination.js\";\nimport VoxelBoundsCollection from \"./VoxelBoundsCollection.js\";\nimport VoxelRenderResources from \"./VoxelRenderResources.js\";\n\nconst textureResolutionScratch = new Cartesian2();\n\n/**\n * @function\n *\n * @param {VoxelPrimitive} primitive\n * @param {Context} context\n *\n * @private\n */\nfunction buildVoxelDrawCommands(primitive, context) {\n  const renderResources = new VoxelRenderResources(primitive);\n\n  processVoxelProperties(renderResources, primitive);\n\n  const {\n    shaderBuilder,\n    clippingPlanes,\n    clippingPlanesLength,\n    renderBoundPlanes,\n    renderBoundPlanesLength,\n  } = renderResources;\n\n  if (clippingPlanesLength > 0) {\n    const functionId = \"getClippingPlane\";\n    const functionSignature = `vec4 ${functionId}(highp sampler2D packedPlanes, int planeNumber)`;\n    const textureResolution = ClippingPlaneCollection.getTextureResolution(\n      clippingPlanes,\n      context,\n      textureResolutionScratch,\n    );\n    const functionBody = getPlaneFunctionBody(textureResolution);\n    shaderBuilder.addFunction(\n      functionId,\n      functionSignature,\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addFunctionLines(functionId, [functionBody]);\n  }\n\n  if (renderBoundPlanesLength > 0) {\n    const functionId = \"getBoundPlane\";\n    const functionSignature = `vec4 ${functionId}(highp sampler2D packedPlanes, int planeNumber)`;\n    const textureResolution = VoxelBoundsCollection.getTextureResolution(\n      renderBoundPlanes,\n      context,\n      textureResolutionScratch,\n    );\n    const functionBody = getPlaneFunctionBody(textureResolution);\n    shaderBuilder.addFunction(\n      functionId,\n      functionSignature,\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addFunctionLines(functionId, [functionBody]);\n  }\n\n  // Compile shaders\n  const shaderBuilderPick = shaderBuilder.clone();\n  shaderBuilderPick.addDefine(\"PICKING\", undefined, ShaderDestination.FRAGMENT);\n  const shaderBuilderPickVoxel = shaderBuilder.clone();\n  shaderBuilderPickVoxel.addDefine(\n    \"PICKING_VOXEL\",\n    undefined,\n    ShaderDestination.FRAGMENT,\n  );\n  const shaderProgram = shaderBuilder.buildShaderProgram(context);\n  const shaderProgramPick = shaderBuilderPick.buildShaderProgram(context);\n  const shaderProgramPickVoxel =\n    shaderBuilderPickVoxel.buildShaderProgram(context);\n  const renderState = RenderState.fromCache({\n    cull: {\n      enabled: true,\n      face: CullFace.BACK,\n    },\n    depthTest: {\n      enabled: false,\n    },\n    depthMask: false,\n    // internally the shader does premultiplied alpha, so it makes sense to blend that way too\n    blending: BlendingState.PRE_MULTIPLIED_ALPHA_BLEND,\n  });\n\n  // Create the draw commands\n  const viewportQuadVertexArray = context.getViewportQuadVertexArray();\n  const depthTest = primitive._depthTest;\n  const drawCommand = new DrawCommand({\n    vertexArray: viewportQuadVertexArray,\n    primitiveType: PrimitiveType.TRIANGLES,\n    renderState: renderState,\n    shaderProgram: shaderProgram,\n    uniformMap: renderResources.uniformMap,\n    modelMatrix: primitive._compoundModelMatrix,\n    pass: Pass.VOXELS,\n    executeInClosestFrustum: true,\n    owner: this,\n    cull: depthTest, // don't cull or occlude if depth testing is off\n    occlude: depthTest, // don't cull or occlude if depth testing is off\n  });\n\n  // Create the pick draw command\n  const drawCommandPick = DrawCommand.shallowClone(\n    drawCommand,\n    new DrawCommand(),\n  );\n  drawCommandPick.shaderProgram = shaderProgramPick;\n  drawCommandPick.pickOnly = true;\n\n  // Create the pick voxels draw command\n  const drawCommandPickVoxel = DrawCommand.shallowClone(\n    drawCommand,\n    new DrawCommand(),\n  );\n  drawCommandPickVoxel.shaderProgram = shaderProgramPickVoxel;\n  drawCommandPickVoxel.pickOnly = true;\n\n  // Delete the old shader programs\n  if (defined(primitive._drawCommand)) {\n    const command = primitive._drawCommand;\n    command.shaderProgram =\n      command.shaderProgram && command.shaderProgram.destroy();\n  }\n  if (defined(primitive._drawCommandPick)) {\n    const command = primitive._drawCommandPick;\n    command.shaderProgram =\n      command.shaderProgram && command.shaderProgram.destroy();\n  }\n  if (defined(primitive._drawCommandPickVoxel)) {\n    const command = primitive._drawCommandPickVoxel;\n    command.shaderProgram =\n      command.shaderProgram && command.shaderProgram.destroy();\n  }\n\n  primitive._drawCommand = drawCommand;\n  primitive._drawCommandPick = drawCommandPick;\n  primitive._drawCommandPickVoxel = drawCommandPickVoxel;\n}\n\nfunction getPlaneFunctionBody(textureResolution) {\n  const width = textureResolution.x;\n  const height = textureResolution.y;\n\n  const pixelWidth = 1.0 / width;\n  const pixelHeight = 1.0 / height;\n\n  let pixelWidthString = `${pixelWidth}`;\n  if (pixelWidthString.indexOf(\".\") === -1) {\n    pixelWidthString += \".0\";\n  }\n  let pixelHeightString = `${pixelHeight}`;\n  if (pixelHeightString.indexOf(\".\") === -1) {\n    pixelHeightString += \".0\";\n  }\n\n  return `int pixY = planeNumber / ${width};\n    int pixX = planeNumber - (pixY * ${width});\n    // Sample from center of pixel\n    float u = (float(pixX) + 0.5) * ${pixelWidthString};\n    float v = (float(pixY) + 0.5) * ${pixelHeightString};\n    return texture(packedPlanes, vec2(u, v));`;\n}\n\nexport default buildVoxelDrawCommands;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}