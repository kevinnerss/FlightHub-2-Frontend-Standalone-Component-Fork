{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport ShaderDestination from \"../Renderer/ShaderDestination.js\";\n\n/**\n * Update the shader with defines, structs, and functions to handle\n * voxel properties and statistics\n * @function\n *\n * @param {VoxelRenderResources} renderResources\n * @param {VoxelPrimitive} primitive\n *\n * @private\n */\nfunction processVoxelProperties(renderResources, primitive) {\n  const {\n    shaderBuilder\n  } = renderResources;\n  const {\n    names,\n    types,\n    componentTypes,\n    minimumValues,\n    maximumValues\n  } = primitive._provider;\n  const attributeLength = types.length;\n  const hasStatistics = defined(minimumValues) && defined(maximumValues);\n  shaderBuilder.addDefine(\"METADATA_COUNT\", attributeLength, ShaderDestination.FRAGMENT);\n  if (hasStatistics) {\n    shaderBuilder.addDefine(\"STATISTICS\", undefined, ShaderDestination.FRAGMENT);\n  }\n\n  // PropertyStatistics structs\n  for (let i = 0; i < attributeLength; i++) {\n    const name = names[i];\n    const glslType = getGlslType(types[i]);\n    const propertyStatisticsStructId = `PropertyStatistics_${name}`;\n    const propertyStatisticsStructName = `PropertyStatistics_${name}`;\n    shaderBuilder.addStruct(propertyStatisticsStructId, propertyStatisticsStructName, ShaderDestination.FRAGMENT);\n    shaderBuilder.addStructField(propertyStatisticsStructId, glslType, \"min\");\n    shaderBuilder.addStructField(propertyStatisticsStructId, glslType, \"max\");\n  }\n\n  // MetadataStatistics struct\n  const metadataStatisticsStructId = \"MetadataStatistics\";\n  const metadataStatisticsStructName = \"MetadataStatistics\";\n  const metadataStatisticsFieldName = \"metadataStatistics\";\n  shaderBuilder.addStruct(metadataStatisticsStructId, metadataStatisticsStructName, ShaderDestination.FRAGMENT);\n  for (let i = 0; i < attributeLength; i++) {\n    const name = names[i];\n    const propertyStructName = `PropertyStatistics_${name}`;\n    const propertyFieldName = name;\n    shaderBuilder.addStructField(metadataStatisticsStructId, propertyStructName, propertyFieldName);\n  }\n\n  // Metadata struct\n  const metadataStructId = \"Metadata\";\n  const metadataStructName = \"Metadata\";\n  const metadataFieldName = \"metadata\";\n  shaderBuilder.addStruct(metadataStructId, metadataStructName, ShaderDestination.FRAGMENT);\n  for (let i = 0; i < attributeLength; i++) {\n    const glslType = getGlslType(types[i]);\n    shaderBuilder.addStructField(metadataStructId, glslType, names[i]);\n  }\n\n  // Attributes struct\n  const attributesStructId = \"Attributes\";\n  const attributesStructName = \"Attributes\";\n  const attributesFieldName = \"attributes\";\n  shaderBuilder.addStruct(attributesStructId, attributesStructName, ShaderDestination.FRAGMENT);\n  shaderBuilder.addStructField(attributesStructId, \"vec3\", \"positionEC\");\n  shaderBuilder.addStructField(attributesStructId, \"vec3\", \"normalEC\");\n\n  // Voxel struct\n  const voxelStructId = \"Voxel\";\n  const voxelStructName = \"Voxel\";\n  const voxelFieldName = \"voxel\";\n  shaderBuilder.addStruct(voxelStructId, voxelStructName, ShaderDestination.FRAGMENT);\n  shaderBuilder.addStructField(voxelStructId, \"vec3\", \"viewDirUv\");\n  shaderBuilder.addStructField(voxelStructId, \"float\", \"travelDistance\");\n  shaderBuilder.addStructField(voxelStructId, \"int\", \"stepCount\");\n  shaderBuilder.addStructField(voxelStructId, \"int\", \"tileIndex\");\n  shaderBuilder.addStructField(voxelStructId, \"int\", \"sampleIndex\");\n  shaderBuilder.addStructField(voxelStructId, \"float\", \"distanceToDepthBuffer\");\n\n  // FragmentInput struct\n  const fragmentInputStructId = \"FragmentInput\";\n  const fragmentInputStructName = \"FragmentInput\";\n  shaderBuilder.addStruct(fragmentInputStructId, fragmentInputStructName, ShaderDestination.FRAGMENT);\n  shaderBuilder.addStructField(fragmentInputStructId, metadataStatisticsStructName, metadataStatisticsFieldName);\n  shaderBuilder.addStructField(fragmentInputStructId, metadataStructName, metadataFieldName);\n  shaderBuilder.addStructField(fragmentInputStructId, attributesStructName, attributesFieldName);\n  shaderBuilder.addStructField(fragmentInputStructId, voxelStructName, voxelFieldName);\n\n  // Properties struct\n  const propertiesStructId = \"Properties\";\n  const propertiesStructName = \"Properties\";\n  const propertiesFieldName = \"properties\";\n  shaderBuilder.addStruct(propertiesStructId, propertiesStructName, ShaderDestination.FRAGMENT);\n  for (let i = 0; i < attributeLength; i++) {\n    const glslType = getGlslType(types[i]);\n    shaderBuilder.addStructField(propertiesStructId, glslType, names[i]);\n  }\n\n  // Fragment shader functions\n\n  // clearProperties function\n  {\n    const functionId = \"clearProperties\";\n    shaderBuilder.addFunction(functionId, `${propertiesStructName} clearProperties()`, ShaderDestination.FRAGMENT);\n    shaderBuilder.addFunctionLines(functionId, [`${propertiesStructName} ${propertiesFieldName};`]);\n    for (let i = 0; i < attributeLength; i++) {\n      const glslType = getGlslType(types[i], componentTypes[i]);\n      shaderBuilder.addFunctionLines(functionId, [`${propertiesFieldName}.${names[i]} = ${glslType}(0.0);`]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [`return ${propertiesFieldName};`]);\n  }\n\n  // sumProperties function\n  {\n    const functionId = \"sumProperties\";\n    shaderBuilder.addFunction(functionId, `${propertiesStructName} sumProperties(${propertiesStructName} propertiesA, ${propertiesStructName} propertiesB)`, ShaderDestination.FRAGMENT);\n    shaderBuilder.addFunctionLines(functionId, [`${propertiesStructName} ${propertiesFieldName};`]);\n    for (let i = 0; i < attributeLength; i++) {\n      const name = names[i];\n      shaderBuilder.addFunctionLines(functionId, [`${propertiesFieldName}.${name} = propertiesA.${name} + propertiesB.${name};`]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [`return ${propertiesFieldName};`]);\n  }\n\n  // scaleProperties function\n  {\n    const functionId = \"scaleProperties\";\n    shaderBuilder.addFunction(functionId, `${propertiesStructName} scaleProperties(${propertiesStructName} ${propertiesFieldName}, float scale)`, ShaderDestination.FRAGMENT);\n    shaderBuilder.addFunctionLines(functionId, [`${propertiesStructName} scaledProperties = ${propertiesFieldName};`]);\n    for (let i = 0; i < attributeLength; i++) {\n      shaderBuilder.addFunctionLines(functionId, [`scaledProperties.${names[i]} *= scale;`]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [`return scaledProperties;`]);\n  }\n\n  // mixProperties\n  {\n    const functionId = \"mixProperties\";\n    shaderBuilder.addFunction(functionId, `${propertiesStructName} mixProperties(${propertiesStructName} propertiesA, ${propertiesStructName} propertiesB, float mixFactor)`, ShaderDestination.FRAGMENT);\n    shaderBuilder.addFunctionLines(functionId, [`${propertiesStructName} ${propertiesFieldName};`]);\n    for (let i = 0; i < attributeLength; i++) {\n      const name = names[i];\n      shaderBuilder.addFunctionLines(functionId, [`${propertiesFieldName}.${name} = mix(propertiesA.${name}, propertiesB.${name}, mixFactor);`]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [`return ${propertiesFieldName};`]);\n  }\n\n  // copyPropertiesToMetadata\n  {\n    const functionId = \"copyPropertiesToMetadata\";\n    shaderBuilder.addFunction(functionId, `void copyPropertiesToMetadata(in ${propertiesStructName} ${propertiesFieldName}, inout ${metadataStructName} ${metadataFieldName})`, ShaderDestination.FRAGMENT);\n    for (let i = 0; i < attributeLength; i++) {\n      const name = names[i];\n      shaderBuilder.addFunctionLines(functionId, [`${metadataFieldName}.${name} = ${propertiesFieldName}.${name};`]);\n    }\n  }\n\n  // setStatistics function\n  if (hasStatistics) {\n    const functionId = \"setStatistics\";\n    shaderBuilder.addFunction(functionId, `void setStatistics(inout ${metadataStatisticsStructName} ${metadataStatisticsFieldName})`, ShaderDestination.FRAGMENT);\n    for (let i = 0; i < attributeLength; i++) {\n      const name = names[i];\n      const type = types[i];\n      const componentCount = MetadataType.getComponentCount(type);\n      for (let j = 0; j < componentCount; j++) {\n        const glslField = getGlslField(type, j);\n        const minimumValue = minimumValues[i][j];\n        const maximumValue = maximumValues[i][j];\n        if (!defined(minimumValue) || !defined(maximumValue)) {\n          continue;\n        }\n        shaderBuilder.addFunctionLines(functionId, [`${metadataStatisticsFieldName}.${name}.min${glslField} = ${getGlslNumberAsFloat(minimumValue)};`, `${metadataStatisticsFieldName}.${name}.max${glslField} = ${getGlslNumberAsFloat(maximumValue)};`]);\n      }\n    }\n  }\n\n  // getPropertiesFromMegatextureAtUv\n  {\n    const functionId = \"getPropertiesFromMegatextureAtUv\";\n    shaderBuilder.addFunction(functionId, `${propertiesStructName} getPropertiesFromMegatextureAtUv(vec2 texcoord)`, ShaderDestination.FRAGMENT);\n    shaderBuilder.addFunctionLines(functionId, [`${propertiesStructName} ${propertiesFieldName};`]);\n    for (let i = 0; i < attributeLength; i++) {\n      const type = types[i];\n      const componentType = componentTypes[i];\n      const glslTextureSwizzle = getGlslTextureSwizzle(type, componentType);\n      shaderBuilder.addFunctionLines(functionId, [`properties.${names[i]} = texture(u_megatextureTextures[${i}], texcoord)${glslTextureSwizzle};`]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [`return ${propertiesFieldName};`]);\n  }\n}\n\n/**\n * Converts a {@link MetadataType} to a GLSL type.\n *\n * @function\n *\n * @param {MetadataType} type The {@link MetadataType}.\n * @returns {string} The GLSL type.\n *\n * @private\n */\nfunction getGlslType(type) {\n  if (type === MetadataType.SCALAR) {\n    return \"float\";\n  } else if (type === MetadataType.VEC2) {\n    return \"vec2\";\n  } else if (type === MetadataType.VEC3) {\n    return \"vec3\";\n  } else if (type === MetadataType.VEC4) {\n    return \"vec4\";\n  }\n}\n\n/**\n * Gets the GLSL swizzle when reading data from a texture.\n *\n * @function\n *\n * @param {MetadataType} type The {@link MetadataType}.\n * @returns {string} The GLSL swizzle.\n *\n * @private\n */\nfunction getGlslTextureSwizzle(type) {\n  if (type === MetadataType.SCALAR) {\n    return \".r\";\n  } else if (type === MetadataType.VEC2) {\n    return \".ra\";\n  } else if (type === MetadataType.VEC3) {\n    return \".rgb\";\n  } else if (type === MetadataType.VEC4) {\n    return \"\";\n  }\n}\n\n/**\n * GLSL needs to have `.0` at the end of whole number floats or else it's\n * treated like an integer.\n *\n * @function\n *\n * @param {number} number The number to convert.\n * @returns {string} The number as floating point in GLSL.\n *\n * @private\n */\nfunction getGlslNumberAsFloat(number) {\n  let numberString = number.toString();\n  if (numberString.indexOf(\".\") === -1) {\n    numberString = `${number}.0`;\n  }\n  return numberString;\n}\n\n/**\n * Gets the GLSL field\n *\n * @function\n *\n * @param {MetadataType} type\n * @param {number} index\n * @returns {string}\n *\n * @private\n */\nfunction getGlslField(type, index) {\n  if (type === MetadataType.SCALAR) {\n    return \"\";\n  }\n  return `[${index}]`;\n}\nexport default processVoxelProperties;","map":{"version":3,"names":["defined","MetadataType","ShaderDestination","processVoxelProperties","renderResources","primitive","shaderBuilder","names","types","componentTypes","minimumValues","maximumValues","_provider","attributeLength","length","hasStatistics","addDefine","FRAGMENT","undefined","i","name","glslType","getGlslType","propertyStatisticsStructId","propertyStatisticsStructName","addStruct","addStructField","metadataStatisticsStructId","metadataStatisticsStructName","metadataStatisticsFieldName","propertyStructName","propertyFieldName","metadataStructId","metadataStructName","metadataFieldName","attributesStructId","attributesStructName","attributesFieldName","voxelStructId","voxelStructName","voxelFieldName","fragmentInputStructId","fragmentInputStructName","propertiesStructId","propertiesStructName","propertiesFieldName","functionId","addFunction","addFunctionLines","type","componentCount","getComponentCount","j","glslField","getGlslField","minimumValue","maximumValue","getGlslNumberAsFloat","componentType","glslTextureSwizzle","getGlslTextureSwizzle","SCALAR","VEC2","VEC3","VEC4","number","numberString","toString","indexOf","index"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/processVoxelProperties.js"],"sourcesContent":["import defined from \"../Core/defined.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport ShaderDestination from \"../Renderer/ShaderDestination.js\";\n\n/**\n * Update the shader with defines, structs, and functions to handle\n * voxel properties and statistics\n * @function\n *\n * @param {VoxelRenderResources} renderResources\n * @param {VoxelPrimitive} primitive\n *\n * @private\n */\nfunction processVoxelProperties(renderResources, primitive) {\n  const { shaderBuilder } = renderResources;\n\n  const { names, types, componentTypes, minimumValues, maximumValues } =\n    primitive._provider;\n\n  const attributeLength = types.length;\n  const hasStatistics = defined(minimumValues) && defined(maximumValues);\n\n  shaderBuilder.addDefine(\n    \"METADATA_COUNT\",\n    attributeLength,\n    ShaderDestination.FRAGMENT,\n  );\n\n  if (hasStatistics) {\n    shaderBuilder.addDefine(\n      \"STATISTICS\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  // PropertyStatistics structs\n  for (let i = 0; i < attributeLength; i++) {\n    const name = names[i];\n    const glslType = getGlslType(types[i]);\n    const propertyStatisticsStructId = `PropertyStatistics_${name}`;\n    const propertyStatisticsStructName = `PropertyStatistics_${name}`;\n    shaderBuilder.addStruct(\n      propertyStatisticsStructId,\n      propertyStatisticsStructName,\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addStructField(propertyStatisticsStructId, glslType, \"min\");\n    shaderBuilder.addStructField(propertyStatisticsStructId, glslType, \"max\");\n  }\n\n  // MetadataStatistics struct\n  const metadataStatisticsStructId = \"MetadataStatistics\";\n  const metadataStatisticsStructName = \"MetadataStatistics\";\n  const metadataStatisticsFieldName = \"metadataStatistics\";\n  shaderBuilder.addStruct(\n    metadataStatisticsStructId,\n    metadataStatisticsStructName,\n    ShaderDestination.FRAGMENT,\n  );\n  for (let i = 0; i < attributeLength; i++) {\n    const name = names[i];\n    const propertyStructName = `PropertyStatistics_${name}`;\n    const propertyFieldName = name;\n    shaderBuilder.addStructField(\n      metadataStatisticsStructId,\n      propertyStructName,\n      propertyFieldName,\n    );\n  }\n\n  // Metadata struct\n  const metadataStructId = \"Metadata\";\n  const metadataStructName = \"Metadata\";\n  const metadataFieldName = \"metadata\";\n  shaderBuilder.addStruct(\n    metadataStructId,\n    metadataStructName,\n    ShaderDestination.FRAGMENT,\n  );\n  for (let i = 0; i < attributeLength; i++) {\n    const glslType = getGlslType(types[i]);\n    shaderBuilder.addStructField(metadataStructId, glslType, names[i]);\n  }\n\n  // Attributes struct\n  const attributesStructId = \"Attributes\";\n  const attributesStructName = \"Attributes\";\n  const attributesFieldName = \"attributes\";\n  shaderBuilder.addStruct(\n    attributesStructId,\n    attributesStructName,\n    ShaderDestination.FRAGMENT,\n  );\n  shaderBuilder.addStructField(attributesStructId, \"vec3\", \"positionEC\");\n  shaderBuilder.addStructField(attributesStructId, \"vec3\", \"normalEC\");\n\n  // Voxel struct\n  const voxelStructId = \"Voxel\";\n  const voxelStructName = \"Voxel\";\n  const voxelFieldName = \"voxel\";\n  shaderBuilder.addStruct(\n    voxelStructId,\n    voxelStructName,\n    ShaderDestination.FRAGMENT,\n  );\n  shaderBuilder.addStructField(voxelStructId, \"vec3\", \"viewDirUv\");\n  shaderBuilder.addStructField(voxelStructId, \"float\", \"travelDistance\");\n  shaderBuilder.addStructField(voxelStructId, \"int\", \"stepCount\");\n  shaderBuilder.addStructField(voxelStructId, \"int\", \"tileIndex\");\n  shaderBuilder.addStructField(voxelStructId, \"int\", \"sampleIndex\");\n  shaderBuilder.addStructField(voxelStructId, \"float\", \"distanceToDepthBuffer\");\n\n  // FragmentInput struct\n  const fragmentInputStructId = \"FragmentInput\";\n  const fragmentInputStructName = \"FragmentInput\";\n  shaderBuilder.addStruct(\n    fragmentInputStructId,\n    fragmentInputStructName,\n    ShaderDestination.FRAGMENT,\n  );\n  shaderBuilder.addStructField(\n    fragmentInputStructId,\n    metadataStatisticsStructName,\n    metadataStatisticsFieldName,\n  );\n  shaderBuilder.addStructField(\n    fragmentInputStructId,\n    metadataStructName,\n    metadataFieldName,\n  );\n  shaderBuilder.addStructField(\n    fragmentInputStructId,\n    attributesStructName,\n    attributesFieldName,\n  );\n  shaderBuilder.addStructField(\n    fragmentInputStructId,\n    voxelStructName,\n    voxelFieldName,\n  );\n\n  // Properties struct\n  const propertiesStructId = \"Properties\";\n  const propertiesStructName = \"Properties\";\n  const propertiesFieldName = \"properties\";\n  shaderBuilder.addStruct(\n    propertiesStructId,\n    propertiesStructName,\n    ShaderDestination.FRAGMENT,\n  );\n  for (let i = 0; i < attributeLength; i++) {\n    const glslType = getGlslType(types[i]);\n    shaderBuilder.addStructField(propertiesStructId, glslType, names[i]);\n  }\n\n  // Fragment shader functions\n\n  // clearProperties function\n  {\n    const functionId = \"clearProperties\";\n    shaderBuilder.addFunction(\n      functionId,\n      `${propertiesStructName} clearProperties()`,\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addFunctionLines(functionId, [\n      `${propertiesStructName} ${propertiesFieldName};`,\n    ]);\n    for (let i = 0; i < attributeLength; i++) {\n      const glslType = getGlslType(types[i], componentTypes[i]);\n      shaderBuilder.addFunctionLines(functionId, [\n        `${propertiesFieldName}.${names[i]} = ${glslType}(0.0);`,\n      ]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [\n      `return ${propertiesFieldName};`,\n    ]);\n  }\n\n  // sumProperties function\n  {\n    const functionId = \"sumProperties\";\n    shaderBuilder.addFunction(\n      functionId,\n      `${propertiesStructName} sumProperties(${propertiesStructName} propertiesA, ${propertiesStructName} propertiesB)`,\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addFunctionLines(functionId, [\n      `${propertiesStructName} ${propertiesFieldName};`,\n    ]);\n    for (let i = 0; i < attributeLength; i++) {\n      const name = names[i];\n      shaderBuilder.addFunctionLines(functionId, [\n        `${propertiesFieldName}.${name} = propertiesA.${name} + propertiesB.${name};`,\n      ]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [\n      `return ${propertiesFieldName};`,\n    ]);\n  }\n\n  // scaleProperties function\n  {\n    const functionId = \"scaleProperties\";\n    shaderBuilder.addFunction(\n      functionId,\n      `${propertiesStructName} scaleProperties(${propertiesStructName} ${propertiesFieldName}, float scale)`,\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addFunctionLines(functionId, [\n      `${propertiesStructName} scaledProperties = ${propertiesFieldName};`,\n    ]);\n    for (let i = 0; i < attributeLength; i++) {\n      shaderBuilder.addFunctionLines(functionId, [\n        `scaledProperties.${names[i]} *= scale;`,\n      ]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [`return scaledProperties;`]);\n  }\n\n  // mixProperties\n  {\n    const functionId = \"mixProperties\";\n    shaderBuilder.addFunction(\n      functionId,\n      `${propertiesStructName} mixProperties(${propertiesStructName} propertiesA, ${propertiesStructName} propertiesB, float mixFactor)`,\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addFunctionLines(functionId, [\n      `${propertiesStructName} ${propertiesFieldName};`,\n    ]);\n    for (let i = 0; i < attributeLength; i++) {\n      const name = names[i];\n      shaderBuilder.addFunctionLines(functionId, [\n        `${propertiesFieldName}.${name} = mix(propertiesA.${name}, propertiesB.${name}, mixFactor);`,\n      ]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [\n      `return ${propertiesFieldName};`,\n    ]);\n  }\n\n  // copyPropertiesToMetadata\n  {\n    const functionId = \"copyPropertiesToMetadata\";\n    shaderBuilder.addFunction(\n      functionId,\n      `void copyPropertiesToMetadata(in ${propertiesStructName} ${propertiesFieldName}, inout ${metadataStructName} ${metadataFieldName})`,\n      ShaderDestination.FRAGMENT,\n    );\n    for (let i = 0; i < attributeLength; i++) {\n      const name = names[i];\n      shaderBuilder.addFunctionLines(functionId, [\n        `${metadataFieldName}.${name} = ${propertiesFieldName}.${name};`,\n      ]);\n    }\n  }\n\n  // setStatistics function\n  if (hasStatistics) {\n    const functionId = \"setStatistics\";\n    shaderBuilder.addFunction(\n      functionId,\n      `void setStatistics(inout ${metadataStatisticsStructName} ${metadataStatisticsFieldName})`,\n      ShaderDestination.FRAGMENT,\n    );\n    for (let i = 0; i < attributeLength; i++) {\n      const name = names[i];\n      const type = types[i];\n      const componentCount = MetadataType.getComponentCount(type);\n      for (let j = 0; j < componentCount; j++) {\n        const glslField = getGlslField(type, j);\n        const minimumValue = minimumValues[i][j];\n        const maximumValue = maximumValues[i][j];\n        if (!defined(minimumValue) || !defined(maximumValue)) {\n          continue;\n        }\n        shaderBuilder.addFunctionLines(functionId, [\n          `${metadataStatisticsFieldName}.${name}.min${glslField} = ${getGlslNumberAsFloat(\n            minimumValue,\n          )};`,\n          `${metadataStatisticsFieldName}.${name}.max${glslField} = ${getGlslNumberAsFloat(\n            maximumValue,\n          )};`,\n        ]);\n      }\n    }\n  }\n\n  // getPropertiesFromMegatextureAtUv\n  {\n    const functionId = \"getPropertiesFromMegatextureAtUv\";\n    shaderBuilder.addFunction(\n      functionId,\n      `${propertiesStructName} getPropertiesFromMegatextureAtUv(vec2 texcoord)`,\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addFunctionLines(functionId, [\n      `${propertiesStructName} ${propertiesFieldName};`,\n    ]);\n    for (let i = 0; i < attributeLength; i++) {\n      const type = types[i];\n      const componentType = componentTypes[i];\n      const glslTextureSwizzle = getGlslTextureSwizzle(type, componentType);\n      shaderBuilder.addFunctionLines(functionId, [\n        `properties.${names[i]} = texture(u_megatextureTextures[${i}], texcoord)${glslTextureSwizzle};`,\n      ]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [\n      `return ${propertiesFieldName};`,\n    ]);\n  }\n}\n\n/**\n * Converts a {@link MetadataType} to a GLSL type.\n *\n * @function\n *\n * @param {MetadataType} type The {@link MetadataType}.\n * @returns {string} The GLSL type.\n *\n * @private\n */\nfunction getGlslType(type) {\n  if (type === MetadataType.SCALAR) {\n    return \"float\";\n  } else if (type === MetadataType.VEC2) {\n    return \"vec2\";\n  } else if (type === MetadataType.VEC3) {\n    return \"vec3\";\n  } else if (type === MetadataType.VEC4) {\n    return \"vec4\";\n  }\n}\n\n/**\n * Gets the GLSL swizzle when reading data from a texture.\n *\n * @function\n *\n * @param {MetadataType} type The {@link MetadataType}.\n * @returns {string} The GLSL swizzle.\n *\n * @private\n */\nfunction getGlslTextureSwizzle(type) {\n  if (type === MetadataType.SCALAR) {\n    return \".r\";\n  } else if (type === MetadataType.VEC2) {\n    return \".ra\";\n  } else if (type === MetadataType.VEC3) {\n    return \".rgb\";\n  } else if (type === MetadataType.VEC4) {\n    return \"\";\n  }\n}\n\n/**\n * GLSL needs to have `.0` at the end of whole number floats or else it's\n * treated like an integer.\n *\n * @function\n *\n * @param {number} number The number to convert.\n * @returns {string} The number as floating point in GLSL.\n *\n * @private\n */\nfunction getGlslNumberAsFloat(number) {\n  let numberString = number.toString();\n  if (numberString.indexOf(\".\") === -1) {\n    numberString = `${number}.0`;\n  }\n  return numberString;\n}\n\n/**\n * Gets the GLSL field\n *\n * @function\n *\n * @param {MetadataType} type\n * @param {number} index\n * @returns {string}\n *\n * @private\n */\nfunction getGlslField(type, index) {\n  if (type === MetadataType.SCALAR) {\n    return \"\";\n  }\n  return `[${index}]`;\n}\n\nexport default processVoxelProperties;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}