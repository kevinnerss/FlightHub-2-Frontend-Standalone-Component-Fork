{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport ImageryLayer from \"./ImageryLayer.js\";\n\n/**\n * An ordered collection of imagery layers for rendering raster imagery on a {@link Globe} or {@link Cesium3DTileset}.\n *\n * @alias ImageryLayerCollection\n * @constructor\n * @see {@link Scene#imageryLayers} for manipulating imagery layers on the globe.\n * @see {@link Cesium3DTileset#imageryLayers} for manipulating imagery layers on a 3D tileset.\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Imagery%20Adjustment.html|Cesium Sandcastle Imagery Adjustment Demo}\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Imagery%20Layers%20Manipulation.html|Cesium Sandcastle Imagery Manipulation Demo}\n */\nfunction ImageryLayerCollection() {\n  this._layers = [];\n\n  /**\n   * An event that is raised when a layer is added to the collection.  Event handlers are passed the layer that\n   * was added and the index at which it was added.\n   * @type {Event}\n   * @default Event()\n   */\n  this.layerAdded = new Event();\n\n  /**\n   * An event that is raised when a layer is removed from the collection.  Event handlers are passed the layer that\n   * was removed and the index from which it was removed.\n   * @type {Event}\n   * @default Event()\n   */\n  this.layerRemoved = new Event();\n\n  /**\n   * An event that is raised when a layer changes position in the collection.  Event handlers are passed the layer that\n   * was moved, its new index after the move, and its old index prior to the move.\n   * @type {Event}\n   * @default Event()\n   */\n  this.layerMoved = new Event();\n\n  /**\n   * An event that is raised when a layer is shown or hidden by setting the\n   * {@link ImageryLayer#show} property.  Event handlers are passed a reference to this layer,\n   * the index of the layer in the collection, and a flag that is true if the layer is now\n   * shown or false if it is now hidden.\n   *\n   * @type {Event}\n   * @default Event()\n   */\n  this.layerShownOrHidden = new Event();\n}\nObject.defineProperties(ImageryLayerCollection.prototype, {\n  /**\n   * Gets the number of layers in this collection.\n   * @memberof ImageryLayerCollection.prototype\n   * @type {number}\n   */\n  length: {\n    get: function () {\n      return this._layers.length;\n    }\n  }\n});\n\n/**\n * Adds a layer to the collection.\n *\n * @param {ImageryLayer} layer the layer to add.\n * @param {number} [index] the index to add the layer at.  If omitted, the layer will\n *                         be added on top of all existing layers.\n *\n * @exception {DeveloperError} index, if supplied, must be greater than or equal to zero and less than or equal to the number of the layers.\n *\n * @example\n * const imageryLayer = Cesium.ImageryLayer.fromWorldImagery();\n * scene.imageryLayers.add(imageryLayer);\n *\n * @example\n * const imageryLayer = Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));\n * scene.imageryLayers.add(imageryLayer);\n */\nImageryLayerCollection.prototype.add = function (layer, index) {\n  const hasIndex = defined(index);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(layer)) {\n    throw new DeveloperError(\"layer is required.\");\n  }\n  if (hasIndex) {\n    if (index < 0) {\n      throw new DeveloperError(\"index must be greater than or equal to zero.\");\n    } else if (index > this._layers.length) {\n      throw new DeveloperError(\"index must be less than or equal to the number of layers.\");\n    }\n  }\n  //>>includeEnd('debug');\n\n  if (!hasIndex) {\n    index = this._layers.length;\n    this._layers.push(layer);\n  } else {\n    this._layers.splice(index, 0, layer);\n  }\n  this._update();\n  this.layerAdded.raiseEvent(layer, index);\n  const removeReadyEventListener = layer.readyEvent.addEventListener(() => {\n    this.layerShownOrHidden.raiseEvent(layer, layer._layerIndex, layer.show);\n    removeReadyEventListener();\n  });\n};\n\n/**\n * Creates a new layer using the given ImageryProvider and adds it to the collection.\n *\n * @param {ImageryProvider} imageryProvider the imagery provider to create a new layer for.\n * @param {number} [index] the index to add the layer at.  If omitted, the layer will\n *                         added on top of all existing layers.\n * @returns {ImageryLayer} The newly created layer.\n *\n * @example\n * try {\n *    const provider = await Cesium.IonImageryProvider.fromAssetId(3812);\n *    scene.imageryLayers.addImageryProvider(provider);\n * } catch (error) {\n *   console.log(`There was an error creating the imagery layer. ${error}`)\n * }\n */\nImageryLayerCollection.prototype.addImageryProvider = function (imageryProvider, index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(imageryProvider)) {\n    throw new DeveloperError(\"imageryProvider is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const layer = new ImageryLayer(imageryProvider);\n  this.add(layer, index);\n  return layer;\n};\n\n/**\n * Removes a layer from this collection, if present.\n *\n * @param {ImageryLayer} layer The layer to remove.\n * @param {boolean} [destroy=true] whether to destroy the layers in addition to removing them.\n * @returns {boolean} true if the layer was in the collection and was removed,\n *                    false if the layer was not in the collection.\n */\nImageryLayerCollection.prototype.remove = function (layer, destroy) {\n  destroy = destroy ?? true;\n  const index = this._layers.indexOf(layer);\n  if (index !== -1) {\n    this._layers.splice(index, 1);\n    this._update();\n    this.layerRemoved.raiseEvent(layer, index);\n    if (destroy) {\n      layer.destroy();\n    }\n    return true;\n  }\n  return false;\n};\n\n/**\n * Removes all layers from this collection.\n *\n * @param {boolean} [destroy=true] whether to destroy the layers in addition to removing them.\n */\nImageryLayerCollection.prototype.removeAll = function (destroy) {\n  destroy = destroy ?? true;\n  const layers = this._layers;\n  for (let i = 0, len = layers.length; i < len; i++) {\n    const layer = layers[i];\n    this.layerRemoved.raiseEvent(layer, i);\n    if (destroy) {\n      layer.destroy();\n    }\n  }\n  this._layers = [];\n};\n\n/**\n * Checks to see if the collection contains a given layer.\n *\n * @param {ImageryLayer} layer the layer to check for.\n *\n * @returns {boolean} true if the collection contains the layer, false otherwise.\n */\nImageryLayerCollection.prototype.contains = function (layer) {\n  return this.indexOf(layer) !== -1;\n};\n\n/**\n * Determines the index of a given layer in the collection.\n *\n * @param {ImageryLayer} layer The layer to find the index of.\n *\n * @returns {number} The index of the layer in the collection, or -1 if the layer does not exist in the collection.\n */\nImageryLayerCollection.prototype.indexOf = function (layer) {\n  return this._layers.indexOf(layer);\n};\n\n/**\n * Gets a layer by index from the collection.\n *\n * @param {number} index the index to retrieve.\n *\n * @returns {ImageryLayer} The imagery layer at the given index.\n */\nImageryLayerCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\", \"index\");\n  }\n  //>>includeEnd('debug');\n\n  return this._layers[index];\n};\nfunction getLayerIndex(layers, layer) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(layer)) {\n    throw new DeveloperError(\"layer is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const index = layers.indexOf(layer);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (index === -1) {\n    throw new DeveloperError(\"layer is not in this collection.\");\n  }\n  //>>includeEnd('debug');\n\n  return index;\n}\nfunction swapLayers(collection, i, j) {\n  const arr = collection._layers;\n  i = CesiumMath.clamp(i, 0, arr.length - 1);\n  j = CesiumMath.clamp(j, 0, arr.length - 1);\n  if (i === j) {\n    return;\n  }\n  const temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n  collection._update();\n  collection.layerMoved.raiseEvent(temp, j, i);\n}\n\n/**\n * Raises a layer up one position in the collection.\n *\n * @param {ImageryLayer} layer the layer to move.\n *\n * @exception {DeveloperError} layer is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nImageryLayerCollection.prototype.raise = function (layer) {\n  const index = getLayerIndex(this._layers, layer);\n  swapLayers(this, index, index + 1);\n};\n\n/**\n * Lowers a layer down one position in the collection.\n *\n * @param {ImageryLayer} layer the layer to move.\n *\n * @exception {DeveloperError} layer is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nImageryLayerCollection.prototype.lower = function (layer) {\n  const index = getLayerIndex(this._layers, layer);\n  swapLayers(this, index, index - 1);\n};\n\n/**\n * Raises a layer to the top of the collection.\n *\n * @param {ImageryLayer} layer the layer to move.\n *\n * @exception {DeveloperError} layer is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nImageryLayerCollection.prototype.raiseToTop = function (layer) {\n  const index = getLayerIndex(this._layers, layer);\n  if (index === this._layers.length - 1) {\n    return;\n  }\n  this._layers.splice(index, 1);\n  this._layers.push(layer);\n  this._update();\n  this.layerMoved.raiseEvent(layer, this._layers.length - 1, index);\n};\n\n/**\n * Lowers a layer to the bottom of the collection.\n *\n * @param {ImageryLayer} layer the layer to move.\n *\n * @exception {DeveloperError} layer is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nImageryLayerCollection.prototype.lowerToBottom = function (layer) {\n  const index = getLayerIndex(this._layers, layer);\n  if (index === 0) {\n    return;\n  }\n  this._layers.splice(index, 1);\n  this._layers.splice(0, 0, layer);\n  this._update();\n  this.layerMoved.raiseEvent(layer, 0, index);\n};\nconst applicableRectangleScratch = new Rectangle();\nfunction pickImageryHelper(scene, pickedLocation, pickFeatures, callback) {\n  // Find the terrain tile containing the picked location.\n  const tilesToRender = scene.globe._surface._tilesToRender;\n  let pickedTile;\n  for (let textureIndex = 0; !defined(pickedTile) && textureIndex < tilesToRender.length; ++textureIndex) {\n    const tile = tilesToRender[textureIndex];\n    if (Rectangle.contains(tile.rectangle, pickedLocation)) {\n      pickedTile = tile;\n    }\n  }\n  if (!defined(pickedTile)) {\n    return;\n  }\n\n  // Pick against all attached imagery tiles containing the pickedLocation.\n  const imageryTiles = pickedTile.data.imagery;\n  for (let i = imageryTiles.length - 1; i >= 0; --i) {\n    const terrainImagery = imageryTiles[i];\n    const imagery = terrainImagery.readyImagery;\n    if (!defined(imagery)) {\n      continue;\n    }\n    if (!imagery.imageryLayer.ready) {\n      continue;\n    }\n    const provider = imagery.imageryLayer.imageryProvider;\n    if (pickFeatures && !defined(provider.pickFeatures)) {\n      continue;\n    }\n    if (!Rectangle.contains(imagery.rectangle, pickedLocation)) {\n      continue;\n    }\n\n    // If this imagery came from a parent, it may not be applicable to its entire rectangle.\n    // Check the textureCoordinateRectangle.\n    const applicableRectangle = applicableRectangleScratch;\n    const epsilon = 1 / 1024; // 1/4 of a pixel in a typical 256x256 tile.\n    applicableRectangle.west = CesiumMath.lerp(pickedTile.rectangle.west, pickedTile.rectangle.east, terrainImagery.textureCoordinateRectangle.x - epsilon);\n    applicableRectangle.east = CesiumMath.lerp(pickedTile.rectangle.west, pickedTile.rectangle.east, terrainImagery.textureCoordinateRectangle.z + epsilon);\n    applicableRectangle.south = CesiumMath.lerp(pickedTile.rectangle.south, pickedTile.rectangle.north, terrainImagery.textureCoordinateRectangle.y - epsilon);\n    applicableRectangle.north = CesiumMath.lerp(pickedTile.rectangle.south, pickedTile.rectangle.north, terrainImagery.textureCoordinateRectangle.w + epsilon);\n    if (!Rectangle.contains(applicableRectangle, pickedLocation)) {\n      continue;\n    }\n    callback(imagery);\n  }\n}\n\n/**\n * Determines the imagery layers that are intersected by a pick ray. To compute a pick ray from a\n * location on the screen, use {@link Camera.getPickRay}.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {Scene} scene The scene.\n * @return {ImageryLayer[]|undefined} An array that includes all of\n *                                 the layers that are intersected by a given pick ray. Undefined if\n *                                 no layers are selected.\n *\n */\nImageryLayerCollection.prototype.pickImageryLayers = function (ray, scene) {\n  // Find the picked location on the globe.\n  const pickedPosition = scene.globe.pick(ray, scene);\n  if (!defined(pickedPosition)) {\n    return;\n  }\n  const pickedLocation = scene.ellipsoid.cartesianToCartographic(pickedPosition);\n  const imageryLayers = [];\n  pickImageryHelper(scene, pickedLocation, false, function (imagery) {\n    imageryLayers.push(imagery.imageryLayer);\n  });\n  if (imageryLayers.length === 0) {\n    return undefined;\n  }\n  return imageryLayers;\n};\n\n/**\n * Asynchronously determines the imagery layer features that are intersected by a pick ray.  The intersected imagery\n * layer features are found by invoking {@link ImageryProvider#pickFeatures} for each imagery layer tile intersected\n * by the pick ray.  To compute a pick ray from a location on the screen, use {@link Camera.getPickRay}.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {Scene} scene The scene.\n * @return {Promise<ImageryLayerFeatureInfo[]>|undefined} A promise that resolves to an array of features intersected by the pick ray.\n *                                             If it can be quickly determined that no features are intersected (for example,\n *                                             because no active imagery providers support {@link ImageryProvider#pickFeatures}\n *                                             or because the pick ray does not intersect the surface), this function will\n *                                             return undefined.\n *\n * @example\n * const pickRay = viewer.camera.getPickRay(windowPosition);\n * const featuresPromise = viewer.imageryLayers.pickImageryLayerFeatures(pickRay, viewer.scene);\n * if (!Cesium.defined(featuresPromise)) {\n *     console.log('No features picked.');\n * } else {\n *     Promise.resolve(featuresPromise).then(function(features) {\n *         // This function is called asynchronously when the list if picked features is available.\n *         console.log(`Number of features: ${features.length}`);\n *         if (features.length > 0) {\n *             console.log(`First feature name: ${features[0].name}`);\n *         }\n *     });\n * }\n */\nImageryLayerCollection.prototype.pickImageryLayerFeatures = function (ray, scene) {\n  // Find the picked location on the globe.\n  const pickedPosition = scene.globe.pick(ray, scene);\n  if (!defined(pickedPosition)) {\n    return;\n  }\n  const pickedLocation = scene.ellipsoid.cartesianToCartographic(pickedPosition);\n  const promises = [];\n  const imageryLayers = [];\n  pickImageryHelper(scene, pickedLocation, true, function (imagery) {\n    if (!imagery.imageryLayer.ready) {\n      return undefined;\n    }\n    const provider = imagery.imageryLayer.imageryProvider;\n    const promise = provider.pickFeatures(imagery.x, imagery.y, imagery.level, pickedLocation.longitude, pickedLocation.latitude);\n    if (defined(promise)) {\n      promises.push(promise);\n      imageryLayers.push(imagery.imageryLayer);\n    }\n  });\n  if (promises.length === 0) {\n    return undefined;\n  }\n  return Promise.all(promises).then(function (results) {\n    const features = [];\n    for (let resultIndex = 0; resultIndex < results.length; ++resultIndex) {\n      const result = results[resultIndex];\n      const image = imageryLayers[resultIndex];\n      if (defined(result) && result.length > 0) {\n        for (let featureIndex = 0; featureIndex < result.length; ++featureIndex) {\n          const feature = result[featureIndex];\n          feature.imageryLayer = image;\n          // For features without a position, use the picked location.\n          if (!defined(feature.position)) {\n            feature.position = pickedLocation;\n          }\n          features.push(feature);\n        }\n      }\n    }\n    return features;\n  });\n};\n\n/**\n * Updates frame state to execute any queued texture re-projections.\n *\n * @private\n *\n * @param {FrameState} frameState The frameState.\n */\nImageryLayerCollection.prototype.queueReprojectionCommands = function (frameState) {\n  const layers = this._layers;\n  for (let i = 0, len = layers.length; i < len; ++i) {\n    layers[i].queueReprojectionCommands(frameState);\n  }\n};\n\n/**\n * Cancels re-projection commands queued for the next frame.\n *\n * @private\n */\nImageryLayerCollection.prototype.cancelReprojections = function () {\n  const layers = this._layers;\n  for (let i = 0, len = layers.length; i < len; ++i) {\n    layers[i].cancelReprojections();\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} true if this object was destroyed; otherwise, false.\n *\n * @see ImageryLayerCollection#destroy\n */\nImageryLayerCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by all layers in this collection.  Explicitly destroying this\n * object allows for deterministic release of WebGL resources, instead of relying on the garbage\n * collector.\n * <br /><br />\n * Once this object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * layerCollection = layerCollection && layerCollection.destroy();\n *\n * @see ImageryLayerCollection#isDestroyed\n */\nImageryLayerCollection.prototype.destroy = function () {\n  this.removeAll(true);\n  return destroyObject(this);\n};\nImageryLayerCollection.prototype._update = function () {\n  let isBaseLayer = true;\n  const layers = this._layers;\n  let layersShownOrHidden;\n  let layer;\n  let i, len;\n  for (i = 0, len = layers.length; i < len; ++i) {\n    layer = layers[i];\n    layer._layerIndex = i;\n    if (layer.show) {\n      layer._isBaseLayer = isBaseLayer;\n      isBaseLayer = false;\n    } else {\n      layer._isBaseLayer = false;\n    }\n    if (layer.show !== layer._show) {\n      if (defined(layer._show)) {\n        if (!defined(layersShownOrHidden)) {\n          layersShownOrHidden = [];\n        }\n        layersShownOrHidden.push(layer);\n      }\n      layer._show = layer.show;\n    }\n  }\n  if (defined(layersShownOrHidden)) {\n    for (i = 0, len = layersShownOrHidden.length; i < len; ++i) {\n      layer = layersShownOrHidden[i];\n      this.layerShownOrHidden.raiseEvent(layer, layer._layerIndex, layer.show);\n    }\n  }\n};\nexport default ImageryLayerCollection;","map":{"version":3,"names":["defined","destroyObject","DeveloperError","Event","CesiumMath","Rectangle","ImageryLayer","ImageryLayerCollection","_layers","layerAdded","layerRemoved","layerMoved","layerShownOrHidden","Object","defineProperties","prototype","length","get","add","layer","index","hasIndex","push","splice","_update","raiseEvent","removeReadyEventListener","readyEvent","addEventListener","_layerIndex","show","addImageryProvider","imageryProvider","remove","destroy","indexOf","removeAll","layers","i","len","contains","getLayerIndex","swapLayers","collection","j","arr","clamp","temp","raise","lower","raiseToTop","lowerToBottom","applicableRectangleScratch","pickImageryHelper","scene","pickedLocation","pickFeatures","callback","tilesToRender","globe","_surface","_tilesToRender","pickedTile","textureIndex","tile","rectangle","imageryTiles","data","imagery","terrainImagery","readyImagery","imageryLayer","ready","provider","applicableRectangle","epsilon","west","lerp","east","textureCoordinateRectangle","x","z","south","north","y","w","pickImageryLayers","ray","pickedPosition","pick","ellipsoid","cartesianToCartographic","imageryLayers","undefined","pickImageryLayerFeatures","promises","promise","level","longitude","latitude","Promise","all","then","results","features","resultIndex","result","image","featureIndex","feature","position","queueReprojectionCommands","frameState","cancelReprojections","isDestroyed","isBaseLayer","layersShownOrHidden","_isBaseLayer","_show"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/ImageryLayerCollection.js"],"sourcesContent":["import defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport ImageryLayer from \"./ImageryLayer.js\";\n\n/**\n * An ordered collection of imagery layers for rendering raster imagery on a {@link Globe} or {@link Cesium3DTileset}.\n *\n * @alias ImageryLayerCollection\n * @constructor\n * @see {@link Scene#imageryLayers} for manipulating imagery layers on the globe.\n * @see {@link Cesium3DTileset#imageryLayers} for manipulating imagery layers on a 3D tileset.\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Imagery%20Adjustment.html|Cesium Sandcastle Imagery Adjustment Demo}\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Imagery%20Layers%20Manipulation.html|Cesium Sandcastle Imagery Manipulation Demo}\n */\nfunction ImageryLayerCollection() {\n  this._layers = [];\n\n  /**\n   * An event that is raised when a layer is added to the collection.  Event handlers are passed the layer that\n   * was added and the index at which it was added.\n   * @type {Event}\n   * @default Event()\n   */\n  this.layerAdded = new Event();\n\n  /**\n   * An event that is raised when a layer is removed from the collection.  Event handlers are passed the layer that\n   * was removed and the index from which it was removed.\n   * @type {Event}\n   * @default Event()\n   */\n  this.layerRemoved = new Event();\n\n  /**\n   * An event that is raised when a layer changes position in the collection.  Event handlers are passed the layer that\n   * was moved, its new index after the move, and its old index prior to the move.\n   * @type {Event}\n   * @default Event()\n   */\n  this.layerMoved = new Event();\n\n  /**\n   * An event that is raised when a layer is shown or hidden by setting the\n   * {@link ImageryLayer#show} property.  Event handlers are passed a reference to this layer,\n   * the index of the layer in the collection, and a flag that is true if the layer is now\n   * shown or false if it is now hidden.\n   *\n   * @type {Event}\n   * @default Event()\n   */\n  this.layerShownOrHidden = new Event();\n}\n\nObject.defineProperties(ImageryLayerCollection.prototype, {\n  /**\n   * Gets the number of layers in this collection.\n   * @memberof ImageryLayerCollection.prototype\n   * @type {number}\n   */\n  length: {\n    get: function () {\n      return this._layers.length;\n    },\n  },\n});\n\n/**\n * Adds a layer to the collection.\n *\n * @param {ImageryLayer} layer the layer to add.\n * @param {number} [index] the index to add the layer at.  If omitted, the layer will\n *                         be added on top of all existing layers.\n *\n * @exception {DeveloperError} index, if supplied, must be greater than or equal to zero and less than or equal to the number of the layers.\n *\n * @example\n * const imageryLayer = Cesium.ImageryLayer.fromWorldImagery();\n * scene.imageryLayers.add(imageryLayer);\n *\n * @example\n * const imageryLayer = Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));\n * scene.imageryLayers.add(imageryLayer);\n */\nImageryLayerCollection.prototype.add = function (layer, index) {\n  const hasIndex = defined(index);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(layer)) {\n    throw new DeveloperError(\"layer is required.\");\n  }\n  if (hasIndex) {\n    if (index < 0) {\n      throw new DeveloperError(\"index must be greater than or equal to zero.\");\n    } else if (index > this._layers.length) {\n      throw new DeveloperError(\n        \"index must be less than or equal to the number of layers.\",\n      );\n    }\n  }\n  //>>includeEnd('debug');\n\n  if (!hasIndex) {\n    index = this._layers.length;\n    this._layers.push(layer);\n  } else {\n    this._layers.splice(index, 0, layer);\n  }\n\n  this._update();\n  this.layerAdded.raiseEvent(layer, index);\n  const removeReadyEventListener = layer.readyEvent.addEventListener(() => {\n    this.layerShownOrHidden.raiseEvent(layer, layer._layerIndex, layer.show);\n    removeReadyEventListener();\n  });\n};\n\n/**\n * Creates a new layer using the given ImageryProvider and adds it to the collection.\n *\n * @param {ImageryProvider} imageryProvider the imagery provider to create a new layer for.\n * @param {number} [index] the index to add the layer at.  If omitted, the layer will\n *                         added on top of all existing layers.\n * @returns {ImageryLayer} The newly created layer.\n *\n * @example\n * try {\n *    const provider = await Cesium.IonImageryProvider.fromAssetId(3812);\n *    scene.imageryLayers.addImageryProvider(provider);\n * } catch (error) {\n *   console.log(`There was an error creating the imagery layer. ${error}`)\n * }\n */\nImageryLayerCollection.prototype.addImageryProvider = function (\n  imageryProvider,\n  index,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(imageryProvider)) {\n    throw new DeveloperError(\"imageryProvider is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const layer = new ImageryLayer(imageryProvider);\n  this.add(layer, index);\n  return layer;\n};\n\n/**\n * Removes a layer from this collection, if present.\n *\n * @param {ImageryLayer} layer The layer to remove.\n * @param {boolean} [destroy=true] whether to destroy the layers in addition to removing them.\n * @returns {boolean} true if the layer was in the collection and was removed,\n *                    false if the layer was not in the collection.\n */\nImageryLayerCollection.prototype.remove = function (layer, destroy) {\n  destroy = destroy ?? true;\n\n  const index = this._layers.indexOf(layer);\n  if (index !== -1) {\n    this._layers.splice(index, 1);\n\n    this._update();\n\n    this.layerRemoved.raiseEvent(layer, index);\n\n    if (destroy) {\n      layer.destroy();\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Removes all layers from this collection.\n *\n * @param {boolean} [destroy=true] whether to destroy the layers in addition to removing them.\n */\nImageryLayerCollection.prototype.removeAll = function (destroy) {\n  destroy = destroy ?? true;\n\n  const layers = this._layers;\n  for (let i = 0, len = layers.length; i < len; i++) {\n    const layer = layers[i];\n    this.layerRemoved.raiseEvent(layer, i);\n\n    if (destroy) {\n      layer.destroy();\n    }\n  }\n\n  this._layers = [];\n};\n\n/**\n * Checks to see if the collection contains a given layer.\n *\n * @param {ImageryLayer} layer the layer to check for.\n *\n * @returns {boolean} true if the collection contains the layer, false otherwise.\n */\nImageryLayerCollection.prototype.contains = function (layer) {\n  return this.indexOf(layer) !== -1;\n};\n\n/**\n * Determines the index of a given layer in the collection.\n *\n * @param {ImageryLayer} layer The layer to find the index of.\n *\n * @returns {number} The index of the layer in the collection, or -1 if the layer does not exist in the collection.\n */\nImageryLayerCollection.prototype.indexOf = function (layer) {\n  return this._layers.indexOf(layer);\n};\n\n/**\n * Gets a layer by index from the collection.\n *\n * @param {number} index the index to retrieve.\n *\n * @returns {ImageryLayer} The imagery layer at the given index.\n */\nImageryLayerCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\", \"index\");\n  }\n  //>>includeEnd('debug');\n\n  return this._layers[index];\n};\n\nfunction getLayerIndex(layers, layer) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(layer)) {\n    throw new DeveloperError(\"layer is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const index = layers.indexOf(layer);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (index === -1) {\n    throw new DeveloperError(\"layer is not in this collection.\");\n  }\n  //>>includeEnd('debug');\n\n  return index;\n}\n\nfunction swapLayers(collection, i, j) {\n  const arr = collection._layers;\n  i = CesiumMath.clamp(i, 0, arr.length - 1);\n  j = CesiumMath.clamp(j, 0, arr.length - 1);\n\n  if (i === j) {\n    return;\n  }\n\n  const temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n\n  collection._update();\n\n  collection.layerMoved.raiseEvent(temp, j, i);\n}\n\n/**\n * Raises a layer up one position in the collection.\n *\n * @param {ImageryLayer} layer the layer to move.\n *\n * @exception {DeveloperError} layer is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nImageryLayerCollection.prototype.raise = function (layer) {\n  const index = getLayerIndex(this._layers, layer);\n  swapLayers(this, index, index + 1);\n};\n\n/**\n * Lowers a layer down one position in the collection.\n *\n * @param {ImageryLayer} layer the layer to move.\n *\n * @exception {DeveloperError} layer is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nImageryLayerCollection.prototype.lower = function (layer) {\n  const index = getLayerIndex(this._layers, layer);\n  swapLayers(this, index, index - 1);\n};\n\n/**\n * Raises a layer to the top of the collection.\n *\n * @param {ImageryLayer} layer the layer to move.\n *\n * @exception {DeveloperError} layer is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nImageryLayerCollection.prototype.raiseToTop = function (layer) {\n  const index = getLayerIndex(this._layers, layer);\n  if (index === this._layers.length - 1) {\n    return;\n  }\n  this._layers.splice(index, 1);\n  this._layers.push(layer);\n\n  this._update();\n\n  this.layerMoved.raiseEvent(layer, this._layers.length - 1, index);\n};\n\n/**\n * Lowers a layer to the bottom of the collection.\n *\n * @param {ImageryLayer} layer the layer to move.\n *\n * @exception {DeveloperError} layer is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nImageryLayerCollection.prototype.lowerToBottom = function (layer) {\n  const index = getLayerIndex(this._layers, layer);\n  if (index === 0) {\n    return;\n  }\n  this._layers.splice(index, 1);\n  this._layers.splice(0, 0, layer);\n\n  this._update();\n\n  this.layerMoved.raiseEvent(layer, 0, index);\n};\n\nconst applicableRectangleScratch = new Rectangle();\n\nfunction pickImageryHelper(scene, pickedLocation, pickFeatures, callback) {\n  // Find the terrain tile containing the picked location.\n  const tilesToRender = scene.globe._surface._tilesToRender;\n  let pickedTile;\n\n  for (\n    let textureIndex = 0;\n    !defined(pickedTile) && textureIndex < tilesToRender.length;\n    ++textureIndex\n  ) {\n    const tile = tilesToRender[textureIndex];\n    if (Rectangle.contains(tile.rectangle, pickedLocation)) {\n      pickedTile = tile;\n    }\n  }\n\n  if (!defined(pickedTile)) {\n    return;\n  }\n\n  // Pick against all attached imagery tiles containing the pickedLocation.\n  const imageryTiles = pickedTile.data.imagery;\n\n  for (let i = imageryTiles.length - 1; i >= 0; --i) {\n    const terrainImagery = imageryTiles[i];\n    const imagery = terrainImagery.readyImagery;\n    if (!defined(imagery)) {\n      continue;\n    }\n    if (!imagery.imageryLayer.ready) {\n      continue;\n    }\n    const provider = imagery.imageryLayer.imageryProvider;\n    if (pickFeatures && !defined(provider.pickFeatures)) {\n      continue;\n    }\n\n    if (!Rectangle.contains(imagery.rectangle, pickedLocation)) {\n      continue;\n    }\n\n    // If this imagery came from a parent, it may not be applicable to its entire rectangle.\n    // Check the textureCoordinateRectangle.\n    const applicableRectangle = applicableRectangleScratch;\n\n    const epsilon = 1 / 1024; // 1/4 of a pixel in a typical 256x256 tile.\n    applicableRectangle.west = CesiumMath.lerp(\n      pickedTile.rectangle.west,\n      pickedTile.rectangle.east,\n      terrainImagery.textureCoordinateRectangle.x - epsilon,\n    );\n    applicableRectangle.east = CesiumMath.lerp(\n      pickedTile.rectangle.west,\n      pickedTile.rectangle.east,\n      terrainImagery.textureCoordinateRectangle.z + epsilon,\n    );\n    applicableRectangle.south = CesiumMath.lerp(\n      pickedTile.rectangle.south,\n      pickedTile.rectangle.north,\n      terrainImagery.textureCoordinateRectangle.y - epsilon,\n    );\n    applicableRectangle.north = CesiumMath.lerp(\n      pickedTile.rectangle.south,\n      pickedTile.rectangle.north,\n      terrainImagery.textureCoordinateRectangle.w + epsilon,\n    );\n    if (!Rectangle.contains(applicableRectangle, pickedLocation)) {\n      continue;\n    }\n\n    callback(imagery);\n  }\n}\n\n/**\n * Determines the imagery layers that are intersected by a pick ray. To compute a pick ray from a\n * location on the screen, use {@link Camera.getPickRay}.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {Scene} scene The scene.\n * @return {ImageryLayer[]|undefined} An array that includes all of\n *                                 the layers that are intersected by a given pick ray. Undefined if\n *                                 no layers are selected.\n *\n */\nImageryLayerCollection.prototype.pickImageryLayers = function (ray, scene) {\n  // Find the picked location on the globe.\n  const pickedPosition = scene.globe.pick(ray, scene);\n  if (!defined(pickedPosition)) {\n    return;\n  }\n\n  const pickedLocation =\n    scene.ellipsoid.cartesianToCartographic(pickedPosition);\n\n  const imageryLayers = [];\n\n  pickImageryHelper(scene, pickedLocation, false, function (imagery) {\n    imageryLayers.push(imagery.imageryLayer);\n  });\n\n  if (imageryLayers.length === 0) {\n    return undefined;\n  }\n\n  return imageryLayers;\n};\n\n/**\n * Asynchronously determines the imagery layer features that are intersected by a pick ray.  The intersected imagery\n * layer features are found by invoking {@link ImageryProvider#pickFeatures} for each imagery layer tile intersected\n * by the pick ray.  To compute a pick ray from a location on the screen, use {@link Camera.getPickRay}.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {Scene} scene The scene.\n * @return {Promise<ImageryLayerFeatureInfo[]>|undefined} A promise that resolves to an array of features intersected by the pick ray.\n *                                             If it can be quickly determined that no features are intersected (for example,\n *                                             because no active imagery providers support {@link ImageryProvider#pickFeatures}\n *                                             or because the pick ray does not intersect the surface), this function will\n *                                             return undefined.\n *\n * @example\n * const pickRay = viewer.camera.getPickRay(windowPosition);\n * const featuresPromise = viewer.imageryLayers.pickImageryLayerFeatures(pickRay, viewer.scene);\n * if (!Cesium.defined(featuresPromise)) {\n *     console.log('No features picked.');\n * } else {\n *     Promise.resolve(featuresPromise).then(function(features) {\n *         // This function is called asynchronously when the list if picked features is available.\n *         console.log(`Number of features: ${features.length}`);\n *         if (features.length > 0) {\n *             console.log(`First feature name: ${features[0].name}`);\n *         }\n *     });\n * }\n */\nImageryLayerCollection.prototype.pickImageryLayerFeatures = function (\n  ray,\n  scene,\n) {\n  // Find the picked location on the globe.\n  const pickedPosition = scene.globe.pick(ray, scene);\n  if (!defined(pickedPosition)) {\n    return;\n  }\n\n  const pickedLocation =\n    scene.ellipsoid.cartesianToCartographic(pickedPosition);\n\n  const promises = [];\n  const imageryLayers = [];\n\n  pickImageryHelper(scene, pickedLocation, true, function (imagery) {\n    if (!imagery.imageryLayer.ready) {\n      return undefined;\n    }\n    const provider = imagery.imageryLayer.imageryProvider;\n    const promise = provider.pickFeatures(\n      imagery.x,\n      imagery.y,\n      imagery.level,\n      pickedLocation.longitude,\n      pickedLocation.latitude,\n    );\n    if (defined(promise)) {\n      promises.push(promise);\n      imageryLayers.push(imagery.imageryLayer);\n    }\n  });\n\n  if (promises.length === 0) {\n    return undefined;\n  }\n  return Promise.all(promises).then(function (results) {\n    const features = [];\n    for (let resultIndex = 0; resultIndex < results.length; ++resultIndex) {\n      const result = results[resultIndex];\n      const image = imageryLayers[resultIndex];\n      if (defined(result) && result.length > 0) {\n        for (\n          let featureIndex = 0;\n          featureIndex < result.length;\n          ++featureIndex\n        ) {\n          const feature = result[featureIndex];\n          feature.imageryLayer = image;\n          // For features without a position, use the picked location.\n          if (!defined(feature.position)) {\n            feature.position = pickedLocation;\n          }\n          features.push(feature);\n        }\n      }\n    }\n    return features;\n  });\n};\n\n/**\n * Updates frame state to execute any queued texture re-projections.\n *\n * @private\n *\n * @param {FrameState} frameState The frameState.\n */\nImageryLayerCollection.prototype.queueReprojectionCommands = function (\n  frameState,\n) {\n  const layers = this._layers;\n  for (let i = 0, len = layers.length; i < len; ++i) {\n    layers[i].queueReprojectionCommands(frameState);\n  }\n};\n\n/**\n * Cancels re-projection commands queued for the next frame.\n *\n * @private\n */\nImageryLayerCollection.prototype.cancelReprojections = function () {\n  const layers = this._layers;\n  for (let i = 0, len = layers.length; i < len; ++i) {\n    layers[i].cancelReprojections();\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} true if this object was destroyed; otherwise, false.\n *\n * @see ImageryLayerCollection#destroy\n */\nImageryLayerCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by all layers in this collection.  Explicitly destroying this\n * object allows for deterministic release of WebGL resources, instead of relying on the garbage\n * collector.\n * <br /><br />\n * Once this object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * layerCollection = layerCollection && layerCollection.destroy();\n *\n * @see ImageryLayerCollection#isDestroyed\n */\nImageryLayerCollection.prototype.destroy = function () {\n  this.removeAll(true);\n  return destroyObject(this);\n};\n\nImageryLayerCollection.prototype._update = function () {\n  let isBaseLayer = true;\n  const layers = this._layers;\n  let layersShownOrHidden;\n  let layer;\n  let i, len;\n  for (i = 0, len = layers.length; i < len; ++i) {\n    layer = layers[i];\n\n    layer._layerIndex = i;\n\n    if (layer.show) {\n      layer._isBaseLayer = isBaseLayer;\n      isBaseLayer = false;\n    } else {\n      layer._isBaseLayer = false;\n    }\n\n    if (layer.show !== layer._show) {\n      if (defined(layer._show)) {\n        if (!defined(layersShownOrHidden)) {\n          layersShownOrHidden = [];\n        }\n        layersShownOrHidden.push(layer);\n      }\n      layer._show = layer.show;\n    }\n  }\n\n  if (defined(layersShownOrHidden)) {\n    for (i = 0, len = layersShownOrHidden.length; i < len; ++i) {\n      layer = layersShownOrHidden[i];\n      this.layerShownOrHidden.raiseEvent(layer, layer._layerIndex, layer.show);\n    }\n  }\n};\nexport default ImageryLayerCollection;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}