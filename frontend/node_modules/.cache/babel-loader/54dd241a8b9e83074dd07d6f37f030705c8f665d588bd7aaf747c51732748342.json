{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport AssociativeArray from \"../Core/AssociativeArray.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ClassificationType from \"../Scene/ClassificationType.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ShadowMode from \"../Scene/ShadowMode.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryBatch from \"./DynamicGeometryBatch.js\";\nimport Entity from \"./Entity.js\";\nimport GeometryUpdaterSet from \"./GeometryUpdaterSet.js\";\nimport StaticGeometryColorBatch from \"./StaticGeometryColorBatch.js\";\nimport StaticGeometryPerMaterialBatch from \"./StaticGeometryPerMaterialBatch.js\";\nimport StaticGroundGeometryColorBatch from \"./StaticGroundGeometryColorBatch.js\";\nimport StaticGroundGeometryPerMaterialBatch from \"./StaticGroundGeometryPerMaterialBatch.js\";\nimport StaticOutlineGeometryBatch from \"./StaticOutlineGeometryBatch.js\";\nconst emptyArray = [];\n\n/**\n * A general purpose visualizer for geometry represented by {@link Primitive} instances.\n * @alias GeometryVisualizer\n * @constructor\n *\n * @param {Scene} scene The scene the primitives will be rendered in.\n * @param {EntityCollection} entityCollection The entityCollection to visualize.\n * @param {PrimitiveCollection} [primitives=scene.primitives] A collection to add primitives related to the entities\n * @param {PrimitiveCollection} [groundPrimitives=scene.groundPrimitives] A collection to add ground primitives related to the entities\n */\nfunction GeometryVisualizer(scene, entityCollection, primitives, groundPrimitives) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"scene\", scene);\n  Check.defined(\"entityCollection\", entityCollection);\n  //>>includeEnd('debug');\n\n  primitives = primitives ?? scene.primitives;\n  groundPrimitives = groundPrimitives ?? scene.groundPrimitives;\n  this._scene = scene;\n  this._primitives = primitives;\n  this._groundPrimitives = groundPrimitives;\n  this._entityCollection = undefined;\n  this._addedObjects = new AssociativeArray();\n  this._removedObjects = new AssociativeArray();\n  this._changedObjects = new AssociativeArray();\n  const numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n  this._outlineBatches = new Array(numberOfShadowModes * 2);\n  this._closedColorBatches = new Array(numberOfShadowModes * 2);\n  this._closedMaterialBatches = new Array(numberOfShadowModes * 2);\n  this._openColorBatches = new Array(numberOfShadowModes * 2);\n  this._openMaterialBatches = new Array(numberOfShadowModes * 2);\n  const supportsMaterialsforEntitiesOnTerrain = Entity.supportsMaterialsforEntitiesOnTerrain(scene);\n  this._supportsMaterialsforEntitiesOnTerrain = supportsMaterialsforEntitiesOnTerrain;\n  let i;\n  for (i = 0; i < numberOfShadowModes; ++i) {\n    this._outlineBatches[i] = new StaticOutlineGeometryBatch(primitives, scene, i, false);\n    this._outlineBatches[numberOfShadowModes + i] = new StaticOutlineGeometryBatch(primitives, scene, i, true);\n    this._closedColorBatches[i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, true, i, true);\n    this._closedColorBatches[numberOfShadowModes + i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, true, i, false);\n    this._closedMaterialBatches[i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, true, i, true);\n    this._closedMaterialBatches[numberOfShadowModes + i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, true, i, false);\n    this._openColorBatches[i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, false, i, true);\n    this._openColorBatches[numberOfShadowModes + i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, false, i, false);\n    this._openMaterialBatches[i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, false, i, true);\n    this._openMaterialBatches[numberOfShadowModes + i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, false, i, false);\n  }\n  const numberOfClassificationTypes = ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES;\n  const groundColorBatches = new Array(numberOfClassificationTypes);\n  const groundMaterialBatches = [];\n  if (supportsMaterialsforEntitiesOnTerrain) {\n    for (i = 0; i < numberOfClassificationTypes; ++i) {\n      groundMaterialBatches.push(new StaticGroundGeometryPerMaterialBatch(groundPrimitives, i, MaterialAppearance));\n      groundColorBatches[i] = new StaticGroundGeometryColorBatch(groundPrimitives, i);\n    }\n  } else {\n    for (i = 0; i < numberOfClassificationTypes; ++i) {\n      groundColorBatches[i] = new StaticGroundGeometryColorBatch(groundPrimitives, i);\n    }\n  }\n  this._groundColorBatches = groundColorBatches;\n  this._groundMaterialBatches = groundMaterialBatches;\n  this._dynamicBatch = new DynamicGeometryBatch(primitives, groundPrimitives);\n  this._batches = this._outlineBatches.concat(this._closedColorBatches, this._closedMaterialBatches, this._openColorBatches, this._openMaterialBatches, this._groundColorBatches, this._groundMaterialBatches, this._dynamicBatch);\n  this._subscriptions = new AssociativeArray();\n  this._updaterSets = new AssociativeArray();\n  this._entityCollection = entityCollection;\n  entityCollection.collectionChanged.addEventListener(GeometryVisualizer.prototype._onCollectionChanged, this);\n  this._onCollectionChanged(entityCollection, entityCollection.values, emptyArray);\n}\n\n/**\n * Add the provided updater to the default list of updaters if not already included\n * @private\n * @param {GeometryUpdater} updater\n */\nGeometryVisualizer.registerUpdater = function (updater) {\n  GeometryUpdaterSet.registerUpdater(updater);\n};\n\n/**\n * Remove the provided updater from the default list of updaters if included\n * @private\n * @param {GeometryUpdater} updater\n */\nGeometryVisualizer.unregisterUpdater = function (updater) {\n  GeometryUpdaterSet.unregisterUpdater(updater);\n};\n\n/**\n * Updates all of the primitives created by this visualizer to match their\n * Entity counterpart at the given time.\n *\n * @param {JulianDate} time The time to update to.\n * @returns {boolean} True if the visualizer successfully updated to the provided time,\n * false if the visualizer is waiting for asynchronous primitives to be created.\n */\nGeometryVisualizer.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  const addedObjects = this._addedObjects;\n  const added = addedObjects.values;\n  const removedObjects = this._removedObjects;\n  const removed = removedObjects.values;\n  const changedObjects = this._changedObjects;\n  const changed = changedObjects.values;\n  let i;\n  let entity;\n  let id;\n  let updaterSet;\n  const that = this;\n  for (i = changed.length - 1; i > -1; i--) {\n    entity = changed[i];\n    id = entity.id;\n    updaterSet = this._updaterSets.get(id);\n\n    //If in a single update, an entity gets removed and a new instance\n    //re-added with the same id, the updater no longer tracks the\n    //correct entity, we need to both remove the old one and\n    //add the new one, which is done by pushing the entity\n    //onto the removed/added lists.\n    if (updaterSet.entity === entity) {\n      updaterSet.forEach(function (updater) {\n        that._removeUpdater(updater);\n        that._insertUpdaterIntoBatch(time, updater);\n      });\n    } else {\n      removed.push(entity);\n      added.push(entity);\n    }\n  }\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    id = entity.id;\n    updaterSet = this._updaterSets.get(id);\n    updaterSet.forEach(this._removeUpdater.bind(this));\n    updaterSet.destroy();\n    this._updaterSets.remove(id);\n    this._subscriptions.get(id)();\n    this._subscriptions.remove(id);\n  }\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    id = entity.id;\n    updaterSet = new GeometryUpdaterSet(entity, this._scene);\n    this._updaterSets.set(id, updaterSet);\n    updaterSet.forEach(function (updater) {\n      that._insertUpdaterIntoBatch(time, updater);\n    });\n    this._subscriptions.set(id, updaterSet.geometryChanged.addEventListener(GeometryVisualizer._onGeometryChanged, this));\n  }\n  addedObjects.removeAll();\n  removedObjects.removeAll();\n  changedObjects.removeAll();\n  let isUpdated = true;\n  const batches = this._batches;\n  const length = batches.length;\n  for (i = 0; i < length; i++) {\n    isUpdated = batches[i].update(time) && isUpdated;\n  }\n  return isUpdated;\n};\nconst getBoundingSphereArrayScratch = [];\nconst getBoundingSphereBoundingSphereScratch = new BoundingSphere();\n\n/**\n * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n * The bounding sphere is in the fixed frame of the scene's globe.\n *\n * @param {Entity} entity The entity whose bounding sphere to compute.\n * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n *                       BoundingSphereState.PENDING if the result is still being computed, or\n *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n * @private\n */\nGeometryVisualizer.prototype.getBoundingSphere = function (entity, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"entity\", entity);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  const boundingSpheres = getBoundingSphereArrayScratch;\n  const tmp = getBoundingSphereBoundingSphereScratch;\n  let count = 0;\n  let state = BoundingSphereState.DONE;\n  const batches = this._batches;\n  const batchesLength = batches.length;\n  const id = entity.id;\n  const updaters = this._updaterSets.get(id).updaters;\n  for (let j = 0; j < updaters.length; j++) {\n    const updater = updaters[j];\n    for (let i = 0; i < batchesLength; i++) {\n      state = batches[i].getBoundingSphere(updater, tmp);\n      if (state === BoundingSphereState.PENDING) {\n        return BoundingSphereState.PENDING;\n      } else if (state === BoundingSphereState.DONE) {\n        boundingSpheres[count] = BoundingSphere.clone(tmp, boundingSpheres[count]);\n        count++;\n      }\n    }\n  }\n  if (count === 0) {\n    return BoundingSphereState.FAILED;\n  }\n  boundingSpheres.length = count;\n  BoundingSphere.fromBoundingSpheres(boundingSpheres, result);\n  return BoundingSphereState.DONE;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n */\nGeometryVisualizer.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes and destroys all primitives created by this instance.\n */\nGeometryVisualizer.prototype.destroy = function () {\n  this._entityCollection.collectionChanged.removeEventListener(GeometryVisualizer.prototype._onCollectionChanged, this);\n  this._addedObjects.removeAll();\n  this._removedObjects.removeAll();\n  let i;\n  const batches = this._batches;\n  let length = batches.length;\n  for (i = 0; i < length; i++) {\n    batches[i].removeAllPrimitives();\n  }\n  const subscriptions = this._subscriptions.values;\n  length = subscriptions.length;\n  for (i = 0; i < length; i++) {\n    subscriptions[i]();\n  }\n  this._subscriptions.removeAll();\n  const updaterSets = this._updaterSets.values;\n  length = updaterSets.length;\n  for (i = 0; i < length; i++) {\n    updaterSets[i].destroy();\n  }\n  this._updaterSets.removeAll();\n  return destroyObject(this);\n};\n\n/**\n * @private\n */\nGeometryVisualizer.prototype._removeUpdater = function (updater) {\n  //We don't keep track of which batch an updater is in, so just remove it from all of them.\n  const batches = this._batches;\n  const length = batches.length;\n  for (let i = 0; i < length; i++) {\n    batches[i].remove(updater);\n  }\n};\n\n/**\n * @private\n */\nGeometryVisualizer.prototype._insertUpdaterIntoBatch = function (time, updater) {\n  if (updater.isDynamic) {\n    this._dynamicBatch.add(time, updater);\n    return;\n  }\n  let shadows;\n  if (updater.outlineEnabled || updater.fillEnabled) {\n    shadows = updater.shadowsProperty.getValue(time);\n  }\n  const numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n  if (updater.outlineEnabled) {\n    if (defined(updater.terrainOffsetProperty)) {\n      this._outlineBatches[numberOfShadowModes + shadows].add(time, updater);\n    } else {\n      this._outlineBatches[shadows].add(time, updater);\n    }\n  }\n  if (updater.fillEnabled) {\n    if (updater.onTerrain) {\n      const classificationType = updater.classificationTypeProperty.getValue(time);\n      if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n        this._groundColorBatches[classificationType].add(time, updater);\n      } else {\n        // If unsupported, updater will not be on terrain.\n        this._groundMaterialBatches[classificationType].add(time, updater);\n      }\n    } else if (updater.isClosed) {\n      if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n        if (defined(updater.terrainOffsetProperty)) {\n          this._closedColorBatches[numberOfShadowModes + shadows].add(time, updater);\n        } else {\n          this._closedColorBatches[shadows].add(time, updater);\n        }\n      } else if (defined(updater.terrainOffsetProperty)) {\n        this._closedMaterialBatches[numberOfShadowModes + shadows].add(time, updater);\n      } else {\n        this._closedMaterialBatches[shadows].add(time, updater);\n      }\n    } else if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n      if (defined(updater.terrainOffsetProperty)) {\n        this._openColorBatches[numberOfShadowModes + shadows].add(time, updater);\n      } else {\n        this._openColorBatches[shadows].add(time, updater);\n      }\n    } else if (defined(updater.terrainOffsetProperty)) {\n      this._openMaterialBatches[numberOfShadowModes + shadows].add(time, updater);\n    } else {\n      this._openMaterialBatches[shadows].add(time, updater);\n    }\n  }\n};\n\n/**\n * @private\n */\nGeometryVisualizer._onGeometryChanged = function (updater) {\n  const removedObjects = this._removedObjects;\n  const changedObjects = this._changedObjects;\n  const entity = updater.entity;\n  const id = entity.id;\n  if (!defined(removedObjects.get(id)) && !defined(changedObjects.get(id))) {\n    changedObjects.set(id, entity);\n  }\n};\n\n/**\n * @private\n */\nGeometryVisualizer.prototype._onCollectionChanged = function (entityCollection, added, removed) {\n  const addedObjects = this._addedObjects;\n  const removedObjects = this._removedObjects;\n  const changedObjects = this._changedObjects;\n  let i;\n  let id;\n  let entity;\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    id = entity.id;\n    if (!addedObjects.remove(id)) {\n      removedObjects.set(id, entity);\n      changedObjects.remove(id);\n    }\n  }\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    id = entity.id;\n    if (removedObjects.remove(id)) {\n      changedObjects.set(id, entity);\n    } else {\n      addedObjects.set(id, entity);\n    }\n  }\n};\nexport default GeometryVisualizer;","map":{"version":3,"names":["AssociativeArray","BoundingSphere","Check","defined","destroyObject","ClassificationType","MaterialAppearance","PerInstanceColorAppearance","ShadowMode","BoundingSphereState","ColorMaterialProperty","DynamicGeometryBatch","Entity","GeometryUpdaterSet","StaticGeometryColorBatch","StaticGeometryPerMaterialBatch","StaticGroundGeometryColorBatch","StaticGroundGeometryPerMaterialBatch","StaticOutlineGeometryBatch","emptyArray","GeometryVisualizer","scene","entityCollection","primitives","groundPrimitives","_scene","_primitives","_groundPrimitives","_entityCollection","undefined","_addedObjects","_removedObjects","_changedObjects","numberOfShadowModes","NUMBER_OF_SHADOW_MODES","_outlineBatches","Array","_closedColorBatches","_closedMaterialBatches","_openColorBatches","_openMaterialBatches","supportsMaterialsforEntitiesOnTerrain","_supportsMaterialsforEntitiesOnTerrain","i","numberOfClassificationTypes","NUMBER_OF_CLASSIFICATION_TYPES","groundColorBatches","groundMaterialBatches","push","_groundColorBatches","_groundMaterialBatches","_dynamicBatch","_batches","concat","_subscriptions","_updaterSets","collectionChanged","addEventListener","prototype","_onCollectionChanged","values","registerUpdater","updater","unregisterUpdater","update","time","addedObjects","added","removedObjects","removed","changedObjects","changed","entity","id","updaterSet","that","length","get","forEach","_removeUpdater","_insertUpdaterIntoBatch","bind","destroy","remove","set","geometryChanged","_onGeometryChanged","removeAll","isUpdated","batches","getBoundingSphereArrayScratch","getBoundingSphereBoundingSphereScratch","getBoundingSphere","result","boundingSpheres","tmp","count","state","DONE","batchesLength","updaters","j","PENDING","clone","FAILED","fromBoundingSpheres","isDestroyed","removeEventListener","removeAllPrimitives","subscriptions","updaterSets","isDynamic","add","shadows","outlineEnabled","fillEnabled","shadowsProperty","getValue","terrainOffsetProperty","onTerrain","classificationType","classificationTypeProperty","fillMaterialProperty","isClosed"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/DataSources/GeometryVisualizer.js"],"sourcesContent":["import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ClassificationType from \"../Scene/ClassificationType.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ShadowMode from \"../Scene/ShadowMode.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryBatch from \"./DynamicGeometryBatch.js\";\nimport Entity from \"./Entity.js\";\nimport GeometryUpdaterSet from \"./GeometryUpdaterSet.js\";\nimport StaticGeometryColorBatch from \"./StaticGeometryColorBatch.js\";\nimport StaticGeometryPerMaterialBatch from \"./StaticGeometryPerMaterialBatch.js\";\nimport StaticGroundGeometryColorBatch from \"./StaticGroundGeometryColorBatch.js\";\nimport StaticGroundGeometryPerMaterialBatch from \"./StaticGroundGeometryPerMaterialBatch.js\";\nimport StaticOutlineGeometryBatch from \"./StaticOutlineGeometryBatch.js\";\n\nconst emptyArray = [];\n\n/**\n * A general purpose visualizer for geometry represented by {@link Primitive} instances.\n * @alias GeometryVisualizer\n * @constructor\n *\n * @param {Scene} scene The scene the primitives will be rendered in.\n * @param {EntityCollection} entityCollection The entityCollection to visualize.\n * @param {PrimitiveCollection} [primitives=scene.primitives] A collection to add primitives related to the entities\n * @param {PrimitiveCollection} [groundPrimitives=scene.groundPrimitives] A collection to add ground primitives related to the entities\n */\nfunction GeometryVisualizer(\n  scene,\n  entityCollection,\n  primitives,\n  groundPrimitives,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"scene\", scene);\n  Check.defined(\"entityCollection\", entityCollection);\n  //>>includeEnd('debug');\n\n  primitives = primitives ?? scene.primitives;\n  groundPrimitives = groundPrimitives ?? scene.groundPrimitives;\n\n  this._scene = scene;\n  this._primitives = primitives;\n  this._groundPrimitives = groundPrimitives;\n  this._entityCollection = undefined;\n  this._addedObjects = new AssociativeArray();\n  this._removedObjects = new AssociativeArray();\n  this._changedObjects = new AssociativeArray();\n\n  const numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n  this._outlineBatches = new Array(numberOfShadowModes * 2);\n  this._closedColorBatches = new Array(numberOfShadowModes * 2);\n  this._closedMaterialBatches = new Array(numberOfShadowModes * 2);\n  this._openColorBatches = new Array(numberOfShadowModes * 2);\n  this._openMaterialBatches = new Array(numberOfShadowModes * 2);\n\n  const supportsMaterialsforEntitiesOnTerrain =\n    Entity.supportsMaterialsforEntitiesOnTerrain(scene);\n  this._supportsMaterialsforEntitiesOnTerrain =\n    supportsMaterialsforEntitiesOnTerrain;\n\n  let i;\n  for (i = 0; i < numberOfShadowModes; ++i) {\n    this._outlineBatches[i] = new StaticOutlineGeometryBatch(\n      primitives,\n      scene,\n      i,\n      false,\n    );\n    this._outlineBatches[numberOfShadowModes + i] =\n      new StaticOutlineGeometryBatch(primitives, scene, i, true);\n\n    this._closedColorBatches[i] = new StaticGeometryColorBatch(\n      primitives,\n      PerInstanceColorAppearance,\n      undefined,\n      true,\n      i,\n      true,\n    );\n    this._closedColorBatches[numberOfShadowModes + i] =\n      new StaticGeometryColorBatch(\n        primitives,\n        PerInstanceColorAppearance,\n        undefined,\n        true,\n        i,\n        false,\n      );\n\n    this._closedMaterialBatches[i] = new StaticGeometryPerMaterialBatch(\n      primitives,\n      MaterialAppearance,\n      undefined,\n      true,\n      i,\n      true,\n    );\n    this._closedMaterialBatches[numberOfShadowModes + i] =\n      new StaticGeometryPerMaterialBatch(\n        primitives,\n        MaterialAppearance,\n        undefined,\n        true,\n        i,\n        false,\n      );\n\n    this._openColorBatches[i] = new StaticGeometryColorBatch(\n      primitives,\n      PerInstanceColorAppearance,\n      undefined,\n      false,\n      i,\n      true,\n    );\n    this._openColorBatches[numberOfShadowModes + i] =\n      new StaticGeometryColorBatch(\n        primitives,\n        PerInstanceColorAppearance,\n        undefined,\n        false,\n        i,\n        false,\n      );\n\n    this._openMaterialBatches[i] = new StaticGeometryPerMaterialBatch(\n      primitives,\n      MaterialAppearance,\n      undefined,\n      false,\n      i,\n      true,\n    );\n    this._openMaterialBatches[numberOfShadowModes + i] =\n      new StaticGeometryPerMaterialBatch(\n        primitives,\n        MaterialAppearance,\n        undefined,\n        false,\n        i,\n        false,\n      );\n  }\n\n  const numberOfClassificationTypes =\n    ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES;\n  const groundColorBatches = new Array(numberOfClassificationTypes);\n  const groundMaterialBatches = [];\n  if (supportsMaterialsforEntitiesOnTerrain) {\n    for (i = 0; i < numberOfClassificationTypes; ++i) {\n      groundMaterialBatches.push(\n        new StaticGroundGeometryPerMaterialBatch(\n          groundPrimitives,\n          i,\n          MaterialAppearance,\n        ),\n      );\n      groundColorBatches[i] = new StaticGroundGeometryColorBatch(\n        groundPrimitives,\n        i,\n      );\n    }\n  } else {\n    for (i = 0; i < numberOfClassificationTypes; ++i) {\n      groundColorBatches[i] = new StaticGroundGeometryColorBatch(\n        groundPrimitives,\n        i,\n      );\n    }\n  }\n\n  this._groundColorBatches = groundColorBatches;\n  this._groundMaterialBatches = groundMaterialBatches;\n\n  this._dynamicBatch = new DynamicGeometryBatch(primitives, groundPrimitives);\n\n  this._batches = this._outlineBatches.concat(\n    this._closedColorBatches,\n    this._closedMaterialBatches,\n    this._openColorBatches,\n    this._openMaterialBatches,\n    this._groundColorBatches,\n    this._groundMaterialBatches,\n    this._dynamicBatch,\n  );\n\n  this._subscriptions = new AssociativeArray();\n  this._updaterSets = new AssociativeArray();\n\n  this._entityCollection = entityCollection;\n  entityCollection.collectionChanged.addEventListener(\n    GeometryVisualizer.prototype._onCollectionChanged,\n    this,\n  );\n  this._onCollectionChanged(\n    entityCollection,\n    entityCollection.values,\n    emptyArray,\n  );\n}\n\n/**\n * Add the provided updater to the default list of updaters if not already included\n * @private\n * @param {GeometryUpdater} updater\n */\nGeometryVisualizer.registerUpdater = function (updater) {\n  GeometryUpdaterSet.registerUpdater(updater);\n};\n\n/**\n * Remove the provided updater from the default list of updaters if included\n * @private\n * @param {GeometryUpdater} updater\n */\nGeometryVisualizer.unregisterUpdater = function (updater) {\n  GeometryUpdaterSet.unregisterUpdater(updater);\n};\n\n/**\n * Updates all of the primitives created by this visualizer to match their\n * Entity counterpart at the given time.\n *\n * @param {JulianDate} time The time to update to.\n * @returns {boolean} True if the visualizer successfully updated to the provided time,\n * false if the visualizer is waiting for asynchronous primitives to be created.\n */\nGeometryVisualizer.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  const addedObjects = this._addedObjects;\n  const added = addedObjects.values;\n  const removedObjects = this._removedObjects;\n  const removed = removedObjects.values;\n  const changedObjects = this._changedObjects;\n  const changed = changedObjects.values;\n\n  let i;\n  let entity;\n  let id;\n  let updaterSet;\n  const that = this;\n\n  for (i = changed.length - 1; i > -1; i--) {\n    entity = changed[i];\n    id = entity.id;\n    updaterSet = this._updaterSets.get(id);\n\n    //If in a single update, an entity gets removed and a new instance\n    //re-added with the same id, the updater no longer tracks the\n    //correct entity, we need to both remove the old one and\n    //add the new one, which is done by pushing the entity\n    //onto the removed/added lists.\n    if (updaterSet.entity === entity) {\n      updaterSet.forEach(function (updater) {\n        that._removeUpdater(updater);\n        that._insertUpdaterIntoBatch(time, updater);\n      });\n    } else {\n      removed.push(entity);\n      added.push(entity);\n    }\n  }\n\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    id = entity.id;\n    updaterSet = this._updaterSets.get(id);\n    updaterSet.forEach(this._removeUpdater.bind(this));\n    updaterSet.destroy();\n    this._updaterSets.remove(id);\n    this._subscriptions.get(id)();\n    this._subscriptions.remove(id);\n  }\n\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    id = entity.id;\n    updaterSet = new GeometryUpdaterSet(entity, this._scene);\n    this._updaterSets.set(id, updaterSet);\n    updaterSet.forEach(function (updater) {\n      that._insertUpdaterIntoBatch(time, updater);\n    });\n    this._subscriptions.set(\n      id,\n      updaterSet.geometryChanged.addEventListener(\n        GeometryVisualizer._onGeometryChanged,\n        this,\n      ),\n    );\n  }\n\n  addedObjects.removeAll();\n  removedObjects.removeAll();\n  changedObjects.removeAll();\n\n  let isUpdated = true;\n  const batches = this._batches;\n  const length = batches.length;\n  for (i = 0; i < length; i++) {\n    isUpdated = batches[i].update(time) && isUpdated;\n  }\n\n  return isUpdated;\n};\n\nconst getBoundingSphereArrayScratch = [];\nconst getBoundingSphereBoundingSphereScratch = new BoundingSphere();\n\n/**\n * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n * The bounding sphere is in the fixed frame of the scene's globe.\n *\n * @param {Entity} entity The entity whose bounding sphere to compute.\n * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n *                       BoundingSphereState.PENDING if the result is still being computed, or\n *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n * @private\n */\nGeometryVisualizer.prototype.getBoundingSphere = function (entity, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"entity\", entity);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  const boundingSpheres = getBoundingSphereArrayScratch;\n  const tmp = getBoundingSphereBoundingSphereScratch;\n\n  let count = 0;\n  let state = BoundingSphereState.DONE;\n  const batches = this._batches;\n  const batchesLength = batches.length;\n\n  const id = entity.id;\n  const updaters = this._updaterSets.get(id).updaters;\n\n  for (let j = 0; j < updaters.length; j++) {\n    const updater = updaters[j];\n    for (let i = 0; i < batchesLength; i++) {\n      state = batches[i].getBoundingSphere(updater, tmp);\n      if (state === BoundingSphereState.PENDING) {\n        return BoundingSphereState.PENDING;\n      } else if (state === BoundingSphereState.DONE) {\n        boundingSpheres[count] = BoundingSphere.clone(\n          tmp,\n          boundingSpheres[count],\n        );\n        count++;\n      }\n    }\n  }\n\n  if (count === 0) {\n    return BoundingSphereState.FAILED;\n  }\n\n  boundingSpheres.length = count;\n  BoundingSphere.fromBoundingSpheres(boundingSpheres, result);\n  return BoundingSphereState.DONE;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n */\nGeometryVisualizer.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes and destroys all primitives created by this instance.\n */\nGeometryVisualizer.prototype.destroy = function () {\n  this._entityCollection.collectionChanged.removeEventListener(\n    GeometryVisualizer.prototype._onCollectionChanged,\n    this,\n  );\n  this._addedObjects.removeAll();\n  this._removedObjects.removeAll();\n\n  let i;\n  const batches = this._batches;\n  let length = batches.length;\n  for (i = 0; i < length; i++) {\n    batches[i].removeAllPrimitives();\n  }\n\n  const subscriptions = this._subscriptions.values;\n  length = subscriptions.length;\n  for (i = 0; i < length; i++) {\n    subscriptions[i]();\n  }\n  this._subscriptions.removeAll();\n\n  const updaterSets = this._updaterSets.values;\n  length = updaterSets.length;\n  for (i = 0; i < length; i++) {\n    updaterSets[i].destroy();\n  }\n  this._updaterSets.removeAll();\n  return destroyObject(this);\n};\n\n/**\n * @private\n */\nGeometryVisualizer.prototype._removeUpdater = function (updater) {\n  //We don't keep track of which batch an updater is in, so just remove it from all of them.\n  const batches = this._batches;\n  const length = batches.length;\n  for (let i = 0; i < length; i++) {\n    batches[i].remove(updater);\n  }\n};\n\n/**\n * @private\n */\nGeometryVisualizer.prototype._insertUpdaterIntoBatch = function (\n  time,\n  updater,\n) {\n  if (updater.isDynamic) {\n    this._dynamicBatch.add(time, updater);\n    return;\n  }\n\n  let shadows;\n  if (updater.outlineEnabled || updater.fillEnabled) {\n    shadows = updater.shadowsProperty.getValue(time);\n  }\n\n  const numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n  if (updater.outlineEnabled) {\n    if (defined(updater.terrainOffsetProperty)) {\n      this._outlineBatches[numberOfShadowModes + shadows].add(time, updater);\n    } else {\n      this._outlineBatches[shadows].add(time, updater);\n    }\n  }\n\n  if (updater.fillEnabled) {\n    if (updater.onTerrain) {\n      const classificationType =\n        updater.classificationTypeProperty.getValue(time);\n      if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n        this._groundColorBatches[classificationType].add(time, updater);\n      } else {\n        // If unsupported, updater will not be on terrain.\n        this._groundMaterialBatches[classificationType].add(time, updater);\n      }\n    } else if (updater.isClosed) {\n      if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n        if (defined(updater.terrainOffsetProperty)) {\n          this._closedColorBatches[numberOfShadowModes + shadows].add(\n            time,\n            updater,\n          );\n        } else {\n          this._closedColorBatches[shadows].add(time, updater);\n        }\n      } else if (defined(updater.terrainOffsetProperty)) {\n        this._closedMaterialBatches[numberOfShadowModes + shadows].add(\n          time,\n          updater,\n        );\n      } else {\n        this._closedMaterialBatches[shadows].add(time, updater);\n      }\n    } else if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n      if (defined(updater.terrainOffsetProperty)) {\n        this._openColorBatches[numberOfShadowModes + shadows].add(\n          time,\n          updater,\n        );\n      } else {\n        this._openColorBatches[shadows].add(time, updater);\n      }\n    } else if (defined(updater.terrainOffsetProperty)) {\n      this._openMaterialBatches[numberOfShadowModes + shadows].add(\n        time,\n        updater,\n      );\n    } else {\n      this._openMaterialBatches[shadows].add(time, updater);\n    }\n  }\n};\n\n/**\n * @private\n */\nGeometryVisualizer._onGeometryChanged = function (updater) {\n  const removedObjects = this._removedObjects;\n  const changedObjects = this._changedObjects;\n\n  const entity = updater.entity;\n  const id = entity.id;\n\n  if (!defined(removedObjects.get(id)) && !defined(changedObjects.get(id))) {\n    changedObjects.set(id, entity);\n  }\n};\n\n/**\n * @private\n */\nGeometryVisualizer.prototype._onCollectionChanged = function (\n  entityCollection,\n  added,\n  removed,\n) {\n  const addedObjects = this._addedObjects;\n  const removedObjects = this._removedObjects;\n  const changedObjects = this._changedObjects;\n\n  let i;\n  let id;\n  let entity;\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    id = entity.id;\n    if (!addedObjects.remove(id)) {\n      removedObjects.set(id, entity);\n      changedObjects.remove(id);\n    }\n  }\n\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    id = entity.id;\n    if (removedObjects.remove(id)) {\n      changedObjects.set(id, entity);\n    } else {\n      addedObjects.set(id, entity);\n    }\n  }\n};\nexport default GeometryVisualizer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}