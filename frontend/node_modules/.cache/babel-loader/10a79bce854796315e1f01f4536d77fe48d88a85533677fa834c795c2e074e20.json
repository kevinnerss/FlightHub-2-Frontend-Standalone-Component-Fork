{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport AxisAlignedBoundingBox from \"./AxisAlignedBoundingBox.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidalOccluder from \"./EllipsoidalOccluder.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport Transforms from \"./Transforms.js\";\nimport WebMercatorProjection from \"./WebMercatorProjection.js\";\n\n/**\n * Contains functions to create a mesh from a heightmap image.\n *\n * @namespace HeightmapTessellator\n *\n * @private\n */\nconst HeightmapTessellator = {};\n\n/**\n * The default structure of a heightmap, as given to {@link HeightmapTessellator.computeVertices}.\n *\n * @constant\n */\nHeightmapTessellator.DEFAULT_STRUCTURE = Object.freeze({\n  heightScale: 1.0,\n  heightOffset: 0.0,\n  elementsPerHeight: 1,\n  stride: 1,\n  elementMultiplier: 256.0,\n  isBigEndian: false\n});\nconst cartesian3Scratch = new Cartesian3();\nconst matrix4Scratch = new Matrix4();\nconst minimumScratch = new Cartesian3();\nconst maximumScratch = new Cartesian3();\n\n/**\n * Fills an array of vertices from a heightmap image.\n *\n * @param {object} options Object with the following properties:\n * @param {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} options.heightmap The heightmap to tessellate.\n * @param {number} options.width The width of the heightmap, in height samples.\n * @param {number} options.height The height of the heightmap, in height samples.\n * @param {number} options.skirtHeight The height of skirts to drape at the edges of the heightmap.\n * @param {Rectangle} options.nativeRectangle A rectangle in the native coordinates of the heightmap's projection.  For\n *                 a heightmap with a geographic projection, this is degrees.  For the web mercator\n *                 projection, this is meters.\n * @param {number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {number} [options.exaggerationRelativeHeight=0.0] The height from which terrain is exaggerated.\n * @param {Rectangle} [options.rectangle] The rectangle covered by the heightmap, in geodetic coordinates with north, south, east and\n *                 west properties in radians.  Either rectangle or nativeRectangle must be provided.  If both\n *                 are provided, they're assumed to be consistent.\n * @param {boolean} [options.isGeographic=true] True if the heightmap uses a {@link GeographicProjection}, or false if it uses\n *                  a {@link WebMercatorProjection}.\n * @param {Cartesian3} [options.relativeToCenter=Cartesian3.ZERO] The positions will be computed as <code>Cartesian3.subtract(worldPosition, relativeToCenter)</code>.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to which the heightmap applies.\n * @param {object} [options.structure] An object describing the structure of the height data.\n * @param {number} [options.structure.heightScale=1.0] The factor by which to multiply height samples in order to obtain\n *                 the height above the heightOffset, in meters.  The heightOffset is added to the resulting\n *                 height after multiplying by the scale.\n * @param {number} [options.structure.heightOffset=0.0] The offset to add to the scaled height to obtain the final\n *                 height in meters.  The offset is added after the height sample is multiplied by the\n *                 heightScale.\n * @param {number} [options.structure.elementsPerHeight=1] The number of elements in the buffer that make up a single height\n *                 sample.  This is usually 1, indicating that each element is a separate height sample.  If\n *                 it is greater than 1, that number of elements together form the height sample, which is\n *                 computed according to the structure.elementMultiplier and structure.isBigEndian properties.\n * @param {number} [options.structure.stride=1] The number of elements to skip to get from the first element of\n *                 one height to the first element of the next height.\n * @param {number} [options.structure.elementMultiplier=256.0] The multiplier used to compute the height value when the\n *                 stride property is greater than 1.  For example, if the stride is 4 and the strideMultiplier\n *                 is 256, the height is computed as follows:\n *                 `height = buffer[index] + buffer[index + 1] * 256 + buffer[index + 2] * 256 * 256 + buffer[index + 3] * 256 * 256 * 256`\n *                 This is assuming that the isBigEndian property is false.  If it is true, the order of the\n *                 elements is reversed.\n * @param {number} [options.structure.lowestEncodedHeight] The lowest value that can be stored in the height buffer.  Any heights that are lower\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be 0 because a `Uint16Array` cannot store negative numbers.  If this parameter is\n *                 not specified, no minimum value is enforced.\n * @param {number} [options.structure.highestEncodedHeight] The highest value that can be stored in the height buffer.  Any heights that are higher\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be `256 * 256 - 1` or 65535 because a `Uint16Array` cannot store numbers larger\n *                 than 65535.  If this parameter is not specified, no maximum value is enforced.\n * @param {boolean} [options.structure.isBigEndian=false] Indicates endianness of the elements in the buffer when the\n *                  stride property is greater than 1.  If this property is false, the first element is the\n *                  low-order element.  If it is true, the first element is the high-order element.\n *\n * @example\n * const width = 5;\n * const height = 5;\n * const statistics = Cesium.HeightmapTessellator.computeVertices({\n *     heightmap : [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0],\n *     width : width,\n *     height : height,\n *     skirtHeight : 0.0,\n *     nativeRectangle : {\n *         west : 10.0,\n *         east : 20.0,\n *         south : 30.0,\n *         north : 40.0\n *     }\n * });\n *\n * const encoding = statistics.encoding;\n * const position = encoding.decodePosition(statistics.vertices, index);\n */\nHeightmapTessellator.computeVertices = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.heightmap)) {\n    throw new DeveloperError(\"options.heightmap is required.\");\n  }\n  if (!defined(options.width) || !defined(options.height)) {\n    throw new DeveloperError(\"options.width and options.height are required.\");\n  }\n  if (!defined(options.nativeRectangle)) {\n    throw new DeveloperError(\"options.nativeRectangle is required.\");\n  }\n  if (!defined(options.skirtHeight)) {\n    throw new DeveloperError(\"options.skirtHeight is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // This function tends to be a performance hotspot for terrain rendering,\n  // so it employs a lot of inlining and unrolling as an optimization.\n  // In particular, the functionality of Ellipsoid.cartographicToCartesian\n  // is inlined.\n\n  const cos = Math.cos;\n  const sin = Math.sin;\n  const sqrt = Math.sqrt;\n  const atan = Math.atan;\n  const exp = Math.exp;\n  const piOverTwo = CesiumMath.PI_OVER_TWO;\n  const toRadians = CesiumMath.toRadians;\n  const heightmap = options.heightmap;\n  const width = options.width;\n  const height = options.height;\n  const skirtHeight = options.skirtHeight;\n  const hasSkirts = skirtHeight > 0.0;\n  const isGeographic = options.isGeographic ?? true;\n  const ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n  const oneOverGlobeSemimajorAxis = 1.0 / ellipsoid.maximumRadius;\n  const nativeRectangle = Rectangle.clone(options.nativeRectangle);\n  const rectangle = Rectangle.clone(options.rectangle);\n  let geographicWest;\n  let geographicSouth;\n  let geographicEast;\n  let geographicNorth;\n  if (!defined(rectangle)) {\n    if (isGeographic) {\n      geographicWest = toRadians(nativeRectangle.west);\n      geographicSouth = toRadians(nativeRectangle.south);\n      geographicEast = toRadians(nativeRectangle.east);\n      geographicNorth = toRadians(nativeRectangle.north);\n    } else {\n      geographicWest = nativeRectangle.west * oneOverGlobeSemimajorAxis;\n      geographicSouth = piOverTwo - 2.0 * atan(exp(-nativeRectangle.south * oneOverGlobeSemimajorAxis));\n      geographicEast = nativeRectangle.east * oneOverGlobeSemimajorAxis;\n      geographicNorth = piOverTwo - 2.0 * atan(exp(-nativeRectangle.north * oneOverGlobeSemimajorAxis));\n    }\n  } else {\n    geographicWest = rectangle.west;\n    geographicSouth = rectangle.south;\n    geographicEast = rectangle.east;\n    geographicNorth = rectangle.north;\n  }\n  let relativeToCenter = options.relativeToCenter;\n  const hasRelativeToCenter = defined(relativeToCenter);\n  relativeToCenter = hasRelativeToCenter ? relativeToCenter : Cartesian3.ZERO;\n  const includeWebMercatorT = options.includeWebMercatorT ?? false;\n  const exaggeration = options.exaggeration ?? 1.0;\n  const exaggerationRelativeHeight = options.exaggerationRelativeHeight ?? 0.0;\n  const hasExaggeration = exaggeration !== 1.0;\n  const includeGeodeticSurfaceNormals = hasExaggeration;\n  const structure = options.structure ?? HeightmapTessellator.DEFAULT_STRUCTURE;\n  const heightScale = structure.heightScale ?? HeightmapTessellator.DEFAULT_STRUCTURE.heightScale;\n  const heightOffset = structure.heightOffset ?? HeightmapTessellator.DEFAULT_STRUCTURE.heightOffset;\n  const elementsPerHeight = structure.elementsPerHeight ?? HeightmapTessellator.DEFAULT_STRUCTURE.elementsPerHeight;\n  const stride = structure.stride ?? HeightmapTessellator.DEFAULT_STRUCTURE.stride;\n  const elementMultiplier = structure.elementMultiplier ?? HeightmapTessellator.DEFAULT_STRUCTURE.elementMultiplier;\n  const isBigEndian = structure.isBigEndian ?? HeightmapTessellator.DEFAULT_STRUCTURE.isBigEndian;\n  let rectangleWidth = Rectangle.computeWidth(nativeRectangle);\n  let rectangleHeight = Rectangle.computeHeight(nativeRectangle);\n  const granularityX = rectangleWidth / (width - 1);\n  const granularityY = rectangleHeight / (height - 1);\n  if (!isGeographic) {\n    rectangleWidth *= oneOverGlobeSemimajorAxis;\n    rectangleHeight *= oneOverGlobeSemimajorAxis;\n  }\n  const radiiSquared = ellipsoid.radiiSquared;\n  const radiiSquaredX = radiiSquared.x;\n  const radiiSquaredY = radiiSquared.y;\n  const radiiSquaredZ = radiiSquared.z;\n  let minimumHeight = 65536.0;\n  let maximumHeight = -65536.0;\n  const fromENU = Transforms.eastNorthUpToFixedFrame(relativeToCenter, ellipsoid);\n  const toENU = Matrix4.inverseTransformation(fromENU, matrix4Scratch);\n  let southMercatorY;\n  let oneOverMercatorHeight;\n  if (includeWebMercatorT) {\n    southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(geographicSouth);\n    oneOverMercatorHeight = 1.0 / (WebMercatorProjection.geodeticLatitudeToMercatorAngle(geographicNorth) - southMercatorY);\n  }\n  const minimum = minimumScratch;\n  minimum.x = Number.POSITIVE_INFINITY;\n  minimum.y = Number.POSITIVE_INFINITY;\n  minimum.z = Number.POSITIVE_INFINITY;\n  const maximum = maximumScratch;\n  maximum.x = Number.NEGATIVE_INFINITY;\n  maximum.y = Number.NEGATIVE_INFINITY;\n  maximum.z = Number.NEGATIVE_INFINITY;\n  let hMin = Number.POSITIVE_INFINITY;\n  const gridVertexCount = width * height;\n  const edgeVertexCount = skirtHeight > 0.0 ? width * 2 + height * 2 : 0;\n  const vertexCount = gridVertexCount + edgeVertexCount;\n  const positions = new Array(vertexCount);\n  const heights = new Array(vertexCount);\n  const uvs = new Array(vertexCount);\n  const webMercatorTs = includeWebMercatorT ? new Array(vertexCount) : [];\n  const geodeticSurfaceNormals = includeGeodeticSurfaceNormals ? new Array(vertexCount) : [];\n  let startRow = 0;\n  let endRow = height;\n  let startCol = 0;\n  let endCol = width;\n  if (hasSkirts) {\n    --startRow;\n    ++endRow;\n    --startCol;\n    ++endCol;\n  }\n  const skirtOffsetPercentage = 0.00001;\n  for (let rowIndex = startRow; rowIndex < endRow; ++rowIndex) {\n    let row = rowIndex;\n    if (row < 0) {\n      row = 0;\n    }\n    if (row >= height) {\n      row = height - 1;\n    }\n    let latitude = nativeRectangle.north - granularityY * row;\n    if (!isGeographic) {\n      latitude = piOverTwo - 2.0 * atan(exp(-latitude * oneOverGlobeSemimajorAxis));\n    } else {\n      latitude = toRadians(latitude);\n    }\n    let v = (latitude - geographicSouth) / (geographicNorth - geographicSouth);\n    v = CesiumMath.clamp(v, 0.0, 1.0);\n    const isNorthEdge = rowIndex === startRow;\n    const isSouthEdge = rowIndex === endRow - 1;\n    if (skirtHeight > 0.0) {\n      if (isNorthEdge) {\n        latitude += skirtOffsetPercentage * rectangleHeight;\n      } else if (isSouthEdge) {\n        latitude -= skirtOffsetPercentage * rectangleHeight;\n      }\n    }\n    const cosLatitude = cos(latitude);\n    const nZ = sin(latitude);\n    const kZ = radiiSquaredZ * nZ;\n    let webMercatorT;\n    if (includeWebMercatorT) {\n      webMercatorT = (WebMercatorProjection.geodeticLatitudeToMercatorAngle(latitude) - southMercatorY) * oneOverMercatorHeight;\n    }\n    for (let colIndex = startCol; colIndex < endCol; ++colIndex) {\n      let col = colIndex;\n      if (col < 0) {\n        col = 0;\n      }\n      if (col >= width) {\n        col = width - 1;\n      }\n      const terrainOffset = row * (width * stride) + col * stride;\n      let heightSample;\n      if (elementsPerHeight === 1) {\n        heightSample = heightmap[terrainOffset];\n      } else {\n        heightSample = 0;\n        let elementOffset;\n        if (isBigEndian) {\n          for (elementOffset = 0; elementOffset < elementsPerHeight; ++elementOffset) {\n            heightSample = heightSample * elementMultiplier + heightmap[terrainOffset + elementOffset];\n          }\n        } else {\n          for (elementOffset = elementsPerHeight - 1; elementOffset >= 0; --elementOffset) {\n            heightSample = heightSample * elementMultiplier + heightmap[terrainOffset + elementOffset];\n          }\n        }\n      }\n      heightSample = heightSample * heightScale + heightOffset;\n      maximumHeight = Math.max(maximumHeight, heightSample);\n      minimumHeight = Math.min(minimumHeight, heightSample);\n      let longitude = nativeRectangle.west + granularityX * col;\n      if (!isGeographic) {\n        longitude = longitude * oneOverGlobeSemimajorAxis;\n      } else {\n        longitude = toRadians(longitude);\n      }\n      let u = (longitude - geographicWest) / (geographicEast - geographicWest);\n      u = CesiumMath.clamp(u, 0.0, 1.0);\n      let index = row * width + col;\n      if (skirtHeight > 0.0) {\n        const isWestEdge = colIndex === startCol;\n        const isEastEdge = colIndex === endCol - 1;\n        const isEdge = isNorthEdge || isSouthEdge || isWestEdge || isEastEdge;\n        const isCorner = (isNorthEdge || isSouthEdge) && (isWestEdge || isEastEdge);\n        if (isCorner) {\n          // Don't generate skirts on the corners.\n          continue;\n        } else if (isEdge) {\n          heightSample -= skirtHeight;\n          if (isWestEdge) {\n            // The outer loop iterates north to south but the indices are ordered south to north, hence the index flip below\n            index = gridVertexCount + (height - row - 1);\n            longitude -= skirtOffsetPercentage * rectangleWidth;\n          } else if (isSouthEdge) {\n            // Add after west indices. South indices are ordered east to west.\n            index = gridVertexCount + height + (width - col - 1);\n          } else if (isEastEdge) {\n            // Add after west and south indices. East indices are ordered north to south. The index is flipped like above.\n            index = gridVertexCount + height + width + row;\n            longitude += skirtOffsetPercentage * rectangleWidth;\n          } else if (isNorthEdge) {\n            // Add after west, south, and east indices. North indices are ordered west to east.\n            index = gridVertexCount + height + width + height + col;\n          }\n        }\n      }\n      const nX = cosLatitude * cos(longitude);\n      const nY = cosLatitude * sin(longitude);\n      const kX = radiiSquaredX * nX;\n      const kY = radiiSquaredY * nY;\n      const gamma = sqrt(kX * nX + kY * nY + kZ * nZ);\n      const oneOverGamma = 1.0 / gamma;\n      const rSurfaceX = kX * oneOverGamma;\n      const rSurfaceY = kY * oneOverGamma;\n      const rSurfaceZ = kZ * oneOverGamma;\n      const position = new Cartesian3();\n      position.x = rSurfaceX + nX * heightSample;\n      position.y = rSurfaceY + nY * heightSample;\n      position.z = rSurfaceZ + nZ * heightSample;\n      Matrix4.multiplyByPoint(toENU, position, cartesian3Scratch);\n      Cartesian3.minimumByComponent(cartesian3Scratch, minimum, minimum);\n      Cartesian3.maximumByComponent(cartesian3Scratch, maximum, maximum);\n      hMin = Math.min(hMin, heightSample);\n      positions[index] = position;\n      uvs[index] = new Cartesian2(u, v);\n      heights[index] = heightSample;\n      if (includeWebMercatorT) {\n        webMercatorTs[index] = webMercatorT;\n      }\n      if (includeGeodeticSurfaceNormals) {\n        geodeticSurfaceNormals[index] = ellipsoid.geodeticSurfaceNormal(position);\n      }\n    }\n  }\n  const boundingSphere3D = BoundingSphere.fromPoints(positions);\n  let orientedBoundingBox;\n  if (defined(rectangle)) {\n    orientedBoundingBox = OrientedBoundingBox.fromRectangle(rectangle, minimumHeight, maximumHeight, ellipsoid);\n  }\n  let occludeePointInScaledSpace;\n  if (hasRelativeToCenter) {\n    const occluder = new EllipsoidalOccluder(ellipsoid);\n    occludeePointInScaledSpace = occluder.computeHorizonCullingPointPossiblyUnderEllipsoid(relativeToCenter, positions, minimumHeight);\n  }\n  const aaBox = new AxisAlignedBoundingBox(minimum, maximum, relativeToCenter);\n  const encoding = new TerrainEncoding(relativeToCenter, aaBox, hMin, maximumHeight, fromENU, false, includeWebMercatorT, includeGeodeticSurfaceNormals, exaggeration, exaggerationRelativeHeight);\n  const vertices = new Float32Array(vertexCount * encoding.stride);\n  let bufferIndex = 0;\n  for (let j = 0; j < vertexCount; ++j) {\n    bufferIndex = encoding.encode(vertices, bufferIndex, positions[j], uvs[j], heights[j], undefined, webMercatorTs[j], geodeticSurfaceNormals[j]);\n  }\n  return {\n    vertices: vertices,\n    maximumHeight: maximumHeight,\n    minimumHeight: minimumHeight,\n    encoding: encoding,\n    boundingSphere3D: boundingSphere3D,\n    orientedBoundingBox: orientedBoundingBox,\n    occludeePointInScaledSpace: occludeePointInScaledSpace\n  };\n};\nexport default HeightmapTessellator;","map":{"version":3,"names":["AxisAlignedBoundingBox","BoundingSphere","Cartesian2","Cartesian3","defined","DeveloperError","Ellipsoid","EllipsoidalOccluder","CesiumMath","Matrix4","OrientedBoundingBox","Rectangle","TerrainEncoding","Transforms","WebMercatorProjection","HeightmapTessellator","DEFAULT_STRUCTURE","Object","freeze","heightScale","heightOffset","elementsPerHeight","stride","elementMultiplier","isBigEndian","cartesian3Scratch","matrix4Scratch","minimumScratch","maximumScratch","computeVertices","options","heightmap","width","height","nativeRectangle","skirtHeight","cos","Math","sin","sqrt","atan","exp","piOverTwo","PI_OVER_TWO","toRadians","hasSkirts","isGeographic","ellipsoid","default","oneOverGlobeSemimajorAxis","maximumRadius","clone","rectangle","geographicWest","geographicSouth","geographicEast","geographicNorth","west","south","east","north","relativeToCenter","hasRelativeToCenter","ZERO","includeWebMercatorT","exaggeration","exaggerationRelativeHeight","hasExaggeration","includeGeodeticSurfaceNormals","structure","rectangleWidth","computeWidth","rectangleHeight","computeHeight","granularityX","granularityY","radiiSquared","radiiSquaredX","x","radiiSquaredY","y","radiiSquaredZ","z","minimumHeight","maximumHeight","fromENU","eastNorthUpToFixedFrame","toENU","inverseTransformation","southMercatorY","oneOverMercatorHeight","geodeticLatitudeToMercatorAngle","minimum","Number","POSITIVE_INFINITY","maximum","NEGATIVE_INFINITY","hMin","gridVertexCount","edgeVertexCount","vertexCount","positions","Array","heights","uvs","webMercatorTs","geodeticSurfaceNormals","startRow","endRow","startCol","endCol","skirtOffsetPercentage","rowIndex","row","latitude","v","clamp","isNorthEdge","isSouthEdge","cosLatitude","nZ","kZ","webMercatorT","colIndex","col","terrainOffset","heightSample","elementOffset","max","min","longitude","u","index","isWestEdge","isEastEdge","isEdge","isCorner","nX","nY","kX","kY","gamma","oneOverGamma","rSurfaceX","rSurfaceY","rSurfaceZ","position","multiplyByPoint","minimumByComponent","maximumByComponent","geodeticSurfaceNormal","boundingSphere3D","fromPoints","orientedBoundingBox","fromRectangle","occludeePointInScaledSpace","occluder","computeHorizonCullingPointPossiblyUnderEllipsoid","aaBox","encoding","vertices","Float32Array","bufferIndex","j","encode","undefined"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/HeightmapTessellator.js"],"sourcesContent":["import AxisAlignedBoundingBox from \"./AxisAlignedBoundingBox.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidalOccluder from \"./EllipsoidalOccluder.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport Transforms from \"./Transforms.js\";\nimport WebMercatorProjection from \"./WebMercatorProjection.js\";\n\n/**\n * Contains functions to create a mesh from a heightmap image.\n *\n * @namespace HeightmapTessellator\n *\n * @private\n */\nconst HeightmapTessellator = {};\n\n/**\n * The default structure of a heightmap, as given to {@link HeightmapTessellator.computeVertices}.\n *\n * @constant\n */\nHeightmapTessellator.DEFAULT_STRUCTURE = Object.freeze({\n  heightScale: 1.0,\n  heightOffset: 0.0,\n  elementsPerHeight: 1,\n  stride: 1,\n  elementMultiplier: 256.0,\n  isBigEndian: false,\n});\n\nconst cartesian3Scratch = new Cartesian3();\nconst matrix4Scratch = new Matrix4();\nconst minimumScratch = new Cartesian3();\nconst maximumScratch = new Cartesian3();\n\n/**\n * Fills an array of vertices from a heightmap image.\n *\n * @param {object} options Object with the following properties:\n * @param {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} options.heightmap The heightmap to tessellate.\n * @param {number} options.width The width of the heightmap, in height samples.\n * @param {number} options.height The height of the heightmap, in height samples.\n * @param {number} options.skirtHeight The height of skirts to drape at the edges of the heightmap.\n * @param {Rectangle} options.nativeRectangle A rectangle in the native coordinates of the heightmap's projection.  For\n *                 a heightmap with a geographic projection, this is degrees.  For the web mercator\n *                 projection, this is meters.\n * @param {number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {number} [options.exaggerationRelativeHeight=0.0] The height from which terrain is exaggerated.\n * @param {Rectangle} [options.rectangle] The rectangle covered by the heightmap, in geodetic coordinates with north, south, east and\n *                 west properties in radians.  Either rectangle or nativeRectangle must be provided.  If both\n *                 are provided, they're assumed to be consistent.\n * @param {boolean} [options.isGeographic=true] True if the heightmap uses a {@link GeographicProjection}, or false if it uses\n *                  a {@link WebMercatorProjection}.\n * @param {Cartesian3} [options.relativeToCenter=Cartesian3.ZERO] The positions will be computed as <code>Cartesian3.subtract(worldPosition, relativeToCenter)</code>.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid to which the heightmap applies.\n * @param {object} [options.structure] An object describing the structure of the height data.\n * @param {number} [options.structure.heightScale=1.0] The factor by which to multiply height samples in order to obtain\n *                 the height above the heightOffset, in meters.  The heightOffset is added to the resulting\n *                 height after multiplying by the scale.\n * @param {number} [options.structure.heightOffset=0.0] The offset to add to the scaled height to obtain the final\n *                 height in meters.  The offset is added after the height sample is multiplied by the\n *                 heightScale.\n * @param {number} [options.structure.elementsPerHeight=1] The number of elements in the buffer that make up a single height\n *                 sample.  This is usually 1, indicating that each element is a separate height sample.  If\n *                 it is greater than 1, that number of elements together form the height sample, which is\n *                 computed according to the structure.elementMultiplier and structure.isBigEndian properties.\n * @param {number} [options.structure.stride=1] The number of elements to skip to get from the first element of\n *                 one height to the first element of the next height.\n * @param {number} [options.structure.elementMultiplier=256.0] The multiplier used to compute the height value when the\n *                 stride property is greater than 1.  For example, if the stride is 4 and the strideMultiplier\n *                 is 256, the height is computed as follows:\n *                 `height = buffer[index] + buffer[index + 1] * 256 + buffer[index + 2] * 256 * 256 + buffer[index + 3] * 256 * 256 * 256`\n *                 This is assuming that the isBigEndian property is false.  If it is true, the order of the\n *                 elements is reversed.\n * @param {number} [options.structure.lowestEncodedHeight] The lowest value that can be stored in the height buffer.  Any heights that are lower\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be 0 because a `Uint16Array` cannot store negative numbers.  If this parameter is\n *                 not specified, no minimum value is enforced.\n * @param {number} [options.structure.highestEncodedHeight] The highest value that can be stored in the height buffer.  Any heights that are higher\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be `256 * 256 - 1` or 65535 because a `Uint16Array` cannot store numbers larger\n *                 than 65535.  If this parameter is not specified, no maximum value is enforced.\n * @param {boolean} [options.structure.isBigEndian=false] Indicates endianness of the elements in the buffer when the\n *                  stride property is greater than 1.  If this property is false, the first element is the\n *                  low-order element.  If it is true, the first element is the high-order element.\n *\n * @example\n * const width = 5;\n * const height = 5;\n * const statistics = Cesium.HeightmapTessellator.computeVertices({\n *     heightmap : [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0],\n *     width : width,\n *     height : height,\n *     skirtHeight : 0.0,\n *     nativeRectangle : {\n *         west : 10.0,\n *         east : 20.0,\n *         south : 30.0,\n *         north : 40.0\n *     }\n * });\n *\n * const encoding = statistics.encoding;\n * const position = encoding.decodePosition(statistics.vertices, index);\n */\nHeightmapTessellator.computeVertices = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.heightmap)) {\n    throw new DeveloperError(\"options.heightmap is required.\");\n  }\n  if (!defined(options.width) || !defined(options.height)) {\n    throw new DeveloperError(\"options.width and options.height are required.\");\n  }\n  if (!defined(options.nativeRectangle)) {\n    throw new DeveloperError(\"options.nativeRectangle is required.\");\n  }\n  if (!defined(options.skirtHeight)) {\n    throw new DeveloperError(\"options.skirtHeight is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // This function tends to be a performance hotspot for terrain rendering,\n  // so it employs a lot of inlining and unrolling as an optimization.\n  // In particular, the functionality of Ellipsoid.cartographicToCartesian\n  // is inlined.\n\n  const cos = Math.cos;\n  const sin = Math.sin;\n  const sqrt = Math.sqrt;\n  const atan = Math.atan;\n  const exp = Math.exp;\n  const piOverTwo = CesiumMath.PI_OVER_TWO;\n  const toRadians = CesiumMath.toRadians;\n\n  const heightmap = options.heightmap;\n  const width = options.width;\n  const height = options.height;\n  const skirtHeight = options.skirtHeight;\n  const hasSkirts = skirtHeight > 0.0;\n\n  const isGeographic = options.isGeographic ?? true;\n  const ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n\n  const oneOverGlobeSemimajorAxis = 1.0 / ellipsoid.maximumRadius;\n\n  const nativeRectangle = Rectangle.clone(options.nativeRectangle);\n  const rectangle = Rectangle.clone(options.rectangle);\n\n  let geographicWest;\n  let geographicSouth;\n  let geographicEast;\n  let geographicNorth;\n\n  if (!defined(rectangle)) {\n    if (isGeographic) {\n      geographicWest = toRadians(nativeRectangle.west);\n      geographicSouth = toRadians(nativeRectangle.south);\n      geographicEast = toRadians(nativeRectangle.east);\n      geographicNorth = toRadians(nativeRectangle.north);\n    } else {\n      geographicWest = nativeRectangle.west * oneOverGlobeSemimajorAxis;\n      geographicSouth =\n        piOverTwo -\n        2.0 * atan(exp(-nativeRectangle.south * oneOverGlobeSemimajorAxis));\n      geographicEast = nativeRectangle.east * oneOverGlobeSemimajorAxis;\n      geographicNorth =\n        piOverTwo -\n        2.0 * atan(exp(-nativeRectangle.north * oneOverGlobeSemimajorAxis));\n    }\n  } else {\n    geographicWest = rectangle.west;\n    geographicSouth = rectangle.south;\n    geographicEast = rectangle.east;\n    geographicNorth = rectangle.north;\n  }\n\n  let relativeToCenter = options.relativeToCenter;\n  const hasRelativeToCenter = defined(relativeToCenter);\n  relativeToCenter = hasRelativeToCenter ? relativeToCenter : Cartesian3.ZERO;\n  const includeWebMercatorT = options.includeWebMercatorT ?? false;\n\n  const exaggeration = options.exaggeration ?? 1.0;\n  const exaggerationRelativeHeight = options.exaggerationRelativeHeight ?? 0.0;\n  const hasExaggeration = exaggeration !== 1.0;\n  const includeGeodeticSurfaceNormals = hasExaggeration;\n\n  const structure = options.structure ?? HeightmapTessellator.DEFAULT_STRUCTURE;\n  const heightScale =\n    structure.heightScale ?? HeightmapTessellator.DEFAULT_STRUCTURE.heightScale;\n  const heightOffset =\n    structure.heightOffset ??\n    HeightmapTessellator.DEFAULT_STRUCTURE.heightOffset;\n  const elementsPerHeight =\n    structure.elementsPerHeight ??\n    HeightmapTessellator.DEFAULT_STRUCTURE.elementsPerHeight;\n  const stride =\n    structure.stride ?? HeightmapTessellator.DEFAULT_STRUCTURE.stride;\n  const elementMultiplier =\n    structure.elementMultiplier ??\n    HeightmapTessellator.DEFAULT_STRUCTURE.elementMultiplier;\n  const isBigEndian =\n    structure.isBigEndian ?? HeightmapTessellator.DEFAULT_STRUCTURE.isBigEndian;\n\n  let rectangleWidth = Rectangle.computeWidth(nativeRectangle);\n  let rectangleHeight = Rectangle.computeHeight(nativeRectangle);\n\n  const granularityX = rectangleWidth / (width - 1);\n  const granularityY = rectangleHeight / (height - 1);\n\n  if (!isGeographic) {\n    rectangleWidth *= oneOverGlobeSemimajorAxis;\n    rectangleHeight *= oneOverGlobeSemimajorAxis;\n  }\n\n  const radiiSquared = ellipsoid.radiiSquared;\n  const radiiSquaredX = radiiSquared.x;\n  const radiiSquaredY = radiiSquared.y;\n  const radiiSquaredZ = radiiSquared.z;\n\n  let minimumHeight = 65536.0;\n  let maximumHeight = -65536.0;\n\n  const fromENU = Transforms.eastNorthUpToFixedFrame(\n    relativeToCenter,\n    ellipsoid,\n  );\n  const toENU = Matrix4.inverseTransformation(fromENU, matrix4Scratch);\n\n  let southMercatorY;\n  let oneOverMercatorHeight;\n  if (includeWebMercatorT) {\n    southMercatorY =\n      WebMercatorProjection.geodeticLatitudeToMercatorAngle(geographicSouth);\n    oneOverMercatorHeight =\n      1.0 /\n      (WebMercatorProjection.geodeticLatitudeToMercatorAngle(geographicNorth) -\n        southMercatorY);\n  }\n\n  const minimum = minimumScratch;\n  minimum.x = Number.POSITIVE_INFINITY;\n  minimum.y = Number.POSITIVE_INFINITY;\n  minimum.z = Number.POSITIVE_INFINITY;\n\n  const maximum = maximumScratch;\n  maximum.x = Number.NEGATIVE_INFINITY;\n  maximum.y = Number.NEGATIVE_INFINITY;\n  maximum.z = Number.NEGATIVE_INFINITY;\n\n  let hMin = Number.POSITIVE_INFINITY;\n\n  const gridVertexCount = width * height;\n  const edgeVertexCount = skirtHeight > 0.0 ? width * 2 + height * 2 : 0;\n  const vertexCount = gridVertexCount + edgeVertexCount;\n\n  const positions = new Array(vertexCount);\n  const heights = new Array(vertexCount);\n  const uvs = new Array(vertexCount);\n  const webMercatorTs = includeWebMercatorT ? new Array(vertexCount) : [];\n  const geodeticSurfaceNormals = includeGeodeticSurfaceNormals\n    ? new Array(vertexCount)\n    : [];\n\n  let startRow = 0;\n  let endRow = height;\n  let startCol = 0;\n  let endCol = width;\n\n  if (hasSkirts) {\n    --startRow;\n    ++endRow;\n    --startCol;\n    ++endCol;\n  }\n\n  const skirtOffsetPercentage = 0.00001;\n\n  for (let rowIndex = startRow; rowIndex < endRow; ++rowIndex) {\n    let row = rowIndex;\n    if (row < 0) {\n      row = 0;\n    }\n    if (row >= height) {\n      row = height - 1;\n    }\n\n    let latitude = nativeRectangle.north - granularityY * row;\n\n    if (!isGeographic) {\n      latitude =\n        piOverTwo - 2.0 * atan(exp(-latitude * oneOverGlobeSemimajorAxis));\n    } else {\n      latitude = toRadians(latitude);\n    }\n\n    let v = (latitude - geographicSouth) / (geographicNorth - geographicSouth);\n    v = CesiumMath.clamp(v, 0.0, 1.0);\n\n    const isNorthEdge = rowIndex === startRow;\n    const isSouthEdge = rowIndex === endRow - 1;\n    if (skirtHeight > 0.0) {\n      if (isNorthEdge) {\n        latitude += skirtOffsetPercentage * rectangleHeight;\n      } else if (isSouthEdge) {\n        latitude -= skirtOffsetPercentage * rectangleHeight;\n      }\n    }\n\n    const cosLatitude = cos(latitude);\n    const nZ = sin(latitude);\n    const kZ = radiiSquaredZ * nZ;\n\n    let webMercatorT;\n    if (includeWebMercatorT) {\n      webMercatorT =\n        (WebMercatorProjection.geodeticLatitudeToMercatorAngle(latitude) -\n          southMercatorY) *\n        oneOverMercatorHeight;\n    }\n\n    for (let colIndex = startCol; colIndex < endCol; ++colIndex) {\n      let col = colIndex;\n      if (col < 0) {\n        col = 0;\n      }\n      if (col >= width) {\n        col = width - 1;\n      }\n\n      const terrainOffset = row * (width * stride) + col * stride;\n\n      let heightSample;\n      if (elementsPerHeight === 1) {\n        heightSample = heightmap[terrainOffset];\n      } else {\n        heightSample = 0;\n\n        let elementOffset;\n        if (isBigEndian) {\n          for (\n            elementOffset = 0;\n            elementOffset < elementsPerHeight;\n            ++elementOffset\n          ) {\n            heightSample =\n              heightSample * elementMultiplier +\n              heightmap[terrainOffset + elementOffset];\n          }\n        } else {\n          for (\n            elementOffset = elementsPerHeight - 1;\n            elementOffset >= 0;\n            --elementOffset\n          ) {\n            heightSample =\n              heightSample * elementMultiplier +\n              heightmap[terrainOffset + elementOffset];\n          }\n        }\n      }\n\n      heightSample = heightSample * heightScale + heightOffset;\n\n      maximumHeight = Math.max(maximumHeight, heightSample);\n      minimumHeight = Math.min(minimumHeight, heightSample);\n\n      let longitude = nativeRectangle.west + granularityX * col;\n\n      if (!isGeographic) {\n        longitude = longitude * oneOverGlobeSemimajorAxis;\n      } else {\n        longitude = toRadians(longitude);\n      }\n\n      let u = (longitude - geographicWest) / (geographicEast - geographicWest);\n      u = CesiumMath.clamp(u, 0.0, 1.0);\n\n      let index = row * width + col;\n\n      if (skirtHeight > 0.0) {\n        const isWestEdge = colIndex === startCol;\n        const isEastEdge = colIndex === endCol - 1;\n        const isEdge = isNorthEdge || isSouthEdge || isWestEdge || isEastEdge;\n        const isCorner =\n          (isNorthEdge || isSouthEdge) && (isWestEdge || isEastEdge);\n        if (isCorner) {\n          // Don't generate skirts on the corners.\n          continue;\n        } else if (isEdge) {\n          heightSample -= skirtHeight;\n\n          if (isWestEdge) {\n            // The outer loop iterates north to south but the indices are ordered south to north, hence the index flip below\n            index = gridVertexCount + (height - row - 1);\n            longitude -= skirtOffsetPercentage * rectangleWidth;\n          } else if (isSouthEdge) {\n            // Add after west indices. South indices are ordered east to west.\n            index = gridVertexCount + height + (width - col - 1);\n          } else if (isEastEdge) {\n            // Add after west and south indices. East indices are ordered north to south. The index is flipped like above.\n            index = gridVertexCount + height + width + row;\n            longitude += skirtOffsetPercentage * rectangleWidth;\n          } else if (isNorthEdge) {\n            // Add after west, south, and east indices. North indices are ordered west to east.\n            index = gridVertexCount + height + width + height + col;\n          }\n        }\n      }\n\n      const nX = cosLatitude * cos(longitude);\n      const nY = cosLatitude * sin(longitude);\n\n      const kX = radiiSquaredX * nX;\n      const kY = radiiSquaredY * nY;\n\n      const gamma = sqrt(kX * nX + kY * nY + kZ * nZ);\n      const oneOverGamma = 1.0 / gamma;\n\n      const rSurfaceX = kX * oneOverGamma;\n      const rSurfaceY = kY * oneOverGamma;\n      const rSurfaceZ = kZ * oneOverGamma;\n\n      const position = new Cartesian3();\n      position.x = rSurfaceX + nX * heightSample;\n      position.y = rSurfaceY + nY * heightSample;\n      position.z = rSurfaceZ + nZ * heightSample;\n\n      Matrix4.multiplyByPoint(toENU, position, cartesian3Scratch);\n      Cartesian3.minimumByComponent(cartesian3Scratch, minimum, minimum);\n      Cartesian3.maximumByComponent(cartesian3Scratch, maximum, maximum);\n      hMin = Math.min(hMin, heightSample);\n\n      positions[index] = position;\n      uvs[index] = new Cartesian2(u, v);\n      heights[index] = heightSample;\n\n      if (includeWebMercatorT) {\n        webMercatorTs[index] = webMercatorT;\n      }\n\n      if (includeGeodeticSurfaceNormals) {\n        geodeticSurfaceNormals[index] =\n          ellipsoid.geodeticSurfaceNormal(position);\n      }\n    }\n  }\n\n  const boundingSphere3D = BoundingSphere.fromPoints(positions);\n  let orientedBoundingBox;\n  if (defined(rectangle)) {\n    orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n      rectangle,\n      minimumHeight,\n      maximumHeight,\n      ellipsoid,\n    );\n  }\n\n  let occludeePointInScaledSpace;\n  if (hasRelativeToCenter) {\n    const occluder = new EllipsoidalOccluder(ellipsoid);\n    occludeePointInScaledSpace =\n      occluder.computeHorizonCullingPointPossiblyUnderEllipsoid(\n        relativeToCenter,\n        positions,\n        minimumHeight,\n      );\n  }\n\n  const aaBox = new AxisAlignedBoundingBox(minimum, maximum, relativeToCenter);\n  const encoding = new TerrainEncoding(\n    relativeToCenter,\n    aaBox,\n    hMin,\n    maximumHeight,\n    fromENU,\n    false,\n    includeWebMercatorT,\n    includeGeodeticSurfaceNormals,\n    exaggeration,\n    exaggerationRelativeHeight,\n  );\n  const vertices = new Float32Array(vertexCount * encoding.stride);\n\n  let bufferIndex = 0;\n  for (let j = 0; j < vertexCount; ++j) {\n    bufferIndex = encoding.encode(\n      vertices,\n      bufferIndex,\n      positions[j],\n      uvs[j],\n      heights[j],\n      undefined,\n      webMercatorTs[j],\n      geodeticSurfaceNormals[j],\n    );\n  }\n\n  return {\n    vertices: vertices,\n    maximumHeight: maximumHeight,\n    minimumHeight: minimumHeight,\n    encoding: encoding,\n    boundingSphere3D: boundingSphere3D,\n    orientedBoundingBox: orientedBoundingBox,\n    occludeePointInScaledSpace: occludeePointInScaledSpace,\n  };\n};\nexport default HeightmapTessellator;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}