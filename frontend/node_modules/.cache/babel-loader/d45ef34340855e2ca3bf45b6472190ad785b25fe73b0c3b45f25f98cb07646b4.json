{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Encapsulates an algorithm to optimize triangles for the post\n * vertex-shader cache.  This is based on the 2007 SIGGRAPH paper\n * 'Fast Triangle Reordering for Vertex Locality and Reduced Overdraw.'\n * The runtime is linear but several passes are made.\n *\n * @namespace Tipsify\n *\n * @see <a href='http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf'>\n * Fast Triangle Reordering for Vertex Locality and Reduced Overdraw</a>\n * by Sander, Nehab, and Barczak\n *\n * @private\n */\nconst Tipsify = {};\n\n/**\n * Calculates the average cache miss ratio (ACMR) for a given set of indices.\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.indices Lists triads of numbers corresponding to the indices of the vertices\n *                        in the vertex buffer that define the geometry's triangles.\n * @param {number} [options.maximumIndex] The maximum value of the elements in <code>args.indices</code>.\n *                                     If not supplied, this value will be computed.\n * @param {number} [options.cacheSize=24] The number of vertices that can be stored in the cache at any one time.\n * @returns {number} The average cache miss ratio (ACMR).\n *\n * @exception {DeveloperError} indices length must be a multiple of three.\n * @exception {DeveloperError} cacheSize must be greater than two.\n *\n * @example\n * const indices = [0, 1, 2, 3, 4, 5];\n * const maxIndex = 5;\n * const cacheSize = 3;\n * const acmr = Cesium.Tipsify.calculateACMR({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});\n */\nTipsify.calculateACMR = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const indices = options.indices;\n  let maximumIndex = options.maximumIndex;\n  const cacheSize = options.cacheSize ?? 24;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(indices)) {\n    throw new DeveloperError(\"indices is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const numIndices = indices.length;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numIndices < 3 || numIndices % 3 !== 0) {\n    throw new DeveloperError(\"indices length must be a multiple of three.\");\n  }\n  if (maximumIndex <= 0) {\n    throw new DeveloperError(\"maximumIndex must be greater than zero.\");\n  }\n  if (cacheSize < 3) {\n    throw new DeveloperError(\"cacheSize must be greater than two.\");\n  }\n  //>>includeEnd('debug');\n\n  // Compute the maximumIndex if not given\n  if (!defined(maximumIndex)) {\n    maximumIndex = 0;\n    let currentIndex = 0;\n    let intoIndices = indices[currentIndex];\n    while (currentIndex < numIndices) {\n      if (intoIndices > maximumIndex) {\n        maximumIndex = intoIndices;\n      }\n      ++currentIndex;\n      intoIndices = indices[currentIndex];\n    }\n  }\n\n  // Vertex time stamps\n  const vertexTimeStamps = [];\n  for (let i = 0; i < maximumIndex + 1; i++) {\n    vertexTimeStamps[i] = 0;\n  }\n\n  // Cache processing\n  let s = cacheSize + 1;\n  for (let j = 0; j < numIndices; ++j) {\n    if (s - vertexTimeStamps[indices[j]] > cacheSize) {\n      vertexTimeStamps[indices[j]] = s;\n      ++s;\n    }\n  }\n  return (s - cacheSize + 1) / (numIndices / 3);\n};\n\n/**\n * Optimizes triangles for the post-vertex shader cache.\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.indices Lists triads of numbers corresponding to the indices of the vertices\n *                        in the vertex buffer that define the geometry's triangles.\n * @param {number} [options.maximumIndex] The maximum value of the elements in <code>args.indices</code>.\n *                                     If not supplied, this value will be computed.\n * @param {number} [options.cacheSize=24] The number of vertices that can be stored in the cache at any one time.\n * @returns {number[]} A list of the input indices in an optimized order.\n *\n * @exception {DeveloperError} indices length must be a multiple of three.\n * @exception {DeveloperError} cacheSize must be greater than two.\n *\n * @example\n * const indices = [0, 1, 2, 3, 4, 5];\n * const maxIndex = 5;\n * const cacheSize = 3;\n * const reorderedIndices = Cesium.Tipsify.tipsify({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});\n */\nTipsify.tipsify = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const indices = options.indices;\n  const maximumIndex = options.maximumIndex;\n  const cacheSize = options.cacheSize ?? 24;\n  let cursor;\n  function skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne) {\n    while (deadEnd.length >= 1) {\n      // while the stack is not empty\n      const d = deadEnd[deadEnd.length - 1]; // top of the stack\n      deadEnd.splice(deadEnd.length - 1, 1); // pop the stack\n\n      if (vertices[d].numLiveTriangles > 0) {\n        return d;\n      }\n    }\n    while (cursor < maximumIndexPlusOne) {\n      if (vertices[cursor].numLiveTriangles > 0) {\n        ++cursor;\n        return cursor - 1;\n      }\n      ++cursor;\n    }\n    return -1;\n  }\n  function getNextVertex(indices, cacheSize, oneRing, vertices, s, deadEnd, maximumIndexPlusOne) {\n    let n = -1;\n    let p;\n    let m = -1;\n    let itOneRing = 0;\n    while (itOneRing < oneRing.length) {\n      const index = oneRing[itOneRing];\n      if (vertices[index].numLiveTriangles) {\n        p = 0;\n        if (s - vertices[index].timeStamp + 2 * vertices[index].numLiveTriangles <= cacheSize) {\n          p = s - vertices[index].timeStamp;\n        }\n        if (p > m || m === -1) {\n          m = p;\n          n = index;\n        }\n      }\n      ++itOneRing;\n    }\n    if (n === -1) {\n      return skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne);\n    }\n    return n;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(indices)) {\n    throw new DeveloperError(\"indices is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const numIndices = indices.length;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numIndices < 3 || numIndices % 3 !== 0) {\n    throw new DeveloperError(\"indices length must be a multiple of three.\");\n  }\n  if (maximumIndex <= 0) {\n    throw new DeveloperError(\"maximumIndex must be greater than zero.\");\n  }\n  if (cacheSize < 3) {\n    throw new DeveloperError(\"cacheSize must be greater than two.\");\n  }\n  //>>includeEnd('debug');\n\n  // Determine maximum index\n  let maximumIndexPlusOne = 0;\n  let currentIndex = 0;\n  let intoIndices = indices[currentIndex];\n  const endIndex = numIndices;\n  if (defined(maximumIndex)) {\n    maximumIndexPlusOne = maximumIndex + 1;\n  } else {\n    while (currentIndex < endIndex) {\n      if (intoIndices > maximumIndexPlusOne) {\n        maximumIndexPlusOne = intoIndices;\n      }\n      ++currentIndex;\n      intoIndices = indices[currentIndex];\n    }\n    if (maximumIndexPlusOne === -1) {\n      return 0;\n    }\n    ++maximumIndexPlusOne;\n  }\n\n  // Vertices\n  const vertices = [];\n  let i;\n  for (i = 0; i < maximumIndexPlusOne; i++) {\n    vertices[i] = {\n      numLiveTriangles: 0,\n      timeStamp: 0,\n      vertexTriangles: []\n    };\n  }\n  currentIndex = 0;\n  let triangle = 0;\n  while (currentIndex < endIndex) {\n    vertices[indices[currentIndex]].vertexTriangles.push(triangle);\n    ++vertices[indices[currentIndex]].numLiveTriangles;\n    vertices[indices[currentIndex + 1]].vertexTriangles.push(triangle);\n    ++vertices[indices[currentIndex + 1]].numLiveTriangles;\n    vertices[indices[currentIndex + 2]].vertexTriangles.push(triangle);\n    ++vertices[indices[currentIndex + 2]].numLiveTriangles;\n    ++triangle;\n    currentIndex += 3;\n  }\n\n  // Starting index\n  let f = 0;\n\n  // Time Stamp\n  let s = cacheSize + 1;\n  cursor = 1;\n\n  // Process\n  let oneRing = [];\n  const deadEnd = []; //Stack\n  let vertex;\n  let intoVertices;\n  let currentOutputIndex = 0;\n  const outputIndices = [];\n  const numTriangles = numIndices / 3;\n  const triangleEmitted = [];\n  for (i = 0; i < numTriangles; i++) {\n    triangleEmitted[i] = false;\n  }\n  let index;\n  let limit;\n  while (f !== -1) {\n    oneRing = [];\n    intoVertices = vertices[f];\n    limit = intoVertices.vertexTriangles.length;\n    for (let k = 0; k < limit; ++k) {\n      triangle = intoVertices.vertexTriangles[k];\n      if (!triangleEmitted[triangle]) {\n        triangleEmitted[triangle] = true;\n        currentIndex = triangle + triangle + triangle;\n        for (let j = 0; j < 3; ++j) {\n          // Set this index as a possible next index\n          index = indices[currentIndex];\n          oneRing.push(index);\n          deadEnd.push(index);\n\n          // Output index\n          outputIndices[currentOutputIndex] = index;\n          ++currentOutputIndex;\n\n          // Cache processing\n          vertex = vertices[index];\n          --vertex.numLiveTriangles;\n          if (s - vertex.timeStamp > cacheSize) {\n            vertex.timeStamp = s;\n            ++s;\n          }\n          ++currentIndex;\n        }\n      }\n    }\n    f = getNextVertex(indices, cacheSize, oneRing, vertices, s, deadEnd, maximumIndexPlusOne);\n  }\n  return outputIndices;\n};\nexport default Tipsify;","map":{"version":3,"names":["Frozen","defined","DeveloperError","Tipsify","calculateACMR","options","EMPTY_OBJECT","indices","maximumIndex","cacheSize","numIndices","length","currentIndex","intoIndices","vertexTimeStamps","i","s","j","tipsify","cursor","skipDeadEnd","vertices","deadEnd","maximumIndexPlusOne","d","splice","numLiveTriangles","getNextVertex","oneRing","n","p","m","itOneRing","index","timeStamp","endIndex","vertexTriangles","triangle","push","f","vertex","intoVertices","currentOutputIndex","outputIndices","numTriangles","triangleEmitted","limit","k"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/Tipsify.js"],"sourcesContent":["import Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Encapsulates an algorithm to optimize triangles for the post\n * vertex-shader cache.  This is based on the 2007 SIGGRAPH paper\n * 'Fast Triangle Reordering for Vertex Locality and Reduced Overdraw.'\n * The runtime is linear but several passes are made.\n *\n * @namespace Tipsify\n *\n * @see <a href='http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf'>\n * Fast Triangle Reordering for Vertex Locality and Reduced Overdraw</a>\n * by Sander, Nehab, and Barczak\n *\n * @private\n */\nconst Tipsify = {};\n\n/**\n * Calculates the average cache miss ratio (ACMR) for a given set of indices.\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.indices Lists triads of numbers corresponding to the indices of the vertices\n *                        in the vertex buffer that define the geometry's triangles.\n * @param {number} [options.maximumIndex] The maximum value of the elements in <code>args.indices</code>.\n *                                     If not supplied, this value will be computed.\n * @param {number} [options.cacheSize=24] The number of vertices that can be stored in the cache at any one time.\n * @returns {number} The average cache miss ratio (ACMR).\n *\n * @exception {DeveloperError} indices length must be a multiple of three.\n * @exception {DeveloperError} cacheSize must be greater than two.\n *\n * @example\n * const indices = [0, 1, 2, 3, 4, 5];\n * const maxIndex = 5;\n * const cacheSize = 3;\n * const acmr = Cesium.Tipsify.calculateACMR({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});\n */\nTipsify.calculateACMR = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const indices = options.indices;\n  let maximumIndex = options.maximumIndex;\n  const cacheSize = options.cacheSize ?? 24;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(indices)) {\n    throw new DeveloperError(\"indices is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const numIndices = indices.length;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numIndices < 3 || numIndices % 3 !== 0) {\n    throw new DeveloperError(\"indices length must be a multiple of three.\");\n  }\n  if (maximumIndex <= 0) {\n    throw new DeveloperError(\"maximumIndex must be greater than zero.\");\n  }\n  if (cacheSize < 3) {\n    throw new DeveloperError(\"cacheSize must be greater than two.\");\n  }\n  //>>includeEnd('debug');\n\n  // Compute the maximumIndex if not given\n  if (!defined(maximumIndex)) {\n    maximumIndex = 0;\n    let currentIndex = 0;\n    let intoIndices = indices[currentIndex];\n    while (currentIndex < numIndices) {\n      if (intoIndices > maximumIndex) {\n        maximumIndex = intoIndices;\n      }\n      ++currentIndex;\n      intoIndices = indices[currentIndex];\n    }\n  }\n\n  // Vertex time stamps\n  const vertexTimeStamps = [];\n  for (let i = 0; i < maximumIndex + 1; i++) {\n    vertexTimeStamps[i] = 0;\n  }\n\n  // Cache processing\n  let s = cacheSize + 1;\n  for (let j = 0; j < numIndices; ++j) {\n    if (s - vertexTimeStamps[indices[j]] > cacheSize) {\n      vertexTimeStamps[indices[j]] = s;\n      ++s;\n    }\n  }\n\n  return (s - cacheSize + 1) / (numIndices / 3);\n};\n\n/**\n * Optimizes triangles for the post-vertex shader cache.\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.indices Lists triads of numbers corresponding to the indices of the vertices\n *                        in the vertex buffer that define the geometry's triangles.\n * @param {number} [options.maximumIndex] The maximum value of the elements in <code>args.indices</code>.\n *                                     If not supplied, this value will be computed.\n * @param {number} [options.cacheSize=24] The number of vertices that can be stored in the cache at any one time.\n * @returns {number[]} A list of the input indices in an optimized order.\n *\n * @exception {DeveloperError} indices length must be a multiple of three.\n * @exception {DeveloperError} cacheSize must be greater than two.\n *\n * @example\n * const indices = [0, 1, 2, 3, 4, 5];\n * const maxIndex = 5;\n * const cacheSize = 3;\n * const reorderedIndices = Cesium.Tipsify.tipsify({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});\n */\nTipsify.tipsify = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const indices = options.indices;\n  const maximumIndex = options.maximumIndex;\n  const cacheSize = options.cacheSize ?? 24;\n\n  let cursor;\n\n  function skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne) {\n    while (deadEnd.length >= 1) {\n      // while the stack is not empty\n      const d = deadEnd[deadEnd.length - 1]; // top of the stack\n      deadEnd.splice(deadEnd.length - 1, 1); // pop the stack\n\n      if (vertices[d].numLiveTriangles > 0) {\n        return d;\n      }\n    }\n\n    while (cursor < maximumIndexPlusOne) {\n      if (vertices[cursor].numLiveTriangles > 0) {\n        ++cursor;\n        return cursor - 1;\n      }\n      ++cursor;\n    }\n    return -1;\n  }\n\n  function getNextVertex(\n    indices,\n    cacheSize,\n    oneRing,\n    vertices,\n    s,\n    deadEnd,\n    maximumIndexPlusOne,\n  ) {\n    let n = -1;\n    let p;\n    let m = -1;\n    let itOneRing = 0;\n    while (itOneRing < oneRing.length) {\n      const index = oneRing[itOneRing];\n      if (vertices[index].numLiveTriangles) {\n        p = 0;\n        if (\n          s -\n            vertices[index].timeStamp +\n            2 * vertices[index].numLiveTriangles <=\n          cacheSize\n        ) {\n          p = s - vertices[index].timeStamp;\n        }\n        if (p > m || m === -1) {\n          m = p;\n          n = index;\n        }\n      }\n      ++itOneRing;\n    }\n    if (n === -1) {\n      return skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne);\n    }\n    return n;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(indices)) {\n    throw new DeveloperError(\"indices is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const numIndices = indices.length;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numIndices < 3 || numIndices % 3 !== 0) {\n    throw new DeveloperError(\"indices length must be a multiple of three.\");\n  }\n  if (maximumIndex <= 0) {\n    throw new DeveloperError(\"maximumIndex must be greater than zero.\");\n  }\n  if (cacheSize < 3) {\n    throw new DeveloperError(\"cacheSize must be greater than two.\");\n  }\n  //>>includeEnd('debug');\n\n  // Determine maximum index\n  let maximumIndexPlusOne = 0;\n  let currentIndex = 0;\n  let intoIndices = indices[currentIndex];\n  const endIndex = numIndices;\n  if (defined(maximumIndex)) {\n    maximumIndexPlusOne = maximumIndex + 1;\n  } else {\n    while (currentIndex < endIndex) {\n      if (intoIndices > maximumIndexPlusOne) {\n        maximumIndexPlusOne = intoIndices;\n      }\n      ++currentIndex;\n      intoIndices = indices[currentIndex];\n    }\n    if (maximumIndexPlusOne === -1) {\n      return 0;\n    }\n    ++maximumIndexPlusOne;\n  }\n\n  // Vertices\n  const vertices = [];\n  let i;\n  for (i = 0; i < maximumIndexPlusOne; i++) {\n    vertices[i] = {\n      numLiveTriangles: 0,\n      timeStamp: 0,\n      vertexTriangles: [],\n    };\n  }\n  currentIndex = 0;\n  let triangle = 0;\n  while (currentIndex < endIndex) {\n    vertices[indices[currentIndex]].vertexTriangles.push(triangle);\n    ++vertices[indices[currentIndex]].numLiveTriangles;\n    vertices[indices[currentIndex + 1]].vertexTriangles.push(triangle);\n    ++vertices[indices[currentIndex + 1]].numLiveTriangles;\n    vertices[indices[currentIndex + 2]].vertexTriangles.push(triangle);\n    ++vertices[indices[currentIndex + 2]].numLiveTriangles;\n    ++triangle;\n    currentIndex += 3;\n  }\n\n  // Starting index\n  let f = 0;\n\n  // Time Stamp\n  let s = cacheSize + 1;\n  cursor = 1;\n\n  // Process\n  let oneRing = [];\n  const deadEnd = []; //Stack\n  let vertex;\n  let intoVertices;\n  let currentOutputIndex = 0;\n  const outputIndices = [];\n  const numTriangles = numIndices / 3;\n  const triangleEmitted = [];\n  for (i = 0; i < numTriangles; i++) {\n    triangleEmitted[i] = false;\n  }\n  let index;\n  let limit;\n  while (f !== -1) {\n    oneRing = [];\n    intoVertices = vertices[f];\n    limit = intoVertices.vertexTriangles.length;\n    for (let k = 0; k < limit; ++k) {\n      triangle = intoVertices.vertexTriangles[k];\n      if (!triangleEmitted[triangle]) {\n        triangleEmitted[triangle] = true;\n        currentIndex = triangle + triangle + triangle;\n        for (let j = 0; j < 3; ++j) {\n          // Set this index as a possible next index\n          index = indices[currentIndex];\n          oneRing.push(index);\n          deadEnd.push(index);\n\n          // Output index\n          outputIndices[currentOutputIndex] = index;\n          ++currentOutputIndex;\n\n          // Cache processing\n          vertex = vertices[index];\n          --vertex.numLiveTriangles;\n          if (s - vertex.timeStamp > cacheSize) {\n            vertex.timeStamp = s;\n            ++s;\n          }\n          ++currentIndex;\n        }\n      }\n    }\n    f = getNextVertex(\n      indices,\n      cacheSize,\n      oneRing,\n      vertices,\n      s,\n      deadEnd,\n      maximumIndexPlusOne,\n    );\n  }\n\n  return outputIndices;\n};\nexport default Tipsify;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}