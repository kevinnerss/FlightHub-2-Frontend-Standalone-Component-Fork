{"ast":null,"code":"// Regex that specifies any delimiter char that allows us to treat the number as\n// a phone number rather than just any other number that could appear in text.\nvar hasDelimCharsRe = /[-. ()]/;\n// Over the years, many people have added to this regex, but it should have been\n// split up by country. Maybe one day we can break this down.\nvar mostPhoneNumbers = /(?:(?:(?:(\\+)?\\d{1,3}[-. ]?)?\\(?\\d{3}\\)?[-. ]?\\d{3}[-. ]?\\d{4})|(?:(\\+)(?:9[976]\\d|8[987530]\\d|6[987]\\d|5[90]\\d|42\\d|3[875]\\d|2[98654321]\\d|9[8543210]|8[6421]|6[6543210]|5[87654321]|4[987654310]|3[9643210]|2[70]|7|1)[-. ]?(?:\\d[-. ]?){6,12}\\d+))([,;]+[0-9]+#?)*/;\n// Regex for Japanese phone numbers\nvar japanesePhoneRe = /(0([1-9]-?[1-9]\\d{3}|[1-9]{2}-?\\d{3}|[1-9]{2}\\d{1}-?\\d{2}|[1-9]{2}\\d{2}-?\\d{1})-?\\d{4}|0[789]0-?\\d{4}-?\\d{4}|050-?\\d{4}-?\\d{4})/;\n// Combined regex\nvar validPhoneNumberRe = new RegExp(\"^\".concat(mostPhoneNumbers.source, \"|\").concat(japanesePhoneRe.source, \"$\"));\n/**\n * Determines if the character is a phone number separator character (i.e.\n * '-', '.', or ' ' (space))\n */\nexport function isPhoneNumberSeparatorChar(charCode) {\n  return charCode === 45 /* Char.Dash */ ||\n  // '-'\n  charCode === 46 /* Char.Dot */ ||\n  // '.'\n  charCode === 32 /* Char.Space */ // ' '\n  ;\n}\n/**\n * Determines if the character is a control character in a phone number. Control\n * characters are as follows:\n *\n * - ',': A 1 second pause. Useful for dialing extensions once the main phone number has been reached\n * - ';': A \"wait\" that waits for the user to take action (tap something, for instance on a smart phone)\n */\nexport function isPhoneNumberControlChar(charCode) {\n  return charCode === 44 /* Char.Comma */ ||\n  // ','\n  charCode === 59 /* Char.SemiColon */ // ';'\n  ;\n}\n/**\n * Determines if the given phone number text found in a string is a valid phone\n * number.\n *\n * Our state machine parser is simplified to grab anything that looks like a\n * phone number, and this function confirms the match.\n */\nexport function isValidPhoneNumber(phoneNumberText) {\n  // We'll only consider the match as a phone number if there is some kind of\n  // delimiter character (a prefixed '+' sign, or separator chars).\n  //\n  // Accepts:\n  //     (123) 456-7890\n  //     +38755233976\n  // Does not accept:\n  //     1234567890  (no delimiter chars - may just be a random number that's not a phone number)\n  var hasDelimiters = phoneNumberText.charAt(0) === '+' || hasDelimCharsRe.test(phoneNumberText);\n  return hasDelimiters && validPhoneNumberRe.test(phoneNumberText);\n}","map":{"version":3,"names":["hasDelimCharsRe","mostPhoneNumbers","japanesePhoneRe","validPhoneNumberRe","RegExp","concat","source","isPhoneNumberSeparatorChar","charCode","isPhoneNumberControlChar","isValidPhoneNumber","phoneNumberText","hasDelimiters","charAt","test"],"sources":["../../../src/parser/phone-number-utils.ts"],"sourcesContent":["// Regex that specifies any delimiter char that allows us to treat the number as\n\nimport { Char } from '../char';\n\n// a phone number rather than just any other number that could appear in text.\nconst hasDelimCharsRe = /[-. ()]/;\n\n// Over the years, many people have added to this regex, but it should have been\n// split up by country. Maybe one day we can break this down.\nconst mostPhoneNumbers =\n    /(?:(?:(?:(\\+)?\\d{1,3}[-. ]?)?\\(?\\d{3}\\)?[-. ]?\\d{3}[-. ]?\\d{4})|(?:(\\+)(?:9[976]\\d|8[987530]\\d|6[987]\\d|5[90]\\d|42\\d|3[875]\\d|2[98654321]\\d|9[8543210]|8[6421]|6[6543210]|5[87654321]|4[987654310]|3[9643210]|2[70]|7|1)[-. ]?(?:\\d[-. ]?){6,12}\\d+))([,;]+[0-9]+#?)*/;\n\n// Regex for Japanese phone numbers\nconst japanesePhoneRe =\n    /(0([1-9]-?[1-9]\\d{3}|[1-9]{2}-?\\d{3}|[1-9]{2}\\d{1}-?\\d{2}|[1-9]{2}\\d{2}-?\\d{1})-?\\d{4}|0[789]0-?\\d{4}-?\\d{4}|050-?\\d{4}-?\\d{4})/;\n\n// Combined regex\nconst validPhoneNumberRe = new RegExp(`^${mostPhoneNumbers.source}|${japanesePhoneRe.source}$`);\n\n/**\n * Determines if the character is a phone number separator character (i.e.\n * '-', '.', or ' ' (space))\n */\nexport function isPhoneNumberSeparatorChar(charCode: number): boolean {\n    return (\n        charCode === Char.Dash || // '-'\n        charCode === Char.Dot || // '.'\n        charCode === Char.Space // ' '\n    );\n}\n\n/**\n * Determines if the character is a control character in a phone number. Control\n * characters are as follows:\n *\n * - ',': A 1 second pause. Useful for dialing extensions once the main phone number has been reached\n * - ';': A \"wait\" that waits for the user to take action (tap something, for instance on a smart phone)\n */\nexport function isPhoneNumberControlChar(charCode: number): boolean {\n    return (\n        charCode === Char.Comma || // ','\n        charCode === Char.SemiColon // ';'\n    );\n}\n\n/**\n * Determines if the given phone number text found in a string is a valid phone\n * number.\n *\n * Our state machine parser is simplified to grab anything that looks like a\n * phone number, and this function confirms the match.\n */\nexport function isValidPhoneNumber(phoneNumberText: string): boolean {\n    // We'll only consider the match as a phone number if there is some kind of\n    // delimiter character (a prefixed '+' sign, or separator chars).\n    //\n    // Accepts:\n    //     (123) 456-7890\n    //     +38755233976\n    // Does not accept:\n    //     1234567890  (no delimiter chars - may just be a random number that's not a phone number)\n    const hasDelimiters =\n        phoneNumberText.charAt(0) === '+' || hasDelimCharsRe.test(phoneNumberText);\n\n    return hasDelimiters && validPhoneNumberRe.test(phoneNumberText);\n}\n"],"mappings":"AAAA;AAIA;AACA,IAAMA,eAAe,GAAG,SAAS;AAEjC;AACA;AACA,IAAMC,gBAAgB,GAClB,uQAAuQ;AAE3Q;AACA,IAAMC,eAAe,GACjB,iIAAiI;AAErI;AACA,IAAMC,kBAAkB,GAAG,IAAIC,MAAM,CAAC,IAAAC,MAAA,CAAIJ,gBAAgB,CAACK,MAAM,OAAAD,MAAA,CAAIH,eAAe,CAACI,MAAM,MAAG,CAAC;AAE/F;;;;AAIA,OAAM,SAAUC,0BAA0BA,CAACC,QAAgB;EACvD,OACIA,QAAQ;EAAkB;EAC1BA,QAAQ;EAAiB;EACzBA,QAAQ,yBAAgB;EAAA;AAEhC;AAEA;;;;;;;AAOA,OAAM,SAAUC,wBAAwBA,CAACD,QAAgB;EACrD,OACIA,QAAQ;EAAmB;EAC3BA,QAAQ,6BAAoB;EAAA;AAEpC;AAEA;;;;;;;AAOA,OAAM,SAAUE,kBAAkBA,CAACC,eAAuB;EACtD;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAMC,aAAa,GACfD,eAAe,CAACE,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIb,eAAe,CAACc,IAAI,CAACH,eAAe,CAAC;EAE9E,OAAOC,aAAa,IAAIT,kBAAkB,CAACW,IAAI,CAACH,eAAe,CAAC;AACpE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}