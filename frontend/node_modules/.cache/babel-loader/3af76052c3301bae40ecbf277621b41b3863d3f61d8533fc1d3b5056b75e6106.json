{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Check from \"../Core/Check.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PolygonGeometry from \"../Core/PolygonGeometry.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\n\n/**\n * A geodesic polygon to be used with {@link ClippingPlaneCollection} for selectively hiding regions in a model, a 3D tileset, or the globe.\n * @alias ClippingPolygon\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions A list of three or more Cartesian coordinates defining the outer ring of the clipping polygon.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default]\n *\n * @example\n * const positions = Cesium.Cartesian3.fromRadiansArray([\n *     -1.3194369277314022,\n *     0.6988062530900625,\n *     -1.31941,\n *     0.69879,\n *     -1.3193955980204217,\n *     0.6988091578771254,\n *     -1.3193931220959367,\n *     0.698743632490865,\n *     -1.3194358224045408,\n *     0.6987471965556998,\n * ]);\n *\n * const polygon = new Cesium.ClippingPolygon({\n *     positions: positions\n * });\n */\nfunction ClippingPolygon(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.positions\", options.positions);\n  Check.typeOf.number.greaterThanOrEquals(\"options.positions.length\", options.positions.length, 3);\n  //>>includeEnd('debug');\n\n  this._ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n  this._positions = copyArrayCartesian3(options.positions);\n\n  /**\n   * A copy of the input positions.\n   *\n   * This is used to detect modifications of the positions in\n   * <code>coputeRectangle</code>: The rectangle only has\n   * to be re-computed when these positions have changed.\n   *\n   * @type {Cartesian3[]|undefined}\n   * @private\n   */\n  this._cachedPositions = undefined;\n\n  /**\n   * A cached version of the rectangle that is computed in\n   * <code>computeRectangle</code>.\n   *\n   * This is only re-computed when the positions have changed, as\n   * determined  by comparing the <code>_positions</code> to the\n   * <code>_cachedPositions</code>\n   *\n   * @type {Rectangle|undefined}\n   * @private\n   */\n  this._cachedRectangle = undefined;\n}\n\n/**\n * Returns a deep copy of the given array.\n *\n * If the input is undefined, then <code>undefined</code> is returned.\n *\n * Otherwise, the result will be a copy of the given array, where\n * each element is copied with <code>Cartesian3.clone</code>.\n *\n * @param {Cartesian3[]|undefined} input The input array\n * @returns {Cartesian3[]|undefined} The copy\n */\nfunction copyArrayCartesian3(input) {\n  if (!defined(input)) {\n    return undefined;\n  }\n  const n = input.length;\n  const output = Array(n);\n  for (let i = 0; i < n; i++) {\n    output[i] = Cartesian3.clone(input[i]);\n  }\n  return output;\n}\n\n/**\n * Returns whether the given arrays are component-wise equal.\n *\n * When both arrays are undefined, then <code>true</code> is returned.\n * When only one array is defined, or they are both defined but have\n * different lengths, then <code>false</code> is returned.\n *\n * Otherwise, returns whether the corresponding elements of the arrays\n * are equal, as of <code>Cartesian3.equals</code>.\n *\n * @param {Cartesian3[]|undefined} a The first array\n * @param {Cartesian3[]|undefined} b The second array\n * @returns {boolean} Whether the arrays are equal\n */\nfunction equalsArrayCartesian3(a, b) {\n  if (!defined(a) && !defined(b)) {\n    return true;\n  }\n  if (defined(a) !== defined(b)) {\n    return false;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  const n = a.length;\n  for (let i = 0; i < n; i++) {\n    const ca = a[i];\n    const cb = b[i];\n    if (!Cartesian3.equals(ca, cb)) {\n      return false;\n    }\n  }\n  return true;\n}\nObject.defineProperties(ClippingPolygon.prototype, {\n  /**\n   * Returns the total number of positions in the polygon, include any holes.\n   *\n   * @memberof ClippingPolygon.prototype\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._positions.length;\n    }\n  },\n  /**\n   * Returns the outer ring of positions.\n   *\n   * @memberof ClippingPolygon.prototype\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  positions: {\n    get: function () {\n      return this._positions;\n    }\n  },\n  /**\n   * Returns the ellipsoid used to project the polygon onto surfaces when clipping.\n   *\n   * @memberof ClippingPolygon.prototype\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    }\n  }\n});\n\n/**\n * Clones the ClippingPolygon without setting its ownership.\n * @param {ClippingPolygon} polygon The ClippingPolygon to be cloned\n * @param {ClippingPolygon} [result] The object on which to store the cloned parameters.\n * @returns {ClippingPolygon} a clone of the input ClippingPolygon\n */\nClippingPolygon.clone = function (polygon, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"polygon\", polygon);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new ClippingPolygon({\n      positions: polygon.positions,\n      ellipsoid: polygon.ellipsoid\n    });\n  }\n  result._ellipsoid = polygon.ellipsoid;\n  result._positions.length = 0;\n  result._positions.push(...polygon.positions);\n  return result;\n};\n\n/**\n * Compares the provided ClippingPolygons and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {ClippingPolygon} left The first polygon.\n * @param {ClippingPolygon} right The second polygon.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nClippingPolygon.equals = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.ellipsoid.equals(right.ellipsoid) && left.positions === right.positions;\n};\n\n/**\n * Computes a cartographic rectangle which encloses the polygon defined by the list of positions, including cases over the international date line and the poles.\n *\n * @param {Rectangle} [result] An object in which to store the result.\n * @returns {Rectangle} The result rectangle\n */\nClippingPolygon.prototype.computeRectangle = function (result) {\n  if (equalsArrayCartesian3(this._positions, this._cachedPositions)) {\n    return Rectangle.clone(this._cachedRectangle, result);\n  }\n  const rectangle = PolygonGeometry.computeRectangleFromPositions(this.positions, this.ellipsoid, undefined, result);\n  this._cachedPositions = copyArrayCartesian3(this._positions);\n  this._cachedRectangle = Rectangle.clone(rectangle);\n  return rectangle;\n};\nconst scratchRectangle = new Rectangle();\nconst spherePointScratch = new Cartesian3();\n/**\n * Computes a rectangle with the spherical extents that encloses the polygon defined by the list of positions, including cases over the international date line and the poles.\n *\n * @private\n *\n * @param {Rectangle} [result] An object in which to store the result.\n * @returns {Rectangle} The result rectangle with spherical extents.\n */\nClippingPolygon.prototype.computeSphericalExtents = function (result) {\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n  const rectangle = this.computeRectangle(scratchRectangle);\n  let spherePoint = Cartographic.toCartesian(Rectangle.southwest(rectangle), this.ellipsoid, spherePointScratch);\n\n  // Project into plane with vertical for latitude\n  let magXY = Math.sqrt(spherePoint.x * spherePoint.x + spherePoint.y * spherePoint.y);\n\n  // Use fastApproximateAtan2 for alignment with shader\n  let sphereLatitude = CesiumMath.fastApproximateAtan2(magXY, spherePoint.z);\n  let sphereLongitude = CesiumMath.fastApproximateAtan2(spherePoint.x, spherePoint.y);\n  result.south = sphereLatitude;\n  result.west = sphereLongitude;\n  spherePoint = Cartographic.toCartesian(Rectangle.northeast(rectangle), this.ellipsoid, spherePointScratch);\n\n  // Project into plane with vertical for latitude\n  magXY = Math.sqrt(spherePoint.x * spherePoint.x + spherePoint.y * spherePoint.y);\n\n  // Use fastApproximateAtan2 for alignment with shader\n  sphereLatitude = CesiumMath.fastApproximateAtan2(magXY, spherePoint.z);\n  sphereLongitude = CesiumMath.fastApproximateAtan2(spherePoint.x, spherePoint.y);\n  result.north = sphereLatitude;\n  result.east = sphereLongitude;\n  return result;\n};\nexport default ClippingPolygon;","map":{"version":3,"names":["Check","Cartesian3","Cartographic","defined","Ellipsoid","CesiumMath","PolygonGeometry","Rectangle","ClippingPolygon","options","typeOf","object","positions","number","greaterThanOrEquals","length","_ellipsoid","ellipsoid","default","_positions","copyArrayCartesian3","_cachedPositions","undefined","_cachedRectangle","input","n","output","Array","i","clone","equalsArrayCartesian3","a","b","ca","cb","equals","Object","defineProperties","prototype","get","polygon","result","push","left","right","computeRectangle","rectangle","computeRectangleFromPositions","scratchRectangle","spherePointScratch","computeSphericalExtents","spherePoint","toCartesian","southwest","magXY","Math","sqrt","x","y","sphereLatitude","fastApproximateAtan2","z","sphereLongitude","south","west","northeast","north","east"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/ClippingPolygon.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PolygonGeometry from \"../Core/PolygonGeometry.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\n\n/**\n * A geodesic polygon to be used with {@link ClippingPlaneCollection} for selectively hiding regions in a model, a 3D tileset, or the globe.\n * @alias ClippingPolygon\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions A list of three or more Cartesian coordinates defining the outer ring of the clipping polygon.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default]\n *\n * @example\n * const positions = Cesium.Cartesian3.fromRadiansArray([\n *     -1.3194369277314022,\n *     0.6988062530900625,\n *     -1.31941,\n *     0.69879,\n *     -1.3193955980204217,\n *     0.6988091578771254,\n *     -1.3193931220959367,\n *     0.698743632490865,\n *     -1.3194358224045408,\n *     0.6987471965556998,\n * ]);\n *\n * const polygon = new Cesium.ClippingPolygon({\n *     positions: positions\n * });\n */\nfunction ClippingPolygon(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.positions\", options.positions);\n  Check.typeOf.number.greaterThanOrEquals(\n    \"options.positions.length\",\n    options.positions.length,\n    3,\n  );\n  //>>includeEnd('debug');\n\n  this._ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n  this._positions = copyArrayCartesian3(options.positions);\n\n  /**\n   * A copy of the input positions.\n   *\n   * This is used to detect modifications of the positions in\n   * <code>coputeRectangle</code>: The rectangle only has\n   * to be re-computed when these positions have changed.\n   *\n   * @type {Cartesian3[]|undefined}\n   * @private\n   */\n  this._cachedPositions = undefined;\n\n  /**\n   * A cached version of the rectangle that is computed in\n   * <code>computeRectangle</code>.\n   *\n   * This is only re-computed when the positions have changed, as\n   * determined  by comparing the <code>_positions</code> to the\n   * <code>_cachedPositions</code>\n   *\n   * @type {Rectangle|undefined}\n   * @private\n   */\n  this._cachedRectangle = undefined;\n}\n\n/**\n * Returns a deep copy of the given array.\n *\n * If the input is undefined, then <code>undefined</code> is returned.\n *\n * Otherwise, the result will be a copy of the given array, where\n * each element is copied with <code>Cartesian3.clone</code>.\n *\n * @param {Cartesian3[]|undefined} input The input array\n * @returns {Cartesian3[]|undefined} The copy\n */\nfunction copyArrayCartesian3(input) {\n  if (!defined(input)) {\n    return undefined;\n  }\n  const n = input.length;\n  const output = Array(n);\n  for (let i = 0; i < n; i++) {\n    output[i] = Cartesian3.clone(input[i]);\n  }\n  return output;\n}\n\n/**\n * Returns whether the given arrays are component-wise equal.\n *\n * When both arrays are undefined, then <code>true</code> is returned.\n * When only one array is defined, or they are both defined but have\n * different lengths, then <code>false</code> is returned.\n *\n * Otherwise, returns whether the corresponding elements of the arrays\n * are equal, as of <code>Cartesian3.equals</code>.\n *\n * @param {Cartesian3[]|undefined} a The first array\n * @param {Cartesian3[]|undefined} b The second array\n * @returns {boolean} Whether the arrays are equal\n */\nfunction equalsArrayCartesian3(a, b) {\n  if (!defined(a) && !defined(b)) {\n    return true;\n  }\n  if (defined(a) !== defined(b)) {\n    return false;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  const n = a.length;\n  for (let i = 0; i < n; i++) {\n    const ca = a[i];\n    const cb = b[i];\n    if (!Cartesian3.equals(ca, cb)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nObject.defineProperties(ClippingPolygon.prototype, {\n  /**\n   * Returns the total number of positions in the polygon, include any holes.\n   *\n   * @memberof ClippingPolygon.prototype\n   * @type {number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._positions.length;\n    },\n  },\n  /**\n   * Returns the outer ring of positions.\n   *\n   * @memberof ClippingPolygon.prototype\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  positions: {\n    get: function () {\n      return this._positions;\n    },\n  },\n  /**\n   * Returns the ellipsoid used to project the polygon onto surfaces when clipping.\n   *\n   * @memberof ClippingPolygon.prototype\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n});\n\n/**\n * Clones the ClippingPolygon without setting its ownership.\n * @param {ClippingPolygon} polygon The ClippingPolygon to be cloned\n * @param {ClippingPolygon} [result] The object on which to store the cloned parameters.\n * @returns {ClippingPolygon} a clone of the input ClippingPolygon\n */\nClippingPolygon.clone = function (polygon, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"polygon\", polygon);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new ClippingPolygon({\n      positions: polygon.positions,\n      ellipsoid: polygon.ellipsoid,\n    });\n  }\n\n  result._ellipsoid = polygon.ellipsoid;\n  result._positions.length = 0;\n  result._positions.push(...polygon.positions);\n  return result;\n};\n\n/**\n * Compares the provided ClippingPolygons and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {ClippingPolygon} left The first polygon.\n * @param {ClippingPolygon} right The second polygon.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nClippingPolygon.equals = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return (\n    left.ellipsoid.equals(right.ellipsoid) && left.positions === right.positions\n  );\n};\n\n/**\n * Computes a cartographic rectangle which encloses the polygon defined by the list of positions, including cases over the international date line and the poles.\n *\n * @param {Rectangle} [result] An object in which to store the result.\n * @returns {Rectangle} The result rectangle\n */\nClippingPolygon.prototype.computeRectangle = function (result) {\n  if (equalsArrayCartesian3(this._positions, this._cachedPositions)) {\n    return Rectangle.clone(this._cachedRectangle, result);\n  }\n  const rectangle = PolygonGeometry.computeRectangleFromPositions(\n    this.positions,\n    this.ellipsoid,\n    undefined,\n    result,\n  );\n  this._cachedPositions = copyArrayCartesian3(this._positions);\n  this._cachedRectangle = Rectangle.clone(rectangle);\n  return rectangle;\n};\n\nconst scratchRectangle = new Rectangle();\nconst spherePointScratch = new Cartesian3();\n/**\n * Computes a rectangle with the spherical extents that encloses the polygon defined by the list of positions, including cases over the international date line and the poles.\n *\n * @private\n *\n * @param {Rectangle} [result] An object in which to store the result.\n * @returns {Rectangle} The result rectangle with spherical extents.\n */\nClippingPolygon.prototype.computeSphericalExtents = function (result) {\n  if (!defined(result)) {\n    result = new Rectangle();\n  }\n\n  const rectangle = this.computeRectangle(scratchRectangle);\n\n  let spherePoint = Cartographic.toCartesian(\n    Rectangle.southwest(rectangle),\n    this.ellipsoid,\n    spherePointScratch,\n  );\n\n  // Project into plane with vertical for latitude\n  let magXY = Math.sqrt(\n    spherePoint.x * spherePoint.x + spherePoint.y * spherePoint.y,\n  );\n\n  // Use fastApproximateAtan2 for alignment with shader\n  let sphereLatitude = CesiumMath.fastApproximateAtan2(magXY, spherePoint.z);\n  let sphereLongitude = CesiumMath.fastApproximateAtan2(\n    spherePoint.x,\n    spherePoint.y,\n  );\n\n  result.south = sphereLatitude;\n  result.west = sphereLongitude;\n\n  spherePoint = Cartographic.toCartesian(\n    Rectangle.northeast(rectangle),\n    this.ellipsoid,\n    spherePointScratch,\n  );\n\n  // Project into plane with vertical for latitude\n  magXY = Math.sqrt(\n    spherePoint.x * spherePoint.x + spherePoint.y * spherePoint.y,\n  );\n\n  // Use fastApproximateAtan2 for alignment with shader\n  sphereLatitude = CesiumMath.fastApproximateAtan2(magXY, spherePoint.z);\n  sphereLongitude = CesiumMath.fastApproximateAtan2(\n    spherePoint.x,\n    spherePoint.y,\n  );\n\n  result.north = sphereLatitude;\n  result.east = sphereLongitude;\n\n  return result;\n};\n\nexport default ClippingPolygon;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}