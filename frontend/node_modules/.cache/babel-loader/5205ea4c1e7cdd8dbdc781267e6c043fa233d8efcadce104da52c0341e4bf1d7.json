{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-hex.js\";\nimport \"core-js/modules/esnext.uint8-array.to-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.to-hex.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport Cesium3DTileFeatureTable from \"./Cesium3DTileFeatureTable.js\";\nimport VertexAttributeSemantic from \"./VertexAttributeSemantic.js\";\n\n/**\n * Handles parsing of a Point Cloud\n *\n * @namespace PntsParser\n * @private\n */\nconst PntsParser = {};\nconst sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\n\n/**\n * Parses the contents of a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/PointCloud|Point Cloud}.\n *\n * @private\n *\n * @param {*} arrayBuffer The array buffer containing the pnts\n * @param {*} [byteOffset=0] The byte offset of the beginning of the pnts in the array buffer\n * @returns {object} An object containing a parsed representation of the point cloud\n */\nPntsParser.parse = function (arrayBuffer, byteOffset) {\n  byteOffset = byteOffset ?? 0;\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"arrayBuffer\", arrayBuffer);\n  //>>includeEnd('debug');\n\n  const uint8Array = new Uint8Array(arrayBuffer);\n  const view = new DataView(arrayBuffer);\n  byteOffset += sizeOfUint32; // Skip magic\n\n  const version = view.getUint32(byteOffset, true);\n  if (version !== 1) {\n    throw new RuntimeError(`Only Point Cloud tile version 1 is supported.  Version ${version} is not.`);\n  }\n  byteOffset += sizeOfUint32;\n\n  // Skip byteLength\n  byteOffset += sizeOfUint32;\n  const featureTableJsonByteLength = view.getUint32(byteOffset, true);\n  if (featureTableJsonByteLength === 0) {\n    throw new RuntimeError(\"Feature table must have a byte length greater than zero\");\n  }\n  byteOffset += sizeOfUint32;\n  const featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const batchTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const featureTableJson = getJsonFromTypedArray(uint8Array, byteOffset, featureTableJsonByteLength);\n  byteOffset += featureTableJsonByteLength;\n  const featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);\n  byteOffset += featureTableBinaryByteLength;\n\n  // Get the batch table JSON and binary\n  let batchTableJson;\n  let batchTableBinary;\n  if (batchTableJsonByteLength > 0) {\n    // Has a batch table JSON\n    batchTableJson = getJsonFromTypedArray(uint8Array, byteOffset, batchTableJsonByteLength);\n    if (Object.keys(batchTableJson).length === 0) {\n      batchTableJson = undefined;\n    }\n    byteOffset += batchTableJsonByteLength;\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength);\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n      byteOffset += batchTableBinaryByteLength;\n    }\n  }\n  const featureTable = new Cesium3DTileFeatureTable(featureTableJson, featureTableBinary);\n  const pointsLength = featureTable.getGlobalProperty(\"POINTS_LENGTH\");\n  featureTable.featuresLength = pointsLength;\n  if (!defined(pointsLength)) {\n    throw new RuntimeError(\"Feature table global property: POINTS_LENGTH must be defined\");\n  }\n  let rtcCenter = featureTable.getGlobalProperty(\"RTC_CENTER\", ComponentDatatype.FLOAT, 3);\n  if (defined(rtcCenter)) {\n    rtcCenter = Cartesian3.unpack(rtcCenter);\n  }\n\n  // Start with the draco compressed properties and add in uncompressed\n  // properties.\n  const parsedContent = parseDracoProperties(featureTable, batchTableJson);\n  parsedContent.rtcCenter = rtcCenter;\n  parsedContent.pointsLength = pointsLength;\n  if (!parsedContent.hasPositions) {\n    const positions = parsePositions(featureTable);\n    parsedContent.positions = positions;\n    parsedContent.hasPositions = parsedContent.hasPositions || defined(positions);\n  }\n  if (!parsedContent.hasPositions) {\n    throw new RuntimeError(\"Either POSITION or POSITION_QUANTIZED must be defined.\");\n  }\n  if (!parsedContent.hasNormals) {\n    const normals = parseNormals(featureTable);\n    parsedContent.normals = normals;\n    parsedContent.hasNormals = parsedContent.hasNormals || defined(normals);\n  }\n  if (!parsedContent.hasColors) {\n    const colors = parseColors(featureTable);\n    parsedContent.colors = colors;\n    parsedContent.hasColors = parsedContent.hasColors || defined(colors);\n    parsedContent.hasConstantColor = defined(parsedContent.constantColor);\n    parsedContent.isTranslucent = defined(colors) && colors.isTranslucent;\n  }\n  if (!parsedContent.hasBatchIds) {\n    const batchIds = parseBatchIds(featureTable);\n    parsedContent.batchIds = batchIds;\n    parsedContent.hasBatchIds = parsedContent.hasBatchIds || defined(batchIds);\n  }\n  if (parsedContent.hasBatchIds) {\n    const batchLength = featureTable.getGlobalProperty(\"BATCH_LENGTH\");\n    if (!defined(batchLength)) {\n      throw new RuntimeError(\"Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.\");\n    }\n    parsedContent.batchLength = batchLength;\n  }\n  if (defined(batchTableJson) || defined(batchTableBinary)) {\n    parsedContent.batchTableJson = batchTableJson;\n    parsedContent.batchTableBinary = batchTableBinary;\n  }\n\n  // Handle the case that binary body references are contained in the\n  // batch table without a batch table binary being present\n  removeInvalidBinaryBodyReferences(parsedContent);\n  return parsedContent;\n};\n\n/**\n * Remove all invalid binary body references from the batch table\n * JSON of the given parsed content.\n *\n * This is a workaround for gracefully handling the invalid PNTS\n * files that may have been created by the point cloud tiler.\n * See https://github.com/CesiumGS/cesium/issues/12872\n *\n * When the batch table JSON is undefined, nothing will be done.\n * When the batch table binary is defined, nothing will be done\n * (assuming that any binary body references are valid - this is\n * not checked here).\n *\n * Otherwise, this will remove all binary body references from the\n * batch table JSON that are not resolved from draco via the\n * `parsedContent.draco.batchTableProperties`.\n *\n * If any (invalid) binary body reference is found (and removed),\n * a one-time warning will be printed.\n *\n * @param {object} parsedContent The parsed content\n */\nfunction removeInvalidBinaryBodyReferences(parsedContent) {\n  const batchTableJson = parsedContent.batchTableJson;\n  if (!defined(batchTableJson)) {\n    return;\n  }\n  const batchTableBinary = parsedContent.batchTableBinary;\n  if (defined(batchTableBinary)) {\n    return;\n  }\n  const dracoBatchTablePropertyNames = Object.keys(parsedContent.draco?.batchTableProperties ?? {});\n\n  // Collect the names of all binary body references (identified\n  // by the property having a `byteOffset`) that have not been\n  // resolved via the parsedContent.draco.batchTableProperties\n  const invalidBinaryBodyReferenceNames = [];\n  for (const name of Object.keys(batchTableJson)) {\n    const property = batchTableJson[name];\n    const byteOffset = property.byteOffset;\n    if (defined(byteOffset)) {\n      if (!dracoBatchTablePropertyNames.includes(name)) {\n        invalidBinaryBodyReferenceNames.push(name);\n      }\n    }\n  }\n\n  // If there have been invalid binary body references, print\n  // a one-time warning for each of them, and delete them.\n  for (const name of invalidBinaryBodyReferenceNames) {\n    oneTimeWarning(`PntsParser-invalidBinaryBodyReference`, `The point cloud data contained a binary property ${name} that could not be resolved - skipping`);\n    delete batchTableJson[name];\n  }\n}\nfunction parseDracoProperties(featureTable, batchTableJson) {\n  const featureTableJson = featureTable.json;\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n  const featureTableDraco = defined(featureTableJson.extensions) ? featureTableJson.extensions[\"3DTILES_draco_point_compression\"] : undefined;\n  const batchTableDraco = defined(batchTableJson) && defined(batchTableJson.extensions) ? batchTableJson.extensions[\"3DTILES_draco_point_compression\"] : undefined;\n  if (defined(batchTableDraco)) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n  let hasPositions;\n  let hasColors;\n  let hasNormals;\n  let hasBatchIds;\n  let isTranslucent;\n  if (defined(featureTableDraco)) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (!defined(dracoFeatureTableProperties) || !defined(dracoByteOffset) || !defined(dracoByteLength)) {\n      throw new RuntimeError(\"Draco properties, byteOffset, and byteLength must be defined\");\n    }\n    dracoBuffer = featureTable.buffer.slice(dracoByteOffset, dracoByteOffset + dracoByteLength);\n    hasPositions = defined(dracoFeatureTableProperties.POSITION);\n    hasColors = defined(dracoFeatureTableProperties.RGB) || defined(dracoFeatureTableProperties.RGBA);\n    hasNormals = defined(dracoFeatureTableProperties.NORMAL);\n    hasBatchIds = defined(dracoFeatureTableProperties.BATCH_ID);\n    isTranslucent = defined(dracoFeatureTableProperties.RGBA);\n  }\n  let draco;\n  if (defined(dracoBuffer)) {\n    draco = {\n      buffer: dracoBuffer,\n      featureTableProperties: dracoFeatureTableProperties,\n      batchTableProperties: dracoBatchTableProperties,\n      properties: combine(dracoFeatureTableProperties, dracoBatchTableProperties),\n      dequantizeInShader: true\n    };\n  }\n  return {\n    draco: draco,\n    hasPositions: hasPositions,\n    hasColors: hasColors,\n    isTranslucent: isTranslucent,\n    hasNormals: hasNormals,\n    hasBatchIds: hasBatchIds\n  };\n}\nfunction parsePositions(featureTable) {\n  const featureTableJson = featureTable.json;\n  let positions;\n  if (defined(featureTableJson.POSITION)) {\n    positions = featureTable.getPropertyArray(\"POSITION\", ComponentDatatype.FLOAT, 3);\n    return {\n      name: VertexAttributeSemantic.POSITION,\n      semantic: VertexAttributeSemantic.POSITION,\n      typedArray: positions,\n      isQuantized: false,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3\n    };\n  } else if (defined(featureTableJson.POSITION_QUANTIZED)) {\n    positions = featureTable.getPropertyArray(\"POSITION_QUANTIZED\", ComponentDatatype.UNSIGNED_SHORT, 3);\n    const quantizedVolumeScale = featureTable.getGlobalProperty(\"QUANTIZED_VOLUME_SCALE\", ComponentDatatype.FLOAT, 3);\n    if (!defined(quantizedVolumeScale)) {\n      throw new RuntimeError(\"Global property: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\");\n    }\n    const quantizedRange = (1 << 16) - 1;\n    const quantizedVolumeOffset = featureTable.getGlobalProperty(\"QUANTIZED_VOLUME_OFFSET\", ComponentDatatype.FLOAT, 3);\n    if (!defined(quantizedVolumeOffset)) {\n      throw new RuntimeError(\"Global property: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\");\n    }\n    return {\n      name: VertexAttributeSemantic.POSITION,\n      semantic: VertexAttributeSemantic.POSITION,\n      typedArray: positions,\n      isQuantized: true,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n      quantizedRange: quantizedRange,\n      quantizedVolumeOffset: Cartesian3.unpack(quantizedVolumeOffset),\n      quantizedVolumeScale: Cartesian3.unpack(quantizedVolumeScale),\n      quantizedComponentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n      quantizedType: AttributeType.VEC3\n    };\n  }\n}\nfunction parseColors(featureTable) {\n  const featureTableJson = featureTable.json;\n  let colors;\n  if (defined(featureTableJson.RGBA)) {\n    colors = featureTable.getPropertyArray(\"RGBA\", ComponentDatatype.UNSIGNED_BYTE, 4);\n    return {\n      name: VertexAttributeSemantic.COLOR,\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: colors,\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      type: AttributeType.VEC4,\n      normalized: true,\n      isRGB565: false,\n      isTranslucent: true\n    };\n  } else if (defined(featureTableJson.RGB)) {\n    colors = featureTable.getPropertyArray(\"RGB\", ComponentDatatype.UNSIGNED_BYTE, 3);\n    return {\n      name: \"COLOR\",\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: colors,\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      type: AttributeType.VEC3,\n      normalized: true,\n      isRGB565: false,\n      isTranslucent: false\n    };\n  } else if (defined(featureTableJson.RGB565)) {\n    colors = featureTable.getPropertyArray(\"RGB565\", ComponentDatatype.UNSIGNED_SHORT, 1);\n    return {\n      name: \"COLOR\",\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: colors,\n      // These settings are for the Model implementation\n      // which decodes on the CPU and uploads a VEC3 of float colors.\n      // PointCloud does the decoding on the GPU so uploads a\n      // UNSIGNED_SHORT instead.\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n      normalized: false,\n      isRGB565: true,\n      isTranslucent: false\n    };\n  } else if (defined(featureTableJson.CONSTANT_RGBA)) {\n    const constantRGBA = featureTable.getGlobalProperty(\"CONSTANT_RGBA\", ComponentDatatype.UNSIGNED_BYTE, 4);\n    const alpha = constantRGBA[3];\n    const constantColor = Color.fromBytes(constantRGBA[0], constantRGBA[1], constantRGBA[2], alpha);\n    const isTranslucent = alpha < 255;\n    return {\n      name: VertexAttributeSemantic.COLOR,\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      constantColor: constantColor,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC4,\n      isQuantized: false,\n      isTranslucent: isTranslucent\n    };\n  }\n  return undefined;\n}\nfunction parseNormals(featureTable) {\n  const featureTableJson = featureTable.json;\n  let normals;\n  if (defined(featureTableJson.NORMAL)) {\n    normals = featureTable.getPropertyArray(\"NORMAL\", ComponentDatatype.FLOAT, 3);\n    return {\n      name: VertexAttributeSemantic.NORMAL,\n      semantic: VertexAttributeSemantic.NORMAL,\n      typedArray: normals,\n      octEncoded: false,\n      octEncodedZXY: false,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3\n    };\n  } else if (defined(featureTableJson.NORMAL_OCT16P)) {\n    normals = featureTable.getPropertyArray(\"NORMAL_OCT16P\", ComponentDatatype.UNSIGNED_BYTE, 2);\n    const quantizationBits = 8;\n    return {\n      name: VertexAttributeSemantic.NORMAL,\n      semantic: VertexAttributeSemantic.NORMAL,\n      typedArray: normals,\n      octEncoded: true,\n      octEncodedZXY: false,\n      quantizedRange: (1 << quantizationBits) - 1,\n      quantizedType: AttributeType.VEC2,\n      quantizedComponentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3\n    };\n  }\n  return undefined;\n}\nfunction parseBatchIds(featureTable) {\n  const featureTableJson = featureTable.json;\n  if (defined(featureTableJson.BATCH_ID)) {\n    const batchIds = featureTable.getPropertyArray(\"BATCH_ID\", ComponentDatatype.UNSIGNED_SHORT, 1);\n    return {\n      name: VertexAttributeSemantic.FEATURE_ID,\n      semantic: VertexAttributeSemantic.FEATURE_ID,\n      setIndex: 0,\n      typedArray: batchIds,\n      componentDatatype: ComponentDatatype.fromTypedArray(batchIds),\n      type: AttributeType.SCALAR\n    };\n  }\n  return undefined;\n}\nexport default PntsParser;","map":{"version":3,"names":["Cartesian3","Check","Color","combine","ComponentDatatype","defined","getJsonFromTypedArray","oneTimeWarning","RuntimeError","AttributeType","Cesium3DTileFeatureTable","VertexAttributeSemantic","PntsParser","sizeOfUint32","Uint32Array","BYTES_PER_ELEMENT","parse","arrayBuffer","byteOffset","uint8Array","Uint8Array","view","DataView","version","getUint32","featureTableJsonByteLength","featureTableBinaryByteLength","batchTableJsonByteLength","batchTableBinaryByteLength","featureTableJson","featureTableBinary","batchTableJson","batchTableBinary","Object","keys","length","undefined","featureTable","pointsLength","getGlobalProperty","featuresLength","rtcCenter","FLOAT","unpack","parsedContent","parseDracoProperties","hasPositions","positions","parsePositions","hasNormals","normals","parseNormals","hasColors","colors","parseColors","hasConstantColor","constantColor","isTranslucent","hasBatchIds","batchIds","parseBatchIds","batchLength","removeInvalidBinaryBodyReferences","dracoBatchTablePropertyNames","draco","batchTableProperties","invalidBinaryBodyReferenceNames","name","property","includes","push","json","dracoBuffer","dracoFeatureTableProperties","dracoBatchTableProperties","featureTableDraco","extensions","batchTableDraco","properties","dracoByteOffset","dracoByteLength","byteLength","buffer","slice","POSITION","RGB","RGBA","NORMAL","BATCH_ID","featureTableProperties","dequantizeInShader","getPropertyArray","semantic","typedArray","isQuantized","componentDatatype","type","VEC3","POSITION_QUANTIZED","UNSIGNED_SHORT","quantizedVolumeScale","quantizedRange","quantizedVolumeOffset","quantizedComponentDatatype","quantizedType","UNSIGNED_BYTE","COLOR","setIndex","VEC4","normalized","isRGB565","RGB565","CONSTANT_RGBA","constantRGBA","alpha","fromBytes","octEncoded","octEncodedZXY","NORMAL_OCT16P","quantizationBits","VEC2","FEATURE_ID","fromTypedArray","SCALAR"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/PntsParser.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport Cesium3DTileFeatureTable from \"./Cesium3DTileFeatureTable.js\";\nimport VertexAttributeSemantic from \"./VertexAttributeSemantic.js\";\n\n/**\n * Handles parsing of a Point Cloud\n *\n * @namespace PntsParser\n * @private\n */\nconst PntsParser = {};\n\nconst sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\n\n/**\n * Parses the contents of a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/PointCloud|Point Cloud}.\n *\n * @private\n *\n * @param {*} arrayBuffer The array buffer containing the pnts\n * @param {*} [byteOffset=0] The byte offset of the beginning of the pnts in the array buffer\n * @returns {object} An object containing a parsed representation of the point cloud\n */\nPntsParser.parse = function (arrayBuffer, byteOffset) {\n  byteOffset = byteOffset ?? 0;\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"arrayBuffer\", arrayBuffer);\n  //>>includeEnd('debug');\n\n  const uint8Array = new Uint8Array(arrayBuffer);\n  const view = new DataView(arrayBuffer);\n  byteOffset += sizeOfUint32; // Skip magic\n\n  const version = view.getUint32(byteOffset, true);\n  if (version !== 1) {\n    throw new RuntimeError(\n      `Only Point Cloud tile version 1 is supported.  Version ${version} is not.`,\n    );\n  }\n  byteOffset += sizeOfUint32;\n\n  // Skip byteLength\n  byteOffset += sizeOfUint32;\n\n  const featureTableJsonByteLength = view.getUint32(byteOffset, true);\n  if (featureTableJsonByteLength === 0) {\n    throw new RuntimeError(\n      \"Feature table must have a byte length greater than zero\",\n    );\n  }\n  byteOffset += sizeOfUint32;\n\n  const featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  const batchTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  const featureTableJson = getJsonFromTypedArray(\n    uint8Array,\n    byteOffset,\n    featureTableJsonByteLength,\n  );\n  byteOffset += featureTableJsonByteLength;\n\n  const featureTableBinary = new Uint8Array(\n    arrayBuffer,\n    byteOffset,\n    featureTableBinaryByteLength,\n  );\n  byteOffset += featureTableBinaryByteLength;\n\n  // Get the batch table JSON and binary\n  let batchTableJson;\n  let batchTableBinary;\n  if (batchTableJsonByteLength > 0) {\n    // Has a batch table JSON\n    batchTableJson = getJsonFromTypedArray(\n      uint8Array,\n      byteOffset,\n      batchTableJsonByteLength,\n    );\n    if (Object.keys(batchTableJson).length === 0) {\n      batchTableJson = undefined;\n    }\n    byteOffset += batchTableJsonByteLength;\n\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      batchTableBinary = new Uint8Array(\n        arrayBuffer,\n        byteOffset,\n        batchTableBinaryByteLength,\n      );\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n      byteOffset += batchTableBinaryByteLength;\n    }\n  }\n\n  const featureTable = new Cesium3DTileFeatureTable(\n    featureTableJson,\n    featureTableBinary,\n  );\n\n  const pointsLength = featureTable.getGlobalProperty(\"POINTS_LENGTH\");\n  featureTable.featuresLength = pointsLength;\n\n  if (!defined(pointsLength)) {\n    throw new RuntimeError(\n      \"Feature table global property: POINTS_LENGTH must be defined\",\n    );\n  }\n\n  let rtcCenter = featureTable.getGlobalProperty(\n    \"RTC_CENTER\",\n    ComponentDatatype.FLOAT,\n    3,\n  );\n  if (defined(rtcCenter)) {\n    rtcCenter = Cartesian3.unpack(rtcCenter);\n  }\n\n  // Start with the draco compressed properties and add in uncompressed\n  // properties.\n  const parsedContent = parseDracoProperties(featureTable, batchTableJson);\n  parsedContent.rtcCenter = rtcCenter;\n  parsedContent.pointsLength = pointsLength;\n\n  if (!parsedContent.hasPositions) {\n    const positions = parsePositions(featureTable);\n    parsedContent.positions = positions;\n    parsedContent.hasPositions =\n      parsedContent.hasPositions || defined(positions);\n  }\n\n  if (!parsedContent.hasPositions) {\n    throw new RuntimeError(\n      \"Either POSITION or POSITION_QUANTIZED must be defined.\",\n    );\n  }\n\n  if (!parsedContent.hasNormals) {\n    const normals = parseNormals(featureTable);\n    parsedContent.normals = normals;\n    parsedContent.hasNormals = parsedContent.hasNormals || defined(normals);\n  }\n\n  if (!parsedContent.hasColors) {\n    const colors = parseColors(featureTable);\n    parsedContent.colors = colors;\n    parsedContent.hasColors = parsedContent.hasColors || defined(colors);\n    parsedContent.hasConstantColor = defined(parsedContent.constantColor);\n    parsedContent.isTranslucent = defined(colors) && colors.isTranslucent;\n  }\n\n  if (!parsedContent.hasBatchIds) {\n    const batchIds = parseBatchIds(featureTable);\n    parsedContent.batchIds = batchIds;\n    parsedContent.hasBatchIds = parsedContent.hasBatchIds || defined(batchIds);\n  }\n\n  if (parsedContent.hasBatchIds) {\n    const batchLength = featureTable.getGlobalProperty(\"BATCH_LENGTH\");\n    if (!defined(batchLength)) {\n      throw new RuntimeError(\n        \"Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.\",\n      );\n    }\n    parsedContent.batchLength = batchLength;\n  }\n\n  if (defined(batchTableJson) || defined(batchTableBinary)) {\n    parsedContent.batchTableJson = batchTableJson;\n    parsedContent.batchTableBinary = batchTableBinary;\n  }\n\n  // Handle the case that binary body references are contained in the\n  // batch table without a batch table binary being present\n  removeInvalidBinaryBodyReferences(parsedContent);\n\n  return parsedContent;\n};\n\n/**\n * Remove all invalid binary body references from the batch table\n * JSON of the given parsed content.\n *\n * This is a workaround for gracefully handling the invalid PNTS\n * files that may have been created by the point cloud tiler.\n * See https://github.com/CesiumGS/cesium/issues/12872\n *\n * When the batch table JSON is undefined, nothing will be done.\n * When the batch table binary is defined, nothing will be done\n * (assuming that any binary body references are valid - this is\n * not checked here).\n *\n * Otherwise, this will remove all binary body references from the\n * batch table JSON that are not resolved from draco via the\n * `parsedContent.draco.batchTableProperties`.\n *\n * If any (invalid) binary body reference is found (and removed),\n * a one-time warning will be printed.\n *\n * @param {object} parsedContent The parsed content\n */\nfunction removeInvalidBinaryBodyReferences(parsedContent) {\n  const batchTableJson = parsedContent.batchTableJson;\n  if (!defined(batchTableJson)) {\n    return;\n  }\n  const batchTableBinary = parsedContent.batchTableBinary;\n  if (defined(batchTableBinary)) {\n    return;\n  }\n  const dracoBatchTablePropertyNames = Object.keys(\n    parsedContent.draco?.batchTableProperties ?? {},\n  );\n\n  // Collect the names of all binary body references (identified\n  // by the property having a `byteOffset`) that have not been\n  // resolved via the parsedContent.draco.batchTableProperties\n  const invalidBinaryBodyReferenceNames = [];\n  for (const name of Object.keys(batchTableJson)) {\n    const property = batchTableJson[name];\n    const byteOffset = property.byteOffset;\n    if (defined(byteOffset)) {\n      if (!dracoBatchTablePropertyNames.includes(name)) {\n        invalidBinaryBodyReferenceNames.push(name);\n      }\n    }\n  }\n\n  // If there have been invalid binary body references, print\n  // a one-time warning for each of them, and delete them.\n  for (const name of invalidBinaryBodyReferenceNames) {\n    oneTimeWarning(\n      `PntsParser-invalidBinaryBodyReference`,\n      `The point cloud data contained a binary property ${name} that could not be resolved - skipping`,\n    );\n    delete batchTableJson[name];\n  }\n}\n\nfunction parseDracoProperties(featureTable, batchTableJson) {\n  const featureTableJson = featureTable.json;\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n\n  const featureTableDraco = defined(featureTableJson.extensions)\n    ? featureTableJson.extensions[\"3DTILES_draco_point_compression\"]\n    : undefined;\n  const batchTableDraco =\n    defined(batchTableJson) && defined(batchTableJson.extensions)\n      ? batchTableJson.extensions[\"3DTILES_draco_point_compression\"]\n      : undefined;\n\n  if (defined(batchTableDraco)) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  let hasPositions;\n  let hasColors;\n  let hasNormals;\n  let hasBatchIds;\n  let isTranslucent;\n  if (defined(featureTableDraco)) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (\n      !defined(dracoFeatureTableProperties) ||\n      !defined(dracoByteOffset) ||\n      !defined(dracoByteLength)\n    ) {\n      throw new RuntimeError(\n        \"Draco properties, byteOffset, and byteLength must be defined\",\n      );\n    }\n    dracoBuffer = featureTable.buffer.slice(\n      dracoByteOffset,\n      dracoByteOffset + dracoByteLength,\n    );\n    hasPositions = defined(dracoFeatureTableProperties.POSITION);\n    hasColors =\n      defined(dracoFeatureTableProperties.RGB) ||\n      defined(dracoFeatureTableProperties.RGBA);\n    hasNormals = defined(dracoFeatureTableProperties.NORMAL);\n    hasBatchIds = defined(dracoFeatureTableProperties.BATCH_ID);\n    isTranslucent = defined(dracoFeatureTableProperties.RGBA);\n  }\n\n  let draco;\n  if (defined(dracoBuffer)) {\n    draco = {\n      buffer: dracoBuffer,\n      featureTableProperties: dracoFeatureTableProperties,\n      batchTableProperties: dracoBatchTableProperties,\n      properties: combine(\n        dracoFeatureTableProperties,\n        dracoBatchTableProperties,\n      ),\n      dequantizeInShader: true,\n    };\n  }\n\n  return {\n    draco: draco,\n    hasPositions: hasPositions,\n    hasColors: hasColors,\n    isTranslucent: isTranslucent,\n    hasNormals: hasNormals,\n    hasBatchIds: hasBatchIds,\n  };\n}\n\nfunction parsePositions(featureTable) {\n  const featureTableJson = featureTable.json;\n\n  let positions;\n  if (defined(featureTableJson.POSITION)) {\n    positions = featureTable.getPropertyArray(\n      \"POSITION\",\n      ComponentDatatype.FLOAT,\n      3,\n    );\n\n    return {\n      name: VertexAttributeSemantic.POSITION,\n      semantic: VertexAttributeSemantic.POSITION,\n      typedArray: positions,\n      isQuantized: false,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n    };\n  } else if (defined(featureTableJson.POSITION_QUANTIZED)) {\n    positions = featureTable.getPropertyArray(\n      \"POSITION_QUANTIZED\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      3,\n    );\n\n    const quantizedVolumeScale = featureTable.getGlobalProperty(\n      \"QUANTIZED_VOLUME_SCALE\",\n      ComponentDatatype.FLOAT,\n      3,\n    );\n    if (!defined(quantizedVolumeScale)) {\n      throw new RuntimeError(\n        \"Global property: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\",\n      );\n    }\n    const quantizedRange = (1 << 16) - 1;\n\n    const quantizedVolumeOffset = featureTable.getGlobalProperty(\n      \"QUANTIZED_VOLUME_OFFSET\",\n      ComponentDatatype.FLOAT,\n      3,\n    );\n    if (!defined(quantizedVolumeOffset)) {\n      throw new RuntimeError(\n        \"Global property: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\",\n      );\n    }\n\n    return {\n      name: VertexAttributeSemantic.POSITION,\n      semantic: VertexAttributeSemantic.POSITION,\n      typedArray: positions,\n      isQuantized: true,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n      quantizedRange: quantizedRange,\n      quantizedVolumeOffset: Cartesian3.unpack(quantizedVolumeOffset),\n      quantizedVolumeScale: Cartesian3.unpack(quantizedVolumeScale),\n      quantizedComponentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n      quantizedType: AttributeType.VEC3,\n    };\n  }\n}\n\nfunction parseColors(featureTable) {\n  const featureTableJson = featureTable.json;\n\n  let colors;\n  if (defined(featureTableJson.RGBA)) {\n    colors = featureTable.getPropertyArray(\n      \"RGBA\",\n      ComponentDatatype.UNSIGNED_BYTE,\n      4,\n    );\n    return {\n      name: VertexAttributeSemantic.COLOR,\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: colors,\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      type: AttributeType.VEC4,\n      normalized: true,\n      isRGB565: false,\n      isTranslucent: true,\n    };\n  } else if (defined(featureTableJson.RGB)) {\n    colors = featureTable.getPropertyArray(\n      \"RGB\",\n      ComponentDatatype.UNSIGNED_BYTE,\n      3,\n    );\n    return {\n      name: \"COLOR\",\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: colors,\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      type: AttributeType.VEC3,\n      normalized: true,\n      isRGB565: false,\n      isTranslucent: false,\n    };\n  } else if (defined(featureTableJson.RGB565)) {\n    colors = featureTable.getPropertyArray(\n      \"RGB565\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      1,\n    );\n    return {\n      name: \"COLOR\",\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: colors,\n      // These settings are for the Model implementation\n      // which decodes on the CPU and uploads a VEC3 of float colors.\n      // PointCloud does the decoding on the GPU so uploads a\n      // UNSIGNED_SHORT instead.\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n      normalized: false,\n      isRGB565: true,\n      isTranslucent: false,\n    };\n  } else if (defined(featureTableJson.CONSTANT_RGBA)) {\n    const constantRGBA = featureTable.getGlobalProperty(\n      \"CONSTANT_RGBA\",\n      ComponentDatatype.UNSIGNED_BYTE,\n      4,\n    );\n\n    const alpha = constantRGBA[3];\n    const constantColor = Color.fromBytes(\n      constantRGBA[0],\n      constantRGBA[1],\n      constantRGBA[2],\n      alpha,\n    );\n\n    const isTranslucent = alpha < 255;\n    return {\n      name: VertexAttributeSemantic.COLOR,\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      constantColor: constantColor,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC4,\n      isQuantized: false,\n      isTranslucent: isTranslucent,\n    };\n  }\n\n  return undefined;\n}\n\nfunction parseNormals(featureTable) {\n  const featureTableJson = featureTable.json;\n  let normals;\n  if (defined(featureTableJson.NORMAL)) {\n    normals = featureTable.getPropertyArray(\n      \"NORMAL\",\n      ComponentDatatype.FLOAT,\n      3,\n    );\n    return {\n      name: VertexAttributeSemantic.NORMAL,\n      semantic: VertexAttributeSemantic.NORMAL,\n      typedArray: normals,\n      octEncoded: false,\n      octEncodedZXY: false,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n    };\n  } else if (defined(featureTableJson.NORMAL_OCT16P)) {\n    normals = featureTable.getPropertyArray(\n      \"NORMAL_OCT16P\",\n      ComponentDatatype.UNSIGNED_BYTE,\n      2,\n    );\n    const quantizationBits = 8;\n    return {\n      name: VertexAttributeSemantic.NORMAL,\n      semantic: VertexAttributeSemantic.NORMAL,\n      typedArray: normals,\n      octEncoded: true,\n      octEncodedZXY: false,\n      quantizedRange: (1 << quantizationBits) - 1,\n      quantizedType: AttributeType.VEC2,\n      quantizedComponentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n    };\n  }\n\n  return undefined;\n}\n\nfunction parseBatchIds(featureTable) {\n  const featureTableJson = featureTable.json;\n  if (defined(featureTableJson.BATCH_ID)) {\n    const batchIds = featureTable.getPropertyArray(\n      \"BATCH_ID\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      1,\n    );\n    return {\n      name: VertexAttributeSemantic.FEATURE_ID,\n      semantic: VertexAttributeSemantic.FEATURE_ID,\n      setIndex: 0,\n      typedArray: batchIds,\n      componentDatatype: ComponentDatatype.fromTypedArray(batchIds),\n      type: AttributeType.SCALAR,\n    };\n  }\n\n  return undefined;\n}\n\nexport default PntsParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}