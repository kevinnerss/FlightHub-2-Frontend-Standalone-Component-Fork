{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport ArcType from \"../Core/ArcType.js\";\nimport AssociativeArray from \"../Core/AssociativeArray.js\";\nimport BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport buildModuleUrl from \"../Core/buildModuleUrl.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport ClockRange from \"../Core/ClockRange.js\";\nimport ClockStep from \"../Core/ClockStep.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport Credit from \"../Core/Credit.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defer from \"../Core/defer.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Event from \"../Core/Event.js\";\nimport getExtensionFromUri from \"../Core/getExtensionFromUri.js\";\nimport getFilenameFromUri from \"../Core/getFilenameFromUri.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport HeadingPitchRange from \"../Core/HeadingPitchRange.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport objectToQuery from \"../Core/objectToQuery.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport PinBuilder from \"../Core/PinBuilder.js\";\nimport PolygonHierarchy from \"../Core/PolygonHierarchy.js\";\nimport queryToObject from \"../Core/queryToObject.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TimeInterval from \"../Core/TimeInterval.js\";\nimport TimeIntervalCollection from \"../Core/TimeIntervalCollection.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport HorizontalOrigin from \"../Scene/HorizontalOrigin.js\";\nimport LabelStyle from \"../Scene/LabelStyle.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport Autolinker from \"autolinker\";\nimport Uri from \"urijs\";\nimport { configure, BlobReader, Data64URIWriter, TextWriter, ZipReader } from \"@zip.js/zip.js/lib/zip-core.js\";\nimport getElement from \"./getElement.js\";\nimport BillboardGraphics from \"./BillboardGraphics.js\";\nimport CompositePositionProperty from \"./CompositePositionProperty.js\";\nimport DataSource from \"./DataSource.js\";\nimport DataSourceClock from \"./DataSourceClock.js\";\nimport Entity from \"./Entity.js\";\nimport EntityCluster from \"./EntityCluster.js\";\nimport EntityCollection from \"./EntityCollection.js\";\nimport KmlCamera from \"./KmlCamera.js\";\nimport KmlLookAt from \"./KmlLookAt.js\";\nimport KmlTour from \"./KmlTour.js\";\nimport KmlTourFlyTo from \"./KmlTourFlyTo.js\";\nimport KmlTourWait from \"./KmlTourWait.js\";\nimport LabelGraphics from \"./LabelGraphics.js\";\nimport PathGraphics from \"./PathGraphics.js\";\nimport PolygonGraphics from \"./PolygonGraphics.js\";\nimport PolylineGraphics from \"./PolylineGraphics.js\";\nimport PositionPropertyArray from \"./PositionPropertyArray.js\";\nimport RectangleGraphics from \"./RectangleGraphics.js\";\nimport ReferenceProperty from \"./ReferenceProperty.js\";\nimport SampledPositionProperty from \"./SampledPositionProperty.js\";\nimport ScaledPositionProperty from \"./ScaledPositionProperty.js\";\nimport TimeIntervalCollectionProperty from \"./TimeIntervalCollectionProperty.js\";\nimport WallGraphics from \"./WallGraphics.js\";\n\n//This is by no means an exhaustive list of MIME types.\n//The purpose of this list is to be able to accurately identify content embedded\n//in KMZ files. Eventually, we can make this configurable by the end user so they can add\n//there own content types if they have KMZ files that require it.\nconst MimeTypes = {\n  avi: \"video/x-msvideo\",\n  bmp: \"image/bmp\",\n  bz2: \"application/x-bzip2\",\n  chm: \"application/vnd.ms-htmlhelp\",\n  css: \"text/css\",\n  csv: \"text/csv\",\n  doc: \"application/msword\",\n  dvi: \"application/x-dvi\",\n  eps: \"application/postscript\",\n  flv: \"video/x-flv\",\n  gif: \"image/gif\",\n  gz: \"application/x-gzip\",\n  htm: \"text/html\",\n  html: \"text/html\",\n  ico: \"image/vnd.microsoft.icon\",\n  jnlp: \"application/x-java-jnlp-file\",\n  jpeg: \"image/jpeg\",\n  jpg: \"image/jpeg\",\n  m3u: \"audio/x-mpegurl\",\n  m4v: \"video/mp4\",\n  mathml: \"application/mathml+xml\",\n  mid: \"audio/midi\",\n  midi: \"audio/midi\",\n  mov: \"video/quicktime\",\n  mp3: \"audio/mpeg\",\n  mp4: \"video/mp4\",\n  mp4v: \"video/mp4\",\n  mpeg: \"video/mpeg\",\n  mpg: \"video/mpeg\",\n  odp: \"application/vnd.oasis.opendocument.presentation\",\n  ods: \"application/vnd.oasis.opendocument.spreadsheet\",\n  odt: \"application/vnd.oasis.opendocument.text\",\n  ogg: \"application/ogg\",\n  pdf: \"application/pdf\",\n  png: \"image/png\",\n  pps: \"application/vnd.ms-powerpoint\",\n  ppt: \"application/vnd.ms-powerpoint\",\n  ps: \"application/postscript\",\n  qt: \"video/quicktime\",\n  rdf: \"application/rdf+xml\",\n  rss: \"application/rss+xml\",\n  rtf: \"application/rtf\",\n  svg: \"image/svg+xml\",\n  swf: \"application/x-shockwave-flash\",\n  text: \"text/plain\",\n  tif: \"image/tiff\",\n  tiff: \"image/tiff\",\n  txt: \"text/plain\",\n  wav: \"audio/x-wav\",\n  wma: \"audio/x-ms-wma\",\n  wmv: \"video/x-ms-wmv\",\n  xml: \"application/xml\",\n  zip: \"application/zip\",\n  detectFromFilename: function (filename) {\n    let ext = filename.toLowerCase();\n    ext = getExtensionFromUri(ext);\n    return MimeTypes[ext];\n  }\n};\nlet parser;\nif (typeof DOMParser !== \"undefined\") {\n  parser = new DOMParser();\n}\nconst autolinker = new Autolinker({\n  stripPrefix: false,\n  email: false,\n  replaceFn: function (match) {\n    //Prevent matching of non-explicit urls.\n    //i.e. foo.id won't match but http://foo.id will\n    return match.urlMatchType === \"scheme\" || match.urlMatchType === \"www\";\n  }\n});\nconst BILLBOARD_SIZE = 32;\nconst BILLBOARD_NEAR_DISTANCE = 2414016;\nconst BILLBOARD_NEAR_RATIO = 1.0;\nconst BILLBOARD_FAR_DISTANCE = 1.6093e7;\nconst BILLBOARD_FAR_RATIO = 0.1;\nconst kmlNamespaces = [null, undefined, \"http://www.opengis.net/kml/2.2\", \"http://earth.google.com/kml/2.2\", \"http://earth.google.com/kml/2.1\", \"http://earth.google.com/kml/2.0\"];\nconst gxNamespaces = [\"http://www.google.com/kml/ext/2.2\"];\nconst atomNamespaces = [\"http://www.w3.org/2005/Atom\"];\nconst namespaces = {\n  kml: kmlNamespaces,\n  gx: gxNamespaces,\n  atom: atomNamespaces,\n  kmlgx: kmlNamespaces.concat(gxNamespaces)\n};\n\n// Ensure Specs/Data/KML/unsupported.kml is kept up to date with these supported types\nconst featureTypes = {\n  Document: processDocument,\n  Folder: processFolder,\n  Placemark: processPlacemark,\n  NetworkLink: processNetworkLink,\n  GroundOverlay: processGroundOverlay,\n  PhotoOverlay: processUnsupportedFeature,\n  ScreenOverlay: processScreenOverlay,\n  Tour: processTour\n};\nfunction DeferredLoading(dataSource) {\n  this._dataSource = dataSource;\n  this._deferred = defer();\n  this._stack = [];\n  this._promises = [];\n  this._timeoutSet = false;\n  this._used = false;\n  this._started = 0;\n  this._timeThreshold = 1000; // Initial load is 1 second\n}\nObject.defineProperties(DeferredLoading.prototype, {\n  dataSource: {\n    get: function () {\n      return this._dataSource;\n    }\n  }\n});\nDeferredLoading.prototype.addNodes = function (nodes, processingData) {\n  this._stack.push({\n    nodes: nodes,\n    index: 0,\n    processingData: processingData\n  });\n  this._used = true;\n};\nDeferredLoading.prototype.addPromise = function (promise) {\n  this._promises.push(promise);\n};\nDeferredLoading.prototype.wait = function () {\n  // Case where we had a non-document/folder as the root\n  const deferred = this._deferred;\n  if (!this._used) {\n    deferred.resolve();\n  }\n  return Promise.all([deferred.promise, Promise.all(this._promises)]);\n};\nDeferredLoading.prototype.process = function () {\n  const isFirstCall = this._stack.length === 1;\n  if (isFirstCall) {\n    this._started = KmlDataSource._getTimestamp();\n  }\n  return this._process(isFirstCall);\n};\nDeferredLoading.prototype._giveUpTime = function () {\n  if (this._timeoutSet) {\n    // Timeout was already set so just return\n    return;\n  }\n  this._timeoutSet = true;\n  this._timeThreshold = 50; // After the first load lower threshold to 0.5 seconds\n  const that = this;\n  setTimeout(function () {\n    that._timeoutSet = false;\n    that._started = KmlDataSource._getTimestamp();\n    that._process(true);\n  }, 0);\n};\nDeferredLoading.prototype._nextNode = function () {\n  const stack = this._stack;\n  const top = stack[stack.length - 1];\n  const index = top.index;\n  const nodes = top.nodes;\n  if (index === nodes.length) {\n    return;\n  }\n  ++top.index;\n  return nodes[index];\n};\nDeferredLoading.prototype._pop = function () {\n  const stack = this._stack;\n  stack.pop();\n\n  // Return false if we are done\n  if (stack.length === 0) {\n    this._deferred.resolve();\n    return false;\n  }\n  return true;\n};\nDeferredLoading.prototype._process = function (isFirstCall) {\n  const dataSource = this.dataSource;\n  const processingData = this._stack[this._stack.length - 1].processingData;\n  let child = this._nextNode();\n  while (defined(child)) {\n    const featureProcessor = featureTypes[child.localName];\n    if (defined(featureProcessor) && (namespaces.kml.indexOf(child.namespaceURI) !== -1 || namespaces.gx.indexOf(child.namespaceURI) !== -1)) {\n      featureProcessor(dataSource, child, processingData, this);\n\n      // Give up time and continue loading later\n      if (this._timeoutSet || KmlDataSource._getTimestamp() > this._started + this._timeThreshold) {\n        this._giveUpTime();\n        return;\n      }\n    }\n    child = this._nextNode();\n  }\n\n  // If we are a recursive call from a subfolder, just return so the parent folder can continue processing\n  // If we aren't then make another call to processNodes because there is stuff still left in the queue\n  if (this._pop() && isFirstCall) {\n    this._process(true);\n  }\n};\nfunction isZipFile(blob) {\n  const magicBlob = blob.slice(0, Math.min(4, blob.size));\n  const deferred = defer();\n  const reader = new FileReader();\n  reader.addEventListener(\"load\", function () {\n    deferred.resolve(new DataView(reader.result).getUint32(0, false) === 0x504b0304);\n  });\n  reader.addEventListener(\"error\", function () {\n    deferred.reject(reader.error);\n  });\n  reader.readAsArrayBuffer(magicBlob);\n  return deferred.promise;\n}\nfunction readBlobAsText(blob) {\n  const deferred = defer();\n  const reader = new FileReader();\n  reader.addEventListener(\"load\", function () {\n    deferred.resolve(reader.result);\n  });\n  reader.addEventListener(\"error\", function () {\n    deferred.reject(reader.error);\n  });\n  reader.readAsText(blob);\n  return deferred.promise;\n}\nfunction insertNamespaces(text) {\n  const namespaceMap = {\n    xsi: \"http://www.w3.org/2001/XMLSchema-instance\"\n  };\n  let firstPart, lastPart, reg, declaration;\n  for (const key in namespaceMap) {\n    if (namespaceMap.hasOwnProperty(key)) {\n      reg = RegExp(`[< ]${key}:`);\n      declaration = `xmlns:${key}=`;\n      if (reg.test(text) && text.indexOf(declaration) === -1) {\n        if (!defined(firstPart)) {\n          firstPart = text.substr(0, text.indexOf(\"<kml\") + 4);\n          lastPart = text.substr(firstPart.length);\n        }\n        firstPart += ` ${declaration}\"${namespaceMap[key]}\"`;\n      }\n    }\n  }\n  if (defined(firstPart)) {\n    text = firstPart + lastPart;\n  }\n  return text;\n}\nfunction removeDuplicateNamespaces(text) {\n  let index = text.indexOf(\"xmlns:\");\n  const endDeclaration = text.indexOf(\">\", index);\n  let namespace, startIndex, endIndex;\n  while (index !== -1 && index < endDeclaration) {\n    namespace = text.slice(index, text.indexOf('\"', index));\n    startIndex = index;\n    index = text.indexOf(namespace, index + 1);\n    if (index !== -1) {\n      endIndex = text.indexOf('\"', text.indexOf('\"', index) + 1);\n      text = text.slice(0, index - 1) + text.slice(endIndex + 1, text.length);\n      index = text.indexOf(\"xmlns:\", startIndex - 1);\n    } else {\n      index = text.indexOf(\"xmlns:\", startIndex + 1);\n    }\n  }\n  return text;\n}\nasync function loadXmlFromZip(entry, uriResolver) {\n  let text = await entry.getData(new TextWriter());\n  text = insertNamespaces(text);\n  text = removeDuplicateNamespaces(text);\n  uriResolver.kml = parser.parseFromString(text, \"application/xml\");\n}\nasync function loadDataUriFromZip(entry, uriResolver) {\n  const mimeType = MimeTypes.detectFromFilename(entry.filename) ?? \"application/octet-stream\";\n  const dataUri = await entry.getData(new Data64URIWriter(mimeType));\n  uriResolver[entry.filename] = dataUri;\n}\nfunction embedDataUris(div, elementType, attributeName, uriResolver) {\n  const keys = uriResolver.keys;\n  const baseUri = new Uri(\".\");\n  const elements = div.querySelectorAll(elementType);\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    const value = element.getAttribute(attributeName);\n    if (defined(value)) {\n      const relativeUri = new Uri(value);\n      const uri = relativeUri.absoluteTo(baseUri).toString();\n      const index = keys.indexOf(uri);\n      if (index !== -1) {\n        const key = keys[index];\n        element.setAttribute(attributeName, uriResolver[key]);\n        if (elementType === \"a\" && element.getAttribute(\"download\") === null) {\n          element.setAttribute(\"download\", key);\n        }\n      }\n    }\n  }\n}\nfunction applyBasePath(div, elementType, attributeName, sourceResource) {\n  const elements = div.querySelectorAll(elementType);\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    const value = element.getAttribute(attributeName);\n    const resource = resolveHref(value, sourceResource);\n    if (defined(resource)) {\n      element.setAttribute(attributeName, resource.url);\n    }\n  }\n}\n\n// an optional context is passed to allow for some malformed kmls (those with multiple geometries with same ids) to still parse\n// correctly, as they do in Google Earth.\nfunction createEntity(node, entityCollection, context) {\n  let id = queryStringAttribute(node, \"id\");\n  id = defined(id) && id.length !== 0 ? id : createGuid();\n  if (defined(context)) {\n    id = context + id;\n  }\n\n  // If we have a duplicate ID just generate one.\n  // This isn't valid KML but Google Earth handles this case.\n  let entity = entityCollection.getById(id);\n  if (defined(entity)) {\n    id = createGuid();\n    if (defined(context)) {\n      id = context + id;\n    }\n  }\n  entity = entityCollection.add(new Entity({\n    id: id\n  }));\n  if (!defined(entity.kml)) {\n    entity.addProperty(\"kml\");\n    entity.kml = new KmlFeatureData();\n  }\n  return entity;\n}\nfunction isExtrudable(altitudeMode, gxAltitudeMode) {\n  return altitudeMode === \"absolute\" || altitudeMode === \"relativeToGround\" || gxAltitudeMode === \"relativeToSeaFloor\";\n}\nfunction readCoordinate(value, ellipsoid) {\n  //Google Earth treats empty or missing coordinates as 0.\n  if (!defined(value)) {\n    return Cartesian3.fromDegrees(0, 0, 0, ellipsoid);\n  }\n  const digits = value.match(/[^\\s,\\n]+/g);\n  if (!defined(digits)) {\n    return Cartesian3.fromDegrees(0, 0, 0, ellipsoid);\n  }\n  let longitude = parseFloat(digits[0]);\n  let latitude = parseFloat(digits[1]);\n  let height = parseFloat(digits[2]);\n  longitude = isNaN(longitude) ? 0.0 : longitude;\n  latitude = isNaN(latitude) ? 0.0 : latitude;\n  height = isNaN(height) ? 0.0 : height;\n  return Cartesian3.fromDegrees(longitude, latitude, height, ellipsoid);\n}\nfunction readCoordinates(element, ellipsoid) {\n  if (!defined(element)) {\n    return undefined;\n  }\n  const tuples = element.textContent.match(/[^\\s\\n]+/g);\n  if (!defined(tuples)) {\n    return undefined;\n  }\n  const length = tuples.length;\n  const result = new Array(length);\n  let resultIndex = 0;\n  for (let i = 0; i < length; i++) {\n    result[resultIndex++] = readCoordinate(tuples[i], ellipsoid);\n  }\n  return result;\n}\nfunction queryNumericAttribute(node, attributeName) {\n  if (!defined(node)) {\n    return undefined;\n  }\n  const value = node.getAttribute(attributeName);\n  if (value !== null) {\n    const result = parseFloat(value);\n    return !isNaN(result) ? result : undefined;\n  }\n  return undefined;\n}\nfunction queryStringAttribute(node, attributeName) {\n  if (!defined(node)) {\n    return undefined;\n  }\n  const value = node.getAttribute(attributeName);\n  return value !== null ? value : undefined;\n}\nfunction queryFirstNode(node, tagName, namespace) {\n  if (!defined(node)) {\n    return undefined;\n  }\n  const childNodes = node.childNodes;\n  const length = childNodes.length;\n  for (let q = 0; q < length; q++) {\n    const child = childNodes[q];\n    if (child.localName === tagName && namespace.indexOf(child.namespaceURI) !== -1) {\n      return child;\n    }\n  }\n  return undefined;\n}\nfunction queryNodes(node, tagName, namespace) {\n  if (!defined(node)) {\n    return undefined;\n  }\n  const result = [];\n  const childNodes = node.getElementsByTagNameNS(\"*\", tagName);\n  const length = childNodes.length;\n  for (let q = 0; q < length; q++) {\n    const child = childNodes[q];\n    if (child.localName === tagName && namespace.indexOf(child.namespaceURI) !== -1) {\n      result.push(child);\n    }\n  }\n  return result;\n}\nfunction queryChildNodes(node, tagName, namespace) {\n  if (!defined(node)) {\n    return [];\n  }\n  const result = [];\n  const childNodes = node.childNodes;\n  const length = childNodes.length;\n  for (let q = 0; q < length; q++) {\n    const child = childNodes[q];\n    if (child.localName === tagName && namespace.indexOf(child.namespaceURI) !== -1) {\n      result.push(child);\n    }\n  }\n  return result;\n}\nfunction queryNumericValue(node, tagName, namespace) {\n  const resultNode = queryFirstNode(node, tagName, namespace);\n  if (defined(resultNode)) {\n    const result = parseFloat(resultNode.textContent);\n    return !isNaN(result) ? result : undefined;\n  }\n  return undefined;\n}\nfunction queryStringValue(node, tagName, namespace) {\n  const result = queryFirstNode(node, tagName, namespace);\n  if (defined(result)) {\n    return result.textContent.trim();\n  }\n  return undefined;\n}\nfunction queryBooleanValue(node, tagName, namespace) {\n  const result = queryFirstNode(node, tagName, namespace);\n  if (defined(result)) {\n    const value = result.textContent.trim();\n    return value === \"1\" || /^true$/i.test(value);\n  }\n  return undefined;\n}\nfunction resolveHref(href, sourceResource, uriResolver) {\n  if (!defined(href)) {\n    return undefined;\n  }\n  let resource;\n  if (defined(uriResolver)) {\n    // To resolve issues with KML sources defined in Windows style paths.\n    href = href.replace(/\\\\/g, \"/\");\n    let blob = uriResolver[href];\n    if (defined(blob)) {\n      resource = new Resource({\n        url: blob\n      });\n    } else {\n      // Needed for multiple levels of KML files in a KMZ\n      const baseUri = new Uri(sourceResource.getUrlComponent());\n      const uri = new Uri(href);\n      blob = uriResolver[uri.absoluteTo(baseUri)];\n      if (defined(blob)) {\n        resource = new Resource({\n          url: blob\n        });\n      }\n    }\n  }\n  if (!defined(resource)) {\n    resource = sourceResource.getDerivedResource({\n      url: href\n    });\n  }\n  return resource;\n}\nconst colorOptions = {\n  maximumRed: undefined,\n  red: undefined,\n  maximumGreen: undefined,\n  green: undefined,\n  maximumBlue: undefined,\n  blue: undefined\n};\nfunction parseColorString(value, isRandom) {\n  if (!defined(value) || /^\\s*$/gm.test(value)) {\n    return undefined;\n  }\n  if (value[0] === \"#\") {\n    value = value.substring(1);\n  }\n  const alpha = parseInt(value.substring(0, 2), 16) / 255.0;\n  const blue = parseInt(value.substring(2, 4), 16) / 255.0;\n  const green = parseInt(value.substring(4, 6), 16) / 255.0;\n  const red = parseInt(value.substring(6, 8), 16) / 255.0;\n  if (!isRandom) {\n    return new Color(red, green, blue, alpha);\n  }\n  if (red > 0) {\n    colorOptions.maximumRed = red;\n    colorOptions.red = undefined;\n  } else {\n    colorOptions.maximumRed = undefined;\n    colorOptions.red = 0;\n  }\n  if (green > 0) {\n    colorOptions.maximumGreen = green;\n    colorOptions.green = undefined;\n  } else {\n    colorOptions.maximumGreen = undefined;\n    colorOptions.green = 0;\n  }\n  if (blue > 0) {\n    colorOptions.maximumBlue = blue;\n    colorOptions.blue = undefined;\n  } else {\n    colorOptions.maximumBlue = undefined;\n    colorOptions.blue = 0;\n  }\n  colorOptions.alpha = alpha;\n  return Color.fromRandom(colorOptions);\n}\nfunction queryColorValue(node, tagName, namespace) {\n  const value = queryStringValue(node, tagName, namespace);\n  if (!defined(value)) {\n    return undefined;\n  }\n  return parseColorString(value, queryStringValue(node, \"colorMode\", namespace) === \"random\");\n}\nfunction processTimeStamp(featureNode) {\n  const node = queryFirstNode(featureNode, \"TimeStamp\", namespaces.kmlgx);\n  const whenString = queryStringValue(node, \"when\", namespaces.kmlgx);\n  if (!defined(node) || !defined(whenString) || whenString.length === 0) {\n    return undefined;\n  }\n\n  //According to the KML spec, a TimeStamp represents a \"single moment in time\"\n  //However, since Cesium animates much differently than Google Earth, that doesn't\n  //Make much sense here.  Instead, we use the TimeStamp as the moment the feature\n  //comes into existence.  This works much better and gives a similar feel to\n  //GE's experience.\n  const when = JulianDate.fromIso8601(whenString);\n  const result = new TimeIntervalCollection();\n  result.addInterval(new TimeInterval({\n    start: when,\n    stop: Iso8601.MAXIMUM_VALUE\n  }));\n  return result;\n}\nfunction processTimeSpan(featureNode) {\n  const node = queryFirstNode(featureNode, \"TimeSpan\", namespaces.kmlgx);\n  if (!defined(node)) {\n    return undefined;\n  }\n  let result;\n  const beginNode = queryFirstNode(node, \"begin\", namespaces.kmlgx);\n  let beginDate = defined(beginNode) ? JulianDate.fromIso8601(beginNode.textContent) : undefined;\n  const endNode = queryFirstNode(node, \"end\", namespaces.kmlgx);\n  let endDate = defined(endNode) ? JulianDate.fromIso8601(endNode.textContent) : undefined;\n  if (defined(beginDate) && defined(endDate)) {\n    if (JulianDate.lessThan(endDate, beginDate)) {\n      const tmp = beginDate;\n      beginDate = endDate;\n      endDate = tmp;\n    }\n    result = new TimeIntervalCollection();\n    result.addInterval(new TimeInterval({\n      start: beginDate,\n      stop: endDate\n    }));\n  } else if (defined(beginDate)) {\n    result = new TimeIntervalCollection();\n    result.addInterval(new TimeInterval({\n      start: beginDate,\n      stop: Iso8601.MAXIMUM_VALUE\n    }));\n  } else if (defined(endDate)) {\n    result = new TimeIntervalCollection();\n    result.addInterval(new TimeInterval({\n      start: Iso8601.MINIMUM_VALUE,\n      stop: endDate\n    }));\n  }\n  return result;\n}\nfunction createDefaultBillboard() {\n  const billboard = new BillboardGraphics();\n  billboard.width = BILLBOARD_SIZE;\n  billboard.height = BILLBOARD_SIZE;\n  billboard.scaleByDistance = new NearFarScalar(BILLBOARD_NEAR_DISTANCE, BILLBOARD_NEAR_RATIO, BILLBOARD_FAR_DISTANCE, BILLBOARD_FAR_RATIO);\n  billboard.pixelOffsetScaleByDistance = new NearFarScalar(BILLBOARD_NEAR_DISTANCE, BILLBOARD_NEAR_RATIO, BILLBOARD_FAR_DISTANCE, BILLBOARD_FAR_RATIO);\n  return billboard;\n}\nfunction createDefaultPolygon() {\n  const polygon = new PolygonGraphics();\n  polygon.outline = true;\n  polygon.outlineColor = Color.WHITE;\n  return polygon;\n}\nfunction createDefaultLabel() {\n  const label = new LabelGraphics();\n  label.translucencyByDistance = new NearFarScalar(3000000, 1.0, 5000000, 0.0);\n  label.pixelOffset = new Cartesian2(17, 0);\n  label.horizontalOrigin = HorizontalOrigin.LEFT;\n  label.font = \"16px sans-serif\";\n  label.style = LabelStyle.FILL_AND_OUTLINE;\n  return label;\n}\nfunction getIconHref(iconNode, dataSource, sourceResource, uriResolver, canRefresh) {\n  let href = queryStringValue(iconNode, \"href\", namespaces.kml);\n  if (!defined(href) || href.length === 0) {\n    return undefined;\n  }\n  if (href.indexOf(\"root://icons/palette-\") === 0) {\n    const palette = href.charAt(21);\n\n    // Get the icon number\n    let x = queryNumericValue(iconNode, \"x\", namespaces.gx) ?? 0;\n    let y = queryNumericValue(iconNode, \"y\", namespaces.gx) ?? 0;\n    x = Math.min(x / 32, 7);\n    y = 7 - Math.min(y / 32, 7);\n    const iconNum = 8 * y + x;\n    href = `https://maps.google.com/mapfiles/kml/pal${palette}/icon${iconNum}.png`;\n  }\n  const hrefResource = resolveHref(href, sourceResource, uriResolver);\n  if (canRefresh) {\n    const refreshMode = queryStringValue(iconNode, \"refreshMode\", namespaces.kml);\n    const viewRefreshMode = queryStringValue(iconNode, \"viewRefreshMode\", namespaces.kml);\n    if (refreshMode === \"onInterval\" || refreshMode === \"onExpire\") {\n      oneTimeWarning(`kml-refreshMode-${refreshMode}`, `KML - Unsupported Icon refreshMode: ${refreshMode}`);\n    } else if (viewRefreshMode === \"onStop\" || viewRefreshMode === \"onRegion\") {\n      oneTimeWarning(`kml-refreshMode-${viewRefreshMode}`, `KML - Unsupported Icon viewRefreshMode: ${viewRefreshMode}`);\n    }\n    const viewBoundScale = queryStringValue(iconNode, \"viewBoundScale\", namespaces.kml) ?? 1.0;\n    const defaultViewFormat = viewRefreshMode === \"onStop\" ? \"BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]\" : \"\";\n    const viewFormat = queryStringValue(iconNode, \"viewFormat\", namespaces.kml) ?? defaultViewFormat;\n    const httpQuery = queryStringValue(iconNode, \"httpQuery\", namespaces.kml);\n    if (defined(viewFormat)) {\n      hrefResource.setQueryParameters(queryToObject(cleanupString(viewFormat)));\n    }\n    if (defined(httpQuery)) {\n      hrefResource.setQueryParameters(queryToObject(cleanupString(httpQuery)));\n    }\n    const ellipsoid = dataSource._ellipsoid;\n    processNetworkLinkQueryString(hrefResource, dataSource.camera, dataSource.canvas, viewBoundScale, dataSource._lastCameraView.bbox, ellipsoid);\n    return hrefResource;\n  }\n  return hrefResource;\n}\nfunction processBillboardIcon(dataSource, node, targetEntity, sourceResource, uriResolver) {\n  let scale = queryNumericValue(node, \"scale\", namespaces.kml);\n  const heading = queryNumericValue(node, \"heading\", namespaces.kml);\n  const color = queryColorValue(node, \"color\", namespaces.kml);\n  const iconNode = queryFirstNode(node, \"Icon\", namespaces.kml);\n  let icon = getIconHref(iconNode, dataSource, sourceResource, uriResolver, false);\n\n  // If icon tags are present but blank, we do not want to show an icon\n  if (defined(iconNode) && !defined(icon)) {\n    icon = false;\n  }\n  const x = queryNumericValue(iconNode, \"x\", namespaces.gx);\n  const y = queryNumericValue(iconNode, \"y\", namespaces.gx);\n  const w = queryNumericValue(iconNode, \"w\", namespaces.gx);\n  const h = queryNumericValue(iconNode, \"h\", namespaces.gx);\n  const hotSpotNode = queryFirstNode(node, \"hotSpot\", namespaces.kml);\n  const hotSpotX = queryNumericAttribute(hotSpotNode, \"x\");\n  const hotSpotY = queryNumericAttribute(hotSpotNode, \"y\");\n  const hotSpotXUnit = queryStringAttribute(hotSpotNode, \"xunits\");\n  const hotSpotYUnit = queryStringAttribute(hotSpotNode, \"yunits\");\n  let billboard = targetEntity.billboard;\n  if (!defined(billboard)) {\n    billboard = createDefaultBillboard();\n    targetEntity.billboard = billboard;\n  }\n  billboard.image = icon;\n  billboard.scale = scale;\n  billboard.color = color;\n  if (defined(x) || defined(y) || defined(w) || defined(h)) {\n    billboard.imageSubRegion = new BoundingRectangle(x, y, w, h);\n  }\n\n  //GE treats a heading of zero as no heading\n  //You can still point north using a 360 degree angle (or any multiple of 360)\n  if (defined(heading) && heading !== 0) {\n    billboard.rotation = CesiumMath.toRadians(-heading);\n    billboard.alignedAxis = Cartesian3.UNIT_Z;\n  }\n\n  //Hotpot is the KML equivalent of pixel offset\n  //The hotspot origin is the lower left, but we leave\n  //our billboard origin at the center and simply\n  //modify the pixel offset to take this into account\n  scale = scale ?? 1.0;\n  let xOffset;\n  let yOffset;\n  if (defined(hotSpotX)) {\n    if (hotSpotXUnit === \"pixels\") {\n      xOffset = -hotSpotX * scale;\n    } else if (hotSpotXUnit === \"insetPixels\") {\n      xOffset = (hotSpotX - BILLBOARD_SIZE) * scale;\n    } else if (hotSpotXUnit === \"fraction\") {\n      xOffset = -hotSpotX * BILLBOARD_SIZE * scale;\n    }\n    xOffset += BILLBOARD_SIZE * 0.5 * scale;\n  }\n  if (defined(hotSpotY)) {\n    if (hotSpotYUnit === \"pixels\") {\n      yOffset = hotSpotY * scale;\n    } else if (hotSpotYUnit === \"insetPixels\") {\n      yOffset = (-hotSpotY + BILLBOARD_SIZE) * scale;\n    } else if (hotSpotYUnit === \"fraction\") {\n      yOffset = hotSpotY * BILLBOARD_SIZE * scale;\n    }\n    yOffset -= BILLBOARD_SIZE * 0.5 * scale;\n  }\n  if (defined(xOffset) || defined(yOffset)) {\n    billboard.pixelOffset = new Cartesian2(xOffset, yOffset);\n  }\n}\nfunction applyStyle(dataSource, styleNode, targetEntity, sourceResource, uriResolver) {\n  for (let i = 0, len = styleNode.childNodes.length; i < len; i++) {\n    const node = styleNode.childNodes.item(i);\n    if (node.localName === \"IconStyle\") {\n      processBillboardIcon(dataSource, node, targetEntity, sourceResource, uriResolver);\n    } else if (node.localName === \"LabelStyle\") {\n      let label = targetEntity.label;\n      if (!defined(label)) {\n        label = createDefaultLabel();\n        targetEntity.label = label;\n      }\n      label.scale = queryNumericValue(node, \"scale\", namespaces.kml) ?? label.scale;\n      label.fillColor = queryColorValue(node, \"color\", namespaces.kml) ?? label.fillColor;\n      label.text = targetEntity.name;\n    } else if (node.localName === \"LineStyle\") {\n      let polyline = targetEntity.polyline;\n      if (!defined(polyline)) {\n        polyline = new PolylineGraphics();\n        targetEntity.polyline = polyline;\n      }\n      polyline.width = queryNumericValue(node, \"width\", namespaces.kml);\n      polyline.material = queryColorValue(node, \"color\", namespaces.kml);\n      if (defined(queryColorValue(node, \"outerColor\", namespaces.gx))) {\n        oneTimeWarning(\"kml-gx:outerColor\", \"KML - gx:outerColor is not supported in a LineStyle\");\n      }\n      if (defined(queryNumericValue(node, \"outerWidth\", namespaces.gx))) {\n        oneTimeWarning(\"kml-gx:outerWidth\", \"KML - gx:outerWidth is not supported in a LineStyle\");\n      }\n      if (defined(queryNumericValue(node, \"physicalWidth\", namespaces.gx))) {\n        oneTimeWarning(\"kml-gx:physicalWidth\", \"KML - gx:physicalWidth is not supported in a LineStyle\");\n      }\n      if (defined(queryBooleanValue(node, \"labelVisibility\", namespaces.gx))) {\n        oneTimeWarning(\"kml-gx:labelVisibility\", \"KML - gx:labelVisibility is not supported in a LineStyle\");\n      }\n    } else if (node.localName === \"PolyStyle\") {\n      let polygon = targetEntity.polygon;\n      if (!defined(polygon)) {\n        polygon = createDefaultPolygon();\n        targetEntity.polygon = polygon;\n      }\n      polygon.material = queryColorValue(node, \"color\", namespaces.kml) ?? polygon.material;\n      polygon.fill = queryBooleanValue(node, \"fill\", namespaces.kml) ?? polygon.fill;\n      polygon.outline = queryBooleanValue(node, \"outline\", namespaces.kml) ?? polygon.outline;\n    } else if (node.localName === \"BalloonStyle\") {\n      const bgColor = parseColorString(queryStringValue(node, \"bgColor\", namespaces.kml)) ?? Color.WHITE;\n      const textColor = parseColorString(queryStringValue(node, \"textColor\", namespaces.kml)) ?? Color.BLACK;\n      const text = queryStringValue(node, \"text\", namespaces.kml);\n\n      //This is purely an internal property used in style processing,\n      //it never ends up on the final entity.\n      targetEntity.addProperty(\"balloonStyle\");\n      targetEntity.balloonStyle = {\n        bgColor: bgColor,\n        textColor: textColor,\n        text: text\n      };\n    } else if (node.localName === \"ListStyle\") {\n      const listItemType = queryStringValue(node, \"listItemType\", namespaces.kml);\n      if (listItemType === \"radioFolder\" || listItemType === \"checkOffOnly\") {\n        oneTimeWarning(`kml-listStyle-${listItemType}`, `KML - Unsupported ListStyle with listItemType: ${listItemType}`);\n      }\n    }\n  }\n}\n\n//Processes and merges any inline styles for the provided node into the provided entity.\nfunction computeFinalStyle(dataSource, placeMark, styleCollection, sourceResource, uriResolver) {\n  const result = new Entity();\n  let styleEntity;\n\n  //Google earth seems to always use the last inline Style/StyleMap only\n  let styleIndex = -1;\n  const childNodes = placeMark.childNodes;\n  const length = childNodes.length;\n  for (let q = 0; q < length; q++) {\n    const child = childNodes[q];\n    if (child.localName === \"Style\" || child.localName === \"StyleMap\") {\n      styleIndex = q;\n    }\n  }\n  if (styleIndex !== -1) {\n    const inlineStyleNode = childNodes[styleIndex];\n    if (inlineStyleNode.localName === \"Style\") {\n      applyStyle(dataSource, inlineStyleNode, result, sourceResource, uriResolver);\n    } else {\n      // StyleMap\n      const pairs = queryChildNodes(inlineStyleNode, \"Pair\", namespaces.kml);\n      for (let p = 0; p < pairs.length; p++) {\n        const pair = pairs[p];\n        const key = queryStringValue(pair, \"key\", namespaces.kml);\n        if (key === \"normal\") {\n          const styleUrl = queryStringValue(pair, \"styleUrl\", namespaces.kml);\n          if (defined(styleUrl)) {\n            styleEntity = styleCollection.getById(styleUrl);\n            if (!defined(styleEntity)) {\n              styleEntity = styleCollection.getById(`#${styleUrl}`);\n            }\n            if (defined(styleEntity)) {\n              result.merge(styleEntity);\n            }\n          } else {\n            const node = queryFirstNode(pair, \"Style\", namespaces.kml);\n            applyStyle(dataSource, node, result, sourceResource, uriResolver);\n          }\n        } else {\n          oneTimeWarning(`kml-styleMap-${key}`, `KML - Unsupported StyleMap key: ${key}`);\n        }\n      }\n    }\n  }\n\n  //Google earth seems to always use the first external style only.\n  const externalStyle = queryStringValue(placeMark, \"styleUrl\", namespaces.kml);\n  if (defined(externalStyle)) {\n    let id = externalStyle;\n    if (externalStyle[0] !== \"#\" && externalStyle.indexOf(\"#\") !== -1) {\n      const tokens = externalStyle.split(\"#\");\n      const uri = tokens[0];\n      const resource = sourceResource.getDerivedResource({\n        url: uri\n      });\n      id = `${resource.getUrlComponent()}#${tokens[1]}`;\n    }\n    styleEntity = styleCollection.getById(id);\n    if (!defined(styleEntity)) {\n      styleEntity = styleCollection.getById(`#${id}`);\n    }\n    if (defined(styleEntity)) {\n      result.merge(styleEntity);\n    }\n  }\n  return result;\n}\n\n//Asynchronously processes an external style file.\nfunction processExternalStyles(dataSource, resource, styleCollection) {\n  return resource.fetchXML().then(function (styleKml) {\n    return processStyles(dataSource, styleKml, styleCollection, resource, true);\n  });\n}\n\n//Processes all shared and external styles and stores\n//their id into the provided styleCollection.\n//Returns an array of promises that will resolve when\n//each style is loaded.\nfunction processStyles(dataSource, kml, styleCollection, sourceResource, isExternal, uriResolver) {\n  let i;\n  let id;\n  let styleEntity;\n  let node;\n  const styleNodes = queryNodes(kml, \"Style\", namespaces.kml);\n  if (defined(styleNodes)) {\n    const styleNodesLength = styleNodes.length;\n    for (i = 0; i < styleNodesLength; i++) {\n      node = styleNodes[i];\n      id = queryStringAttribute(node, \"id\");\n      if (defined(id)) {\n        id = `#${id}`;\n        if (isExternal && defined(sourceResource)) {\n          id = sourceResource.getUrlComponent() + id;\n        }\n        if (!defined(styleCollection.getById(id))) {\n          styleEntity = new Entity({\n            id: id\n          });\n          styleCollection.add(styleEntity);\n          applyStyle(dataSource, node, styleEntity, sourceResource, uriResolver);\n        }\n      }\n    }\n  }\n  const styleMaps = queryNodes(kml, \"StyleMap\", namespaces.kml);\n  if (defined(styleMaps)) {\n    const styleMapsLength = styleMaps.length;\n    for (i = 0; i < styleMapsLength; i++) {\n      const styleMap = styleMaps[i];\n      id = queryStringAttribute(styleMap, \"id\");\n      if (defined(id)) {\n        const pairs = queryChildNodes(styleMap, \"Pair\", namespaces.kml);\n        for (let p = 0; p < pairs.length; p++) {\n          const pair = pairs[p];\n          const key = queryStringValue(pair, \"key\", namespaces.kml);\n          if (key === \"normal\") {\n            id = `#${id}`;\n            if (isExternal && defined(sourceResource)) {\n              id = sourceResource.getUrlComponent() + id;\n            }\n            if (!defined(styleCollection.getById(id))) {\n              styleEntity = styleCollection.getOrCreateEntity(id);\n              let styleUrl = queryStringValue(pair, \"styleUrl\", namespaces.kml);\n              if (defined(styleUrl)) {\n                if (styleUrl[0] !== \"#\") {\n                  styleUrl = `#${styleUrl}`;\n                }\n                if (isExternal && defined(sourceResource)) {\n                  styleUrl = sourceResource.getUrlComponent() + styleUrl;\n                }\n                const base = styleCollection.getById(styleUrl);\n                if (defined(base)) {\n                  styleEntity.merge(base);\n                }\n              } else {\n                node = queryFirstNode(pair, \"Style\", namespaces.kml);\n                applyStyle(dataSource, node, styleEntity, sourceResource, uriResolver);\n              }\n            }\n          } else {\n            oneTimeWarning(`kml-styleMap-${key}`, `KML - Unsupported StyleMap key: ${key}`);\n          }\n        }\n      }\n    }\n  }\n  const promises = [];\n  const styleUrlNodes = kml.getElementsByTagName(\"styleUrl\");\n  const styleUrlNodesLength = styleUrlNodes.length;\n  for (i = 0; i < styleUrlNodesLength; i++) {\n    const styleReference = styleUrlNodes[i].textContent;\n    if (styleReference[0] !== \"#\") {\n      //According to the spec, all local styles should start with a #\n      //and everything else is an external style that has a # seperating\n      //the URL of the document and the style.  However, Google Earth\n      //also accepts styleUrls without a # as meaning a local style.\n      const tokens = styleReference.split(\"#\");\n      if (tokens.length === 2) {\n        const uri = tokens[0];\n        const resource = sourceResource.getDerivedResource({\n          url: uri\n        });\n        promises.push(processExternalStyles(dataSource, resource, styleCollection));\n      }\n    }\n  }\n  return promises;\n}\nfunction createDropLine(entityCollection, entity, styleEntity) {\n  const entityPosition = new ReferenceProperty(entityCollection, entity.id, [\"position\"]);\n  const surfacePosition = new ScaledPositionProperty(entity.position);\n  entity.polyline = defined(styleEntity.polyline) ? styleEntity.polyline.clone() : new PolylineGraphics();\n  entity.polyline.positions = new PositionPropertyArray([entityPosition, surfacePosition]);\n}\nfunction heightReferenceFromAltitudeMode(altitudeMode, gxAltitudeMode) {\n  if (!defined(altitudeMode) && !defined(gxAltitudeMode) || altitudeMode === \"clampToGround\") {\n    return HeightReference.CLAMP_TO_GROUND;\n  }\n  if (altitudeMode === \"relativeToGround\") {\n    return HeightReference.RELATIVE_TO_GROUND;\n  }\n  if (altitudeMode === \"absolute\") {\n    return HeightReference.NONE;\n  }\n  if (gxAltitudeMode === \"clampToSeaFloor\") {\n    oneTimeWarning(\"kml-gx:altitudeMode-clampToSeaFloor\", \"KML - <gx:altitudeMode>:clampToSeaFloor is currently not supported, using <kml:altitudeMode>:clampToGround.\");\n    return HeightReference.CLAMP_TO_GROUND;\n  }\n  if (gxAltitudeMode === \"relativeToSeaFloor\") {\n    oneTimeWarning(\"kml-gx:altitudeMode-relativeToSeaFloor\", \"KML - <gx:altitudeMode>:relativeToSeaFloor is currently not supported, using <kml:altitudeMode>:relativeToGround.\");\n    return HeightReference.RELATIVE_TO_GROUND;\n  }\n  if (defined(altitudeMode)) {\n    oneTimeWarning(\"kml-altitudeMode-unknown\", `KML - Unknown <kml:altitudeMode>:${altitudeMode}, using <kml:altitudeMode>:CLAMP_TO_GROUND.`);\n  } else {\n    oneTimeWarning(\"kml-gx:altitudeMode-unknown\", `KML - Unknown <gx:altitudeMode>:${gxAltitudeMode}, using <kml:altitudeMode>:CLAMP_TO_GROUND.`);\n  }\n\n  // Clamp to ground is the default\n  return HeightReference.CLAMP_TO_GROUND;\n}\nfunction createPositionPropertyFromAltitudeMode(property, altitudeMode, gxAltitudeMode) {\n  if (gxAltitudeMode === \"relativeToSeaFloor\" || altitudeMode === \"absolute\" || altitudeMode === \"relativeToGround\") {\n    //Just return the ellipsoid referenced property until we support MSL\n    return property;\n  }\n  if (defined(altitudeMode) && altitudeMode !== \"clampToGround\" ||\n  //\n  defined(gxAltitudeMode) && gxAltitudeMode !== \"clampToSeaFloor\") {\n    oneTimeWarning(\"kml-altitudeMode-unknown\", `KML - Unknown altitudeMode: ${altitudeMode ?? gxAltitudeMode}`);\n  }\n\n  // Clamp to ground is the default\n  return new ScaledPositionProperty(property);\n}\nfunction createPositionPropertyArrayFromAltitudeMode(properties, altitudeMode, gxAltitudeMode, ellipsoid) {\n  if (!defined(properties)) {\n    return undefined;\n  }\n  if (gxAltitudeMode === \"relativeToSeaFloor\" || altitudeMode === \"absolute\" || altitudeMode === \"relativeToGround\") {\n    //Just return the ellipsoid referenced property until we support MSL\n    return properties;\n  }\n  if (defined(altitudeMode) && altitudeMode !== \"clampToGround\" ||\n  //\n  defined(gxAltitudeMode) && gxAltitudeMode !== \"clampToSeaFloor\") {\n    oneTimeWarning(\"kml-altitudeMode-unknown\", `KML - Unknown altitudeMode: ${altitudeMode ?? gxAltitudeMode}`);\n  }\n\n  // Clamp to ground is the default\n  const propertiesLength = properties.length;\n  for (let i = 0; i < propertiesLength; i++) {\n    const property = properties[i];\n    ellipsoid.scaleToGeodeticSurface(property, property);\n  }\n  return properties;\n}\nfunction processPositionGraphics(dataSource, entity, styleEntity, heightReference) {\n  let label = entity.label;\n  if (!defined(label)) {\n    label = defined(styleEntity.label) ? styleEntity.label.clone() : createDefaultLabel();\n    entity.label = label;\n  }\n  label.text = entity.name;\n  let billboard = entity.billboard;\n  if (!defined(billboard)) {\n    billboard = defined(styleEntity.billboard) ? styleEntity.billboard.clone() : createDefaultBillboard();\n    entity.billboard = billboard;\n  }\n  if (!defined(billboard.image)) {\n    billboard.image = dataSource._pinBuilder.fromColor(Color.YELLOW, 64);\n\n    // If there were empty <Icon> tags in the KML, then billboard.image was set to false above\n    // However, in this case, the false value would have been converted to a property afterwards\n    // Thus, we check if billboard.image is defined with value of false\n  } else if (!billboard.image.getValue()) {\n    billboard.image = undefined;\n  }\n  let scale = 1.0;\n  if (defined(billboard.scale)) {\n    scale = billboard.scale.getValue();\n    if (scale !== 0) {\n      label.pixelOffset = new Cartesian2(scale * 16 + 1, 0);\n    } else {\n      //Minor tweaks to better match Google Earth.\n      label.pixelOffset = undefined;\n      label.horizontalOrigin = undefined;\n    }\n  }\n  if (defined(heightReference) && dataSource._clampToGround) {\n    billboard.heightReference = heightReference;\n    label.heightReference = heightReference;\n  }\n}\nfunction processPathGraphics(entity, styleEntity) {\n  let path = entity.path;\n  if (!defined(path)) {\n    path = new PathGraphics();\n    path.leadTime = 0;\n    entity.path = path;\n  }\n  const polyline = styleEntity.polyline;\n  if (defined(polyline)) {\n    path.material = polyline.material;\n    path.width = polyline.width;\n  }\n}\nfunction processPoint(dataSource, entityCollection, geometryNode, entity, styleEntity) {\n  const coordinatesString = queryStringValue(geometryNode, \"coordinates\", namespaces.kml);\n  const altitudeMode = queryStringValue(geometryNode, \"altitudeMode\", namespaces.kml);\n  const gxAltitudeMode = queryStringValue(geometryNode, \"altitudeMode\", namespaces.gx);\n  const extrude = queryBooleanValue(geometryNode, \"extrude\", namespaces.kml);\n  const ellipsoid = dataSource._ellipsoid;\n  const position = readCoordinate(coordinatesString, ellipsoid);\n  entity.position = position;\n  processPositionGraphics(dataSource, entity, styleEntity, heightReferenceFromAltitudeMode(altitudeMode, gxAltitudeMode));\n  if (extrude && isExtrudable(altitudeMode, gxAltitudeMode)) {\n    createDropLine(entityCollection, entity, styleEntity);\n  }\n  return true;\n}\nfunction processLineStringOrLinearRing(dataSource, entityCollection, geometryNode, entity, styleEntity) {\n  const coordinatesNode = queryFirstNode(geometryNode, \"coordinates\", namespaces.kml);\n  const altitudeMode = queryStringValue(geometryNode, \"altitudeMode\", namespaces.kml);\n  const gxAltitudeMode = queryStringValue(geometryNode, \"altitudeMode\", namespaces.gx);\n  const extrude = queryBooleanValue(geometryNode, \"extrude\", namespaces.kml);\n  const tessellate = queryBooleanValue(geometryNode, \"tessellate\", namespaces.kml);\n  const canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);\n  const zIndex = queryNumericValue(geometryNode, \"drawOrder\", namespaces.gx);\n  const ellipsoid = dataSource._ellipsoid;\n  const coordinates = readCoordinates(coordinatesNode, ellipsoid);\n  let polyline = styleEntity.polyline;\n  if (canExtrude && extrude) {\n    const wall = new WallGraphics();\n    entity.wall = wall;\n    wall.positions = coordinates;\n    const polygon = styleEntity.polygon;\n    if (defined(polygon)) {\n      wall.fill = polygon.fill;\n      wall.material = polygon.material;\n    }\n\n    //Always outline walls so they show up in 2D.\n    wall.outline = true;\n    if (defined(polyline)) {\n      wall.outlineColor = defined(polyline.material) ? polyline.material.color : Color.WHITE;\n      wall.outlineWidth = polyline.width;\n    } else if (defined(polygon)) {\n      wall.outlineColor = defined(polygon.material) ? polygon.material.color : Color.WHITE;\n    }\n  } else if (dataSource._clampToGround && !canExtrude && tessellate) {\n    const polylineGraphics = new PolylineGraphics();\n    polylineGraphics.clampToGround = true;\n    entity.polyline = polylineGraphics;\n    polylineGraphics.positions = coordinates;\n    if (defined(polyline)) {\n      polylineGraphics.material = defined(polyline.material) ? polyline.material.color.getValue(Iso8601.MINIMUM_VALUE) : Color.WHITE;\n      polylineGraphics.width = polyline.width ?? 1.0;\n    } else {\n      polylineGraphics.material = Color.WHITE;\n      polylineGraphics.width = 1.0;\n    }\n    polylineGraphics.zIndex = zIndex;\n  } else {\n    if (defined(zIndex)) {\n      oneTimeWarning(\"kml-gx:drawOrder\", \"KML - gx:drawOrder is not supported in LineStrings when clampToGround is false\");\n    }\n    if (dataSource._clampToGround && !tessellate) {\n      oneTimeWarning(\"kml-line-tesselate\", \"Ignoring clampToGround for KML lines without the tessellate flag.\");\n    }\n    polyline = defined(polyline) ? polyline.clone() : new PolylineGraphics();\n    entity.polyline = polyline;\n    polyline.positions = createPositionPropertyArrayFromAltitudeMode(coordinates, altitudeMode, gxAltitudeMode, ellipsoid);\n    if (!tessellate || canExtrude) {\n      polyline.arcType = ArcType.NONE;\n    }\n  }\n  return true;\n}\nfunction processPolygon(dataSource, entityCollection, geometryNode, entity, styleEntity) {\n  const outerBoundaryIsNode = queryFirstNode(geometryNode, \"outerBoundaryIs\", namespaces.kml);\n  let linearRingNode = queryFirstNode(outerBoundaryIsNode, \"LinearRing\", namespaces.kml);\n  let coordinatesNode = queryFirstNode(linearRingNode, \"coordinates\", namespaces.kml);\n  const ellipsoid = dataSource._ellipsoid;\n  let coordinates = readCoordinates(coordinatesNode, ellipsoid);\n  const extrude = queryBooleanValue(geometryNode, \"extrude\", namespaces.kml);\n  const altitudeMode = queryStringValue(geometryNode, \"altitudeMode\", namespaces.kml);\n  const gxAltitudeMode = queryStringValue(geometryNode, \"altitudeMode\", namespaces.gx);\n  const canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);\n  const polygon = defined(styleEntity.polygon) ? styleEntity.polygon.clone() : createDefaultPolygon();\n  const polyline = styleEntity.polyline;\n  if (defined(polyline)) {\n    polygon.outlineColor = defined(polyline.material) ? polyline.material.color : Color.WHITE;\n    polygon.outlineWidth = polyline.width;\n  }\n  entity.polygon = polygon;\n  if (canExtrude) {\n    polygon.perPositionHeight = true;\n    polygon.extrudedHeight = extrude ? 0 : undefined;\n  } else if (!dataSource._clampToGround) {\n    polygon.height = 0;\n  }\n  if (defined(coordinates)) {\n    const hierarchy = new PolygonHierarchy(coordinates);\n    const innerBoundaryIsNodes = queryChildNodes(geometryNode, \"innerBoundaryIs\", namespaces.kml);\n    for (let j = 0; j < innerBoundaryIsNodes.length; j++) {\n      linearRingNode = queryChildNodes(innerBoundaryIsNodes[j], \"LinearRing\", namespaces.kml);\n      for (let k = 0; k < linearRingNode.length; k++) {\n        coordinatesNode = queryFirstNode(linearRingNode[k], \"coordinates\", namespaces.kml);\n        coordinates = readCoordinates(coordinatesNode, ellipsoid);\n        if (defined(coordinates)) {\n          hierarchy.holes.push(new PolygonHierarchy(coordinates));\n        }\n      }\n    }\n    polygon.hierarchy = hierarchy;\n  }\n  return true;\n}\nfunction processTrack(dataSource, entityCollection, geometryNode, entity, styleEntity) {\n  const altitudeMode = queryStringValue(geometryNode, \"altitudeMode\", namespaces.kml);\n  const gxAltitudeMode = queryStringValue(geometryNode, \"altitudeMode\", namespaces.gx);\n  const coordNodes = queryChildNodes(geometryNode, \"coord\", namespaces.gx);\n  const angleNodes = queryChildNodes(geometryNode, \"angles\", namespaces.gx);\n  const timeNodes = queryChildNodes(geometryNode, \"when\", namespaces.kml);\n  const extrude = queryBooleanValue(geometryNode, \"extrude\", namespaces.kml);\n  const canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);\n  const ellipsoid = dataSource._ellipsoid;\n  if (angleNodes.length > 0) {\n    oneTimeWarning(\"kml-gx:angles\", \"KML - gx:angles are not supported in gx:Tracks\");\n  }\n  const length = Math.min(coordNodes.length, timeNodes.length);\n  const coordinates = [];\n  const times = [];\n  for (let i = 0; i < length; i++) {\n    const position = readCoordinate(coordNodes[i].textContent, ellipsoid);\n    coordinates.push(position);\n    times.push(JulianDate.fromIso8601(timeNodes[i].textContent));\n  }\n  const property = new SampledPositionProperty();\n  property.addSamples(times, coordinates);\n  entity.position = property;\n  processPositionGraphics(dataSource, entity, styleEntity, heightReferenceFromAltitudeMode(altitudeMode, gxAltitudeMode));\n  processPathGraphics(entity, styleEntity);\n  entity.availability = new TimeIntervalCollection();\n  if (timeNodes.length > 0) {\n    entity.availability.addInterval(new TimeInterval({\n      start: times[0],\n      stop: times[times.length - 1]\n    }));\n  }\n  if (canExtrude && extrude) {\n    createDropLine(entityCollection, entity, styleEntity);\n  }\n  return true;\n}\nfunction addToMultiTrack(times, positions, composite, availability, dropShowProperty, extrude, altitudeMode, gxAltitudeMode, includeEndPoints) {\n  const start = times[0];\n  const stop = times[times.length - 1];\n  const data = new SampledPositionProperty();\n  data.addSamples(times, positions);\n  composite.intervals.addInterval(new TimeInterval({\n    start: start,\n    stop: stop,\n    isStartIncluded: includeEndPoints,\n    isStopIncluded: includeEndPoints,\n    data: createPositionPropertyFromAltitudeMode(data, altitudeMode, gxAltitudeMode)\n  }));\n  availability.addInterval(new TimeInterval({\n    start: start,\n    stop: stop,\n    isStartIncluded: includeEndPoints,\n    isStopIncluded: includeEndPoints\n  }));\n  dropShowProperty.intervals.addInterval(new TimeInterval({\n    start: start,\n    stop: stop,\n    isStartIncluded: includeEndPoints,\n    isStopIncluded: includeEndPoints,\n    data: extrude\n  }));\n}\nfunction processMultiTrack(dataSource, entityCollection, geometryNode, entity, styleEntity) {\n  // Multitrack options do not work in GE as detailed in the spec,\n  // rather than altitudeMode being at the MultiTrack level,\n  // GE just defers all settings to the underlying track.\n\n  const interpolate = queryBooleanValue(geometryNode, \"interpolate\", namespaces.gx);\n  const trackNodes = queryChildNodes(geometryNode, \"Track\", namespaces.gx);\n  let times;\n  let lastStop;\n  let lastStopPosition;\n  let needDropLine = false;\n  const dropShowProperty = new TimeIntervalCollectionProperty();\n  const availability = new TimeIntervalCollection();\n  const composite = new CompositePositionProperty();\n  const ellipsoid = dataSource._ellipsoid;\n  for (let i = 0, len = trackNodes.length; i < len; i++) {\n    const trackNode = trackNodes[i];\n    const timeNodes = queryChildNodes(trackNode, \"when\", namespaces.kml);\n    const coordNodes = queryChildNodes(trackNode, \"coord\", namespaces.gx);\n    const altitudeMode = queryStringValue(trackNode, \"altitudeMode\", namespaces.kml);\n    const gxAltitudeMode = queryStringValue(trackNode, \"altitudeMode\", namespaces.gx);\n    const canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);\n    const extrude = queryBooleanValue(trackNode, \"extrude\", namespaces.kml);\n    const length = Math.min(coordNodes.length, timeNodes.length);\n    const positions = [];\n    times = [];\n    for (let x = 0; x < length; x++) {\n      const position = readCoordinate(coordNodes[x].textContent, ellipsoid);\n      positions.push(position);\n      times.push(JulianDate.fromIso8601(timeNodes[x].textContent));\n    }\n    if (interpolate) {\n      //If we are interpolating, then we need to fill in the end of\n      //the last track and the beginning of this one with a sampled\n      //property.  From testing in Google Earth, this property\n      //is never extruded and always absolute.\n      if (defined(lastStop)) {\n        addToMultiTrack([lastStop, times[0]], [lastStopPosition, positions[0]], composite, availability, dropShowProperty, false, \"absolute\", undefined, false);\n      }\n      lastStop = times[length - 1];\n      lastStopPosition = positions[positions.length - 1];\n    }\n    addToMultiTrack(times, positions, composite, availability, dropShowProperty, canExtrude && extrude, altitudeMode, gxAltitudeMode, true);\n    needDropLine = needDropLine || canExtrude && extrude;\n  }\n  entity.availability = availability;\n  entity.position = composite;\n  processPositionGraphics(dataSource, entity, styleEntity);\n  processPathGraphics(entity, styleEntity);\n  if (needDropLine) {\n    createDropLine(entityCollection, entity, styleEntity);\n    entity.polyline.show = dropShowProperty;\n  }\n  return true;\n}\nconst geometryTypes = {\n  Point: processPoint,\n  LineString: processLineStringOrLinearRing,\n  LinearRing: processLineStringOrLinearRing,\n  Polygon: processPolygon,\n  Track: processTrack,\n  MultiTrack: processMultiTrack,\n  MultiGeometry: processMultiGeometry,\n  Model: processUnsupportedGeometry\n};\nfunction processMultiGeometry(dataSource, entityCollection, geometryNode, entity, styleEntity, context) {\n  const childNodes = geometryNode.childNodes;\n  let hasGeometry = false;\n  for (let i = 0, len = childNodes.length; i < len; i++) {\n    const childNode = childNodes.item(i);\n    const geometryProcessor = geometryTypes[childNode.localName];\n    if (defined(geometryProcessor)) {\n      const childEntity = createEntity(childNode, entityCollection, context);\n      childEntity.parent = entity;\n      childEntity.name = entity.name;\n      childEntity.availability = entity.availability;\n      childEntity.description = entity.description;\n      childEntity.kml = entity.kml;\n      if (geometryProcessor(dataSource, entityCollection, childNode, childEntity, styleEntity)) {\n        hasGeometry = true;\n      }\n    }\n  }\n  return hasGeometry;\n}\nfunction processUnsupportedGeometry(dataSource, entityCollection, geometryNode, entity, styleEntity) {\n  oneTimeWarning(\"kml-unsupportedGeometry\", `KML - Unsupported geometry: ${geometryNode.localName}`);\n  return false;\n}\nfunction processExtendedData(node, entity) {\n  const extendedDataNode = queryFirstNode(node, \"ExtendedData\", namespaces.kml);\n  if (!defined(extendedDataNode)) {\n    return undefined;\n  }\n  if (defined(queryFirstNode(extendedDataNode, \"SchemaData\", namespaces.kml))) {\n    oneTimeWarning(\"kml-schemaData\", \"KML - SchemaData is unsupported\");\n  }\n  if (defined(queryStringAttribute(extendedDataNode, \"xmlns:prefix\"))) {\n    oneTimeWarning(\"kml-extendedData\", \"KML - ExtendedData with xmlns:prefix is unsupported\");\n  }\n  const result = {};\n  const dataNodes = queryChildNodes(extendedDataNode, \"Data\", namespaces.kml);\n  if (defined(dataNodes)) {\n    const length = dataNodes.length;\n    for (let i = 0; i < length; i++) {\n      const dataNode = dataNodes[i];\n      const name = queryStringAttribute(dataNode, \"name\");\n      if (defined(name)) {\n        result[name] = {\n          displayName: queryStringValue(dataNode, \"displayName\", namespaces.kml),\n          value: queryStringValue(dataNode, \"value\", namespaces.kml)\n        };\n      }\n    }\n  }\n  entity.kml.extendedData = result;\n}\nlet scratchDiv;\nif (typeof document !== \"undefined\") {\n  scratchDiv = document.createElement(\"div\");\n}\nfunction processDescription(node, entity, styleEntity, uriResolver, sourceResource) {\n  let i;\n  let key;\n  let keys;\n  const kmlData = entity.kml;\n  const extendedData = kmlData.extendedData;\n  const description = queryStringValue(node, \"description\", namespaces.kml);\n  const balloonStyle = entity.balloonStyle ?? styleEntity.balloonStyle;\n  let background = Color.WHITE;\n  let foreground = Color.BLACK;\n  let text = description;\n  if (defined(balloonStyle)) {\n    background = balloonStyle.bgColor ?? Color.WHITE;\n    foreground = balloonStyle.textColor ?? Color.BLACK;\n    text = balloonStyle.text ?? description;\n  }\n  let value;\n  if (defined(text)) {\n    text = text.replace(\"$[name]\", entity.name ?? \"\");\n    text = text.replace(\"$[description]\", description ?? \"\");\n    text = text.replace(\"$[address]\", kmlData.address ?? \"\");\n    text = text.replace(\"$[Snippet]\", kmlData.snippet ?? \"\");\n    text = text.replace(\"$[id]\", entity.id);\n\n    //While not explicitly defined by the OGC spec, in Google Earth\n    //The appearance of geDirections adds the directions to/from links\n    //We simply replace this string with nothing.\n    text = text.replace(\"$[geDirections]\", \"\");\n    if (defined(extendedData)) {\n      const matches = text.match(/\\$\\[.+?\\]/g);\n      if (matches !== null) {\n        for (i = 0; i < matches.length; i++) {\n          const token = matches[i];\n          let propertyName = token.substr(2, token.length - 3);\n          const isDisplayName = /\\/displayName$/.test(propertyName);\n          propertyName = propertyName.replace(/\\/displayName$/, \"\");\n          value = extendedData[propertyName];\n          if (defined(value)) {\n            value = isDisplayName ? value.displayName : value.value;\n          }\n          if (defined(value)) {\n            text = text.replace(token, value ?? \"\");\n          }\n        }\n      }\n    }\n  } else if (defined(extendedData)) {\n    //If no description exists, build a table out of the extended data\n    keys = Object.keys(extendedData);\n    if (keys.length > 0) {\n      text = '<table class=\"cesium-infoBox-defaultTable cesium-infoBox-defaultTable-lighter\"><tbody>';\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n        value = extendedData[key];\n        text += `<tr><th>${value.displayName ?? key}</th><td>${value.value ?? \"\"}</td></tr>`;\n      }\n      text += \"</tbody></table>\";\n    }\n  }\n  if (!defined(text)) {\n    //No description\n    return;\n  }\n\n  //Turns non-explicit links into clickable links.\n  text = autolinker.link(text);\n\n  //Use a temporary div to manipulate the links\n  //so that they open in a new window.\n  scratchDiv.innerHTML = text;\n  const links = scratchDiv.querySelectorAll(\"a\");\n  for (i = 0; i < links.length; i++) {\n    links[i].setAttribute(\"target\", \"_blank\");\n  }\n\n  //Rewrite any KMZ embedded urls\n  if (defined(uriResolver) && uriResolver.keys.length > 1) {\n    embedDataUris(scratchDiv, \"a\", \"href\", uriResolver);\n    embedDataUris(scratchDiv, \"link\", \"href\", uriResolver);\n    embedDataUris(scratchDiv, \"area\", \"href\", uriResolver);\n    embedDataUris(scratchDiv, \"img\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"iframe\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"video\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"audio\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"source\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"track\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"input\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"embed\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"script\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"video\", \"poster\", uriResolver);\n  }\n\n  //Make relative urls absolute using the sourceResource\n  applyBasePath(scratchDiv, \"a\", \"href\", sourceResource);\n  applyBasePath(scratchDiv, \"link\", \"href\", sourceResource);\n  applyBasePath(scratchDiv, \"area\", \"href\", sourceResource);\n  applyBasePath(scratchDiv, \"img\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"iframe\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"video\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"audio\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"source\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"track\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"input\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"embed\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"script\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"video\", \"poster\", sourceResource);\n  let tmp = '<div class=\"cesium-infoBox-description-lighter\" style=\"';\n  tmp += \"overflow:auto;\";\n  tmp += \"word-wrap:break-word;\";\n  tmp += `background-color:${background.toCssColorString()};`;\n  tmp += `color:${foreground.toCssColorString()};`;\n  tmp += '\">';\n  tmp += `${scratchDiv.innerHTML}</div>`;\n  scratchDiv.innerHTML = \"\";\n\n  //Set the final HTML as the description.\n  entity.description = tmp;\n}\nfunction processFeature(dataSource, featureNode, processingData) {\n  const entityCollection = processingData.entityCollection;\n  const parent = processingData.parentEntity;\n  const sourceResource = processingData.sourceResource;\n  const uriResolver = processingData.uriResolver;\n  const entity = createEntity(featureNode, entityCollection, processingData.context);\n  const kmlData = entity.kml;\n  const styleEntity = computeFinalStyle(dataSource, featureNode, processingData.styleCollection, sourceResource, uriResolver);\n  const name = queryStringValue(featureNode, \"name\", namespaces.kml);\n  entity.name = name;\n  entity.parent = parent;\n  let availability = processTimeSpan(featureNode);\n  if (!defined(availability)) {\n    availability = processTimeStamp(featureNode);\n  }\n  entity.availability = availability;\n  mergeAvailabilityWithParent(entity);\n\n  // Per KML spec \"A Feature is visible only if it and all its ancestors are visible.\"\n  function ancestryIsVisible(parentEntity) {\n    if (!parentEntity) {\n      return true;\n    }\n    return parentEntity.show && ancestryIsVisible(parentEntity.parent);\n  }\n  const visibility = queryBooleanValue(featureNode, \"visibility\", namespaces.kml);\n  entity.show = ancestryIsVisible(parent) && (visibility ?? true);\n  //const open = queryBooleanValue(featureNode, 'open', namespaces.kml);\n\n  const authorNode = queryFirstNode(featureNode, \"author\", namespaces.atom);\n  const author = kmlData.author;\n  author.name = queryStringValue(authorNode, \"name\", namespaces.atom);\n  author.uri = queryStringValue(authorNode, \"uri\", namespaces.atom);\n  author.email = queryStringValue(authorNode, \"email\", namespaces.atom);\n  const linkNode = queryFirstNode(featureNode, \"link\", namespaces.atom);\n  const link = kmlData.link;\n  link.href = queryStringAttribute(linkNode, \"href\");\n  link.hreflang = queryStringAttribute(linkNode, \"hreflang\");\n  link.rel = queryStringAttribute(linkNode, \"rel\");\n  link.type = queryStringAttribute(linkNode, \"type\");\n  link.title = queryStringAttribute(linkNode, \"title\");\n  link.length = queryStringAttribute(linkNode, \"length\");\n  kmlData.address = queryStringValue(featureNode, \"address\", namespaces.kml);\n  kmlData.phoneNumber = queryStringValue(featureNode, \"phoneNumber\", namespaces.kml);\n  kmlData.snippet = queryStringValue(featureNode, \"Snippet\", namespaces.kml);\n  processExtendedData(featureNode, entity);\n  processDescription(featureNode, entity, styleEntity, uriResolver, sourceResource);\n  const ellipsoid = dataSource._ellipsoid;\n  processLookAt(featureNode, entity, ellipsoid);\n  processCamera(featureNode, entity, ellipsoid);\n  if (defined(queryFirstNode(featureNode, \"Region\", namespaces.kml))) {\n    oneTimeWarning(\"kml-region\", \"KML - Placemark Regions are unsupported\");\n  }\n  return {\n    entity: entity,\n    styleEntity: styleEntity\n  };\n}\nfunction processDocument(dataSource, node, processingData, deferredLoading) {\n  deferredLoading.addNodes(node.childNodes, processingData);\n  deferredLoading.process();\n}\nfunction processFolder(dataSource, node, processingData, deferredLoading) {\n  const r = processFeature(dataSource, node, processingData);\n  const newProcessingData = clone(processingData);\n  newProcessingData.parentEntity = r.entity;\n  processDocument(dataSource, node, newProcessingData, deferredLoading);\n}\nfunction processPlacemark(dataSource, placemark, processingData, deferredLoading) {\n  const r = processFeature(dataSource, placemark, processingData);\n  const entity = r.entity;\n  const styleEntity = r.styleEntity;\n  let hasGeometry = false;\n  const childNodes = placemark.childNodes;\n  for (let i = 0, len = childNodes.length; i < len && !hasGeometry; i++) {\n    const childNode = childNodes.item(i);\n    const geometryProcessor = geometryTypes[childNode.localName];\n    if (defined(geometryProcessor)) {\n      // pass the placemark entity id as a context for case of defining multiple child entities together to handle case\n      // where some malformed kmls reuse the same id across placemarks, which works in GE, but is not technically to spec.\n      geometryProcessor(dataSource, processingData.entityCollection, childNode, entity, styleEntity, entity.id);\n      hasGeometry = true;\n    }\n  }\n  if (!hasGeometry) {\n    entity.merge(styleEntity);\n    processPositionGraphics(dataSource, entity, styleEntity);\n  }\n}\nconst playlistNodeProcessors = {\n  FlyTo: processTourFlyTo,\n  Wait: processTourWait,\n  SoundCue: processTourUnsupportedNode,\n  AnimatedUpdate: processTourUnsupportedNode,\n  TourControl: processTourUnsupportedNode\n};\nfunction processTour(dataSource, node, processingData, deferredLoading) {\n  const name = queryStringValue(node, \"name\", namespaces.kml);\n  const id = queryStringAttribute(node, \"id\");\n  const tour = new KmlTour(name, id);\n  const playlistNode = queryFirstNode(node, \"Playlist\", namespaces.gx);\n  if (playlistNode) {\n    const ellipsoid = dataSource._ellipsoid;\n    const childNodes = playlistNode.childNodes;\n    for (let i = 0; i < childNodes.length; i++) {\n      const entryNode = childNodes[i];\n      if (entryNode.localName) {\n        const playlistNodeProcessor = playlistNodeProcessors[entryNode.localName];\n        if (playlistNodeProcessor) {\n          playlistNodeProcessor(tour, entryNode, ellipsoid);\n        } else {\n          console.log(`Unknown KML Tour playlist entry type ${entryNode.localName}`);\n        }\n      }\n    }\n  }\n  dataSource._kmlTours.push(tour);\n}\nfunction processTourUnsupportedNode(tour, entryNode) {\n  oneTimeWarning(`KML Tour unsupported node ${entryNode.localName}`);\n}\nfunction processTourWait(tour, entryNode) {\n  const duration = queryNumericValue(entryNode, \"duration\", namespaces.gx);\n  tour.addPlaylistEntry(new KmlTourWait(duration));\n}\nfunction processTourFlyTo(tour, entryNode, ellipsoid) {\n  const duration = queryNumericValue(entryNode, \"duration\", namespaces.gx);\n  const flyToMode = queryStringValue(entryNode, \"flyToMode\", namespaces.gx);\n  const t = {\n    kml: {}\n  };\n  processLookAt(entryNode, t, ellipsoid);\n  processCamera(entryNode, t, ellipsoid);\n  const view = t.kml.lookAt || t.kml.camera;\n  const flyto = new KmlTourFlyTo(duration, flyToMode, view);\n  tour.addPlaylistEntry(flyto);\n}\nfunction processCamera(featureNode, entity, ellipsoid) {\n  const camera = queryFirstNode(featureNode, \"Camera\", namespaces.kml);\n  if (defined(camera)) {\n    const lon = queryNumericValue(camera, \"longitude\", namespaces.kml) ?? 0.0;\n    const lat = queryNumericValue(camera, \"latitude\", namespaces.kml) ?? 0.0;\n    const altitude = queryNumericValue(camera, \"altitude\", namespaces.kml) ?? 0.0;\n    const heading = queryNumericValue(camera, \"heading\", namespaces.kml) ?? 0.0;\n    const tilt = queryNumericValue(camera, \"tilt\", namespaces.kml) ?? 0.0;\n    const roll = queryNumericValue(camera, \"roll\", namespaces.kml) ?? 0.0;\n    const position = Cartesian3.fromDegrees(lon, lat, altitude, ellipsoid);\n    const hpr = HeadingPitchRoll.fromDegrees(heading, tilt - 90.0, roll);\n    entity.kml.camera = new KmlCamera(position, hpr);\n  }\n}\nfunction processLookAt(featureNode, entity, ellipsoid) {\n  const lookAt = queryFirstNode(featureNode, \"LookAt\", namespaces.kml);\n  if (defined(lookAt)) {\n    const lon = queryNumericValue(lookAt, \"longitude\", namespaces.kml) ?? 0.0;\n    const lat = queryNumericValue(lookAt, \"latitude\", namespaces.kml) ?? 0.0;\n    const altitude = queryNumericValue(lookAt, \"altitude\", namespaces.kml) ?? 0.0;\n    let heading = queryNumericValue(lookAt, \"heading\", namespaces.kml);\n    let tilt = queryNumericValue(lookAt, \"tilt\", namespaces.kml);\n    const range = queryNumericValue(lookAt, \"range\", namespaces.kml) ?? 0.0;\n    tilt = CesiumMath.toRadians(tilt ?? 0.0);\n    heading = CesiumMath.toRadians(heading ?? 0.0);\n    const hpr = new HeadingPitchRange(heading, tilt - CesiumMath.PI_OVER_TWO, range);\n    const viewPoint = Cartesian3.fromDegrees(lon, lat, altitude, ellipsoid);\n    entity.kml.lookAt = new KmlLookAt(viewPoint, hpr);\n  }\n}\nfunction processScreenOverlay(dataSource, screenOverlayNode, processingData, deferredLoading) {\n  const screenOverlay = processingData.screenOverlayContainer;\n  if (!defined(screenOverlay)) {\n    return undefined;\n  }\n  const sourceResource = processingData.sourceResource;\n  const uriResolver = processingData.uriResolver;\n  const iconNode = queryFirstNode(screenOverlayNode, \"Icon\", namespaces.kml);\n  const icon = getIconHref(iconNode, dataSource, sourceResource, uriResolver, false);\n  if (!defined(icon)) {\n    return undefined;\n  }\n  const img = document.createElement(\"img\");\n  dataSource._screenOverlays.push(img);\n  img.src = icon.url;\n  img.onload = function () {\n    const styles = [\"position: absolute\"];\n    const screenXY = queryFirstNode(screenOverlayNode, \"screenXY\", namespaces.kml);\n    const overlayXY = queryFirstNode(screenOverlayNode, \"overlayXY\", namespaces.kml);\n    const size = queryFirstNode(screenOverlayNode, \"size\", namespaces.kml);\n    let x, y;\n    let xUnit, yUnit;\n    let xStyle, yStyle;\n    if (defined(size)) {\n      x = queryNumericAttribute(size, \"x\");\n      y = queryNumericAttribute(size, \"y\");\n      xUnit = queryStringAttribute(size, \"xunits\");\n      yUnit = queryStringAttribute(size, \"yunits\");\n      if (defined(x) && x !== -1 && x !== 0) {\n        if (xUnit === \"fraction\") {\n          xStyle = `width: ${Math.floor(x * 100)}%`;\n        } else if (xUnit === \"pixels\") {\n          xStyle = `width: ${x}px`;\n        }\n        styles.push(xStyle);\n      }\n      if (defined(y) && y !== -1 && y !== 0) {\n        if (yUnit === \"fraction\") {\n          yStyle = `height: ${Math.floor(y * 100)}%`;\n        } else if (yUnit === \"pixels\") {\n          yStyle = `height: ${y}px`;\n        }\n        styles.push(yStyle);\n      }\n    }\n\n    // set the interim style so the width/height properties get calculated\n    img.style = styles.join(\";\");\n    let xOrigin = 0;\n    let yOrigin = img.height;\n    if (defined(overlayXY)) {\n      x = queryNumericAttribute(overlayXY, \"x\");\n      y = queryNumericAttribute(overlayXY, \"y\");\n      xUnit = queryStringAttribute(overlayXY, \"xunits\");\n      yUnit = queryStringAttribute(overlayXY, \"yunits\");\n      if (defined(x)) {\n        if (xUnit === \"fraction\") {\n          xOrigin = x * img.width;\n        } else if (xUnit === \"pixels\") {\n          xOrigin = x;\n        } else if (xUnit === \"insetPixels\") {\n          xOrigin = x;\n        }\n      }\n      if (defined(y)) {\n        if (yUnit === \"fraction\") {\n          yOrigin = y * img.height;\n        } else if (yUnit === \"pixels\") {\n          yOrigin = y;\n        } else if (yUnit === \"insetPixels\") {\n          yOrigin = y;\n        }\n      }\n    }\n    if (defined(screenXY)) {\n      x = queryNumericAttribute(screenXY, \"x\");\n      y = queryNumericAttribute(screenXY, \"y\");\n      xUnit = queryStringAttribute(screenXY, \"xunits\");\n      yUnit = queryStringAttribute(screenXY, \"yunits\");\n      if (defined(x)) {\n        if (xUnit === \"fraction\") {\n          xStyle = `${\"left: \" + \"calc(\"}${Math.floor(x * 100)}% - ${xOrigin}px)`;\n        } else if (xUnit === \"pixels\") {\n          xStyle = `left: ${x - xOrigin}px`;\n        } else if (xUnit === \"insetPixels\") {\n          xStyle = `right: ${x - xOrigin}px`;\n        }\n        styles.push(xStyle);\n      }\n      if (defined(y)) {\n        if (yUnit === \"fraction\") {\n          yStyle = `${\"bottom: \" + \"calc(\"}${Math.floor(y * 100)}% - ${yOrigin}px)`;\n        } else if (yUnit === \"pixels\") {\n          yStyle = `bottom: ${y - yOrigin}px`;\n        } else if (yUnit === \"insetPixels\") {\n          yStyle = `top: ${y - yOrigin}px`;\n        }\n        styles.push(yStyle);\n      }\n    }\n    img.style = styles.join(\";\");\n  };\n  screenOverlay.appendChild(img);\n}\nfunction processGroundOverlay(dataSource, groundOverlay, processingData, deferredLoading) {\n  const r = processFeature(dataSource, groundOverlay, processingData);\n  const entity = r.entity;\n  let geometry;\n  let isLatLonQuad = false;\n  const ellipsoid = dataSource._ellipsoid;\n  const positions = readCoordinates(queryFirstNode(groundOverlay, \"LatLonQuad\", namespaces.gx), ellipsoid);\n  const zIndex = queryNumericValue(groundOverlay, \"drawOrder\", namespaces.kml);\n  if (defined(positions)) {\n    geometry = createDefaultPolygon();\n    geometry.hierarchy = new PolygonHierarchy(positions);\n    geometry.zIndex = zIndex;\n    entity.polygon = geometry;\n    isLatLonQuad = true;\n  } else {\n    geometry = new RectangleGraphics();\n    geometry.zIndex = zIndex;\n    entity.rectangle = geometry;\n    const latLonBox = queryFirstNode(groundOverlay, \"LatLonBox\", namespaces.kml);\n    if (defined(latLonBox)) {\n      let west = queryNumericValue(latLonBox, \"west\", namespaces.kml);\n      let south = queryNumericValue(latLonBox, \"south\", namespaces.kml);\n      let east = queryNumericValue(latLonBox, \"east\", namespaces.kml);\n      let north = queryNumericValue(latLonBox, \"north\", namespaces.kml);\n      if (defined(west)) {\n        west = CesiumMath.negativePiToPi(CesiumMath.toRadians(west));\n      }\n      if (defined(south)) {\n        south = CesiumMath.clampToLatitudeRange(CesiumMath.toRadians(south));\n      }\n      if (defined(east)) {\n        east = CesiumMath.negativePiToPi(CesiumMath.toRadians(east));\n      }\n      if (defined(north)) {\n        north = CesiumMath.clampToLatitudeRange(CesiumMath.toRadians(north));\n      }\n      geometry.coordinates = new Rectangle(west, south, east, north);\n      const rotation = queryNumericValue(latLonBox, \"rotation\", namespaces.kml);\n      if (defined(rotation)) {\n        const rotationRadians = CesiumMath.toRadians(rotation);\n        geometry.rotation = rotationRadians;\n        geometry.stRotation = rotationRadians;\n      }\n    }\n  }\n  const iconNode = queryFirstNode(groundOverlay, \"Icon\", namespaces.kml);\n  const href = getIconHref(iconNode, dataSource, processingData.sourceResource, processingData.uriResolver, true);\n  if (defined(href)) {\n    if (isLatLonQuad) {\n      oneTimeWarning(\"kml-gx:LatLonQuad\", \"KML - gx:LatLonQuad Icon does not support texture projection.\");\n    }\n    const x = queryNumericValue(iconNode, \"x\", namespaces.gx);\n    const y = queryNumericValue(iconNode, \"y\", namespaces.gx);\n    const w = queryNumericValue(iconNode, \"w\", namespaces.gx);\n    const h = queryNumericValue(iconNode, \"h\", namespaces.gx);\n    if (defined(x) || defined(y) || defined(w) || defined(h)) {\n      oneTimeWarning(\"kml-groundOverlay-xywh\", \"KML - gx:x, gx:y, gx:w, gx:h aren't supported for GroundOverlays\");\n    }\n    geometry.material = href;\n    geometry.material.color = queryColorValue(groundOverlay, \"color\", namespaces.kml);\n    geometry.material.transparent = true;\n  } else {\n    geometry.material = queryColorValue(groundOverlay, \"color\", namespaces.kml);\n  }\n  let altitudeMode = queryStringValue(groundOverlay, \"altitudeMode\", namespaces.kml);\n  if (defined(altitudeMode)) {\n    if (altitudeMode === \"absolute\") {\n      //Use height above ellipsoid until we support MSL.\n      geometry.height = queryNumericValue(groundOverlay, \"altitude\", namespaces.kml);\n      geometry.zIndex = undefined;\n    } else if (altitudeMode !== \"clampToGround\") {\n      oneTimeWarning(\"kml-altitudeMode-unknown\", `KML - Unknown altitudeMode: ${altitudeMode}`);\n    }\n    // else just use the default of 0 until we support 'clampToGround'\n  } else {\n    altitudeMode = queryStringValue(groundOverlay, \"altitudeMode\", namespaces.gx);\n    if (altitudeMode === \"relativeToSeaFloor\") {\n      oneTimeWarning(\"kml-altitudeMode-relativeToSeaFloor\", \"KML - altitudeMode relativeToSeaFloor is currently not supported, treating as absolute.\");\n      geometry.height = queryNumericValue(groundOverlay, \"altitude\", namespaces.kml);\n      geometry.zIndex = undefined;\n    } else if (altitudeMode === \"clampToSeaFloor\") {\n      oneTimeWarning(\"kml-altitudeMode-clampToSeaFloor\", \"KML - altitudeMode clampToSeaFloor is currently not supported, treating as clampToGround.\");\n    } else if (defined(altitudeMode)) {\n      oneTimeWarning(\"kml-altitudeMode-unknown\", `KML - Unknown altitudeMode: ${altitudeMode}`);\n    }\n  }\n}\nfunction processUnsupportedFeature(dataSource, node, processingData, deferredLoading) {\n  dataSource._unsupportedNode.raiseEvent(dataSource, processingData.parentEntity, node, processingData.entityCollection, processingData.styleCollection, processingData.sourceResource, processingData.uriResolver);\n  oneTimeWarning(`kml-unsupportedFeature-${node.nodeName}`, `KML - Unsupported feature: ${node.nodeName}`);\n}\nconst RefreshMode = {\n  INTERVAL: 0,\n  EXPIRE: 1,\n  STOP: 2\n};\nfunction cleanupString(s) {\n  if (!defined(s) || s.length === 0) {\n    return \"\";\n  }\n  const sFirst = s[0];\n  if (sFirst === \"&\" || sFirst === \"?\") {\n    s = s.substring(1);\n  }\n  return s;\n}\nconst zeroRectangle = new Rectangle();\nconst scratchCartographic = new Cartographic();\nconst scratchCartesian2 = new Cartesian2();\nconst scratchCartesian3 = new Cartesian3();\nfunction processNetworkLinkQueryString(resource, camera, canvas, viewBoundScale, bbox, ellipsoid) {\n  function fixLatitude(value) {\n    if (value < -CesiumMath.PI_OVER_TWO) {\n      return -CesiumMath.PI_OVER_TWO;\n    } else if (value > CesiumMath.PI_OVER_TWO) {\n      return CesiumMath.PI_OVER_TWO;\n    }\n    return value;\n  }\n  function fixLongitude(value) {\n    if (value > CesiumMath.PI) {\n      return value - CesiumMath.TWO_PI;\n    } else if (value < -CesiumMath.PI) {\n      return value + CesiumMath.TWO_PI;\n    }\n    return value;\n  }\n  let queryString = objectToQuery(resource.queryParameters);\n\n  // objectToQuery escapes [ and ], so fix that\n  queryString = queryString.replace(/%5B/g, \"[\").replace(/%5D/g, \"]\");\n  if (defined(camera) && camera._mode !== SceneMode.MORPHING) {\n    let centerCartesian;\n    let centerCartographic;\n    bbox = bbox ?? zeroRectangle;\n    if (defined(canvas)) {\n      scratchCartesian2.x = canvas.clientWidth * 0.5;\n      scratchCartesian2.y = canvas.clientHeight * 0.5;\n      centerCartesian = camera.pickEllipsoid(scratchCartesian2, ellipsoid, scratchCartesian3);\n    }\n    if (defined(centerCartesian)) {\n      centerCartographic = ellipsoid.cartesianToCartographic(centerCartesian, scratchCartographic);\n    } else {\n      centerCartographic = Rectangle.center(bbox, scratchCartographic);\n      centerCartesian = ellipsoid.cartographicToCartesian(centerCartographic);\n    }\n    if (defined(viewBoundScale) && !CesiumMath.equalsEpsilon(viewBoundScale, 1.0, CesiumMath.EPSILON9)) {\n      const newHalfWidth = bbox.width * viewBoundScale * 0.5;\n      const newHalfHeight = bbox.height * viewBoundScale * 0.5;\n      bbox = new Rectangle(fixLongitude(centerCartographic.longitude - newHalfWidth), fixLatitude(centerCartographic.latitude - newHalfHeight), fixLongitude(centerCartographic.longitude + newHalfWidth), fixLatitude(centerCartographic.latitude + newHalfHeight));\n    }\n    queryString = queryString.replace(\"[bboxWest]\", CesiumMath.toDegrees(bbox.west).toString());\n    queryString = queryString.replace(\"[bboxSouth]\", CesiumMath.toDegrees(bbox.south).toString());\n    queryString = queryString.replace(\"[bboxEast]\", CesiumMath.toDegrees(bbox.east).toString());\n    queryString = queryString.replace(\"[bboxNorth]\", CesiumMath.toDegrees(bbox.north).toString());\n    const lon = CesiumMath.toDegrees(centerCartographic.longitude).toString();\n    const lat = CesiumMath.toDegrees(centerCartographic.latitude).toString();\n    queryString = queryString.replace(\"[lookatLon]\", lon);\n    queryString = queryString.replace(\"[lookatLat]\", lat);\n    queryString = queryString.replace(\"[lookatTilt]\", CesiumMath.toDegrees(camera.pitch).toString());\n    queryString = queryString.replace(\"[lookatHeading]\", CesiumMath.toDegrees(camera.heading).toString());\n    queryString = queryString.replace(\"[lookatRange]\", Cartesian3.distance(camera.positionWC, centerCartesian));\n    queryString = queryString.replace(\"[lookatTerrainLon]\", lon);\n    queryString = queryString.replace(\"[lookatTerrainLat]\", lat);\n    queryString = queryString.replace(\"[lookatTerrainAlt]\", centerCartographic.height.toString());\n    ellipsoid.cartesianToCartographic(camera.positionWC, scratchCartographic);\n    queryString = queryString.replace(\"[cameraLon]\", CesiumMath.toDegrees(scratchCartographic.longitude).toString());\n    queryString = queryString.replace(\"[cameraLat]\", CesiumMath.toDegrees(scratchCartographic.latitude).toString());\n    queryString = queryString.replace(\"[cameraAlt]\", CesiumMath.toDegrees(scratchCartographic.height).toString());\n    const frustum = camera.frustum;\n    const aspectRatio = frustum.aspectRatio;\n    let horizFov = \"\";\n    let vertFov = \"\";\n    if (defined(aspectRatio)) {\n      const fov = CesiumMath.toDegrees(frustum.fov);\n      if (aspectRatio > 1.0) {\n        horizFov = fov;\n        vertFov = fov / aspectRatio;\n      } else {\n        vertFov = fov;\n        horizFov = fov * aspectRatio;\n      }\n    }\n    queryString = queryString.replace(\"[horizFov]\", horizFov.toString());\n    queryString = queryString.replace(\"[vertFov]\", vertFov.toString());\n  } else {\n    queryString = queryString.replace(\"[bboxWest]\", \"-180\");\n    queryString = queryString.replace(\"[bboxSouth]\", \"-90\");\n    queryString = queryString.replace(\"[bboxEast]\", \"180\");\n    queryString = queryString.replace(\"[bboxNorth]\", \"90\");\n    queryString = queryString.replace(\"[lookatLon]\", \"\");\n    queryString = queryString.replace(\"[lookatLat]\", \"\");\n    queryString = queryString.replace(\"[lookatRange]\", \"\");\n    queryString = queryString.replace(\"[lookatTilt]\", \"\");\n    queryString = queryString.replace(\"[lookatHeading]\", \"\");\n    queryString = queryString.replace(\"[lookatTerrainLon]\", \"\");\n    queryString = queryString.replace(\"[lookatTerrainLat]\", \"\");\n    queryString = queryString.replace(\"[lookatTerrainAlt]\", \"\");\n    queryString = queryString.replace(\"[cameraLon]\", \"\");\n    queryString = queryString.replace(\"[cameraLat]\", \"\");\n    queryString = queryString.replace(\"[cameraAlt]\", \"\");\n    queryString = queryString.replace(\"[horizFov]\", \"\");\n    queryString = queryString.replace(\"[vertFov]\", \"\");\n  }\n  if (defined(canvas)) {\n    queryString = queryString.replace(\"[horizPixels]\", canvas.clientWidth);\n    queryString = queryString.replace(\"[vertPixels]\", canvas.clientHeight);\n  } else {\n    queryString = queryString.replace(\"[horizPixels]\", \"\");\n    queryString = queryString.replace(\"[vertPixels]\", \"\");\n  }\n  queryString = queryString.replace(\"[terrainEnabled]\", \"1\");\n  queryString = queryString.replace(\"[clientVersion]\", \"1\");\n  queryString = queryString.replace(\"[kmlVersion]\", \"2.2\");\n  queryString = queryString.replace(\"[clientName]\", \"Cesium\");\n  queryString = queryString.replace(\"[language]\", \"English\");\n  resource.setQueryParameters(queryToObject(queryString));\n}\nfunction processNetworkLink(dataSource, node, processingData, deferredLoading) {\n  const r = processFeature(dataSource, node, processingData);\n  const networkEntity = r.entity;\n  const sourceResource = processingData.sourceResource;\n  const uriResolver = processingData.uriResolver;\n  let link = queryFirstNode(node, \"Link\", namespaces.kml);\n  if (!defined(link)) {\n    link = queryFirstNode(node, \"Url\", namespaces.kml);\n  }\n  if (defined(link)) {\n    let href = queryStringValue(link, \"href\", namespaces.kml);\n    let viewRefreshMode;\n    let viewBoundScale;\n    if (defined(href)) {\n      let newSourceUri = href;\n      href = resolveHref(href, sourceResource, processingData.uriResolver);\n\n      // We need to pass in the original path if resolveHref returns a data uri because the network link\n      //  references a document in a KMZ archive\n      if (/^data:/.test(href.getUrlComponent())) {\n        // So if sourceUri isn't the kmz file, then its another kml in the archive, so resolve it\n        if (!/\\.kmz/i.test(sourceResource.getUrlComponent())) {\n          newSourceUri = sourceResource.getDerivedResource({\n            url: newSourceUri\n          });\n        }\n      } else {\n        newSourceUri = href.clone(); // Not a data uri so use the fully qualified uri\n        viewRefreshMode = queryStringValue(link, \"viewRefreshMode\", namespaces.kml);\n        if (viewRefreshMode === \"onRegion\") {\n          oneTimeWarning(\"kml-refrehMode-onRegion\", \"KML - Unsupported viewRefreshMode: onRegion\");\n          return;\n        }\n        viewBoundScale = queryStringValue(link, \"viewBoundScale\", namespaces.kml) ?? 1.0;\n        const defaultViewFormat = viewRefreshMode === \"onStop\" ? \"BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]\" : \"\";\n        const viewFormat = queryStringValue(link, \"viewFormat\", namespaces.kml) ?? defaultViewFormat;\n        const httpQuery = queryStringValue(link, \"httpQuery\", namespaces.kml);\n        if (defined(viewFormat)) {\n          href.setQueryParameters(queryToObject(cleanupString(viewFormat)));\n        }\n        if (defined(httpQuery)) {\n          href.setQueryParameters(queryToObject(cleanupString(httpQuery)));\n        }\n        const ellipsoid = dataSource._ellipsoid;\n        processNetworkLinkQueryString(href, dataSource.camera, dataSource.canvas, viewBoundScale, dataSource._lastCameraView.bbox, ellipsoid);\n      }\n      const options = {\n        sourceUri: newSourceUri,\n        uriResolver: uriResolver,\n        context: networkEntity.id,\n        screenOverlayContainer: processingData.screenOverlayContainer\n      };\n      const networkLinkCollection = new EntityCollection();\n      const promise = load(dataSource, networkLinkCollection, href, options).then(function (rootElement) {\n        const entities = dataSource._entityCollection;\n        const newEntities = networkLinkCollection.values;\n        entities.suspendEvents();\n        for (let i = 0; i < newEntities.length; i++) {\n          const newEntity = newEntities[i];\n          if (!defined(newEntity.parent)) {\n            newEntity.parent = networkEntity;\n            mergeAvailabilityWithParent(newEntity);\n          }\n          entities.add(newEntity);\n        }\n        entities.resumeEvents();\n\n        // Add network links to a list if we need they will need to be updated\n        const refreshMode = queryStringValue(link, \"refreshMode\", namespaces.kml);\n        let refreshInterval = queryNumericValue(link, \"refreshInterval\", namespaces.kml) ?? 0;\n        if (refreshMode === \"onInterval\" && refreshInterval > 0 || refreshMode === \"onExpire\" || viewRefreshMode === \"onStop\") {\n          const networkLinkControl = queryFirstNode(rootElement, \"NetworkLinkControl\", namespaces.kml);\n          const hasNetworkLinkControl = defined(networkLinkControl);\n          const now = JulianDate.now();\n          const networkLinkInfo = {\n            id: createGuid(),\n            href: href,\n            cookie: {},\n            lastUpdated: now,\n            updating: false,\n            entity: networkEntity,\n            viewBoundScale: viewBoundScale,\n            needsUpdate: false,\n            cameraUpdateTime: now\n          };\n          let minRefreshPeriod = 0;\n          if (hasNetworkLinkControl) {\n            networkLinkInfo.cookie = queryToObject(queryStringValue(networkLinkControl, \"cookie\", namespaces.kml) ?? \"\");\n            minRefreshPeriod = queryNumericValue(networkLinkControl, \"minRefreshPeriod\", namespaces.kml) ?? 0;\n          }\n          if (refreshMode === \"onInterval\") {\n            if (hasNetworkLinkControl) {\n              refreshInterval = Math.max(minRefreshPeriod, refreshInterval);\n            }\n            networkLinkInfo.refreshMode = RefreshMode.INTERVAL;\n            networkLinkInfo.time = refreshInterval;\n          } else if (refreshMode === \"onExpire\") {\n            let expires;\n            if (hasNetworkLinkControl) {\n              expires = queryStringValue(networkLinkControl, \"expires\", namespaces.kml);\n            }\n            if (defined(expires)) {\n              try {\n                const date = JulianDate.fromIso8601(expires);\n                const diff = JulianDate.secondsDifference(date, now);\n                if (diff > 0 && diff < minRefreshPeriod) {\n                  JulianDate.addSeconds(now, minRefreshPeriod, date);\n                }\n                networkLinkInfo.refreshMode = RefreshMode.EXPIRE;\n                networkLinkInfo.time = date;\n              } catch (e) {\n                oneTimeWarning(\"kml-refreshMode-onInterval-onExpire\", \"KML - NetworkLinkControl expires is not a valid date\");\n              }\n            } else {\n              oneTimeWarning(\"kml-refreshMode-onExpire\", \"KML - refreshMode of onExpire requires the NetworkLinkControl to have an expires element\");\n            }\n          } else if (defined(dataSource.camera)) {\n            // Only allow onStop refreshes if we have a camera\n            networkLinkInfo.refreshMode = RefreshMode.STOP;\n            networkLinkInfo.time = queryNumericValue(link, \"viewRefreshTime\", namespaces.kml) ?? 0;\n          } else {\n            oneTimeWarning(\"kml-refrehMode-onStop-noCamera\", \"A NetworkLink with viewRefreshMode=onStop requires the `camera` property to be defined.\");\n          }\n          if (defined(networkLinkInfo.refreshMode)) {\n            dataSource._networkLinks.set(networkLinkInfo.id, networkLinkInfo);\n          }\n        }\n      }).catch(function (error) {\n        oneTimeWarning(`An error occured during loading ${href.url}`);\n        dataSource._error.raiseEvent(dataSource, error);\n      });\n      deferredLoading.addPromise(promise);\n    }\n  }\n}\nfunction processFeatureNode(dataSource, node, processingData, deferredLoading) {\n  const featureProcessor = featureTypes[node.localName];\n  if (defined(featureProcessor)) {\n    return featureProcessor(dataSource, node, processingData, deferredLoading);\n  }\n  return processUnsupportedFeature(dataSource, node, processingData, deferredLoading);\n}\nfunction loadKml(dataSource, entityCollection, kml, sourceResource, uriResolver, screenOverlayContainer, context) {\n  entityCollection.removeAll();\n  const documentElement = kml.documentElement;\n  const document = documentElement.localName === \"Document\" ? documentElement : queryFirstNode(documentElement, \"Document\", namespaces.kml);\n  let name = queryStringValue(document, \"name\", namespaces.kml);\n  if (!defined(name)) {\n    name = getFilenameFromUri(sourceResource.getUrlComponent());\n  }\n\n  // Only set the name from the root document\n  if (!defined(dataSource._name)) {\n    dataSource._name = name;\n  }\n  const deferredLoading = new KmlDataSource._DeferredLoading(dataSource);\n  const styleCollection = new EntityCollection(dataSource);\n  return Promise.all(processStyles(dataSource, kml, styleCollection, sourceResource, false, uriResolver)).then(function () {\n    let element = kml.documentElement;\n    if (element.localName === \"kml\") {\n      const childNodes = element.childNodes;\n      for (let i = 0; i < childNodes.length; i++) {\n        const tmp = childNodes[i];\n        if (defined(featureTypes[tmp.localName])) {\n          element = tmp;\n          break;\n        }\n      }\n    }\n    const processingData = {\n      parentEntity: undefined,\n      entityCollection: entityCollection,\n      styleCollection: styleCollection,\n      sourceResource: sourceResource,\n      uriResolver: uriResolver,\n      context: context,\n      screenOverlayContainer: screenOverlayContainer\n    };\n    entityCollection.suspendEvents();\n    processFeatureNode(dataSource, element, processingData, deferredLoading);\n    entityCollection.resumeEvents();\n    return deferredLoading.wait().then(function () {\n      return kml.documentElement;\n    });\n  });\n}\nasync function loadKmz(dataSource, entityCollection, blob, sourceResource, screenOverlayContainer) {\n  const zWorkerUri = buildModuleUrl(\"ThirdParty/Workers/zip-web-worker.js\");\n  const zWasmUri = buildModuleUrl(\"ThirdParty/zip-module.wasm\");\n  configure({\n    workerURI: zWorkerUri,\n    wasmURI: zWasmUri\n  });\n  const reader = new ZipReader(new BlobReader(blob));\n  const entries = await reader.getEntries();\n  const promises = [];\n  const uriResolver = {};\n  let docEntry;\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i];\n    if (!entry.directory) {\n      if (/\\.kml$/i.test(entry.filename)) {\n        // We use the first KML document we come across\n        //  https://developers.google.com/kml/documentation/kmzarchives\n        // Unless we come across a .kml file at the root of the archive because GE does this\n        if (!defined(docEntry) || !/\\//i.test(entry.filename)) {\n          if (defined(docEntry)) {\n            // We found one at the root so load the initial kml as a data uri\n            promises.push(loadDataUriFromZip(docEntry, uriResolver));\n          }\n          docEntry = entry;\n        } else {\n          // Wasn't the first kml and wasn't at the root\n          promises.push(loadDataUriFromZip(entry, uriResolver));\n        }\n      } else {\n        promises.push(loadDataUriFromZip(entry, uriResolver));\n      }\n    }\n  }\n\n  // Now load the root KML document\n  if (defined(docEntry)) {\n    promises.push(loadXmlFromZip(docEntry, uriResolver));\n  }\n  await Promise.all(promises);\n  reader.close();\n  if (!defined(uriResolver.kml)) {\n    throw new RuntimeError(\"KMZ file does not contain a KML document.\");\n  }\n  uriResolver.keys = Object.keys(uriResolver);\n  return loadKml(dataSource, entityCollection, uriResolver.kml, sourceResource, uriResolver, screenOverlayContainer);\n}\nfunction load(dataSource, entityCollection, data, options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  let sourceUri = options.sourceUri;\n  const uriResolver = options.uriResolver;\n  const context = options.context;\n  let screenOverlayContainer = options.screenOverlayContainer;\n  let promise = data;\n  if (typeof data === \"string\" || data instanceof Resource) {\n    data = Resource.createIfNeeded(data);\n    promise = data.fetchBlob();\n    sourceUri = sourceUri ?? data.clone();\n\n    // Add resource credits to our list of credits to display\n    const resourceCredits = dataSource._resourceCredits;\n    const credits = data.credits;\n    if (defined(credits)) {\n      const length = credits.length;\n      for (let i = 0; i < length; i++) {\n        resourceCredits.push(credits[i]);\n      }\n    }\n  } else {\n    sourceUri = sourceUri ?? Resource.DEFAULT.clone();\n  }\n  sourceUri = Resource.createIfNeeded(sourceUri);\n  if (defined(screenOverlayContainer)) {\n    screenOverlayContainer = getElement(screenOverlayContainer);\n  }\n  return Promise.resolve(promise).then(function (dataToLoad) {\n    if (dataToLoad instanceof Blob) {\n      return isZipFile(dataToLoad).then(function (isZip) {\n        if (isZip) {\n          return loadKmz(dataSource, entityCollection, dataToLoad, sourceUri, screenOverlayContainer);\n        }\n        return readBlobAsText(dataToLoad).then(function (text) {\n          //There's no official way to validate if a parse was successful.\n          //The following check detects the error on various browsers.\n\n          //Insert missing namespaces\n          text = insertNamespaces(text);\n\n          //Remove Duplicate Namespaces\n          text = removeDuplicateNamespaces(text);\n\n          //IE raises an exception\n          let kml;\n          let error;\n          try {\n            kml = parser.parseFromString(text, \"application/xml\");\n          } catch (e) {\n            error = e.toString();\n          }\n\n          //The parse succeeds on Chrome and Firefox, but the error\n          //handling is different in each.\n          if (defined(error) || kml.body || kml.documentElement.tagName === \"parsererror\") {\n            //Firefox has error information as the firstChild nodeValue.\n            let msg = defined(error) ? error : kml.documentElement.firstChild.nodeValue;\n\n            //Chrome has it in the body text.\n            if (!msg) {\n              msg = kml.body.innerText;\n            }\n\n            //Return the error\n            throw new RuntimeError(msg);\n          }\n          return loadKml(dataSource, entityCollection, kml, sourceUri, uriResolver, screenOverlayContainer, context);\n        });\n      });\n    }\n    return loadKml(dataSource, entityCollection, dataToLoad, sourceUri, uriResolver, screenOverlayContainer, context);\n  }).catch(function (error) {\n    dataSource._error.raiseEvent(dataSource, error);\n    console.log(error);\n    return Promise.reject(error);\n  });\n}\n\n// NOTE: LoadOptions properties are repeated in ConstructorOptions because some\n// tooling does not support \"base types\" for @typedef.  Remove if/when\n// https://github.com/microsoft/TypeScript/issues/20077 and/or\n// https://github.com/jsdoc/jsdoc/issues/1199 actually get resolved\n/**\n * @typedef {object} KmlDataSource.LoadOptions\n *\n * Initialization options for the `load` method.\n *\n * @property {string} [sourceUri] Overrides the url to use for resolving relative links and other KML network features.\n * @property {boolean} [clampToGround=false] true if we want the geometry features (Polygons, LineStrings and LinearRings) clamped to the ground.\n * @property {Ellipsoid} [ellipsoid=Ellipsoid.default] The global ellipsoid used for geographical calculations.\n * @property {Element|string} [screenOverlayContainer] A container for ScreenOverlay images.\n */\n\n/**\n * @typedef {object} KmlDataSource.ConstructorOptions\n *\n * Options for constructing a new KmlDataSource, or calling the static `load` method.\n *\n * @property {Camera} [camera] The camera that is used for viewRefreshModes and sending camera properties to network links.\n * @property {HTMLCanvasElement} [canvas] The canvas that is used for sending viewer properties to network links.\n * @property {Credit|string} [credit] A credit for the data source, which is displayed on the canvas.\n *\n * @property {string} [sourceUri] Overrides the url to use for resolving relative links and other KML network features.\n * @property {boolean} [clampToGround=false] true if we want the geometry features (Polygons, LineStrings and LinearRings) clamped to the ground.\n * @property {Ellipsoid} [ellipsoid=Ellipsoid.default] The global ellipsoid used for geographical calculations.\n * @property {Element|string} [screenOverlayContainer] A container for ScreenOverlay images.\n\n*/\n\n/**\n * A {@link DataSource} which processes Keyhole Markup Language 2.2 (KML).\n * <p>\n * KML support in Cesium is incomplete, but a large amount of the standard,\n * as well as Google's <code>gx</code> extension namespace, is supported. See Github issue\n * {@link https://github.com/CesiumGS/cesium/issues/873|#873} for a\n * detailed list of what is and isn't supported. Cesium will also write information to the\n * console when it encounters most unsupported features.\n * </p>\n * <p>\n * Non visual feature data, such as <code>atom:author</code> and <code>ExtendedData</code>\n * is exposed via an instance of {@link KmlFeatureData}, which is added to each {@link Entity}\n * under the <code>kml</code> property.\n * </p>\n *\n * @alias KmlDataSource\n * @constructor\n *\n * @param {KmlDataSource.ConstructorOptions} [options] Object describing initialization options\n *\n * @see {@link http://www.opengeospatial.org/standards/kml/|Open Geospatial Consortium KML Standard}\n * @see {@link https://developers.google.com/kml/|Google KML Documentation}\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=KML.html|Cesium Sandcastle KML Demo}\n *\n * @example\n * const viewer = new Cesium.Viewer('cesiumContainer');\n * viewer.dataSources.add(Cesium.KmlDataSource.load('../../SampleData/facilities.kmz',\n *      {\n *           camera: viewer.scene.camera,\n *           canvas: viewer.scene.canvas\n *      })\n * );\n */\nfunction KmlDataSource(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const camera = options.camera;\n  const canvas = options.canvas;\n  this._changed = new Event();\n  this._error = new Event();\n  this._loading = new Event();\n  this._refresh = new Event();\n  this._unsupportedNode = new Event();\n  this._clock = undefined;\n  this._entityCollection = new EntityCollection(this);\n  this._name = undefined;\n  this._isLoading = false;\n  this._pinBuilder = new PinBuilder();\n  this._networkLinks = new AssociativeArray();\n  this._entityCluster = new EntityCluster();\n\n  /**\n   * The current size of this Canvas will be used to populate the Link parameters\n   * for client height and width.\n   *\n   * @type {HTMLCanvasElement | undefined}\n   */\n  this.canvas = canvas;\n\n  /**\n   * The position and orientation of this {@link Camera} will be used to\n   * populate various camera parameters when making network requests.\n   * Camera movement will determine when to trigger NetworkLink refresh if\n   * <code>viewRefreshMode</code> is <code>onStop</code>.\n   *\n   * @type {Camera | undefined}\n   */\n  this.camera = camera;\n  this._lastCameraView = {\n    position: defined(camera) ? Cartesian3.clone(camera.positionWC) : undefined,\n    direction: defined(camera) ? Cartesian3.clone(camera.directionWC) : undefined,\n    up: defined(camera) ? Cartesian3.clone(camera.upWC) : undefined,\n    bbox: defined(camera) ? camera.computeViewRectangle() : Rectangle.clone(Rectangle.MAX_VALUE)\n  };\n  this._ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n\n  // User specified credit\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  this._credit = credit;\n\n  // Create a list of Credit's from the resource that the user can't remove\n  this._resourceCredits = [];\n  this._kmlTours = [];\n  this._screenOverlays = [];\n}\n\n/**\n * Creates a Promise to a new instance loaded with the provided KML data.\n *\n * @param {Resource|string|Document|Blob} data A url, parsed KML document, or Blob containing binary KMZ data or a parsed KML document.\n * @param {KmlDataSource.ConstructorOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<KmlDataSource>} A promise that will resolve to a new KmlDataSource instance once the KML is loaded.\n */\nKmlDataSource.load = function (data, options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const dataSource = new KmlDataSource(options);\n  return dataSource.load(data, options);\n};\nObject.defineProperties(KmlDataSource.prototype, {\n  /**\n   * Gets or sets a human-readable name for this instance.\n   * This will be automatically be set to the KML document name on load.\n   * @memberof KmlDataSource.prototype\n   * @type {string}\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n    set: function (value) {\n      if (this._name !== value) {\n        this._name = value;\n        this._changed.raiseEvent(this);\n      }\n    }\n  },\n  /**\n   * Gets the clock settings defined by the loaded KML. This represents the total\n   * availability interval for all time-dynamic data. If the KML does not contain\n   * time-dynamic data, this value is undefined.\n   * @memberof KmlDataSource.prototype\n   * @type {DataSourceClock}\n   */\n  clock: {\n    get: function () {\n      return this._clock;\n    }\n  },\n  /**\n   * Gets the collection of {@link Entity} instances.\n   * @memberof KmlDataSource.prototype\n   * @type {EntityCollection}\n   */\n  entities: {\n    get: function () {\n      return this._entityCollection;\n    }\n  },\n  /**\n   * Gets a value indicating if the data source is currently loading data.\n   * @memberof KmlDataSource.prototype\n   * @type {boolean}\n   */\n  isLoading: {\n    get: function () {\n      return this._isLoading;\n    }\n  },\n  /**\n   * Gets an event that will be raised when the underlying data changes.\n   * @memberof KmlDataSource.prototype\n   * @type {Event}\n   */\n  changedEvent: {\n    get: function () {\n      return this._changed;\n    }\n  },\n  /**\n   * Gets an event that will be raised if an error is encountered during processing.\n   * @memberof KmlDataSource.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._error;\n    }\n  },\n  /**\n   * Gets an event that will be raised when the data source either starts or stops loading.\n   * @memberof KmlDataSource.prototype\n   * @type {Event}\n   */\n  loadingEvent: {\n    get: function () {\n      return this._loading;\n    }\n  },\n  /**\n   * Gets an event that will be raised when the data source refreshes a network link.\n   * @memberof KmlDataSource.prototype\n   * @type {Event}\n   */\n  refreshEvent: {\n    get: function () {\n      return this._refresh;\n    }\n  },\n  /**\n   * Gets an event that will be raised when the data source finds an unsupported node type.\n   * @memberof KmlDataSource.prototype\n   * @type {Event}\n   */\n  unsupportedNodeEvent: {\n    get: function () {\n      return this._unsupportedNode;\n    }\n  },\n  /**\n   * Gets whether or not this data source should be displayed.\n   * @memberof KmlDataSource.prototype\n   * @type {boolean}\n   */\n  show: {\n    get: function () {\n      return this._entityCollection.show;\n    },\n    set: function (value) {\n      this._entityCollection.show = value;\n    }\n  },\n  /**\n   * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.\n   *\n   * @memberof KmlDataSource.prototype\n   * @type {EntityCluster}\n   */\n  clustering: {\n    get: function () {\n      return this._entityCluster;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value must be defined.\");\n      }\n      //>>includeEnd('debug');\n      this._entityCluster = value;\n    }\n  },\n  /**\n   * Gets the credit that will be displayed for the data source\n   * @memberof KmlDataSource.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    }\n  },\n  /**\n   * Gets the KML Tours that are used to guide the camera to specified destinations on given time intervals.\n   * @memberof KmlDataSource.prototype\n   * @type {KmlTour[]}\n   */\n  kmlTours: {\n    get: function () {\n      return this._kmlTours;\n    }\n  }\n});\n\n/**\n * Asynchronously loads the provided KML data, replacing any existing data.\n *\n * @param {Resource|string|Document|Blob} data A url, parsed KML document, or Blob containing binary KMZ data or a parsed KML document.\n * @param {KmlDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<KmlDataSource>} A promise that will resolve to this instances once the KML is loaded.\n */\nKmlDataSource.prototype.load = function (data, options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(data)) {\n    throw new DeveloperError(\"data is required.\");\n  }\n  //>>includeEnd('debug');\n\n  options = options ?? Frozen.EMPTY_OBJECT;\n  DataSource.setLoading(this, true);\n  const oldName = this._name;\n  this._name = undefined;\n  this._clampToGround = options.clampToGround ?? false;\n  const that = this;\n  return load(this, this._entityCollection, data, options).then(function () {\n    let clock;\n    const availability = that._entityCollection.computeAvailability();\n    let start = availability.start;\n    let stop = availability.stop;\n    const isMinStart = JulianDate.equals(start, Iso8601.MINIMUM_VALUE);\n    const isMaxStop = JulianDate.equals(stop, Iso8601.MAXIMUM_VALUE);\n    if (!isMinStart || !isMaxStop) {\n      let date;\n\n      //If start is min time just start at midnight this morning, local time\n      if (isMinStart) {\n        date = new Date();\n        date.setHours(0, 0, 0, 0);\n        start = JulianDate.fromDate(date);\n      }\n\n      //If stop is max value just stop at midnight tonight, local time\n      if (isMaxStop) {\n        date = new Date();\n        date.setHours(24, 0, 0, 0);\n        stop = JulianDate.fromDate(date);\n      }\n      clock = new DataSourceClock();\n      clock.startTime = start;\n      clock.stopTime = stop;\n      clock.currentTime = JulianDate.clone(start);\n      clock.clockRange = ClockRange.LOOP_STOP;\n      clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;\n      clock.multiplier = Math.round(Math.min(Math.max(JulianDate.secondsDifference(stop, start) / 60, 1), 3.15569e7));\n    }\n    let changed = false;\n    if (clock !== that._clock) {\n      that._clock = clock;\n      changed = true;\n    }\n    if (oldName !== that._name) {\n      changed = true;\n    }\n    if (changed) {\n      that._changed.raiseEvent(that);\n    }\n    DataSource.setLoading(that, false);\n    return that;\n  }).catch(function (error) {\n    DataSource.setLoading(that, false);\n    that._error.raiseEvent(that, error);\n    console.log(error);\n    return Promise.reject(error);\n  });\n};\n\n/**\n * Cleans up any non-entity elements created by the data source. Currently this only affects ScreenOverlay elements.\n */\nKmlDataSource.prototype.destroy = function () {\n  while (this._screenOverlays.length > 0) {\n    const elem = this._screenOverlays.pop();\n    elem.remove();\n  }\n};\nfunction mergeAvailabilityWithParent(child) {\n  const parent = child.parent;\n  if (defined(parent)) {\n    const parentAvailability = parent.availability;\n    if (defined(parentAvailability)) {\n      const childAvailability = child.availability;\n      if (defined(childAvailability)) {\n        childAvailability.intersect(parentAvailability);\n      } else {\n        child.availability = parentAvailability;\n      }\n    }\n  }\n}\nfunction getNetworkLinkUpdateCallback(dataSource, networkLink, newEntityCollection, networkLinks, processedHref) {\n  return function (rootElement) {\n    if (!networkLinks.contains(networkLink.id)) {\n      // Got into the odd case where a parent network link was updated while a child\n      //  network link update was in flight, so just throw it away.\n      return;\n    }\n    let remove = false;\n    const networkLinkControl = queryFirstNode(rootElement, \"NetworkLinkControl\", namespaces.kml);\n    const hasNetworkLinkControl = defined(networkLinkControl);\n    let minRefreshPeriod = 0;\n    if (hasNetworkLinkControl) {\n      if (defined(queryFirstNode(networkLinkControl, \"Update\", namespaces.kml))) {\n        oneTimeWarning(\"kml-networkLinkControl-update\", \"KML - NetworkLinkControl updates aren't supported.\");\n        networkLink.updating = false;\n        networkLinks.remove(networkLink.id);\n        return;\n      }\n      networkLink.cookie = queryToObject(queryStringValue(networkLinkControl, \"cookie\", namespaces.kml) ?? \"\");\n      minRefreshPeriod = queryNumericValue(networkLinkControl, \"minRefreshPeriod\", namespaces.kml) ?? 0;\n    }\n    const now = JulianDate.now();\n    const refreshMode = networkLink.refreshMode;\n    if (refreshMode === RefreshMode.INTERVAL) {\n      if (defined(networkLinkControl)) {\n        networkLink.time = Math.max(minRefreshPeriod, networkLink.time);\n      }\n    } else if (refreshMode === RefreshMode.EXPIRE) {\n      let expires;\n      if (defined(networkLinkControl)) {\n        expires = queryStringValue(networkLinkControl, \"expires\", namespaces.kml);\n      }\n      if (defined(expires)) {\n        try {\n          const date = JulianDate.fromIso8601(expires);\n          const diff = JulianDate.secondsDifference(date, now);\n          if (diff > 0 && diff < minRefreshPeriod) {\n            JulianDate.addSeconds(now, minRefreshPeriod, date);\n          }\n          networkLink.time = date;\n        } catch (e) {\n          oneTimeWarning(\"kml-networkLinkControl-expires\", \"KML - NetworkLinkControl expires is not a valid date\");\n          remove = true;\n        }\n      } else {\n        oneTimeWarning(\"kml-refreshMode-onExpire\", \"KML - refreshMode of onExpire requires the NetworkLinkControl to have an expires element\");\n        remove = true;\n      }\n    }\n    const networkLinkEntity = networkLink.entity;\n    const entityCollection = dataSource._entityCollection;\n    const newEntities = newEntityCollection.values;\n    function removeChildren(entity) {\n      entityCollection.remove(entity);\n      const children = entity._children;\n      const count = children.length;\n      for (let i = 0; i < count; ++i) {\n        removeChildren(children[i]);\n      }\n    }\n\n    // Remove old entities\n    entityCollection.suspendEvents();\n    const entitiesCopy = entityCollection.values.slice();\n    let i;\n    for (i = 0; i < entitiesCopy.length; ++i) {\n      const entityToRemove = entitiesCopy[i];\n      if (entityToRemove.parent === networkLinkEntity) {\n        entityToRemove.parent = undefined;\n        removeChildren(entityToRemove);\n      }\n    }\n    entityCollection.resumeEvents();\n\n    // Add new entities\n    entityCollection.suspendEvents();\n    for (i = 0; i < newEntities.length; i++) {\n      const newEntity = newEntities[i];\n      if (!defined(newEntity.parent)) {\n        newEntity.parent = networkLinkEntity;\n        mergeAvailabilityWithParent(newEntity);\n      }\n      entityCollection.add(newEntity);\n    }\n    entityCollection.resumeEvents();\n\n    // No refresh information remove it, otherwise update lastUpdate time\n    if (remove) {\n      networkLinks.remove(networkLink.id);\n    } else {\n      networkLink.lastUpdated = now;\n    }\n    const availability = entityCollection.computeAvailability();\n    const start = availability.start;\n    const stop = availability.stop;\n    const isMinStart = JulianDate.equals(start, Iso8601.MINIMUM_VALUE);\n    const isMaxStop = JulianDate.equals(stop, Iso8601.MAXIMUM_VALUE);\n    if (!isMinStart || !isMaxStop) {\n      const clock = dataSource._clock;\n      if (clock.startTime !== start || clock.stopTime !== stop) {\n        clock.startTime = start;\n        clock.stopTime = stop;\n        dataSource._changed.raiseEvent(dataSource);\n      }\n    }\n    networkLink.updating = false;\n    networkLink.needsUpdate = false;\n    dataSource._refresh.raiseEvent(dataSource, processedHref.getUrlComponent(true));\n  };\n}\nconst entitiesToIgnore = new AssociativeArray();\n\n/**\n * Updates any NetworkLink that require updating.\n *\n * @param {JulianDate} time The simulation time.\n * @returns {boolean} True if this data source is ready to be displayed at the provided time, false otherwise.\n */\nKmlDataSource.prototype.update = function (time) {\n  const networkLinks = this._networkLinks;\n  if (networkLinks.length === 0) {\n    return true;\n  }\n  const now = JulianDate.now();\n  const that = this;\n  entitiesToIgnore.removeAll();\n  function recurseIgnoreEntities(entity) {\n    const children = entity._children;\n    const count = children.length;\n    for (let i = 0; i < count; ++i) {\n      const child = children[i];\n      entitiesToIgnore.set(child.id, child);\n      recurseIgnoreEntities(child);\n    }\n  }\n  let cameraViewUpdate = false;\n  const lastCameraView = this._lastCameraView;\n  const camera = this.camera;\n  if (defined(camera) && !(camera.positionWC.equalsEpsilon(lastCameraView.position, CesiumMath.EPSILON7) && camera.directionWC.equalsEpsilon(lastCameraView.direction, CesiumMath.EPSILON7) && camera.upWC.equalsEpsilon(lastCameraView.up, CesiumMath.EPSILON7))) {\n    // Camera has changed so update the last view\n    lastCameraView.position = Cartesian3.clone(camera.positionWC);\n    lastCameraView.direction = Cartesian3.clone(camera.directionWC);\n    lastCameraView.up = Cartesian3.clone(camera.upWC);\n    lastCameraView.bbox = camera.computeViewRectangle();\n    cameraViewUpdate = true;\n  }\n  const newNetworkLinks = new AssociativeArray();\n  let changed = false;\n  networkLinks.values.forEach(function (networkLink) {\n    const entity = networkLink.entity;\n    if (entitiesToIgnore.contains(entity.id)) {\n      return;\n    }\n    if (!networkLink.updating) {\n      let doUpdate = false;\n      if (networkLink.refreshMode === RefreshMode.INTERVAL) {\n        if (JulianDate.secondsDifference(now, networkLink.lastUpdated) > networkLink.time) {\n          doUpdate = true;\n        }\n      } else if (networkLink.refreshMode === RefreshMode.EXPIRE) {\n        if (JulianDate.greaterThan(now, networkLink.time)) {\n          doUpdate = true;\n        }\n      } else if (networkLink.refreshMode === RefreshMode.STOP) {\n        if (cameraViewUpdate) {\n          networkLink.needsUpdate = true;\n          networkLink.cameraUpdateTime = now;\n        }\n        if (networkLink.needsUpdate && JulianDate.secondsDifference(now, networkLink.cameraUpdateTime) >= networkLink.time) {\n          doUpdate = true;\n        }\n      }\n      if (doUpdate) {\n        recurseIgnoreEntities(entity);\n        networkLink.updating = true;\n        const newEntityCollection = new EntityCollection();\n        const href = networkLink.href.clone();\n        href.setQueryParameters(networkLink.cookie);\n        const ellipsoid = that._ellipsoid ?? Ellipsoid.default;\n        processNetworkLinkQueryString(href, that.camera, that.canvas, networkLink.viewBoundScale, lastCameraView.bbox, ellipsoid);\n        load(that, newEntityCollection, href, {\n          context: entity.id\n        }).then(getNetworkLinkUpdateCallback(that, networkLink, newEntityCollection, newNetworkLinks, href)).catch(function (error) {\n          const msg = `NetworkLink ${networkLink.href} refresh failed: ${error}`;\n          console.log(msg);\n          that._error.raiseEvent(that, msg);\n        });\n        changed = true;\n      }\n    }\n    newNetworkLinks.set(networkLink.id, networkLink);\n  });\n  if (changed) {\n    this._networkLinks = newNetworkLinks;\n    this._changed.raiseEvent(this);\n  }\n  return true;\n};\n\n/**\n * Contains KML Feature data loaded into the <code>Entity.kml</code> property by {@link KmlDataSource}.\n * @alias KmlFeatureData\n * @constructor\n */\nfunction KmlFeatureData() {\n  /**\n   * @typedef KmlFeatureData.Author\n   * @type {object}\n   * @property {string} name Gets the name.\n   * @property {string} uri Gets the URI.\n   * @property {number} age Gets the email.\n   */\n\n  /**\n   * Gets the atom syndication format author field.\n   * @type {KmlFeatureData.Author}\n   */\n  this.author = {\n    name: undefined,\n    uri: undefined,\n    email: undefined\n  };\n\n  /**\n   * @typedef KmlFeatureData.Link\n   * @type {object}\n   * @property {string} href Gets the href.\n   * @property {string} hreflang Gets the language of the linked resource.\n   * @property {string} rel Gets the link relation.\n   * @property {string} type Gets the link type.\n   * @property {string} title Gets the link title.\n   * @property {string} length Gets the link length.\n   */\n\n  /**\n   * Gets the link.\n   * @type {KmlFeatureData.Link}\n   */\n  this.link = {\n    href: undefined,\n    hreflang: undefined,\n    rel: undefined,\n    type: undefined,\n    title: undefined,\n    length: undefined\n  };\n\n  /**\n   * Gets the unstructured address field.\n   * @type {string}\n   */\n  this.address = undefined;\n  /**\n   * Gets the phone number.\n   * @type {string}\n   */\n  this.phoneNumber = undefined;\n  /**\n   * Gets the snippet.\n   * @type {string}\n   */\n  this.snippet = undefined;\n  /**\n   * Gets the extended data, parsed into a JSON object.\n   * Currently only the <code>Data</code> property is supported.\n   * <code>SchemaData</code> and custom data are ignored.\n   * @type {string}\n   */\n  this.extendedData = undefined;\n}\n\n// For testing\nKmlDataSource._DeferredLoading = DeferredLoading;\nKmlDataSource._getTimestamp = getTimestamp;\nexport default KmlDataSource;","map":{"version":3,"names":["ArcType","AssociativeArray","BoundingRectangle","buildModuleUrl","Cartesian2","Cartesian3","Cartographic","ClockRange","ClockStep","clone","Color","createGuid","Credit","Frozen","defer","defined","DeveloperError","Ellipsoid","Event","getExtensionFromUri","getFilenameFromUri","getTimestamp","HeadingPitchRange","HeadingPitchRoll","Iso8601","JulianDate","CesiumMath","NearFarScalar","objectToQuery","oneTimeWarning","PinBuilder","PolygonHierarchy","queryToObject","Rectangle","Resource","RuntimeError","TimeInterval","TimeIntervalCollection","HeightReference","HorizontalOrigin","LabelStyle","SceneMode","Autolinker","Uri","configure","BlobReader","Data64URIWriter","TextWriter","ZipReader","getElement","BillboardGraphics","CompositePositionProperty","DataSource","DataSourceClock","Entity","EntityCluster","EntityCollection","KmlCamera","KmlLookAt","KmlTour","KmlTourFlyTo","KmlTourWait","LabelGraphics","PathGraphics","PolygonGraphics","PolylineGraphics","PositionPropertyArray","RectangleGraphics","ReferenceProperty","SampledPositionProperty","ScaledPositionProperty","TimeIntervalCollectionProperty","WallGraphics","MimeTypes","avi","bmp","bz2","chm","css","csv","doc","dvi","eps","flv","gif","gz","htm","html","ico","jnlp","jpeg","jpg","m3u","m4v","mathml","mid","midi","mov","mp3","mp4","mp4v","mpeg","mpg","odp","ods","odt","ogg","pdf","png","pps","ppt","ps","qt","rdf","rss","rtf","svg","swf","text","tif","tiff","txt","wav","wma","wmv","xml","zip","detectFromFilename","filename","ext","toLowerCase","parser","DOMParser","autolinker","stripPrefix","email","replaceFn","match","urlMatchType","BILLBOARD_SIZE","BILLBOARD_NEAR_DISTANCE","BILLBOARD_NEAR_RATIO","BILLBOARD_FAR_DISTANCE","BILLBOARD_FAR_RATIO","kmlNamespaces","undefined","gxNamespaces","atomNamespaces","namespaces","kml","gx","atom","kmlgx","concat","featureTypes","Document","processDocument","Folder","processFolder","Placemark","processPlacemark","NetworkLink","processNetworkLink","GroundOverlay","processGroundOverlay","PhotoOverlay","processUnsupportedFeature","ScreenOverlay","processScreenOverlay","Tour","processTour","DeferredLoading","dataSource","_dataSource","_deferred","_stack","_promises","_timeoutSet","_used","_started","_timeThreshold","Object","defineProperties","prototype","get","addNodes","nodes","processingData","push","index","addPromise","promise","wait","deferred","resolve","Promise","all","process","isFirstCall","length","KmlDataSource","_getTimestamp","_process","_giveUpTime","that","setTimeout","_nextNode","stack","top","_pop","pop","child","featureProcessor","localName","indexOf","namespaceURI","isZipFile","blob","magicBlob","slice","Math","min","size","reader","FileReader","addEventListener","DataView","result","getUint32","reject","error","readAsArrayBuffer","readBlobAsText","readAsText","insertNamespaces","namespaceMap","xsi","firstPart","lastPart","reg","declaration","key","hasOwnProperty","RegExp","test","substr","removeDuplicateNamespaces","endDeclaration","namespace","startIndex","endIndex","loadXmlFromZip","entry","uriResolver","getData","parseFromString","loadDataUriFromZip","mimeType","dataUri","embedDataUris","div","elementType","attributeName","keys","baseUri","elements","querySelectorAll","i","element","value","getAttribute","relativeUri","uri","absoluteTo","toString","setAttribute","applyBasePath","sourceResource","resource","resolveHref","url","createEntity","node","entityCollection","context","id","queryStringAttribute","entity","getById","add","addProperty","KmlFeatureData","isExtrudable","altitudeMode","gxAltitudeMode","readCoordinate","ellipsoid","fromDegrees","digits","longitude","parseFloat","latitude","height","isNaN","readCoordinates","tuples","textContent","Array","resultIndex","queryNumericAttribute","queryFirstNode","tagName","childNodes","q","queryNodes","getElementsByTagNameNS","queryChildNodes","queryNumericValue","resultNode","queryStringValue","trim","queryBooleanValue","href","replace","getUrlComponent","getDerivedResource","colorOptions","maximumRed","red","maximumGreen","green","maximumBlue","blue","parseColorString","isRandom","substring","alpha","parseInt","fromRandom","queryColorValue","processTimeStamp","featureNode","whenString","when","fromIso8601","addInterval","start","stop","MAXIMUM_VALUE","processTimeSpan","beginNode","beginDate","endNode","endDate","lessThan","tmp","MINIMUM_VALUE","createDefaultBillboard","billboard","width","scaleByDistance","pixelOffsetScaleByDistance","createDefaultPolygon","polygon","outline","outlineColor","WHITE","createDefaultLabel","label","translucencyByDistance","pixelOffset","horizontalOrigin","LEFT","font","style","FILL_AND_OUTLINE","getIconHref","iconNode","canRefresh","palette","charAt","x","y","iconNum","hrefResource","refreshMode","viewRefreshMode","viewBoundScale","defaultViewFormat","viewFormat","httpQuery","setQueryParameters","cleanupString","_ellipsoid","processNetworkLinkQueryString","camera","canvas","_lastCameraView","bbox","processBillboardIcon","targetEntity","scale","heading","color","icon","w","h","hotSpotNode","hotSpotX","hotSpotY","hotSpotXUnit","hotSpotYUnit","image","imageSubRegion","rotation","toRadians","alignedAxis","UNIT_Z","xOffset","yOffset","applyStyle","styleNode","len","item","fillColor","name","polyline","material","fill","bgColor","textColor","BLACK","balloonStyle","listItemType","computeFinalStyle","placeMark","styleCollection","styleEntity","styleIndex","inlineStyleNode","pairs","p","pair","styleUrl","merge","externalStyle","tokens","split","processExternalStyles","fetchXML","then","styleKml","processStyles","isExternal","styleNodes","styleNodesLength","styleMaps","styleMapsLength","styleMap","getOrCreateEntity","base","promises","styleUrlNodes","getElementsByTagName","styleUrlNodesLength","styleReference","createDropLine","entityPosition","surfacePosition","position","positions","heightReferenceFromAltitudeMode","CLAMP_TO_GROUND","RELATIVE_TO_GROUND","NONE","createPositionPropertyFromAltitudeMode","property","createPositionPropertyArrayFromAltitudeMode","properties","propertiesLength","scaleToGeodeticSurface","processPositionGraphics","heightReference","_pinBuilder","fromColor","YELLOW","getValue","_clampToGround","processPathGraphics","path","leadTime","processPoint","geometryNode","coordinatesString","extrude","processLineStringOrLinearRing","coordinatesNode","tessellate","canExtrude","zIndex","coordinates","wall","outlineWidth","polylineGraphics","clampToGround","arcType","processPolygon","outerBoundaryIsNode","linearRingNode","perPositionHeight","extrudedHeight","hierarchy","innerBoundaryIsNodes","j","k","holes","processTrack","coordNodes","angleNodes","timeNodes","times","addSamples","availability","addToMultiTrack","composite","dropShowProperty","includeEndPoints","data","intervals","isStartIncluded","isStopIncluded","processMultiTrack","interpolate","trackNodes","lastStop","lastStopPosition","needDropLine","trackNode","show","geometryTypes","Point","LineString","LinearRing","Polygon","Track","MultiTrack","MultiGeometry","processMultiGeometry","Model","processUnsupportedGeometry","hasGeometry","childNode","geometryProcessor","childEntity","parent","description","processExtendedData","extendedDataNode","dataNodes","dataNode","displayName","extendedData","scratchDiv","document","createElement","processDescription","kmlData","background","foreground","address","snippet","matches","token","propertyName","isDisplayName","link","innerHTML","links","toCssColorString","processFeature","parentEntity","mergeAvailabilityWithParent","ancestryIsVisible","visibility","authorNode","author","linkNode","hreflang","rel","type","title","phoneNumber","processLookAt","processCamera","deferredLoading","r","newProcessingData","placemark","playlistNodeProcessors","FlyTo","processTourFlyTo","Wait","processTourWait","SoundCue","processTourUnsupportedNode","AnimatedUpdate","TourControl","tour","playlistNode","entryNode","playlistNodeProcessor","console","log","_kmlTours","duration","addPlaylistEntry","flyToMode","t","view","lookAt","flyto","lon","lat","altitude","tilt","roll","hpr","range","PI_OVER_TWO","viewPoint","screenOverlayNode","screenOverlay","screenOverlayContainer","img","_screenOverlays","src","onload","styles","screenXY","overlayXY","xUnit","yUnit","xStyle","yStyle","floor","join","xOrigin","yOrigin","appendChild","groundOverlay","geometry","isLatLonQuad","rectangle","latLonBox","west","south","east","north","negativePiToPi","clampToLatitudeRange","rotationRadians","stRotation","transparent","_unsupportedNode","raiseEvent","nodeName","RefreshMode","INTERVAL","EXPIRE","STOP","s","sFirst","zeroRectangle","scratchCartographic","scratchCartesian2","scratchCartesian3","fixLatitude","fixLongitude","PI","TWO_PI","queryString","queryParameters","_mode","MORPHING","centerCartesian","centerCartographic","clientWidth","clientHeight","pickEllipsoid","cartesianToCartographic","center","cartographicToCartesian","equalsEpsilon","EPSILON9","newHalfWidth","newHalfHeight","toDegrees","pitch","distance","positionWC","frustum","aspectRatio","horizFov","vertFov","fov","networkEntity","newSourceUri","options","sourceUri","networkLinkCollection","load","rootElement","entities","_entityCollection","newEntities","values","suspendEvents","newEntity","resumeEvents","refreshInterval","networkLinkControl","hasNetworkLinkControl","now","networkLinkInfo","cookie","lastUpdated","updating","needsUpdate","cameraUpdateTime","minRefreshPeriod","max","time","expires","date","diff","secondsDifference","addSeconds","e","_networkLinks","set","catch","_error","processFeatureNode","loadKml","removeAll","documentElement","_name","_DeferredLoading","loadKmz","zWorkerUri","zWasmUri","workerURI","wasmURI","entries","getEntries","docEntry","directory","close","EMPTY_OBJECT","createIfNeeded","fetchBlob","resourceCredits","_resourceCredits","credits","DEFAULT","dataToLoad","Blob","isZip","body","msg","firstChild","nodeValue","innerText","_changed","_loading","_refresh","_clock","_isLoading","_entityCluster","direction","directionWC","up","upWC","computeViewRectangle","MAX_VALUE","default","credit","_credit","clock","isLoading","changedEvent","errorEvent","loadingEvent","refreshEvent","unsupportedNodeEvent","clustering","kmlTours","setLoading","oldName","computeAvailability","isMinStart","equals","isMaxStop","Date","setHours","fromDate","startTime","stopTime","currentTime","clockRange","LOOP_STOP","clockStep","SYSTEM_CLOCK_MULTIPLIER","multiplier","round","changed","destroy","elem","remove","parentAvailability","childAvailability","intersect","getNetworkLinkUpdateCallback","networkLink","newEntityCollection","networkLinks","processedHref","contains","networkLinkEntity","removeChildren","children","_children","count","entitiesCopy","entityToRemove","entitiesToIgnore","update","recurseIgnoreEntities","cameraViewUpdate","lastCameraView","EPSILON7","newNetworkLinks","forEach","doUpdate","greaterThan"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/DataSources/KmlDataSource.js"],"sourcesContent":["import ArcType from \"../Core/ArcType.js\";\nimport AssociativeArray from \"../Core/AssociativeArray.js\";\nimport BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport buildModuleUrl from \"../Core/buildModuleUrl.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport ClockRange from \"../Core/ClockRange.js\";\nimport ClockStep from \"../Core/ClockStep.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport Credit from \"../Core/Credit.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defer from \"../Core/defer.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Event from \"../Core/Event.js\";\nimport getExtensionFromUri from \"../Core/getExtensionFromUri.js\";\nimport getFilenameFromUri from \"../Core/getFilenameFromUri.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport HeadingPitchRange from \"../Core/HeadingPitchRange.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport objectToQuery from \"../Core/objectToQuery.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport PinBuilder from \"../Core/PinBuilder.js\";\nimport PolygonHierarchy from \"../Core/PolygonHierarchy.js\";\nimport queryToObject from \"../Core/queryToObject.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TimeInterval from \"../Core/TimeInterval.js\";\nimport TimeIntervalCollection from \"../Core/TimeIntervalCollection.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport HorizontalOrigin from \"../Scene/HorizontalOrigin.js\";\nimport LabelStyle from \"../Scene/LabelStyle.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport Autolinker from \"autolinker\";\nimport Uri from \"urijs\";\nimport {\n  configure,\n  BlobReader,\n  Data64URIWriter,\n  TextWriter,\n  ZipReader,\n} from \"@zip.js/zip.js/lib/zip-core.js\";\nimport getElement from \"./getElement.js\";\nimport BillboardGraphics from \"./BillboardGraphics.js\";\nimport CompositePositionProperty from \"./CompositePositionProperty.js\";\nimport DataSource from \"./DataSource.js\";\nimport DataSourceClock from \"./DataSourceClock.js\";\nimport Entity from \"./Entity.js\";\nimport EntityCluster from \"./EntityCluster.js\";\nimport EntityCollection from \"./EntityCollection.js\";\nimport KmlCamera from \"./KmlCamera.js\";\nimport KmlLookAt from \"./KmlLookAt.js\";\nimport KmlTour from \"./KmlTour.js\";\nimport KmlTourFlyTo from \"./KmlTourFlyTo.js\";\nimport KmlTourWait from \"./KmlTourWait.js\";\nimport LabelGraphics from \"./LabelGraphics.js\";\nimport PathGraphics from \"./PathGraphics.js\";\nimport PolygonGraphics from \"./PolygonGraphics.js\";\nimport PolylineGraphics from \"./PolylineGraphics.js\";\nimport PositionPropertyArray from \"./PositionPropertyArray.js\";\nimport RectangleGraphics from \"./RectangleGraphics.js\";\nimport ReferenceProperty from \"./ReferenceProperty.js\";\nimport SampledPositionProperty from \"./SampledPositionProperty.js\";\nimport ScaledPositionProperty from \"./ScaledPositionProperty.js\";\nimport TimeIntervalCollectionProperty from \"./TimeIntervalCollectionProperty.js\";\nimport WallGraphics from \"./WallGraphics.js\";\n\n//This is by no means an exhaustive list of MIME types.\n//The purpose of this list is to be able to accurately identify content embedded\n//in KMZ files. Eventually, we can make this configurable by the end user so they can add\n//there own content types if they have KMZ files that require it.\nconst MimeTypes = {\n  avi: \"video/x-msvideo\",\n  bmp: \"image/bmp\",\n  bz2: \"application/x-bzip2\",\n  chm: \"application/vnd.ms-htmlhelp\",\n  css: \"text/css\",\n  csv: \"text/csv\",\n  doc: \"application/msword\",\n  dvi: \"application/x-dvi\",\n  eps: \"application/postscript\",\n  flv: \"video/x-flv\",\n  gif: \"image/gif\",\n  gz: \"application/x-gzip\",\n  htm: \"text/html\",\n  html: \"text/html\",\n  ico: \"image/vnd.microsoft.icon\",\n  jnlp: \"application/x-java-jnlp-file\",\n  jpeg: \"image/jpeg\",\n  jpg: \"image/jpeg\",\n  m3u: \"audio/x-mpegurl\",\n  m4v: \"video/mp4\",\n  mathml: \"application/mathml+xml\",\n  mid: \"audio/midi\",\n  midi: \"audio/midi\",\n  mov: \"video/quicktime\",\n  mp3: \"audio/mpeg\",\n  mp4: \"video/mp4\",\n  mp4v: \"video/mp4\",\n  mpeg: \"video/mpeg\",\n  mpg: \"video/mpeg\",\n  odp: \"application/vnd.oasis.opendocument.presentation\",\n  ods: \"application/vnd.oasis.opendocument.spreadsheet\",\n  odt: \"application/vnd.oasis.opendocument.text\",\n  ogg: \"application/ogg\",\n  pdf: \"application/pdf\",\n  png: \"image/png\",\n  pps: \"application/vnd.ms-powerpoint\",\n  ppt: \"application/vnd.ms-powerpoint\",\n  ps: \"application/postscript\",\n  qt: \"video/quicktime\",\n  rdf: \"application/rdf+xml\",\n  rss: \"application/rss+xml\",\n  rtf: \"application/rtf\",\n  svg: \"image/svg+xml\",\n  swf: \"application/x-shockwave-flash\",\n  text: \"text/plain\",\n  tif: \"image/tiff\",\n  tiff: \"image/tiff\",\n  txt: \"text/plain\",\n  wav: \"audio/x-wav\",\n  wma: \"audio/x-ms-wma\",\n  wmv: \"video/x-ms-wmv\",\n  xml: \"application/xml\",\n  zip: \"application/zip\",\n\n  detectFromFilename: function (filename) {\n    let ext = filename.toLowerCase();\n    ext = getExtensionFromUri(ext);\n    return MimeTypes[ext];\n  },\n};\n\nlet parser;\nif (typeof DOMParser !== \"undefined\") {\n  parser = new DOMParser();\n}\n\nconst autolinker = new Autolinker({\n  stripPrefix: false,\n  email: false,\n  replaceFn: function (match) {\n    //Prevent matching of non-explicit urls.\n    //i.e. foo.id won't match but http://foo.id will\n    return match.urlMatchType === \"scheme\" || match.urlMatchType === \"www\";\n  },\n});\n\nconst BILLBOARD_SIZE = 32;\n\nconst BILLBOARD_NEAR_DISTANCE = 2414016;\nconst BILLBOARD_NEAR_RATIO = 1.0;\nconst BILLBOARD_FAR_DISTANCE = 1.6093e7;\nconst BILLBOARD_FAR_RATIO = 0.1;\n\nconst kmlNamespaces = [\n  null,\n  undefined,\n  \"http://www.opengis.net/kml/2.2\",\n  \"http://earth.google.com/kml/2.2\",\n  \"http://earth.google.com/kml/2.1\",\n  \"http://earth.google.com/kml/2.0\",\n];\nconst gxNamespaces = [\"http://www.google.com/kml/ext/2.2\"];\nconst atomNamespaces = [\"http://www.w3.org/2005/Atom\"];\nconst namespaces = {\n  kml: kmlNamespaces,\n  gx: gxNamespaces,\n  atom: atomNamespaces,\n  kmlgx: kmlNamespaces.concat(gxNamespaces),\n};\n\n// Ensure Specs/Data/KML/unsupported.kml is kept up to date with these supported types\nconst featureTypes = {\n  Document: processDocument,\n  Folder: processFolder,\n  Placemark: processPlacemark,\n  NetworkLink: processNetworkLink,\n  GroundOverlay: processGroundOverlay,\n  PhotoOverlay: processUnsupportedFeature,\n  ScreenOverlay: processScreenOverlay,\n  Tour: processTour,\n};\n\nfunction DeferredLoading(dataSource) {\n  this._dataSource = dataSource;\n  this._deferred = defer();\n  this._stack = [];\n  this._promises = [];\n  this._timeoutSet = false;\n  this._used = false;\n\n  this._started = 0;\n  this._timeThreshold = 1000; // Initial load is 1 second\n}\n\nObject.defineProperties(DeferredLoading.prototype, {\n  dataSource: {\n    get: function () {\n      return this._dataSource;\n    },\n  },\n});\n\nDeferredLoading.prototype.addNodes = function (nodes, processingData) {\n  this._stack.push({\n    nodes: nodes,\n    index: 0,\n    processingData: processingData,\n  });\n  this._used = true;\n};\n\nDeferredLoading.prototype.addPromise = function (promise) {\n  this._promises.push(promise);\n};\n\nDeferredLoading.prototype.wait = function () {\n  // Case where we had a non-document/folder as the root\n  const deferred = this._deferred;\n  if (!this._used) {\n    deferred.resolve();\n  }\n\n  return Promise.all([deferred.promise, Promise.all(this._promises)]);\n};\n\nDeferredLoading.prototype.process = function () {\n  const isFirstCall = this._stack.length === 1;\n  if (isFirstCall) {\n    this._started = KmlDataSource._getTimestamp();\n  }\n\n  return this._process(isFirstCall);\n};\n\nDeferredLoading.prototype._giveUpTime = function () {\n  if (this._timeoutSet) {\n    // Timeout was already set so just return\n    return;\n  }\n\n  this._timeoutSet = true;\n  this._timeThreshold = 50; // After the first load lower threshold to 0.5 seconds\n  const that = this;\n  setTimeout(function () {\n    that._timeoutSet = false;\n    that._started = KmlDataSource._getTimestamp();\n    that._process(true);\n  }, 0);\n};\n\nDeferredLoading.prototype._nextNode = function () {\n  const stack = this._stack;\n  const top = stack[stack.length - 1];\n  const index = top.index;\n  const nodes = top.nodes;\n  if (index === nodes.length) {\n    return;\n  }\n  ++top.index;\n\n  return nodes[index];\n};\n\nDeferredLoading.prototype._pop = function () {\n  const stack = this._stack;\n  stack.pop();\n\n  // Return false if we are done\n  if (stack.length === 0) {\n    this._deferred.resolve();\n    return false;\n  }\n\n  return true;\n};\n\nDeferredLoading.prototype._process = function (isFirstCall) {\n  const dataSource = this.dataSource;\n  const processingData = this._stack[this._stack.length - 1].processingData;\n\n  let child = this._nextNode();\n  while (defined(child)) {\n    const featureProcessor = featureTypes[child.localName];\n    if (\n      defined(featureProcessor) &&\n      (namespaces.kml.indexOf(child.namespaceURI) !== -1 ||\n        namespaces.gx.indexOf(child.namespaceURI) !== -1)\n    ) {\n      featureProcessor(dataSource, child, processingData, this);\n\n      // Give up time and continue loading later\n      if (\n        this._timeoutSet ||\n        KmlDataSource._getTimestamp() > this._started + this._timeThreshold\n      ) {\n        this._giveUpTime();\n        return;\n      }\n    }\n\n    child = this._nextNode();\n  }\n\n  // If we are a recursive call from a subfolder, just return so the parent folder can continue processing\n  // If we aren't then make another call to processNodes because there is stuff still left in the queue\n  if (this._pop() && isFirstCall) {\n    this._process(true);\n  }\n};\n\nfunction isZipFile(blob) {\n  const magicBlob = blob.slice(0, Math.min(4, blob.size));\n  const deferred = defer();\n  const reader = new FileReader();\n  reader.addEventListener(\"load\", function () {\n    deferred.resolve(\n      new DataView(reader.result).getUint32(0, false) === 0x504b0304,\n    );\n  });\n  reader.addEventListener(\"error\", function () {\n    deferred.reject(reader.error);\n  });\n  reader.readAsArrayBuffer(magicBlob);\n  return deferred.promise;\n}\n\nfunction readBlobAsText(blob) {\n  const deferred = defer();\n  const reader = new FileReader();\n  reader.addEventListener(\"load\", function () {\n    deferred.resolve(reader.result);\n  });\n  reader.addEventListener(\"error\", function () {\n    deferred.reject(reader.error);\n  });\n  reader.readAsText(blob);\n  return deferred.promise;\n}\n\nfunction insertNamespaces(text) {\n  const namespaceMap = {\n    xsi: \"http://www.w3.org/2001/XMLSchema-instance\",\n  };\n  let firstPart, lastPart, reg, declaration;\n\n  for (const key in namespaceMap) {\n    if (namespaceMap.hasOwnProperty(key)) {\n      reg = RegExp(`[< ]${key}:`);\n      declaration = `xmlns:${key}=`;\n      if (reg.test(text) && text.indexOf(declaration) === -1) {\n        if (!defined(firstPart)) {\n          firstPart = text.substr(0, text.indexOf(\"<kml\") + 4);\n          lastPart = text.substr(firstPart.length);\n        }\n        firstPart += ` ${declaration}\"${namespaceMap[key]}\"`;\n      }\n    }\n  }\n\n  if (defined(firstPart)) {\n    text = firstPart + lastPart;\n  }\n\n  return text;\n}\n\nfunction removeDuplicateNamespaces(text) {\n  let index = text.indexOf(\"xmlns:\");\n  const endDeclaration = text.indexOf(\">\", index);\n  let namespace, startIndex, endIndex;\n\n  while (index !== -1 && index < endDeclaration) {\n    namespace = text.slice(index, text.indexOf('\"', index));\n    startIndex = index;\n    index = text.indexOf(namespace, index + 1);\n    if (index !== -1) {\n      endIndex = text.indexOf('\"', text.indexOf('\"', index) + 1);\n      text = text.slice(0, index - 1) + text.slice(endIndex + 1, text.length);\n      index = text.indexOf(\"xmlns:\", startIndex - 1);\n    } else {\n      index = text.indexOf(\"xmlns:\", startIndex + 1);\n    }\n  }\n\n  return text;\n}\n\nasync function loadXmlFromZip(entry, uriResolver) {\n  let text = await entry.getData(new TextWriter());\n  text = insertNamespaces(text);\n  text = removeDuplicateNamespaces(text);\n  uriResolver.kml = parser.parseFromString(text, \"application/xml\");\n}\n\nasync function loadDataUriFromZip(entry, uriResolver) {\n  const mimeType =\n    MimeTypes.detectFromFilename(entry.filename) ?? \"application/octet-stream\";\n  const dataUri = await entry.getData(new Data64URIWriter(mimeType));\n  uriResolver[entry.filename] = dataUri;\n}\n\nfunction embedDataUris(div, elementType, attributeName, uriResolver) {\n  const keys = uriResolver.keys;\n  const baseUri = new Uri(\".\");\n  const elements = div.querySelectorAll(elementType);\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    const value = element.getAttribute(attributeName);\n    if (defined(value)) {\n      const relativeUri = new Uri(value);\n      const uri = relativeUri.absoluteTo(baseUri).toString();\n      const index = keys.indexOf(uri);\n      if (index !== -1) {\n        const key = keys[index];\n        element.setAttribute(attributeName, uriResolver[key]);\n        if (elementType === \"a\" && element.getAttribute(\"download\") === null) {\n          element.setAttribute(\"download\", key);\n        }\n      }\n    }\n  }\n}\n\nfunction applyBasePath(div, elementType, attributeName, sourceResource) {\n  const elements = div.querySelectorAll(elementType);\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    const value = element.getAttribute(attributeName);\n    const resource = resolveHref(value, sourceResource);\n    if (defined(resource)) {\n      element.setAttribute(attributeName, resource.url);\n    }\n  }\n}\n\n// an optional context is passed to allow for some malformed kmls (those with multiple geometries with same ids) to still parse\n// correctly, as they do in Google Earth.\nfunction createEntity(node, entityCollection, context) {\n  let id = queryStringAttribute(node, \"id\");\n  id = defined(id) && id.length !== 0 ? id : createGuid();\n  if (defined(context)) {\n    id = context + id;\n  }\n\n  // If we have a duplicate ID just generate one.\n  // This isn't valid KML but Google Earth handles this case.\n  let entity = entityCollection.getById(id);\n  if (defined(entity)) {\n    id = createGuid();\n    if (defined(context)) {\n      id = context + id;\n    }\n  }\n\n  entity = entityCollection.add(new Entity({ id: id }));\n  if (!defined(entity.kml)) {\n    entity.addProperty(\"kml\");\n    entity.kml = new KmlFeatureData();\n  }\n  return entity;\n}\n\nfunction isExtrudable(altitudeMode, gxAltitudeMode) {\n  return (\n    altitudeMode === \"absolute\" ||\n    altitudeMode === \"relativeToGround\" ||\n    gxAltitudeMode === \"relativeToSeaFloor\"\n  );\n}\n\nfunction readCoordinate(value, ellipsoid) {\n  //Google Earth treats empty or missing coordinates as 0.\n  if (!defined(value)) {\n    return Cartesian3.fromDegrees(0, 0, 0, ellipsoid);\n  }\n\n  const digits = value.match(/[^\\s,\\n]+/g);\n  if (!defined(digits)) {\n    return Cartesian3.fromDegrees(0, 0, 0, ellipsoid);\n  }\n\n  let longitude = parseFloat(digits[0]);\n  let latitude = parseFloat(digits[1]);\n  let height = parseFloat(digits[2]);\n\n  longitude = isNaN(longitude) ? 0.0 : longitude;\n  latitude = isNaN(latitude) ? 0.0 : latitude;\n  height = isNaN(height) ? 0.0 : height;\n\n  return Cartesian3.fromDegrees(longitude, latitude, height, ellipsoid);\n}\n\nfunction readCoordinates(element, ellipsoid) {\n  if (!defined(element)) {\n    return undefined;\n  }\n\n  const tuples = element.textContent.match(/[^\\s\\n]+/g);\n  if (!defined(tuples)) {\n    return undefined;\n  }\n\n  const length = tuples.length;\n  const result = new Array(length);\n  let resultIndex = 0;\n  for (let i = 0; i < length; i++) {\n    result[resultIndex++] = readCoordinate(tuples[i], ellipsoid);\n  }\n  return result;\n}\n\nfunction queryNumericAttribute(node, attributeName) {\n  if (!defined(node)) {\n    return undefined;\n  }\n\n  const value = node.getAttribute(attributeName);\n  if (value !== null) {\n    const result = parseFloat(value);\n    return !isNaN(result) ? result : undefined;\n  }\n  return undefined;\n}\n\nfunction queryStringAttribute(node, attributeName) {\n  if (!defined(node)) {\n    return undefined;\n  }\n  const value = node.getAttribute(attributeName);\n  return value !== null ? value : undefined;\n}\n\nfunction queryFirstNode(node, tagName, namespace) {\n  if (!defined(node)) {\n    return undefined;\n  }\n  const childNodes = node.childNodes;\n  const length = childNodes.length;\n  for (let q = 0; q < length; q++) {\n    const child = childNodes[q];\n    if (\n      child.localName === tagName &&\n      namespace.indexOf(child.namespaceURI) !== -1\n    ) {\n      return child;\n    }\n  }\n  return undefined;\n}\n\nfunction queryNodes(node, tagName, namespace) {\n  if (!defined(node)) {\n    return undefined;\n  }\n  const result = [];\n  const childNodes = node.getElementsByTagNameNS(\"*\", tagName);\n  const length = childNodes.length;\n  for (let q = 0; q < length; q++) {\n    const child = childNodes[q];\n    if (\n      child.localName === tagName &&\n      namespace.indexOf(child.namespaceURI) !== -1\n    ) {\n      result.push(child);\n    }\n  }\n  return result;\n}\n\nfunction queryChildNodes(node, tagName, namespace) {\n  if (!defined(node)) {\n    return [];\n  }\n  const result = [];\n  const childNodes = node.childNodes;\n  const length = childNodes.length;\n  for (let q = 0; q < length; q++) {\n    const child = childNodes[q];\n    if (\n      child.localName === tagName &&\n      namespace.indexOf(child.namespaceURI) !== -1\n    ) {\n      result.push(child);\n    }\n  }\n  return result;\n}\n\nfunction queryNumericValue(node, tagName, namespace) {\n  const resultNode = queryFirstNode(node, tagName, namespace);\n  if (defined(resultNode)) {\n    const result = parseFloat(resultNode.textContent);\n    return !isNaN(result) ? result : undefined;\n  }\n  return undefined;\n}\n\nfunction queryStringValue(node, tagName, namespace) {\n  const result = queryFirstNode(node, tagName, namespace);\n  if (defined(result)) {\n    return result.textContent.trim();\n  }\n  return undefined;\n}\n\nfunction queryBooleanValue(node, tagName, namespace) {\n  const result = queryFirstNode(node, tagName, namespace);\n  if (defined(result)) {\n    const value = result.textContent.trim();\n    return value === \"1\" || /^true$/i.test(value);\n  }\n  return undefined;\n}\n\nfunction resolveHref(href, sourceResource, uriResolver) {\n  if (!defined(href)) {\n    return undefined;\n  }\n\n  let resource;\n  if (defined(uriResolver)) {\n    // To resolve issues with KML sources defined in Windows style paths.\n    href = href.replace(/\\\\/g, \"/\");\n    let blob = uriResolver[href];\n    if (defined(blob)) {\n      resource = new Resource({\n        url: blob,\n      });\n    } else {\n      // Needed for multiple levels of KML files in a KMZ\n      const baseUri = new Uri(sourceResource.getUrlComponent());\n      const uri = new Uri(href);\n      blob = uriResolver[uri.absoluteTo(baseUri)];\n      if (defined(blob)) {\n        resource = new Resource({\n          url: blob,\n        });\n      }\n    }\n  }\n\n  if (!defined(resource)) {\n    resource = sourceResource.getDerivedResource({\n      url: href,\n    });\n  }\n\n  return resource;\n}\n\nconst colorOptions = {\n  maximumRed: undefined,\n  red: undefined,\n  maximumGreen: undefined,\n  green: undefined,\n  maximumBlue: undefined,\n  blue: undefined,\n};\n\nfunction parseColorString(value, isRandom) {\n  if (!defined(value) || /^\\s*$/gm.test(value)) {\n    return undefined;\n  }\n\n  if (value[0] === \"#\") {\n    value = value.substring(1);\n  }\n\n  const alpha = parseInt(value.substring(0, 2), 16) / 255.0;\n  const blue = parseInt(value.substring(2, 4), 16) / 255.0;\n  const green = parseInt(value.substring(4, 6), 16) / 255.0;\n  const red = parseInt(value.substring(6, 8), 16) / 255.0;\n\n  if (!isRandom) {\n    return new Color(red, green, blue, alpha);\n  }\n\n  if (red > 0) {\n    colorOptions.maximumRed = red;\n    colorOptions.red = undefined;\n  } else {\n    colorOptions.maximumRed = undefined;\n    colorOptions.red = 0;\n  }\n  if (green > 0) {\n    colorOptions.maximumGreen = green;\n    colorOptions.green = undefined;\n  } else {\n    colorOptions.maximumGreen = undefined;\n    colorOptions.green = 0;\n  }\n  if (blue > 0) {\n    colorOptions.maximumBlue = blue;\n    colorOptions.blue = undefined;\n  } else {\n    colorOptions.maximumBlue = undefined;\n    colorOptions.blue = 0;\n  }\n  colorOptions.alpha = alpha;\n  return Color.fromRandom(colorOptions);\n}\n\nfunction queryColorValue(node, tagName, namespace) {\n  const value = queryStringValue(node, tagName, namespace);\n  if (!defined(value)) {\n    return undefined;\n  }\n  return parseColorString(\n    value,\n    queryStringValue(node, \"colorMode\", namespace) === \"random\",\n  );\n}\n\nfunction processTimeStamp(featureNode) {\n  const node = queryFirstNode(featureNode, \"TimeStamp\", namespaces.kmlgx);\n  const whenString = queryStringValue(node, \"when\", namespaces.kmlgx);\n\n  if (!defined(node) || !defined(whenString) || whenString.length === 0) {\n    return undefined;\n  }\n\n  //According to the KML spec, a TimeStamp represents a \"single moment in time\"\n  //However, since Cesium animates much differently than Google Earth, that doesn't\n  //Make much sense here.  Instead, we use the TimeStamp as the moment the feature\n  //comes into existence.  This works much better and gives a similar feel to\n  //GE's experience.\n  const when = JulianDate.fromIso8601(whenString);\n  const result = new TimeIntervalCollection();\n  result.addInterval(\n    new TimeInterval({\n      start: when,\n      stop: Iso8601.MAXIMUM_VALUE,\n    }),\n  );\n  return result;\n}\n\nfunction processTimeSpan(featureNode) {\n  const node = queryFirstNode(featureNode, \"TimeSpan\", namespaces.kmlgx);\n  if (!defined(node)) {\n    return undefined;\n  }\n  let result;\n\n  const beginNode = queryFirstNode(node, \"begin\", namespaces.kmlgx);\n  let beginDate = defined(beginNode)\n    ? JulianDate.fromIso8601(beginNode.textContent)\n    : undefined;\n\n  const endNode = queryFirstNode(node, \"end\", namespaces.kmlgx);\n  let endDate = defined(endNode)\n    ? JulianDate.fromIso8601(endNode.textContent)\n    : undefined;\n\n  if (defined(beginDate) && defined(endDate)) {\n    if (JulianDate.lessThan(endDate, beginDate)) {\n      const tmp = beginDate;\n      beginDate = endDate;\n      endDate = tmp;\n    }\n    result = new TimeIntervalCollection();\n    result.addInterval(\n      new TimeInterval({\n        start: beginDate,\n        stop: endDate,\n      }),\n    );\n  } else if (defined(beginDate)) {\n    result = new TimeIntervalCollection();\n    result.addInterval(\n      new TimeInterval({\n        start: beginDate,\n        stop: Iso8601.MAXIMUM_VALUE,\n      }),\n    );\n  } else if (defined(endDate)) {\n    result = new TimeIntervalCollection();\n    result.addInterval(\n      new TimeInterval({\n        start: Iso8601.MINIMUM_VALUE,\n        stop: endDate,\n      }),\n    );\n  }\n\n  return result;\n}\n\nfunction createDefaultBillboard() {\n  const billboard = new BillboardGraphics();\n  billboard.width = BILLBOARD_SIZE;\n  billboard.height = BILLBOARD_SIZE;\n  billboard.scaleByDistance = new NearFarScalar(\n    BILLBOARD_NEAR_DISTANCE,\n    BILLBOARD_NEAR_RATIO,\n    BILLBOARD_FAR_DISTANCE,\n    BILLBOARD_FAR_RATIO,\n  );\n  billboard.pixelOffsetScaleByDistance = new NearFarScalar(\n    BILLBOARD_NEAR_DISTANCE,\n    BILLBOARD_NEAR_RATIO,\n    BILLBOARD_FAR_DISTANCE,\n    BILLBOARD_FAR_RATIO,\n  );\n  return billboard;\n}\n\nfunction createDefaultPolygon() {\n  const polygon = new PolygonGraphics();\n  polygon.outline = true;\n  polygon.outlineColor = Color.WHITE;\n  return polygon;\n}\n\nfunction createDefaultLabel() {\n  const label = new LabelGraphics();\n  label.translucencyByDistance = new NearFarScalar(3000000, 1.0, 5000000, 0.0);\n  label.pixelOffset = new Cartesian2(17, 0);\n  label.horizontalOrigin = HorizontalOrigin.LEFT;\n  label.font = \"16px sans-serif\";\n  label.style = LabelStyle.FILL_AND_OUTLINE;\n  return label;\n}\n\nfunction getIconHref(\n  iconNode,\n  dataSource,\n  sourceResource,\n  uriResolver,\n  canRefresh,\n) {\n  let href = queryStringValue(iconNode, \"href\", namespaces.kml);\n  if (!defined(href) || href.length === 0) {\n    return undefined;\n  }\n\n  if (href.indexOf(\"root://icons/palette-\") === 0) {\n    const palette = href.charAt(21);\n\n    // Get the icon number\n    let x = queryNumericValue(iconNode, \"x\", namespaces.gx) ?? 0;\n    let y = queryNumericValue(iconNode, \"y\", namespaces.gx) ?? 0;\n    x = Math.min(x / 32, 7);\n    y = 7 - Math.min(y / 32, 7);\n    const iconNum = 8 * y + x;\n\n    href = `https://maps.google.com/mapfiles/kml/pal${palette}/icon${iconNum}.png`;\n  }\n\n  const hrefResource = resolveHref(href, sourceResource, uriResolver);\n\n  if (canRefresh) {\n    const refreshMode = queryStringValue(\n      iconNode,\n      \"refreshMode\",\n      namespaces.kml,\n    );\n    const viewRefreshMode = queryStringValue(\n      iconNode,\n      \"viewRefreshMode\",\n      namespaces.kml,\n    );\n    if (refreshMode === \"onInterval\" || refreshMode === \"onExpire\") {\n      oneTimeWarning(\n        `kml-refreshMode-${refreshMode}`,\n        `KML - Unsupported Icon refreshMode: ${refreshMode}`,\n      );\n    } else if (viewRefreshMode === \"onStop\" || viewRefreshMode === \"onRegion\") {\n      oneTimeWarning(\n        `kml-refreshMode-${viewRefreshMode}`,\n        `KML - Unsupported Icon viewRefreshMode: ${viewRefreshMode}`,\n      );\n    }\n\n    const viewBoundScale =\n      queryStringValue(iconNode, \"viewBoundScale\", namespaces.kml) ?? 1.0;\n    const defaultViewFormat =\n      viewRefreshMode === \"onStop\"\n        ? \"BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]\"\n        : \"\";\n    const viewFormat =\n      queryStringValue(iconNode, \"viewFormat\", namespaces.kml) ??\n      defaultViewFormat;\n    const httpQuery = queryStringValue(iconNode, \"httpQuery\", namespaces.kml);\n    if (defined(viewFormat)) {\n      hrefResource.setQueryParameters(queryToObject(cleanupString(viewFormat)));\n    }\n    if (defined(httpQuery)) {\n      hrefResource.setQueryParameters(queryToObject(cleanupString(httpQuery)));\n    }\n\n    const ellipsoid = dataSource._ellipsoid;\n    processNetworkLinkQueryString(\n      hrefResource,\n      dataSource.camera,\n      dataSource.canvas,\n      viewBoundScale,\n      dataSource._lastCameraView.bbox,\n      ellipsoid,\n    );\n\n    return hrefResource;\n  }\n\n  return hrefResource;\n}\n\nfunction processBillboardIcon(\n  dataSource,\n  node,\n  targetEntity,\n  sourceResource,\n  uriResolver,\n) {\n  let scale = queryNumericValue(node, \"scale\", namespaces.kml);\n  const heading = queryNumericValue(node, \"heading\", namespaces.kml);\n  const color = queryColorValue(node, \"color\", namespaces.kml);\n\n  const iconNode = queryFirstNode(node, \"Icon\", namespaces.kml);\n  let icon = getIconHref(\n    iconNode,\n    dataSource,\n    sourceResource,\n    uriResolver,\n    false,\n  );\n\n  // If icon tags are present but blank, we do not want to show an icon\n  if (defined(iconNode) && !defined(icon)) {\n    icon = false;\n  }\n\n  const x = queryNumericValue(iconNode, \"x\", namespaces.gx);\n  const y = queryNumericValue(iconNode, \"y\", namespaces.gx);\n  const w = queryNumericValue(iconNode, \"w\", namespaces.gx);\n  const h = queryNumericValue(iconNode, \"h\", namespaces.gx);\n\n  const hotSpotNode = queryFirstNode(node, \"hotSpot\", namespaces.kml);\n  const hotSpotX = queryNumericAttribute(hotSpotNode, \"x\");\n  const hotSpotY = queryNumericAttribute(hotSpotNode, \"y\");\n  const hotSpotXUnit = queryStringAttribute(hotSpotNode, \"xunits\");\n  const hotSpotYUnit = queryStringAttribute(hotSpotNode, \"yunits\");\n\n  let billboard = targetEntity.billboard;\n  if (!defined(billboard)) {\n    billboard = createDefaultBillboard();\n    targetEntity.billboard = billboard;\n  }\n\n  billboard.image = icon;\n  billboard.scale = scale;\n  billboard.color = color;\n\n  if (defined(x) || defined(y) || defined(w) || defined(h)) {\n    billboard.imageSubRegion = new BoundingRectangle(x, y, w, h);\n  }\n\n  //GE treats a heading of zero as no heading\n  //You can still point north using a 360 degree angle (or any multiple of 360)\n  if (defined(heading) && heading !== 0) {\n    billboard.rotation = CesiumMath.toRadians(-heading);\n    billboard.alignedAxis = Cartesian3.UNIT_Z;\n  }\n\n  //Hotpot is the KML equivalent of pixel offset\n  //The hotspot origin is the lower left, but we leave\n  //our billboard origin at the center and simply\n  //modify the pixel offset to take this into account\n  scale = scale ?? 1.0;\n\n  let xOffset;\n  let yOffset;\n  if (defined(hotSpotX)) {\n    if (hotSpotXUnit === \"pixels\") {\n      xOffset = -hotSpotX * scale;\n    } else if (hotSpotXUnit === \"insetPixels\") {\n      xOffset = (hotSpotX - BILLBOARD_SIZE) * scale;\n    } else if (hotSpotXUnit === \"fraction\") {\n      xOffset = -hotSpotX * BILLBOARD_SIZE * scale;\n    }\n    xOffset += BILLBOARD_SIZE * 0.5 * scale;\n  }\n\n  if (defined(hotSpotY)) {\n    if (hotSpotYUnit === \"pixels\") {\n      yOffset = hotSpotY * scale;\n    } else if (hotSpotYUnit === \"insetPixels\") {\n      yOffset = (-hotSpotY + BILLBOARD_SIZE) * scale;\n    } else if (hotSpotYUnit === \"fraction\") {\n      yOffset = hotSpotY * BILLBOARD_SIZE * scale;\n    }\n\n    yOffset -= BILLBOARD_SIZE * 0.5 * scale;\n  }\n\n  if (defined(xOffset) || defined(yOffset)) {\n    billboard.pixelOffset = new Cartesian2(xOffset, yOffset);\n  }\n}\n\nfunction applyStyle(\n  dataSource,\n  styleNode,\n  targetEntity,\n  sourceResource,\n  uriResolver,\n) {\n  for (let i = 0, len = styleNode.childNodes.length; i < len; i++) {\n    const node = styleNode.childNodes.item(i);\n    if (node.localName === \"IconStyle\") {\n      processBillboardIcon(\n        dataSource,\n        node,\n        targetEntity,\n        sourceResource,\n        uriResolver,\n      );\n    } else if (node.localName === \"LabelStyle\") {\n      let label = targetEntity.label;\n      if (!defined(label)) {\n        label = createDefaultLabel();\n        targetEntity.label = label;\n      }\n      label.scale =\n        queryNumericValue(node, \"scale\", namespaces.kml) ?? label.scale;\n      label.fillColor =\n        queryColorValue(node, \"color\", namespaces.kml) ?? label.fillColor;\n      label.text = targetEntity.name;\n    } else if (node.localName === \"LineStyle\") {\n      let polyline = targetEntity.polyline;\n      if (!defined(polyline)) {\n        polyline = new PolylineGraphics();\n        targetEntity.polyline = polyline;\n      }\n      polyline.width = queryNumericValue(node, \"width\", namespaces.kml);\n      polyline.material = queryColorValue(node, \"color\", namespaces.kml);\n      if (defined(queryColorValue(node, \"outerColor\", namespaces.gx))) {\n        oneTimeWarning(\n          \"kml-gx:outerColor\",\n          \"KML - gx:outerColor is not supported in a LineStyle\",\n        );\n      }\n      if (defined(queryNumericValue(node, \"outerWidth\", namespaces.gx))) {\n        oneTimeWarning(\n          \"kml-gx:outerWidth\",\n          \"KML - gx:outerWidth is not supported in a LineStyle\",\n        );\n      }\n      if (defined(queryNumericValue(node, \"physicalWidth\", namespaces.gx))) {\n        oneTimeWarning(\n          \"kml-gx:physicalWidth\",\n          \"KML - gx:physicalWidth is not supported in a LineStyle\",\n        );\n      }\n      if (defined(queryBooleanValue(node, \"labelVisibility\", namespaces.gx))) {\n        oneTimeWarning(\n          \"kml-gx:labelVisibility\",\n          \"KML - gx:labelVisibility is not supported in a LineStyle\",\n        );\n      }\n    } else if (node.localName === \"PolyStyle\") {\n      let polygon = targetEntity.polygon;\n      if (!defined(polygon)) {\n        polygon = createDefaultPolygon();\n        targetEntity.polygon = polygon;\n      }\n      polygon.material =\n        queryColorValue(node, \"color\", namespaces.kml) ?? polygon.material;\n      polygon.fill =\n        queryBooleanValue(node, \"fill\", namespaces.kml) ?? polygon.fill;\n      polygon.outline =\n        queryBooleanValue(node, \"outline\", namespaces.kml) ?? polygon.outline;\n    } else if (node.localName === \"BalloonStyle\") {\n      const bgColor =\n        parseColorString(queryStringValue(node, \"bgColor\", namespaces.kml)) ??\n        Color.WHITE;\n      const textColor =\n        parseColorString(queryStringValue(node, \"textColor\", namespaces.kml)) ??\n        Color.BLACK;\n      const text = queryStringValue(node, \"text\", namespaces.kml);\n\n      //This is purely an internal property used in style processing,\n      //it never ends up on the final entity.\n      targetEntity.addProperty(\"balloonStyle\");\n      targetEntity.balloonStyle = {\n        bgColor: bgColor,\n        textColor: textColor,\n        text: text,\n      };\n    } else if (node.localName === \"ListStyle\") {\n      const listItemType = queryStringValue(\n        node,\n        \"listItemType\",\n        namespaces.kml,\n      );\n      if (listItemType === \"radioFolder\" || listItemType === \"checkOffOnly\") {\n        oneTimeWarning(\n          `kml-listStyle-${listItemType}`,\n          `KML - Unsupported ListStyle with listItemType: ${listItemType}`,\n        );\n      }\n    }\n  }\n}\n\n//Processes and merges any inline styles for the provided node into the provided entity.\nfunction computeFinalStyle(\n  dataSource,\n  placeMark,\n  styleCollection,\n  sourceResource,\n  uriResolver,\n) {\n  const result = new Entity();\n  let styleEntity;\n\n  //Google earth seems to always use the last inline Style/StyleMap only\n  let styleIndex = -1;\n  const childNodes = placeMark.childNodes;\n  const length = childNodes.length;\n  for (let q = 0; q < length; q++) {\n    const child = childNodes[q];\n    if (child.localName === \"Style\" || child.localName === \"StyleMap\") {\n      styleIndex = q;\n    }\n  }\n\n  if (styleIndex !== -1) {\n    const inlineStyleNode = childNodes[styleIndex];\n    if (inlineStyleNode.localName === \"Style\") {\n      applyStyle(\n        dataSource,\n        inlineStyleNode,\n        result,\n        sourceResource,\n        uriResolver,\n      );\n    } else {\n      // StyleMap\n      const pairs = queryChildNodes(inlineStyleNode, \"Pair\", namespaces.kml);\n      for (let p = 0; p < pairs.length; p++) {\n        const pair = pairs[p];\n        const key = queryStringValue(pair, \"key\", namespaces.kml);\n        if (key === \"normal\") {\n          const styleUrl = queryStringValue(pair, \"styleUrl\", namespaces.kml);\n          if (defined(styleUrl)) {\n            styleEntity = styleCollection.getById(styleUrl);\n            if (!defined(styleEntity)) {\n              styleEntity = styleCollection.getById(`#${styleUrl}`);\n            }\n            if (defined(styleEntity)) {\n              result.merge(styleEntity);\n            }\n          } else {\n            const node = queryFirstNode(pair, \"Style\", namespaces.kml);\n            applyStyle(dataSource, node, result, sourceResource, uriResolver);\n          }\n        } else {\n          oneTimeWarning(\n            `kml-styleMap-${key}`,\n            `KML - Unsupported StyleMap key: ${key}`,\n          );\n        }\n      }\n    }\n  }\n\n  //Google earth seems to always use the first external style only.\n  const externalStyle = queryStringValue(placeMark, \"styleUrl\", namespaces.kml);\n  if (defined(externalStyle)) {\n    let id = externalStyle;\n    if (externalStyle[0] !== \"#\" && externalStyle.indexOf(\"#\") !== -1) {\n      const tokens = externalStyle.split(\"#\");\n      const uri = tokens[0];\n      const resource = sourceResource.getDerivedResource({\n        url: uri,\n      });\n\n      id = `${resource.getUrlComponent()}#${tokens[1]}`;\n    }\n\n    styleEntity = styleCollection.getById(id);\n    if (!defined(styleEntity)) {\n      styleEntity = styleCollection.getById(`#${id}`);\n    }\n    if (defined(styleEntity)) {\n      result.merge(styleEntity);\n    }\n  }\n\n  return result;\n}\n\n//Asynchronously processes an external style file.\nfunction processExternalStyles(dataSource, resource, styleCollection) {\n  return resource.fetchXML().then(function (styleKml) {\n    return processStyles(dataSource, styleKml, styleCollection, resource, true);\n  });\n}\n\n//Processes all shared and external styles and stores\n//their id into the provided styleCollection.\n//Returns an array of promises that will resolve when\n//each style is loaded.\nfunction processStyles(\n  dataSource,\n  kml,\n  styleCollection,\n  sourceResource,\n  isExternal,\n  uriResolver,\n) {\n  let i;\n  let id;\n  let styleEntity;\n\n  let node;\n  const styleNodes = queryNodes(kml, \"Style\", namespaces.kml);\n  if (defined(styleNodes)) {\n    const styleNodesLength = styleNodes.length;\n    for (i = 0; i < styleNodesLength; i++) {\n      node = styleNodes[i];\n      id = queryStringAttribute(node, \"id\");\n      if (defined(id)) {\n        id = `#${id}`;\n        if (isExternal && defined(sourceResource)) {\n          id = sourceResource.getUrlComponent() + id;\n        }\n        if (!defined(styleCollection.getById(id))) {\n          styleEntity = new Entity({\n            id: id,\n          });\n          styleCollection.add(styleEntity);\n          applyStyle(\n            dataSource,\n            node,\n            styleEntity,\n            sourceResource,\n            uriResolver,\n          );\n        }\n      }\n    }\n  }\n\n  const styleMaps = queryNodes(kml, \"StyleMap\", namespaces.kml);\n  if (defined(styleMaps)) {\n    const styleMapsLength = styleMaps.length;\n    for (i = 0; i < styleMapsLength; i++) {\n      const styleMap = styleMaps[i];\n      id = queryStringAttribute(styleMap, \"id\");\n      if (defined(id)) {\n        const pairs = queryChildNodes(styleMap, \"Pair\", namespaces.kml);\n        for (let p = 0; p < pairs.length; p++) {\n          const pair = pairs[p];\n          const key = queryStringValue(pair, \"key\", namespaces.kml);\n          if (key === \"normal\") {\n            id = `#${id}`;\n            if (isExternal && defined(sourceResource)) {\n              id = sourceResource.getUrlComponent() + id;\n            }\n            if (!defined(styleCollection.getById(id))) {\n              styleEntity = styleCollection.getOrCreateEntity(id);\n\n              let styleUrl = queryStringValue(pair, \"styleUrl\", namespaces.kml);\n              if (defined(styleUrl)) {\n                if (styleUrl[0] !== \"#\") {\n                  styleUrl = `#${styleUrl}`;\n                }\n\n                if (isExternal && defined(sourceResource)) {\n                  styleUrl = sourceResource.getUrlComponent() + styleUrl;\n                }\n                const base = styleCollection.getById(styleUrl);\n\n                if (defined(base)) {\n                  styleEntity.merge(base);\n                }\n              } else {\n                node = queryFirstNode(pair, \"Style\", namespaces.kml);\n                applyStyle(\n                  dataSource,\n                  node,\n                  styleEntity,\n                  sourceResource,\n                  uriResolver,\n                );\n              }\n            }\n          } else {\n            oneTimeWarning(\n              `kml-styleMap-${key}`,\n              `KML - Unsupported StyleMap key: ${key}`,\n            );\n          }\n        }\n      }\n    }\n  }\n\n  const promises = [];\n  const styleUrlNodes = kml.getElementsByTagName(\"styleUrl\");\n  const styleUrlNodesLength = styleUrlNodes.length;\n  for (i = 0; i < styleUrlNodesLength; i++) {\n    const styleReference = styleUrlNodes[i].textContent;\n    if (styleReference[0] !== \"#\") {\n      //According to the spec, all local styles should start with a #\n      //and everything else is an external style that has a # seperating\n      //the URL of the document and the style.  However, Google Earth\n      //also accepts styleUrls without a # as meaning a local style.\n      const tokens = styleReference.split(\"#\");\n      if (tokens.length === 2) {\n        const uri = tokens[0];\n        const resource = sourceResource.getDerivedResource({\n          url: uri,\n        });\n\n        promises.push(\n          processExternalStyles(dataSource, resource, styleCollection),\n        );\n      }\n    }\n  }\n\n  return promises;\n}\n\nfunction createDropLine(entityCollection, entity, styleEntity) {\n  const entityPosition = new ReferenceProperty(entityCollection, entity.id, [\n    \"position\",\n  ]);\n  const surfacePosition = new ScaledPositionProperty(entity.position);\n  entity.polyline = defined(styleEntity.polyline)\n    ? styleEntity.polyline.clone()\n    : new PolylineGraphics();\n  entity.polyline.positions = new PositionPropertyArray([\n    entityPosition,\n    surfacePosition,\n  ]);\n}\n\nfunction heightReferenceFromAltitudeMode(altitudeMode, gxAltitudeMode) {\n  if (\n    (!defined(altitudeMode) && !defined(gxAltitudeMode)) ||\n    altitudeMode === \"clampToGround\"\n  ) {\n    return HeightReference.CLAMP_TO_GROUND;\n  }\n\n  if (altitudeMode === \"relativeToGround\") {\n    return HeightReference.RELATIVE_TO_GROUND;\n  }\n\n  if (altitudeMode === \"absolute\") {\n    return HeightReference.NONE;\n  }\n\n  if (gxAltitudeMode === \"clampToSeaFloor\") {\n    oneTimeWarning(\n      \"kml-gx:altitudeMode-clampToSeaFloor\",\n      \"KML - <gx:altitudeMode>:clampToSeaFloor is currently not supported, using <kml:altitudeMode>:clampToGround.\",\n    );\n    return HeightReference.CLAMP_TO_GROUND;\n  }\n\n  if (gxAltitudeMode === \"relativeToSeaFloor\") {\n    oneTimeWarning(\n      \"kml-gx:altitudeMode-relativeToSeaFloor\",\n      \"KML - <gx:altitudeMode>:relativeToSeaFloor is currently not supported, using <kml:altitudeMode>:relativeToGround.\",\n    );\n    return HeightReference.RELATIVE_TO_GROUND;\n  }\n\n  if (defined(altitudeMode)) {\n    oneTimeWarning(\n      \"kml-altitudeMode-unknown\",\n      `KML - Unknown <kml:altitudeMode>:${altitudeMode}, using <kml:altitudeMode>:CLAMP_TO_GROUND.`,\n    );\n  } else {\n    oneTimeWarning(\n      \"kml-gx:altitudeMode-unknown\",\n      `KML - Unknown <gx:altitudeMode>:${gxAltitudeMode}, using <kml:altitudeMode>:CLAMP_TO_GROUND.`,\n    );\n  }\n\n  // Clamp to ground is the default\n  return HeightReference.CLAMP_TO_GROUND;\n}\n\nfunction createPositionPropertyFromAltitudeMode(\n  property,\n  altitudeMode,\n  gxAltitudeMode,\n) {\n  if (\n    gxAltitudeMode === \"relativeToSeaFloor\" ||\n    altitudeMode === \"absolute\" ||\n    altitudeMode === \"relativeToGround\"\n  ) {\n    //Just return the ellipsoid referenced property until we support MSL\n    return property;\n  }\n\n  if (\n    (defined(altitudeMode) && altitudeMode !== \"clampToGround\") || //\n    (defined(gxAltitudeMode) && gxAltitudeMode !== \"clampToSeaFloor\")\n  ) {\n    oneTimeWarning(\n      \"kml-altitudeMode-unknown\",\n      `KML - Unknown altitudeMode: ${altitudeMode ?? gxAltitudeMode}`,\n    );\n  }\n\n  // Clamp to ground is the default\n  return new ScaledPositionProperty(property);\n}\n\nfunction createPositionPropertyArrayFromAltitudeMode(\n  properties,\n  altitudeMode,\n  gxAltitudeMode,\n  ellipsoid,\n) {\n  if (!defined(properties)) {\n    return undefined;\n  }\n\n  if (\n    gxAltitudeMode === \"relativeToSeaFloor\" ||\n    altitudeMode === \"absolute\" ||\n    altitudeMode === \"relativeToGround\"\n  ) {\n    //Just return the ellipsoid referenced property until we support MSL\n    return properties;\n  }\n\n  if (\n    (defined(altitudeMode) && altitudeMode !== \"clampToGround\") || //\n    (defined(gxAltitudeMode) && gxAltitudeMode !== \"clampToSeaFloor\")\n  ) {\n    oneTimeWarning(\n      \"kml-altitudeMode-unknown\",\n      `KML - Unknown altitudeMode: ${altitudeMode ?? gxAltitudeMode}`,\n    );\n  }\n\n  // Clamp to ground is the default\n  const propertiesLength = properties.length;\n  for (let i = 0; i < propertiesLength; i++) {\n    const property = properties[i];\n    ellipsoid.scaleToGeodeticSurface(property, property);\n  }\n  return properties;\n}\n\nfunction processPositionGraphics(\n  dataSource,\n  entity,\n  styleEntity,\n  heightReference,\n) {\n  let label = entity.label;\n  if (!defined(label)) {\n    label = defined(styleEntity.label)\n      ? styleEntity.label.clone()\n      : createDefaultLabel();\n    entity.label = label;\n  }\n  label.text = entity.name;\n\n  let billboard = entity.billboard;\n  if (!defined(billboard)) {\n    billboard = defined(styleEntity.billboard)\n      ? styleEntity.billboard.clone()\n      : createDefaultBillboard();\n    entity.billboard = billboard;\n  }\n\n  if (!defined(billboard.image)) {\n    billboard.image = dataSource._pinBuilder.fromColor(Color.YELLOW, 64);\n\n    // If there were empty <Icon> tags in the KML, then billboard.image was set to false above\n    // However, in this case, the false value would have been converted to a property afterwards\n    // Thus, we check if billboard.image is defined with value of false\n  } else if (!billboard.image.getValue()) {\n    billboard.image = undefined;\n  }\n\n  let scale = 1.0;\n  if (defined(billboard.scale)) {\n    scale = billboard.scale.getValue();\n    if (scale !== 0) {\n      label.pixelOffset = new Cartesian2(scale * 16 + 1, 0);\n    } else {\n      //Minor tweaks to better match Google Earth.\n      label.pixelOffset = undefined;\n      label.horizontalOrigin = undefined;\n    }\n  }\n\n  if (defined(heightReference) && dataSource._clampToGround) {\n    billboard.heightReference = heightReference;\n    label.heightReference = heightReference;\n  }\n}\n\nfunction processPathGraphics(entity, styleEntity) {\n  let path = entity.path;\n  if (!defined(path)) {\n    path = new PathGraphics();\n    path.leadTime = 0;\n    entity.path = path;\n  }\n\n  const polyline = styleEntity.polyline;\n  if (defined(polyline)) {\n    path.material = polyline.material;\n    path.width = polyline.width;\n  }\n}\n\nfunction processPoint(\n  dataSource,\n  entityCollection,\n  geometryNode,\n  entity,\n  styleEntity,\n) {\n  const coordinatesString = queryStringValue(\n    geometryNode,\n    \"coordinates\",\n    namespaces.kml,\n  );\n  const altitudeMode = queryStringValue(\n    geometryNode,\n    \"altitudeMode\",\n    namespaces.kml,\n  );\n  const gxAltitudeMode = queryStringValue(\n    geometryNode,\n    \"altitudeMode\",\n    namespaces.gx,\n  );\n  const extrude = queryBooleanValue(geometryNode, \"extrude\", namespaces.kml);\n  const ellipsoid = dataSource._ellipsoid;\n  const position = readCoordinate(coordinatesString, ellipsoid);\n\n  entity.position = position;\n  processPositionGraphics(\n    dataSource,\n    entity,\n    styleEntity,\n    heightReferenceFromAltitudeMode(altitudeMode, gxAltitudeMode),\n  );\n\n  if (extrude && isExtrudable(altitudeMode, gxAltitudeMode)) {\n    createDropLine(entityCollection, entity, styleEntity);\n  }\n\n  return true;\n}\n\nfunction processLineStringOrLinearRing(\n  dataSource,\n  entityCollection,\n  geometryNode,\n  entity,\n  styleEntity,\n) {\n  const coordinatesNode = queryFirstNode(\n    geometryNode,\n    \"coordinates\",\n    namespaces.kml,\n  );\n  const altitudeMode = queryStringValue(\n    geometryNode,\n    \"altitudeMode\",\n    namespaces.kml,\n  );\n  const gxAltitudeMode = queryStringValue(\n    geometryNode,\n    \"altitudeMode\",\n    namespaces.gx,\n  );\n  const extrude = queryBooleanValue(geometryNode, \"extrude\", namespaces.kml);\n  const tessellate = queryBooleanValue(\n    geometryNode,\n    \"tessellate\",\n    namespaces.kml,\n  );\n  const canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);\n  const zIndex = queryNumericValue(geometryNode, \"drawOrder\", namespaces.gx);\n\n  const ellipsoid = dataSource._ellipsoid;\n  const coordinates = readCoordinates(coordinatesNode, ellipsoid);\n  let polyline = styleEntity.polyline;\n  if (canExtrude && extrude) {\n    const wall = new WallGraphics();\n    entity.wall = wall;\n    wall.positions = coordinates;\n    const polygon = styleEntity.polygon;\n\n    if (defined(polygon)) {\n      wall.fill = polygon.fill;\n      wall.material = polygon.material;\n    }\n\n    //Always outline walls so they show up in 2D.\n    wall.outline = true;\n    if (defined(polyline)) {\n      wall.outlineColor = defined(polyline.material)\n        ? polyline.material.color\n        : Color.WHITE;\n      wall.outlineWidth = polyline.width;\n    } else if (defined(polygon)) {\n      wall.outlineColor = defined(polygon.material)\n        ? polygon.material.color\n        : Color.WHITE;\n    }\n  } else if (dataSource._clampToGround && !canExtrude && tessellate) {\n    const polylineGraphics = new PolylineGraphics();\n    polylineGraphics.clampToGround = true;\n    entity.polyline = polylineGraphics;\n    polylineGraphics.positions = coordinates;\n    if (defined(polyline)) {\n      polylineGraphics.material = defined(polyline.material)\n        ? polyline.material.color.getValue(Iso8601.MINIMUM_VALUE)\n        : Color.WHITE;\n      polylineGraphics.width = polyline.width ?? 1.0;\n    } else {\n      polylineGraphics.material = Color.WHITE;\n      polylineGraphics.width = 1.0;\n    }\n    polylineGraphics.zIndex = zIndex;\n  } else {\n    if (defined(zIndex)) {\n      oneTimeWarning(\n        \"kml-gx:drawOrder\",\n        \"KML - gx:drawOrder is not supported in LineStrings when clampToGround is false\",\n      );\n    }\n    if (dataSource._clampToGround && !tessellate) {\n      oneTimeWarning(\n        \"kml-line-tesselate\",\n        \"Ignoring clampToGround for KML lines without the tessellate flag.\",\n      );\n    }\n\n    polyline = defined(polyline) ? polyline.clone() : new PolylineGraphics();\n    entity.polyline = polyline;\n    polyline.positions = createPositionPropertyArrayFromAltitudeMode(\n      coordinates,\n      altitudeMode,\n      gxAltitudeMode,\n      ellipsoid,\n    );\n    if (!tessellate || canExtrude) {\n      polyline.arcType = ArcType.NONE;\n    }\n  }\n\n  return true;\n}\n\nfunction processPolygon(\n  dataSource,\n  entityCollection,\n  geometryNode,\n  entity,\n  styleEntity,\n) {\n  const outerBoundaryIsNode = queryFirstNode(\n    geometryNode,\n    \"outerBoundaryIs\",\n    namespaces.kml,\n  );\n  let linearRingNode = queryFirstNode(\n    outerBoundaryIsNode,\n    \"LinearRing\",\n    namespaces.kml,\n  );\n  let coordinatesNode = queryFirstNode(\n    linearRingNode,\n    \"coordinates\",\n    namespaces.kml,\n  );\n  const ellipsoid = dataSource._ellipsoid;\n  let coordinates = readCoordinates(coordinatesNode, ellipsoid);\n  const extrude = queryBooleanValue(geometryNode, \"extrude\", namespaces.kml);\n  const altitudeMode = queryStringValue(\n    geometryNode,\n    \"altitudeMode\",\n    namespaces.kml,\n  );\n  const gxAltitudeMode = queryStringValue(\n    geometryNode,\n    \"altitudeMode\",\n    namespaces.gx,\n  );\n  const canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);\n\n  const polygon = defined(styleEntity.polygon)\n    ? styleEntity.polygon.clone()\n    : createDefaultPolygon();\n\n  const polyline = styleEntity.polyline;\n  if (defined(polyline)) {\n    polygon.outlineColor = defined(polyline.material)\n      ? polyline.material.color\n      : Color.WHITE;\n    polygon.outlineWidth = polyline.width;\n  }\n  entity.polygon = polygon;\n\n  if (canExtrude) {\n    polygon.perPositionHeight = true;\n    polygon.extrudedHeight = extrude ? 0 : undefined;\n  } else if (!dataSource._clampToGround) {\n    polygon.height = 0;\n  }\n\n  if (defined(coordinates)) {\n    const hierarchy = new PolygonHierarchy(coordinates);\n    const innerBoundaryIsNodes = queryChildNodes(\n      geometryNode,\n      \"innerBoundaryIs\",\n      namespaces.kml,\n    );\n    for (let j = 0; j < innerBoundaryIsNodes.length; j++) {\n      linearRingNode = queryChildNodes(\n        innerBoundaryIsNodes[j],\n        \"LinearRing\",\n        namespaces.kml,\n      );\n      for (let k = 0; k < linearRingNode.length; k++) {\n        coordinatesNode = queryFirstNode(\n          linearRingNode[k],\n          \"coordinates\",\n          namespaces.kml,\n        );\n        coordinates = readCoordinates(coordinatesNode, ellipsoid);\n        if (defined(coordinates)) {\n          hierarchy.holes.push(new PolygonHierarchy(coordinates));\n        }\n      }\n    }\n    polygon.hierarchy = hierarchy;\n  }\n\n  return true;\n}\n\nfunction processTrack(\n  dataSource,\n  entityCollection,\n  geometryNode,\n  entity,\n  styleEntity,\n) {\n  const altitudeMode = queryStringValue(\n    geometryNode,\n    \"altitudeMode\",\n    namespaces.kml,\n  );\n  const gxAltitudeMode = queryStringValue(\n    geometryNode,\n    \"altitudeMode\",\n    namespaces.gx,\n  );\n  const coordNodes = queryChildNodes(geometryNode, \"coord\", namespaces.gx);\n  const angleNodes = queryChildNodes(geometryNode, \"angles\", namespaces.gx);\n  const timeNodes = queryChildNodes(geometryNode, \"when\", namespaces.kml);\n  const extrude = queryBooleanValue(geometryNode, \"extrude\", namespaces.kml);\n  const canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);\n  const ellipsoid = dataSource._ellipsoid;\n\n  if (angleNodes.length > 0) {\n    oneTimeWarning(\n      \"kml-gx:angles\",\n      \"KML - gx:angles are not supported in gx:Tracks\",\n    );\n  }\n\n  const length = Math.min(coordNodes.length, timeNodes.length);\n  const coordinates = [];\n  const times = [];\n  for (let i = 0; i < length; i++) {\n    const position = readCoordinate(coordNodes[i].textContent, ellipsoid);\n    coordinates.push(position);\n    times.push(JulianDate.fromIso8601(timeNodes[i].textContent));\n  }\n  const property = new SampledPositionProperty();\n  property.addSamples(times, coordinates);\n  entity.position = property;\n  processPositionGraphics(\n    dataSource,\n    entity,\n    styleEntity,\n    heightReferenceFromAltitudeMode(altitudeMode, gxAltitudeMode),\n  );\n  processPathGraphics(entity, styleEntity);\n\n  entity.availability = new TimeIntervalCollection();\n\n  if (timeNodes.length > 0) {\n    entity.availability.addInterval(\n      new TimeInterval({\n        start: times[0],\n        stop: times[times.length - 1],\n      }),\n    );\n  }\n\n  if (canExtrude && extrude) {\n    createDropLine(entityCollection, entity, styleEntity);\n  }\n\n  return true;\n}\n\nfunction addToMultiTrack(\n  times,\n  positions,\n  composite,\n  availability,\n  dropShowProperty,\n  extrude,\n  altitudeMode,\n  gxAltitudeMode,\n  includeEndPoints,\n) {\n  const start = times[0];\n  const stop = times[times.length - 1];\n\n  const data = new SampledPositionProperty();\n  data.addSamples(times, positions);\n\n  composite.intervals.addInterval(\n    new TimeInterval({\n      start: start,\n      stop: stop,\n      isStartIncluded: includeEndPoints,\n      isStopIncluded: includeEndPoints,\n      data: createPositionPropertyFromAltitudeMode(\n        data,\n        altitudeMode,\n        gxAltitudeMode,\n      ),\n    }),\n  );\n  availability.addInterval(\n    new TimeInterval({\n      start: start,\n      stop: stop,\n      isStartIncluded: includeEndPoints,\n      isStopIncluded: includeEndPoints,\n    }),\n  );\n  dropShowProperty.intervals.addInterval(\n    new TimeInterval({\n      start: start,\n      stop: stop,\n      isStartIncluded: includeEndPoints,\n      isStopIncluded: includeEndPoints,\n      data: extrude,\n    }),\n  );\n}\n\nfunction processMultiTrack(\n  dataSource,\n  entityCollection,\n  geometryNode,\n  entity,\n  styleEntity,\n) {\n  // Multitrack options do not work in GE as detailed in the spec,\n  // rather than altitudeMode being at the MultiTrack level,\n  // GE just defers all settings to the underlying track.\n\n  const interpolate = queryBooleanValue(\n    geometryNode,\n    \"interpolate\",\n    namespaces.gx,\n  );\n  const trackNodes = queryChildNodes(geometryNode, \"Track\", namespaces.gx);\n\n  let times;\n  let lastStop;\n  let lastStopPosition;\n  let needDropLine = false;\n  const dropShowProperty = new TimeIntervalCollectionProperty();\n  const availability = new TimeIntervalCollection();\n  const composite = new CompositePositionProperty();\n  const ellipsoid = dataSource._ellipsoid;\n  for (let i = 0, len = trackNodes.length; i < len; i++) {\n    const trackNode = trackNodes[i];\n    const timeNodes = queryChildNodes(trackNode, \"when\", namespaces.kml);\n    const coordNodes = queryChildNodes(trackNode, \"coord\", namespaces.gx);\n    const altitudeMode = queryStringValue(\n      trackNode,\n      \"altitudeMode\",\n      namespaces.kml,\n    );\n    const gxAltitudeMode = queryStringValue(\n      trackNode,\n      \"altitudeMode\",\n      namespaces.gx,\n    );\n    const canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);\n    const extrude = queryBooleanValue(trackNode, \"extrude\", namespaces.kml);\n\n    const length = Math.min(coordNodes.length, timeNodes.length);\n\n    const positions = [];\n    times = [];\n    for (let x = 0; x < length; x++) {\n      const position = readCoordinate(coordNodes[x].textContent, ellipsoid);\n      positions.push(position);\n      times.push(JulianDate.fromIso8601(timeNodes[x].textContent));\n    }\n\n    if (interpolate) {\n      //If we are interpolating, then we need to fill in the end of\n      //the last track and the beginning of this one with a sampled\n      //property.  From testing in Google Earth, this property\n      //is never extruded and always absolute.\n      if (defined(lastStop)) {\n        addToMultiTrack(\n          [lastStop, times[0]],\n          [lastStopPosition, positions[0]],\n          composite,\n          availability,\n          dropShowProperty,\n          false,\n          \"absolute\",\n          undefined,\n          false,\n        );\n      }\n      lastStop = times[length - 1];\n      lastStopPosition = positions[positions.length - 1];\n    }\n\n    addToMultiTrack(\n      times,\n      positions,\n      composite,\n      availability,\n      dropShowProperty,\n      canExtrude && extrude,\n      altitudeMode,\n      gxAltitudeMode,\n      true,\n    );\n    needDropLine = needDropLine || (canExtrude && extrude);\n  }\n\n  entity.availability = availability;\n  entity.position = composite;\n  processPositionGraphics(dataSource, entity, styleEntity);\n  processPathGraphics(entity, styleEntity);\n  if (needDropLine) {\n    createDropLine(entityCollection, entity, styleEntity);\n    entity.polyline.show = dropShowProperty;\n  }\n\n  return true;\n}\n\nconst geometryTypes = {\n  Point: processPoint,\n  LineString: processLineStringOrLinearRing,\n  LinearRing: processLineStringOrLinearRing,\n  Polygon: processPolygon,\n  Track: processTrack,\n  MultiTrack: processMultiTrack,\n  MultiGeometry: processMultiGeometry,\n  Model: processUnsupportedGeometry,\n};\n\nfunction processMultiGeometry(\n  dataSource,\n  entityCollection,\n  geometryNode,\n  entity,\n  styleEntity,\n  context,\n) {\n  const childNodes = geometryNode.childNodes;\n  let hasGeometry = false;\n  for (let i = 0, len = childNodes.length; i < len; i++) {\n    const childNode = childNodes.item(i);\n    const geometryProcessor = geometryTypes[childNode.localName];\n    if (defined(geometryProcessor)) {\n      const childEntity = createEntity(childNode, entityCollection, context);\n      childEntity.parent = entity;\n      childEntity.name = entity.name;\n      childEntity.availability = entity.availability;\n      childEntity.description = entity.description;\n      childEntity.kml = entity.kml;\n      if (\n        geometryProcessor(\n          dataSource,\n          entityCollection,\n          childNode,\n          childEntity,\n          styleEntity,\n        )\n      ) {\n        hasGeometry = true;\n      }\n    }\n  }\n\n  return hasGeometry;\n}\n\nfunction processUnsupportedGeometry(\n  dataSource,\n  entityCollection,\n  geometryNode,\n  entity,\n  styleEntity,\n) {\n  oneTimeWarning(\n    \"kml-unsupportedGeometry\",\n    `KML - Unsupported geometry: ${geometryNode.localName}`,\n  );\n  return false;\n}\n\nfunction processExtendedData(node, entity) {\n  const extendedDataNode = queryFirstNode(node, \"ExtendedData\", namespaces.kml);\n\n  if (!defined(extendedDataNode)) {\n    return undefined;\n  }\n\n  if (defined(queryFirstNode(extendedDataNode, \"SchemaData\", namespaces.kml))) {\n    oneTimeWarning(\"kml-schemaData\", \"KML - SchemaData is unsupported\");\n  }\n  if (defined(queryStringAttribute(extendedDataNode, \"xmlns:prefix\"))) {\n    oneTimeWarning(\n      \"kml-extendedData\",\n      \"KML - ExtendedData with xmlns:prefix is unsupported\",\n    );\n  }\n\n  const result = {};\n  const dataNodes = queryChildNodes(extendedDataNode, \"Data\", namespaces.kml);\n  if (defined(dataNodes)) {\n    const length = dataNodes.length;\n    for (let i = 0; i < length; i++) {\n      const dataNode = dataNodes[i];\n      const name = queryStringAttribute(dataNode, \"name\");\n      if (defined(name)) {\n        result[name] = {\n          displayName: queryStringValue(\n            dataNode,\n            \"displayName\",\n            namespaces.kml,\n          ),\n          value: queryStringValue(dataNode, \"value\", namespaces.kml),\n        };\n      }\n    }\n  }\n  entity.kml.extendedData = result;\n}\n\nlet scratchDiv;\nif (typeof document !== \"undefined\") {\n  scratchDiv = document.createElement(\"div\");\n}\n\nfunction processDescription(\n  node,\n  entity,\n  styleEntity,\n  uriResolver,\n  sourceResource,\n) {\n  let i;\n  let key;\n  let keys;\n\n  const kmlData = entity.kml;\n  const extendedData = kmlData.extendedData;\n  const description = queryStringValue(node, \"description\", namespaces.kml);\n\n  const balloonStyle = entity.balloonStyle ?? styleEntity.balloonStyle;\n\n  let background = Color.WHITE;\n  let foreground = Color.BLACK;\n  let text = description;\n\n  if (defined(balloonStyle)) {\n    background = balloonStyle.bgColor ?? Color.WHITE;\n    foreground = balloonStyle.textColor ?? Color.BLACK;\n    text = balloonStyle.text ?? description;\n  }\n\n  let value;\n  if (defined(text)) {\n    text = text.replace(\"$[name]\", entity.name ?? \"\");\n    text = text.replace(\"$[description]\", description ?? \"\");\n    text = text.replace(\"$[address]\", kmlData.address ?? \"\");\n    text = text.replace(\"$[Snippet]\", kmlData.snippet ?? \"\");\n    text = text.replace(\"$[id]\", entity.id);\n\n    //While not explicitly defined by the OGC spec, in Google Earth\n    //The appearance of geDirections adds the directions to/from links\n    //We simply replace this string with nothing.\n    text = text.replace(\"$[geDirections]\", \"\");\n\n    if (defined(extendedData)) {\n      const matches = text.match(/\\$\\[.+?\\]/g);\n      if (matches !== null) {\n        for (i = 0; i < matches.length; i++) {\n          const token = matches[i];\n          let propertyName = token.substr(2, token.length - 3);\n          const isDisplayName = /\\/displayName$/.test(propertyName);\n          propertyName = propertyName.replace(/\\/displayName$/, \"\");\n\n          value = extendedData[propertyName];\n          if (defined(value)) {\n            value = isDisplayName ? value.displayName : value.value;\n          }\n          if (defined(value)) {\n            text = text.replace(token, value ?? \"\");\n          }\n        }\n      }\n    }\n  } else if (defined(extendedData)) {\n    //If no description exists, build a table out of the extended data\n    keys = Object.keys(extendedData);\n    if (keys.length > 0) {\n      text =\n        '<table class=\"cesium-infoBox-defaultTable cesium-infoBox-defaultTable-lighter\"><tbody>';\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n        value = extendedData[key];\n        text += `<tr><th>${value.displayName ?? key}</th><td>${value.value ?? \"\"}</td></tr>`;\n      }\n      text += \"</tbody></table>\";\n    }\n  }\n\n  if (!defined(text)) {\n    //No description\n    return;\n  }\n\n  //Turns non-explicit links into clickable links.\n  text = autolinker.link(text);\n\n  //Use a temporary div to manipulate the links\n  //so that they open in a new window.\n  scratchDiv.innerHTML = text;\n  const links = scratchDiv.querySelectorAll(\"a\");\n  for (i = 0; i < links.length; i++) {\n    links[i].setAttribute(\"target\", \"_blank\");\n  }\n\n  //Rewrite any KMZ embedded urls\n  if (defined(uriResolver) && uriResolver.keys.length > 1) {\n    embedDataUris(scratchDiv, \"a\", \"href\", uriResolver);\n    embedDataUris(scratchDiv, \"link\", \"href\", uriResolver);\n    embedDataUris(scratchDiv, \"area\", \"href\", uriResolver);\n    embedDataUris(scratchDiv, \"img\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"iframe\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"video\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"audio\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"source\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"track\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"input\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"embed\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"script\", \"src\", uriResolver);\n    embedDataUris(scratchDiv, \"video\", \"poster\", uriResolver);\n  }\n\n  //Make relative urls absolute using the sourceResource\n  applyBasePath(scratchDiv, \"a\", \"href\", sourceResource);\n  applyBasePath(scratchDiv, \"link\", \"href\", sourceResource);\n  applyBasePath(scratchDiv, \"area\", \"href\", sourceResource);\n  applyBasePath(scratchDiv, \"img\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"iframe\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"video\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"audio\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"source\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"track\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"input\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"embed\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"script\", \"src\", sourceResource);\n  applyBasePath(scratchDiv, \"video\", \"poster\", sourceResource);\n\n  let tmp = '<div class=\"cesium-infoBox-description-lighter\" style=\"';\n  tmp += \"overflow:auto;\";\n  tmp += \"word-wrap:break-word;\";\n  tmp += `background-color:${background.toCssColorString()};`;\n  tmp += `color:${foreground.toCssColorString()};`;\n  tmp += '\">';\n  tmp += `${scratchDiv.innerHTML}</div>`;\n  scratchDiv.innerHTML = \"\";\n\n  //Set the final HTML as the description.\n  entity.description = tmp;\n}\n\nfunction processFeature(dataSource, featureNode, processingData) {\n  const entityCollection = processingData.entityCollection;\n  const parent = processingData.parentEntity;\n  const sourceResource = processingData.sourceResource;\n  const uriResolver = processingData.uriResolver;\n\n  const entity = createEntity(\n    featureNode,\n    entityCollection,\n    processingData.context,\n  );\n  const kmlData = entity.kml;\n  const styleEntity = computeFinalStyle(\n    dataSource,\n    featureNode,\n    processingData.styleCollection,\n    sourceResource,\n    uriResolver,\n  );\n\n  const name = queryStringValue(featureNode, \"name\", namespaces.kml);\n  entity.name = name;\n  entity.parent = parent;\n\n  let availability = processTimeSpan(featureNode);\n  if (!defined(availability)) {\n    availability = processTimeStamp(featureNode);\n  }\n  entity.availability = availability;\n\n  mergeAvailabilityWithParent(entity);\n\n  // Per KML spec \"A Feature is visible only if it and all its ancestors are visible.\"\n  function ancestryIsVisible(parentEntity) {\n    if (!parentEntity) {\n      return true;\n    }\n    return parentEntity.show && ancestryIsVisible(parentEntity.parent);\n  }\n\n  const visibility = queryBooleanValue(\n    featureNode,\n    \"visibility\",\n    namespaces.kml,\n  );\n  entity.show = ancestryIsVisible(parent) && (visibility ?? true);\n  //const open = queryBooleanValue(featureNode, 'open', namespaces.kml);\n\n  const authorNode = queryFirstNode(featureNode, \"author\", namespaces.atom);\n  const author = kmlData.author;\n  author.name = queryStringValue(authorNode, \"name\", namespaces.atom);\n  author.uri = queryStringValue(authorNode, \"uri\", namespaces.atom);\n  author.email = queryStringValue(authorNode, \"email\", namespaces.atom);\n\n  const linkNode = queryFirstNode(featureNode, \"link\", namespaces.atom);\n  const link = kmlData.link;\n  link.href = queryStringAttribute(linkNode, \"href\");\n  link.hreflang = queryStringAttribute(linkNode, \"hreflang\");\n  link.rel = queryStringAttribute(linkNode, \"rel\");\n  link.type = queryStringAttribute(linkNode, \"type\");\n  link.title = queryStringAttribute(linkNode, \"title\");\n  link.length = queryStringAttribute(linkNode, \"length\");\n\n  kmlData.address = queryStringValue(featureNode, \"address\", namespaces.kml);\n  kmlData.phoneNumber = queryStringValue(\n    featureNode,\n    \"phoneNumber\",\n    namespaces.kml,\n  );\n  kmlData.snippet = queryStringValue(featureNode, \"Snippet\", namespaces.kml);\n\n  processExtendedData(featureNode, entity);\n  processDescription(\n    featureNode,\n    entity,\n    styleEntity,\n    uriResolver,\n    sourceResource,\n  );\n\n  const ellipsoid = dataSource._ellipsoid;\n  processLookAt(featureNode, entity, ellipsoid);\n  processCamera(featureNode, entity, ellipsoid);\n\n  if (defined(queryFirstNode(featureNode, \"Region\", namespaces.kml))) {\n    oneTimeWarning(\"kml-region\", \"KML - Placemark Regions are unsupported\");\n  }\n\n  return {\n    entity: entity,\n    styleEntity: styleEntity,\n  };\n}\n\nfunction processDocument(dataSource, node, processingData, deferredLoading) {\n  deferredLoading.addNodes(node.childNodes, processingData);\n  deferredLoading.process();\n}\n\nfunction processFolder(dataSource, node, processingData, deferredLoading) {\n  const r = processFeature(dataSource, node, processingData);\n  const newProcessingData = clone(processingData);\n  newProcessingData.parentEntity = r.entity;\n  processDocument(dataSource, node, newProcessingData, deferredLoading);\n}\n\nfunction processPlacemark(\n  dataSource,\n  placemark,\n  processingData,\n  deferredLoading,\n) {\n  const r = processFeature(dataSource, placemark, processingData);\n  const entity = r.entity;\n  const styleEntity = r.styleEntity;\n\n  let hasGeometry = false;\n  const childNodes = placemark.childNodes;\n  for (let i = 0, len = childNodes.length; i < len && !hasGeometry; i++) {\n    const childNode = childNodes.item(i);\n    const geometryProcessor = geometryTypes[childNode.localName];\n    if (defined(geometryProcessor)) {\n      // pass the placemark entity id as a context for case of defining multiple child entities together to handle case\n      // where some malformed kmls reuse the same id across placemarks, which works in GE, but is not technically to spec.\n      geometryProcessor(\n        dataSource,\n        processingData.entityCollection,\n        childNode,\n        entity,\n        styleEntity,\n        entity.id,\n      );\n      hasGeometry = true;\n    }\n  }\n\n  if (!hasGeometry) {\n    entity.merge(styleEntity);\n    processPositionGraphics(dataSource, entity, styleEntity);\n  }\n}\n\nconst playlistNodeProcessors = {\n  FlyTo: processTourFlyTo,\n  Wait: processTourWait,\n  SoundCue: processTourUnsupportedNode,\n  AnimatedUpdate: processTourUnsupportedNode,\n  TourControl: processTourUnsupportedNode,\n};\n\nfunction processTour(dataSource, node, processingData, deferredLoading) {\n  const name = queryStringValue(node, \"name\", namespaces.kml);\n  const id = queryStringAttribute(node, \"id\");\n  const tour = new KmlTour(name, id);\n\n  const playlistNode = queryFirstNode(node, \"Playlist\", namespaces.gx);\n  if (playlistNode) {\n    const ellipsoid = dataSource._ellipsoid;\n    const childNodes = playlistNode.childNodes;\n    for (let i = 0; i < childNodes.length; i++) {\n      const entryNode = childNodes[i];\n      if (entryNode.localName) {\n        const playlistNodeProcessor =\n          playlistNodeProcessors[entryNode.localName];\n        if (playlistNodeProcessor) {\n          playlistNodeProcessor(tour, entryNode, ellipsoid);\n        } else {\n          console.log(\n            `Unknown KML Tour playlist entry type ${entryNode.localName}`,\n          );\n        }\n      }\n    }\n  }\n\n  dataSource._kmlTours.push(tour);\n}\n\nfunction processTourUnsupportedNode(tour, entryNode) {\n  oneTimeWarning(`KML Tour unsupported node ${entryNode.localName}`);\n}\n\nfunction processTourWait(tour, entryNode) {\n  const duration = queryNumericValue(entryNode, \"duration\", namespaces.gx);\n  tour.addPlaylistEntry(new KmlTourWait(duration));\n}\n\nfunction processTourFlyTo(tour, entryNode, ellipsoid) {\n  const duration = queryNumericValue(entryNode, \"duration\", namespaces.gx);\n  const flyToMode = queryStringValue(entryNode, \"flyToMode\", namespaces.gx);\n\n  const t = { kml: {} };\n\n  processLookAt(entryNode, t, ellipsoid);\n  processCamera(entryNode, t, ellipsoid);\n\n  const view = t.kml.lookAt || t.kml.camera;\n\n  const flyto = new KmlTourFlyTo(duration, flyToMode, view);\n  tour.addPlaylistEntry(flyto);\n}\n\nfunction processCamera(featureNode, entity, ellipsoid) {\n  const camera = queryFirstNode(featureNode, \"Camera\", namespaces.kml);\n  if (defined(camera)) {\n    const lon = queryNumericValue(camera, \"longitude\", namespaces.kml) ?? 0.0;\n    const lat = queryNumericValue(camera, \"latitude\", namespaces.kml) ?? 0.0;\n    const altitude =\n      queryNumericValue(camera, \"altitude\", namespaces.kml) ?? 0.0;\n\n    const heading = queryNumericValue(camera, \"heading\", namespaces.kml) ?? 0.0;\n    const tilt = queryNumericValue(camera, \"tilt\", namespaces.kml) ?? 0.0;\n    const roll = queryNumericValue(camera, \"roll\", namespaces.kml) ?? 0.0;\n\n    const position = Cartesian3.fromDegrees(lon, lat, altitude, ellipsoid);\n    const hpr = HeadingPitchRoll.fromDegrees(heading, tilt - 90.0, roll);\n\n    entity.kml.camera = new KmlCamera(position, hpr);\n  }\n}\n\nfunction processLookAt(featureNode, entity, ellipsoid) {\n  const lookAt = queryFirstNode(featureNode, \"LookAt\", namespaces.kml);\n  if (defined(lookAt)) {\n    const lon = queryNumericValue(lookAt, \"longitude\", namespaces.kml) ?? 0.0;\n    const lat = queryNumericValue(lookAt, \"latitude\", namespaces.kml) ?? 0.0;\n    const altitude =\n      queryNumericValue(lookAt, \"altitude\", namespaces.kml) ?? 0.0;\n    let heading = queryNumericValue(lookAt, \"heading\", namespaces.kml);\n    let tilt = queryNumericValue(lookAt, \"tilt\", namespaces.kml);\n    const range = queryNumericValue(lookAt, \"range\", namespaces.kml) ?? 0.0;\n\n    tilt = CesiumMath.toRadians(tilt ?? 0.0);\n    heading = CesiumMath.toRadians(heading ?? 0.0);\n\n    const hpr = new HeadingPitchRange(\n      heading,\n      tilt - CesiumMath.PI_OVER_TWO,\n      range,\n    );\n    const viewPoint = Cartesian3.fromDegrees(lon, lat, altitude, ellipsoid);\n\n    entity.kml.lookAt = new KmlLookAt(viewPoint, hpr);\n  }\n}\n\nfunction processScreenOverlay(\n  dataSource,\n  screenOverlayNode,\n  processingData,\n  deferredLoading,\n) {\n  const screenOverlay = processingData.screenOverlayContainer;\n  if (!defined(screenOverlay)) {\n    return undefined;\n  }\n\n  const sourceResource = processingData.sourceResource;\n  const uriResolver = processingData.uriResolver;\n\n  const iconNode = queryFirstNode(screenOverlayNode, \"Icon\", namespaces.kml);\n  const icon = getIconHref(\n    iconNode,\n    dataSource,\n    sourceResource,\n    uriResolver,\n    false,\n  );\n\n  if (!defined(icon)) {\n    return undefined;\n  }\n\n  const img = document.createElement(\"img\");\n  dataSource._screenOverlays.push(img);\n\n  img.src = icon.url;\n  img.onload = function () {\n    const styles = [\"position: absolute\"];\n\n    const screenXY = queryFirstNode(\n      screenOverlayNode,\n      \"screenXY\",\n      namespaces.kml,\n    );\n    const overlayXY = queryFirstNode(\n      screenOverlayNode,\n      \"overlayXY\",\n      namespaces.kml,\n    );\n    const size = queryFirstNode(screenOverlayNode, \"size\", namespaces.kml);\n\n    let x, y;\n    let xUnit, yUnit;\n    let xStyle, yStyle;\n\n    if (defined(size)) {\n      x = queryNumericAttribute(size, \"x\");\n      y = queryNumericAttribute(size, \"y\");\n      xUnit = queryStringAttribute(size, \"xunits\");\n      yUnit = queryStringAttribute(size, \"yunits\");\n\n      if (defined(x) && x !== -1 && x !== 0) {\n        if (xUnit === \"fraction\") {\n          xStyle = `width: ${Math.floor(x * 100)}%`;\n        } else if (xUnit === \"pixels\") {\n          xStyle = `width: ${x}px`;\n        }\n\n        styles.push(xStyle);\n      }\n\n      if (defined(y) && y !== -1 && y !== 0) {\n        if (yUnit === \"fraction\") {\n          yStyle = `height: ${Math.floor(y * 100)}%`;\n        } else if (yUnit === \"pixels\") {\n          yStyle = `height: ${y}px`;\n        }\n\n        styles.push(yStyle);\n      }\n    }\n\n    // set the interim style so the width/height properties get calculated\n    img.style = styles.join(\";\");\n\n    let xOrigin = 0;\n    let yOrigin = img.height;\n\n    if (defined(overlayXY)) {\n      x = queryNumericAttribute(overlayXY, \"x\");\n      y = queryNumericAttribute(overlayXY, \"y\");\n      xUnit = queryStringAttribute(overlayXY, \"xunits\");\n      yUnit = queryStringAttribute(overlayXY, \"yunits\");\n\n      if (defined(x)) {\n        if (xUnit === \"fraction\") {\n          xOrigin = x * img.width;\n        } else if (xUnit === \"pixels\") {\n          xOrigin = x;\n        } else if (xUnit === \"insetPixels\") {\n          xOrigin = x;\n        }\n      }\n\n      if (defined(y)) {\n        if (yUnit === \"fraction\") {\n          yOrigin = y * img.height;\n        } else if (yUnit === \"pixels\") {\n          yOrigin = y;\n        } else if (yUnit === \"insetPixels\") {\n          yOrigin = y;\n        }\n      }\n    }\n\n    if (defined(screenXY)) {\n      x = queryNumericAttribute(screenXY, \"x\");\n      y = queryNumericAttribute(screenXY, \"y\");\n      xUnit = queryStringAttribute(screenXY, \"xunits\");\n      yUnit = queryStringAttribute(screenXY, \"yunits\");\n\n      if (defined(x)) {\n        if (xUnit === \"fraction\") {\n          xStyle = `${\"left: \" + \"calc(\"}${Math.floor(\n            x * 100,\n          )}% - ${xOrigin}px)`;\n        } else if (xUnit === \"pixels\") {\n          xStyle = `left: ${x - xOrigin}px`;\n        } else if (xUnit === \"insetPixels\") {\n          xStyle = `right: ${x - xOrigin}px`;\n        }\n\n        styles.push(xStyle);\n      }\n\n      if (defined(y)) {\n        if (yUnit === \"fraction\") {\n          yStyle = `${\"bottom: \" + \"calc(\"}${Math.floor(\n            y * 100,\n          )}% - ${yOrigin}px)`;\n        } else if (yUnit === \"pixels\") {\n          yStyle = `bottom: ${y - yOrigin}px`;\n        } else if (yUnit === \"insetPixels\") {\n          yStyle = `top: ${y - yOrigin}px`;\n        }\n\n        styles.push(yStyle);\n      }\n    }\n\n    img.style = styles.join(\";\");\n  };\n\n  screenOverlay.appendChild(img);\n}\n\nfunction processGroundOverlay(\n  dataSource,\n  groundOverlay,\n  processingData,\n  deferredLoading,\n) {\n  const r = processFeature(dataSource, groundOverlay, processingData);\n  const entity = r.entity;\n\n  let geometry;\n  let isLatLonQuad = false;\n\n  const ellipsoid = dataSource._ellipsoid;\n  const positions = readCoordinates(\n    queryFirstNode(groundOverlay, \"LatLonQuad\", namespaces.gx),\n    ellipsoid,\n  );\n  const zIndex = queryNumericValue(groundOverlay, \"drawOrder\", namespaces.kml);\n  if (defined(positions)) {\n    geometry = createDefaultPolygon();\n    geometry.hierarchy = new PolygonHierarchy(positions);\n    geometry.zIndex = zIndex;\n    entity.polygon = geometry;\n    isLatLonQuad = true;\n  } else {\n    geometry = new RectangleGraphics();\n    geometry.zIndex = zIndex;\n    entity.rectangle = geometry;\n\n    const latLonBox = queryFirstNode(\n      groundOverlay,\n      \"LatLonBox\",\n      namespaces.kml,\n    );\n    if (defined(latLonBox)) {\n      let west = queryNumericValue(latLonBox, \"west\", namespaces.kml);\n      let south = queryNumericValue(latLonBox, \"south\", namespaces.kml);\n      let east = queryNumericValue(latLonBox, \"east\", namespaces.kml);\n      let north = queryNumericValue(latLonBox, \"north\", namespaces.kml);\n\n      if (defined(west)) {\n        west = CesiumMath.negativePiToPi(CesiumMath.toRadians(west));\n      }\n      if (defined(south)) {\n        south = CesiumMath.clampToLatitudeRange(CesiumMath.toRadians(south));\n      }\n      if (defined(east)) {\n        east = CesiumMath.negativePiToPi(CesiumMath.toRadians(east));\n      }\n      if (defined(north)) {\n        north = CesiumMath.clampToLatitudeRange(CesiumMath.toRadians(north));\n      }\n      geometry.coordinates = new Rectangle(west, south, east, north);\n\n      const rotation = queryNumericValue(latLonBox, \"rotation\", namespaces.kml);\n      if (defined(rotation)) {\n        const rotationRadians = CesiumMath.toRadians(rotation);\n        geometry.rotation = rotationRadians;\n        geometry.stRotation = rotationRadians;\n      }\n    }\n  }\n\n  const iconNode = queryFirstNode(groundOverlay, \"Icon\", namespaces.kml);\n  const href = getIconHref(\n    iconNode,\n    dataSource,\n    processingData.sourceResource,\n    processingData.uriResolver,\n    true,\n  );\n  if (defined(href)) {\n    if (isLatLonQuad) {\n      oneTimeWarning(\n        \"kml-gx:LatLonQuad\",\n        \"KML - gx:LatLonQuad Icon does not support texture projection.\",\n      );\n    }\n    const x = queryNumericValue(iconNode, \"x\", namespaces.gx);\n    const y = queryNumericValue(iconNode, \"y\", namespaces.gx);\n    const w = queryNumericValue(iconNode, \"w\", namespaces.gx);\n    const h = queryNumericValue(iconNode, \"h\", namespaces.gx);\n\n    if (defined(x) || defined(y) || defined(w) || defined(h)) {\n      oneTimeWarning(\n        \"kml-groundOverlay-xywh\",\n        \"KML - gx:x, gx:y, gx:w, gx:h aren't supported for GroundOverlays\",\n      );\n    }\n\n    geometry.material = href;\n    geometry.material.color = queryColorValue(\n      groundOverlay,\n      \"color\",\n      namespaces.kml,\n    );\n    geometry.material.transparent = true;\n  } else {\n    geometry.material = queryColorValue(groundOverlay, \"color\", namespaces.kml);\n  }\n\n  let altitudeMode = queryStringValue(\n    groundOverlay,\n    \"altitudeMode\",\n    namespaces.kml,\n  );\n\n  if (defined(altitudeMode)) {\n    if (altitudeMode === \"absolute\") {\n      //Use height above ellipsoid until we support MSL.\n      geometry.height = queryNumericValue(\n        groundOverlay,\n        \"altitude\",\n        namespaces.kml,\n      );\n      geometry.zIndex = undefined;\n    } else if (altitudeMode !== \"clampToGround\") {\n      oneTimeWarning(\n        \"kml-altitudeMode-unknown\",\n        `KML - Unknown altitudeMode: ${altitudeMode}`,\n      );\n    }\n    // else just use the default of 0 until we support 'clampToGround'\n  } else {\n    altitudeMode = queryStringValue(\n      groundOverlay,\n      \"altitudeMode\",\n      namespaces.gx,\n    );\n    if (altitudeMode === \"relativeToSeaFloor\") {\n      oneTimeWarning(\n        \"kml-altitudeMode-relativeToSeaFloor\",\n        \"KML - altitudeMode relativeToSeaFloor is currently not supported, treating as absolute.\",\n      );\n      geometry.height = queryNumericValue(\n        groundOverlay,\n        \"altitude\",\n        namespaces.kml,\n      );\n      geometry.zIndex = undefined;\n    } else if (altitudeMode === \"clampToSeaFloor\") {\n      oneTimeWarning(\n        \"kml-altitudeMode-clampToSeaFloor\",\n        \"KML - altitudeMode clampToSeaFloor is currently not supported, treating as clampToGround.\",\n      );\n    } else if (defined(altitudeMode)) {\n      oneTimeWarning(\n        \"kml-altitudeMode-unknown\",\n        `KML - Unknown altitudeMode: ${altitudeMode}`,\n      );\n    }\n  }\n}\n\nfunction processUnsupportedFeature(\n  dataSource,\n  node,\n  processingData,\n  deferredLoading,\n) {\n  dataSource._unsupportedNode.raiseEvent(\n    dataSource,\n    processingData.parentEntity,\n    node,\n    processingData.entityCollection,\n    processingData.styleCollection,\n    processingData.sourceResource,\n    processingData.uriResolver,\n  );\n  oneTimeWarning(\n    `kml-unsupportedFeature-${node.nodeName}`,\n    `KML - Unsupported feature: ${node.nodeName}`,\n  );\n}\n\nconst RefreshMode = {\n  INTERVAL: 0,\n  EXPIRE: 1,\n  STOP: 2,\n};\n\nfunction cleanupString(s) {\n  if (!defined(s) || s.length === 0) {\n    return \"\";\n  }\n\n  const sFirst = s[0];\n  if (sFirst === \"&\" || sFirst === \"?\") {\n    s = s.substring(1);\n  }\n\n  return s;\n}\n\nconst zeroRectangle = new Rectangle();\nconst scratchCartographic = new Cartographic();\nconst scratchCartesian2 = new Cartesian2();\nconst scratchCartesian3 = new Cartesian3();\n\nfunction processNetworkLinkQueryString(\n  resource,\n  camera,\n  canvas,\n  viewBoundScale,\n  bbox,\n  ellipsoid,\n) {\n  function fixLatitude(value) {\n    if (value < -CesiumMath.PI_OVER_TWO) {\n      return -CesiumMath.PI_OVER_TWO;\n    } else if (value > CesiumMath.PI_OVER_TWO) {\n      return CesiumMath.PI_OVER_TWO;\n    }\n    return value;\n  }\n\n  function fixLongitude(value) {\n    if (value > CesiumMath.PI) {\n      return value - CesiumMath.TWO_PI;\n    } else if (value < -CesiumMath.PI) {\n      return value + CesiumMath.TWO_PI;\n    }\n\n    return value;\n  }\n\n  let queryString = objectToQuery(resource.queryParameters);\n\n  // objectToQuery escapes [ and ], so fix that\n  queryString = queryString.replace(/%5B/g, \"[\").replace(/%5D/g, \"]\");\n\n  if (defined(camera) && camera._mode !== SceneMode.MORPHING) {\n    let centerCartesian;\n    let centerCartographic;\n\n    bbox = bbox ?? zeroRectangle;\n    if (defined(canvas)) {\n      scratchCartesian2.x = canvas.clientWidth * 0.5;\n      scratchCartesian2.y = canvas.clientHeight * 0.5;\n      centerCartesian = camera.pickEllipsoid(\n        scratchCartesian2,\n        ellipsoid,\n        scratchCartesian3,\n      );\n    }\n\n    if (defined(centerCartesian)) {\n      centerCartographic = ellipsoid.cartesianToCartographic(\n        centerCartesian,\n        scratchCartographic,\n      );\n    } else {\n      centerCartographic = Rectangle.center(bbox, scratchCartographic);\n      centerCartesian = ellipsoid.cartographicToCartesian(centerCartographic);\n    }\n\n    if (\n      defined(viewBoundScale) &&\n      !CesiumMath.equalsEpsilon(viewBoundScale, 1.0, CesiumMath.EPSILON9)\n    ) {\n      const newHalfWidth = bbox.width * viewBoundScale * 0.5;\n      const newHalfHeight = bbox.height * viewBoundScale * 0.5;\n      bbox = new Rectangle(\n        fixLongitude(centerCartographic.longitude - newHalfWidth),\n        fixLatitude(centerCartographic.latitude - newHalfHeight),\n        fixLongitude(centerCartographic.longitude + newHalfWidth),\n        fixLatitude(centerCartographic.latitude + newHalfHeight),\n      );\n    }\n\n    queryString = queryString.replace(\n      \"[bboxWest]\",\n      CesiumMath.toDegrees(bbox.west).toString(),\n    );\n    queryString = queryString.replace(\n      \"[bboxSouth]\",\n      CesiumMath.toDegrees(bbox.south).toString(),\n    );\n    queryString = queryString.replace(\n      \"[bboxEast]\",\n      CesiumMath.toDegrees(bbox.east).toString(),\n    );\n    queryString = queryString.replace(\n      \"[bboxNorth]\",\n      CesiumMath.toDegrees(bbox.north).toString(),\n    );\n\n    const lon = CesiumMath.toDegrees(centerCartographic.longitude).toString();\n    const lat = CesiumMath.toDegrees(centerCartographic.latitude).toString();\n    queryString = queryString.replace(\"[lookatLon]\", lon);\n    queryString = queryString.replace(\"[lookatLat]\", lat);\n    queryString = queryString.replace(\n      \"[lookatTilt]\",\n      CesiumMath.toDegrees(camera.pitch).toString(),\n    );\n    queryString = queryString.replace(\n      \"[lookatHeading]\",\n      CesiumMath.toDegrees(camera.heading).toString(),\n    );\n    queryString = queryString.replace(\n      \"[lookatRange]\",\n      Cartesian3.distance(camera.positionWC, centerCartesian),\n    );\n    queryString = queryString.replace(\"[lookatTerrainLon]\", lon);\n    queryString = queryString.replace(\"[lookatTerrainLat]\", lat);\n    queryString = queryString.replace(\n      \"[lookatTerrainAlt]\",\n      centerCartographic.height.toString(),\n    );\n\n    ellipsoid.cartesianToCartographic(camera.positionWC, scratchCartographic);\n    queryString = queryString.replace(\n      \"[cameraLon]\",\n      CesiumMath.toDegrees(scratchCartographic.longitude).toString(),\n    );\n    queryString = queryString.replace(\n      \"[cameraLat]\",\n      CesiumMath.toDegrees(scratchCartographic.latitude).toString(),\n    );\n    queryString = queryString.replace(\n      \"[cameraAlt]\",\n      CesiumMath.toDegrees(scratchCartographic.height).toString(),\n    );\n\n    const frustum = camera.frustum;\n    const aspectRatio = frustum.aspectRatio;\n    let horizFov = \"\";\n    let vertFov = \"\";\n    if (defined(aspectRatio)) {\n      const fov = CesiumMath.toDegrees(frustum.fov);\n      if (aspectRatio > 1.0) {\n        horizFov = fov;\n        vertFov = fov / aspectRatio;\n      } else {\n        vertFov = fov;\n        horizFov = fov * aspectRatio;\n      }\n    }\n    queryString = queryString.replace(\"[horizFov]\", horizFov.toString());\n    queryString = queryString.replace(\"[vertFov]\", vertFov.toString());\n  } else {\n    queryString = queryString.replace(\"[bboxWest]\", \"-180\");\n    queryString = queryString.replace(\"[bboxSouth]\", \"-90\");\n    queryString = queryString.replace(\"[bboxEast]\", \"180\");\n    queryString = queryString.replace(\"[bboxNorth]\", \"90\");\n\n    queryString = queryString.replace(\"[lookatLon]\", \"\");\n    queryString = queryString.replace(\"[lookatLat]\", \"\");\n    queryString = queryString.replace(\"[lookatRange]\", \"\");\n    queryString = queryString.replace(\"[lookatTilt]\", \"\");\n    queryString = queryString.replace(\"[lookatHeading]\", \"\");\n    queryString = queryString.replace(\"[lookatTerrainLon]\", \"\");\n    queryString = queryString.replace(\"[lookatTerrainLat]\", \"\");\n    queryString = queryString.replace(\"[lookatTerrainAlt]\", \"\");\n\n    queryString = queryString.replace(\"[cameraLon]\", \"\");\n    queryString = queryString.replace(\"[cameraLat]\", \"\");\n    queryString = queryString.replace(\"[cameraAlt]\", \"\");\n    queryString = queryString.replace(\"[horizFov]\", \"\");\n    queryString = queryString.replace(\"[vertFov]\", \"\");\n  }\n\n  if (defined(canvas)) {\n    queryString = queryString.replace(\"[horizPixels]\", canvas.clientWidth);\n    queryString = queryString.replace(\"[vertPixels]\", canvas.clientHeight);\n  } else {\n    queryString = queryString.replace(\"[horizPixels]\", \"\");\n    queryString = queryString.replace(\"[vertPixels]\", \"\");\n  }\n\n  queryString = queryString.replace(\"[terrainEnabled]\", \"1\");\n  queryString = queryString.replace(\"[clientVersion]\", \"1\");\n  queryString = queryString.replace(\"[kmlVersion]\", \"2.2\");\n  queryString = queryString.replace(\"[clientName]\", \"Cesium\");\n  queryString = queryString.replace(\"[language]\", \"English\");\n\n  resource.setQueryParameters(queryToObject(queryString));\n}\n\nfunction processNetworkLink(dataSource, node, processingData, deferredLoading) {\n  const r = processFeature(dataSource, node, processingData);\n  const networkEntity = r.entity;\n\n  const sourceResource = processingData.sourceResource;\n  const uriResolver = processingData.uriResolver;\n\n  let link = queryFirstNode(node, \"Link\", namespaces.kml);\n\n  if (!defined(link)) {\n    link = queryFirstNode(node, \"Url\", namespaces.kml);\n  }\n  if (defined(link)) {\n    let href = queryStringValue(link, \"href\", namespaces.kml);\n    let viewRefreshMode;\n    let viewBoundScale;\n    if (defined(href)) {\n      let newSourceUri = href;\n      href = resolveHref(href, sourceResource, processingData.uriResolver);\n\n      // We need to pass in the original path if resolveHref returns a data uri because the network link\n      //  references a document in a KMZ archive\n      if (/^data:/.test(href.getUrlComponent())) {\n        // So if sourceUri isn't the kmz file, then its another kml in the archive, so resolve it\n        if (!/\\.kmz/i.test(sourceResource.getUrlComponent())) {\n          newSourceUri = sourceResource.getDerivedResource({\n            url: newSourceUri,\n          });\n        }\n      } else {\n        newSourceUri = href.clone(); // Not a data uri so use the fully qualified uri\n        viewRefreshMode = queryStringValue(\n          link,\n          \"viewRefreshMode\",\n          namespaces.kml,\n        );\n        if (viewRefreshMode === \"onRegion\") {\n          oneTimeWarning(\n            \"kml-refrehMode-onRegion\",\n            \"KML - Unsupported viewRefreshMode: onRegion\",\n          );\n          return;\n        }\n        viewBoundScale =\n          queryStringValue(link, \"viewBoundScale\", namespaces.kml) ?? 1.0;\n        const defaultViewFormat =\n          viewRefreshMode === \"onStop\"\n            ? \"BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]\"\n            : \"\";\n        const viewFormat =\n          queryStringValue(link, \"viewFormat\", namespaces.kml) ??\n          defaultViewFormat;\n        const httpQuery = queryStringValue(link, \"httpQuery\", namespaces.kml);\n        if (defined(viewFormat)) {\n          href.setQueryParameters(queryToObject(cleanupString(viewFormat)));\n        }\n        if (defined(httpQuery)) {\n          href.setQueryParameters(queryToObject(cleanupString(httpQuery)));\n        }\n\n        const ellipsoid = dataSource._ellipsoid;\n        processNetworkLinkQueryString(\n          href,\n          dataSource.camera,\n          dataSource.canvas,\n          viewBoundScale,\n          dataSource._lastCameraView.bbox,\n          ellipsoid,\n        );\n      }\n\n      const options = {\n        sourceUri: newSourceUri,\n        uriResolver: uriResolver,\n        context: networkEntity.id,\n        screenOverlayContainer: processingData.screenOverlayContainer,\n      };\n      const networkLinkCollection = new EntityCollection();\n      const promise = load(dataSource, networkLinkCollection, href, options)\n        .then(function (rootElement) {\n          const entities = dataSource._entityCollection;\n          const newEntities = networkLinkCollection.values;\n          entities.suspendEvents();\n          for (let i = 0; i < newEntities.length; i++) {\n            const newEntity = newEntities[i];\n            if (!defined(newEntity.parent)) {\n              newEntity.parent = networkEntity;\n              mergeAvailabilityWithParent(newEntity);\n            }\n\n            entities.add(newEntity);\n          }\n          entities.resumeEvents();\n\n          // Add network links to a list if we need they will need to be updated\n          const refreshMode = queryStringValue(\n            link,\n            \"refreshMode\",\n            namespaces.kml,\n          );\n          let refreshInterval =\n            queryNumericValue(link, \"refreshInterval\", namespaces.kml) ?? 0;\n          if (\n            (refreshMode === \"onInterval\" && refreshInterval > 0) ||\n            refreshMode === \"onExpire\" ||\n            viewRefreshMode === \"onStop\"\n          ) {\n            const networkLinkControl = queryFirstNode(\n              rootElement,\n              \"NetworkLinkControl\",\n              namespaces.kml,\n            );\n            const hasNetworkLinkControl = defined(networkLinkControl);\n\n            const now = JulianDate.now();\n            const networkLinkInfo = {\n              id: createGuid(),\n              href: href,\n              cookie: {},\n              lastUpdated: now,\n              updating: false,\n              entity: networkEntity,\n              viewBoundScale: viewBoundScale,\n              needsUpdate: false,\n              cameraUpdateTime: now,\n            };\n\n            let minRefreshPeriod = 0;\n            if (hasNetworkLinkControl) {\n              networkLinkInfo.cookie = queryToObject(\n                queryStringValue(\n                  networkLinkControl,\n                  \"cookie\",\n                  namespaces.kml,\n                ) ?? \"\",\n              );\n              minRefreshPeriod =\n                queryNumericValue(\n                  networkLinkControl,\n                  \"minRefreshPeriod\",\n                  namespaces.kml,\n                ) ?? 0;\n            }\n\n            if (refreshMode === \"onInterval\") {\n              if (hasNetworkLinkControl) {\n                refreshInterval = Math.max(minRefreshPeriod, refreshInterval);\n              }\n              networkLinkInfo.refreshMode = RefreshMode.INTERVAL;\n              networkLinkInfo.time = refreshInterval;\n            } else if (refreshMode === \"onExpire\") {\n              let expires;\n              if (hasNetworkLinkControl) {\n                expires = queryStringValue(\n                  networkLinkControl,\n                  \"expires\",\n                  namespaces.kml,\n                );\n              }\n              if (defined(expires)) {\n                try {\n                  const date = JulianDate.fromIso8601(expires);\n                  const diff = JulianDate.secondsDifference(date, now);\n                  if (diff > 0 && diff < minRefreshPeriod) {\n                    JulianDate.addSeconds(now, minRefreshPeriod, date);\n                  }\n                  networkLinkInfo.refreshMode = RefreshMode.EXPIRE;\n                  networkLinkInfo.time = date;\n                } catch (e) {\n                  oneTimeWarning(\n                    \"kml-refreshMode-onInterval-onExpire\",\n                    \"KML - NetworkLinkControl expires is not a valid date\",\n                  );\n                }\n              } else {\n                oneTimeWarning(\n                  \"kml-refreshMode-onExpire\",\n                  \"KML - refreshMode of onExpire requires the NetworkLinkControl to have an expires element\",\n                );\n              }\n            } else if (defined(dataSource.camera)) {\n              // Only allow onStop refreshes if we have a camera\n              networkLinkInfo.refreshMode = RefreshMode.STOP;\n              networkLinkInfo.time =\n                queryNumericValue(link, \"viewRefreshTime\", namespaces.kml) ?? 0;\n            } else {\n              oneTimeWarning(\n                \"kml-refrehMode-onStop-noCamera\",\n                \"A NetworkLink with viewRefreshMode=onStop requires the `camera` property to be defined.\",\n              );\n            }\n\n            if (defined(networkLinkInfo.refreshMode)) {\n              dataSource._networkLinks.set(networkLinkInfo.id, networkLinkInfo);\n            }\n          }\n        })\n        .catch(function (error) {\n          oneTimeWarning(`An error occured during loading ${href.url}`);\n          dataSource._error.raiseEvent(dataSource, error);\n        });\n\n      deferredLoading.addPromise(promise);\n    }\n  }\n}\n\nfunction processFeatureNode(dataSource, node, processingData, deferredLoading) {\n  const featureProcessor = featureTypes[node.localName];\n  if (defined(featureProcessor)) {\n    return featureProcessor(dataSource, node, processingData, deferredLoading);\n  }\n\n  return processUnsupportedFeature(\n    dataSource,\n    node,\n    processingData,\n    deferredLoading,\n  );\n}\n\nfunction loadKml(\n  dataSource,\n  entityCollection,\n  kml,\n  sourceResource,\n  uriResolver,\n  screenOverlayContainer,\n  context,\n) {\n  entityCollection.removeAll();\n\n  const documentElement = kml.documentElement;\n  const document =\n    documentElement.localName === \"Document\"\n      ? documentElement\n      : queryFirstNode(documentElement, \"Document\", namespaces.kml);\n  let name = queryStringValue(document, \"name\", namespaces.kml);\n  if (!defined(name)) {\n    name = getFilenameFromUri(sourceResource.getUrlComponent());\n  }\n\n  // Only set the name from the root document\n  if (!defined(dataSource._name)) {\n    dataSource._name = name;\n  }\n\n  const deferredLoading = new KmlDataSource._DeferredLoading(dataSource);\n  const styleCollection = new EntityCollection(dataSource);\n  return Promise.all(\n    processStyles(\n      dataSource,\n      kml,\n      styleCollection,\n      sourceResource,\n      false,\n      uriResolver,\n    ),\n  ).then(function () {\n    let element = kml.documentElement;\n    if (element.localName === \"kml\") {\n      const childNodes = element.childNodes;\n      for (let i = 0; i < childNodes.length; i++) {\n        const tmp = childNodes[i];\n        if (defined(featureTypes[tmp.localName])) {\n          element = tmp;\n          break;\n        }\n      }\n    }\n\n    const processingData = {\n      parentEntity: undefined,\n      entityCollection: entityCollection,\n      styleCollection: styleCollection,\n      sourceResource: sourceResource,\n      uriResolver: uriResolver,\n      context: context,\n      screenOverlayContainer: screenOverlayContainer,\n    };\n\n    entityCollection.suspendEvents();\n    processFeatureNode(dataSource, element, processingData, deferredLoading);\n    entityCollection.resumeEvents();\n\n    return deferredLoading.wait().then(function () {\n      return kml.documentElement;\n    });\n  });\n}\n\nasync function loadKmz(\n  dataSource,\n  entityCollection,\n  blob,\n  sourceResource,\n  screenOverlayContainer,\n) {\n  const zWorkerUri = buildModuleUrl(\"ThirdParty/Workers/zip-web-worker.js\");\n  const zWasmUri = buildModuleUrl(\"ThirdParty/zip-module.wasm\");\n  configure({\n    workerURI: zWorkerUri,\n    wasmURI: zWasmUri,\n  });\n\n  const reader = new ZipReader(new BlobReader(blob));\n  const entries = await reader.getEntries();\n\n  const promises = [];\n  const uriResolver = {};\n  let docEntry;\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i];\n    if (!entry.directory) {\n      if (/\\.kml$/i.test(entry.filename)) {\n        // We use the first KML document we come across\n        //  https://developers.google.com/kml/documentation/kmzarchives\n        // Unless we come across a .kml file at the root of the archive because GE does this\n        if (!defined(docEntry) || !/\\//i.test(entry.filename)) {\n          if (defined(docEntry)) {\n            // We found one at the root so load the initial kml as a data uri\n            promises.push(loadDataUriFromZip(docEntry, uriResolver));\n          }\n          docEntry = entry;\n        } else {\n          // Wasn't the first kml and wasn't at the root\n          promises.push(loadDataUriFromZip(entry, uriResolver));\n        }\n      } else {\n        promises.push(loadDataUriFromZip(entry, uriResolver));\n      }\n    }\n  }\n\n  // Now load the root KML document\n  if (defined(docEntry)) {\n    promises.push(loadXmlFromZip(docEntry, uriResolver));\n  }\n  await Promise.all(promises);\n  reader.close();\n  if (!defined(uriResolver.kml)) {\n    throw new RuntimeError(\"KMZ file does not contain a KML document.\");\n  }\n  uriResolver.keys = Object.keys(uriResolver);\n\n  return loadKml(\n    dataSource,\n    entityCollection,\n    uriResolver.kml,\n    sourceResource,\n    uriResolver,\n    screenOverlayContainer,\n  );\n}\n\nfunction load(dataSource, entityCollection, data, options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  let sourceUri = options.sourceUri;\n  const uriResolver = options.uriResolver;\n  const context = options.context;\n  let screenOverlayContainer = options.screenOverlayContainer;\n\n  let promise = data;\n  if (typeof data === \"string\" || data instanceof Resource) {\n    data = Resource.createIfNeeded(data);\n    promise = data.fetchBlob();\n    sourceUri = sourceUri ?? data.clone();\n\n    // Add resource credits to our list of credits to display\n    const resourceCredits = dataSource._resourceCredits;\n    const credits = data.credits;\n    if (defined(credits)) {\n      const length = credits.length;\n      for (let i = 0; i < length; i++) {\n        resourceCredits.push(credits[i]);\n      }\n    }\n  } else {\n    sourceUri = sourceUri ?? Resource.DEFAULT.clone();\n  }\n\n  sourceUri = Resource.createIfNeeded(sourceUri);\n\n  if (defined(screenOverlayContainer)) {\n    screenOverlayContainer = getElement(screenOverlayContainer);\n  }\n\n  return Promise.resolve(promise)\n    .then(function (dataToLoad) {\n      if (dataToLoad instanceof Blob) {\n        return isZipFile(dataToLoad).then(function (isZip) {\n          if (isZip) {\n            return loadKmz(\n              dataSource,\n              entityCollection,\n              dataToLoad,\n              sourceUri,\n              screenOverlayContainer,\n            );\n          }\n          return readBlobAsText(dataToLoad).then(function (text) {\n            //There's no official way to validate if a parse was successful.\n            //The following check detects the error on various browsers.\n\n            //Insert missing namespaces\n            text = insertNamespaces(text);\n\n            //Remove Duplicate Namespaces\n            text = removeDuplicateNamespaces(text);\n\n            //IE raises an exception\n            let kml;\n            let error;\n            try {\n              kml = parser.parseFromString(text, \"application/xml\");\n            } catch (e) {\n              error = e.toString();\n            }\n\n            //The parse succeeds on Chrome and Firefox, but the error\n            //handling is different in each.\n            if (\n              defined(error) ||\n              kml.body ||\n              kml.documentElement.tagName === \"parsererror\"\n            ) {\n              //Firefox has error information as the firstChild nodeValue.\n              let msg = defined(error)\n                ? error\n                : kml.documentElement.firstChild.nodeValue;\n\n              //Chrome has it in the body text.\n              if (!msg) {\n                msg = kml.body.innerText;\n              }\n\n              //Return the error\n              throw new RuntimeError(msg);\n            }\n            return loadKml(\n              dataSource,\n              entityCollection,\n              kml,\n              sourceUri,\n              uriResolver,\n              screenOverlayContainer,\n              context,\n            );\n          });\n        });\n      }\n      return loadKml(\n        dataSource,\n        entityCollection,\n        dataToLoad,\n        sourceUri,\n        uriResolver,\n        screenOverlayContainer,\n        context,\n      );\n    })\n    .catch(function (error) {\n      dataSource._error.raiseEvent(dataSource, error);\n      console.log(error);\n      return Promise.reject(error);\n    });\n}\n\n// NOTE: LoadOptions properties are repeated in ConstructorOptions because some\n// tooling does not support \"base types\" for @typedef.  Remove if/when\n// https://github.com/microsoft/TypeScript/issues/20077 and/or\n// https://github.com/jsdoc/jsdoc/issues/1199 actually get resolved\n/**\n * @typedef {object} KmlDataSource.LoadOptions\n *\n * Initialization options for the `load` method.\n *\n * @property {string} [sourceUri] Overrides the url to use for resolving relative links and other KML network features.\n * @property {boolean} [clampToGround=false] true if we want the geometry features (Polygons, LineStrings and LinearRings) clamped to the ground.\n * @property {Ellipsoid} [ellipsoid=Ellipsoid.default] The global ellipsoid used for geographical calculations.\n * @property {Element|string} [screenOverlayContainer] A container for ScreenOverlay images.\n */\n\n/**\n * @typedef {object} KmlDataSource.ConstructorOptions\n *\n * Options for constructing a new KmlDataSource, or calling the static `load` method.\n *\n * @property {Camera} [camera] The camera that is used for viewRefreshModes and sending camera properties to network links.\n * @property {HTMLCanvasElement} [canvas] The canvas that is used for sending viewer properties to network links.\n * @property {Credit|string} [credit] A credit for the data source, which is displayed on the canvas.\n *\n * @property {string} [sourceUri] Overrides the url to use for resolving relative links and other KML network features.\n * @property {boolean} [clampToGround=false] true if we want the geometry features (Polygons, LineStrings and LinearRings) clamped to the ground.\n * @property {Ellipsoid} [ellipsoid=Ellipsoid.default] The global ellipsoid used for geographical calculations.\n * @property {Element|string} [screenOverlayContainer] A container for ScreenOverlay images.\n\n*/\n\n/**\n * A {@link DataSource} which processes Keyhole Markup Language 2.2 (KML).\n * <p>\n * KML support in Cesium is incomplete, but a large amount of the standard,\n * as well as Google's <code>gx</code> extension namespace, is supported. See Github issue\n * {@link https://github.com/CesiumGS/cesium/issues/873|#873} for a\n * detailed list of what is and isn't supported. Cesium will also write information to the\n * console when it encounters most unsupported features.\n * </p>\n * <p>\n * Non visual feature data, such as <code>atom:author</code> and <code>ExtendedData</code>\n * is exposed via an instance of {@link KmlFeatureData}, which is added to each {@link Entity}\n * under the <code>kml</code> property.\n * </p>\n *\n * @alias KmlDataSource\n * @constructor\n *\n * @param {KmlDataSource.ConstructorOptions} [options] Object describing initialization options\n *\n * @see {@link http://www.opengeospatial.org/standards/kml/|Open Geospatial Consortium KML Standard}\n * @see {@link https://developers.google.com/kml/|Google KML Documentation}\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=KML.html|Cesium Sandcastle KML Demo}\n *\n * @example\n * const viewer = new Cesium.Viewer('cesiumContainer');\n * viewer.dataSources.add(Cesium.KmlDataSource.load('../../SampleData/facilities.kmz',\n *      {\n *           camera: viewer.scene.camera,\n *           canvas: viewer.scene.canvas\n *      })\n * );\n */\nfunction KmlDataSource(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const camera = options.camera;\n  const canvas = options.canvas;\n\n  this._changed = new Event();\n  this._error = new Event();\n  this._loading = new Event();\n  this._refresh = new Event();\n  this._unsupportedNode = new Event();\n\n  this._clock = undefined;\n  this._entityCollection = new EntityCollection(this);\n  this._name = undefined;\n  this._isLoading = false;\n  this._pinBuilder = new PinBuilder();\n  this._networkLinks = new AssociativeArray();\n  this._entityCluster = new EntityCluster();\n\n  /**\n   * The current size of this Canvas will be used to populate the Link parameters\n   * for client height and width.\n   *\n   * @type {HTMLCanvasElement | undefined}\n   */\n  this.canvas = canvas;\n\n  /**\n   * The position and orientation of this {@link Camera} will be used to\n   * populate various camera parameters when making network requests.\n   * Camera movement will determine when to trigger NetworkLink refresh if\n   * <code>viewRefreshMode</code> is <code>onStop</code>.\n   *\n   * @type {Camera | undefined}\n   */\n  this.camera = camera;\n\n  this._lastCameraView = {\n    position: defined(camera) ? Cartesian3.clone(camera.positionWC) : undefined,\n    direction: defined(camera)\n      ? Cartesian3.clone(camera.directionWC)\n      : undefined,\n    up: defined(camera) ? Cartesian3.clone(camera.upWC) : undefined,\n    bbox: defined(camera)\n      ? camera.computeViewRectangle()\n      : Rectangle.clone(Rectangle.MAX_VALUE),\n  };\n\n  this._ellipsoid = options.ellipsoid ?? Ellipsoid.default;\n\n  // User specified credit\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  this._credit = credit;\n\n  // Create a list of Credit's from the resource that the user can't remove\n  this._resourceCredits = [];\n\n  this._kmlTours = [];\n\n  this._screenOverlays = [];\n}\n\n/**\n * Creates a Promise to a new instance loaded with the provided KML data.\n *\n * @param {Resource|string|Document|Blob} data A url, parsed KML document, or Blob containing binary KMZ data or a parsed KML document.\n * @param {KmlDataSource.ConstructorOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<KmlDataSource>} A promise that will resolve to a new KmlDataSource instance once the KML is loaded.\n */\nKmlDataSource.load = function (data, options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const dataSource = new KmlDataSource(options);\n  return dataSource.load(data, options);\n};\n\nObject.defineProperties(KmlDataSource.prototype, {\n  /**\n   * Gets or sets a human-readable name for this instance.\n   * This will be automatically be set to the KML document name on load.\n   * @memberof KmlDataSource.prototype\n   * @type {string}\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n    set: function (value) {\n      if (this._name !== value) {\n        this._name = value;\n        this._changed.raiseEvent(this);\n      }\n    },\n  },\n  /**\n   * Gets the clock settings defined by the loaded KML. This represents the total\n   * availability interval for all time-dynamic data. If the KML does not contain\n   * time-dynamic data, this value is undefined.\n   * @memberof KmlDataSource.prototype\n   * @type {DataSourceClock}\n   */\n  clock: {\n    get: function () {\n      return this._clock;\n    },\n  },\n  /**\n   * Gets the collection of {@link Entity} instances.\n   * @memberof KmlDataSource.prototype\n   * @type {EntityCollection}\n   */\n  entities: {\n    get: function () {\n      return this._entityCollection;\n    },\n  },\n  /**\n   * Gets a value indicating if the data source is currently loading data.\n   * @memberof KmlDataSource.prototype\n   * @type {boolean}\n   */\n  isLoading: {\n    get: function () {\n      return this._isLoading;\n    },\n  },\n  /**\n   * Gets an event that will be raised when the underlying data changes.\n   * @memberof KmlDataSource.prototype\n   * @type {Event}\n   */\n  changedEvent: {\n    get: function () {\n      return this._changed;\n    },\n  },\n  /**\n   * Gets an event that will be raised if an error is encountered during processing.\n   * @memberof KmlDataSource.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._error;\n    },\n  },\n  /**\n   * Gets an event that will be raised when the data source either starts or stops loading.\n   * @memberof KmlDataSource.prototype\n   * @type {Event}\n   */\n  loadingEvent: {\n    get: function () {\n      return this._loading;\n    },\n  },\n  /**\n   * Gets an event that will be raised when the data source refreshes a network link.\n   * @memberof KmlDataSource.prototype\n   * @type {Event}\n   */\n  refreshEvent: {\n    get: function () {\n      return this._refresh;\n    },\n  },\n  /**\n   * Gets an event that will be raised when the data source finds an unsupported node type.\n   * @memberof KmlDataSource.prototype\n   * @type {Event}\n   */\n  unsupportedNodeEvent: {\n    get: function () {\n      return this._unsupportedNode;\n    },\n  },\n  /**\n   * Gets whether or not this data source should be displayed.\n   * @memberof KmlDataSource.prototype\n   * @type {boolean}\n   */\n  show: {\n    get: function () {\n      return this._entityCollection.show;\n    },\n    set: function (value) {\n      this._entityCollection.show = value;\n    },\n  },\n\n  /**\n   * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.\n   *\n   * @memberof KmlDataSource.prototype\n   * @type {EntityCluster}\n   */\n  clustering: {\n    get: function () {\n      return this._entityCluster;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value must be defined.\");\n      }\n      //>>includeEnd('debug');\n      this._entityCluster = value;\n    },\n  },\n  /**\n   * Gets the credit that will be displayed for the data source\n   * @memberof KmlDataSource.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n  /**\n   * Gets the KML Tours that are used to guide the camera to specified destinations on given time intervals.\n   * @memberof KmlDataSource.prototype\n   * @type {KmlTour[]}\n   */\n  kmlTours: {\n    get: function () {\n      return this._kmlTours;\n    },\n  },\n});\n\n/**\n * Asynchronously loads the provided KML data, replacing any existing data.\n *\n * @param {Resource|string|Document|Blob} data A url, parsed KML document, or Blob containing binary KMZ data or a parsed KML document.\n * @param {KmlDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise<KmlDataSource>} A promise that will resolve to this instances once the KML is loaded.\n */\nKmlDataSource.prototype.load = function (data, options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(data)) {\n    throw new DeveloperError(\"data is required.\");\n  }\n  //>>includeEnd('debug');\n\n  options = options ?? Frozen.EMPTY_OBJECT;\n  DataSource.setLoading(this, true);\n\n  const oldName = this._name;\n  this._name = undefined;\n  this._clampToGround = options.clampToGround ?? false;\n\n  const that = this;\n  return load(this, this._entityCollection, data, options)\n    .then(function () {\n      let clock;\n\n      const availability = that._entityCollection.computeAvailability();\n\n      let start = availability.start;\n      let stop = availability.stop;\n      const isMinStart = JulianDate.equals(start, Iso8601.MINIMUM_VALUE);\n      const isMaxStop = JulianDate.equals(stop, Iso8601.MAXIMUM_VALUE);\n      if (!isMinStart || !isMaxStop) {\n        let date;\n\n        //If start is min time just start at midnight this morning, local time\n        if (isMinStart) {\n          date = new Date();\n          date.setHours(0, 0, 0, 0);\n          start = JulianDate.fromDate(date);\n        }\n\n        //If stop is max value just stop at midnight tonight, local time\n        if (isMaxStop) {\n          date = new Date();\n          date.setHours(24, 0, 0, 0);\n          stop = JulianDate.fromDate(date);\n        }\n\n        clock = new DataSourceClock();\n        clock.startTime = start;\n        clock.stopTime = stop;\n        clock.currentTime = JulianDate.clone(start);\n        clock.clockRange = ClockRange.LOOP_STOP;\n        clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;\n        clock.multiplier = Math.round(\n          Math.min(\n            Math.max(JulianDate.secondsDifference(stop, start) / 60, 1),\n            3.15569e7,\n          ),\n        );\n      }\n\n      let changed = false;\n      if (clock !== that._clock) {\n        that._clock = clock;\n        changed = true;\n      }\n\n      if (oldName !== that._name) {\n        changed = true;\n      }\n\n      if (changed) {\n        that._changed.raiseEvent(that);\n      }\n\n      DataSource.setLoading(that, false);\n\n      return that;\n    })\n    .catch(function (error) {\n      DataSource.setLoading(that, false);\n      that._error.raiseEvent(that, error);\n      console.log(error);\n      return Promise.reject(error);\n    });\n};\n\n/**\n * Cleans up any non-entity elements created by the data source. Currently this only affects ScreenOverlay elements.\n */\nKmlDataSource.prototype.destroy = function () {\n  while (this._screenOverlays.length > 0) {\n    const elem = this._screenOverlays.pop();\n    elem.remove();\n  }\n};\n\nfunction mergeAvailabilityWithParent(child) {\n  const parent = child.parent;\n  if (defined(parent)) {\n    const parentAvailability = parent.availability;\n    if (defined(parentAvailability)) {\n      const childAvailability = child.availability;\n      if (defined(childAvailability)) {\n        childAvailability.intersect(parentAvailability);\n      } else {\n        child.availability = parentAvailability;\n      }\n    }\n  }\n}\n\nfunction getNetworkLinkUpdateCallback(\n  dataSource,\n  networkLink,\n  newEntityCollection,\n  networkLinks,\n  processedHref,\n) {\n  return function (rootElement) {\n    if (!networkLinks.contains(networkLink.id)) {\n      // Got into the odd case where a parent network link was updated while a child\n      //  network link update was in flight, so just throw it away.\n      return;\n    }\n    let remove = false;\n    const networkLinkControl = queryFirstNode(\n      rootElement,\n      \"NetworkLinkControl\",\n      namespaces.kml,\n    );\n    const hasNetworkLinkControl = defined(networkLinkControl);\n\n    let minRefreshPeriod = 0;\n    if (hasNetworkLinkControl) {\n      if (\n        defined(queryFirstNode(networkLinkControl, \"Update\", namespaces.kml))\n      ) {\n        oneTimeWarning(\n          \"kml-networkLinkControl-update\",\n          \"KML - NetworkLinkControl updates aren't supported.\",\n        );\n        networkLink.updating = false;\n        networkLinks.remove(networkLink.id);\n        return;\n      }\n      networkLink.cookie = queryToObject(\n        queryStringValue(networkLinkControl, \"cookie\", namespaces.kml) ?? \"\",\n      );\n      minRefreshPeriod =\n        queryNumericValue(\n          networkLinkControl,\n          \"minRefreshPeriod\",\n          namespaces.kml,\n        ) ?? 0;\n    }\n\n    const now = JulianDate.now();\n    const refreshMode = networkLink.refreshMode;\n    if (refreshMode === RefreshMode.INTERVAL) {\n      if (defined(networkLinkControl)) {\n        networkLink.time = Math.max(minRefreshPeriod, networkLink.time);\n      }\n    } else if (refreshMode === RefreshMode.EXPIRE) {\n      let expires;\n      if (defined(networkLinkControl)) {\n        expires = queryStringValue(\n          networkLinkControl,\n          \"expires\",\n          namespaces.kml,\n        );\n      }\n      if (defined(expires)) {\n        try {\n          const date = JulianDate.fromIso8601(expires);\n          const diff = JulianDate.secondsDifference(date, now);\n          if (diff > 0 && diff < minRefreshPeriod) {\n            JulianDate.addSeconds(now, minRefreshPeriod, date);\n          }\n          networkLink.time = date;\n        } catch (e) {\n          oneTimeWarning(\n            \"kml-networkLinkControl-expires\",\n            \"KML - NetworkLinkControl expires is not a valid date\",\n          );\n          remove = true;\n        }\n      } else {\n        oneTimeWarning(\n          \"kml-refreshMode-onExpire\",\n          \"KML - refreshMode of onExpire requires the NetworkLinkControl to have an expires element\",\n        );\n        remove = true;\n      }\n    }\n\n    const networkLinkEntity = networkLink.entity;\n    const entityCollection = dataSource._entityCollection;\n    const newEntities = newEntityCollection.values;\n\n    function removeChildren(entity) {\n      entityCollection.remove(entity);\n      const children = entity._children;\n      const count = children.length;\n      for (let i = 0; i < count; ++i) {\n        removeChildren(children[i]);\n      }\n    }\n\n    // Remove old entities\n    entityCollection.suspendEvents();\n    const entitiesCopy = entityCollection.values.slice();\n    let i;\n    for (i = 0; i < entitiesCopy.length; ++i) {\n      const entityToRemove = entitiesCopy[i];\n      if (entityToRemove.parent === networkLinkEntity) {\n        entityToRemove.parent = undefined;\n        removeChildren(entityToRemove);\n      }\n    }\n    entityCollection.resumeEvents();\n\n    // Add new entities\n    entityCollection.suspendEvents();\n    for (i = 0; i < newEntities.length; i++) {\n      const newEntity = newEntities[i];\n      if (!defined(newEntity.parent)) {\n        newEntity.parent = networkLinkEntity;\n        mergeAvailabilityWithParent(newEntity);\n      }\n      entityCollection.add(newEntity);\n    }\n    entityCollection.resumeEvents();\n\n    // No refresh information remove it, otherwise update lastUpdate time\n    if (remove) {\n      networkLinks.remove(networkLink.id);\n    } else {\n      networkLink.lastUpdated = now;\n    }\n\n    const availability = entityCollection.computeAvailability();\n\n    const start = availability.start;\n    const stop = availability.stop;\n    const isMinStart = JulianDate.equals(start, Iso8601.MINIMUM_VALUE);\n    const isMaxStop = JulianDate.equals(stop, Iso8601.MAXIMUM_VALUE);\n    if (!isMinStart || !isMaxStop) {\n      const clock = dataSource._clock;\n\n      if (clock.startTime !== start || clock.stopTime !== stop) {\n        clock.startTime = start;\n        clock.stopTime = stop;\n        dataSource._changed.raiseEvent(dataSource);\n      }\n    }\n\n    networkLink.updating = false;\n    networkLink.needsUpdate = false;\n    dataSource._refresh.raiseEvent(\n      dataSource,\n      processedHref.getUrlComponent(true),\n    );\n  };\n}\n\nconst entitiesToIgnore = new AssociativeArray();\n\n/**\n * Updates any NetworkLink that require updating.\n *\n * @param {JulianDate} time The simulation time.\n * @returns {boolean} True if this data source is ready to be displayed at the provided time, false otherwise.\n */\nKmlDataSource.prototype.update = function (time) {\n  const networkLinks = this._networkLinks;\n  if (networkLinks.length === 0) {\n    return true;\n  }\n\n  const now = JulianDate.now();\n  const that = this;\n\n  entitiesToIgnore.removeAll();\n\n  function recurseIgnoreEntities(entity) {\n    const children = entity._children;\n    const count = children.length;\n    for (let i = 0; i < count; ++i) {\n      const child = children[i];\n      entitiesToIgnore.set(child.id, child);\n      recurseIgnoreEntities(child);\n    }\n  }\n\n  let cameraViewUpdate = false;\n  const lastCameraView = this._lastCameraView;\n  const camera = this.camera;\n  if (\n    defined(camera) &&\n    !(\n      camera.positionWC.equalsEpsilon(\n        lastCameraView.position,\n        CesiumMath.EPSILON7,\n      ) &&\n      camera.directionWC.equalsEpsilon(\n        lastCameraView.direction,\n        CesiumMath.EPSILON7,\n      ) &&\n      camera.upWC.equalsEpsilon(lastCameraView.up, CesiumMath.EPSILON7)\n    )\n  ) {\n    // Camera has changed so update the last view\n    lastCameraView.position = Cartesian3.clone(camera.positionWC);\n    lastCameraView.direction = Cartesian3.clone(camera.directionWC);\n    lastCameraView.up = Cartesian3.clone(camera.upWC);\n    lastCameraView.bbox = camera.computeViewRectangle();\n    cameraViewUpdate = true;\n  }\n\n  const newNetworkLinks = new AssociativeArray();\n  let changed = false;\n  networkLinks.values.forEach(function (networkLink) {\n    const entity = networkLink.entity;\n    if (entitiesToIgnore.contains(entity.id)) {\n      return;\n    }\n\n    if (!networkLink.updating) {\n      let doUpdate = false;\n      if (networkLink.refreshMode === RefreshMode.INTERVAL) {\n        if (\n          JulianDate.secondsDifference(now, networkLink.lastUpdated) >\n          networkLink.time\n        ) {\n          doUpdate = true;\n        }\n      } else if (networkLink.refreshMode === RefreshMode.EXPIRE) {\n        if (JulianDate.greaterThan(now, networkLink.time)) {\n          doUpdate = true;\n        }\n      } else if (networkLink.refreshMode === RefreshMode.STOP) {\n        if (cameraViewUpdate) {\n          networkLink.needsUpdate = true;\n          networkLink.cameraUpdateTime = now;\n        }\n\n        if (\n          networkLink.needsUpdate &&\n          JulianDate.secondsDifference(now, networkLink.cameraUpdateTime) >=\n            networkLink.time\n        ) {\n          doUpdate = true;\n        }\n      }\n\n      if (doUpdate) {\n        recurseIgnoreEntities(entity);\n        networkLink.updating = true;\n        const newEntityCollection = new EntityCollection();\n        const href = networkLink.href.clone();\n\n        href.setQueryParameters(networkLink.cookie);\n        const ellipsoid = that._ellipsoid ?? Ellipsoid.default;\n        processNetworkLinkQueryString(\n          href,\n          that.camera,\n          that.canvas,\n          networkLink.viewBoundScale,\n          lastCameraView.bbox,\n          ellipsoid,\n        );\n\n        load(that, newEntityCollection, href, {\n          context: entity.id,\n        })\n          .then(\n            getNetworkLinkUpdateCallback(\n              that,\n              networkLink,\n              newEntityCollection,\n              newNetworkLinks,\n              href,\n            ),\n          )\n          .catch(function (error) {\n            const msg = `NetworkLink ${networkLink.href} refresh failed: ${error}`;\n            console.log(msg);\n            that._error.raiseEvent(that, msg);\n          });\n        changed = true;\n      }\n    }\n    newNetworkLinks.set(networkLink.id, networkLink);\n  });\n\n  if (changed) {\n    this._networkLinks = newNetworkLinks;\n    this._changed.raiseEvent(this);\n  }\n\n  return true;\n};\n\n/**\n * Contains KML Feature data loaded into the <code>Entity.kml</code> property by {@link KmlDataSource}.\n * @alias KmlFeatureData\n * @constructor\n */\nfunction KmlFeatureData() {\n  /**\n   * @typedef KmlFeatureData.Author\n   * @type {object}\n   * @property {string} name Gets the name.\n   * @property {string} uri Gets the URI.\n   * @property {number} age Gets the email.\n   */\n\n  /**\n   * Gets the atom syndication format author field.\n   * @type {KmlFeatureData.Author}\n   */\n  this.author = {\n    name: undefined,\n    uri: undefined,\n    email: undefined,\n  };\n\n  /**\n   * @typedef KmlFeatureData.Link\n   * @type {object}\n   * @property {string} href Gets the href.\n   * @property {string} hreflang Gets the language of the linked resource.\n   * @property {string} rel Gets the link relation.\n   * @property {string} type Gets the link type.\n   * @property {string} title Gets the link title.\n   * @property {string} length Gets the link length.\n   */\n\n  /**\n   * Gets the link.\n   * @type {KmlFeatureData.Link}\n   */\n  this.link = {\n    href: undefined,\n    hreflang: undefined,\n    rel: undefined,\n    type: undefined,\n    title: undefined,\n    length: undefined,\n  };\n\n  /**\n   * Gets the unstructured address field.\n   * @type {string}\n   */\n  this.address = undefined;\n  /**\n   * Gets the phone number.\n   * @type {string}\n   */\n  this.phoneNumber = undefined;\n  /**\n   * Gets the snippet.\n   * @type {string}\n   */\n  this.snippet = undefined;\n  /**\n   * Gets the extended data, parsed into a JSON object.\n   * Currently only the <code>Data</code> property is supported.\n   * <code>SchemaData</code> and custom data are ignored.\n   * @type {string}\n   */\n  this.extendedData = undefined;\n}\n\n// For testing\nKmlDataSource._DeferredLoading = DeferredLoading;\nKmlDataSource._getTimestamp = getTimestamp;\n\nexport default KmlDataSource;\n"],"mappings":";;;;;;AAAA,OAAOA,OAAO,MAAM,oBAAoB;AACxC,OAAOC,gBAAgB,MAAM,6BAA6B;AAC1D,OAAOC,iBAAiB,MAAM,8BAA8B;AAC5D,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,SAAS,MAAM,sBAAsB;AAC5C,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,MAAM,MAAM,mBAAmB;AACtC,OAAOC,MAAM,MAAM,mBAAmB;AACtC,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,SAAS,MAAM,sBAAsB;AAC5C,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,mBAAmB,MAAM,gCAAgC;AAChE,OAAOC,kBAAkB,MAAM,+BAA+B;AAC9D,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,iBAAiB,MAAM,8BAA8B;AAC5D,OAAOC,gBAAgB,MAAM,6BAA6B;AAC1D,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,aAAa,MAAM,0BAA0B;AACpD,OAAOC,aAAa,MAAM,0BAA0B;AACpD,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,gBAAgB,MAAM,6BAA6B;AAC1D,OAAOC,aAAa,MAAM,0BAA0B;AACpD,OAAOC,SAAS,MAAM,sBAAsB;AAC5C,OAAOC,QAAQ,MAAM,qBAAqB;AAC1C,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,sBAAsB,MAAM,mCAAmC;AACtE,OAAOC,eAAe,MAAM,6BAA6B;AACzD,OAAOC,gBAAgB,MAAM,8BAA8B;AAC3D,OAAOC,UAAU,MAAM,wBAAwB;AAC/C,OAAOC,SAAS,MAAM,uBAAuB;AAC7C,OAAOC,UAAU,MAAM,YAAY;AACnC,OAAOC,GAAG,MAAM,OAAO;AACvB,SACEC,SAAS,EACTC,UAAU,EACVC,eAAe,EACfC,UAAU,EACVC,SAAS,QACJ,gCAAgC;AACvC,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,iBAAiB,MAAM,wBAAwB;AACtD,OAAOC,yBAAyB,MAAM,gCAAgC;AACtE,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,eAAe,MAAM,sBAAsB;AAClD,OAAOC,MAAM,MAAM,aAAa;AAChC,OAAOC,aAAa,MAAM,oBAAoB;AAC9C,OAAOC,gBAAgB,MAAM,uBAAuB;AACpD,OAAOC,SAAS,MAAM,gBAAgB;AACtC,OAAOC,SAAS,MAAM,gBAAgB;AACtC,OAAOC,OAAO,MAAM,cAAc;AAClC,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,WAAW,MAAM,kBAAkB;AAC1C,OAAOC,aAAa,MAAM,oBAAoB;AAC9C,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,eAAe,MAAM,sBAAsB;AAClD,OAAOC,gBAAgB,MAAM,uBAAuB;AACpD,OAAOC,qBAAqB,MAAM,4BAA4B;AAC9D,OAAOC,iBAAiB,MAAM,wBAAwB;AACtD,OAAOC,iBAAiB,MAAM,wBAAwB;AACtD,OAAOC,uBAAuB,MAAM,8BAA8B;AAClE,OAAOC,sBAAsB,MAAM,6BAA6B;AAChE,OAAOC,8BAA8B,MAAM,qCAAqC;AAChF,OAAOC,YAAY,MAAM,mBAAmB;;AAE5C;AACA;AACA;AACA;AACA,MAAMC,SAAS,GAAG;EAChBC,GAAG,EAAE,iBAAiB;EACtBC,GAAG,EAAE,WAAW;EAChBC,GAAG,EAAE,qBAAqB;EAC1BC,GAAG,EAAE,6BAA6B;EAClCC,GAAG,EAAE,UAAU;EACfC,GAAG,EAAE,UAAU;EACfC,GAAG,EAAE,oBAAoB;EACzBC,GAAG,EAAE,mBAAmB;EACxBC,GAAG,EAAE,wBAAwB;EAC7BC,GAAG,EAAE,aAAa;EAClBC,GAAG,EAAE,WAAW;EAChBC,EAAE,EAAE,oBAAoB;EACxBC,GAAG,EAAE,WAAW;EAChBC,IAAI,EAAE,WAAW;EACjBC,GAAG,EAAE,0BAA0B;EAC/BC,IAAI,EAAE,8BAA8B;EACpCC,IAAI,EAAE,YAAY;EAClBC,GAAG,EAAE,YAAY;EACjBC,GAAG,EAAE,iBAAiB;EACtBC,GAAG,EAAE,WAAW;EAChBC,MAAM,EAAE,wBAAwB;EAChCC,GAAG,EAAE,YAAY;EACjBC,IAAI,EAAE,YAAY;EAClBC,GAAG,EAAE,iBAAiB;EACtBC,GAAG,EAAE,YAAY;EACjBC,GAAG,EAAE,WAAW;EAChBC,IAAI,EAAE,WAAW;EACjBC,IAAI,EAAE,YAAY;EAClBC,GAAG,EAAE,YAAY;EACjBC,GAAG,EAAE,iDAAiD;EACtDC,GAAG,EAAE,gDAAgD;EACrDC,GAAG,EAAE,yCAAyC;EAC9CC,GAAG,EAAE,iBAAiB;EACtBC,GAAG,EAAE,iBAAiB;EACtBC,GAAG,EAAE,WAAW;EAChBC,GAAG,EAAE,+BAA+B;EACpCC,GAAG,EAAE,+BAA+B;EACpCC,EAAE,EAAE,wBAAwB;EAC5BC,EAAE,EAAE,iBAAiB;EACrBC,GAAG,EAAE,qBAAqB;EAC1BC,GAAG,EAAE,qBAAqB;EAC1BC,GAAG,EAAE,iBAAiB;EACtBC,GAAG,EAAE,eAAe;EACpBC,GAAG,EAAE,+BAA+B;EACpCC,IAAI,EAAE,YAAY;EAClBC,GAAG,EAAE,YAAY;EACjBC,IAAI,EAAE,YAAY;EAClBC,GAAG,EAAE,YAAY;EACjBC,GAAG,EAAE,aAAa;EAClBC,GAAG,EAAE,gBAAgB;EACrBC,GAAG,EAAE,gBAAgB;EACrBC,GAAG,EAAE,iBAAiB;EACtBC,GAAG,EAAE,iBAAiB;EAEtBC,kBAAkB,EAAE,SAAAA,CAAUC,QAAQ,EAAE;IACtC,IAAIC,GAAG,GAAGD,QAAQ,CAACE,WAAW,CAAC,CAAC;IAChCD,GAAG,GAAG9G,mBAAmB,CAAC8G,GAAG,CAAC;IAC9B,OAAOxD,SAAS,CAACwD,GAAG,CAAC;EACvB;AACF,CAAC;AAED,IAAIE,MAAM;AACV,IAAI,OAAOC,SAAS,KAAK,WAAW,EAAE;EACpCD,MAAM,GAAG,IAAIC,SAAS,CAAC,CAAC;AAC1B;AAEA,MAAMC,UAAU,GAAG,IAAI3F,UAAU,CAAC;EAChC4F,WAAW,EAAE,KAAK;EAClBC,KAAK,EAAE,KAAK;EACZC,SAAS,EAAE,SAAAA,CAAUC,KAAK,EAAE;IAC1B;IACA;IACA,OAAOA,KAAK,CAACC,YAAY,KAAK,QAAQ,IAAID,KAAK,CAACC,YAAY,KAAK,KAAK;EACxE;AACF,CAAC,CAAC;AAEF,MAAMC,cAAc,GAAG,EAAE;AAEzB,MAAMC,uBAAuB,GAAG,OAAO;AACvC,MAAMC,oBAAoB,GAAG,GAAG;AAChC,MAAMC,sBAAsB,GAAG,QAAQ;AACvC,MAAMC,mBAAmB,GAAG,GAAG;AAE/B,MAAMC,aAAa,GAAG,CACpB,IAAI,EACJC,SAAS,EACT,gCAAgC,EAChC,iCAAiC,EACjC,iCAAiC,EACjC,iCAAiC,CAClC;AACD,MAAMC,YAAY,GAAG,CAAC,mCAAmC,CAAC;AAC1D,MAAMC,cAAc,GAAG,CAAC,6BAA6B,CAAC;AACtD,MAAMC,UAAU,GAAG;EACjBC,GAAG,EAAEL,aAAa;EAClBM,EAAE,EAAEJ,YAAY;EAChBK,IAAI,EAAEJ,cAAc;EACpBK,KAAK,EAAER,aAAa,CAACS,MAAM,CAACP,YAAY;AAC1C,CAAC;;AAED;AACA,MAAMQ,YAAY,GAAG;EACnBC,QAAQ,EAAEC,eAAe;EACzBC,MAAM,EAAEC,aAAa;EACrBC,SAAS,EAAEC,gBAAgB;EAC3BC,WAAW,EAAEC,kBAAkB;EAC/BC,aAAa,EAAEC,oBAAoB;EACnCC,YAAY,EAAEC,yBAAyB;EACvCC,aAAa,EAAEC,oBAAoB;EACnCC,IAAI,EAAEC;AACR,CAAC;AAED,SAASC,eAAeA,CAACC,UAAU,EAAE;EACnC,IAAI,CAACC,WAAW,GAAGD,UAAU;EAC7B,IAAI,CAACE,SAAS,GAAGhK,KAAK,CAAC,CAAC;EACxB,IAAI,CAACiK,MAAM,GAAG,EAAE;EAChB,IAAI,CAACC,SAAS,GAAG,EAAE;EACnB,IAAI,CAACC,WAAW,GAAG,KAAK;EACxB,IAAI,CAACC,KAAK,GAAG,KAAK;EAElB,IAAI,CAACC,QAAQ,GAAG,CAAC;EACjB,IAAI,CAACC,cAAc,GAAG,IAAI,CAAC,CAAC;AAC9B;AAEAC,MAAM,CAACC,gBAAgB,CAACX,eAAe,CAACY,SAAS,EAAE;EACjDX,UAAU,EAAE;IACVY,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACX,WAAW;IACzB;EACF;AACF,CAAC,CAAC;AAEFF,eAAe,CAACY,SAAS,CAACE,QAAQ,GAAG,UAAUC,KAAK,EAAEC,cAAc,EAAE;EACpE,IAAI,CAACZ,MAAM,CAACa,IAAI,CAAC;IACfF,KAAK,EAAEA,KAAK;IACZG,KAAK,EAAE,CAAC;IACRF,cAAc,EAAEA;EAClB,CAAC,CAAC;EACF,IAAI,CAACT,KAAK,GAAG,IAAI;AACnB,CAAC;AAEDP,eAAe,CAACY,SAAS,CAACO,UAAU,GAAG,UAAUC,OAAO,EAAE;EACxD,IAAI,CAACf,SAAS,CAACY,IAAI,CAACG,OAAO,CAAC;AAC9B,CAAC;AAEDpB,eAAe,CAACY,SAAS,CAACS,IAAI,GAAG,YAAY;EAC3C;EACA,MAAMC,QAAQ,GAAG,IAAI,CAACnB,SAAS;EAC/B,IAAI,CAAC,IAAI,CAACI,KAAK,EAAE;IACfe,QAAQ,CAACC,OAAO,CAAC,CAAC;EACpB;EAEA,OAAOC,OAAO,CAACC,GAAG,CAAC,CAACH,QAAQ,CAACF,OAAO,EAAEI,OAAO,CAACC,GAAG,CAAC,IAAI,CAACpB,SAAS,CAAC,CAAC,CAAC;AACrE,CAAC;AAEDL,eAAe,CAACY,SAAS,CAACc,OAAO,GAAG,YAAY;EAC9C,MAAMC,WAAW,GAAG,IAAI,CAACvB,MAAM,CAACwB,MAAM,KAAK,CAAC;EAC5C,IAAID,WAAW,EAAE;IACf,IAAI,CAACnB,QAAQ,GAAGqB,aAAa,CAACC,aAAa,CAAC,CAAC;EAC/C;EAEA,OAAO,IAAI,CAACC,QAAQ,CAACJ,WAAW,CAAC;AACnC,CAAC;AAED3B,eAAe,CAACY,SAAS,CAACoB,WAAW,GAAG,YAAY;EAClD,IAAI,IAAI,CAAC1B,WAAW,EAAE;IACpB;IACA;EACF;EAEA,IAAI,CAACA,WAAW,GAAG,IAAI;EACvB,IAAI,CAACG,cAAc,GAAG,EAAE,CAAC,CAAC;EAC1B,MAAMwB,IAAI,GAAG,IAAI;EACjBC,UAAU,CAAC,YAAY;IACrBD,IAAI,CAAC3B,WAAW,GAAG,KAAK;IACxB2B,IAAI,CAACzB,QAAQ,GAAGqB,aAAa,CAACC,aAAa,CAAC,CAAC;IAC7CG,IAAI,CAACF,QAAQ,CAAC,IAAI,CAAC;EACrB,CAAC,EAAE,CAAC,CAAC;AACP,CAAC;AAED/B,eAAe,CAACY,SAAS,CAACuB,SAAS,GAAG,YAAY;EAChD,MAAMC,KAAK,GAAG,IAAI,CAAChC,MAAM;EACzB,MAAMiC,GAAG,GAAGD,KAAK,CAACA,KAAK,CAACR,MAAM,GAAG,CAAC,CAAC;EACnC,MAAMV,KAAK,GAAGmB,GAAG,CAACnB,KAAK;EACvB,MAAMH,KAAK,GAAGsB,GAAG,CAACtB,KAAK;EACvB,IAAIG,KAAK,KAAKH,KAAK,CAACa,MAAM,EAAE;IAC1B;EACF;EACA,EAAES,GAAG,CAACnB,KAAK;EAEX,OAAOH,KAAK,CAACG,KAAK,CAAC;AACrB,CAAC;AAEDlB,eAAe,CAACY,SAAS,CAAC0B,IAAI,GAAG,YAAY;EAC3C,MAAMF,KAAK,GAAG,IAAI,CAAChC,MAAM;EACzBgC,KAAK,CAACG,GAAG,CAAC,CAAC;;EAEX;EACA,IAAIH,KAAK,CAACR,MAAM,KAAK,CAAC,EAAE;IACtB,IAAI,CAACzB,SAAS,CAACoB,OAAO,CAAC,CAAC;IACxB,OAAO,KAAK;EACd;EAEA,OAAO,IAAI;AACb,CAAC;AAEDvB,eAAe,CAACY,SAAS,CAACmB,QAAQ,GAAG,UAAUJ,WAAW,EAAE;EAC1D,MAAM1B,UAAU,GAAG,IAAI,CAACA,UAAU;EAClC,MAAMe,cAAc,GAAG,IAAI,CAACZ,MAAM,CAAC,IAAI,CAACA,MAAM,CAACwB,MAAM,GAAG,CAAC,CAAC,CAACZ,cAAc;EAEzE,IAAIwB,KAAK,GAAG,IAAI,CAACL,SAAS,CAAC,CAAC;EAC5B,OAAO/L,OAAO,CAACoM,KAAK,CAAC,EAAE;IACrB,MAAMC,gBAAgB,GAAG1D,YAAY,CAACyD,KAAK,CAACE,SAAS,CAAC;IACtD,IACEtM,OAAO,CAACqM,gBAAgB,CAAC,KACxBhE,UAAU,CAACC,GAAG,CAACiE,OAAO,CAACH,KAAK,CAACI,YAAY,CAAC,KAAK,CAAC,CAAC,IAChDnE,UAAU,CAACE,EAAE,CAACgE,OAAO,CAACH,KAAK,CAACI,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,EACnD;MACAH,gBAAgB,CAACxC,UAAU,EAAEuC,KAAK,EAAExB,cAAc,EAAE,IAAI,CAAC;;MAEzD;MACA,IACE,IAAI,CAACV,WAAW,IAChBuB,aAAa,CAACC,aAAa,CAAC,CAAC,GAAG,IAAI,CAACtB,QAAQ,GAAG,IAAI,CAACC,cAAc,EACnE;QACA,IAAI,CAACuB,WAAW,CAAC,CAAC;QAClB;MACF;IACF;IAEAQ,KAAK,GAAG,IAAI,CAACL,SAAS,CAAC,CAAC;EAC1B;;EAEA;EACA;EACA,IAAI,IAAI,CAACG,IAAI,CAAC,CAAC,IAAIX,WAAW,EAAE;IAC9B,IAAI,CAACI,QAAQ,CAAC,IAAI,CAAC;EACrB;AACF,CAAC;AAED,SAASc,SAASA,CAACC,IAAI,EAAE;EACvB,MAAMC,SAAS,GAAGD,IAAI,CAACE,KAAK,CAAC,CAAC,EAAEC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEJ,IAAI,CAACK,IAAI,CAAC,CAAC;EACvD,MAAM7B,QAAQ,GAAGnL,KAAK,CAAC,CAAC;EACxB,MAAMiN,MAAM,GAAG,IAAIC,UAAU,CAAC,CAAC;EAC/BD,MAAM,CAACE,gBAAgB,CAAC,MAAM,EAAE,YAAY;IAC1ChC,QAAQ,CAACC,OAAO,CACd,IAAIgC,QAAQ,CAACH,MAAM,CAACI,MAAM,CAAC,CAACC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,KAAK,UACtD,CAAC;EACH,CAAC,CAAC;EACFL,MAAM,CAACE,gBAAgB,CAAC,OAAO,EAAE,YAAY;IAC3ChC,QAAQ,CAACoC,MAAM,CAACN,MAAM,CAACO,KAAK,CAAC;EAC/B,CAAC,CAAC;EACFP,MAAM,CAACQ,iBAAiB,CAACb,SAAS,CAAC;EACnC,OAAOzB,QAAQ,CAACF,OAAO;AACzB;AAEA,SAASyC,cAAcA,CAACf,IAAI,EAAE;EAC5B,MAAMxB,QAAQ,GAAGnL,KAAK,CAAC,CAAC;EACxB,MAAMiN,MAAM,GAAG,IAAIC,UAAU,CAAC,CAAC;EAC/BD,MAAM,CAACE,gBAAgB,CAAC,MAAM,EAAE,YAAY;IAC1ChC,QAAQ,CAACC,OAAO,CAAC6B,MAAM,CAACI,MAAM,CAAC;EACjC,CAAC,CAAC;EACFJ,MAAM,CAACE,gBAAgB,CAAC,OAAO,EAAE,YAAY;IAC3ChC,QAAQ,CAACoC,MAAM,CAACN,MAAM,CAACO,KAAK,CAAC;EAC/B,CAAC,CAAC;EACFP,MAAM,CAACU,UAAU,CAAChB,IAAI,CAAC;EACvB,OAAOxB,QAAQ,CAACF,OAAO;AACzB;AAEA,SAAS2C,gBAAgBA,CAACpH,IAAI,EAAE;EAC9B,MAAMqH,YAAY,GAAG;IACnBC,GAAG,EAAE;EACP,CAAC;EACD,IAAIC,SAAS,EAAEC,QAAQ,EAAEC,GAAG,EAAEC,WAAW;EAEzC,KAAK,MAAMC,GAAG,IAAIN,YAAY,EAAE;IAC9B,IAAIA,YAAY,CAACO,cAAc,CAACD,GAAG,CAAC,EAAE;MACpCF,GAAG,GAAGI,MAAM,CAAC,OAAOF,GAAG,GAAG,CAAC;MAC3BD,WAAW,GAAG,SAASC,GAAG,GAAG;MAC7B,IAAIF,GAAG,CAACK,IAAI,CAAC9H,IAAI,CAAC,IAAIA,IAAI,CAACgG,OAAO,CAAC0B,WAAW,CAAC,KAAK,CAAC,CAAC,EAAE;QACtD,IAAI,CAACjO,OAAO,CAAC8N,SAAS,CAAC,EAAE;UACvBA,SAAS,GAAGvH,IAAI,CAAC+H,MAAM,CAAC,CAAC,EAAE/H,IAAI,CAACgG,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;UACpDwB,QAAQ,GAAGxH,IAAI,CAAC+H,MAAM,CAACR,SAAS,CAACtC,MAAM,CAAC;QAC1C;QACAsC,SAAS,IAAI,IAAIG,WAAW,IAAIL,YAAY,CAACM,GAAG,CAAC,GAAG;MACtD;IACF;EACF;EAEA,IAAIlO,OAAO,CAAC8N,SAAS,CAAC,EAAE;IACtBvH,IAAI,GAAGuH,SAAS,GAAGC,QAAQ;EAC7B;EAEA,OAAOxH,IAAI;AACb;AAEA,SAASgI,yBAAyBA,CAAChI,IAAI,EAAE;EACvC,IAAIuE,KAAK,GAAGvE,IAAI,CAACgG,OAAO,CAAC,QAAQ,CAAC;EAClC,MAAMiC,cAAc,GAAGjI,IAAI,CAACgG,OAAO,CAAC,GAAG,EAAEzB,KAAK,CAAC;EAC/C,IAAI2D,SAAS,EAAEC,UAAU,EAAEC,QAAQ;EAEnC,OAAO7D,KAAK,KAAK,CAAC,CAAC,IAAIA,KAAK,GAAG0D,cAAc,EAAE;IAC7CC,SAAS,GAAGlI,IAAI,CAACqG,KAAK,CAAC9B,KAAK,EAAEvE,IAAI,CAACgG,OAAO,CAAC,GAAG,EAAEzB,KAAK,CAAC,CAAC;IACvD4D,UAAU,GAAG5D,KAAK;IAClBA,KAAK,GAAGvE,IAAI,CAACgG,OAAO,CAACkC,SAAS,EAAE3D,KAAK,GAAG,CAAC,CAAC;IAC1C,IAAIA,KAAK,KAAK,CAAC,CAAC,EAAE;MAChB6D,QAAQ,GAAGpI,IAAI,CAACgG,OAAO,CAAC,GAAG,EAAEhG,IAAI,CAACgG,OAAO,CAAC,GAAG,EAAEzB,KAAK,CAAC,GAAG,CAAC,CAAC;MAC1DvE,IAAI,GAAGA,IAAI,CAACqG,KAAK,CAAC,CAAC,EAAE9B,KAAK,GAAG,CAAC,CAAC,GAAGvE,IAAI,CAACqG,KAAK,CAAC+B,QAAQ,GAAG,CAAC,EAAEpI,IAAI,CAACiF,MAAM,CAAC;MACvEV,KAAK,GAAGvE,IAAI,CAACgG,OAAO,CAAC,QAAQ,EAAEmC,UAAU,GAAG,CAAC,CAAC;IAChD,CAAC,MAAM;MACL5D,KAAK,GAAGvE,IAAI,CAACgG,OAAO,CAAC,QAAQ,EAAEmC,UAAU,GAAG,CAAC,CAAC;IAChD;EACF;EAEA,OAAOnI,IAAI;AACb;AAEA,eAAeqI,cAAcA,CAACC,KAAK,EAAEC,WAAW,EAAE;EAChD,IAAIvI,IAAI,GAAG,MAAMsI,KAAK,CAACE,OAAO,CAAC,IAAI/M,UAAU,CAAC,CAAC,CAAC;EAChDuE,IAAI,GAAGoH,gBAAgB,CAACpH,IAAI,CAAC;EAC7BA,IAAI,GAAGgI,yBAAyB,CAAChI,IAAI,CAAC;EACtCuI,WAAW,CAACxG,GAAG,GAAGlB,MAAM,CAAC4H,eAAe,CAACzI,IAAI,EAAE,iBAAiB,CAAC;AACnE;AAEA,eAAe0I,kBAAkBA,CAACJ,KAAK,EAAEC,WAAW,EAAE;EACpD,MAAMI,QAAQ,GACZxL,SAAS,CAACsD,kBAAkB,CAAC6H,KAAK,CAAC5H,QAAQ,CAAC,IAAI,0BAA0B;EAC5E,MAAMkI,OAAO,GAAG,MAAMN,KAAK,CAACE,OAAO,CAAC,IAAIhN,eAAe,CAACmN,QAAQ,CAAC,CAAC;EAClEJ,WAAW,CAACD,KAAK,CAAC5H,QAAQ,CAAC,GAAGkI,OAAO;AACvC;AAEA,SAASC,aAAaA,CAACC,GAAG,EAAEC,WAAW,EAAEC,aAAa,EAAET,WAAW,EAAE;EACnE,MAAMU,IAAI,GAAGV,WAAW,CAACU,IAAI;EAC7B,MAAMC,OAAO,GAAG,IAAI7N,GAAG,CAAC,GAAG,CAAC;EAC5B,MAAM8N,QAAQ,GAAGL,GAAG,CAACM,gBAAgB,CAACL,WAAW,CAAC;EAClD,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,QAAQ,CAAClE,MAAM,EAAEoE,CAAC,EAAE,EAAE;IACxC,MAAMC,OAAO,GAAGH,QAAQ,CAACE,CAAC,CAAC;IAC3B,MAAME,KAAK,GAAGD,OAAO,CAACE,YAAY,CAACR,aAAa,CAAC;IACjD,IAAIvP,OAAO,CAAC8P,KAAK,CAAC,EAAE;MAClB,MAAME,WAAW,GAAG,IAAIpO,GAAG,CAACkO,KAAK,CAAC;MAClC,MAAMG,GAAG,GAAGD,WAAW,CAACE,UAAU,CAACT,OAAO,CAAC,CAACU,QAAQ,CAAC,CAAC;MACtD,MAAMrF,KAAK,GAAG0E,IAAI,CAACjD,OAAO,CAAC0D,GAAG,CAAC;MAC/B,IAAInF,KAAK,KAAK,CAAC,CAAC,EAAE;QAChB,MAAMoD,GAAG,GAAGsB,IAAI,CAAC1E,KAAK,CAAC;QACvB+E,OAAO,CAACO,YAAY,CAACb,aAAa,EAAET,WAAW,CAACZ,GAAG,CAAC,CAAC;QACrD,IAAIoB,WAAW,KAAK,GAAG,IAAIO,OAAO,CAACE,YAAY,CAAC,UAAU,CAAC,KAAK,IAAI,EAAE;UACpEF,OAAO,CAACO,YAAY,CAAC,UAAU,EAAElC,GAAG,CAAC;QACvC;MACF;IACF;EACF;AACF;AAEA,SAASmC,aAAaA,CAAChB,GAAG,EAAEC,WAAW,EAAEC,aAAa,EAAEe,cAAc,EAAE;EACtE,MAAMZ,QAAQ,GAAGL,GAAG,CAACM,gBAAgB,CAACL,WAAW,CAAC;EAClD,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,QAAQ,CAAClE,MAAM,EAAEoE,CAAC,EAAE,EAAE;IACxC,MAAMC,OAAO,GAAGH,QAAQ,CAACE,CAAC,CAAC;IAC3B,MAAME,KAAK,GAAGD,OAAO,CAACE,YAAY,CAACR,aAAa,CAAC;IACjD,MAAMgB,QAAQ,GAAGC,WAAW,CAACV,KAAK,EAAEQ,cAAc,CAAC;IACnD,IAAItQ,OAAO,CAACuQ,QAAQ,CAAC,EAAE;MACrBV,OAAO,CAACO,YAAY,CAACb,aAAa,EAAEgB,QAAQ,CAACE,GAAG,CAAC;IACnD;EACF;AACF;;AAEA;AACA;AACA,SAASC,YAAYA,CAACC,IAAI,EAAEC,gBAAgB,EAAEC,OAAO,EAAE;EACrD,IAAIC,EAAE,GAAGC,oBAAoB,CAACJ,IAAI,EAAE,IAAI,CAAC;EACzCG,EAAE,GAAG9Q,OAAO,CAAC8Q,EAAE,CAAC,IAAIA,EAAE,CAACtF,MAAM,KAAK,CAAC,GAAGsF,EAAE,GAAGlR,UAAU,CAAC,CAAC;EACvD,IAAII,OAAO,CAAC6Q,OAAO,CAAC,EAAE;IACpBC,EAAE,GAAGD,OAAO,GAAGC,EAAE;EACnB;;EAEA;EACA;EACA,IAAIE,MAAM,GAAGJ,gBAAgB,CAACK,OAAO,CAACH,EAAE,CAAC;EACzC,IAAI9Q,OAAO,CAACgR,MAAM,CAAC,EAAE;IACnBF,EAAE,GAAGlR,UAAU,CAAC,CAAC;IACjB,IAAII,OAAO,CAAC6Q,OAAO,CAAC,EAAE;MACpBC,EAAE,GAAGD,OAAO,GAAGC,EAAE;IACnB;EACF;EAEAE,MAAM,GAAGJ,gBAAgB,CAACM,GAAG,CAAC,IAAI3O,MAAM,CAAC;IAAEuO,EAAE,EAAEA;EAAG,CAAC,CAAC,CAAC;EACrD,IAAI,CAAC9Q,OAAO,CAACgR,MAAM,CAAC1I,GAAG,CAAC,EAAE;IACxB0I,MAAM,CAACG,WAAW,CAAC,KAAK,CAAC;IACzBH,MAAM,CAAC1I,GAAG,GAAG,IAAI8I,cAAc,CAAC,CAAC;EACnC;EACA,OAAOJ,MAAM;AACf;AAEA,SAASK,YAAYA,CAACC,YAAY,EAAEC,cAAc,EAAE;EAClD,OACED,YAAY,KAAK,UAAU,IAC3BA,YAAY,KAAK,kBAAkB,IACnCC,cAAc,KAAK,oBAAoB;AAE3C;AAEA,SAASC,cAAcA,CAAC1B,KAAK,EAAE2B,SAAS,EAAE;EACxC;EACA,IAAI,CAACzR,OAAO,CAAC8P,KAAK,CAAC,EAAE;IACnB,OAAOxQ,UAAU,CAACoS,WAAW,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAED,SAAS,CAAC;EACnD;EAEA,MAAME,MAAM,GAAG7B,KAAK,CAACpI,KAAK,CAAC,YAAY,CAAC;EACxC,IAAI,CAAC1H,OAAO,CAAC2R,MAAM,CAAC,EAAE;IACpB,OAAOrS,UAAU,CAACoS,WAAW,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAED,SAAS,CAAC;EACnD;EAEA,IAAIG,SAAS,GAAGC,UAAU,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC;EACrC,IAAIG,QAAQ,GAAGD,UAAU,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC;EACpC,IAAII,MAAM,GAAGF,UAAU,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC;EAElCC,SAAS,GAAGI,KAAK,CAACJ,SAAS,CAAC,GAAG,GAAG,GAAGA,SAAS;EAC9CE,QAAQ,GAAGE,KAAK,CAACF,QAAQ,CAAC,GAAG,GAAG,GAAGA,QAAQ;EAC3CC,MAAM,GAAGC,KAAK,CAACD,MAAM,CAAC,GAAG,GAAG,GAAGA,MAAM;EAErC,OAAOzS,UAAU,CAACoS,WAAW,CAACE,SAAS,EAAEE,QAAQ,EAAEC,MAAM,EAAEN,SAAS,CAAC;AACvE;AAEA,SAASQ,eAAeA,CAACpC,OAAO,EAAE4B,SAAS,EAAE;EAC3C,IAAI,CAACzR,OAAO,CAAC6P,OAAO,CAAC,EAAE;IACrB,OAAO3H,SAAS;EAClB;EAEA,MAAMgK,MAAM,GAAGrC,OAAO,CAACsC,WAAW,CAACzK,KAAK,CAAC,WAAW,CAAC;EACrD,IAAI,CAAC1H,OAAO,CAACkS,MAAM,CAAC,EAAE;IACpB,OAAOhK,SAAS;EAClB;EAEA,MAAMsD,MAAM,GAAG0G,MAAM,CAAC1G,MAAM;EAC5B,MAAM4B,MAAM,GAAG,IAAIgF,KAAK,CAAC5G,MAAM,CAAC;EAChC,IAAI6G,WAAW,GAAG,CAAC;EACnB,KAAK,IAAIzC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpE,MAAM,EAAEoE,CAAC,EAAE,EAAE;IAC/BxC,MAAM,CAACiF,WAAW,EAAE,CAAC,GAAGb,cAAc,CAACU,MAAM,CAACtC,CAAC,CAAC,EAAE6B,SAAS,CAAC;EAC9D;EACA,OAAOrE,MAAM;AACf;AAEA,SAASkF,qBAAqBA,CAAC3B,IAAI,EAAEpB,aAAa,EAAE;EAClD,IAAI,CAACvP,OAAO,CAAC2Q,IAAI,CAAC,EAAE;IAClB,OAAOzI,SAAS;EAClB;EAEA,MAAM4H,KAAK,GAAGa,IAAI,CAACZ,YAAY,CAACR,aAAa,CAAC;EAC9C,IAAIO,KAAK,KAAK,IAAI,EAAE;IAClB,MAAM1C,MAAM,GAAGyE,UAAU,CAAC/B,KAAK,CAAC;IAChC,OAAO,CAACkC,KAAK,CAAC5E,MAAM,CAAC,GAAGA,MAAM,GAAGlF,SAAS;EAC5C;EACA,OAAOA,SAAS;AAClB;AAEA,SAAS6I,oBAAoBA,CAACJ,IAAI,EAAEpB,aAAa,EAAE;EACjD,IAAI,CAACvP,OAAO,CAAC2Q,IAAI,CAAC,EAAE;IAClB,OAAOzI,SAAS;EAClB;EACA,MAAM4H,KAAK,GAAGa,IAAI,CAACZ,YAAY,CAACR,aAAa,CAAC;EAC9C,OAAOO,KAAK,KAAK,IAAI,GAAGA,KAAK,GAAG5H,SAAS;AAC3C;AAEA,SAASqK,cAAcA,CAAC5B,IAAI,EAAE6B,OAAO,EAAE/D,SAAS,EAAE;EAChD,IAAI,CAACzO,OAAO,CAAC2Q,IAAI,CAAC,EAAE;IAClB,OAAOzI,SAAS;EAClB;EACA,MAAMuK,UAAU,GAAG9B,IAAI,CAAC8B,UAAU;EAClC,MAAMjH,MAAM,GAAGiH,UAAU,CAACjH,MAAM;EAChC,KAAK,IAAIkH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlH,MAAM,EAAEkH,CAAC,EAAE,EAAE;IAC/B,MAAMtG,KAAK,GAAGqG,UAAU,CAACC,CAAC,CAAC;IAC3B,IACEtG,KAAK,CAACE,SAAS,KAAKkG,OAAO,IAC3B/D,SAAS,CAAClC,OAAO,CAACH,KAAK,CAACI,YAAY,CAAC,KAAK,CAAC,CAAC,EAC5C;MACA,OAAOJ,KAAK;IACd;EACF;EACA,OAAOlE,SAAS;AAClB;AAEA,SAASyK,UAAUA,CAAChC,IAAI,EAAE6B,OAAO,EAAE/D,SAAS,EAAE;EAC5C,IAAI,CAACzO,OAAO,CAAC2Q,IAAI,CAAC,EAAE;IAClB,OAAOzI,SAAS;EAClB;EACA,MAAMkF,MAAM,GAAG,EAAE;EACjB,MAAMqF,UAAU,GAAG9B,IAAI,CAACiC,sBAAsB,CAAC,GAAG,EAAEJ,OAAO,CAAC;EAC5D,MAAMhH,MAAM,GAAGiH,UAAU,CAACjH,MAAM;EAChC,KAAK,IAAIkH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlH,MAAM,EAAEkH,CAAC,EAAE,EAAE;IAC/B,MAAMtG,KAAK,GAAGqG,UAAU,CAACC,CAAC,CAAC;IAC3B,IACEtG,KAAK,CAACE,SAAS,KAAKkG,OAAO,IAC3B/D,SAAS,CAAClC,OAAO,CAACH,KAAK,CAACI,YAAY,CAAC,KAAK,CAAC,CAAC,EAC5C;MACAY,MAAM,CAACvC,IAAI,CAACuB,KAAK,CAAC;IACpB;EACF;EACA,OAAOgB,MAAM;AACf;AAEA,SAASyF,eAAeA,CAAClC,IAAI,EAAE6B,OAAO,EAAE/D,SAAS,EAAE;EACjD,IAAI,CAACzO,OAAO,CAAC2Q,IAAI,CAAC,EAAE;IAClB,OAAO,EAAE;EACX;EACA,MAAMvD,MAAM,GAAG,EAAE;EACjB,MAAMqF,UAAU,GAAG9B,IAAI,CAAC8B,UAAU;EAClC,MAAMjH,MAAM,GAAGiH,UAAU,CAACjH,MAAM;EAChC,KAAK,IAAIkH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlH,MAAM,EAAEkH,CAAC,EAAE,EAAE;IAC/B,MAAMtG,KAAK,GAAGqG,UAAU,CAACC,CAAC,CAAC;IAC3B,IACEtG,KAAK,CAACE,SAAS,KAAKkG,OAAO,IAC3B/D,SAAS,CAAClC,OAAO,CAACH,KAAK,CAACI,YAAY,CAAC,KAAK,CAAC,CAAC,EAC5C;MACAY,MAAM,CAACvC,IAAI,CAACuB,KAAK,CAAC;IACpB;EACF;EACA,OAAOgB,MAAM;AACf;AAEA,SAAS0F,iBAAiBA,CAACnC,IAAI,EAAE6B,OAAO,EAAE/D,SAAS,EAAE;EACnD,MAAMsE,UAAU,GAAGR,cAAc,CAAC5B,IAAI,EAAE6B,OAAO,EAAE/D,SAAS,CAAC;EAC3D,IAAIzO,OAAO,CAAC+S,UAAU,CAAC,EAAE;IACvB,MAAM3F,MAAM,GAAGyE,UAAU,CAACkB,UAAU,CAACZ,WAAW,CAAC;IACjD,OAAO,CAACH,KAAK,CAAC5E,MAAM,CAAC,GAAGA,MAAM,GAAGlF,SAAS;EAC5C;EACA,OAAOA,SAAS;AAClB;AAEA,SAAS8K,gBAAgBA,CAACrC,IAAI,EAAE6B,OAAO,EAAE/D,SAAS,EAAE;EAClD,MAAMrB,MAAM,GAAGmF,cAAc,CAAC5B,IAAI,EAAE6B,OAAO,EAAE/D,SAAS,CAAC;EACvD,IAAIzO,OAAO,CAACoN,MAAM,CAAC,EAAE;IACnB,OAAOA,MAAM,CAAC+E,WAAW,CAACc,IAAI,CAAC,CAAC;EAClC;EACA,OAAO/K,SAAS;AAClB;AAEA,SAASgL,iBAAiBA,CAACvC,IAAI,EAAE6B,OAAO,EAAE/D,SAAS,EAAE;EACnD,MAAMrB,MAAM,GAAGmF,cAAc,CAAC5B,IAAI,EAAE6B,OAAO,EAAE/D,SAAS,CAAC;EACvD,IAAIzO,OAAO,CAACoN,MAAM,CAAC,EAAE;IACnB,MAAM0C,KAAK,GAAG1C,MAAM,CAAC+E,WAAW,CAACc,IAAI,CAAC,CAAC;IACvC,OAAOnD,KAAK,KAAK,GAAG,IAAI,SAAS,CAACzB,IAAI,CAACyB,KAAK,CAAC;EAC/C;EACA,OAAO5H,SAAS;AAClB;AAEA,SAASsI,WAAWA,CAAC2C,IAAI,EAAE7C,cAAc,EAAExB,WAAW,EAAE;EACtD,IAAI,CAAC9O,OAAO,CAACmT,IAAI,CAAC,EAAE;IAClB,OAAOjL,SAAS;EAClB;EAEA,IAAIqI,QAAQ;EACZ,IAAIvQ,OAAO,CAAC8O,WAAW,CAAC,EAAE;IACxB;IACAqE,IAAI,GAAGA,IAAI,CAACC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;IAC/B,IAAI1G,IAAI,GAAGoC,WAAW,CAACqE,IAAI,CAAC;IAC5B,IAAInT,OAAO,CAAC0M,IAAI,CAAC,EAAE;MACjB6D,QAAQ,GAAG,IAAIpP,QAAQ,CAAC;QACtBsP,GAAG,EAAE/D;MACP,CAAC,CAAC;IACJ,CAAC,MAAM;MACL;MACA,MAAM+C,OAAO,GAAG,IAAI7N,GAAG,CAAC0O,cAAc,CAAC+C,eAAe,CAAC,CAAC,CAAC;MACzD,MAAMpD,GAAG,GAAG,IAAIrO,GAAG,CAACuR,IAAI,CAAC;MACzBzG,IAAI,GAAGoC,WAAW,CAACmB,GAAG,CAACC,UAAU,CAACT,OAAO,CAAC,CAAC;MAC3C,IAAIzP,OAAO,CAAC0M,IAAI,CAAC,EAAE;QACjB6D,QAAQ,GAAG,IAAIpP,QAAQ,CAAC;UACtBsP,GAAG,EAAE/D;QACP,CAAC,CAAC;MACJ;IACF;EACF;EAEA,IAAI,CAAC1M,OAAO,CAACuQ,QAAQ,CAAC,EAAE;IACtBA,QAAQ,GAAGD,cAAc,CAACgD,kBAAkB,CAAC;MAC3C7C,GAAG,EAAE0C;IACP,CAAC,CAAC;EACJ;EAEA,OAAO5C,QAAQ;AACjB;AAEA,MAAMgD,YAAY,GAAG;EACnBC,UAAU,EAAEtL,SAAS;EACrBuL,GAAG,EAAEvL,SAAS;EACdwL,YAAY,EAAExL,SAAS;EACvByL,KAAK,EAAEzL,SAAS;EAChB0L,WAAW,EAAE1L,SAAS;EACtB2L,IAAI,EAAE3L;AACR,CAAC;AAED,SAAS4L,gBAAgBA,CAAChE,KAAK,EAAEiE,QAAQ,EAAE;EACzC,IAAI,CAAC/T,OAAO,CAAC8P,KAAK,CAAC,IAAI,SAAS,CAACzB,IAAI,CAACyB,KAAK,CAAC,EAAE;IAC5C,OAAO5H,SAAS;EAClB;EAEA,IAAI4H,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;IACpBA,KAAK,GAAGA,KAAK,CAACkE,SAAS,CAAC,CAAC,CAAC;EAC5B;EAEA,MAAMC,KAAK,GAAGC,QAAQ,CAACpE,KAAK,CAACkE,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,KAAK;EACzD,MAAMH,IAAI,GAAGK,QAAQ,CAACpE,KAAK,CAACkE,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,KAAK;EACxD,MAAML,KAAK,GAAGO,QAAQ,CAACpE,KAAK,CAACkE,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,KAAK;EACzD,MAAMP,GAAG,GAAGS,QAAQ,CAACpE,KAAK,CAACkE,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,KAAK;EAEvD,IAAI,CAACD,QAAQ,EAAE;IACb,OAAO,IAAIpU,KAAK,CAAC8T,GAAG,EAAEE,KAAK,EAAEE,IAAI,EAAEI,KAAK,CAAC;EAC3C;EAEA,IAAIR,GAAG,GAAG,CAAC,EAAE;IACXF,YAAY,CAACC,UAAU,GAAGC,GAAG;IAC7BF,YAAY,CAACE,GAAG,GAAGvL,SAAS;EAC9B,CAAC,MAAM;IACLqL,YAAY,CAACC,UAAU,GAAGtL,SAAS;IACnCqL,YAAY,CAACE,GAAG,GAAG,CAAC;EACtB;EACA,IAAIE,KAAK,GAAG,CAAC,EAAE;IACbJ,YAAY,CAACG,YAAY,GAAGC,KAAK;IACjCJ,YAAY,CAACI,KAAK,GAAGzL,SAAS;EAChC,CAAC,MAAM;IACLqL,YAAY,CAACG,YAAY,GAAGxL,SAAS;IACrCqL,YAAY,CAACI,KAAK,GAAG,CAAC;EACxB;EACA,IAAIE,IAAI,GAAG,CAAC,EAAE;IACZN,YAAY,CAACK,WAAW,GAAGC,IAAI;IAC/BN,YAAY,CAACM,IAAI,GAAG3L,SAAS;EAC/B,CAAC,MAAM;IACLqL,YAAY,CAACK,WAAW,GAAG1L,SAAS;IACpCqL,YAAY,CAACM,IAAI,GAAG,CAAC;EACvB;EACAN,YAAY,CAACU,KAAK,GAAGA,KAAK;EAC1B,OAAOtU,KAAK,CAACwU,UAAU,CAACZ,YAAY,CAAC;AACvC;AAEA,SAASa,eAAeA,CAACzD,IAAI,EAAE6B,OAAO,EAAE/D,SAAS,EAAE;EACjD,MAAMqB,KAAK,GAAGkD,gBAAgB,CAACrC,IAAI,EAAE6B,OAAO,EAAE/D,SAAS,CAAC;EACxD,IAAI,CAACzO,OAAO,CAAC8P,KAAK,CAAC,EAAE;IACnB,OAAO5H,SAAS;EAClB;EACA,OAAO4L,gBAAgB,CACrBhE,KAAK,EACLkD,gBAAgB,CAACrC,IAAI,EAAE,WAAW,EAAElC,SAAS,CAAC,KAAK,QACrD,CAAC;AACH;AAEA,SAAS4F,gBAAgBA,CAACC,WAAW,EAAE;EACrC,MAAM3D,IAAI,GAAG4B,cAAc,CAAC+B,WAAW,EAAE,WAAW,EAAEjM,UAAU,CAACI,KAAK,CAAC;EACvE,MAAM8L,UAAU,GAAGvB,gBAAgB,CAACrC,IAAI,EAAE,MAAM,EAAEtI,UAAU,CAACI,KAAK,CAAC;EAEnE,IAAI,CAACzI,OAAO,CAAC2Q,IAAI,CAAC,IAAI,CAAC3Q,OAAO,CAACuU,UAAU,CAAC,IAAIA,UAAU,CAAC/I,MAAM,KAAK,CAAC,EAAE;IACrE,OAAOtD,SAAS;EAClB;;EAEA;EACA;EACA;EACA;EACA;EACA,MAAMsM,IAAI,GAAG9T,UAAU,CAAC+T,WAAW,CAACF,UAAU,CAAC;EAC/C,MAAMnH,MAAM,GAAG,IAAI9L,sBAAsB,CAAC,CAAC;EAC3C8L,MAAM,CAACsH,WAAW,CAChB,IAAIrT,YAAY,CAAC;IACfsT,KAAK,EAAEH,IAAI;IACXI,IAAI,EAAEnU,OAAO,CAACoU;EAChB,CAAC,CACH,CAAC;EACD,OAAOzH,MAAM;AACf;AAEA,SAAS0H,eAAeA,CAACR,WAAW,EAAE;EACpC,MAAM3D,IAAI,GAAG4B,cAAc,CAAC+B,WAAW,EAAE,UAAU,EAAEjM,UAAU,CAACI,KAAK,CAAC;EACtE,IAAI,CAACzI,OAAO,CAAC2Q,IAAI,CAAC,EAAE;IAClB,OAAOzI,SAAS;EAClB;EACA,IAAIkF,MAAM;EAEV,MAAM2H,SAAS,GAAGxC,cAAc,CAAC5B,IAAI,EAAE,OAAO,EAAEtI,UAAU,CAACI,KAAK,CAAC;EACjE,IAAIuM,SAAS,GAAGhV,OAAO,CAAC+U,SAAS,CAAC,GAC9BrU,UAAU,CAAC+T,WAAW,CAACM,SAAS,CAAC5C,WAAW,CAAC,GAC7CjK,SAAS;EAEb,MAAM+M,OAAO,GAAG1C,cAAc,CAAC5B,IAAI,EAAE,KAAK,EAAEtI,UAAU,CAACI,KAAK,CAAC;EAC7D,IAAIyM,OAAO,GAAGlV,OAAO,CAACiV,OAAO,CAAC,GAC1BvU,UAAU,CAAC+T,WAAW,CAACQ,OAAO,CAAC9C,WAAW,CAAC,GAC3CjK,SAAS;EAEb,IAAIlI,OAAO,CAACgV,SAAS,CAAC,IAAIhV,OAAO,CAACkV,OAAO,CAAC,EAAE;IAC1C,IAAIxU,UAAU,CAACyU,QAAQ,CAACD,OAAO,EAAEF,SAAS,CAAC,EAAE;MAC3C,MAAMI,GAAG,GAAGJ,SAAS;MACrBA,SAAS,GAAGE,OAAO;MACnBA,OAAO,GAAGE,GAAG;IACf;IACAhI,MAAM,GAAG,IAAI9L,sBAAsB,CAAC,CAAC;IACrC8L,MAAM,CAACsH,WAAW,CAChB,IAAIrT,YAAY,CAAC;MACfsT,KAAK,EAAEK,SAAS;MAChBJ,IAAI,EAAEM;IACR,CAAC,CACH,CAAC;EACH,CAAC,MAAM,IAAIlV,OAAO,CAACgV,SAAS,CAAC,EAAE;IAC7B5H,MAAM,GAAG,IAAI9L,sBAAsB,CAAC,CAAC;IACrC8L,MAAM,CAACsH,WAAW,CAChB,IAAIrT,YAAY,CAAC;MACfsT,KAAK,EAAEK,SAAS;MAChBJ,IAAI,EAAEnU,OAAO,CAACoU;IAChB,CAAC,CACH,CAAC;EACH,CAAC,MAAM,IAAI7U,OAAO,CAACkV,OAAO,CAAC,EAAE;IAC3B9H,MAAM,GAAG,IAAI9L,sBAAsB,CAAC,CAAC;IACrC8L,MAAM,CAACsH,WAAW,CAChB,IAAIrT,YAAY,CAAC;MACfsT,KAAK,EAAElU,OAAO,CAAC4U,aAAa;MAC5BT,IAAI,EAAEM;IACR,CAAC,CACH,CAAC;EACH;EAEA,OAAO9H,MAAM;AACf;AAEA,SAASkI,sBAAsBA,CAAA,EAAG;EAChC,MAAMC,SAAS,GAAG,IAAIpT,iBAAiB,CAAC,CAAC;EACzCoT,SAAS,CAACC,KAAK,GAAG5N,cAAc;EAChC2N,SAAS,CAACxD,MAAM,GAAGnK,cAAc;EACjC2N,SAAS,CAACE,eAAe,GAAG,IAAI7U,aAAa,CAC3CiH,uBAAuB,EACvBC,oBAAoB,EACpBC,sBAAsB,EACtBC,mBACF,CAAC;EACDuN,SAAS,CAACG,0BAA0B,GAAG,IAAI9U,aAAa,CACtDiH,uBAAuB,EACvBC,oBAAoB,EACpBC,sBAAsB,EACtBC,mBACF,CAAC;EACD,OAAOuN,SAAS;AAClB;AAEA,SAASI,oBAAoBA,CAAA,EAAG;EAC9B,MAAMC,OAAO,GAAG,IAAI3S,eAAe,CAAC,CAAC;EACrC2S,OAAO,CAACC,OAAO,GAAG,IAAI;EACtBD,OAAO,CAACE,YAAY,GAAGnW,KAAK,CAACoW,KAAK;EAClC,OAAOH,OAAO;AAChB;AAEA,SAASI,kBAAkBA,CAAA,EAAG;EAC5B,MAAMC,KAAK,GAAG,IAAIlT,aAAa,CAAC,CAAC;EACjCkT,KAAK,CAACC,sBAAsB,GAAG,IAAItV,aAAa,CAAC,OAAO,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,CAAC;EAC5EqV,KAAK,CAACE,WAAW,GAAG,IAAI9W,UAAU,CAAC,EAAE,EAAE,CAAC,CAAC;EACzC4W,KAAK,CAACG,gBAAgB,GAAG5U,gBAAgB,CAAC6U,IAAI;EAC9CJ,KAAK,CAACK,IAAI,GAAG,iBAAiB;EAC9BL,KAAK,CAACM,KAAK,GAAG9U,UAAU,CAAC+U,gBAAgB;EACzC,OAAOP,KAAK;AACd;AAEA,SAASQ,WAAWA,CAClBC,QAAQ,EACR7M,UAAU,EACVyG,cAAc,EACdxB,WAAW,EACX6H,UAAU,EACV;EACA,IAAIxD,IAAI,GAAGH,gBAAgB,CAAC0D,QAAQ,EAAE,MAAM,EAAErO,UAAU,CAACC,GAAG,CAAC;EAC7D,IAAI,CAACtI,OAAO,CAACmT,IAAI,CAAC,IAAIA,IAAI,CAAC3H,MAAM,KAAK,CAAC,EAAE;IACvC,OAAOtD,SAAS;EAClB;EAEA,IAAIiL,IAAI,CAAC5G,OAAO,CAAC,uBAAuB,CAAC,KAAK,CAAC,EAAE;IAC/C,MAAMqK,OAAO,GAAGzD,IAAI,CAAC0D,MAAM,CAAC,EAAE,CAAC;;IAE/B;IACA,IAAIC,CAAC,GAAGhE,iBAAiB,CAAC4D,QAAQ,EAAE,GAAG,EAAErO,UAAU,CAACE,EAAE,CAAC,IAAI,CAAC;IAC5D,IAAIwO,CAAC,GAAGjE,iBAAiB,CAAC4D,QAAQ,EAAE,GAAG,EAAErO,UAAU,CAACE,EAAE,CAAC,IAAI,CAAC;IAC5DuO,CAAC,GAAGjK,IAAI,CAACC,GAAG,CAACgK,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;IACvBC,CAAC,GAAG,CAAC,GAAGlK,IAAI,CAACC,GAAG,CAACiK,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;IAC3B,MAAMC,OAAO,GAAG,CAAC,GAAGD,CAAC,GAAGD,CAAC;IAEzB3D,IAAI,GAAG,2CAA2CyD,OAAO,QAAQI,OAAO,MAAM;EAChF;EAEA,MAAMC,YAAY,GAAGzG,WAAW,CAAC2C,IAAI,EAAE7C,cAAc,EAAExB,WAAW,CAAC;EAEnE,IAAI6H,UAAU,EAAE;IACd,MAAMO,WAAW,GAAGlE,gBAAgB,CAClC0D,QAAQ,EACR,aAAa,EACbrO,UAAU,CAACC,GACb,CAAC;IACD,MAAM6O,eAAe,GAAGnE,gBAAgB,CACtC0D,QAAQ,EACR,iBAAiB,EACjBrO,UAAU,CAACC,GACb,CAAC;IACD,IAAI4O,WAAW,KAAK,YAAY,IAAIA,WAAW,KAAK,UAAU,EAAE;MAC9DpW,cAAc,CACZ,mBAAmBoW,WAAW,EAAE,EAChC,uCAAuCA,WAAW,EACpD,CAAC;IACH,CAAC,MAAM,IAAIC,eAAe,KAAK,QAAQ,IAAIA,eAAe,KAAK,UAAU,EAAE;MACzErW,cAAc,CACZ,mBAAmBqW,eAAe,EAAE,EACpC,2CAA2CA,eAAe,EAC5D,CAAC;IACH;IAEA,MAAMC,cAAc,GAClBpE,gBAAgB,CAAC0D,QAAQ,EAAE,gBAAgB,EAAErO,UAAU,CAACC,GAAG,CAAC,IAAI,GAAG;IACrE,MAAM+O,iBAAiB,GACrBF,eAAe,KAAK,QAAQ,GACxB,oDAAoD,GACpD,EAAE;IACR,MAAMG,UAAU,GACdtE,gBAAgB,CAAC0D,QAAQ,EAAE,YAAY,EAAErO,UAAU,CAACC,GAAG,CAAC,IACxD+O,iBAAiB;IACnB,MAAME,SAAS,GAAGvE,gBAAgB,CAAC0D,QAAQ,EAAE,WAAW,EAAErO,UAAU,CAACC,GAAG,CAAC;IACzE,IAAItI,OAAO,CAACsX,UAAU,CAAC,EAAE;MACvBL,YAAY,CAACO,kBAAkB,CAACvW,aAAa,CAACwW,aAAa,CAACH,UAAU,CAAC,CAAC,CAAC;IAC3E;IACA,IAAItX,OAAO,CAACuX,SAAS,CAAC,EAAE;MACtBN,YAAY,CAACO,kBAAkB,CAACvW,aAAa,CAACwW,aAAa,CAACF,SAAS,CAAC,CAAC,CAAC;IAC1E;IAEA,MAAM9F,SAAS,GAAG5H,UAAU,CAAC6N,UAAU;IACvCC,6BAA6B,CAC3BV,YAAY,EACZpN,UAAU,CAAC+N,MAAM,EACjB/N,UAAU,CAACgO,MAAM,EACjBT,cAAc,EACdvN,UAAU,CAACiO,eAAe,CAACC,IAAI,EAC/BtG,SACF,CAAC;IAED,OAAOwF,YAAY;EACrB;EAEA,OAAOA,YAAY;AACrB;AAEA,SAASe,oBAAoBA,CAC3BnO,UAAU,EACV8G,IAAI,EACJsH,YAAY,EACZ3H,cAAc,EACdxB,WAAW,EACX;EACA,IAAIoJ,KAAK,GAAGpF,iBAAiB,CAACnC,IAAI,EAAE,OAAO,EAAEtI,UAAU,CAACC,GAAG,CAAC;EAC5D,MAAM6P,OAAO,GAAGrF,iBAAiB,CAACnC,IAAI,EAAE,SAAS,EAAEtI,UAAU,CAACC,GAAG,CAAC;EAClE,MAAM8P,KAAK,GAAGhE,eAAe,CAACzD,IAAI,EAAE,OAAO,EAAEtI,UAAU,CAACC,GAAG,CAAC;EAE5D,MAAMoO,QAAQ,GAAGnE,cAAc,CAAC5B,IAAI,EAAE,MAAM,EAAEtI,UAAU,CAACC,GAAG,CAAC;EAC7D,IAAI+P,IAAI,GAAG5B,WAAW,CACpBC,QAAQ,EACR7M,UAAU,EACVyG,cAAc,EACdxB,WAAW,EACX,KACF,CAAC;;EAED;EACA,IAAI9O,OAAO,CAAC0W,QAAQ,CAAC,IAAI,CAAC1W,OAAO,CAACqY,IAAI,CAAC,EAAE;IACvCA,IAAI,GAAG,KAAK;EACd;EAEA,MAAMvB,CAAC,GAAGhE,iBAAiB,CAAC4D,QAAQ,EAAE,GAAG,EAAErO,UAAU,CAACE,EAAE,CAAC;EACzD,MAAMwO,CAAC,GAAGjE,iBAAiB,CAAC4D,QAAQ,EAAE,GAAG,EAAErO,UAAU,CAACE,EAAE,CAAC;EACzD,MAAM+P,CAAC,GAAGxF,iBAAiB,CAAC4D,QAAQ,EAAE,GAAG,EAAErO,UAAU,CAACE,EAAE,CAAC;EACzD,MAAMgQ,CAAC,GAAGzF,iBAAiB,CAAC4D,QAAQ,EAAE,GAAG,EAAErO,UAAU,CAACE,EAAE,CAAC;EAEzD,MAAMiQ,WAAW,GAAGjG,cAAc,CAAC5B,IAAI,EAAE,SAAS,EAAEtI,UAAU,CAACC,GAAG,CAAC;EACnE,MAAMmQ,QAAQ,GAAGnG,qBAAqB,CAACkG,WAAW,EAAE,GAAG,CAAC;EACxD,MAAME,QAAQ,GAAGpG,qBAAqB,CAACkG,WAAW,EAAE,GAAG,CAAC;EACxD,MAAMG,YAAY,GAAG5H,oBAAoB,CAACyH,WAAW,EAAE,QAAQ,CAAC;EAChE,MAAMI,YAAY,GAAG7H,oBAAoB,CAACyH,WAAW,EAAE,QAAQ,CAAC;EAEhE,IAAIjD,SAAS,GAAG0C,YAAY,CAAC1C,SAAS;EACtC,IAAI,CAACvV,OAAO,CAACuV,SAAS,CAAC,EAAE;IACvBA,SAAS,GAAGD,sBAAsB,CAAC,CAAC;IACpC2C,YAAY,CAAC1C,SAAS,GAAGA,SAAS;EACpC;EAEAA,SAAS,CAACsD,KAAK,GAAGR,IAAI;EACtB9C,SAAS,CAAC2C,KAAK,GAAGA,KAAK;EACvB3C,SAAS,CAAC6C,KAAK,GAAGA,KAAK;EAEvB,IAAIpY,OAAO,CAAC8W,CAAC,CAAC,IAAI9W,OAAO,CAAC+W,CAAC,CAAC,IAAI/W,OAAO,CAACsY,CAAC,CAAC,IAAItY,OAAO,CAACuY,CAAC,CAAC,EAAE;IACxDhD,SAAS,CAACuD,cAAc,GAAG,IAAI3Z,iBAAiB,CAAC2X,CAAC,EAAEC,CAAC,EAAEuB,CAAC,EAAEC,CAAC,CAAC;EAC9D;;EAEA;EACA;EACA,IAAIvY,OAAO,CAACmY,OAAO,CAAC,IAAIA,OAAO,KAAK,CAAC,EAAE;IACrC5C,SAAS,CAACwD,QAAQ,GAAGpY,UAAU,CAACqY,SAAS,CAAC,CAACb,OAAO,CAAC;IACnD5C,SAAS,CAAC0D,WAAW,GAAG3Z,UAAU,CAAC4Z,MAAM;EAC3C;;EAEA;EACA;EACA;EACA;EACAhB,KAAK,GAAGA,KAAK,IAAI,GAAG;EAEpB,IAAIiB,OAAO;EACX,IAAIC,OAAO;EACX,IAAIpZ,OAAO,CAACyY,QAAQ,CAAC,EAAE;IACrB,IAAIE,YAAY,KAAK,QAAQ,EAAE;MAC7BQ,OAAO,GAAG,CAACV,QAAQ,GAAGP,KAAK;IAC7B,CAAC,MAAM,IAAIS,YAAY,KAAK,aAAa,EAAE;MACzCQ,OAAO,GAAG,CAACV,QAAQ,GAAG7Q,cAAc,IAAIsQ,KAAK;IAC/C,CAAC,MAAM,IAAIS,YAAY,KAAK,UAAU,EAAE;MACtCQ,OAAO,GAAG,CAACV,QAAQ,GAAG7Q,cAAc,GAAGsQ,KAAK;IAC9C;IACAiB,OAAO,IAAIvR,cAAc,GAAG,GAAG,GAAGsQ,KAAK;EACzC;EAEA,IAAIlY,OAAO,CAAC0Y,QAAQ,CAAC,EAAE;IACrB,IAAIE,YAAY,KAAK,QAAQ,EAAE;MAC7BQ,OAAO,GAAGV,QAAQ,GAAGR,KAAK;IAC5B,CAAC,MAAM,IAAIU,YAAY,KAAK,aAAa,EAAE;MACzCQ,OAAO,GAAG,CAAC,CAACV,QAAQ,GAAG9Q,cAAc,IAAIsQ,KAAK;IAChD,CAAC,MAAM,IAAIU,YAAY,KAAK,UAAU,EAAE;MACtCQ,OAAO,GAAGV,QAAQ,GAAG9Q,cAAc,GAAGsQ,KAAK;IAC7C;IAEAkB,OAAO,IAAIxR,cAAc,GAAG,GAAG,GAAGsQ,KAAK;EACzC;EAEA,IAAIlY,OAAO,CAACmZ,OAAO,CAAC,IAAInZ,OAAO,CAACoZ,OAAO,CAAC,EAAE;IACxC7D,SAAS,CAACY,WAAW,GAAG,IAAI9W,UAAU,CAAC8Z,OAAO,EAAEC,OAAO,CAAC;EAC1D;AACF;AAEA,SAASC,UAAUA,CACjBxP,UAAU,EACVyP,SAAS,EACTrB,YAAY,EACZ3H,cAAc,EACdxB,WAAW,EACX;EACA,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAE2J,GAAG,GAAGD,SAAS,CAAC7G,UAAU,CAACjH,MAAM,EAAEoE,CAAC,GAAG2J,GAAG,EAAE3J,CAAC,EAAE,EAAE;IAC/D,MAAMe,IAAI,GAAG2I,SAAS,CAAC7G,UAAU,CAAC+G,IAAI,CAAC5J,CAAC,CAAC;IACzC,IAAIe,IAAI,CAACrE,SAAS,KAAK,WAAW,EAAE;MAClC0L,oBAAoB,CAClBnO,UAAU,EACV8G,IAAI,EACJsH,YAAY,EACZ3H,cAAc,EACdxB,WACF,CAAC;IACH,CAAC,MAAM,IAAI6B,IAAI,CAACrE,SAAS,KAAK,YAAY,EAAE;MAC1C,IAAI2J,KAAK,GAAGgC,YAAY,CAAChC,KAAK;MAC9B,IAAI,CAACjW,OAAO,CAACiW,KAAK,CAAC,EAAE;QACnBA,KAAK,GAAGD,kBAAkB,CAAC,CAAC;QAC5BiC,YAAY,CAAChC,KAAK,GAAGA,KAAK;MAC5B;MACAA,KAAK,CAACiC,KAAK,GACTpF,iBAAiB,CAACnC,IAAI,EAAE,OAAO,EAAEtI,UAAU,CAACC,GAAG,CAAC,IAAI2N,KAAK,CAACiC,KAAK;MACjEjC,KAAK,CAACwD,SAAS,GACbrF,eAAe,CAACzD,IAAI,EAAE,OAAO,EAAEtI,UAAU,CAACC,GAAG,CAAC,IAAI2N,KAAK,CAACwD,SAAS;MACnExD,KAAK,CAAC1P,IAAI,GAAG0R,YAAY,CAACyB,IAAI;IAChC,CAAC,MAAM,IAAI/I,IAAI,CAACrE,SAAS,KAAK,WAAW,EAAE;MACzC,IAAIqN,QAAQ,GAAG1B,YAAY,CAAC0B,QAAQ;MACpC,IAAI,CAAC3Z,OAAO,CAAC2Z,QAAQ,CAAC,EAAE;QACtBA,QAAQ,GAAG,IAAIzW,gBAAgB,CAAC,CAAC;QACjC+U,YAAY,CAAC0B,QAAQ,GAAGA,QAAQ;MAClC;MACAA,QAAQ,CAACnE,KAAK,GAAG1C,iBAAiB,CAACnC,IAAI,EAAE,OAAO,EAAEtI,UAAU,CAACC,GAAG,CAAC;MACjEqR,QAAQ,CAACC,QAAQ,GAAGxF,eAAe,CAACzD,IAAI,EAAE,OAAO,EAAEtI,UAAU,CAACC,GAAG,CAAC;MAClE,IAAItI,OAAO,CAACoU,eAAe,CAACzD,IAAI,EAAE,YAAY,EAAEtI,UAAU,CAACE,EAAE,CAAC,CAAC,EAAE;QAC/DzH,cAAc,CACZ,mBAAmB,EACnB,qDACF,CAAC;MACH;MACA,IAAId,OAAO,CAAC8S,iBAAiB,CAACnC,IAAI,EAAE,YAAY,EAAEtI,UAAU,CAACE,EAAE,CAAC,CAAC,EAAE;QACjEzH,cAAc,CACZ,mBAAmB,EACnB,qDACF,CAAC;MACH;MACA,IAAId,OAAO,CAAC8S,iBAAiB,CAACnC,IAAI,EAAE,eAAe,EAAEtI,UAAU,CAACE,EAAE,CAAC,CAAC,EAAE;QACpEzH,cAAc,CACZ,sBAAsB,EACtB,wDACF,CAAC;MACH;MACA,IAAId,OAAO,CAACkT,iBAAiB,CAACvC,IAAI,EAAE,iBAAiB,EAAEtI,UAAU,CAACE,EAAE,CAAC,CAAC,EAAE;QACtEzH,cAAc,CACZ,wBAAwB,EACxB,0DACF,CAAC;MACH;IACF,CAAC,MAAM,IAAI6P,IAAI,CAACrE,SAAS,KAAK,WAAW,EAAE;MACzC,IAAIsJ,OAAO,GAAGqC,YAAY,CAACrC,OAAO;MAClC,IAAI,CAAC5V,OAAO,CAAC4V,OAAO,CAAC,EAAE;QACrBA,OAAO,GAAGD,oBAAoB,CAAC,CAAC;QAChCsC,YAAY,CAACrC,OAAO,GAAGA,OAAO;MAChC;MACAA,OAAO,CAACgE,QAAQ,GACdxF,eAAe,CAACzD,IAAI,EAAE,OAAO,EAAEtI,UAAU,CAACC,GAAG,CAAC,IAAIsN,OAAO,CAACgE,QAAQ;MACpEhE,OAAO,CAACiE,IAAI,GACV3G,iBAAiB,CAACvC,IAAI,EAAE,MAAM,EAAEtI,UAAU,CAACC,GAAG,CAAC,IAAIsN,OAAO,CAACiE,IAAI;MACjEjE,OAAO,CAACC,OAAO,GACb3C,iBAAiB,CAACvC,IAAI,EAAE,SAAS,EAAEtI,UAAU,CAACC,GAAG,CAAC,IAAIsN,OAAO,CAACC,OAAO;IACzE,CAAC,MAAM,IAAIlF,IAAI,CAACrE,SAAS,KAAK,cAAc,EAAE;MAC5C,MAAMwN,OAAO,GACXhG,gBAAgB,CAACd,gBAAgB,CAACrC,IAAI,EAAE,SAAS,EAAEtI,UAAU,CAACC,GAAG,CAAC,CAAC,IACnE3I,KAAK,CAACoW,KAAK;MACb,MAAMgE,SAAS,GACbjG,gBAAgB,CAACd,gBAAgB,CAACrC,IAAI,EAAE,WAAW,EAAEtI,UAAU,CAACC,GAAG,CAAC,CAAC,IACrE3I,KAAK,CAACqa,KAAK;MACb,MAAMzT,IAAI,GAAGyM,gBAAgB,CAACrC,IAAI,EAAE,MAAM,EAAEtI,UAAU,CAACC,GAAG,CAAC;;MAE3D;MACA;MACA2P,YAAY,CAAC9G,WAAW,CAAC,cAAc,CAAC;MACxC8G,YAAY,CAACgC,YAAY,GAAG;QAC1BH,OAAO,EAAEA,OAAO;QAChBC,SAAS,EAAEA,SAAS;QACpBxT,IAAI,EAAEA;MACR,CAAC;IACH,CAAC,MAAM,IAAIoK,IAAI,CAACrE,SAAS,KAAK,WAAW,EAAE;MACzC,MAAM4N,YAAY,GAAGlH,gBAAgB,CACnCrC,IAAI,EACJ,cAAc,EACdtI,UAAU,CAACC,GACb,CAAC;MACD,IAAI4R,YAAY,KAAK,aAAa,IAAIA,YAAY,KAAK,cAAc,EAAE;QACrEpZ,cAAc,CACZ,iBAAiBoZ,YAAY,EAAE,EAC/B,kDAAkDA,YAAY,EAChE,CAAC;MACH;IACF;EACF;AACF;;AAEA;AACA,SAASC,iBAAiBA,CACxBtQ,UAAU,EACVuQ,SAAS,EACTC,eAAe,EACf/J,cAAc,EACdxB,WAAW,EACX;EACA,MAAM1B,MAAM,GAAG,IAAI7K,MAAM,CAAC,CAAC;EAC3B,IAAI+X,WAAW;;EAEf;EACA,IAAIC,UAAU,GAAG,CAAC,CAAC;EACnB,MAAM9H,UAAU,GAAG2H,SAAS,CAAC3H,UAAU;EACvC,MAAMjH,MAAM,GAAGiH,UAAU,CAACjH,MAAM;EAChC,KAAK,IAAIkH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlH,MAAM,EAAEkH,CAAC,EAAE,EAAE;IAC/B,MAAMtG,KAAK,GAAGqG,UAAU,CAACC,CAAC,CAAC;IAC3B,IAAItG,KAAK,CAACE,SAAS,KAAK,OAAO,IAAIF,KAAK,CAACE,SAAS,KAAK,UAAU,EAAE;MACjEiO,UAAU,GAAG7H,CAAC;IAChB;EACF;EAEA,IAAI6H,UAAU,KAAK,CAAC,CAAC,EAAE;IACrB,MAAMC,eAAe,GAAG/H,UAAU,CAAC8H,UAAU,CAAC;IAC9C,IAAIC,eAAe,CAAClO,SAAS,KAAK,OAAO,EAAE;MACzC+M,UAAU,CACRxP,UAAU,EACV2Q,eAAe,EACfpN,MAAM,EACNkD,cAAc,EACdxB,WACF,CAAC;IACH,CAAC,MAAM;MACL;MACA,MAAM2L,KAAK,GAAG5H,eAAe,CAAC2H,eAAe,EAAE,MAAM,EAAEnS,UAAU,CAACC,GAAG,CAAC;MACtE,KAAK,IAAIoS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,KAAK,CAACjP,MAAM,EAAEkP,CAAC,EAAE,EAAE;QACrC,MAAMC,IAAI,GAAGF,KAAK,CAACC,CAAC,CAAC;QACrB,MAAMxM,GAAG,GAAG8E,gBAAgB,CAAC2H,IAAI,EAAE,KAAK,EAAEtS,UAAU,CAACC,GAAG,CAAC;QACzD,IAAI4F,GAAG,KAAK,QAAQ,EAAE;UACpB,MAAM0M,QAAQ,GAAG5H,gBAAgB,CAAC2H,IAAI,EAAE,UAAU,EAAEtS,UAAU,CAACC,GAAG,CAAC;UACnE,IAAItI,OAAO,CAAC4a,QAAQ,CAAC,EAAE;YACrBN,WAAW,GAAGD,eAAe,CAACpJ,OAAO,CAAC2J,QAAQ,CAAC;YAC/C,IAAI,CAAC5a,OAAO,CAACsa,WAAW,CAAC,EAAE;cACzBA,WAAW,GAAGD,eAAe,CAACpJ,OAAO,CAAC,IAAI2J,QAAQ,EAAE,CAAC;YACvD;YACA,IAAI5a,OAAO,CAACsa,WAAW,CAAC,EAAE;cACxBlN,MAAM,CAACyN,KAAK,CAACP,WAAW,CAAC;YAC3B;UACF,CAAC,MAAM;YACL,MAAM3J,IAAI,GAAG4B,cAAc,CAACoI,IAAI,EAAE,OAAO,EAAEtS,UAAU,CAACC,GAAG,CAAC;YAC1D+Q,UAAU,CAACxP,UAAU,EAAE8G,IAAI,EAAEvD,MAAM,EAAEkD,cAAc,EAAExB,WAAW,CAAC;UACnE;QACF,CAAC,MAAM;UACLhO,cAAc,CACZ,gBAAgBoN,GAAG,EAAE,EACrB,mCAAmCA,GAAG,EACxC,CAAC;QACH;MACF;IACF;EACF;;EAEA;EACA,MAAM4M,aAAa,GAAG9H,gBAAgB,CAACoH,SAAS,EAAE,UAAU,EAAE/R,UAAU,CAACC,GAAG,CAAC;EAC7E,IAAItI,OAAO,CAAC8a,aAAa,CAAC,EAAE;IAC1B,IAAIhK,EAAE,GAAGgK,aAAa;IACtB,IAAIA,aAAa,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIA,aAAa,CAACvO,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;MACjE,MAAMwO,MAAM,GAAGD,aAAa,CAACE,KAAK,CAAC,GAAG,CAAC;MACvC,MAAM/K,GAAG,GAAG8K,MAAM,CAAC,CAAC,CAAC;MACrB,MAAMxK,QAAQ,GAAGD,cAAc,CAACgD,kBAAkB,CAAC;QACjD7C,GAAG,EAAER;MACP,CAAC,CAAC;MAEFa,EAAE,GAAG,GAAGP,QAAQ,CAAC8C,eAAe,CAAC,CAAC,IAAI0H,MAAM,CAAC,CAAC,CAAC,EAAE;IACnD;IAEAT,WAAW,GAAGD,eAAe,CAACpJ,OAAO,CAACH,EAAE,CAAC;IACzC,IAAI,CAAC9Q,OAAO,CAACsa,WAAW,CAAC,EAAE;MACzBA,WAAW,GAAGD,eAAe,CAACpJ,OAAO,CAAC,IAAIH,EAAE,EAAE,CAAC;IACjD;IACA,IAAI9Q,OAAO,CAACsa,WAAW,CAAC,EAAE;MACxBlN,MAAM,CAACyN,KAAK,CAACP,WAAW,CAAC;IAC3B;EACF;EAEA,OAAOlN,MAAM;AACf;;AAEA;AACA,SAAS6N,qBAAqBA,CAACpR,UAAU,EAAE0G,QAAQ,EAAE8J,eAAe,EAAE;EACpE,OAAO9J,QAAQ,CAAC2K,QAAQ,CAAC,CAAC,CAACC,IAAI,CAAC,UAAUC,QAAQ,EAAE;IAClD,OAAOC,aAAa,CAACxR,UAAU,EAAEuR,QAAQ,EAAEf,eAAe,EAAE9J,QAAQ,EAAE,IAAI,CAAC;EAC7E,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA,SAAS8K,aAAaA,CACpBxR,UAAU,EACVvB,GAAG,EACH+R,eAAe,EACf/J,cAAc,EACdgL,UAAU,EACVxM,WAAW,EACX;EACA,IAAIc,CAAC;EACL,IAAIkB,EAAE;EACN,IAAIwJ,WAAW;EAEf,IAAI3J,IAAI;EACR,MAAM4K,UAAU,GAAG5I,UAAU,CAACrK,GAAG,EAAE,OAAO,EAAED,UAAU,CAACC,GAAG,CAAC;EAC3D,IAAItI,OAAO,CAACub,UAAU,CAAC,EAAE;IACvB,MAAMC,gBAAgB,GAAGD,UAAU,CAAC/P,MAAM;IAC1C,KAAKoE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4L,gBAAgB,EAAE5L,CAAC,EAAE,EAAE;MACrCe,IAAI,GAAG4K,UAAU,CAAC3L,CAAC,CAAC;MACpBkB,EAAE,GAAGC,oBAAoB,CAACJ,IAAI,EAAE,IAAI,CAAC;MACrC,IAAI3Q,OAAO,CAAC8Q,EAAE,CAAC,EAAE;QACfA,EAAE,GAAG,IAAIA,EAAE,EAAE;QACb,IAAIwK,UAAU,IAAItb,OAAO,CAACsQ,cAAc,CAAC,EAAE;UACzCQ,EAAE,GAAGR,cAAc,CAAC+C,eAAe,CAAC,CAAC,GAAGvC,EAAE;QAC5C;QACA,IAAI,CAAC9Q,OAAO,CAACqa,eAAe,CAACpJ,OAAO,CAACH,EAAE,CAAC,CAAC,EAAE;UACzCwJ,WAAW,GAAG,IAAI/X,MAAM,CAAC;YACvBuO,EAAE,EAAEA;UACN,CAAC,CAAC;UACFuJ,eAAe,CAACnJ,GAAG,CAACoJ,WAAW,CAAC;UAChCjB,UAAU,CACRxP,UAAU,EACV8G,IAAI,EACJ2J,WAAW,EACXhK,cAAc,EACdxB,WACF,CAAC;QACH;MACF;IACF;EACF;EAEA,MAAM2M,SAAS,GAAG9I,UAAU,CAACrK,GAAG,EAAE,UAAU,EAAED,UAAU,CAACC,GAAG,CAAC;EAC7D,IAAItI,OAAO,CAACyb,SAAS,CAAC,EAAE;IACtB,MAAMC,eAAe,GAAGD,SAAS,CAACjQ,MAAM;IACxC,KAAKoE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8L,eAAe,EAAE9L,CAAC,EAAE,EAAE;MACpC,MAAM+L,QAAQ,GAAGF,SAAS,CAAC7L,CAAC,CAAC;MAC7BkB,EAAE,GAAGC,oBAAoB,CAAC4K,QAAQ,EAAE,IAAI,CAAC;MACzC,IAAI3b,OAAO,CAAC8Q,EAAE,CAAC,EAAE;QACf,MAAM2J,KAAK,GAAG5H,eAAe,CAAC8I,QAAQ,EAAE,MAAM,EAAEtT,UAAU,CAACC,GAAG,CAAC;QAC/D,KAAK,IAAIoS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,KAAK,CAACjP,MAAM,EAAEkP,CAAC,EAAE,EAAE;UACrC,MAAMC,IAAI,GAAGF,KAAK,CAACC,CAAC,CAAC;UACrB,MAAMxM,GAAG,GAAG8E,gBAAgB,CAAC2H,IAAI,EAAE,KAAK,EAAEtS,UAAU,CAACC,GAAG,CAAC;UACzD,IAAI4F,GAAG,KAAK,QAAQ,EAAE;YACpB4C,EAAE,GAAG,IAAIA,EAAE,EAAE;YACb,IAAIwK,UAAU,IAAItb,OAAO,CAACsQ,cAAc,CAAC,EAAE;cACzCQ,EAAE,GAAGR,cAAc,CAAC+C,eAAe,CAAC,CAAC,GAAGvC,EAAE;YAC5C;YACA,IAAI,CAAC9Q,OAAO,CAACqa,eAAe,CAACpJ,OAAO,CAACH,EAAE,CAAC,CAAC,EAAE;cACzCwJ,WAAW,GAAGD,eAAe,CAACuB,iBAAiB,CAAC9K,EAAE,CAAC;cAEnD,IAAI8J,QAAQ,GAAG5H,gBAAgB,CAAC2H,IAAI,EAAE,UAAU,EAAEtS,UAAU,CAACC,GAAG,CAAC;cACjE,IAAItI,OAAO,CAAC4a,QAAQ,CAAC,EAAE;gBACrB,IAAIA,QAAQ,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;kBACvBA,QAAQ,GAAG,IAAIA,QAAQ,EAAE;gBAC3B;gBAEA,IAAIU,UAAU,IAAItb,OAAO,CAACsQ,cAAc,CAAC,EAAE;kBACzCsK,QAAQ,GAAGtK,cAAc,CAAC+C,eAAe,CAAC,CAAC,GAAGuH,QAAQ;gBACxD;gBACA,MAAMiB,IAAI,GAAGxB,eAAe,CAACpJ,OAAO,CAAC2J,QAAQ,CAAC;gBAE9C,IAAI5a,OAAO,CAAC6b,IAAI,CAAC,EAAE;kBACjBvB,WAAW,CAACO,KAAK,CAACgB,IAAI,CAAC;gBACzB;cACF,CAAC,MAAM;gBACLlL,IAAI,GAAG4B,cAAc,CAACoI,IAAI,EAAE,OAAO,EAAEtS,UAAU,CAACC,GAAG,CAAC;gBACpD+Q,UAAU,CACRxP,UAAU,EACV8G,IAAI,EACJ2J,WAAW,EACXhK,cAAc,EACdxB,WACF,CAAC;cACH;YACF;UACF,CAAC,MAAM;YACLhO,cAAc,CACZ,gBAAgBoN,GAAG,EAAE,EACrB,mCAAmCA,GAAG,EACxC,CAAC;UACH;QACF;MACF;IACF;EACF;EAEA,MAAM4N,QAAQ,GAAG,EAAE;EACnB,MAAMC,aAAa,GAAGzT,GAAG,CAAC0T,oBAAoB,CAAC,UAAU,CAAC;EAC1D,MAAMC,mBAAmB,GAAGF,aAAa,CAACvQ,MAAM;EAChD,KAAKoE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqM,mBAAmB,EAAErM,CAAC,EAAE,EAAE;IACxC,MAAMsM,cAAc,GAAGH,aAAa,CAACnM,CAAC,CAAC,CAACuC,WAAW;IACnD,IAAI+J,cAAc,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;MAC7B;MACA;MACA;MACA;MACA,MAAMnB,MAAM,GAAGmB,cAAc,CAAClB,KAAK,CAAC,GAAG,CAAC;MACxC,IAAID,MAAM,CAACvP,MAAM,KAAK,CAAC,EAAE;QACvB,MAAMyE,GAAG,GAAG8K,MAAM,CAAC,CAAC,CAAC;QACrB,MAAMxK,QAAQ,GAAGD,cAAc,CAACgD,kBAAkB,CAAC;UACjD7C,GAAG,EAAER;QACP,CAAC,CAAC;QAEF6L,QAAQ,CAACjR,IAAI,CACXoQ,qBAAqB,CAACpR,UAAU,EAAE0G,QAAQ,EAAE8J,eAAe,CAC7D,CAAC;MACH;IACF;EACF;EAEA,OAAOyB,QAAQ;AACjB;AAEA,SAASK,cAAcA,CAACvL,gBAAgB,EAAEI,MAAM,EAAEsJ,WAAW,EAAE;EAC7D,MAAM8B,cAAc,GAAG,IAAI/Y,iBAAiB,CAACuN,gBAAgB,EAAEI,MAAM,CAACF,EAAE,EAAE,CACxE,UAAU,CACX,CAAC;EACF,MAAMuL,eAAe,GAAG,IAAI9Y,sBAAsB,CAACyN,MAAM,CAACsL,QAAQ,CAAC;EACnEtL,MAAM,CAAC2I,QAAQ,GAAG3Z,OAAO,CAACsa,WAAW,CAACX,QAAQ,CAAC,GAC3CW,WAAW,CAACX,QAAQ,CAACja,KAAK,CAAC,CAAC,GAC5B,IAAIwD,gBAAgB,CAAC,CAAC;EAC1B8N,MAAM,CAAC2I,QAAQ,CAAC4C,SAAS,GAAG,IAAIpZ,qBAAqB,CAAC,CACpDiZ,cAAc,EACdC,eAAe,CAChB,CAAC;AACJ;AAEA,SAASG,+BAA+BA,CAAClL,YAAY,EAAEC,cAAc,EAAE;EACrE,IACG,CAACvR,OAAO,CAACsR,YAAY,CAAC,IAAI,CAACtR,OAAO,CAACuR,cAAc,CAAC,IACnDD,YAAY,KAAK,eAAe,EAChC;IACA,OAAO/P,eAAe,CAACkb,eAAe;EACxC;EAEA,IAAInL,YAAY,KAAK,kBAAkB,EAAE;IACvC,OAAO/P,eAAe,CAACmb,kBAAkB;EAC3C;EAEA,IAAIpL,YAAY,KAAK,UAAU,EAAE;IAC/B,OAAO/P,eAAe,CAACob,IAAI;EAC7B;EAEA,IAAIpL,cAAc,KAAK,iBAAiB,EAAE;IACxCzQ,cAAc,CACZ,qCAAqC,EACrC,6GACF,CAAC;IACD,OAAOS,eAAe,CAACkb,eAAe;EACxC;EAEA,IAAIlL,cAAc,KAAK,oBAAoB,EAAE;IAC3CzQ,cAAc,CACZ,wCAAwC,EACxC,mHACF,CAAC;IACD,OAAOS,eAAe,CAACmb,kBAAkB;EAC3C;EAEA,IAAI1c,OAAO,CAACsR,YAAY,CAAC,EAAE;IACzBxQ,cAAc,CACZ,0BAA0B,EAC1B,oCAAoCwQ,YAAY,6CAClD,CAAC;EACH,CAAC,MAAM;IACLxQ,cAAc,CACZ,6BAA6B,EAC7B,mCAAmCyQ,cAAc,6CACnD,CAAC;EACH;;EAEA;EACA,OAAOhQ,eAAe,CAACkb,eAAe;AACxC;AAEA,SAASG,sCAAsCA,CAC7CC,QAAQ,EACRvL,YAAY,EACZC,cAAc,EACd;EACA,IACEA,cAAc,KAAK,oBAAoB,IACvCD,YAAY,KAAK,UAAU,IAC3BA,YAAY,KAAK,kBAAkB,EACnC;IACA;IACA,OAAOuL,QAAQ;EACjB;EAEA,IACG7c,OAAO,CAACsR,YAAY,CAAC,IAAIA,YAAY,KAAK,eAAe;EAAK;EAC9DtR,OAAO,CAACuR,cAAc,CAAC,IAAIA,cAAc,KAAK,iBAAkB,EACjE;IACAzQ,cAAc,CACZ,0BAA0B,EAC1B,+BAA+BwQ,YAAY,IAAIC,cAAc,EAC/D,CAAC;EACH;;EAEA;EACA,OAAO,IAAIhO,sBAAsB,CAACsZ,QAAQ,CAAC;AAC7C;AAEA,SAASC,2CAA2CA,CAClDC,UAAU,EACVzL,YAAY,EACZC,cAAc,EACdE,SAAS,EACT;EACA,IAAI,CAACzR,OAAO,CAAC+c,UAAU,CAAC,EAAE;IACxB,OAAO7U,SAAS;EAClB;EAEA,IACEqJ,cAAc,KAAK,oBAAoB,IACvCD,YAAY,KAAK,UAAU,IAC3BA,YAAY,KAAK,kBAAkB,EACnC;IACA;IACA,OAAOyL,UAAU;EACnB;EAEA,IACG/c,OAAO,CAACsR,YAAY,CAAC,IAAIA,YAAY,KAAK,eAAe;EAAK;EAC9DtR,OAAO,CAACuR,cAAc,CAAC,IAAIA,cAAc,KAAK,iBAAkB,EACjE;IACAzQ,cAAc,CACZ,0BAA0B,EAC1B,+BAA+BwQ,YAAY,IAAIC,cAAc,EAC/D,CAAC;EACH;;EAEA;EACA,MAAMyL,gBAAgB,GAAGD,UAAU,CAACvR,MAAM;EAC1C,KAAK,IAAIoE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoN,gBAAgB,EAAEpN,CAAC,EAAE,EAAE;IACzC,MAAMiN,QAAQ,GAAGE,UAAU,CAACnN,CAAC,CAAC;IAC9B6B,SAAS,CAACwL,sBAAsB,CAACJ,QAAQ,EAAEA,QAAQ,CAAC;EACtD;EACA,OAAOE,UAAU;AACnB;AAEA,SAASG,uBAAuBA,CAC9BrT,UAAU,EACVmH,MAAM,EACNsJ,WAAW,EACX6C,eAAe,EACf;EACA,IAAIlH,KAAK,GAAGjF,MAAM,CAACiF,KAAK;EACxB,IAAI,CAACjW,OAAO,CAACiW,KAAK,CAAC,EAAE;IACnBA,KAAK,GAAGjW,OAAO,CAACsa,WAAW,CAACrE,KAAK,CAAC,GAC9BqE,WAAW,CAACrE,KAAK,CAACvW,KAAK,CAAC,CAAC,GACzBsW,kBAAkB,CAAC,CAAC;IACxBhF,MAAM,CAACiF,KAAK,GAAGA,KAAK;EACtB;EACAA,KAAK,CAAC1P,IAAI,GAAGyK,MAAM,CAAC0I,IAAI;EAExB,IAAInE,SAAS,GAAGvE,MAAM,CAACuE,SAAS;EAChC,IAAI,CAACvV,OAAO,CAACuV,SAAS,CAAC,EAAE;IACvBA,SAAS,GAAGvV,OAAO,CAACsa,WAAW,CAAC/E,SAAS,CAAC,GACtC+E,WAAW,CAAC/E,SAAS,CAAC7V,KAAK,CAAC,CAAC,GAC7B4V,sBAAsB,CAAC,CAAC;IAC5BtE,MAAM,CAACuE,SAAS,GAAGA,SAAS;EAC9B;EAEA,IAAI,CAACvV,OAAO,CAACuV,SAAS,CAACsD,KAAK,CAAC,EAAE;IAC7BtD,SAAS,CAACsD,KAAK,GAAGhP,UAAU,CAACuT,WAAW,CAACC,SAAS,CAAC1d,KAAK,CAAC2d,MAAM,EAAE,EAAE,CAAC;;IAEpE;IACA;IACA;EACF,CAAC,MAAM,IAAI,CAAC/H,SAAS,CAACsD,KAAK,CAAC0E,QAAQ,CAAC,CAAC,EAAE;IACtChI,SAAS,CAACsD,KAAK,GAAG3Q,SAAS;EAC7B;EAEA,IAAIgQ,KAAK,GAAG,GAAG;EACf,IAAIlY,OAAO,CAACuV,SAAS,CAAC2C,KAAK,CAAC,EAAE;IAC5BA,KAAK,GAAG3C,SAAS,CAAC2C,KAAK,CAACqF,QAAQ,CAAC,CAAC;IAClC,IAAIrF,KAAK,KAAK,CAAC,EAAE;MACfjC,KAAK,CAACE,WAAW,GAAG,IAAI9W,UAAU,CAAC6Y,KAAK,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC;IACvD,CAAC,MAAM;MACL;MACAjC,KAAK,CAACE,WAAW,GAAGjO,SAAS;MAC7B+N,KAAK,CAACG,gBAAgB,GAAGlO,SAAS;IACpC;EACF;EAEA,IAAIlI,OAAO,CAACmd,eAAe,CAAC,IAAItT,UAAU,CAAC2T,cAAc,EAAE;IACzDjI,SAAS,CAAC4H,eAAe,GAAGA,eAAe;IAC3ClH,KAAK,CAACkH,eAAe,GAAGA,eAAe;EACzC;AACF;AAEA,SAASM,mBAAmBA,CAACzM,MAAM,EAAEsJ,WAAW,EAAE;EAChD,IAAIoD,IAAI,GAAG1M,MAAM,CAAC0M,IAAI;EACtB,IAAI,CAAC1d,OAAO,CAAC0d,IAAI,CAAC,EAAE;IAClBA,IAAI,GAAG,IAAI1a,YAAY,CAAC,CAAC;IACzB0a,IAAI,CAACC,QAAQ,GAAG,CAAC;IACjB3M,MAAM,CAAC0M,IAAI,GAAGA,IAAI;EACpB;EAEA,MAAM/D,QAAQ,GAAGW,WAAW,CAACX,QAAQ;EACrC,IAAI3Z,OAAO,CAAC2Z,QAAQ,CAAC,EAAE;IACrB+D,IAAI,CAAC9D,QAAQ,GAAGD,QAAQ,CAACC,QAAQ;IACjC8D,IAAI,CAAClI,KAAK,GAAGmE,QAAQ,CAACnE,KAAK;EAC7B;AACF;AAEA,SAASoI,YAAYA,CACnB/T,UAAU,EACV+G,gBAAgB,EAChBiN,YAAY,EACZ7M,MAAM,EACNsJ,WAAW,EACX;EACA,MAAMwD,iBAAiB,GAAG9K,gBAAgB,CACxC6K,YAAY,EACZ,aAAa,EACbxV,UAAU,CAACC,GACb,CAAC;EACD,MAAMgJ,YAAY,GAAG0B,gBAAgB,CACnC6K,YAAY,EACZ,cAAc,EACdxV,UAAU,CAACC,GACb,CAAC;EACD,MAAMiJ,cAAc,GAAGyB,gBAAgB,CACrC6K,YAAY,EACZ,cAAc,EACdxV,UAAU,CAACE,EACb,CAAC;EACD,MAAMwV,OAAO,GAAG7K,iBAAiB,CAAC2K,YAAY,EAAE,SAAS,EAAExV,UAAU,CAACC,GAAG,CAAC;EAC1E,MAAMmJ,SAAS,GAAG5H,UAAU,CAAC6N,UAAU;EACvC,MAAM4E,QAAQ,GAAG9K,cAAc,CAACsM,iBAAiB,EAAErM,SAAS,CAAC;EAE7DT,MAAM,CAACsL,QAAQ,GAAGA,QAAQ;EAC1BY,uBAAuB,CACrBrT,UAAU,EACVmH,MAAM,EACNsJ,WAAW,EACXkC,+BAA+B,CAAClL,YAAY,EAAEC,cAAc,CAC9D,CAAC;EAED,IAAIwM,OAAO,IAAI1M,YAAY,CAACC,YAAY,EAAEC,cAAc,CAAC,EAAE;IACzD4K,cAAc,CAACvL,gBAAgB,EAAEI,MAAM,EAAEsJ,WAAW,CAAC;EACvD;EAEA,OAAO,IAAI;AACb;AAEA,SAAS0D,6BAA6BA,CACpCnU,UAAU,EACV+G,gBAAgB,EAChBiN,YAAY,EACZ7M,MAAM,EACNsJ,WAAW,EACX;EACA,MAAM2D,eAAe,GAAG1L,cAAc,CACpCsL,YAAY,EACZ,aAAa,EACbxV,UAAU,CAACC,GACb,CAAC;EACD,MAAMgJ,YAAY,GAAG0B,gBAAgB,CACnC6K,YAAY,EACZ,cAAc,EACdxV,UAAU,CAACC,GACb,CAAC;EACD,MAAMiJ,cAAc,GAAGyB,gBAAgB,CACrC6K,YAAY,EACZ,cAAc,EACdxV,UAAU,CAACE,EACb,CAAC;EACD,MAAMwV,OAAO,GAAG7K,iBAAiB,CAAC2K,YAAY,EAAE,SAAS,EAAExV,UAAU,CAACC,GAAG,CAAC;EAC1E,MAAM4V,UAAU,GAAGhL,iBAAiB,CAClC2K,YAAY,EACZ,YAAY,EACZxV,UAAU,CAACC,GACb,CAAC;EACD,MAAM6V,UAAU,GAAG9M,YAAY,CAACC,YAAY,EAAEC,cAAc,CAAC;EAC7D,MAAM6M,MAAM,GAAGtL,iBAAiB,CAAC+K,YAAY,EAAE,WAAW,EAAExV,UAAU,CAACE,EAAE,CAAC;EAE1E,MAAMkJ,SAAS,GAAG5H,UAAU,CAAC6N,UAAU;EACvC,MAAM2G,WAAW,GAAGpM,eAAe,CAACgM,eAAe,EAAExM,SAAS,CAAC;EAC/D,IAAIkI,QAAQ,GAAGW,WAAW,CAACX,QAAQ;EACnC,IAAIwE,UAAU,IAAIJ,OAAO,EAAE;IACzB,MAAMO,IAAI,GAAG,IAAI7a,YAAY,CAAC,CAAC;IAC/BuN,MAAM,CAACsN,IAAI,GAAGA,IAAI;IAClBA,IAAI,CAAC/B,SAAS,GAAG8B,WAAW;IAC5B,MAAMzI,OAAO,GAAG0E,WAAW,CAAC1E,OAAO;IAEnC,IAAI5V,OAAO,CAAC4V,OAAO,CAAC,EAAE;MACpB0I,IAAI,CAACzE,IAAI,GAAGjE,OAAO,CAACiE,IAAI;MACxByE,IAAI,CAAC1E,QAAQ,GAAGhE,OAAO,CAACgE,QAAQ;IAClC;;IAEA;IACA0E,IAAI,CAACzI,OAAO,GAAG,IAAI;IACnB,IAAI7V,OAAO,CAAC2Z,QAAQ,CAAC,EAAE;MACrB2E,IAAI,CAACxI,YAAY,GAAG9V,OAAO,CAAC2Z,QAAQ,CAACC,QAAQ,CAAC,GAC1CD,QAAQ,CAACC,QAAQ,CAACxB,KAAK,GACvBzY,KAAK,CAACoW,KAAK;MACfuI,IAAI,CAACC,YAAY,GAAG5E,QAAQ,CAACnE,KAAK;IACpC,CAAC,MAAM,IAAIxV,OAAO,CAAC4V,OAAO,CAAC,EAAE;MAC3B0I,IAAI,CAACxI,YAAY,GAAG9V,OAAO,CAAC4V,OAAO,CAACgE,QAAQ,CAAC,GACzChE,OAAO,CAACgE,QAAQ,CAACxB,KAAK,GACtBzY,KAAK,CAACoW,KAAK;IACjB;EACF,CAAC,MAAM,IAAIlM,UAAU,CAAC2T,cAAc,IAAI,CAACW,UAAU,IAAID,UAAU,EAAE;IACjE,MAAMM,gBAAgB,GAAG,IAAItb,gBAAgB,CAAC,CAAC;IAC/Csb,gBAAgB,CAACC,aAAa,GAAG,IAAI;IACrCzN,MAAM,CAAC2I,QAAQ,GAAG6E,gBAAgB;IAClCA,gBAAgB,CAACjC,SAAS,GAAG8B,WAAW;IACxC,IAAIre,OAAO,CAAC2Z,QAAQ,CAAC,EAAE;MACrB6E,gBAAgB,CAAC5E,QAAQ,GAAG5Z,OAAO,CAAC2Z,QAAQ,CAACC,QAAQ,CAAC,GAClDD,QAAQ,CAACC,QAAQ,CAACxB,KAAK,CAACmF,QAAQ,CAAC9c,OAAO,CAAC4U,aAAa,CAAC,GACvD1V,KAAK,CAACoW,KAAK;MACfyI,gBAAgB,CAAChJ,KAAK,GAAGmE,QAAQ,CAACnE,KAAK,IAAI,GAAG;IAChD,CAAC,MAAM;MACLgJ,gBAAgB,CAAC5E,QAAQ,GAAGja,KAAK,CAACoW,KAAK;MACvCyI,gBAAgB,CAAChJ,KAAK,GAAG,GAAG;IAC9B;IACAgJ,gBAAgB,CAACJ,MAAM,GAAGA,MAAM;EAClC,CAAC,MAAM;IACL,IAAIpe,OAAO,CAACoe,MAAM,CAAC,EAAE;MACnBtd,cAAc,CACZ,kBAAkB,EAClB,gFACF,CAAC;IACH;IACA,IAAI+I,UAAU,CAAC2T,cAAc,IAAI,CAACU,UAAU,EAAE;MAC5Cpd,cAAc,CACZ,oBAAoB,EACpB,mEACF,CAAC;IACH;IAEA6Y,QAAQ,GAAG3Z,OAAO,CAAC2Z,QAAQ,CAAC,GAAGA,QAAQ,CAACja,KAAK,CAAC,CAAC,GAAG,IAAIwD,gBAAgB,CAAC,CAAC;IACxE8N,MAAM,CAAC2I,QAAQ,GAAGA,QAAQ;IAC1BA,QAAQ,CAAC4C,SAAS,GAAGO,2CAA2C,CAC9DuB,WAAW,EACX/M,YAAY,EACZC,cAAc,EACdE,SACF,CAAC;IACD,IAAI,CAACyM,UAAU,IAAIC,UAAU,EAAE;MAC7BxE,QAAQ,CAAC+E,OAAO,GAAGzf,OAAO,CAAC0d,IAAI;IACjC;EACF;EAEA,OAAO,IAAI;AACb;AAEA,SAASgC,cAAcA,CACrB9U,UAAU,EACV+G,gBAAgB,EAChBiN,YAAY,EACZ7M,MAAM,EACNsJ,WAAW,EACX;EACA,MAAMsE,mBAAmB,GAAGrM,cAAc,CACxCsL,YAAY,EACZ,iBAAiB,EACjBxV,UAAU,CAACC,GACb,CAAC;EACD,IAAIuW,cAAc,GAAGtM,cAAc,CACjCqM,mBAAmB,EACnB,YAAY,EACZvW,UAAU,CAACC,GACb,CAAC;EACD,IAAI2V,eAAe,GAAG1L,cAAc,CAClCsM,cAAc,EACd,aAAa,EACbxW,UAAU,CAACC,GACb,CAAC;EACD,MAAMmJ,SAAS,GAAG5H,UAAU,CAAC6N,UAAU;EACvC,IAAI2G,WAAW,GAAGpM,eAAe,CAACgM,eAAe,EAAExM,SAAS,CAAC;EAC7D,MAAMsM,OAAO,GAAG7K,iBAAiB,CAAC2K,YAAY,EAAE,SAAS,EAAExV,UAAU,CAACC,GAAG,CAAC;EAC1E,MAAMgJ,YAAY,GAAG0B,gBAAgB,CACnC6K,YAAY,EACZ,cAAc,EACdxV,UAAU,CAACC,GACb,CAAC;EACD,MAAMiJ,cAAc,GAAGyB,gBAAgB,CACrC6K,YAAY,EACZ,cAAc,EACdxV,UAAU,CAACE,EACb,CAAC;EACD,MAAM4V,UAAU,GAAG9M,YAAY,CAACC,YAAY,EAAEC,cAAc,CAAC;EAE7D,MAAMqE,OAAO,GAAG5V,OAAO,CAACsa,WAAW,CAAC1E,OAAO,CAAC,GACxC0E,WAAW,CAAC1E,OAAO,CAAClW,KAAK,CAAC,CAAC,GAC3BiW,oBAAoB,CAAC,CAAC;EAE1B,MAAMgE,QAAQ,GAAGW,WAAW,CAACX,QAAQ;EACrC,IAAI3Z,OAAO,CAAC2Z,QAAQ,CAAC,EAAE;IACrB/D,OAAO,CAACE,YAAY,GAAG9V,OAAO,CAAC2Z,QAAQ,CAACC,QAAQ,CAAC,GAC7CD,QAAQ,CAACC,QAAQ,CAACxB,KAAK,GACvBzY,KAAK,CAACoW,KAAK;IACfH,OAAO,CAAC2I,YAAY,GAAG5E,QAAQ,CAACnE,KAAK;EACvC;EACAxE,MAAM,CAAC4E,OAAO,GAAGA,OAAO;EAExB,IAAIuI,UAAU,EAAE;IACdvI,OAAO,CAACkJ,iBAAiB,GAAG,IAAI;IAChClJ,OAAO,CAACmJ,cAAc,GAAGhB,OAAO,GAAG,CAAC,GAAG7V,SAAS;EAClD,CAAC,MAAM,IAAI,CAAC2B,UAAU,CAAC2T,cAAc,EAAE;IACrC5H,OAAO,CAAC7D,MAAM,GAAG,CAAC;EACpB;EAEA,IAAI/R,OAAO,CAACqe,WAAW,CAAC,EAAE;IACxB,MAAMW,SAAS,GAAG,IAAIhe,gBAAgB,CAACqd,WAAW,CAAC;IACnD,MAAMY,oBAAoB,GAAGpM,eAAe,CAC1CgL,YAAY,EACZ,iBAAiB,EACjBxV,UAAU,CAACC,GACb,CAAC;IACD,KAAK,IAAI4W,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,oBAAoB,CAACzT,MAAM,EAAE0T,CAAC,EAAE,EAAE;MACpDL,cAAc,GAAGhM,eAAe,CAC9BoM,oBAAoB,CAACC,CAAC,CAAC,EACvB,YAAY,EACZ7W,UAAU,CAACC,GACb,CAAC;MACD,KAAK,IAAI6W,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,cAAc,CAACrT,MAAM,EAAE2T,CAAC,EAAE,EAAE;QAC9ClB,eAAe,GAAG1L,cAAc,CAC9BsM,cAAc,CAACM,CAAC,CAAC,EACjB,aAAa,EACb9W,UAAU,CAACC,GACb,CAAC;QACD+V,WAAW,GAAGpM,eAAe,CAACgM,eAAe,EAAExM,SAAS,CAAC;QACzD,IAAIzR,OAAO,CAACqe,WAAW,CAAC,EAAE;UACxBW,SAAS,CAACI,KAAK,CAACvU,IAAI,CAAC,IAAI7J,gBAAgB,CAACqd,WAAW,CAAC,CAAC;QACzD;MACF;IACF;IACAzI,OAAO,CAACoJ,SAAS,GAAGA,SAAS;EAC/B;EAEA,OAAO,IAAI;AACb;AAEA,SAASK,YAAYA,CACnBxV,UAAU,EACV+G,gBAAgB,EAChBiN,YAAY,EACZ7M,MAAM,EACNsJ,WAAW,EACX;EACA,MAAMhJ,YAAY,GAAG0B,gBAAgB,CACnC6K,YAAY,EACZ,cAAc,EACdxV,UAAU,CAACC,GACb,CAAC;EACD,MAAMiJ,cAAc,GAAGyB,gBAAgB,CACrC6K,YAAY,EACZ,cAAc,EACdxV,UAAU,CAACE,EACb,CAAC;EACD,MAAM+W,UAAU,GAAGzM,eAAe,CAACgL,YAAY,EAAE,OAAO,EAAExV,UAAU,CAACE,EAAE,CAAC;EACxE,MAAMgX,UAAU,GAAG1M,eAAe,CAACgL,YAAY,EAAE,QAAQ,EAAExV,UAAU,CAACE,EAAE,CAAC;EACzE,MAAMiX,SAAS,GAAG3M,eAAe,CAACgL,YAAY,EAAE,MAAM,EAAExV,UAAU,CAACC,GAAG,CAAC;EACvE,MAAMyV,OAAO,GAAG7K,iBAAiB,CAAC2K,YAAY,EAAE,SAAS,EAAExV,UAAU,CAACC,GAAG,CAAC;EAC1E,MAAM6V,UAAU,GAAG9M,YAAY,CAACC,YAAY,EAAEC,cAAc,CAAC;EAC7D,MAAME,SAAS,GAAG5H,UAAU,CAAC6N,UAAU;EAEvC,IAAI6H,UAAU,CAAC/T,MAAM,GAAG,CAAC,EAAE;IACzB1K,cAAc,CACZ,eAAe,EACf,gDACF,CAAC;EACH;EAEA,MAAM0K,MAAM,GAAGqB,IAAI,CAACC,GAAG,CAACwS,UAAU,CAAC9T,MAAM,EAAEgU,SAAS,CAAChU,MAAM,CAAC;EAC5D,MAAM6S,WAAW,GAAG,EAAE;EACtB,MAAMoB,KAAK,GAAG,EAAE;EAChB,KAAK,IAAI7P,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpE,MAAM,EAAEoE,CAAC,EAAE,EAAE;IAC/B,MAAM0M,QAAQ,GAAG9K,cAAc,CAAC8N,UAAU,CAAC1P,CAAC,CAAC,CAACuC,WAAW,EAAEV,SAAS,CAAC;IACrE4M,WAAW,CAACxT,IAAI,CAACyR,QAAQ,CAAC;IAC1BmD,KAAK,CAAC5U,IAAI,CAACnK,UAAU,CAAC+T,WAAW,CAAC+K,SAAS,CAAC5P,CAAC,CAAC,CAACuC,WAAW,CAAC,CAAC;EAC9D;EACA,MAAM0K,QAAQ,GAAG,IAAIvZ,uBAAuB,CAAC,CAAC;EAC9CuZ,QAAQ,CAAC6C,UAAU,CAACD,KAAK,EAAEpB,WAAW,CAAC;EACvCrN,MAAM,CAACsL,QAAQ,GAAGO,QAAQ;EAC1BK,uBAAuB,CACrBrT,UAAU,EACVmH,MAAM,EACNsJ,WAAW,EACXkC,+BAA+B,CAAClL,YAAY,EAAEC,cAAc,CAC9D,CAAC;EACDkM,mBAAmB,CAACzM,MAAM,EAAEsJ,WAAW,CAAC;EAExCtJ,MAAM,CAAC2O,YAAY,GAAG,IAAIre,sBAAsB,CAAC,CAAC;EAElD,IAAIke,SAAS,CAAChU,MAAM,GAAG,CAAC,EAAE;IACxBwF,MAAM,CAAC2O,YAAY,CAACjL,WAAW,CAC7B,IAAIrT,YAAY,CAAC;MACfsT,KAAK,EAAE8K,KAAK,CAAC,CAAC,CAAC;MACf7K,IAAI,EAAE6K,KAAK,CAACA,KAAK,CAACjU,MAAM,GAAG,CAAC;IAC9B,CAAC,CACH,CAAC;EACH;EAEA,IAAI2S,UAAU,IAAIJ,OAAO,EAAE;IACzB5B,cAAc,CAACvL,gBAAgB,EAAEI,MAAM,EAAEsJ,WAAW,CAAC;EACvD;EAEA,OAAO,IAAI;AACb;AAEA,SAASsF,eAAeA,CACtBH,KAAK,EACLlD,SAAS,EACTsD,SAAS,EACTF,YAAY,EACZG,gBAAgB,EAChB/B,OAAO,EACPzM,YAAY,EACZC,cAAc,EACdwO,gBAAgB,EAChB;EACA,MAAMpL,KAAK,GAAG8K,KAAK,CAAC,CAAC,CAAC;EACtB,MAAM7K,IAAI,GAAG6K,KAAK,CAACA,KAAK,CAACjU,MAAM,GAAG,CAAC,CAAC;EAEpC,MAAMwU,IAAI,GAAG,IAAI1c,uBAAuB,CAAC,CAAC;EAC1C0c,IAAI,CAACN,UAAU,CAACD,KAAK,EAAElD,SAAS,CAAC;EAEjCsD,SAAS,CAACI,SAAS,CAACvL,WAAW,CAC7B,IAAIrT,YAAY,CAAC;IACfsT,KAAK,EAAEA,KAAK;IACZC,IAAI,EAAEA,IAAI;IACVsL,eAAe,EAAEH,gBAAgB;IACjCI,cAAc,EAAEJ,gBAAgB;IAChCC,IAAI,EAAEpD,sCAAsC,CAC1CoD,IAAI,EACJ1O,YAAY,EACZC,cACF;EACF,CAAC,CACH,CAAC;EACDoO,YAAY,CAACjL,WAAW,CACtB,IAAIrT,YAAY,CAAC;IACfsT,KAAK,EAAEA,KAAK;IACZC,IAAI,EAAEA,IAAI;IACVsL,eAAe,EAAEH,gBAAgB;IACjCI,cAAc,EAAEJ;EAClB,CAAC,CACH,CAAC;EACDD,gBAAgB,CAACG,SAAS,CAACvL,WAAW,CACpC,IAAIrT,YAAY,CAAC;IACfsT,KAAK,EAAEA,KAAK;IACZC,IAAI,EAAEA,IAAI;IACVsL,eAAe,EAAEH,gBAAgB;IACjCI,cAAc,EAAEJ,gBAAgB;IAChCC,IAAI,EAAEjC;EACR,CAAC,CACH,CAAC;AACH;AAEA,SAASqC,iBAAiBA,CACxBvW,UAAU,EACV+G,gBAAgB,EAChBiN,YAAY,EACZ7M,MAAM,EACNsJ,WAAW,EACX;EACA;EACA;EACA;;EAEA,MAAM+F,WAAW,GAAGnN,iBAAiB,CACnC2K,YAAY,EACZ,aAAa,EACbxV,UAAU,CAACE,EACb,CAAC;EACD,MAAM+X,UAAU,GAAGzN,eAAe,CAACgL,YAAY,EAAE,OAAO,EAAExV,UAAU,CAACE,EAAE,CAAC;EAExE,IAAIkX,KAAK;EACT,IAAIc,QAAQ;EACZ,IAAIC,gBAAgB;EACpB,IAAIC,YAAY,GAAG,KAAK;EACxB,MAAMX,gBAAgB,GAAG,IAAItc,8BAA8B,CAAC,CAAC;EAC7D,MAAMmc,YAAY,GAAG,IAAIre,sBAAsB,CAAC,CAAC;EACjD,MAAMue,SAAS,GAAG,IAAIzd,yBAAyB,CAAC,CAAC;EACjD,MAAMqP,SAAS,GAAG5H,UAAU,CAAC6N,UAAU;EACvC,KAAK,IAAI9H,CAAC,GAAG,CAAC,EAAE2J,GAAG,GAAG+G,UAAU,CAAC9U,MAAM,EAAEoE,CAAC,GAAG2J,GAAG,EAAE3J,CAAC,EAAE,EAAE;IACrD,MAAM8Q,SAAS,GAAGJ,UAAU,CAAC1Q,CAAC,CAAC;IAC/B,MAAM4P,SAAS,GAAG3M,eAAe,CAAC6N,SAAS,EAAE,MAAM,EAAErY,UAAU,CAACC,GAAG,CAAC;IACpE,MAAMgX,UAAU,GAAGzM,eAAe,CAAC6N,SAAS,EAAE,OAAO,EAAErY,UAAU,CAACE,EAAE,CAAC;IACrE,MAAM+I,YAAY,GAAG0B,gBAAgB,CACnC0N,SAAS,EACT,cAAc,EACdrY,UAAU,CAACC,GACb,CAAC;IACD,MAAMiJ,cAAc,GAAGyB,gBAAgB,CACrC0N,SAAS,EACT,cAAc,EACdrY,UAAU,CAACE,EACb,CAAC;IACD,MAAM4V,UAAU,GAAG9M,YAAY,CAACC,YAAY,EAAEC,cAAc,CAAC;IAC7D,MAAMwM,OAAO,GAAG7K,iBAAiB,CAACwN,SAAS,EAAE,SAAS,EAAErY,UAAU,CAACC,GAAG,CAAC;IAEvE,MAAMkD,MAAM,GAAGqB,IAAI,CAACC,GAAG,CAACwS,UAAU,CAAC9T,MAAM,EAAEgU,SAAS,CAAChU,MAAM,CAAC;IAE5D,MAAM+Q,SAAS,GAAG,EAAE;IACpBkD,KAAK,GAAG,EAAE;IACV,KAAK,IAAI3I,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGtL,MAAM,EAAEsL,CAAC,EAAE,EAAE;MAC/B,MAAMwF,QAAQ,GAAG9K,cAAc,CAAC8N,UAAU,CAACxI,CAAC,CAAC,CAAC3E,WAAW,EAAEV,SAAS,CAAC;MACrE8K,SAAS,CAAC1R,IAAI,CAACyR,QAAQ,CAAC;MACxBmD,KAAK,CAAC5U,IAAI,CAACnK,UAAU,CAAC+T,WAAW,CAAC+K,SAAS,CAAC1I,CAAC,CAAC,CAAC3E,WAAW,CAAC,CAAC;IAC9D;IAEA,IAAIkO,WAAW,EAAE;MACf;MACA;MACA;MACA;MACA,IAAIrgB,OAAO,CAACugB,QAAQ,CAAC,EAAE;QACrBX,eAAe,CACb,CAACW,QAAQ,EAAEd,KAAK,CAAC,CAAC,CAAC,CAAC,EACpB,CAACe,gBAAgB,EAAEjE,SAAS,CAAC,CAAC,CAAC,CAAC,EAChCsD,SAAS,EACTF,YAAY,EACZG,gBAAgB,EAChB,KAAK,EACL,UAAU,EACV5X,SAAS,EACT,KACF,CAAC;MACH;MACAqY,QAAQ,GAAGd,KAAK,CAACjU,MAAM,GAAG,CAAC,CAAC;MAC5BgV,gBAAgB,GAAGjE,SAAS,CAACA,SAAS,CAAC/Q,MAAM,GAAG,CAAC,CAAC;IACpD;IAEAoU,eAAe,CACbH,KAAK,EACLlD,SAAS,EACTsD,SAAS,EACTF,YAAY,EACZG,gBAAgB,EAChB3B,UAAU,IAAIJ,OAAO,EACrBzM,YAAY,EACZC,cAAc,EACd,IACF,CAAC;IACDkP,YAAY,GAAGA,YAAY,IAAKtC,UAAU,IAAIJ,OAAQ;EACxD;EAEA/M,MAAM,CAAC2O,YAAY,GAAGA,YAAY;EAClC3O,MAAM,CAACsL,QAAQ,GAAGuD,SAAS;EAC3B3C,uBAAuB,CAACrT,UAAU,EAAEmH,MAAM,EAAEsJ,WAAW,CAAC;EACxDmD,mBAAmB,CAACzM,MAAM,EAAEsJ,WAAW,CAAC;EACxC,IAAImG,YAAY,EAAE;IAChBtE,cAAc,CAACvL,gBAAgB,EAAEI,MAAM,EAAEsJ,WAAW,CAAC;IACrDtJ,MAAM,CAAC2I,QAAQ,CAACgH,IAAI,GAAGb,gBAAgB;EACzC;EAEA,OAAO,IAAI;AACb;AAEA,MAAMc,aAAa,GAAG;EACpBC,KAAK,EAAEjD,YAAY;EACnBkD,UAAU,EAAE9C,6BAA6B;EACzC+C,UAAU,EAAE/C,6BAA6B;EACzCgD,OAAO,EAAErC,cAAc;EACvBsC,KAAK,EAAE5B,YAAY;EACnB6B,UAAU,EAAEd,iBAAiB;EAC7Be,aAAa,EAAEC,oBAAoB;EACnCC,KAAK,EAAEC;AACT,CAAC;AAED,SAASF,oBAAoBA,CAC3BvX,UAAU,EACV+G,gBAAgB,EAChBiN,YAAY,EACZ7M,MAAM,EACNsJ,WAAW,EACXzJ,OAAO,EACP;EACA,MAAM4B,UAAU,GAAGoL,YAAY,CAACpL,UAAU;EAC1C,IAAI8O,WAAW,GAAG,KAAK;EACvB,KAAK,IAAI3R,CAAC,GAAG,CAAC,EAAE2J,GAAG,GAAG9G,UAAU,CAACjH,MAAM,EAAEoE,CAAC,GAAG2J,GAAG,EAAE3J,CAAC,EAAE,EAAE;IACrD,MAAM4R,SAAS,GAAG/O,UAAU,CAAC+G,IAAI,CAAC5J,CAAC,CAAC;IACpC,MAAM6R,iBAAiB,GAAGb,aAAa,CAACY,SAAS,CAAClV,SAAS,CAAC;IAC5D,IAAItM,OAAO,CAACyhB,iBAAiB,CAAC,EAAE;MAC9B,MAAMC,WAAW,GAAGhR,YAAY,CAAC8Q,SAAS,EAAE5Q,gBAAgB,EAAEC,OAAO,CAAC;MACtE6Q,WAAW,CAACC,MAAM,GAAG3Q,MAAM;MAC3B0Q,WAAW,CAAChI,IAAI,GAAG1I,MAAM,CAAC0I,IAAI;MAC9BgI,WAAW,CAAC/B,YAAY,GAAG3O,MAAM,CAAC2O,YAAY;MAC9C+B,WAAW,CAACE,WAAW,GAAG5Q,MAAM,CAAC4Q,WAAW;MAC5CF,WAAW,CAACpZ,GAAG,GAAG0I,MAAM,CAAC1I,GAAG;MAC5B,IACEmZ,iBAAiB,CACf5X,UAAU,EACV+G,gBAAgB,EAChB4Q,SAAS,EACTE,WAAW,EACXpH,WACF,CAAC,EACD;QACAiH,WAAW,GAAG,IAAI;MACpB;IACF;EACF;EAEA,OAAOA,WAAW;AACpB;AAEA,SAASD,0BAA0BA,CACjCzX,UAAU,EACV+G,gBAAgB,EAChBiN,YAAY,EACZ7M,MAAM,EACNsJ,WAAW,EACX;EACAxZ,cAAc,CACZ,yBAAyB,EACzB,+BAA+B+c,YAAY,CAACvR,SAAS,EACvD,CAAC;EACD,OAAO,KAAK;AACd;AAEA,SAASuV,mBAAmBA,CAAClR,IAAI,EAAEK,MAAM,EAAE;EACzC,MAAM8Q,gBAAgB,GAAGvP,cAAc,CAAC5B,IAAI,EAAE,cAAc,EAAEtI,UAAU,CAACC,GAAG,CAAC;EAE7E,IAAI,CAACtI,OAAO,CAAC8hB,gBAAgB,CAAC,EAAE;IAC9B,OAAO5Z,SAAS;EAClB;EAEA,IAAIlI,OAAO,CAACuS,cAAc,CAACuP,gBAAgB,EAAE,YAAY,EAAEzZ,UAAU,CAACC,GAAG,CAAC,CAAC,EAAE;IAC3ExH,cAAc,CAAC,gBAAgB,EAAE,iCAAiC,CAAC;EACrE;EACA,IAAId,OAAO,CAAC+Q,oBAAoB,CAAC+Q,gBAAgB,EAAE,cAAc,CAAC,CAAC,EAAE;IACnEhhB,cAAc,CACZ,kBAAkB,EAClB,qDACF,CAAC;EACH;EAEA,MAAMsM,MAAM,GAAG,CAAC,CAAC;EACjB,MAAM2U,SAAS,GAAGlP,eAAe,CAACiP,gBAAgB,EAAE,MAAM,EAAEzZ,UAAU,CAACC,GAAG,CAAC;EAC3E,IAAItI,OAAO,CAAC+hB,SAAS,CAAC,EAAE;IACtB,MAAMvW,MAAM,GAAGuW,SAAS,CAACvW,MAAM;IAC/B,KAAK,IAAIoE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpE,MAAM,EAAEoE,CAAC,EAAE,EAAE;MAC/B,MAAMoS,QAAQ,GAAGD,SAAS,CAACnS,CAAC,CAAC;MAC7B,MAAM8J,IAAI,GAAG3I,oBAAoB,CAACiR,QAAQ,EAAE,MAAM,CAAC;MACnD,IAAIhiB,OAAO,CAAC0Z,IAAI,CAAC,EAAE;QACjBtM,MAAM,CAACsM,IAAI,CAAC,GAAG;UACbuI,WAAW,EAAEjP,gBAAgB,CAC3BgP,QAAQ,EACR,aAAa,EACb3Z,UAAU,CAACC,GACb,CAAC;UACDwH,KAAK,EAAEkD,gBAAgB,CAACgP,QAAQ,EAAE,OAAO,EAAE3Z,UAAU,CAACC,GAAG;QAC3D,CAAC;MACH;IACF;EACF;EACA0I,MAAM,CAAC1I,GAAG,CAAC4Z,YAAY,GAAG9U,MAAM;AAClC;AAEA,IAAI+U,UAAU;AACd,IAAI,OAAOC,QAAQ,KAAK,WAAW,EAAE;EACnCD,UAAU,GAAGC,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;AAC5C;AAEA,SAASC,kBAAkBA,CACzB3R,IAAI,EACJK,MAAM,EACNsJ,WAAW,EACXxL,WAAW,EACXwB,cAAc,EACd;EACA,IAAIV,CAAC;EACL,IAAI1B,GAAG;EACP,IAAIsB,IAAI;EAER,MAAM+S,OAAO,GAAGvR,MAAM,CAAC1I,GAAG;EAC1B,MAAM4Z,YAAY,GAAGK,OAAO,CAACL,YAAY;EACzC,MAAMN,WAAW,GAAG5O,gBAAgB,CAACrC,IAAI,EAAE,aAAa,EAAEtI,UAAU,CAACC,GAAG,CAAC;EAEzE,MAAM2R,YAAY,GAAGjJ,MAAM,CAACiJ,YAAY,IAAIK,WAAW,CAACL,YAAY;EAEpE,IAAIuI,UAAU,GAAG7iB,KAAK,CAACoW,KAAK;EAC5B,IAAI0M,UAAU,GAAG9iB,KAAK,CAACqa,KAAK;EAC5B,IAAIzT,IAAI,GAAGqb,WAAW;EAEtB,IAAI5hB,OAAO,CAACia,YAAY,CAAC,EAAE;IACzBuI,UAAU,GAAGvI,YAAY,CAACH,OAAO,IAAIna,KAAK,CAACoW,KAAK;IAChD0M,UAAU,GAAGxI,YAAY,CAACF,SAAS,IAAIpa,KAAK,CAACqa,KAAK;IAClDzT,IAAI,GAAG0T,YAAY,CAAC1T,IAAI,IAAIqb,WAAW;EACzC;EAEA,IAAI9R,KAAK;EACT,IAAI9P,OAAO,CAACuG,IAAI,CAAC,EAAE;IACjBA,IAAI,GAAGA,IAAI,CAAC6M,OAAO,CAAC,SAAS,EAAEpC,MAAM,CAAC0I,IAAI,IAAI,EAAE,CAAC;IACjDnT,IAAI,GAAGA,IAAI,CAAC6M,OAAO,CAAC,gBAAgB,EAAEwO,WAAW,IAAI,EAAE,CAAC;IACxDrb,IAAI,GAAGA,IAAI,CAAC6M,OAAO,CAAC,YAAY,EAAEmP,OAAO,CAACG,OAAO,IAAI,EAAE,CAAC;IACxDnc,IAAI,GAAGA,IAAI,CAAC6M,OAAO,CAAC,YAAY,EAAEmP,OAAO,CAACI,OAAO,IAAI,EAAE,CAAC;IACxDpc,IAAI,GAAGA,IAAI,CAAC6M,OAAO,CAAC,OAAO,EAAEpC,MAAM,CAACF,EAAE,CAAC;;IAEvC;IACA;IACA;IACAvK,IAAI,GAAGA,IAAI,CAAC6M,OAAO,CAAC,iBAAiB,EAAE,EAAE,CAAC;IAE1C,IAAIpT,OAAO,CAACkiB,YAAY,CAAC,EAAE;MACzB,MAAMU,OAAO,GAAGrc,IAAI,CAACmB,KAAK,CAAC,YAAY,CAAC;MACxC,IAAIkb,OAAO,KAAK,IAAI,EAAE;QACpB,KAAKhT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgT,OAAO,CAACpX,MAAM,EAAEoE,CAAC,EAAE,EAAE;UACnC,MAAMiT,KAAK,GAAGD,OAAO,CAAChT,CAAC,CAAC;UACxB,IAAIkT,YAAY,GAAGD,KAAK,CAACvU,MAAM,CAAC,CAAC,EAAEuU,KAAK,CAACrX,MAAM,GAAG,CAAC,CAAC;UACpD,MAAMuX,aAAa,GAAG,gBAAgB,CAAC1U,IAAI,CAACyU,YAAY,CAAC;UACzDA,YAAY,GAAGA,YAAY,CAAC1P,OAAO,CAAC,gBAAgB,EAAE,EAAE,CAAC;UAEzDtD,KAAK,GAAGoS,YAAY,CAACY,YAAY,CAAC;UAClC,IAAI9iB,OAAO,CAAC8P,KAAK,CAAC,EAAE;YAClBA,KAAK,GAAGiT,aAAa,GAAGjT,KAAK,CAACmS,WAAW,GAAGnS,KAAK,CAACA,KAAK;UACzD;UACA,IAAI9P,OAAO,CAAC8P,KAAK,CAAC,EAAE;YAClBvJ,IAAI,GAAGA,IAAI,CAAC6M,OAAO,CAACyP,KAAK,EAAE/S,KAAK,IAAI,EAAE,CAAC;UACzC;QACF;MACF;IACF;EACF,CAAC,MAAM,IAAI9P,OAAO,CAACkiB,YAAY,CAAC,EAAE;IAChC;IACA1S,IAAI,GAAGlF,MAAM,CAACkF,IAAI,CAAC0S,YAAY,CAAC;IAChC,IAAI1S,IAAI,CAAChE,MAAM,GAAG,CAAC,EAAE;MACnBjF,IAAI,GACF,wFAAwF;MAC1F,KAAKqJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,IAAI,CAAChE,MAAM,EAAEoE,CAAC,EAAE,EAAE;QAChC1B,GAAG,GAAGsB,IAAI,CAACI,CAAC,CAAC;QACbE,KAAK,GAAGoS,YAAY,CAAChU,GAAG,CAAC;QACzB3H,IAAI,IAAI,WAAWuJ,KAAK,CAACmS,WAAW,IAAI/T,GAAG,YAAY4B,KAAK,CAACA,KAAK,IAAI,EAAE,YAAY;MACtF;MACAvJ,IAAI,IAAI,kBAAkB;IAC5B;EACF;EAEA,IAAI,CAACvG,OAAO,CAACuG,IAAI,CAAC,EAAE;IAClB;IACA;EACF;;EAEA;EACAA,IAAI,GAAGe,UAAU,CAAC0b,IAAI,CAACzc,IAAI,CAAC;;EAE5B;EACA;EACA4b,UAAU,CAACc,SAAS,GAAG1c,IAAI;EAC3B,MAAM2c,KAAK,GAAGf,UAAU,CAACxS,gBAAgB,CAAC,GAAG,CAAC;EAC9C,KAAKC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsT,KAAK,CAAC1X,MAAM,EAAEoE,CAAC,EAAE,EAAE;IACjCsT,KAAK,CAACtT,CAAC,CAAC,CAACQ,YAAY,CAAC,QAAQ,EAAE,QAAQ,CAAC;EAC3C;;EAEA;EACA,IAAIpQ,OAAO,CAAC8O,WAAW,CAAC,IAAIA,WAAW,CAACU,IAAI,CAAChE,MAAM,GAAG,CAAC,EAAE;IACvD4D,aAAa,CAAC+S,UAAU,EAAE,GAAG,EAAE,MAAM,EAAErT,WAAW,CAAC;IACnDM,aAAa,CAAC+S,UAAU,EAAE,MAAM,EAAE,MAAM,EAAErT,WAAW,CAAC;IACtDM,aAAa,CAAC+S,UAAU,EAAE,MAAM,EAAE,MAAM,EAAErT,WAAW,CAAC;IACtDM,aAAa,CAAC+S,UAAU,EAAE,KAAK,EAAE,KAAK,EAAErT,WAAW,CAAC;IACpDM,aAAa,CAAC+S,UAAU,EAAE,QAAQ,EAAE,KAAK,EAAErT,WAAW,CAAC;IACvDM,aAAa,CAAC+S,UAAU,EAAE,OAAO,EAAE,KAAK,EAAErT,WAAW,CAAC;IACtDM,aAAa,CAAC+S,UAAU,EAAE,OAAO,EAAE,KAAK,EAAErT,WAAW,CAAC;IACtDM,aAAa,CAAC+S,UAAU,EAAE,QAAQ,EAAE,KAAK,EAAErT,WAAW,CAAC;IACvDM,aAAa,CAAC+S,UAAU,EAAE,OAAO,EAAE,KAAK,EAAErT,WAAW,CAAC;IACtDM,aAAa,CAAC+S,UAAU,EAAE,OAAO,EAAE,KAAK,EAAErT,WAAW,CAAC;IACtDM,aAAa,CAAC+S,UAAU,EAAE,OAAO,EAAE,KAAK,EAAErT,WAAW,CAAC;IACtDM,aAAa,CAAC+S,UAAU,EAAE,QAAQ,EAAE,KAAK,EAAErT,WAAW,CAAC;IACvDM,aAAa,CAAC+S,UAAU,EAAE,OAAO,EAAE,QAAQ,EAAErT,WAAW,CAAC;EAC3D;;EAEA;EACAuB,aAAa,CAAC8R,UAAU,EAAE,GAAG,EAAE,MAAM,EAAE7R,cAAc,CAAC;EACtDD,aAAa,CAAC8R,UAAU,EAAE,MAAM,EAAE,MAAM,EAAE7R,cAAc,CAAC;EACzDD,aAAa,CAAC8R,UAAU,EAAE,MAAM,EAAE,MAAM,EAAE7R,cAAc,CAAC;EACzDD,aAAa,CAAC8R,UAAU,EAAE,KAAK,EAAE,KAAK,EAAE7R,cAAc,CAAC;EACvDD,aAAa,CAAC8R,UAAU,EAAE,QAAQ,EAAE,KAAK,EAAE7R,cAAc,CAAC;EAC1DD,aAAa,CAAC8R,UAAU,EAAE,OAAO,EAAE,KAAK,EAAE7R,cAAc,CAAC;EACzDD,aAAa,CAAC8R,UAAU,EAAE,OAAO,EAAE,KAAK,EAAE7R,cAAc,CAAC;EACzDD,aAAa,CAAC8R,UAAU,EAAE,QAAQ,EAAE,KAAK,EAAE7R,cAAc,CAAC;EAC1DD,aAAa,CAAC8R,UAAU,EAAE,OAAO,EAAE,KAAK,EAAE7R,cAAc,CAAC;EACzDD,aAAa,CAAC8R,UAAU,EAAE,OAAO,EAAE,KAAK,EAAE7R,cAAc,CAAC;EACzDD,aAAa,CAAC8R,UAAU,EAAE,OAAO,EAAE,KAAK,EAAE7R,cAAc,CAAC;EACzDD,aAAa,CAAC8R,UAAU,EAAE,QAAQ,EAAE,KAAK,EAAE7R,cAAc,CAAC;EAC1DD,aAAa,CAAC8R,UAAU,EAAE,OAAO,EAAE,QAAQ,EAAE7R,cAAc,CAAC;EAE5D,IAAI8E,GAAG,GAAG,yDAAyD;EACnEA,GAAG,IAAI,gBAAgB;EACvBA,GAAG,IAAI,uBAAuB;EAC9BA,GAAG,IAAI,oBAAoBoN,UAAU,CAACW,gBAAgB,CAAC,CAAC,GAAG;EAC3D/N,GAAG,IAAI,SAASqN,UAAU,CAACU,gBAAgB,CAAC,CAAC,GAAG;EAChD/N,GAAG,IAAI,IAAI;EACXA,GAAG,IAAI,GAAG+M,UAAU,CAACc,SAAS,QAAQ;EACtCd,UAAU,CAACc,SAAS,GAAG,EAAE;;EAEzB;EACAjS,MAAM,CAAC4Q,WAAW,GAAGxM,GAAG;AAC1B;AAEA,SAASgO,cAAcA,CAACvZ,UAAU,EAAEyK,WAAW,EAAE1J,cAAc,EAAE;EAC/D,MAAMgG,gBAAgB,GAAGhG,cAAc,CAACgG,gBAAgB;EACxD,MAAM+Q,MAAM,GAAG/W,cAAc,CAACyY,YAAY;EAC1C,MAAM/S,cAAc,GAAG1F,cAAc,CAAC0F,cAAc;EACpD,MAAMxB,WAAW,GAAGlE,cAAc,CAACkE,WAAW;EAE9C,MAAMkC,MAAM,GAAGN,YAAY,CACzB4D,WAAW,EACX1D,gBAAgB,EAChBhG,cAAc,CAACiG,OACjB,CAAC;EACD,MAAM0R,OAAO,GAAGvR,MAAM,CAAC1I,GAAG;EAC1B,MAAMgS,WAAW,GAAGH,iBAAiB,CACnCtQ,UAAU,EACVyK,WAAW,EACX1J,cAAc,CAACyP,eAAe,EAC9B/J,cAAc,EACdxB,WACF,CAAC;EAED,MAAM4K,IAAI,GAAG1G,gBAAgB,CAACsB,WAAW,EAAE,MAAM,EAAEjM,UAAU,CAACC,GAAG,CAAC;EAClE0I,MAAM,CAAC0I,IAAI,GAAGA,IAAI;EAClB1I,MAAM,CAAC2Q,MAAM,GAAGA,MAAM;EAEtB,IAAIhC,YAAY,GAAG7K,eAAe,CAACR,WAAW,CAAC;EAC/C,IAAI,CAACtU,OAAO,CAAC2f,YAAY,CAAC,EAAE;IAC1BA,YAAY,GAAGtL,gBAAgB,CAACC,WAAW,CAAC;EAC9C;EACAtD,MAAM,CAAC2O,YAAY,GAAGA,YAAY;EAElC2D,2BAA2B,CAACtS,MAAM,CAAC;;EAEnC;EACA,SAASuS,iBAAiBA,CAACF,YAAY,EAAE;IACvC,IAAI,CAACA,YAAY,EAAE;MACjB,OAAO,IAAI;IACb;IACA,OAAOA,YAAY,CAAC1C,IAAI,IAAI4C,iBAAiB,CAACF,YAAY,CAAC1B,MAAM,CAAC;EACpE;EAEA,MAAM6B,UAAU,GAAGtQ,iBAAiB,CAClCoB,WAAW,EACX,YAAY,EACZjM,UAAU,CAACC,GACb,CAAC;EACD0I,MAAM,CAAC2P,IAAI,GAAG4C,iBAAiB,CAAC5B,MAAM,CAAC,KAAK6B,UAAU,IAAI,IAAI,CAAC;EAC/D;;EAEA,MAAMC,UAAU,GAAGlR,cAAc,CAAC+B,WAAW,EAAE,QAAQ,EAAEjM,UAAU,CAACG,IAAI,CAAC;EACzE,MAAMkb,MAAM,GAAGnB,OAAO,CAACmB,MAAM;EAC7BA,MAAM,CAAChK,IAAI,GAAG1G,gBAAgB,CAACyQ,UAAU,EAAE,MAAM,EAAEpb,UAAU,CAACG,IAAI,CAAC;EACnEkb,MAAM,CAACzT,GAAG,GAAG+C,gBAAgB,CAACyQ,UAAU,EAAE,KAAK,EAAEpb,UAAU,CAACG,IAAI,CAAC;EACjEkb,MAAM,CAAClc,KAAK,GAAGwL,gBAAgB,CAACyQ,UAAU,EAAE,OAAO,EAAEpb,UAAU,CAACG,IAAI,CAAC;EAErE,MAAMmb,QAAQ,GAAGpR,cAAc,CAAC+B,WAAW,EAAE,MAAM,EAAEjM,UAAU,CAACG,IAAI,CAAC;EACrE,MAAMwa,IAAI,GAAGT,OAAO,CAACS,IAAI;EACzBA,IAAI,CAAC7P,IAAI,GAAGpC,oBAAoB,CAAC4S,QAAQ,EAAE,MAAM,CAAC;EAClDX,IAAI,CAACY,QAAQ,GAAG7S,oBAAoB,CAAC4S,QAAQ,EAAE,UAAU,CAAC;EAC1DX,IAAI,CAACa,GAAG,GAAG9S,oBAAoB,CAAC4S,QAAQ,EAAE,KAAK,CAAC;EAChDX,IAAI,CAACc,IAAI,GAAG/S,oBAAoB,CAAC4S,QAAQ,EAAE,MAAM,CAAC;EAClDX,IAAI,CAACe,KAAK,GAAGhT,oBAAoB,CAAC4S,QAAQ,EAAE,OAAO,CAAC;EACpDX,IAAI,CAACxX,MAAM,GAAGuF,oBAAoB,CAAC4S,QAAQ,EAAE,QAAQ,CAAC;EAEtDpB,OAAO,CAACG,OAAO,GAAG1P,gBAAgB,CAACsB,WAAW,EAAE,SAAS,EAAEjM,UAAU,CAACC,GAAG,CAAC;EAC1Eia,OAAO,CAACyB,WAAW,GAAGhR,gBAAgB,CACpCsB,WAAW,EACX,aAAa,EACbjM,UAAU,CAACC,GACb,CAAC;EACDia,OAAO,CAACI,OAAO,GAAG3P,gBAAgB,CAACsB,WAAW,EAAE,SAAS,EAAEjM,UAAU,CAACC,GAAG,CAAC;EAE1EuZ,mBAAmB,CAACvN,WAAW,EAAEtD,MAAM,CAAC;EACxCsR,kBAAkB,CAChBhO,WAAW,EACXtD,MAAM,EACNsJ,WAAW,EACXxL,WAAW,EACXwB,cACF,CAAC;EAED,MAAMmB,SAAS,GAAG5H,UAAU,CAAC6N,UAAU;EACvCuM,aAAa,CAAC3P,WAAW,EAAEtD,MAAM,EAAES,SAAS,CAAC;EAC7CyS,aAAa,CAAC5P,WAAW,EAAEtD,MAAM,EAAES,SAAS,CAAC;EAE7C,IAAIzR,OAAO,CAACuS,cAAc,CAAC+B,WAAW,EAAE,QAAQ,EAAEjM,UAAU,CAACC,GAAG,CAAC,CAAC,EAAE;IAClExH,cAAc,CAAC,YAAY,EAAE,yCAAyC,CAAC;EACzE;EAEA,OAAO;IACLkQ,MAAM,EAAEA,MAAM;IACdsJ,WAAW,EAAEA;EACf,CAAC;AACH;AAEA,SAASzR,eAAeA,CAACgB,UAAU,EAAE8G,IAAI,EAAE/F,cAAc,EAAEuZ,eAAe,EAAE;EAC1EA,eAAe,CAACzZ,QAAQ,CAACiG,IAAI,CAAC8B,UAAU,EAAE7H,cAAc,CAAC;EACzDuZ,eAAe,CAAC7Y,OAAO,CAAC,CAAC;AAC3B;AAEA,SAASvC,aAAaA,CAACc,UAAU,EAAE8G,IAAI,EAAE/F,cAAc,EAAEuZ,eAAe,EAAE;EACxE,MAAMC,CAAC,GAAGhB,cAAc,CAACvZ,UAAU,EAAE8G,IAAI,EAAE/F,cAAc,CAAC;EAC1D,MAAMyZ,iBAAiB,GAAG3kB,KAAK,CAACkL,cAAc,CAAC;EAC/CyZ,iBAAiB,CAAChB,YAAY,GAAGe,CAAC,CAACpT,MAAM;EACzCnI,eAAe,CAACgB,UAAU,EAAE8G,IAAI,EAAE0T,iBAAiB,EAAEF,eAAe,CAAC;AACvE;AAEA,SAASlb,gBAAgBA,CACvBY,UAAU,EACVya,SAAS,EACT1Z,cAAc,EACduZ,eAAe,EACf;EACA,MAAMC,CAAC,GAAGhB,cAAc,CAACvZ,UAAU,EAAEya,SAAS,EAAE1Z,cAAc,CAAC;EAC/D,MAAMoG,MAAM,GAAGoT,CAAC,CAACpT,MAAM;EACvB,MAAMsJ,WAAW,GAAG8J,CAAC,CAAC9J,WAAW;EAEjC,IAAIiH,WAAW,GAAG,KAAK;EACvB,MAAM9O,UAAU,GAAG6R,SAAS,CAAC7R,UAAU;EACvC,KAAK,IAAI7C,CAAC,GAAG,CAAC,EAAE2J,GAAG,GAAG9G,UAAU,CAACjH,MAAM,EAAEoE,CAAC,GAAG2J,GAAG,IAAI,CAACgI,WAAW,EAAE3R,CAAC,EAAE,EAAE;IACrE,MAAM4R,SAAS,GAAG/O,UAAU,CAAC+G,IAAI,CAAC5J,CAAC,CAAC;IACpC,MAAM6R,iBAAiB,GAAGb,aAAa,CAACY,SAAS,CAAClV,SAAS,CAAC;IAC5D,IAAItM,OAAO,CAACyhB,iBAAiB,CAAC,EAAE;MAC9B;MACA;MACAA,iBAAiB,CACf5X,UAAU,EACVe,cAAc,CAACgG,gBAAgB,EAC/B4Q,SAAS,EACTxQ,MAAM,EACNsJ,WAAW,EACXtJ,MAAM,CAACF,EACT,CAAC;MACDyQ,WAAW,GAAG,IAAI;IACpB;EACF;EAEA,IAAI,CAACA,WAAW,EAAE;IAChBvQ,MAAM,CAAC6J,KAAK,CAACP,WAAW,CAAC;IACzB4C,uBAAuB,CAACrT,UAAU,EAAEmH,MAAM,EAAEsJ,WAAW,CAAC;EAC1D;AACF;AAEA,MAAMiK,sBAAsB,GAAG;EAC7BC,KAAK,EAAEC,gBAAgB;EACvBC,IAAI,EAAEC,eAAe;EACrBC,QAAQ,EAAEC,0BAA0B;EACpCC,cAAc,EAAED,0BAA0B;EAC1CE,WAAW,EAAEF;AACf,CAAC;AAED,SAASlb,WAAWA,CAACE,UAAU,EAAE8G,IAAI,EAAE/F,cAAc,EAAEuZ,eAAe,EAAE;EACtE,MAAMzK,IAAI,GAAG1G,gBAAgB,CAACrC,IAAI,EAAE,MAAM,EAAEtI,UAAU,CAACC,GAAG,CAAC;EAC3D,MAAMwI,EAAE,GAAGC,oBAAoB,CAACJ,IAAI,EAAE,IAAI,CAAC;EAC3C,MAAMqU,IAAI,GAAG,IAAIpiB,OAAO,CAAC8W,IAAI,EAAE5I,EAAE,CAAC;EAElC,MAAMmU,YAAY,GAAG1S,cAAc,CAAC5B,IAAI,EAAE,UAAU,EAAEtI,UAAU,CAACE,EAAE,CAAC;EACpE,IAAI0c,YAAY,EAAE;IAChB,MAAMxT,SAAS,GAAG5H,UAAU,CAAC6N,UAAU;IACvC,MAAMjF,UAAU,GAAGwS,YAAY,CAACxS,UAAU;IAC1C,KAAK,IAAI7C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6C,UAAU,CAACjH,MAAM,EAAEoE,CAAC,EAAE,EAAE;MAC1C,MAAMsV,SAAS,GAAGzS,UAAU,CAAC7C,CAAC,CAAC;MAC/B,IAAIsV,SAAS,CAAC5Y,SAAS,EAAE;QACvB,MAAM6Y,qBAAqB,GACzBZ,sBAAsB,CAACW,SAAS,CAAC5Y,SAAS,CAAC;QAC7C,IAAI6Y,qBAAqB,EAAE;UACzBA,qBAAqB,CAACH,IAAI,EAAEE,SAAS,EAAEzT,SAAS,CAAC;QACnD,CAAC,MAAM;UACL2T,OAAO,CAACC,GAAG,CACT,wCAAwCH,SAAS,CAAC5Y,SAAS,EAC7D,CAAC;QACH;MACF;IACF;EACF;EAEAzC,UAAU,CAACyb,SAAS,CAACza,IAAI,CAACma,IAAI,CAAC;AACjC;AAEA,SAASH,0BAA0BA,CAACG,IAAI,EAAEE,SAAS,EAAE;EACnDpkB,cAAc,CAAC,6BAA6BokB,SAAS,CAAC5Y,SAAS,EAAE,CAAC;AACpE;AAEA,SAASqY,eAAeA,CAACK,IAAI,EAAEE,SAAS,EAAE;EACxC,MAAMK,QAAQ,GAAGzS,iBAAiB,CAACoS,SAAS,EAAE,UAAU,EAAE7c,UAAU,CAACE,EAAE,CAAC;EACxEyc,IAAI,CAACQ,gBAAgB,CAAC,IAAI1iB,WAAW,CAACyiB,QAAQ,CAAC,CAAC;AAClD;AAEA,SAASd,gBAAgBA,CAACO,IAAI,EAAEE,SAAS,EAAEzT,SAAS,EAAE;EACpD,MAAM8T,QAAQ,GAAGzS,iBAAiB,CAACoS,SAAS,EAAE,UAAU,EAAE7c,UAAU,CAACE,EAAE,CAAC;EACxE,MAAMkd,SAAS,GAAGzS,gBAAgB,CAACkS,SAAS,EAAE,WAAW,EAAE7c,UAAU,CAACE,EAAE,CAAC;EAEzE,MAAMmd,CAAC,GAAG;IAAEpd,GAAG,EAAE,CAAC;EAAE,CAAC;EAErB2b,aAAa,CAACiB,SAAS,EAAEQ,CAAC,EAAEjU,SAAS,CAAC;EACtCyS,aAAa,CAACgB,SAAS,EAAEQ,CAAC,EAAEjU,SAAS,CAAC;EAEtC,MAAMkU,IAAI,GAAGD,CAAC,CAACpd,GAAG,CAACsd,MAAM,IAAIF,CAAC,CAACpd,GAAG,CAACsP,MAAM;EAEzC,MAAMiO,KAAK,GAAG,IAAIhjB,YAAY,CAAC0iB,QAAQ,EAAEE,SAAS,EAAEE,IAAI,CAAC;EACzDX,IAAI,CAACQ,gBAAgB,CAACK,KAAK,CAAC;AAC9B;AAEA,SAAS3B,aAAaA,CAAC5P,WAAW,EAAEtD,MAAM,EAAES,SAAS,EAAE;EACrD,MAAMmG,MAAM,GAAGrF,cAAc,CAAC+B,WAAW,EAAE,QAAQ,EAAEjM,UAAU,CAACC,GAAG,CAAC;EACpE,IAAItI,OAAO,CAAC4X,MAAM,CAAC,EAAE;IACnB,MAAMkO,GAAG,GAAGhT,iBAAiB,CAAC8E,MAAM,EAAE,WAAW,EAAEvP,UAAU,CAACC,GAAG,CAAC,IAAI,GAAG;IACzE,MAAMyd,GAAG,GAAGjT,iBAAiB,CAAC8E,MAAM,EAAE,UAAU,EAAEvP,UAAU,CAACC,GAAG,CAAC,IAAI,GAAG;IACxE,MAAM0d,QAAQ,GACZlT,iBAAiB,CAAC8E,MAAM,EAAE,UAAU,EAAEvP,UAAU,CAACC,GAAG,CAAC,IAAI,GAAG;IAE9D,MAAM6P,OAAO,GAAGrF,iBAAiB,CAAC8E,MAAM,EAAE,SAAS,EAAEvP,UAAU,CAACC,GAAG,CAAC,IAAI,GAAG;IAC3E,MAAM2d,IAAI,GAAGnT,iBAAiB,CAAC8E,MAAM,EAAE,MAAM,EAAEvP,UAAU,CAACC,GAAG,CAAC,IAAI,GAAG;IACrE,MAAM4d,IAAI,GAAGpT,iBAAiB,CAAC8E,MAAM,EAAE,MAAM,EAAEvP,UAAU,CAACC,GAAG,CAAC,IAAI,GAAG;IAErE,MAAMgU,QAAQ,GAAGhd,UAAU,CAACoS,WAAW,CAACoU,GAAG,EAAEC,GAAG,EAAEC,QAAQ,EAAEvU,SAAS,CAAC;IACtE,MAAM0U,GAAG,GAAG3lB,gBAAgB,CAACkR,WAAW,CAACyG,OAAO,EAAE8N,IAAI,GAAG,IAAI,EAAEC,IAAI,CAAC;IAEpElV,MAAM,CAAC1I,GAAG,CAACsP,MAAM,GAAG,IAAIlV,SAAS,CAAC4Z,QAAQ,EAAE6J,GAAG,CAAC;EAClD;AACF;AAEA,SAASlC,aAAaA,CAAC3P,WAAW,EAAEtD,MAAM,EAAES,SAAS,EAAE;EACrD,MAAMmU,MAAM,GAAGrT,cAAc,CAAC+B,WAAW,EAAE,QAAQ,EAAEjM,UAAU,CAACC,GAAG,CAAC;EACpE,IAAItI,OAAO,CAAC4lB,MAAM,CAAC,EAAE;IACnB,MAAME,GAAG,GAAGhT,iBAAiB,CAAC8S,MAAM,EAAE,WAAW,EAAEvd,UAAU,CAACC,GAAG,CAAC,IAAI,GAAG;IACzE,MAAMyd,GAAG,GAAGjT,iBAAiB,CAAC8S,MAAM,EAAE,UAAU,EAAEvd,UAAU,CAACC,GAAG,CAAC,IAAI,GAAG;IACxE,MAAM0d,QAAQ,GACZlT,iBAAiB,CAAC8S,MAAM,EAAE,UAAU,EAAEvd,UAAU,CAACC,GAAG,CAAC,IAAI,GAAG;IAC9D,IAAI6P,OAAO,GAAGrF,iBAAiB,CAAC8S,MAAM,EAAE,SAAS,EAAEvd,UAAU,CAACC,GAAG,CAAC;IAClE,IAAI2d,IAAI,GAAGnT,iBAAiB,CAAC8S,MAAM,EAAE,MAAM,EAAEvd,UAAU,CAACC,GAAG,CAAC;IAC5D,MAAM8d,KAAK,GAAGtT,iBAAiB,CAAC8S,MAAM,EAAE,OAAO,EAAEvd,UAAU,CAACC,GAAG,CAAC,IAAI,GAAG;IAEvE2d,IAAI,GAAGtlB,UAAU,CAACqY,SAAS,CAACiN,IAAI,IAAI,GAAG,CAAC;IACxC9N,OAAO,GAAGxX,UAAU,CAACqY,SAAS,CAACb,OAAO,IAAI,GAAG,CAAC;IAE9C,MAAMgO,GAAG,GAAG,IAAI5lB,iBAAiB,CAC/B4X,OAAO,EACP8N,IAAI,GAAGtlB,UAAU,CAAC0lB,WAAW,EAC7BD,KACF,CAAC;IACD,MAAME,SAAS,GAAGhnB,UAAU,CAACoS,WAAW,CAACoU,GAAG,EAAEC,GAAG,EAAEC,QAAQ,EAAEvU,SAAS,CAAC;IAEvET,MAAM,CAAC1I,GAAG,CAACsd,MAAM,GAAG,IAAIjjB,SAAS,CAAC2jB,SAAS,EAAEH,GAAG,CAAC;EACnD;AACF;AAEA,SAAS1c,oBAAoBA,CAC3BI,UAAU,EACV0c,iBAAiB,EACjB3b,cAAc,EACduZ,eAAe,EACf;EACA,MAAMqC,aAAa,GAAG5b,cAAc,CAAC6b,sBAAsB;EAC3D,IAAI,CAACzmB,OAAO,CAACwmB,aAAa,CAAC,EAAE;IAC3B,OAAOte,SAAS;EAClB;EAEA,MAAMoI,cAAc,GAAG1F,cAAc,CAAC0F,cAAc;EACpD,MAAMxB,WAAW,GAAGlE,cAAc,CAACkE,WAAW;EAE9C,MAAM4H,QAAQ,GAAGnE,cAAc,CAACgU,iBAAiB,EAAE,MAAM,EAAEle,UAAU,CAACC,GAAG,CAAC;EAC1E,MAAM+P,IAAI,GAAG5B,WAAW,CACtBC,QAAQ,EACR7M,UAAU,EACVyG,cAAc,EACdxB,WAAW,EACX,KACF,CAAC;EAED,IAAI,CAAC9O,OAAO,CAACqY,IAAI,CAAC,EAAE;IAClB,OAAOnQ,SAAS;EAClB;EAEA,MAAMwe,GAAG,GAAGtE,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;EACzCxY,UAAU,CAAC8c,eAAe,CAAC9b,IAAI,CAAC6b,GAAG,CAAC;EAEpCA,GAAG,CAACE,GAAG,GAAGvO,IAAI,CAAC5H,GAAG;EAClBiW,GAAG,CAACG,MAAM,GAAG,YAAY;IACvB,MAAMC,MAAM,GAAG,CAAC,oBAAoB,CAAC;IAErC,MAAMC,QAAQ,GAAGxU,cAAc,CAC7BgU,iBAAiB,EACjB,UAAU,EACVle,UAAU,CAACC,GACb,CAAC;IACD,MAAM0e,SAAS,GAAGzU,cAAc,CAC9BgU,iBAAiB,EACjB,WAAW,EACXle,UAAU,CAACC,GACb,CAAC;IACD,MAAMyE,IAAI,GAAGwF,cAAc,CAACgU,iBAAiB,EAAE,MAAM,EAAEle,UAAU,CAACC,GAAG,CAAC;IAEtE,IAAIwO,CAAC,EAAEC,CAAC;IACR,IAAIkQ,KAAK,EAAEC,KAAK;IAChB,IAAIC,MAAM,EAAEC,MAAM;IAElB,IAAIpnB,OAAO,CAAC+M,IAAI,CAAC,EAAE;MACjB+J,CAAC,GAAGxE,qBAAqB,CAACvF,IAAI,EAAE,GAAG,CAAC;MACpCgK,CAAC,GAAGzE,qBAAqB,CAACvF,IAAI,EAAE,GAAG,CAAC;MACpCka,KAAK,GAAGlW,oBAAoB,CAAChE,IAAI,EAAE,QAAQ,CAAC;MAC5Cma,KAAK,GAAGnW,oBAAoB,CAAChE,IAAI,EAAE,QAAQ,CAAC;MAE5C,IAAI/M,OAAO,CAAC8W,CAAC,CAAC,IAAIA,CAAC,KAAK,CAAC,CAAC,IAAIA,CAAC,KAAK,CAAC,EAAE;QACrC,IAAImQ,KAAK,KAAK,UAAU,EAAE;UACxBE,MAAM,GAAG,UAAUta,IAAI,CAACwa,KAAK,CAACvQ,CAAC,GAAG,GAAG,CAAC,GAAG;QAC3C,CAAC,MAAM,IAAImQ,KAAK,KAAK,QAAQ,EAAE;UAC7BE,MAAM,GAAG,UAAUrQ,CAAC,IAAI;QAC1B;QAEAgQ,MAAM,CAACjc,IAAI,CAACsc,MAAM,CAAC;MACrB;MAEA,IAAInnB,OAAO,CAAC+W,CAAC,CAAC,IAAIA,CAAC,KAAK,CAAC,CAAC,IAAIA,CAAC,KAAK,CAAC,EAAE;QACrC,IAAImQ,KAAK,KAAK,UAAU,EAAE;UACxBE,MAAM,GAAG,WAAWva,IAAI,CAACwa,KAAK,CAACtQ,CAAC,GAAG,GAAG,CAAC,GAAG;QAC5C,CAAC,MAAM,IAAImQ,KAAK,KAAK,QAAQ,EAAE;UAC7BE,MAAM,GAAG,WAAWrQ,CAAC,IAAI;QAC3B;QAEA+P,MAAM,CAACjc,IAAI,CAACuc,MAAM,CAAC;MACrB;IACF;;IAEA;IACAV,GAAG,CAACnQ,KAAK,GAAGuQ,MAAM,CAACQ,IAAI,CAAC,GAAG,CAAC;IAE5B,IAAIC,OAAO,GAAG,CAAC;IACf,IAAIC,OAAO,GAAGd,GAAG,CAAC3U,MAAM;IAExB,IAAI/R,OAAO,CAACgnB,SAAS,CAAC,EAAE;MACtBlQ,CAAC,GAAGxE,qBAAqB,CAAC0U,SAAS,EAAE,GAAG,CAAC;MACzCjQ,CAAC,GAAGzE,qBAAqB,CAAC0U,SAAS,EAAE,GAAG,CAAC;MACzCC,KAAK,GAAGlW,oBAAoB,CAACiW,SAAS,EAAE,QAAQ,CAAC;MACjDE,KAAK,GAAGnW,oBAAoB,CAACiW,SAAS,EAAE,QAAQ,CAAC;MAEjD,IAAIhnB,OAAO,CAAC8W,CAAC,CAAC,EAAE;QACd,IAAImQ,KAAK,KAAK,UAAU,EAAE;UACxBM,OAAO,GAAGzQ,CAAC,GAAG4P,GAAG,CAAClR,KAAK;QACzB,CAAC,MAAM,IAAIyR,KAAK,KAAK,QAAQ,EAAE;UAC7BM,OAAO,GAAGzQ,CAAC;QACb,CAAC,MAAM,IAAImQ,KAAK,KAAK,aAAa,EAAE;UAClCM,OAAO,GAAGzQ,CAAC;QACb;MACF;MAEA,IAAI9W,OAAO,CAAC+W,CAAC,CAAC,EAAE;QACd,IAAImQ,KAAK,KAAK,UAAU,EAAE;UACxBM,OAAO,GAAGzQ,CAAC,GAAG2P,GAAG,CAAC3U,MAAM;QAC1B,CAAC,MAAM,IAAImV,KAAK,KAAK,QAAQ,EAAE;UAC7BM,OAAO,GAAGzQ,CAAC;QACb,CAAC,MAAM,IAAImQ,KAAK,KAAK,aAAa,EAAE;UAClCM,OAAO,GAAGzQ,CAAC;QACb;MACF;IACF;IAEA,IAAI/W,OAAO,CAAC+mB,QAAQ,CAAC,EAAE;MACrBjQ,CAAC,GAAGxE,qBAAqB,CAACyU,QAAQ,EAAE,GAAG,CAAC;MACxChQ,CAAC,GAAGzE,qBAAqB,CAACyU,QAAQ,EAAE,GAAG,CAAC;MACxCE,KAAK,GAAGlW,oBAAoB,CAACgW,QAAQ,EAAE,QAAQ,CAAC;MAChDG,KAAK,GAAGnW,oBAAoB,CAACgW,QAAQ,EAAE,QAAQ,CAAC;MAEhD,IAAI/mB,OAAO,CAAC8W,CAAC,CAAC,EAAE;QACd,IAAImQ,KAAK,KAAK,UAAU,EAAE;UACxBE,MAAM,GAAG,GAAG,QAAQ,GAAG,OAAO,GAAGta,IAAI,CAACwa,KAAK,CACzCvQ,CAAC,GAAG,GACN,CAAC,OAAOyQ,OAAO,KAAK;QACtB,CAAC,MAAM,IAAIN,KAAK,KAAK,QAAQ,EAAE;UAC7BE,MAAM,GAAG,SAASrQ,CAAC,GAAGyQ,OAAO,IAAI;QACnC,CAAC,MAAM,IAAIN,KAAK,KAAK,aAAa,EAAE;UAClCE,MAAM,GAAG,UAAUrQ,CAAC,GAAGyQ,OAAO,IAAI;QACpC;QAEAT,MAAM,CAACjc,IAAI,CAACsc,MAAM,CAAC;MACrB;MAEA,IAAInnB,OAAO,CAAC+W,CAAC,CAAC,EAAE;QACd,IAAImQ,KAAK,KAAK,UAAU,EAAE;UACxBE,MAAM,GAAG,GAAG,UAAU,GAAG,OAAO,GAAGva,IAAI,CAACwa,KAAK,CAC3CtQ,CAAC,GAAG,GACN,CAAC,OAAOyQ,OAAO,KAAK;QACtB,CAAC,MAAM,IAAIN,KAAK,KAAK,QAAQ,EAAE;UAC7BE,MAAM,GAAG,WAAWrQ,CAAC,GAAGyQ,OAAO,IAAI;QACrC,CAAC,MAAM,IAAIN,KAAK,KAAK,aAAa,EAAE;UAClCE,MAAM,GAAG,QAAQrQ,CAAC,GAAGyQ,OAAO,IAAI;QAClC;QAEAV,MAAM,CAACjc,IAAI,CAACuc,MAAM,CAAC;MACrB;IACF;IAEAV,GAAG,CAACnQ,KAAK,GAAGuQ,MAAM,CAACQ,IAAI,CAAC,GAAG,CAAC;EAC9B,CAAC;EAEDd,aAAa,CAACiB,WAAW,CAACf,GAAG,CAAC;AAChC;AAEA,SAASrd,oBAAoBA,CAC3BQ,UAAU,EACV6d,aAAa,EACb9c,cAAc,EACduZ,eAAe,EACf;EACA,MAAMC,CAAC,GAAGhB,cAAc,CAACvZ,UAAU,EAAE6d,aAAa,EAAE9c,cAAc,CAAC;EACnE,MAAMoG,MAAM,GAAGoT,CAAC,CAACpT,MAAM;EAEvB,IAAI2W,QAAQ;EACZ,IAAIC,YAAY,GAAG,KAAK;EAExB,MAAMnW,SAAS,GAAG5H,UAAU,CAAC6N,UAAU;EACvC,MAAM6E,SAAS,GAAGtK,eAAe,CAC/BM,cAAc,CAACmV,aAAa,EAAE,YAAY,EAAErf,UAAU,CAACE,EAAE,CAAC,EAC1DkJ,SACF,CAAC;EACD,MAAM2M,MAAM,GAAGtL,iBAAiB,CAAC4U,aAAa,EAAE,WAAW,EAAErf,UAAU,CAACC,GAAG,CAAC;EAC5E,IAAItI,OAAO,CAACuc,SAAS,CAAC,EAAE;IACtBoL,QAAQ,GAAGhS,oBAAoB,CAAC,CAAC;IACjCgS,QAAQ,CAAC3I,SAAS,GAAG,IAAIhe,gBAAgB,CAACub,SAAS,CAAC;IACpDoL,QAAQ,CAACvJ,MAAM,GAAGA,MAAM;IACxBpN,MAAM,CAAC4E,OAAO,GAAG+R,QAAQ;IACzBC,YAAY,GAAG,IAAI;EACrB,CAAC,MAAM;IACLD,QAAQ,GAAG,IAAIvkB,iBAAiB,CAAC,CAAC;IAClCukB,QAAQ,CAACvJ,MAAM,GAAGA,MAAM;IACxBpN,MAAM,CAAC6W,SAAS,GAAGF,QAAQ;IAE3B,MAAMG,SAAS,GAAGvV,cAAc,CAC9BmV,aAAa,EACb,WAAW,EACXrf,UAAU,CAACC,GACb,CAAC;IACD,IAAItI,OAAO,CAAC8nB,SAAS,CAAC,EAAE;MACtB,IAAIC,IAAI,GAAGjV,iBAAiB,CAACgV,SAAS,EAAE,MAAM,EAAEzf,UAAU,CAACC,GAAG,CAAC;MAC/D,IAAI0f,KAAK,GAAGlV,iBAAiB,CAACgV,SAAS,EAAE,OAAO,EAAEzf,UAAU,CAACC,GAAG,CAAC;MACjE,IAAI2f,IAAI,GAAGnV,iBAAiB,CAACgV,SAAS,EAAE,MAAM,EAAEzf,UAAU,CAACC,GAAG,CAAC;MAC/D,IAAI4f,KAAK,GAAGpV,iBAAiB,CAACgV,SAAS,EAAE,OAAO,EAAEzf,UAAU,CAACC,GAAG,CAAC;MAEjE,IAAItI,OAAO,CAAC+nB,IAAI,CAAC,EAAE;QACjBA,IAAI,GAAGpnB,UAAU,CAACwnB,cAAc,CAACxnB,UAAU,CAACqY,SAAS,CAAC+O,IAAI,CAAC,CAAC;MAC9D;MACA,IAAI/nB,OAAO,CAACgoB,KAAK,CAAC,EAAE;QAClBA,KAAK,GAAGrnB,UAAU,CAACynB,oBAAoB,CAACznB,UAAU,CAACqY,SAAS,CAACgP,KAAK,CAAC,CAAC;MACtE;MACA,IAAIhoB,OAAO,CAACioB,IAAI,CAAC,EAAE;QACjBA,IAAI,GAAGtnB,UAAU,CAACwnB,cAAc,CAACxnB,UAAU,CAACqY,SAAS,CAACiP,IAAI,CAAC,CAAC;MAC9D;MACA,IAAIjoB,OAAO,CAACkoB,KAAK,CAAC,EAAE;QAClBA,KAAK,GAAGvnB,UAAU,CAACynB,oBAAoB,CAACznB,UAAU,CAACqY,SAAS,CAACkP,KAAK,CAAC,CAAC;MACtE;MACAP,QAAQ,CAACtJ,WAAW,GAAG,IAAInd,SAAS,CAAC6mB,IAAI,EAAEC,KAAK,EAAEC,IAAI,EAAEC,KAAK,CAAC;MAE9D,MAAMnP,QAAQ,GAAGjG,iBAAiB,CAACgV,SAAS,EAAE,UAAU,EAAEzf,UAAU,CAACC,GAAG,CAAC;MACzE,IAAItI,OAAO,CAAC+Y,QAAQ,CAAC,EAAE;QACrB,MAAMsP,eAAe,GAAG1nB,UAAU,CAACqY,SAAS,CAACD,QAAQ,CAAC;QACtD4O,QAAQ,CAAC5O,QAAQ,GAAGsP,eAAe;QACnCV,QAAQ,CAACW,UAAU,GAAGD,eAAe;MACvC;IACF;EACF;EAEA,MAAM3R,QAAQ,GAAGnE,cAAc,CAACmV,aAAa,EAAE,MAAM,EAAErf,UAAU,CAACC,GAAG,CAAC;EACtE,MAAM6K,IAAI,GAAGsD,WAAW,CACtBC,QAAQ,EACR7M,UAAU,EACVe,cAAc,CAAC0F,cAAc,EAC7B1F,cAAc,CAACkE,WAAW,EAC1B,IACF,CAAC;EACD,IAAI9O,OAAO,CAACmT,IAAI,CAAC,EAAE;IACjB,IAAIyU,YAAY,EAAE;MAChB9mB,cAAc,CACZ,mBAAmB,EACnB,+DACF,CAAC;IACH;IACA,MAAMgW,CAAC,GAAGhE,iBAAiB,CAAC4D,QAAQ,EAAE,GAAG,EAAErO,UAAU,CAACE,EAAE,CAAC;IACzD,MAAMwO,CAAC,GAAGjE,iBAAiB,CAAC4D,QAAQ,EAAE,GAAG,EAAErO,UAAU,CAACE,EAAE,CAAC;IACzD,MAAM+P,CAAC,GAAGxF,iBAAiB,CAAC4D,QAAQ,EAAE,GAAG,EAAErO,UAAU,CAACE,EAAE,CAAC;IACzD,MAAMgQ,CAAC,GAAGzF,iBAAiB,CAAC4D,QAAQ,EAAE,GAAG,EAAErO,UAAU,CAACE,EAAE,CAAC;IAEzD,IAAIvI,OAAO,CAAC8W,CAAC,CAAC,IAAI9W,OAAO,CAAC+W,CAAC,CAAC,IAAI/W,OAAO,CAACsY,CAAC,CAAC,IAAItY,OAAO,CAACuY,CAAC,CAAC,EAAE;MACxDzX,cAAc,CACZ,wBAAwB,EACxB,kEACF,CAAC;IACH;IAEA6mB,QAAQ,CAAC/N,QAAQ,GAAGzG,IAAI;IACxBwU,QAAQ,CAAC/N,QAAQ,CAACxB,KAAK,GAAGhE,eAAe,CACvCsT,aAAa,EACb,OAAO,EACPrf,UAAU,CAACC,GACb,CAAC;IACDqf,QAAQ,CAAC/N,QAAQ,CAAC2O,WAAW,GAAG,IAAI;EACtC,CAAC,MAAM;IACLZ,QAAQ,CAAC/N,QAAQ,GAAGxF,eAAe,CAACsT,aAAa,EAAE,OAAO,EAAErf,UAAU,CAACC,GAAG,CAAC;EAC7E;EAEA,IAAIgJ,YAAY,GAAG0B,gBAAgB,CACjC0U,aAAa,EACb,cAAc,EACdrf,UAAU,CAACC,GACb,CAAC;EAED,IAAItI,OAAO,CAACsR,YAAY,CAAC,EAAE;IACzB,IAAIA,YAAY,KAAK,UAAU,EAAE;MAC/B;MACAqW,QAAQ,CAAC5V,MAAM,GAAGe,iBAAiB,CACjC4U,aAAa,EACb,UAAU,EACVrf,UAAU,CAACC,GACb,CAAC;MACDqf,QAAQ,CAACvJ,MAAM,GAAGlW,SAAS;IAC7B,CAAC,MAAM,IAAIoJ,YAAY,KAAK,eAAe,EAAE;MAC3CxQ,cAAc,CACZ,0BAA0B,EAC1B,+BAA+BwQ,YAAY,EAC7C,CAAC;IACH;IACA;EACF,CAAC,MAAM;IACLA,YAAY,GAAG0B,gBAAgB,CAC7B0U,aAAa,EACb,cAAc,EACdrf,UAAU,CAACE,EACb,CAAC;IACD,IAAI+I,YAAY,KAAK,oBAAoB,EAAE;MACzCxQ,cAAc,CACZ,qCAAqC,EACrC,yFACF,CAAC;MACD6mB,QAAQ,CAAC5V,MAAM,GAAGe,iBAAiB,CACjC4U,aAAa,EACb,UAAU,EACVrf,UAAU,CAACC,GACb,CAAC;MACDqf,QAAQ,CAACvJ,MAAM,GAAGlW,SAAS;IAC7B,CAAC,MAAM,IAAIoJ,YAAY,KAAK,iBAAiB,EAAE;MAC7CxQ,cAAc,CACZ,kCAAkC,EAClC,2FACF,CAAC;IACH,CAAC,MAAM,IAAId,OAAO,CAACsR,YAAY,CAAC,EAAE;MAChCxQ,cAAc,CACZ,0BAA0B,EAC1B,+BAA+BwQ,YAAY,EAC7C,CAAC;IACH;EACF;AACF;AAEA,SAAS/H,yBAAyBA,CAChCM,UAAU,EACV8G,IAAI,EACJ/F,cAAc,EACduZ,eAAe,EACf;EACAta,UAAU,CAAC2e,gBAAgB,CAACC,UAAU,CACpC5e,UAAU,EACVe,cAAc,CAACyY,YAAY,EAC3B1S,IAAI,EACJ/F,cAAc,CAACgG,gBAAgB,EAC/BhG,cAAc,CAACyP,eAAe,EAC9BzP,cAAc,CAAC0F,cAAc,EAC7B1F,cAAc,CAACkE,WACjB,CAAC;EACDhO,cAAc,CACZ,0BAA0B6P,IAAI,CAAC+X,QAAQ,EAAE,EACzC,8BAA8B/X,IAAI,CAAC+X,QAAQ,EAC7C,CAAC;AACH;AAEA,MAAMC,WAAW,GAAG;EAClBC,QAAQ,EAAE,CAAC;EACXC,MAAM,EAAE,CAAC;EACTC,IAAI,EAAE;AACR,CAAC;AAED,SAASrR,aAAaA,CAACsR,CAAC,EAAE;EACxB,IAAI,CAAC/oB,OAAO,CAAC+oB,CAAC,CAAC,IAAIA,CAAC,CAACvd,MAAM,KAAK,CAAC,EAAE;IACjC,OAAO,EAAE;EACX;EAEA,MAAMwd,MAAM,GAAGD,CAAC,CAAC,CAAC,CAAC;EACnB,IAAIC,MAAM,KAAK,GAAG,IAAIA,MAAM,KAAK,GAAG,EAAE;IACpCD,CAAC,GAAGA,CAAC,CAAC/U,SAAS,CAAC,CAAC,CAAC;EACpB;EAEA,OAAO+U,CAAC;AACV;AAEA,MAAME,aAAa,GAAG,IAAI/nB,SAAS,CAAC,CAAC;AACrC,MAAMgoB,mBAAmB,GAAG,IAAI3pB,YAAY,CAAC,CAAC;AAC9C,MAAM4pB,iBAAiB,GAAG,IAAI9pB,UAAU,CAAC,CAAC;AAC1C,MAAM+pB,iBAAiB,GAAG,IAAI9pB,UAAU,CAAC,CAAC;AAE1C,SAASqY,6BAA6BA,CACpCpH,QAAQ,EACRqH,MAAM,EACNC,MAAM,EACNT,cAAc,EACdW,IAAI,EACJtG,SAAS,EACT;EACA,SAAS4X,WAAWA,CAACvZ,KAAK,EAAE;IAC1B,IAAIA,KAAK,GAAG,CAACnP,UAAU,CAAC0lB,WAAW,EAAE;MACnC,OAAO,CAAC1lB,UAAU,CAAC0lB,WAAW;IAChC,CAAC,MAAM,IAAIvW,KAAK,GAAGnP,UAAU,CAAC0lB,WAAW,EAAE;MACzC,OAAO1lB,UAAU,CAAC0lB,WAAW;IAC/B;IACA,OAAOvW,KAAK;EACd;EAEA,SAASwZ,YAAYA,CAACxZ,KAAK,EAAE;IAC3B,IAAIA,KAAK,GAAGnP,UAAU,CAAC4oB,EAAE,EAAE;MACzB,OAAOzZ,KAAK,GAAGnP,UAAU,CAAC6oB,MAAM;IAClC,CAAC,MAAM,IAAI1Z,KAAK,GAAG,CAACnP,UAAU,CAAC4oB,EAAE,EAAE;MACjC,OAAOzZ,KAAK,GAAGnP,UAAU,CAAC6oB,MAAM;IAClC;IAEA,OAAO1Z,KAAK;EACd;EAEA,IAAI2Z,WAAW,GAAG5oB,aAAa,CAAC0P,QAAQ,CAACmZ,eAAe,CAAC;;EAEzD;EACAD,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CAACA,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC;EAEnE,IAAIpT,OAAO,CAAC4X,MAAM,CAAC,IAAIA,MAAM,CAAC+R,KAAK,KAAKjoB,SAAS,CAACkoB,QAAQ,EAAE;IAC1D,IAAIC,eAAe;IACnB,IAAIC,kBAAkB;IAEtB/R,IAAI,GAAGA,IAAI,IAAIkR,aAAa;IAC5B,IAAIjpB,OAAO,CAAC6X,MAAM,CAAC,EAAE;MACnBsR,iBAAiB,CAACrS,CAAC,GAAGe,MAAM,CAACkS,WAAW,GAAG,GAAG;MAC9CZ,iBAAiB,CAACpS,CAAC,GAAGc,MAAM,CAACmS,YAAY,GAAG,GAAG;MAC/CH,eAAe,GAAGjS,MAAM,CAACqS,aAAa,CACpCd,iBAAiB,EACjB1X,SAAS,EACT2X,iBACF,CAAC;IACH;IAEA,IAAIppB,OAAO,CAAC6pB,eAAe,CAAC,EAAE;MAC5BC,kBAAkB,GAAGrY,SAAS,CAACyY,uBAAuB,CACpDL,eAAe,EACfX,mBACF,CAAC;IACH,CAAC,MAAM;MACLY,kBAAkB,GAAG5oB,SAAS,CAACipB,MAAM,CAACpS,IAAI,EAAEmR,mBAAmB,CAAC;MAChEW,eAAe,GAAGpY,SAAS,CAAC2Y,uBAAuB,CAACN,kBAAkB,CAAC;IACzE;IAEA,IACE9pB,OAAO,CAACoX,cAAc,CAAC,IACvB,CAACzW,UAAU,CAAC0pB,aAAa,CAACjT,cAAc,EAAE,GAAG,EAAEzW,UAAU,CAAC2pB,QAAQ,CAAC,EACnE;MACA,MAAMC,YAAY,GAAGxS,IAAI,CAACvC,KAAK,GAAG4B,cAAc,GAAG,GAAG;MACtD,MAAMoT,aAAa,GAAGzS,IAAI,CAAChG,MAAM,GAAGqF,cAAc,GAAG,GAAG;MACxDW,IAAI,GAAG,IAAI7W,SAAS,CAClBooB,YAAY,CAACQ,kBAAkB,CAAClY,SAAS,GAAG2Y,YAAY,CAAC,EACzDlB,WAAW,CAACS,kBAAkB,CAAChY,QAAQ,GAAG0Y,aAAa,CAAC,EACxDlB,YAAY,CAACQ,kBAAkB,CAAClY,SAAS,GAAG2Y,YAAY,CAAC,EACzDlB,WAAW,CAACS,kBAAkB,CAAChY,QAAQ,GAAG0Y,aAAa,CACzD,CAAC;IACH;IAEAf,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAC/B,YAAY,EACZzS,UAAU,CAAC8pB,SAAS,CAAC1S,IAAI,CAACgQ,IAAI,CAAC,CAAC5X,QAAQ,CAAC,CAC3C,CAAC;IACDsZ,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAC/B,aAAa,EACbzS,UAAU,CAAC8pB,SAAS,CAAC1S,IAAI,CAACiQ,KAAK,CAAC,CAAC7X,QAAQ,CAAC,CAC5C,CAAC;IACDsZ,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAC/B,YAAY,EACZzS,UAAU,CAAC8pB,SAAS,CAAC1S,IAAI,CAACkQ,IAAI,CAAC,CAAC9X,QAAQ,CAAC,CAC3C,CAAC;IACDsZ,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAC/B,aAAa,EACbzS,UAAU,CAAC8pB,SAAS,CAAC1S,IAAI,CAACmQ,KAAK,CAAC,CAAC/X,QAAQ,CAAC,CAC5C,CAAC;IAED,MAAM2V,GAAG,GAAGnlB,UAAU,CAAC8pB,SAAS,CAACX,kBAAkB,CAAClY,SAAS,CAAC,CAACzB,QAAQ,CAAC,CAAC;IACzE,MAAM4V,GAAG,GAAGplB,UAAU,CAAC8pB,SAAS,CAACX,kBAAkB,CAAChY,QAAQ,CAAC,CAAC3B,QAAQ,CAAC,CAAC;IACxEsZ,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,aAAa,EAAE0S,GAAG,CAAC;IACrD2D,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,aAAa,EAAE2S,GAAG,CAAC;IACrD0D,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAC/B,cAAc,EACdzS,UAAU,CAAC8pB,SAAS,CAAC7S,MAAM,CAAC8S,KAAK,CAAC,CAACva,QAAQ,CAAC,CAC9C,CAAC;IACDsZ,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAC/B,iBAAiB,EACjBzS,UAAU,CAAC8pB,SAAS,CAAC7S,MAAM,CAACO,OAAO,CAAC,CAAChI,QAAQ,CAAC,CAChD,CAAC;IACDsZ,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAC/B,eAAe,EACf9T,UAAU,CAACqrB,QAAQ,CAAC/S,MAAM,CAACgT,UAAU,EAAEf,eAAe,CACxD,CAAC;IACDJ,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,oBAAoB,EAAE0S,GAAG,CAAC;IAC5D2D,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,oBAAoB,EAAE2S,GAAG,CAAC;IAC5D0D,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAC/B,oBAAoB,EACpB0W,kBAAkB,CAAC/X,MAAM,CAAC5B,QAAQ,CAAC,CACrC,CAAC;IAEDsB,SAAS,CAACyY,uBAAuB,CAACtS,MAAM,CAACgT,UAAU,EAAE1B,mBAAmB,CAAC;IACzEO,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAC/B,aAAa,EACbzS,UAAU,CAAC8pB,SAAS,CAACvB,mBAAmB,CAACtX,SAAS,CAAC,CAACzB,QAAQ,CAAC,CAC/D,CAAC;IACDsZ,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAC/B,aAAa,EACbzS,UAAU,CAAC8pB,SAAS,CAACvB,mBAAmB,CAACpX,QAAQ,CAAC,CAAC3B,QAAQ,CAAC,CAC9D,CAAC;IACDsZ,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAC/B,aAAa,EACbzS,UAAU,CAAC8pB,SAAS,CAACvB,mBAAmB,CAACnX,MAAM,CAAC,CAAC5B,QAAQ,CAAC,CAC5D,CAAC;IAED,MAAM0a,OAAO,GAAGjT,MAAM,CAACiT,OAAO;IAC9B,MAAMC,WAAW,GAAGD,OAAO,CAACC,WAAW;IACvC,IAAIC,QAAQ,GAAG,EAAE;IACjB,IAAIC,OAAO,GAAG,EAAE;IAChB,IAAIhrB,OAAO,CAAC8qB,WAAW,CAAC,EAAE;MACxB,MAAMG,GAAG,GAAGtqB,UAAU,CAAC8pB,SAAS,CAACI,OAAO,CAACI,GAAG,CAAC;MAC7C,IAAIH,WAAW,GAAG,GAAG,EAAE;QACrBC,QAAQ,GAAGE,GAAG;QACdD,OAAO,GAAGC,GAAG,GAAGH,WAAW;MAC7B,CAAC,MAAM;QACLE,OAAO,GAAGC,GAAG;QACbF,QAAQ,GAAGE,GAAG,GAAGH,WAAW;MAC9B;IACF;IACArB,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,YAAY,EAAE2X,QAAQ,CAAC5a,QAAQ,CAAC,CAAC,CAAC;IACpEsZ,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,WAAW,EAAE4X,OAAO,CAAC7a,QAAQ,CAAC,CAAC,CAAC;EACpE,CAAC,MAAM;IACLsZ,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,YAAY,EAAE,MAAM,CAAC;IACvDqW,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,aAAa,EAAE,KAAK,CAAC;IACvDqW,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,YAAY,EAAE,KAAK,CAAC;IACtDqW,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,aAAa,EAAE,IAAI,CAAC;IAEtDqW,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,aAAa,EAAE,EAAE,CAAC;IACpDqW,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,aAAa,EAAE,EAAE,CAAC;IACpDqW,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,eAAe,EAAE,EAAE,CAAC;IACtDqW,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,cAAc,EAAE,EAAE,CAAC;IACrDqW,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,iBAAiB,EAAE,EAAE,CAAC;IACxDqW,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,oBAAoB,EAAE,EAAE,CAAC;IAC3DqW,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,oBAAoB,EAAE,EAAE,CAAC;IAC3DqW,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,oBAAoB,EAAE,EAAE,CAAC;IAE3DqW,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,aAAa,EAAE,EAAE,CAAC;IACpDqW,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,aAAa,EAAE,EAAE,CAAC;IACpDqW,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,aAAa,EAAE,EAAE,CAAC;IACpDqW,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC;IACnDqW,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC;EACpD;EAEA,IAAIpT,OAAO,CAAC6X,MAAM,CAAC,EAAE;IACnB4R,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,eAAe,EAAEyE,MAAM,CAACkS,WAAW,CAAC;IACtEN,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,cAAc,EAAEyE,MAAM,CAACmS,YAAY,CAAC;EACxE,CAAC,MAAM;IACLP,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,eAAe,EAAE,EAAE,CAAC;IACtDqW,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,cAAc,EAAE,EAAE,CAAC;EACvD;EAEAqW,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,kBAAkB,EAAE,GAAG,CAAC;EAC1DqW,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,iBAAiB,EAAE,GAAG,CAAC;EACzDqW,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,cAAc,EAAE,KAAK,CAAC;EACxDqW,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,cAAc,EAAE,QAAQ,CAAC;EAC3DqW,WAAW,GAAGA,WAAW,CAACrW,OAAO,CAAC,YAAY,EAAE,SAAS,CAAC;EAE1D7C,QAAQ,CAACiH,kBAAkB,CAACvW,aAAa,CAACwoB,WAAW,CAAC,CAAC;AACzD;AAEA,SAAStgB,kBAAkBA,CAACU,UAAU,EAAE8G,IAAI,EAAE/F,cAAc,EAAEuZ,eAAe,EAAE;EAC7E,MAAMC,CAAC,GAAGhB,cAAc,CAACvZ,UAAU,EAAE8G,IAAI,EAAE/F,cAAc,CAAC;EAC1D,MAAMsgB,aAAa,GAAG9G,CAAC,CAACpT,MAAM;EAE9B,MAAMV,cAAc,GAAG1F,cAAc,CAAC0F,cAAc;EACpD,MAAMxB,WAAW,GAAGlE,cAAc,CAACkE,WAAW;EAE9C,IAAIkU,IAAI,GAAGzQ,cAAc,CAAC5B,IAAI,EAAE,MAAM,EAAEtI,UAAU,CAACC,GAAG,CAAC;EAEvD,IAAI,CAACtI,OAAO,CAACgjB,IAAI,CAAC,EAAE;IAClBA,IAAI,GAAGzQ,cAAc,CAAC5B,IAAI,EAAE,KAAK,EAAEtI,UAAU,CAACC,GAAG,CAAC;EACpD;EACA,IAAItI,OAAO,CAACgjB,IAAI,CAAC,EAAE;IACjB,IAAI7P,IAAI,GAAGH,gBAAgB,CAACgQ,IAAI,EAAE,MAAM,EAAE3a,UAAU,CAACC,GAAG,CAAC;IACzD,IAAI6O,eAAe;IACnB,IAAIC,cAAc;IAClB,IAAIpX,OAAO,CAACmT,IAAI,CAAC,EAAE;MACjB,IAAIgY,YAAY,GAAGhY,IAAI;MACvBA,IAAI,GAAG3C,WAAW,CAAC2C,IAAI,EAAE7C,cAAc,EAAE1F,cAAc,CAACkE,WAAW,CAAC;;MAEpE;MACA;MACA,IAAI,QAAQ,CAACT,IAAI,CAAC8E,IAAI,CAACE,eAAe,CAAC,CAAC,CAAC,EAAE;QACzC;QACA,IAAI,CAAC,QAAQ,CAAChF,IAAI,CAACiC,cAAc,CAAC+C,eAAe,CAAC,CAAC,CAAC,EAAE;UACpD8X,YAAY,GAAG7a,cAAc,CAACgD,kBAAkB,CAAC;YAC/C7C,GAAG,EAAE0a;UACP,CAAC,CAAC;QACJ;MACF,CAAC,MAAM;QACLA,YAAY,GAAGhY,IAAI,CAACzT,KAAK,CAAC,CAAC,CAAC,CAAC;QAC7ByX,eAAe,GAAGnE,gBAAgB,CAChCgQ,IAAI,EACJ,iBAAiB,EACjB3a,UAAU,CAACC,GACb,CAAC;QACD,IAAI6O,eAAe,KAAK,UAAU,EAAE;UAClCrW,cAAc,CACZ,yBAAyB,EACzB,6CACF,CAAC;UACD;QACF;QACAsW,cAAc,GACZpE,gBAAgB,CAACgQ,IAAI,EAAE,gBAAgB,EAAE3a,UAAU,CAACC,GAAG,CAAC,IAAI,GAAG;QACjE,MAAM+O,iBAAiB,GACrBF,eAAe,KAAK,QAAQ,GACxB,oDAAoD,GACpD,EAAE;QACR,MAAMG,UAAU,GACdtE,gBAAgB,CAACgQ,IAAI,EAAE,YAAY,EAAE3a,UAAU,CAACC,GAAG,CAAC,IACpD+O,iBAAiB;QACnB,MAAME,SAAS,GAAGvE,gBAAgB,CAACgQ,IAAI,EAAE,WAAW,EAAE3a,UAAU,CAACC,GAAG,CAAC;QACrE,IAAItI,OAAO,CAACsX,UAAU,CAAC,EAAE;UACvBnE,IAAI,CAACqE,kBAAkB,CAACvW,aAAa,CAACwW,aAAa,CAACH,UAAU,CAAC,CAAC,CAAC;QACnE;QACA,IAAItX,OAAO,CAACuX,SAAS,CAAC,EAAE;UACtBpE,IAAI,CAACqE,kBAAkB,CAACvW,aAAa,CAACwW,aAAa,CAACF,SAAS,CAAC,CAAC,CAAC;QAClE;QAEA,MAAM9F,SAAS,GAAG5H,UAAU,CAAC6N,UAAU;QACvCC,6BAA6B,CAC3BxE,IAAI,EACJtJ,UAAU,CAAC+N,MAAM,EACjB/N,UAAU,CAACgO,MAAM,EACjBT,cAAc,EACdvN,UAAU,CAACiO,eAAe,CAACC,IAAI,EAC/BtG,SACF,CAAC;MACH;MAEA,MAAM2Z,OAAO,GAAG;QACdC,SAAS,EAAEF,YAAY;QACvBrc,WAAW,EAAEA,WAAW;QACxB+B,OAAO,EAAEqa,aAAa,CAACpa,EAAE;QACzB2V,sBAAsB,EAAE7b,cAAc,CAAC6b;MACzC,CAAC;MACD,MAAM6E,qBAAqB,GAAG,IAAI7oB,gBAAgB,CAAC,CAAC;MACpD,MAAMuI,OAAO,GAAGugB,IAAI,CAAC1hB,UAAU,EAAEyhB,qBAAqB,EAAEnY,IAAI,EAAEiY,OAAO,CAAC,CACnEjQ,IAAI,CAAC,UAAUqQ,WAAW,EAAE;QAC3B,MAAMC,QAAQ,GAAG5hB,UAAU,CAAC6hB,iBAAiB;QAC7C,MAAMC,WAAW,GAAGL,qBAAqB,CAACM,MAAM;QAChDH,QAAQ,CAACI,aAAa,CAAC,CAAC;QACxB,KAAK,IAAIjc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+b,WAAW,CAACngB,MAAM,EAAEoE,CAAC,EAAE,EAAE;UAC3C,MAAMkc,SAAS,GAAGH,WAAW,CAAC/b,CAAC,CAAC;UAChC,IAAI,CAAC5P,OAAO,CAAC8rB,SAAS,CAACnK,MAAM,CAAC,EAAE;YAC9BmK,SAAS,CAACnK,MAAM,GAAGuJ,aAAa;YAChC5H,2BAA2B,CAACwI,SAAS,CAAC;UACxC;UAEAL,QAAQ,CAACva,GAAG,CAAC4a,SAAS,CAAC;QACzB;QACAL,QAAQ,CAACM,YAAY,CAAC,CAAC;;QAEvB;QACA,MAAM7U,WAAW,GAAGlE,gBAAgB,CAClCgQ,IAAI,EACJ,aAAa,EACb3a,UAAU,CAACC,GACb,CAAC;QACD,IAAI0jB,eAAe,GACjBlZ,iBAAiB,CAACkQ,IAAI,EAAE,iBAAiB,EAAE3a,UAAU,CAACC,GAAG,CAAC,IAAI,CAAC;QACjE,IACG4O,WAAW,KAAK,YAAY,IAAI8U,eAAe,GAAG,CAAC,IACpD9U,WAAW,KAAK,UAAU,IAC1BC,eAAe,KAAK,QAAQ,EAC5B;UACA,MAAM8U,kBAAkB,GAAG1Z,cAAc,CACvCiZ,WAAW,EACX,oBAAoB,EACpBnjB,UAAU,CAACC,GACb,CAAC;UACD,MAAM4jB,qBAAqB,GAAGlsB,OAAO,CAACisB,kBAAkB,CAAC;UAEzD,MAAME,GAAG,GAAGzrB,UAAU,CAACyrB,GAAG,CAAC,CAAC;UAC5B,MAAMC,eAAe,GAAG;YACtBtb,EAAE,EAAElR,UAAU,CAAC,CAAC;YAChBuT,IAAI,EAAEA,IAAI;YACVkZ,MAAM,EAAE,CAAC,CAAC;YACVC,WAAW,EAAEH,GAAG;YAChBI,QAAQ,EAAE,KAAK;YACfvb,MAAM,EAAEka,aAAa;YACrB9T,cAAc,EAAEA,cAAc;YAC9BoV,WAAW,EAAE,KAAK;YAClBC,gBAAgB,EAAEN;UACpB,CAAC;UAED,IAAIO,gBAAgB,GAAG,CAAC;UACxB,IAAIR,qBAAqB,EAAE;YACzBE,eAAe,CAACC,MAAM,GAAGprB,aAAa,CACpC+R,gBAAgB,CACdiZ,kBAAkB,EAClB,QAAQ,EACR5jB,UAAU,CAACC,GACb,CAAC,IAAI,EACP,CAAC;YACDokB,gBAAgB,GACd5Z,iBAAiB,CACfmZ,kBAAkB,EAClB,kBAAkB,EAClB5jB,UAAU,CAACC,GACb,CAAC,IAAI,CAAC;UACV;UAEA,IAAI4O,WAAW,KAAK,YAAY,EAAE;YAChC,IAAIgV,qBAAqB,EAAE;cACzBF,eAAe,GAAGnf,IAAI,CAAC8f,GAAG,CAACD,gBAAgB,EAAEV,eAAe,CAAC;YAC/D;YACAI,eAAe,CAAClV,WAAW,GAAGyR,WAAW,CAACC,QAAQ;YAClDwD,eAAe,CAACQ,IAAI,GAAGZ,eAAe;UACxC,CAAC,MAAM,IAAI9U,WAAW,KAAK,UAAU,EAAE;YACrC,IAAI2V,OAAO;YACX,IAAIX,qBAAqB,EAAE;cACzBW,OAAO,GAAG7Z,gBAAgB,CACxBiZ,kBAAkB,EAClB,SAAS,EACT5jB,UAAU,CAACC,GACb,CAAC;YACH;YACA,IAAItI,OAAO,CAAC6sB,OAAO,CAAC,EAAE;cACpB,IAAI;gBACF,MAAMC,IAAI,GAAGpsB,UAAU,CAAC+T,WAAW,CAACoY,OAAO,CAAC;gBAC5C,MAAME,IAAI,GAAGrsB,UAAU,CAACssB,iBAAiB,CAACF,IAAI,EAAEX,GAAG,CAAC;gBACpD,IAAIY,IAAI,GAAG,CAAC,IAAIA,IAAI,GAAGL,gBAAgB,EAAE;kBACvChsB,UAAU,CAACusB,UAAU,CAACd,GAAG,EAAEO,gBAAgB,EAAEI,IAAI,CAAC;gBACpD;gBACAV,eAAe,CAAClV,WAAW,GAAGyR,WAAW,CAACE,MAAM;gBAChDuD,eAAe,CAACQ,IAAI,GAAGE,IAAI;cAC7B,CAAC,CAAC,OAAOI,CAAC,EAAE;gBACVpsB,cAAc,CACZ,qCAAqC,EACrC,sDACF,CAAC;cACH;YACF,CAAC,MAAM;cACLA,cAAc,CACZ,0BAA0B,EAC1B,0FACF,CAAC;YACH;UACF,CAAC,MAAM,IAAId,OAAO,CAAC6J,UAAU,CAAC+N,MAAM,CAAC,EAAE;YACrC;YACAwU,eAAe,CAAClV,WAAW,GAAGyR,WAAW,CAACG,IAAI;YAC9CsD,eAAe,CAACQ,IAAI,GAClB9Z,iBAAiB,CAACkQ,IAAI,EAAE,iBAAiB,EAAE3a,UAAU,CAACC,GAAG,CAAC,IAAI,CAAC;UACnE,CAAC,MAAM;YACLxH,cAAc,CACZ,gCAAgC,EAChC,yFACF,CAAC;UACH;UAEA,IAAId,OAAO,CAACosB,eAAe,CAAClV,WAAW,CAAC,EAAE;YACxCrN,UAAU,CAACsjB,aAAa,CAACC,GAAG,CAAChB,eAAe,CAACtb,EAAE,EAAEsb,eAAe,CAAC;UACnE;QACF;MACF,CAAC,CAAC,CACDiB,KAAK,CAAC,UAAU9f,KAAK,EAAE;QACtBzM,cAAc,CAAC,mCAAmCqS,IAAI,CAAC1C,GAAG,EAAE,CAAC;QAC7D5G,UAAU,CAACyjB,MAAM,CAAC7E,UAAU,CAAC5e,UAAU,EAAE0D,KAAK,CAAC;MACjD,CAAC,CAAC;MAEJ4W,eAAe,CAACpZ,UAAU,CAACC,OAAO,CAAC;IACrC;EACF;AACF;AAEA,SAASuiB,kBAAkBA,CAAC1jB,UAAU,EAAE8G,IAAI,EAAE/F,cAAc,EAAEuZ,eAAe,EAAE;EAC7E,MAAM9X,gBAAgB,GAAG1D,YAAY,CAACgI,IAAI,CAACrE,SAAS,CAAC;EACrD,IAAItM,OAAO,CAACqM,gBAAgB,CAAC,EAAE;IAC7B,OAAOA,gBAAgB,CAACxC,UAAU,EAAE8G,IAAI,EAAE/F,cAAc,EAAEuZ,eAAe,CAAC;EAC5E;EAEA,OAAO5a,yBAAyB,CAC9BM,UAAU,EACV8G,IAAI,EACJ/F,cAAc,EACduZ,eACF,CAAC;AACH;AAEA,SAASqJ,OAAOA,CACd3jB,UAAU,EACV+G,gBAAgB,EAChBtI,GAAG,EACHgI,cAAc,EACdxB,WAAW,EACX2X,sBAAsB,EACtB5V,OAAO,EACP;EACAD,gBAAgB,CAAC6c,SAAS,CAAC,CAAC;EAE5B,MAAMC,eAAe,GAAGplB,GAAG,CAAColB,eAAe;EAC3C,MAAMtL,QAAQ,GACZsL,eAAe,CAACphB,SAAS,KAAK,UAAU,GACpCohB,eAAe,GACfnb,cAAc,CAACmb,eAAe,EAAE,UAAU,EAAErlB,UAAU,CAACC,GAAG,CAAC;EACjE,IAAIoR,IAAI,GAAG1G,gBAAgB,CAACoP,QAAQ,EAAE,MAAM,EAAE/Z,UAAU,CAACC,GAAG,CAAC;EAC7D,IAAI,CAACtI,OAAO,CAAC0Z,IAAI,CAAC,EAAE;IAClBA,IAAI,GAAGrZ,kBAAkB,CAACiQ,cAAc,CAAC+C,eAAe,CAAC,CAAC,CAAC;EAC7D;;EAEA;EACA,IAAI,CAACrT,OAAO,CAAC6J,UAAU,CAAC8jB,KAAK,CAAC,EAAE;IAC9B9jB,UAAU,CAAC8jB,KAAK,GAAGjU,IAAI;EACzB;EAEA,MAAMyK,eAAe,GAAG,IAAI1Y,aAAa,CAACmiB,gBAAgB,CAAC/jB,UAAU,CAAC;EACtE,MAAMwQ,eAAe,GAAG,IAAI5X,gBAAgB,CAACoH,UAAU,CAAC;EACxD,OAAOuB,OAAO,CAACC,GAAG,CAChBgQ,aAAa,CACXxR,UAAU,EACVvB,GAAG,EACH+R,eAAe,EACf/J,cAAc,EACd,KAAK,EACLxB,WACF,CACF,CAAC,CAACqM,IAAI,CAAC,YAAY;IACjB,IAAItL,OAAO,GAAGvH,GAAG,CAAColB,eAAe;IACjC,IAAI7d,OAAO,CAACvD,SAAS,KAAK,KAAK,EAAE;MAC/B,MAAMmG,UAAU,GAAG5C,OAAO,CAAC4C,UAAU;MACrC,KAAK,IAAI7C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6C,UAAU,CAACjH,MAAM,EAAEoE,CAAC,EAAE,EAAE;QAC1C,MAAMwF,GAAG,GAAG3C,UAAU,CAAC7C,CAAC,CAAC;QACzB,IAAI5P,OAAO,CAAC2I,YAAY,CAACyM,GAAG,CAAC9I,SAAS,CAAC,CAAC,EAAE;UACxCuD,OAAO,GAAGuF,GAAG;UACb;QACF;MACF;IACF;IAEA,MAAMxK,cAAc,GAAG;MACrByY,YAAY,EAAEnb,SAAS;MACvB0I,gBAAgB,EAAEA,gBAAgB;MAClCyJ,eAAe,EAAEA,eAAe;MAChC/J,cAAc,EAAEA,cAAc;MAC9BxB,WAAW,EAAEA,WAAW;MACxB+B,OAAO,EAAEA,OAAO;MAChB4V,sBAAsB,EAAEA;IAC1B,CAAC;IAED7V,gBAAgB,CAACib,aAAa,CAAC,CAAC;IAChC0B,kBAAkB,CAAC1jB,UAAU,EAAEgG,OAAO,EAAEjF,cAAc,EAAEuZ,eAAe,CAAC;IACxEvT,gBAAgB,CAACmb,YAAY,CAAC,CAAC;IAE/B,OAAO5H,eAAe,CAAClZ,IAAI,CAAC,CAAC,CAACkQ,IAAI,CAAC,YAAY;MAC7C,OAAO7S,GAAG,CAAColB,eAAe;IAC5B,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;AAEA,eAAeG,OAAOA,CACpBhkB,UAAU,EACV+G,gBAAgB,EAChBlE,IAAI,EACJ4D,cAAc,EACdmW,sBAAsB,EACtB;EACA,MAAMqH,UAAU,GAAG1uB,cAAc,CAAC,sCAAsC,CAAC;EACzE,MAAM2uB,QAAQ,GAAG3uB,cAAc,CAAC,4BAA4B,CAAC;EAC7DyC,SAAS,CAAC;IACRmsB,SAAS,EAAEF,UAAU;IACrBG,OAAO,EAAEF;EACX,CAAC,CAAC;EAEF,MAAM/gB,MAAM,GAAG,IAAI/K,SAAS,CAAC,IAAIH,UAAU,CAAC4K,IAAI,CAAC,CAAC;EAClD,MAAMwhB,OAAO,GAAG,MAAMlhB,MAAM,CAACmhB,UAAU,CAAC,CAAC;EAEzC,MAAMrS,QAAQ,GAAG,EAAE;EACnB,MAAMhN,WAAW,GAAG,CAAC,CAAC;EACtB,IAAIsf,QAAQ;EACZ,KAAK,IAAIxe,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGse,OAAO,CAAC1iB,MAAM,EAAEoE,CAAC,EAAE,EAAE;IACvC,MAAMf,KAAK,GAAGqf,OAAO,CAACte,CAAC,CAAC;IACxB,IAAI,CAACf,KAAK,CAACwf,SAAS,EAAE;MACpB,IAAI,SAAS,CAAChgB,IAAI,CAACQ,KAAK,CAAC5H,QAAQ,CAAC,EAAE;QAClC;QACA;QACA;QACA,IAAI,CAACjH,OAAO,CAACouB,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC/f,IAAI,CAACQ,KAAK,CAAC5H,QAAQ,CAAC,EAAE;UACrD,IAAIjH,OAAO,CAACouB,QAAQ,CAAC,EAAE;YACrB;YACAtS,QAAQ,CAACjR,IAAI,CAACoE,kBAAkB,CAACmf,QAAQ,EAAEtf,WAAW,CAAC,CAAC;UAC1D;UACAsf,QAAQ,GAAGvf,KAAK;QAClB,CAAC,MAAM;UACL;UACAiN,QAAQ,CAACjR,IAAI,CAACoE,kBAAkB,CAACJ,KAAK,EAAEC,WAAW,CAAC,CAAC;QACvD;MACF,CAAC,MAAM;QACLgN,QAAQ,CAACjR,IAAI,CAACoE,kBAAkB,CAACJ,KAAK,EAAEC,WAAW,CAAC,CAAC;MACvD;IACF;EACF;;EAEA;EACA,IAAI9O,OAAO,CAACouB,QAAQ,CAAC,EAAE;IACrBtS,QAAQ,CAACjR,IAAI,CAAC+D,cAAc,CAACwf,QAAQ,EAAEtf,WAAW,CAAC,CAAC;EACtD;EACA,MAAM1D,OAAO,CAACC,GAAG,CAACyQ,QAAQ,CAAC;EAC3B9O,MAAM,CAACshB,KAAK,CAAC,CAAC;EACd,IAAI,CAACtuB,OAAO,CAAC8O,WAAW,CAACxG,GAAG,CAAC,EAAE;IAC7B,MAAM,IAAIlH,YAAY,CAAC,2CAA2C,CAAC;EACrE;EACA0N,WAAW,CAACU,IAAI,GAAGlF,MAAM,CAACkF,IAAI,CAACV,WAAW,CAAC;EAE3C,OAAO0e,OAAO,CACZ3jB,UAAU,EACV+G,gBAAgB,EAChB9B,WAAW,CAACxG,GAAG,EACfgI,cAAc,EACdxB,WAAW,EACX2X,sBACF,CAAC;AACH;AAEA,SAAS8E,IAAIA,CAAC1hB,UAAU,EAAE+G,gBAAgB,EAAEoP,IAAI,EAAEoL,OAAO,EAAE;EACzDA,OAAO,GAAGA,OAAO,IAAItrB,MAAM,CAACyuB,YAAY;EACxC,IAAIlD,SAAS,GAAGD,OAAO,CAACC,SAAS;EACjC,MAAMvc,WAAW,GAAGsc,OAAO,CAACtc,WAAW;EACvC,MAAM+B,OAAO,GAAGua,OAAO,CAACva,OAAO;EAC/B,IAAI4V,sBAAsB,GAAG2E,OAAO,CAAC3E,sBAAsB;EAE3D,IAAIzb,OAAO,GAAGgV,IAAI;EAClB,IAAI,OAAOA,IAAI,KAAK,QAAQ,IAAIA,IAAI,YAAY7e,QAAQ,EAAE;IACxD6e,IAAI,GAAG7e,QAAQ,CAACqtB,cAAc,CAACxO,IAAI,CAAC;IACpChV,OAAO,GAAGgV,IAAI,CAACyO,SAAS,CAAC,CAAC;IAC1BpD,SAAS,GAAGA,SAAS,IAAIrL,IAAI,CAACtgB,KAAK,CAAC,CAAC;;IAErC;IACA,MAAMgvB,eAAe,GAAG7kB,UAAU,CAAC8kB,gBAAgB;IACnD,MAAMC,OAAO,GAAG5O,IAAI,CAAC4O,OAAO;IAC5B,IAAI5uB,OAAO,CAAC4uB,OAAO,CAAC,EAAE;MACpB,MAAMpjB,MAAM,GAAGojB,OAAO,CAACpjB,MAAM;MAC7B,KAAK,IAAIoE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpE,MAAM,EAAEoE,CAAC,EAAE,EAAE;QAC/B8e,eAAe,CAAC7jB,IAAI,CAAC+jB,OAAO,CAAChf,CAAC,CAAC,CAAC;MAClC;IACF;EACF,CAAC,MAAM;IACLyb,SAAS,GAAGA,SAAS,IAAIlqB,QAAQ,CAAC0tB,OAAO,CAACnvB,KAAK,CAAC,CAAC;EACnD;EAEA2rB,SAAS,GAAGlqB,QAAQ,CAACqtB,cAAc,CAACnD,SAAS,CAAC;EAE9C,IAAIrrB,OAAO,CAACymB,sBAAsB,CAAC,EAAE;IACnCA,sBAAsB,GAAGvkB,UAAU,CAACukB,sBAAsB,CAAC;EAC7D;EAEA,OAAOrb,OAAO,CAACD,OAAO,CAACH,OAAO,CAAC,CAC5BmQ,IAAI,CAAC,UAAU2T,UAAU,EAAE;IAC1B,IAAIA,UAAU,YAAYC,IAAI,EAAE;MAC9B,OAAOtiB,SAAS,CAACqiB,UAAU,CAAC,CAAC3T,IAAI,CAAC,UAAU6T,KAAK,EAAE;QACjD,IAAIA,KAAK,EAAE;UACT,OAAOnB,OAAO,CACZhkB,UAAU,EACV+G,gBAAgB,EAChBke,UAAU,EACVzD,SAAS,EACT5E,sBACF,CAAC;QACH;QACA,OAAOhZ,cAAc,CAACqhB,UAAU,CAAC,CAAC3T,IAAI,CAAC,UAAU5U,IAAI,EAAE;UACrD;UACA;;UAEA;UACAA,IAAI,GAAGoH,gBAAgB,CAACpH,IAAI,CAAC;;UAE7B;UACAA,IAAI,GAAGgI,yBAAyB,CAAChI,IAAI,CAAC;;UAEtC;UACA,IAAI+B,GAAG;UACP,IAAIiF,KAAK;UACT,IAAI;YACFjF,GAAG,GAAGlB,MAAM,CAAC4H,eAAe,CAACzI,IAAI,EAAE,iBAAiB,CAAC;UACvD,CAAC,CAAC,OAAO2mB,CAAC,EAAE;YACV3f,KAAK,GAAG2f,CAAC,CAAC/c,QAAQ,CAAC,CAAC;UACtB;;UAEA;UACA;UACA,IACEnQ,OAAO,CAACuN,KAAK,CAAC,IACdjF,GAAG,CAAC2mB,IAAI,IACR3mB,GAAG,CAAColB,eAAe,CAAClb,OAAO,KAAK,aAAa,EAC7C;YACA;YACA,IAAI0c,GAAG,GAAGlvB,OAAO,CAACuN,KAAK,CAAC,GACpBA,KAAK,GACLjF,GAAG,CAAColB,eAAe,CAACyB,UAAU,CAACC,SAAS;;YAE5C;YACA,IAAI,CAACF,GAAG,EAAE;cACRA,GAAG,GAAG5mB,GAAG,CAAC2mB,IAAI,CAACI,SAAS;YAC1B;;YAEA;YACA,MAAM,IAAIjuB,YAAY,CAAC8tB,GAAG,CAAC;UAC7B;UACA,OAAO1B,OAAO,CACZ3jB,UAAU,EACV+G,gBAAgB,EAChBtI,GAAG,EACH+iB,SAAS,EACTvc,WAAW,EACX2X,sBAAsB,EACtB5V,OACF,CAAC;QACH,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ;IACA,OAAO2c,OAAO,CACZ3jB,UAAU,EACV+G,gBAAgB,EAChBke,UAAU,EACVzD,SAAS,EACTvc,WAAW,EACX2X,sBAAsB,EACtB5V,OACF,CAAC;EACH,CAAC,CAAC,CACDwc,KAAK,CAAC,UAAU9f,KAAK,EAAE;IACtB1D,UAAU,CAACyjB,MAAM,CAAC7E,UAAU,CAAC5e,UAAU,EAAE0D,KAAK,CAAC;IAC/C6X,OAAO,CAACC,GAAG,CAAC9X,KAAK,CAAC;IAClB,OAAOnC,OAAO,CAACkC,MAAM,CAACC,KAAK,CAAC;EAC9B,CAAC,CAAC;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS9B,aAAaA,CAAC2f,OAAO,EAAE;EAC9BA,OAAO,GAAGA,OAAO,IAAItrB,MAAM,CAACyuB,YAAY;EACxC,MAAM3W,MAAM,GAAGwT,OAAO,CAACxT,MAAM;EAC7B,MAAMC,MAAM,GAAGuT,OAAO,CAACvT,MAAM;EAE7B,IAAI,CAACyX,QAAQ,GAAG,IAAInvB,KAAK,CAAC,CAAC;EAC3B,IAAI,CAACmtB,MAAM,GAAG,IAAIntB,KAAK,CAAC,CAAC;EACzB,IAAI,CAACovB,QAAQ,GAAG,IAAIpvB,KAAK,CAAC,CAAC;EAC3B,IAAI,CAACqvB,QAAQ,GAAG,IAAIrvB,KAAK,CAAC,CAAC;EAC3B,IAAI,CAACqoB,gBAAgB,GAAG,IAAIroB,KAAK,CAAC,CAAC;EAEnC,IAAI,CAACsvB,MAAM,GAAGvnB,SAAS;EACvB,IAAI,CAACwjB,iBAAiB,GAAG,IAAIjpB,gBAAgB,CAAC,IAAI,CAAC;EACnD,IAAI,CAACkrB,KAAK,GAAGzlB,SAAS;EACtB,IAAI,CAACwnB,UAAU,GAAG,KAAK;EACvB,IAAI,CAACtS,WAAW,GAAG,IAAIrc,UAAU,CAAC,CAAC;EACnC,IAAI,CAACosB,aAAa,GAAG,IAAIjuB,gBAAgB,CAAC,CAAC;EAC3C,IAAI,CAACywB,cAAc,GAAG,IAAIntB,aAAa,CAAC,CAAC;;EAEzC;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACqV,MAAM,GAAGA,MAAM;;EAEpB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACD,MAAM,GAAGA,MAAM;EAEpB,IAAI,CAACE,eAAe,GAAG;IACrBwE,QAAQ,EAAEtc,OAAO,CAAC4X,MAAM,CAAC,GAAGtY,UAAU,CAACI,KAAK,CAACkY,MAAM,CAACgT,UAAU,CAAC,GAAG1iB,SAAS;IAC3E0nB,SAAS,EAAE5vB,OAAO,CAAC4X,MAAM,CAAC,GACtBtY,UAAU,CAACI,KAAK,CAACkY,MAAM,CAACiY,WAAW,CAAC,GACpC3nB,SAAS;IACb4nB,EAAE,EAAE9vB,OAAO,CAAC4X,MAAM,CAAC,GAAGtY,UAAU,CAACI,KAAK,CAACkY,MAAM,CAACmY,IAAI,CAAC,GAAG7nB,SAAS;IAC/D6P,IAAI,EAAE/X,OAAO,CAAC4X,MAAM,CAAC,GACjBA,MAAM,CAACoY,oBAAoB,CAAC,CAAC,GAC7B9uB,SAAS,CAACxB,KAAK,CAACwB,SAAS,CAAC+uB,SAAS;EACzC,CAAC;EAED,IAAI,CAACvY,UAAU,GAAG0T,OAAO,CAAC3Z,SAAS,IAAIvR,SAAS,CAACgwB,OAAO;;EAExD;EACA,IAAIC,MAAM,GAAG/E,OAAO,CAAC+E,MAAM;EAC3B,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;IAC9BA,MAAM,GAAG,IAAItwB,MAAM,CAACswB,MAAM,CAAC;EAC7B;EACA,IAAI,CAACC,OAAO,GAAGD,MAAM;;EAErB;EACA,IAAI,CAACxB,gBAAgB,GAAG,EAAE;EAE1B,IAAI,CAACrJ,SAAS,GAAG,EAAE;EAEnB,IAAI,CAACqB,eAAe,GAAG,EAAE;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAlb,aAAa,CAAC8f,IAAI,GAAG,UAAUvL,IAAI,EAAEoL,OAAO,EAAE;EAC5CA,OAAO,GAAGA,OAAO,IAAItrB,MAAM,CAACyuB,YAAY;EACxC,MAAM1kB,UAAU,GAAG,IAAI4B,aAAa,CAAC2f,OAAO,CAAC;EAC7C,OAAOvhB,UAAU,CAAC0hB,IAAI,CAACvL,IAAI,EAAEoL,OAAO,CAAC;AACvC,CAAC;AAED9gB,MAAM,CAACC,gBAAgB,CAACkB,aAAa,CAACjB,SAAS,EAAE;EAC/C;AACF;AACA;AACA;AACA;AACA;EACEkP,IAAI,EAAE;IACJjP,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACkjB,KAAK;IACnB,CAAC;IACDP,GAAG,EAAE,SAAAA,CAAUtd,KAAK,EAAE;MACpB,IAAI,IAAI,CAAC6d,KAAK,KAAK7d,KAAK,EAAE;QACxB,IAAI,CAAC6d,KAAK,GAAG7d,KAAK;QAClB,IAAI,CAACwf,QAAQ,CAAC7G,UAAU,CAAC,IAAI,CAAC;MAChC;IACF;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EACE4H,KAAK,EAAE;IACL5lB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACglB,MAAM;IACpB;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;EACEhE,QAAQ,EAAE;IACRhhB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACihB,iBAAiB;IAC/B;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;EACE4E,SAAS,EAAE;IACT7lB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACilB,UAAU;IACxB;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;EACEa,YAAY,EAAE;IACZ9lB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC6kB,QAAQ;IACtB;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;EACEkB,UAAU,EAAE;IACV/lB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC6iB,MAAM;IACpB;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;EACEmD,YAAY,EAAE;IACZhmB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC8kB,QAAQ;IACtB;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;EACEmB,YAAY,EAAE;IACZjmB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC+kB,QAAQ;IACtB;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;EACEmB,oBAAoB,EAAE;IACpBlmB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC+d,gBAAgB;IAC9B;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;EACE7H,IAAI,EAAE;IACJlW,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACihB,iBAAiB,CAAC/K,IAAI;IACpC,CAAC;IACDyM,GAAG,EAAE,SAAAA,CAAUtd,KAAK,EAAE;MACpB,IAAI,CAAC4b,iBAAiB,CAAC/K,IAAI,GAAG7Q,KAAK;IACrC;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACE8gB,UAAU,EAAE;IACVnmB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACklB,cAAc;IAC5B,CAAC;IACDvC,GAAG,EAAE,SAAAA,CAAUtd,KAAK,EAAE;MACpB;MACA,IAAI,CAAC9P,OAAO,CAAC8P,KAAK,CAAC,EAAE;QACnB,MAAM,IAAI7P,cAAc,CAAC,wBAAwB,CAAC;MACpD;MACA;MACA,IAAI,CAAC0vB,cAAc,GAAG7f,KAAK;IAC7B;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;EACEqgB,MAAM,EAAE;IACN1lB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC2lB,OAAO;IACrB;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;EACES,QAAQ,EAAE;IACRpmB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC6a,SAAS;IACvB;EACF;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA7Z,aAAa,CAACjB,SAAS,CAAC+gB,IAAI,GAAG,UAAUvL,IAAI,EAAEoL,OAAO,EAAE;EACtD;EACA,IAAI,CAACprB,OAAO,CAACggB,IAAI,CAAC,EAAE;IAClB,MAAM,IAAI/f,cAAc,CAAC,mBAAmB,CAAC;EAC/C;EACA;;EAEAmrB,OAAO,GAAGA,OAAO,IAAItrB,MAAM,CAACyuB,YAAY;EACxClsB,UAAU,CAACyuB,UAAU,CAAC,IAAI,EAAE,IAAI,CAAC;EAEjC,MAAMC,OAAO,GAAG,IAAI,CAACpD,KAAK;EAC1B,IAAI,CAACA,KAAK,GAAGzlB,SAAS;EACtB,IAAI,CAACsV,cAAc,GAAG4N,OAAO,CAAC3M,aAAa,IAAI,KAAK;EAEpD,MAAM5S,IAAI,GAAG,IAAI;EACjB,OAAO0f,IAAI,CAAC,IAAI,EAAE,IAAI,CAACG,iBAAiB,EAAE1L,IAAI,EAAEoL,OAAO,CAAC,CACrDjQ,IAAI,CAAC,YAAY;IAChB,IAAIkV,KAAK;IAET,MAAM1Q,YAAY,GAAG9T,IAAI,CAAC6f,iBAAiB,CAACsF,mBAAmB,CAAC,CAAC;IAEjE,IAAIrc,KAAK,GAAGgL,YAAY,CAAChL,KAAK;IAC9B,IAAIC,IAAI,GAAG+K,YAAY,CAAC/K,IAAI;IAC5B,MAAMqc,UAAU,GAAGvwB,UAAU,CAACwwB,MAAM,CAACvc,KAAK,EAAElU,OAAO,CAAC4U,aAAa,CAAC;IAClE,MAAM8b,SAAS,GAAGzwB,UAAU,CAACwwB,MAAM,CAACtc,IAAI,EAAEnU,OAAO,CAACoU,aAAa,CAAC;IAChE,IAAI,CAACoc,UAAU,IAAI,CAACE,SAAS,EAAE;MAC7B,IAAIrE,IAAI;;MAER;MACA,IAAImE,UAAU,EAAE;QACdnE,IAAI,GAAG,IAAIsE,IAAI,CAAC,CAAC;QACjBtE,IAAI,CAACuE,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACzB1c,KAAK,GAAGjU,UAAU,CAAC4wB,QAAQ,CAACxE,IAAI,CAAC;MACnC;;MAEA;MACA,IAAIqE,SAAS,EAAE;QACbrE,IAAI,GAAG,IAAIsE,IAAI,CAAC,CAAC;QACjBtE,IAAI,CAACuE,QAAQ,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QAC1Bzc,IAAI,GAAGlU,UAAU,CAAC4wB,QAAQ,CAACxE,IAAI,CAAC;MAClC;MAEAuD,KAAK,GAAG,IAAI/tB,eAAe,CAAC,CAAC;MAC7B+tB,KAAK,CAACkB,SAAS,GAAG5c,KAAK;MACvB0b,KAAK,CAACmB,QAAQ,GAAG5c,IAAI;MACrByb,KAAK,CAACoB,WAAW,GAAG/wB,UAAU,CAAChB,KAAK,CAACiV,KAAK,CAAC;MAC3C0b,KAAK,CAACqB,UAAU,GAAGlyB,UAAU,CAACmyB,SAAS;MACvCtB,KAAK,CAACuB,SAAS,GAAGnyB,SAAS,CAACoyB,uBAAuB;MACnDxB,KAAK,CAACyB,UAAU,GAAGjlB,IAAI,CAACklB,KAAK,CAC3BllB,IAAI,CAACC,GAAG,CACND,IAAI,CAAC8f,GAAG,CAACjsB,UAAU,CAACssB,iBAAiB,CAACpY,IAAI,EAAED,KAAK,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,EAC3D,SACF,CACF,CAAC;IACH;IAEA,IAAIqd,OAAO,GAAG,KAAK;IACnB,IAAI3B,KAAK,KAAKxkB,IAAI,CAAC4jB,MAAM,EAAE;MACzB5jB,IAAI,CAAC4jB,MAAM,GAAGY,KAAK;MACnB2B,OAAO,GAAG,IAAI;IAChB;IAEA,IAAIjB,OAAO,KAAKllB,IAAI,CAAC8hB,KAAK,EAAE;MAC1BqE,OAAO,GAAG,IAAI;IAChB;IAEA,IAAIA,OAAO,EAAE;MACXnmB,IAAI,CAACyjB,QAAQ,CAAC7G,UAAU,CAAC5c,IAAI,CAAC;IAChC;IAEAxJ,UAAU,CAACyuB,UAAU,CAACjlB,IAAI,EAAE,KAAK,CAAC;IAElC,OAAOA,IAAI;EACb,CAAC,CAAC,CACDwhB,KAAK,CAAC,UAAU9f,KAAK,EAAE;IACtBlL,UAAU,CAACyuB,UAAU,CAACjlB,IAAI,EAAE,KAAK,CAAC;IAClCA,IAAI,CAACyhB,MAAM,CAAC7E,UAAU,CAAC5c,IAAI,EAAE0B,KAAK,CAAC;IACnC6X,OAAO,CAACC,GAAG,CAAC9X,KAAK,CAAC;IAClB,OAAOnC,OAAO,CAACkC,MAAM,CAACC,KAAK,CAAC;EAC9B,CAAC,CAAC;AACN,CAAC;;AAED;AACA;AACA;AACA9B,aAAa,CAACjB,SAAS,CAACynB,OAAO,GAAG,YAAY;EAC5C,OAAO,IAAI,CAACtL,eAAe,CAACnb,MAAM,GAAG,CAAC,EAAE;IACtC,MAAM0mB,IAAI,GAAG,IAAI,CAACvL,eAAe,CAACxa,GAAG,CAAC,CAAC;IACvC+lB,IAAI,CAACC,MAAM,CAAC,CAAC;EACf;AACF,CAAC;AAED,SAAS7O,2BAA2BA,CAAClX,KAAK,EAAE;EAC1C,MAAMuV,MAAM,GAAGvV,KAAK,CAACuV,MAAM;EAC3B,IAAI3hB,OAAO,CAAC2hB,MAAM,CAAC,EAAE;IACnB,MAAMyQ,kBAAkB,GAAGzQ,MAAM,CAAChC,YAAY;IAC9C,IAAI3f,OAAO,CAACoyB,kBAAkB,CAAC,EAAE;MAC/B,MAAMC,iBAAiB,GAAGjmB,KAAK,CAACuT,YAAY;MAC5C,IAAI3f,OAAO,CAACqyB,iBAAiB,CAAC,EAAE;QAC9BA,iBAAiB,CAACC,SAAS,CAACF,kBAAkB,CAAC;MACjD,CAAC,MAAM;QACLhmB,KAAK,CAACuT,YAAY,GAAGyS,kBAAkB;MACzC;IACF;EACF;AACF;AAEA,SAASG,4BAA4BA,CACnC1oB,UAAU,EACV2oB,WAAW,EACXC,mBAAmB,EACnBC,YAAY,EACZC,aAAa,EACb;EACA,OAAO,UAAUnH,WAAW,EAAE;IAC5B,IAAI,CAACkH,YAAY,CAACE,QAAQ,CAACJ,WAAW,CAAC1hB,EAAE,CAAC,EAAE;MAC1C;MACA;MACA;IACF;IACA,IAAIqhB,MAAM,GAAG,KAAK;IAClB,MAAMlG,kBAAkB,GAAG1Z,cAAc,CACvCiZ,WAAW,EACX,oBAAoB,EACpBnjB,UAAU,CAACC,GACb,CAAC;IACD,MAAM4jB,qBAAqB,GAAGlsB,OAAO,CAACisB,kBAAkB,CAAC;IAEzD,IAAIS,gBAAgB,GAAG,CAAC;IACxB,IAAIR,qBAAqB,EAAE;MACzB,IACElsB,OAAO,CAACuS,cAAc,CAAC0Z,kBAAkB,EAAE,QAAQ,EAAE5jB,UAAU,CAACC,GAAG,CAAC,CAAC,EACrE;QACAxH,cAAc,CACZ,+BAA+B,EAC/B,oDACF,CAAC;QACD0xB,WAAW,CAACjG,QAAQ,GAAG,KAAK;QAC5BmG,YAAY,CAACP,MAAM,CAACK,WAAW,CAAC1hB,EAAE,CAAC;QACnC;MACF;MACA0hB,WAAW,CAACnG,MAAM,GAAGprB,aAAa,CAChC+R,gBAAgB,CAACiZ,kBAAkB,EAAE,QAAQ,EAAE5jB,UAAU,CAACC,GAAG,CAAC,IAAI,EACpE,CAAC;MACDokB,gBAAgB,GACd5Z,iBAAiB,CACfmZ,kBAAkB,EAClB,kBAAkB,EAClB5jB,UAAU,CAACC,GACb,CAAC,IAAI,CAAC;IACV;IAEA,MAAM6jB,GAAG,GAAGzrB,UAAU,CAACyrB,GAAG,CAAC,CAAC;IAC5B,MAAMjV,WAAW,GAAGsb,WAAW,CAACtb,WAAW;IAC3C,IAAIA,WAAW,KAAKyR,WAAW,CAACC,QAAQ,EAAE;MACxC,IAAI5oB,OAAO,CAACisB,kBAAkB,CAAC,EAAE;QAC/BuG,WAAW,CAAC5F,IAAI,GAAG/f,IAAI,CAAC8f,GAAG,CAACD,gBAAgB,EAAE8F,WAAW,CAAC5F,IAAI,CAAC;MACjE;IACF,CAAC,MAAM,IAAI1V,WAAW,KAAKyR,WAAW,CAACE,MAAM,EAAE;MAC7C,IAAIgE,OAAO;MACX,IAAI7sB,OAAO,CAACisB,kBAAkB,CAAC,EAAE;QAC/BY,OAAO,GAAG7Z,gBAAgB,CACxBiZ,kBAAkB,EAClB,SAAS,EACT5jB,UAAU,CAACC,GACb,CAAC;MACH;MACA,IAAItI,OAAO,CAAC6sB,OAAO,CAAC,EAAE;QACpB,IAAI;UACF,MAAMC,IAAI,GAAGpsB,UAAU,CAAC+T,WAAW,CAACoY,OAAO,CAAC;UAC5C,MAAME,IAAI,GAAGrsB,UAAU,CAACssB,iBAAiB,CAACF,IAAI,EAAEX,GAAG,CAAC;UACpD,IAAIY,IAAI,GAAG,CAAC,IAAIA,IAAI,GAAGL,gBAAgB,EAAE;YACvChsB,UAAU,CAACusB,UAAU,CAACd,GAAG,EAAEO,gBAAgB,EAAEI,IAAI,CAAC;UACpD;UACA0F,WAAW,CAAC5F,IAAI,GAAGE,IAAI;QACzB,CAAC,CAAC,OAAOI,CAAC,EAAE;UACVpsB,cAAc,CACZ,gCAAgC,EAChC,sDACF,CAAC;UACDqxB,MAAM,GAAG,IAAI;QACf;MACF,CAAC,MAAM;QACLrxB,cAAc,CACZ,0BAA0B,EAC1B,0FACF,CAAC;QACDqxB,MAAM,GAAG,IAAI;MACf;IACF;IAEA,MAAMU,iBAAiB,GAAGL,WAAW,CAACxhB,MAAM;IAC5C,MAAMJ,gBAAgB,GAAG/G,UAAU,CAAC6hB,iBAAiB;IACrD,MAAMC,WAAW,GAAG8G,mBAAmB,CAAC7G,MAAM;IAE9C,SAASkH,cAAcA,CAAC9hB,MAAM,EAAE;MAC9BJ,gBAAgB,CAACuhB,MAAM,CAACnhB,MAAM,CAAC;MAC/B,MAAM+hB,QAAQ,GAAG/hB,MAAM,CAACgiB,SAAS;MACjC,MAAMC,KAAK,GAAGF,QAAQ,CAACvnB,MAAM;MAC7B,KAAK,IAAIoE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqjB,KAAK,EAAE,EAAErjB,CAAC,EAAE;QAC9BkjB,cAAc,CAACC,QAAQ,CAACnjB,CAAC,CAAC,CAAC;MAC7B;IACF;;IAEA;IACAgB,gBAAgB,CAACib,aAAa,CAAC,CAAC;IAChC,MAAMqH,YAAY,GAAGtiB,gBAAgB,CAACgb,MAAM,CAAChf,KAAK,CAAC,CAAC;IACpD,IAAIgD,CAAC;IACL,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsjB,YAAY,CAAC1nB,MAAM,EAAE,EAAEoE,CAAC,EAAE;MACxC,MAAMujB,cAAc,GAAGD,YAAY,CAACtjB,CAAC,CAAC;MACtC,IAAIujB,cAAc,CAACxR,MAAM,KAAKkR,iBAAiB,EAAE;QAC/CM,cAAc,CAACxR,MAAM,GAAGzZ,SAAS;QACjC4qB,cAAc,CAACK,cAAc,CAAC;MAChC;IACF;IACAviB,gBAAgB,CAACmb,YAAY,CAAC,CAAC;;IAE/B;IACAnb,gBAAgB,CAACib,aAAa,CAAC,CAAC;IAChC,KAAKjc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+b,WAAW,CAACngB,MAAM,EAAEoE,CAAC,EAAE,EAAE;MACvC,MAAMkc,SAAS,GAAGH,WAAW,CAAC/b,CAAC,CAAC;MAChC,IAAI,CAAC5P,OAAO,CAAC8rB,SAAS,CAACnK,MAAM,CAAC,EAAE;QAC9BmK,SAAS,CAACnK,MAAM,GAAGkR,iBAAiB;QACpCvP,2BAA2B,CAACwI,SAAS,CAAC;MACxC;MACAlb,gBAAgB,CAACM,GAAG,CAAC4a,SAAS,CAAC;IACjC;IACAlb,gBAAgB,CAACmb,YAAY,CAAC,CAAC;;IAE/B;IACA,IAAIoG,MAAM,EAAE;MACVO,YAAY,CAACP,MAAM,CAACK,WAAW,CAAC1hB,EAAE,CAAC;IACrC,CAAC,MAAM;MACL0hB,WAAW,CAAClG,WAAW,GAAGH,GAAG;IAC/B;IAEA,MAAMxM,YAAY,GAAG/O,gBAAgB,CAACogB,mBAAmB,CAAC,CAAC;IAE3D,MAAMrc,KAAK,GAAGgL,YAAY,CAAChL,KAAK;IAChC,MAAMC,IAAI,GAAG+K,YAAY,CAAC/K,IAAI;IAC9B,MAAMqc,UAAU,GAAGvwB,UAAU,CAACwwB,MAAM,CAACvc,KAAK,EAAElU,OAAO,CAAC4U,aAAa,CAAC;IAClE,MAAM8b,SAAS,GAAGzwB,UAAU,CAACwwB,MAAM,CAACtc,IAAI,EAAEnU,OAAO,CAACoU,aAAa,CAAC;IAChE,IAAI,CAACoc,UAAU,IAAI,CAACE,SAAS,EAAE;MAC7B,MAAMd,KAAK,GAAGxmB,UAAU,CAAC4lB,MAAM;MAE/B,IAAIY,KAAK,CAACkB,SAAS,KAAK5c,KAAK,IAAI0b,KAAK,CAACmB,QAAQ,KAAK5c,IAAI,EAAE;QACxDyb,KAAK,CAACkB,SAAS,GAAG5c,KAAK;QACvB0b,KAAK,CAACmB,QAAQ,GAAG5c,IAAI;QACrB/K,UAAU,CAACylB,QAAQ,CAAC7G,UAAU,CAAC5e,UAAU,CAAC;MAC5C;IACF;IAEA2oB,WAAW,CAACjG,QAAQ,GAAG,KAAK;IAC5BiG,WAAW,CAAChG,WAAW,GAAG,KAAK;IAC/B3iB,UAAU,CAAC2lB,QAAQ,CAAC/G,UAAU,CAC5B5e,UAAU,EACV8oB,aAAa,CAACtf,eAAe,CAAC,IAAI,CACpC,CAAC;EACH,CAAC;AACH;AAEA,MAAM+f,gBAAgB,GAAG,IAAIl0B,gBAAgB,CAAC,CAAC;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACAuM,aAAa,CAACjB,SAAS,CAAC6oB,MAAM,GAAG,UAAUzG,IAAI,EAAE;EAC/C,MAAM8F,YAAY,GAAG,IAAI,CAACvF,aAAa;EACvC,IAAIuF,YAAY,CAAClnB,MAAM,KAAK,CAAC,EAAE;IAC7B,OAAO,IAAI;EACb;EAEA,MAAM2gB,GAAG,GAAGzrB,UAAU,CAACyrB,GAAG,CAAC,CAAC;EAC5B,MAAMtgB,IAAI,GAAG,IAAI;EAEjBunB,gBAAgB,CAAC3F,SAAS,CAAC,CAAC;EAE5B,SAAS6F,qBAAqBA,CAACtiB,MAAM,EAAE;IACrC,MAAM+hB,QAAQ,GAAG/hB,MAAM,CAACgiB,SAAS;IACjC,MAAMC,KAAK,GAAGF,QAAQ,CAACvnB,MAAM;IAC7B,KAAK,IAAIoE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqjB,KAAK,EAAE,EAAErjB,CAAC,EAAE;MAC9B,MAAMxD,KAAK,GAAG2mB,QAAQ,CAACnjB,CAAC,CAAC;MACzBwjB,gBAAgB,CAAChG,GAAG,CAAChhB,KAAK,CAAC0E,EAAE,EAAE1E,KAAK,CAAC;MACrCknB,qBAAqB,CAAClnB,KAAK,CAAC;IAC9B;EACF;EAEA,IAAImnB,gBAAgB,GAAG,KAAK;EAC5B,MAAMC,cAAc,GAAG,IAAI,CAAC1b,eAAe;EAC3C,MAAMF,MAAM,GAAG,IAAI,CAACA,MAAM;EAC1B,IACE5X,OAAO,CAAC4X,MAAM,CAAC,IACf,EACEA,MAAM,CAACgT,UAAU,CAACP,aAAa,CAC7BmJ,cAAc,CAAClX,QAAQ,EACvB3b,UAAU,CAAC8yB,QACb,CAAC,IACD7b,MAAM,CAACiY,WAAW,CAACxF,aAAa,CAC9BmJ,cAAc,CAAC5D,SAAS,EACxBjvB,UAAU,CAAC8yB,QACb,CAAC,IACD7b,MAAM,CAACmY,IAAI,CAAC1F,aAAa,CAACmJ,cAAc,CAAC1D,EAAE,EAAEnvB,UAAU,CAAC8yB,QAAQ,CAAC,CAClE,EACD;IACA;IACAD,cAAc,CAAClX,QAAQ,GAAGhd,UAAU,CAACI,KAAK,CAACkY,MAAM,CAACgT,UAAU,CAAC;IAC7D4I,cAAc,CAAC5D,SAAS,GAAGtwB,UAAU,CAACI,KAAK,CAACkY,MAAM,CAACiY,WAAW,CAAC;IAC/D2D,cAAc,CAAC1D,EAAE,GAAGxwB,UAAU,CAACI,KAAK,CAACkY,MAAM,CAACmY,IAAI,CAAC;IACjDyD,cAAc,CAACzb,IAAI,GAAGH,MAAM,CAACoY,oBAAoB,CAAC,CAAC;IACnDuD,gBAAgB,GAAG,IAAI;EACzB;EAEA,MAAMG,eAAe,GAAG,IAAIx0B,gBAAgB,CAAC,CAAC;EAC9C,IAAI8yB,OAAO,GAAG,KAAK;EACnBU,YAAY,CAAC9G,MAAM,CAAC+H,OAAO,CAAC,UAAUnB,WAAW,EAAE;IACjD,MAAMxhB,MAAM,GAAGwhB,WAAW,CAACxhB,MAAM;IACjC,IAAIoiB,gBAAgB,CAACR,QAAQ,CAAC5hB,MAAM,CAACF,EAAE,CAAC,EAAE;MACxC;IACF;IAEA,IAAI,CAAC0hB,WAAW,CAACjG,QAAQ,EAAE;MACzB,IAAIqH,QAAQ,GAAG,KAAK;MACpB,IAAIpB,WAAW,CAACtb,WAAW,KAAKyR,WAAW,CAACC,QAAQ,EAAE;QACpD,IACEloB,UAAU,CAACssB,iBAAiB,CAACb,GAAG,EAAEqG,WAAW,CAAClG,WAAW,CAAC,GAC1DkG,WAAW,CAAC5F,IAAI,EAChB;UACAgH,QAAQ,GAAG,IAAI;QACjB;MACF,CAAC,MAAM,IAAIpB,WAAW,CAACtb,WAAW,KAAKyR,WAAW,CAACE,MAAM,EAAE;QACzD,IAAInoB,UAAU,CAACmzB,WAAW,CAAC1H,GAAG,EAAEqG,WAAW,CAAC5F,IAAI,CAAC,EAAE;UACjDgH,QAAQ,GAAG,IAAI;QACjB;MACF,CAAC,MAAM,IAAIpB,WAAW,CAACtb,WAAW,KAAKyR,WAAW,CAACG,IAAI,EAAE;QACvD,IAAIyK,gBAAgB,EAAE;UACpBf,WAAW,CAAChG,WAAW,GAAG,IAAI;UAC9BgG,WAAW,CAAC/F,gBAAgB,GAAGN,GAAG;QACpC;QAEA,IACEqG,WAAW,CAAChG,WAAW,IACvB9rB,UAAU,CAACssB,iBAAiB,CAACb,GAAG,EAAEqG,WAAW,CAAC/F,gBAAgB,CAAC,IAC7D+F,WAAW,CAAC5F,IAAI,EAClB;UACAgH,QAAQ,GAAG,IAAI;QACjB;MACF;MAEA,IAAIA,QAAQ,EAAE;QACZN,qBAAqB,CAACtiB,MAAM,CAAC;QAC7BwhB,WAAW,CAACjG,QAAQ,GAAG,IAAI;QAC3B,MAAMkG,mBAAmB,GAAG,IAAIhwB,gBAAgB,CAAC,CAAC;QAClD,MAAM0Q,IAAI,GAAGqf,WAAW,CAACrf,IAAI,CAACzT,KAAK,CAAC,CAAC;QAErCyT,IAAI,CAACqE,kBAAkB,CAACgb,WAAW,CAACnG,MAAM,CAAC;QAC3C,MAAM5a,SAAS,GAAG5F,IAAI,CAAC6L,UAAU,IAAIxX,SAAS,CAACgwB,OAAO;QACtDvY,6BAA6B,CAC3BxE,IAAI,EACJtH,IAAI,CAAC+L,MAAM,EACX/L,IAAI,CAACgM,MAAM,EACX2a,WAAW,CAACpb,cAAc,EAC1Boc,cAAc,CAACzb,IAAI,EACnBtG,SACF,CAAC;QAED8Z,IAAI,CAAC1f,IAAI,EAAE4mB,mBAAmB,EAAEtf,IAAI,EAAE;UACpCtC,OAAO,EAAEG,MAAM,CAACF;QAClB,CAAC,CAAC,CACCqK,IAAI,CACHoX,4BAA4B,CAC1B1mB,IAAI,EACJ2mB,WAAW,EACXC,mBAAmB,EACnBiB,eAAe,EACfvgB,IACF,CACF,CAAC,CACAka,KAAK,CAAC,UAAU9f,KAAK,EAAE;UACtB,MAAM2hB,GAAG,GAAG,eAAesD,WAAW,CAACrf,IAAI,oBAAoB5F,KAAK,EAAE;UACtE6X,OAAO,CAACC,GAAG,CAAC6J,GAAG,CAAC;UAChBrjB,IAAI,CAACyhB,MAAM,CAAC7E,UAAU,CAAC5c,IAAI,EAAEqjB,GAAG,CAAC;QACnC,CAAC,CAAC;QACJ8C,OAAO,GAAG,IAAI;MAChB;IACF;IACA0B,eAAe,CAACtG,GAAG,CAACoF,WAAW,CAAC1hB,EAAE,EAAE0hB,WAAW,CAAC;EAClD,CAAC,CAAC;EAEF,IAAIR,OAAO,EAAE;IACX,IAAI,CAAC7E,aAAa,GAAGuG,eAAe;IACpC,IAAI,CAACpE,QAAQ,CAAC7G,UAAU,CAAC,IAAI,CAAC;EAChC;EAEA,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,SAASrX,cAAcA,CAAA,EAAG;EACxB;AACF;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;EACE,IAAI,CAACsS,MAAM,GAAG;IACZhK,IAAI,EAAExR,SAAS;IACf+H,GAAG,EAAE/H,SAAS;IACdV,KAAK,EAAEU;EACT,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;EACE,IAAI,CAAC8a,IAAI,GAAG;IACV7P,IAAI,EAAEjL,SAAS;IACf0b,QAAQ,EAAE1b,SAAS;IACnB2b,GAAG,EAAE3b,SAAS;IACd4b,IAAI,EAAE5b,SAAS;IACf6b,KAAK,EAAE7b,SAAS;IAChBsD,MAAM,EAAEtD;EACV,CAAC;;EAED;AACF;AACA;AACA;EACE,IAAI,CAACwa,OAAO,GAAGxa,SAAS;EACxB;AACF;AACA;AACA;EACE,IAAI,CAAC8b,WAAW,GAAG9b,SAAS;EAC5B;AACF;AACA;AACA;EACE,IAAI,CAACya,OAAO,GAAGza,SAAS;EACxB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACga,YAAY,GAAGha,SAAS;AAC/B;;AAEA;AACAuD,aAAa,CAACmiB,gBAAgB,GAAGhkB,eAAe;AAChD6B,aAAa,CAACC,aAAa,GAAGpL,YAAY;AAE1C,eAAemL,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}