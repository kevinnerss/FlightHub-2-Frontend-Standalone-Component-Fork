{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-hex.js\";\nimport \"core-js/modules/esnext.uint8-array.to-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.to-hex.js\";\nimport Check from \"../Core/Check.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport hasExtension from \"./hasExtension.js\";\nimport ImplicitAvailabilityBitstream from \"./ImplicitAvailabilityBitstream.js\";\nimport ImplicitMetadataView from \"./ImplicitMetadataView.js\";\nimport ImplicitSubdivisionScheme from \"./ImplicitSubdivisionScheme.js\";\nimport ImplicitSubtreeMetadata from \"./ImplicitSubtreeMetadata.js\";\nimport MetadataTable from \"./MetadataTable.js\";\nimport ResourceCache from \"./ResourceCache.js\";\n\n/**\n * An object representing a single subtree in an implicit tileset\n * including availability.\n * <p>\n * Subtrees handle tile metadata, defined in the subtree JSON in either\n * tileMetadata (3D Tiles 1.1) or the <code>3DTILES_metadata</code> extension.\n * Subtrees also handle content metadata and metadata about the subtree itself.\n * </p>\n *\n * This object is normally not instantiated directly, use {@link ImplicitSubtree.fromSubtreeJson}.\n *\n * @see {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_metadata#implicit-tile-properties|Implicit Tile Properties in the 3DTILES_metadata specification}\n * @see ImplicitSubtree.fromSubtreeJson\n *\n * @alias ImplicitSubtree\n * @constructor\n *\n * @param {Resource} resource The resource for this subtree. This is used for fetching external buffers as needed.\n * @param {ImplicitTileset} implicitTileset The implicit tileset. This includes information about the size of subtrees\n * @param {ImplicitTileCoordinates} implicitCoordinates The coordinates of the subtree's root tile.\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction ImplicitSubtree(resource, implicitTileset, implicitCoordinates) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"resource\", resource);\n  Check.typeOf.object(\"implicitTileset\", implicitTileset);\n  Check.typeOf.object(\"implicitCoordinates\", implicitCoordinates);\n  //>>includeEnd('debug');\n\n  this._resource = resource;\n  this._subtreeJson = undefined;\n  this._bufferLoader = undefined;\n  this._tileAvailability = undefined;\n  this._contentAvailabilityBitstreams = [];\n  this._childSubtreeAvailability = undefined;\n  this._implicitCoordinates = implicitCoordinates;\n  this._subtreeLevels = implicitTileset.subtreeLevels;\n  this._subdivisionScheme = implicitTileset.subdivisionScheme;\n  this._branchingFactor = implicitTileset.branchingFactor;\n\n  // properties for metadata\n  this._metadata = undefined;\n  this._tileMetadataTable = undefined;\n  this._tilePropertyTableJson = undefined;\n  this._contentMetadataTables = [];\n  this._contentPropertyTableJsons = [];\n\n  // Jump buffers are maps of availability bit index to entity ID\n  this._tileJumpBuffer = undefined;\n  this._contentJumpBuffers = [];\n  this._ready = false;\n}\nObject.defineProperties(ImplicitSubtree.prototype, {\n  /**\n   * Returns true once all necessary availability buffers\n   * are loaded.\n   *\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n  /**\n   * When subtree metadata is present (3D Tiles 1.1), this property stores an {@link ImplicitSubtreeMetadata} instance\n   *\n   * @type {ImplicitSubtreeMetadata}\n   * @readonly\n   * @private\n   */\n  metadata: {\n    get: function () {\n      return this._metadata;\n    }\n  },\n  /**\n   * When tile metadata is present (3D Tiles 1.1) or the <code>3DTILES_metadata</code> extension is used,\n   * this property stores a {@link MetadataTable} instance for the tiles in the subtree.\n   *\n   * @type {MetadataTable}\n   * @readonly\n   * @private\n   */\n  tileMetadataTable: {\n    get: function () {\n      return this._tileMetadataTable;\n    }\n  },\n  /**\n   * When tile metadata is present (3D Tiles 1.1) or the <code>3DTILES_metadata</code> extension is used,\n   * this property stores the JSON from the extension. This is used by {@link TileMetadata}\n   * to get the extras and extensions for the tiles in the subtree.\n   *\n   * @type {object}\n   * @readonly\n   * @private\n   */\n  tilePropertyTableJson: {\n    get: function () {\n      return this._tilePropertyTableJson;\n    }\n  },\n  /**\n   * When content metadata is present (3D Tiles 1.1), this property stores\n   * an array of {@link MetadataTable} instances for the contents in the subtree.\n   *\n   * @type {Array}\n   * @readonly\n   * @private\n   */\n  contentMetadataTables: {\n    get: function () {\n      return this._contentMetadataTables;\n    }\n  },\n  /**\n   * When content metadata is present (3D Tiles 1.1), this property\n   * an array of the JSONs from the extension. This is used to get the extras\n   * and extensions for the contents in the subtree.\n   *\n   * @type {Array}\n   * @readonly\n   * @private\n   */\n  contentPropertyTableJsons: {\n    get: function () {\n      return this._contentPropertyTableJsons;\n    }\n  },\n  /**\n   * Gets the implicit tile coordinates for the root of the subtree.\n   *\n   * @type {ImplicitTileCoordinates}\n   * @readonly\n   * @private\n   */\n  implicitCoordinates: {\n    get: function () {\n      return this._implicitCoordinates;\n    }\n  }\n});\n\n/**\n * Check if a specific tile is available at an index of the tile availability bitstream\n *\n * @param {number} index The index of the desired tile\n * @returns {boolean} The value of the i-th bit\n * @private\n */\nImplicitSubtree.prototype.tileIsAvailableAtIndex = function (index) {\n  return this._tileAvailability.getBit(index);\n};\n\n/**\n * Check if a specific tile is available at an implicit tile coordinate\n * NOTE: only used for voxels.\n *\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a tile\n * @returns {boolean} The value of the i-th bit\n * @private\n */\nImplicitSubtree.prototype.tileIsAvailableAtCoordinates = function (implicitCoordinates) {\n  const index = this.getTileIndex(implicitCoordinates);\n  return this.tileIsAvailableAtIndex(index);\n};\n\n/**\n * Check if a specific tile's content is available at an index of the content availability bitstream\n *\n * @param {number} index The index of the desired tile\n * @param {number} [contentIndex=0] The index of the desired content when multiple contents are used.\n * @returns {boolean} The value of the i-th bit\n * @private\n */\nImplicitSubtree.prototype.contentIsAvailableAtIndex = function (index, contentIndex) {\n  contentIndex = contentIndex ?? 0;\n  //>>includeStart('debug', pragmas.debug);\n  if (contentIndex < 0 || contentIndex >= this._contentAvailabilityBitstreams.length) {\n    throw new DeveloperError(\"contentIndex out of bounds.\");\n  }\n  //>>includeEnd('debug');\n\n  return this._contentAvailabilityBitstreams[contentIndex].getBit(index);\n};\n\n/**\n * Check if a specific tile's content is available at an implicit tile coordinate\n *\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a tile\n * @param {number} [contentIndex=0] The index of the desired content when the <code>3DTILES_multiple_contents</code> extension is used.\n * @returns {boolean} The value of the i-th bit\n * @private\n */\nImplicitSubtree.prototype.contentIsAvailableAtCoordinates = function (implicitCoordinates, contentIndex) {\n  const index = this.getTileIndex(implicitCoordinates);\n  return this.contentIsAvailableAtIndex(index, contentIndex);\n};\n\n/**\n * Check if a child subtree is available at an index of the child subtree availability bitstream\n *\n * @param {number} index The index of the desired child subtree\n * @returns {boolean} The value of the i-th bit\n * @private\n */\nImplicitSubtree.prototype.childSubtreeIsAvailableAtIndex = function (index) {\n  return this._childSubtreeAvailability.getBit(index);\n};\n\n/**\n * Check if a specific child subtree is available at an implicit tile coordinate\n * NOTE: only used for voxels.\n *\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a child subtree\n * @returns {boolean} The value of the i-th bit\n * @private\n */\nImplicitSubtree.prototype.childSubtreeIsAvailableAtCoordinates = function (implicitCoordinates) {\n  const index = this.getChildSubtreeIndex(implicitCoordinates);\n  return this.childSubtreeIsAvailableAtIndex(index);\n};\n\n/**\n * Get the index of the first node at the given level within this subtree.\n * e.g. for a quadtree:\n * <ul>\n * <li>Level 0 starts at index 0</li>\n * <li>Level 1 starts at index 1</li>\n * <li>Level 2 starts at index 5</li>\n * </ul>\n *\n * @param {number} level The 0-indexed level number relative to the root of the subtree\n * @returns {number} The first index at the desired level\n * @private\n */\nImplicitSubtree.prototype.getLevelOffset = function (level) {\n  const branchingFactor = this._branchingFactor;\n  return (Math.pow(branchingFactor, level) - 1) / (branchingFactor - 1);\n};\n\n/**\n * Get the morton index of a tile's parent. This is equivalent to\n * chopping off the last 2 (quadtree) or 3 (octree) bits of the morton\n * index.\n *\n * @param {number} childIndex The morton index of the child tile relative to its parent\n * @returns {number} The index of the child's parent node\n * @private\n */\nImplicitSubtree.prototype.getParentMortonIndex = function (mortonIndex) {\n  let bitsPerLevel = 2;\n  if (this._subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    bitsPerLevel = 3;\n  }\n  return mortonIndex >> bitsPerLevel;\n};\n\n/**\n * Parse all relevant information out of the subtree. This fetches any\n * external buffers that are used by the implicit tileset.\n *\n * @param {Resource} resource The resource for this subtree. This is used for fetching external buffers as needed.\n * @param {object} [json] The JSON object for this subtree. If parsing from a binary subtree file, this will be undefined.\n * @param {Uint8Array} [subtreeView] The contents of the subtree binary\n * @param {ImplicitTileset} implicitTileset The implicit tileset this subtree belongs to.\n * @param {ImplicitTileCoordinates} implicitCoordinates The coordinates of the subtree's root tile.\n * @return {Promise<ImplicitSubtree>} The created subtree\n * @private\n *\n * @exception {DeveloperError} One of json and subtreeView must be defined.\n */\nImplicitSubtree.fromSubtreeJson = async function (resource, json, subtreeView, implicitTileset, implicitCoordinates) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"resource\", resource);\n  if (defined(json) === defined(subtreeView)) {\n    throw new DeveloperError(\"One of json and subtreeView must be defined.\");\n  }\n  Check.typeOf.object(\"implicitTileset\", implicitTileset);\n  Check.typeOf.object(\"implicitCoordinates\", implicitCoordinates);\n  //>>includeEnd('debug');\n\n  const subtree = new ImplicitSubtree(resource, implicitTileset, implicitCoordinates);\n  let chunks;\n  if (defined(json)) {\n    chunks = {\n      json: json,\n      binary: undefined\n    };\n  } else {\n    chunks = parseSubtreeChunks(subtreeView);\n  }\n  const subtreeJson = chunks.json;\n  subtree._subtreeJson = subtreeJson;\n  let tilePropertyTableJson;\n  if (hasExtension(subtreeJson, \"3DTILES_metadata\")) {\n    tilePropertyTableJson = subtreeJson.extensions[\"3DTILES_metadata\"];\n  } else if (defined(subtreeJson.tileMetadata)) {\n    const propertyTableIndex = subtreeJson.tileMetadata;\n    tilePropertyTableJson = subtreeJson.propertyTables[propertyTableIndex];\n  }\n  const contentPropertyTableJsons = [];\n  if (defined(subtreeJson.contentMetadata)) {\n    const length = subtreeJson.contentMetadata.length;\n    for (let i = 0; i < length; i++) {\n      const propertyTableIndex = subtreeJson.contentMetadata[i];\n      contentPropertyTableJsons.push(subtreeJson.propertyTables[propertyTableIndex]);\n    }\n  }\n  let metadata;\n  const schema = implicitTileset.metadataSchema;\n  const subtreeMetadata = subtreeJson.subtreeMetadata;\n  if (defined(subtreeMetadata)) {\n    const metadataClass = subtreeMetadata.class;\n    const subtreeMetadataClass = schema.classes[metadataClass];\n    metadata = new ImplicitSubtreeMetadata({\n      subtreeMetadata: subtreeMetadata,\n      class: subtreeMetadataClass\n    });\n  }\n  subtree._metadata = metadata;\n  subtree._tilePropertyTableJson = tilePropertyTableJson;\n  subtree._contentPropertyTableJsons = contentPropertyTableJsons;\n\n  // if no contentAvailability is specified, no tile in the subtree has\n  // content\n  const defaultContentAvailability = {\n    constant: 0\n  };\n\n  // In 3D Tiles 1.1, content availability is provided in an array in the subtree JSON\n  // regardless of whether or not it contains multiple contents. This differs from previous\n  // schemas, where content availability is either a single object in the subtree JSON or\n  // as an array in the 3DTILES_multiple_contents extension.\n  //\n  // After identifying how availability is stored, put the results in this new array for consistent processing later\n  subtreeJson.contentAvailabilityHeaders = [];\n  if (hasExtension(subtreeJson, \"3DTILES_multiple_contents\")) {\n    subtreeJson.contentAvailabilityHeaders = subtreeJson.extensions[\"3DTILES_multiple_contents\"].contentAvailability;\n  } else if (Array.isArray(subtreeJson.contentAvailability)) {\n    subtreeJson.contentAvailabilityHeaders = subtreeJson.contentAvailability;\n  } else {\n    subtreeJson.contentAvailabilityHeaders.push(subtreeJson.contentAvailability ?? defaultContentAvailability);\n  }\n  const bufferHeaders = preprocessBuffers(subtreeJson.buffers);\n  const bufferViewHeaders = preprocessBufferViews(subtreeJson.bufferViews, bufferHeaders);\n\n  // Buffers and buffer views are inactive until explicitly marked active.\n  // This way we can avoid fetching buffers that will not be used.\n  markActiveBufferViews(subtreeJson, bufferViewHeaders);\n  if (defined(tilePropertyTableJson)) {\n    markActiveMetadataBufferViews(tilePropertyTableJson, bufferViewHeaders);\n  }\n  for (let i = 0; i < contentPropertyTableJsons.length; i++) {\n    const contentPropertyTableJson = contentPropertyTableJsons[i];\n    markActiveMetadataBufferViews(contentPropertyTableJson, bufferViewHeaders);\n  }\n  const buffersU8 = await requestActiveBuffers(subtree, bufferHeaders, chunks.binary);\n  const bufferViewsU8 = parseActiveBufferViews(bufferViewHeaders, buffersU8);\n  parseAvailability(subtree, subtreeJson, implicitTileset, bufferViewsU8);\n  if (defined(tilePropertyTableJson)) {\n    parseTileMetadataTable(subtree, implicitTileset, bufferViewsU8);\n    makeTileJumpBuffer(subtree);\n  }\n  parseContentMetadataTables(subtree, implicitTileset, bufferViewsU8);\n  makeContentJumpBuffers(subtree);\n  subtree._ready = true;\n  return subtree;\n};\n\n/**\n * A helper object for storing the two parts of the subtree binary\n *\n * @typedef {object} SubtreeChunks\n * @property {object} json The json chunk of the subtree\n * @property {Uint8Array} binary The binary chunk of the subtree. This represents the internal buffer.\n * @private\n */\n\n/**\n * Given the binary contents of a subtree, split into JSON and binary chunks\n *\n * @param {Uint8Array} subtreeView The subtree binary\n * @returns {SubtreeChunks} An object containing the JSON and binary chunks.\n * @private\n */\nfunction parseSubtreeChunks(subtreeView) {\n  // Parse the header\n  const littleEndian = true;\n  const subtreeReader = new DataView(subtreeView.buffer, subtreeView.byteOffset);\n  // Skip to the chunk lengths\n  let byteOffset = 8;\n\n  // Read the bottom 32 bits of the 64-bit byte length. This is ok for now because:\n  // 1) not all browsers have native 64-bit operations\n  // 2) the data is well under 4GB\n  const jsonByteLength = subtreeReader.getUint32(byteOffset, littleEndian);\n  byteOffset += 8;\n  const binaryByteLength = subtreeReader.getUint32(byteOffset, littleEndian);\n  byteOffset += 8;\n  const subtreeJson = getJsonFromTypedArray(subtreeView, byteOffset, jsonByteLength);\n  byteOffset += jsonByteLength;\n  const subtreeBinary = subtreeView.subarray(byteOffset, byteOffset + binaryByteLength);\n  return {\n    json: subtreeJson,\n    binary: subtreeBinary\n  };\n}\n\n/**\n * A buffer header is the JSON header from the subtree JSON chunk plus\n * a couple extra boolean flags for easy reference.\n *\n * Buffers are assumed inactive until explicitly marked active. This is used\n * to avoid fetching unneeded buffers.\n *\n * @typedef {object} BufferHeader\n * @property {boolean} isExternal True if this is an external buffer\n * @property {boolean} isActive Whether this buffer is currently used.\n * @property {string} [uri] The URI of the buffer (external buffers only)\n * @property {number} byteLength The byte length of the buffer, including any padding contained within.\n * @private\n */\n\n/**\n * Iterate over the list of buffers from the subtree JSON and add the\n * isExternal and isActive fields for easier parsing later. This modifies\n * the objects in place.\n *\n * @param {Object[]} [bufferHeaders=[]] The JSON from subtreeJson.buffers.\n * @returns {BufferHeader[]} The same array of headers with additional fields.\n * @private\n */\nfunction preprocessBuffers(bufferHeaders) {\n  bufferHeaders = defined(bufferHeaders) ? bufferHeaders : [];\n  for (let i = 0; i < bufferHeaders.length; i++) {\n    const bufferHeader = bufferHeaders[i];\n    bufferHeader.isExternal = defined(bufferHeader.uri);\n    bufferHeader.isActive = false;\n  }\n  return bufferHeaders;\n}\n\n/**\n * A buffer header is the JSON header from the subtree JSON chunk plus\n * the isActive flag and a reference to the header for the underlying buffer\n *\n * @typedef {object} BufferViewHeader\n * @property {BufferHeader} bufferHeader A reference to the header for the underlying buffer\n * @property {boolean} isActive Whether this bufferView is currently used.\n * @property {number} buffer The index of the underlying buffer.\n * @property {number} byteOffset The start byte of the bufferView within the buffer.\n * @property {number} byteLength The length of the bufferView. No padding is included in this length.\n * @private\n */\n\n/**\n * Iterate the list of buffer views from the subtree JSON and add the\n * isActive flag. Also save a reference to the bufferHeader\n *\n * @param {Object[]} [bufferViewHeaders=[]] The JSON from subtree.bufferViews\n * @param {BufferHeader[]} bufferHeaders The preprocessed buffer headers\n * @returns {BufferViewHeader[]} The same array of bufferView headers with additional fields\n * @private\n */\nfunction preprocessBufferViews(bufferViewHeaders, bufferHeaders) {\n  bufferViewHeaders = defined(bufferViewHeaders) ? bufferViewHeaders : [];\n  for (let i = 0; i < bufferViewHeaders.length; i++) {\n    const bufferViewHeader = bufferViewHeaders[i];\n    const bufferHeader = bufferHeaders[bufferViewHeader.buffer];\n    bufferViewHeader.bufferHeader = bufferHeader;\n    bufferViewHeader.isActive = false;\n  }\n  return bufferViewHeaders;\n}\n\n/**\n * Determine which buffer views need to be loaded into memory. This includes:\n *\n * <ul>\n * <li>The tile availability bitstream (if a bitstream is defined)</li>\n * <li>The content availability bitstream(s) (if a bitstream is defined)</li>\n * <li>The child subtree availability bitstream (if a bitstream is defined)</li>\n * </ul>\n *\n * <p>\n * This function modifies the buffer view headers' isActive flags in place.\n * </p>\n *\n * @param {Object[]} subtreeJson The JSON chunk from the subtree\n * @param {BufferViewHeader[]} bufferViewHeaders The preprocessed buffer view headers\n * @private\n */\nfunction markActiveBufferViews(subtreeJson, bufferViewHeaders) {\n  let header;\n  const tileAvailabilityHeader = subtreeJson.tileAvailability;\n\n  // Check for bitstream first, which is part of the current schema.\n  // bufferView is the name of the bitstream from an older schema.\n  if (defined(tileAvailabilityHeader.bitstream)) {\n    header = bufferViewHeaders[tileAvailabilityHeader.bitstream];\n  } else if (defined(tileAvailabilityHeader.bufferView)) {\n    header = bufferViewHeaders[tileAvailabilityHeader.bufferView];\n  }\n  if (defined(header)) {\n    header.isActive = true;\n    header.bufferHeader.isActive = true;\n  }\n  const contentAvailabilityHeaders = subtreeJson.contentAvailabilityHeaders;\n  for (let i = 0; i < contentAvailabilityHeaders.length; i++) {\n    header = undefined;\n    if (defined(contentAvailabilityHeaders[i].bitstream)) {\n      header = bufferViewHeaders[contentAvailabilityHeaders[i].bitstream];\n    } else if (defined(contentAvailabilityHeaders[i].bufferView)) {\n      header = bufferViewHeaders[contentAvailabilityHeaders[i].bufferView];\n    }\n    if (defined(header)) {\n      header.isActive = true;\n      header.bufferHeader.isActive = true;\n    }\n  }\n  header = undefined;\n  const childSubtreeAvailabilityHeader = subtreeJson.childSubtreeAvailability;\n  if (defined(childSubtreeAvailabilityHeader.bitstream)) {\n    header = bufferViewHeaders[childSubtreeAvailabilityHeader.bitstream];\n  } else if (defined(childSubtreeAvailabilityHeader.bufferView)) {\n    header = bufferViewHeaders[childSubtreeAvailabilityHeader.bufferView];\n  }\n  if (defined(header)) {\n    header.isActive = true;\n    header.bufferHeader.isActive = true;\n  }\n}\n\n/**\n * For handling metadata, look over the tile and content metadata buffers\n * <p>\n * This always loads all of the metadata immediately. Future iterations may\n * allow filtering this to avoid downloading unneeded buffers.\n * </p>\n *\n * @param {object} propertyTableJson The property table JSON for either a tile or some content\n * @param {BufferViewHeader[]} bufferViewHeaders The preprocessed buffer view headers\n * @private\n */\nfunction markActiveMetadataBufferViews(propertyTableJson, bufferViewHeaders) {\n  const properties = propertyTableJson.properties;\n  let header;\n  for (const key in properties) {\n    if (properties.hasOwnProperty(key)) {\n      const metadataHeader = properties[key];\n\n      // An older spec used bufferView\n      const valuesBufferView = metadataHeader.values ?? metadataHeader.bufferView;\n      header = bufferViewHeaders[valuesBufferView];\n      header.isActive = true;\n      header.bufferHeader.isActive = true;\n\n      // An older spec used stringOffsetBufferView\n      const stringOffsetBufferView = metadataHeader.stringOffsets ?? metadataHeader.stringOffsetBufferView;\n      if (defined(stringOffsetBufferView)) {\n        header = bufferViewHeaders[stringOffsetBufferView];\n        header.isActive = true;\n        header.bufferHeader.isActive = true;\n      }\n\n      // an older spec used arrayOffsetBufferView\n      const arrayOffsetBufferView = metadataHeader.arrayOffsets ?? metadataHeader.arrayOffsetBufferView;\n      if (defined(arrayOffsetBufferView)) {\n        header = bufferViewHeaders[arrayOffsetBufferView];\n        header.isActive = true;\n        header.bufferHeader.isActive = true;\n      }\n    }\n  }\n}\n\n/**\n * Go through the list of buffers and gather all the active ones into a\n * a dictionary. Since external buffers are allowed, this sometimes involves\n * fetching separate binary files. Consequently, this method returns a promise.\n * <p>\n * The results are put into a dictionary object. The keys are indices of\n * buffers, and the values are Uint8Arrays of the contents. Only buffers\n * marked with the isActive flag are fetched.\n * </p>\n * <p>\n * The internal buffer (the subtree's binary chunk) is also stored in this\n * dictionary if it is marked active.\n * </p>\n * @param {ImplicitSubtree} subtree The subtree\n * @param {BufferHeader[]} bufferHeaders The preprocessed buffer headers\n * @param {Uint8Array} internalBuffer The binary chunk of the subtree file\n * @returns {Promise<object>} A promise resolving to the dictionary of active buffers\n * @private\n */\nfunction requestActiveBuffers(subtree, bufferHeaders, internalBuffer) {\n  const promises = [];\n  for (let i = 0; i < bufferHeaders.length; i++) {\n    const bufferHeader = bufferHeaders[i];\n    if (!bufferHeader.isActive) {\n      promises.push(Promise.resolve(undefined));\n    } else if (bufferHeader.isExternal) {\n      const promise = requestExternalBuffer(subtree, bufferHeader);\n      promises.push(promise);\n    } else {\n      promises.push(Promise.resolve(internalBuffer));\n    }\n  }\n  return Promise.all(promises).then(function (bufferResults) {\n    const buffersU8 = {};\n    for (let i = 0; i < bufferResults.length; i++) {\n      const result = bufferResults[i];\n      if (defined(result)) {\n        buffersU8[i] = result;\n      }\n    }\n    return buffersU8;\n  });\n}\nasync function requestExternalBuffer(subtree, bufferHeader) {\n  const baseResource = subtree._resource;\n  const bufferResource = baseResource.getDerivedResource({\n    url: bufferHeader.uri\n  });\n  const bufferLoader = ResourceCache.getExternalBufferLoader({\n    resource: bufferResource\n  });\n  subtree._bufferLoader = bufferLoader;\n  try {\n    await bufferLoader.load();\n  } catch (error) {\n    if (bufferLoader.isDestroyed()) {\n      return;\n    }\n    throw error;\n  }\n  return bufferLoader.typedArray;\n}\n\n/**\n * Go through the list of buffer views, and if they are marked as active,\n * extract a subarray from one of the active buffers.\n *\n * @param {BufferViewHeader[]} bufferViewHeaders\n * @param {object} buffersU8 A dictionary of buffer index to a Uint8Array of its contents.\n * @returns {object} A dictionary of buffer view index to a Uint8Array of its contents.\n * @private\n */\nfunction parseActiveBufferViews(bufferViewHeaders, buffersU8) {\n  const bufferViewsU8 = {};\n  for (let i = 0; i < bufferViewHeaders.length; i++) {\n    const bufferViewHeader = bufferViewHeaders[i];\n    if (!bufferViewHeader.isActive) {\n      continue;\n    }\n    const start = bufferViewHeader.byteOffset;\n    const end = start + bufferViewHeader.byteLength;\n    const buffer = buffersU8[bufferViewHeader.buffer];\n    const bufferView = buffer.subarray(start, end);\n    bufferViewsU8[i] = bufferView;\n  }\n  return bufferViewsU8;\n}\n\n/**\n * Parse the three availability bitstreams and store them in the subtree\n *\n * @param {ImplicitSubtree} subtree The subtree to modify\n * @param {object} subtreeJson The subtree JSON\n * @param {ImplicitTileset} implicitTileset The implicit tileset this subtree belongs to\n * @param {object} bufferViewsU8 A dictionary of buffer view index to a Uint8Array of its contents.\n * @private\n */\nfunction parseAvailability(subtree, subtreeJson, implicitTileset, bufferViewsU8) {\n  const branchingFactor = implicitTileset.branchingFactor;\n  const subtreeLevels = implicitTileset.subtreeLevels;\n  const tileAvailabilityBits = (Math.pow(branchingFactor, subtreeLevels) - 1) / (branchingFactor - 1);\n  const childSubtreeBits = Math.pow(branchingFactor, subtreeLevels);\n\n  // availableCount is only needed for the metadata jump buffer, which\n  // corresponds to the tile availability bitstream.\n  const hasMetadataExtension = hasExtension(subtreeJson, \"3DTILES_metadata\");\n  const hasTileMetadata = defined(subtree._tilePropertyTableJson);\n  let computeAvailableCountEnabled = hasMetadataExtension || hasTileMetadata;\n  subtree._tileAvailability = parseAvailabilityBitstream(subtreeJson.tileAvailability, bufferViewsU8, tileAvailabilityBits, computeAvailableCountEnabled);\n  const hasContentMetadata = subtree._contentPropertyTableJsons.length > 0;\n  computeAvailableCountEnabled = computeAvailableCountEnabled || hasContentMetadata;\n  for (let i = 0; i < subtreeJson.contentAvailabilityHeaders.length; i++) {\n    const bitstream = parseAvailabilityBitstream(subtreeJson.contentAvailabilityHeaders[i], bufferViewsU8,\n    // content availability has the same length as tile availability.\n    tileAvailabilityBits, computeAvailableCountEnabled);\n    subtree._contentAvailabilityBitstreams.push(bitstream);\n  }\n  subtree._childSubtreeAvailability = parseAvailabilityBitstream(subtreeJson.childSubtreeAvailability, bufferViewsU8, childSubtreeBits);\n}\n\n/**\n * Given the JSON describing an availability bitstream, turn it into an\n * in-memory representation using an {@link ImplicitAvailabilityBitstream}\n * object. This handles both constants and bitstreams from a bufferView.\n *\n * @param {object} availabilityJson A JSON object representing the availability\n * @param {object} bufferViewsU8 A dictionary of bufferView index to its Uint8Array contents.\n * @param {number} lengthBits The length of the availability bitstream in bits\n * @param {boolean} [computeAvailableCountEnabled] If true and availabilityJson.availableCount is undefined, the availableCount will be computed.\n * @returns {ImplicitAvailabilityBitstream} The parsed bitstream object\n * @private\n */\nfunction parseAvailabilityBitstream(availabilityJson, bufferViewsU8, lengthBits, computeAvailableCountEnabled) {\n  if (defined(availabilityJson.constant)) {\n    return new ImplicitAvailabilityBitstream({\n      constant: Boolean(availabilityJson.constant),\n      lengthBits: lengthBits,\n      availableCount: availabilityJson.availableCount\n    });\n  }\n  let bufferView;\n\n  // Check for bitstream first, which is part of the current schema.\n  // bufferView is the name of the bitstream from an older schema.\n  if (defined(availabilityJson.bitstream)) {\n    bufferView = bufferViewsU8[availabilityJson.bitstream];\n  } else if (defined(availabilityJson.bufferView)) {\n    bufferView = bufferViewsU8[availabilityJson.bufferView];\n  }\n  return new ImplicitAvailabilityBitstream({\n    bitstream: bufferView,\n    lengthBits: lengthBits,\n    availableCount: availabilityJson.availableCount,\n    computeAvailableCountEnabled: computeAvailableCountEnabled\n  });\n}\n\n/**\n * Parse the metadata table for the tile metadata, storing a {@link MetadataTable}\n * in the subtree.\n *\n * @param {ImplicitSubtree} subtree The subtree\n * @param {ImplicitTileset} implicitTileset The implicit tileset this subtree belongs to.\n * @param {object} bufferViewsU8 A dictionary of bufferView index to its Uint8Array contents.\n * @private\n */\nfunction parseTileMetadataTable(subtree, implicitTileset, bufferViewsU8) {\n  const tilePropertyTableJson = subtree._tilePropertyTableJson;\n  const tileCount = subtree._tileAvailability.availableCount;\n  const metadataSchema = implicitTileset.metadataSchema;\n  const tileMetadataClassName = tilePropertyTableJson.class;\n  const tileMetadataClass = metadataSchema.classes[tileMetadataClassName];\n  subtree._tileMetadataTable = new MetadataTable({\n    class: tileMetadataClass,\n    count: tileCount,\n    properties: tilePropertyTableJson.properties,\n    bufferViews: bufferViewsU8\n  });\n}\n\n/**\n * Parse the metadata tables for the content metadata, storing an array of\n * {@link MetadataTable}s in the subtree.\n *\n * @param {ImplicitSubtree} subtree The subtree\n * @param {ImplicitTileset} implicitTileset The implicit tileset this subtree belongs to.\n * @param {object} bufferViewsU8 A dictionary of bufferView index to its Uint8Array contents.\n * @private\n */\nfunction parseContentMetadataTables(subtree, implicitTileset, bufferViewsU8) {\n  const contentPropertyTableJsons = subtree._contentPropertyTableJsons;\n  const contentAvailabilityBitstreams = subtree._contentAvailabilityBitstreams;\n  const metadataSchema = implicitTileset.metadataSchema;\n  const contentMetadataTables = subtree._contentMetadataTables;\n  for (let i = 0; i < contentPropertyTableJsons.length; i++) {\n    const contentPropertyTableJson = contentPropertyTableJsons[i];\n    const contentAvailabilityBitsteam = contentAvailabilityBitstreams[i];\n    const contentCount = contentAvailabilityBitsteam.availableCount;\n    const contentMetadataClassName = contentPropertyTableJson.class;\n    const contentMetadataClass = metadataSchema.classes[contentMetadataClassName];\n    const metadataTable = new MetadataTable({\n      class: contentMetadataClass,\n      count: contentCount,\n      properties: contentPropertyTableJson.properties,\n      bufferViews: bufferViewsU8\n    });\n    contentMetadataTables.push(metadataTable);\n  }\n}\n\n/**\n * Make a jump buffer, i.e. a map of a bit index to the metadata entity ID.\n * <p>\n * For unavailable tiles and content, the jump buffer entries will be uninitialized.\n * Use the tile and content availability to determine whether a jump buffer value is valid.\n * </p>\n *\n * @param {ImplicitAvailabilityBitstream} availability The availability bitstream to create the jump buffer from.\n * @returns {Array} The resulting jump buffer.\n * @private\n */\nfunction makeJumpBuffer(availability) {\n  let entityId = 0;\n  const bufferLength = availability.lengthBits;\n  const availableCount = availability.availableCount;\n  let jumpBuffer;\n  if (availableCount < 256) {\n    jumpBuffer = new Uint8Array(bufferLength);\n  } else if (availableCount < 65536) {\n    jumpBuffer = new Uint16Array(bufferLength);\n  } else {\n    jumpBuffer = new Uint32Array(bufferLength);\n  }\n  for (let i = 0; i < availability.lengthBits; i++) {\n    if (availability.getBit(i)) {\n      jumpBuffer[i] = entityId;\n      entityId++;\n    }\n  }\n  return jumpBuffer;\n}\n\n/**\n * Make the jump buffer, i.e. a map of a bit index to the metadata entity ID,\n * for the content metadata. This is stored in the subtree.\n *\n * @param {ImplicitSubtree} subtree The subtree\n * @private\n */\nfunction makeTileJumpBuffer(subtree) {\n  const tileJumpBuffer = makeJumpBuffer(subtree._tileAvailability);\n  subtree._tileJumpBuffer = tileJumpBuffer;\n}\n\n/**\n * Make the jump buffers, i.e. maps of bit indices to the metadata entity IDs,\n * for the content metadata. This is stored in the subtree.\n *\n * @param {ImplicitSubtree} subtree The subtree\n * @private\n */\nfunction makeContentJumpBuffers(subtree) {\n  const contentJumpBuffers = subtree._contentJumpBuffers;\n  const contentAvailabilityBitstreams = subtree._contentAvailabilityBitstreams;\n  for (let i = 0; i < contentAvailabilityBitstreams.length; i++) {\n    const contentAvailability = contentAvailabilityBitstreams[i];\n    const contentJumpBuffer = makeJumpBuffer(contentAvailability);\n    contentJumpBuffers.push(contentJumpBuffer);\n  }\n}\n\n/**\n * Given the implicit tiling coordinates for a tile, get the index within the\n * subtree's tile availability bitstream.\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a tile\n * @return {number} The tile's index within the subtree.\n * @private\n */\nImplicitSubtree.prototype.getTileIndex = function (implicitCoordinates) {\n  const localLevel = implicitCoordinates.level - this._implicitCoordinates.level;\n  if (localLevel < 0 || this._subtreeLevels <= localLevel) {\n    throw new RuntimeError(\"level is out of bounds for this subtree\");\n  }\n  const subtreeCoordinates = implicitCoordinates.getSubtreeCoordinates();\n  const offsetCoordinates = subtreeCoordinates.getOffsetCoordinates(implicitCoordinates);\n  const index = offsetCoordinates.tileIndex;\n  return index;\n};\n\n/**\n * Given the implicit tiling coordinates for a child subtree, get the index within the\n * subtree's child subtree availability bitstream.\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a child subtree\n * @return {number} The child subtree's index within the subtree's child subtree availability bitstream.\n * @private\n */\nImplicitSubtree.prototype.getChildSubtreeIndex = function (implicitCoordinates) {\n  const localLevel = implicitCoordinates.level - this._implicitCoordinates.level;\n  if (localLevel !== this._implicitCoordinates.subtreeLevels) {\n    throw new RuntimeError(\"level is out of bounds for this subtree\");\n  }\n\n  // Call getParentSubtreeCoordinates instead of getSubtreeCoordinates because the\n  // child subtree is by definition the root of its own subtree, so we need to find\n  // the parent subtree.\n  const parentSubtreeCoordinates = implicitCoordinates.getParentSubtreeCoordinates();\n  const offsetCoordinates = parentSubtreeCoordinates.getOffsetCoordinates(implicitCoordinates);\n  const index = offsetCoordinates.mortonIndex;\n  return index;\n};\n\n/**\n * Get the entity ID for a tile within this subtree.\n * @param {ImplicitSubtree} subtree The subtree\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a tile\n * @return {number} The entity ID for this tile for accessing tile metadata, or <code>undefined</code> if not applicable.\n *\n * @private\n */\nfunction getTileEntityId(subtree, implicitCoordinates) {\n  if (!defined(subtree._tileMetadataTable)) {\n    return undefined;\n  }\n  const tileIndex = subtree.getTileIndex(implicitCoordinates);\n  if (subtree._tileAvailability.getBit(tileIndex)) {\n    return subtree._tileJumpBuffer[tileIndex];\n  }\n  return undefined;\n}\n\n/**\n * Get the entity ID for a content within this subtree.\n * @param {ImplicitSubtree} subtree The subtree\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a content\n * @param {number} contentIndex The content index, for distinguishing between multiple contents.\n * @return {number} The entity ID for this content for accessing content metadata, or <code>undefined</code> if not applicable.\n *\n * @private\n */\nfunction getContentEntityId(subtree, implicitCoordinates, contentIndex) {\n  const metadataTables = subtree._contentMetadataTables;\n  if (!defined(metadataTables)) {\n    return undefined;\n  }\n  const metadataTable = metadataTables[contentIndex];\n  if (!defined(metadataTable)) {\n    return undefined;\n  }\n  const availability = subtree._contentAvailabilityBitstreams[contentIndex];\n  const tileIndex = subtree.getTileIndex(implicitCoordinates);\n  if (availability.getBit(tileIndex)) {\n    const contentJumpBuffer = subtree._contentJumpBuffers[contentIndex];\n    return contentJumpBuffer[tileIndex];\n  }\n  return undefined;\n}\n\n/**\n * Create and return a metadata table view for a tile within this subtree.\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a tile\n * @return {ImplicitMetadataView} The metadata view for this tile, or <code>undefined</code> if not applicable.\n *\n * @private\n */\nImplicitSubtree.prototype.getTileMetadataView = function (implicitCoordinates) {\n  const entityId = getTileEntityId(this, implicitCoordinates);\n  if (!defined(entityId)) {\n    return undefined;\n  }\n  const metadataTable = this._tileMetadataTable;\n  return new ImplicitMetadataView({\n    class: metadataTable.class,\n    metadataTable: metadataTable,\n    entityId: entityId,\n    propertyTableJson: this._tilePropertyTableJson\n  });\n};\n\n/**\n * Create and return a metadata table view for a content within this subtree.\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a content\n * @param {number} contentIndex The index of the content used to distinguish between multiple contents\n * @return {ImplicitMetadataView} The metadata view for this content, or <code>undefined</code> if not applicable.\n *\n * @private\n */\nImplicitSubtree.prototype.getContentMetadataView = function (implicitCoordinates, contentIndex) {\n  const entityId = getContentEntityId(this, implicitCoordinates, contentIndex);\n  if (!defined(entityId)) {\n    return undefined;\n  }\n  const metadataTable = this._contentMetadataTables[contentIndex];\n  const propertyTableJson = this._contentPropertyTableJsons[contentIndex];\n  return new ImplicitMetadataView({\n    class: metadataTable.class,\n    metadataTable: metadataTable,\n    entityId: entityId,\n    contentIndex: contentIndex,\n    propertyTableJson: propertyTableJson\n  });\n};\n\n/**\n * @private\n */\nImplicitSubtree.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * @private\n */\nImplicitSubtree.prototype.destroy = function () {\n  if (defined(this._bufferLoader)) {\n    ResourceCache.unload(this._bufferLoader);\n  }\n  return destroyObject(this);\n};\nexport default ImplicitSubtree;","map":{"version":3,"names":["Check","DeveloperError","defined","destroyObject","getJsonFromTypedArray","RuntimeError","hasExtension","ImplicitAvailabilityBitstream","ImplicitMetadataView","ImplicitSubdivisionScheme","ImplicitSubtreeMetadata","MetadataTable","ResourceCache","ImplicitSubtree","resource","implicitTileset","implicitCoordinates","typeOf","object","_resource","_subtreeJson","undefined","_bufferLoader","_tileAvailability","_contentAvailabilityBitstreams","_childSubtreeAvailability","_implicitCoordinates","_subtreeLevels","subtreeLevels","_subdivisionScheme","subdivisionScheme","_branchingFactor","branchingFactor","_metadata","_tileMetadataTable","_tilePropertyTableJson","_contentMetadataTables","_contentPropertyTableJsons","_tileJumpBuffer","_contentJumpBuffers","_ready","Object","defineProperties","prototype","ready","get","metadata","tileMetadataTable","tilePropertyTableJson","contentMetadataTables","contentPropertyTableJsons","tileIsAvailableAtIndex","index","getBit","tileIsAvailableAtCoordinates","getTileIndex","contentIsAvailableAtIndex","contentIndex","length","contentIsAvailableAtCoordinates","childSubtreeIsAvailableAtIndex","childSubtreeIsAvailableAtCoordinates","getChildSubtreeIndex","getLevelOffset","level","Math","pow","getParentMortonIndex","mortonIndex","bitsPerLevel","OCTREE","fromSubtreeJson","json","subtreeView","subtree","chunks","binary","parseSubtreeChunks","subtreeJson","extensions","tileMetadata","propertyTableIndex","propertyTables","contentMetadata","i","push","schema","metadataSchema","subtreeMetadata","metadataClass","class","subtreeMetadataClass","classes","defaultContentAvailability","constant","contentAvailabilityHeaders","contentAvailability","Array","isArray","bufferHeaders","preprocessBuffers","buffers","bufferViewHeaders","preprocessBufferViews","bufferViews","markActiveBufferViews","markActiveMetadataBufferViews","contentPropertyTableJson","buffersU8","requestActiveBuffers","bufferViewsU8","parseActiveBufferViews","parseAvailability","parseTileMetadataTable","makeTileJumpBuffer","parseContentMetadataTables","makeContentJumpBuffers","littleEndian","subtreeReader","DataView","buffer","byteOffset","jsonByteLength","getUint32","binaryByteLength","subtreeBinary","subarray","bufferHeader","isExternal","uri","isActive","bufferViewHeader","header","tileAvailabilityHeader","tileAvailability","bitstream","bufferView","childSubtreeAvailabilityHeader","childSubtreeAvailability","propertyTableJson","properties","key","hasOwnProperty","metadataHeader","valuesBufferView","values","stringOffsetBufferView","stringOffsets","arrayOffsetBufferView","arrayOffsets","internalBuffer","promises","Promise","resolve","promise","requestExternalBuffer","all","then","bufferResults","result","baseResource","bufferResource","getDerivedResource","url","bufferLoader","getExternalBufferLoader","load","error","isDestroyed","typedArray","start","end","byteLength","tileAvailabilityBits","childSubtreeBits","hasMetadataExtension","hasTileMetadata","computeAvailableCountEnabled","parseAvailabilityBitstream","hasContentMetadata","availabilityJson","lengthBits","Boolean","availableCount","tileCount","tileMetadataClassName","tileMetadataClass","count","contentAvailabilityBitstreams","contentAvailabilityBitsteam","contentCount","contentMetadataClassName","contentMetadataClass","metadataTable","makeJumpBuffer","availability","entityId","bufferLength","jumpBuffer","Uint8Array","Uint16Array","Uint32Array","tileJumpBuffer","contentJumpBuffers","contentJumpBuffer","localLevel","subtreeCoordinates","getSubtreeCoordinates","offsetCoordinates","getOffsetCoordinates","tileIndex","parentSubtreeCoordinates","getParentSubtreeCoordinates","getTileEntityId","getContentEntityId","metadataTables","getTileMetadataView","getContentMetadataView","destroy","unload"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/ImplicitSubtree.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport hasExtension from \"./hasExtension.js\";\nimport ImplicitAvailabilityBitstream from \"./ImplicitAvailabilityBitstream.js\";\nimport ImplicitMetadataView from \"./ImplicitMetadataView.js\";\nimport ImplicitSubdivisionScheme from \"./ImplicitSubdivisionScheme.js\";\nimport ImplicitSubtreeMetadata from \"./ImplicitSubtreeMetadata.js\";\nimport MetadataTable from \"./MetadataTable.js\";\nimport ResourceCache from \"./ResourceCache.js\";\n\n/**\n * An object representing a single subtree in an implicit tileset\n * including availability.\n * <p>\n * Subtrees handle tile metadata, defined in the subtree JSON in either\n * tileMetadata (3D Tiles 1.1) or the <code>3DTILES_metadata</code> extension.\n * Subtrees also handle content metadata and metadata about the subtree itself.\n * </p>\n *\n * This object is normally not instantiated directly, use {@link ImplicitSubtree.fromSubtreeJson}.\n *\n * @see {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_metadata#implicit-tile-properties|Implicit Tile Properties in the 3DTILES_metadata specification}\n * @see ImplicitSubtree.fromSubtreeJson\n *\n * @alias ImplicitSubtree\n * @constructor\n *\n * @param {Resource} resource The resource for this subtree. This is used for fetching external buffers as needed.\n * @param {ImplicitTileset} implicitTileset The implicit tileset. This includes information about the size of subtrees\n * @param {ImplicitTileCoordinates} implicitCoordinates The coordinates of the subtree's root tile.\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction ImplicitSubtree(resource, implicitTileset, implicitCoordinates) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"resource\", resource);\n  Check.typeOf.object(\"implicitTileset\", implicitTileset);\n  Check.typeOf.object(\"implicitCoordinates\", implicitCoordinates);\n  //>>includeEnd('debug');\n\n  this._resource = resource;\n  this._subtreeJson = undefined;\n  this._bufferLoader = undefined;\n  this._tileAvailability = undefined;\n  this._contentAvailabilityBitstreams = [];\n  this._childSubtreeAvailability = undefined;\n  this._implicitCoordinates = implicitCoordinates;\n  this._subtreeLevels = implicitTileset.subtreeLevels;\n  this._subdivisionScheme = implicitTileset.subdivisionScheme;\n  this._branchingFactor = implicitTileset.branchingFactor;\n\n  // properties for metadata\n  this._metadata = undefined;\n  this._tileMetadataTable = undefined;\n  this._tilePropertyTableJson = undefined;\n\n  this._contentMetadataTables = [];\n  this._contentPropertyTableJsons = [];\n\n  // Jump buffers are maps of availability bit index to entity ID\n  this._tileJumpBuffer = undefined;\n  this._contentJumpBuffers = [];\n\n  this._ready = false;\n}\n\nObject.defineProperties(ImplicitSubtree.prototype, {\n  /**\n   * Returns true once all necessary availability buffers\n   * are loaded.\n   *\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * When subtree metadata is present (3D Tiles 1.1), this property stores an {@link ImplicitSubtreeMetadata} instance\n   *\n   * @type {ImplicitSubtreeMetadata}\n   * @readonly\n   * @private\n   */\n  metadata: {\n    get: function () {\n      return this._metadata;\n    },\n  },\n\n  /**\n   * When tile metadata is present (3D Tiles 1.1) or the <code>3DTILES_metadata</code> extension is used,\n   * this property stores a {@link MetadataTable} instance for the tiles in the subtree.\n   *\n   * @type {MetadataTable}\n   * @readonly\n   * @private\n   */\n  tileMetadataTable: {\n    get: function () {\n      return this._tileMetadataTable;\n    },\n  },\n\n  /**\n   * When tile metadata is present (3D Tiles 1.1) or the <code>3DTILES_metadata</code> extension is used,\n   * this property stores the JSON from the extension. This is used by {@link TileMetadata}\n   * to get the extras and extensions for the tiles in the subtree.\n   *\n   * @type {object}\n   * @readonly\n   * @private\n   */\n  tilePropertyTableJson: {\n    get: function () {\n      return this._tilePropertyTableJson;\n    },\n  },\n\n  /**\n   * When content metadata is present (3D Tiles 1.1), this property stores\n   * an array of {@link MetadataTable} instances for the contents in the subtree.\n   *\n   * @type {Array}\n   * @readonly\n   * @private\n   */\n  contentMetadataTables: {\n    get: function () {\n      return this._contentMetadataTables;\n    },\n  },\n\n  /**\n   * When content metadata is present (3D Tiles 1.1), this property\n   * an array of the JSONs from the extension. This is used to get the extras\n   * and extensions for the contents in the subtree.\n   *\n   * @type {Array}\n   * @readonly\n   * @private\n   */\n  contentPropertyTableJsons: {\n    get: function () {\n      return this._contentPropertyTableJsons;\n    },\n  },\n\n  /**\n   * Gets the implicit tile coordinates for the root of the subtree.\n   *\n   * @type {ImplicitTileCoordinates}\n   * @readonly\n   * @private\n   */\n  implicitCoordinates: {\n    get: function () {\n      return this._implicitCoordinates;\n    },\n  },\n});\n\n/**\n * Check if a specific tile is available at an index of the tile availability bitstream\n *\n * @param {number} index The index of the desired tile\n * @returns {boolean} The value of the i-th bit\n * @private\n */\nImplicitSubtree.prototype.tileIsAvailableAtIndex = function (index) {\n  return this._tileAvailability.getBit(index);\n};\n\n/**\n * Check if a specific tile is available at an implicit tile coordinate\n * NOTE: only used for voxels.\n *\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a tile\n * @returns {boolean} The value of the i-th bit\n * @private\n */\nImplicitSubtree.prototype.tileIsAvailableAtCoordinates = function (\n  implicitCoordinates,\n) {\n  const index = this.getTileIndex(implicitCoordinates);\n  return this.tileIsAvailableAtIndex(index);\n};\n\n/**\n * Check if a specific tile's content is available at an index of the content availability bitstream\n *\n * @param {number} index The index of the desired tile\n * @param {number} [contentIndex=0] The index of the desired content when multiple contents are used.\n * @returns {boolean} The value of the i-th bit\n * @private\n */\nImplicitSubtree.prototype.contentIsAvailableAtIndex = function (\n  index,\n  contentIndex,\n) {\n  contentIndex = contentIndex ?? 0;\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    contentIndex < 0 ||\n    contentIndex >= this._contentAvailabilityBitstreams.length\n  ) {\n    throw new DeveloperError(\"contentIndex out of bounds.\");\n  }\n  //>>includeEnd('debug');\n\n  return this._contentAvailabilityBitstreams[contentIndex].getBit(index);\n};\n\n/**\n * Check if a specific tile's content is available at an implicit tile coordinate\n *\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a tile\n * @param {number} [contentIndex=0] The index of the desired content when the <code>3DTILES_multiple_contents</code> extension is used.\n * @returns {boolean} The value of the i-th bit\n * @private\n */\nImplicitSubtree.prototype.contentIsAvailableAtCoordinates = function (\n  implicitCoordinates,\n  contentIndex,\n) {\n  const index = this.getTileIndex(implicitCoordinates);\n  return this.contentIsAvailableAtIndex(index, contentIndex);\n};\n\n/**\n * Check if a child subtree is available at an index of the child subtree availability bitstream\n *\n * @param {number} index The index of the desired child subtree\n * @returns {boolean} The value of the i-th bit\n * @private\n */\nImplicitSubtree.prototype.childSubtreeIsAvailableAtIndex = function (index) {\n  return this._childSubtreeAvailability.getBit(index);\n};\n\n/**\n * Check if a specific child subtree is available at an implicit tile coordinate\n * NOTE: only used for voxels.\n *\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a child subtree\n * @returns {boolean} The value of the i-th bit\n * @private\n */\nImplicitSubtree.prototype.childSubtreeIsAvailableAtCoordinates = function (\n  implicitCoordinates,\n) {\n  const index = this.getChildSubtreeIndex(implicitCoordinates);\n  return this.childSubtreeIsAvailableAtIndex(index);\n};\n\n/**\n * Get the index of the first node at the given level within this subtree.\n * e.g. for a quadtree:\n * <ul>\n * <li>Level 0 starts at index 0</li>\n * <li>Level 1 starts at index 1</li>\n * <li>Level 2 starts at index 5</li>\n * </ul>\n *\n * @param {number} level The 0-indexed level number relative to the root of the subtree\n * @returns {number} The first index at the desired level\n * @private\n */\nImplicitSubtree.prototype.getLevelOffset = function (level) {\n  const branchingFactor = this._branchingFactor;\n  return (Math.pow(branchingFactor, level) - 1) / (branchingFactor - 1);\n};\n\n/**\n * Get the morton index of a tile's parent. This is equivalent to\n * chopping off the last 2 (quadtree) or 3 (octree) bits of the morton\n * index.\n *\n * @param {number} childIndex The morton index of the child tile relative to its parent\n * @returns {number} The index of the child's parent node\n * @private\n */\nImplicitSubtree.prototype.getParentMortonIndex = function (mortonIndex) {\n  let bitsPerLevel = 2;\n  if (this._subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    bitsPerLevel = 3;\n  }\n\n  return mortonIndex >> bitsPerLevel;\n};\n\n/**\n * Parse all relevant information out of the subtree. This fetches any\n * external buffers that are used by the implicit tileset.\n *\n * @param {Resource} resource The resource for this subtree. This is used for fetching external buffers as needed.\n * @param {object} [json] The JSON object for this subtree. If parsing from a binary subtree file, this will be undefined.\n * @param {Uint8Array} [subtreeView] The contents of the subtree binary\n * @param {ImplicitTileset} implicitTileset The implicit tileset this subtree belongs to.\n * @param {ImplicitTileCoordinates} implicitCoordinates The coordinates of the subtree's root tile.\n * @return {Promise<ImplicitSubtree>} The created subtree\n * @private\n *\n * @exception {DeveloperError} One of json and subtreeView must be defined.\n */\nImplicitSubtree.fromSubtreeJson = async function (\n  resource,\n  json,\n  subtreeView,\n  implicitTileset,\n  implicitCoordinates,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"resource\", resource);\n  if (defined(json) === defined(subtreeView)) {\n    throw new DeveloperError(\"One of json and subtreeView must be defined.\");\n  }\n  Check.typeOf.object(\"implicitTileset\", implicitTileset);\n  Check.typeOf.object(\"implicitCoordinates\", implicitCoordinates);\n  //>>includeEnd('debug');\n\n  const subtree = new ImplicitSubtree(\n    resource,\n    implicitTileset,\n    implicitCoordinates,\n  );\n\n  let chunks;\n  if (defined(json)) {\n    chunks = {\n      json: json,\n      binary: undefined,\n    };\n  } else {\n    chunks = parseSubtreeChunks(subtreeView);\n  }\n\n  const subtreeJson = chunks.json;\n  subtree._subtreeJson = subtreeJson;\n\n  let tilePropertyTableJson;\n  if (hasExtension(subtreeJson, \"3DTILES_metadata\")) {\n    tilePropertyTableJson = subtreeJson.extensions[\"3DTILES_metadata\"];\n  } else if (defined(subtreeJson.tileMetadata)) {\n    const propertyTableIndex = subtreeJson.tileMetadata;\n    tilePropertyTableJson = subtreeJson.propertyTables[propertyTableIndex];\n  }\n\n  const contentPropertyTableJsons = [];\n  if (defined(subtreeJson.contentMetadata)) {\n    const length = subtreeJson.contentMetadata.length;\n    for (let i = 0; i < length; i++) {\n      const propertyTableIndex = subtreeJson.contentMetadata[i];\n      contentPropertyTableJsons.push(\n        subtreeJson.propertyTables[propertyTableIndex],\n      );\n    }\n  }\n\n  let metadata;\n  const schema = implicitTileset.metadataSchema;\n  const subtreeMetadata = subtreeJson.subtreeMetadata;\n  if (defined(subtreeMetadata)) {\n    const metadataClass = subtreeMetadata.class;\n    const subtreeMetadataClass = schema.classes[metadataClass];\n    metadata = new ImplicitSubtreeMetadata({\n      subtreeMetadata: subtreeMetadata,\n      class: subtreeMetadataClass,\n    });\n  }\n\n  subtree._metadata = metadata;\n  subtree._tilePropertyTableJson = tilePropertyTableJson;\n  subtree._contentPropertyTableJsons = contentPropertyTableJsons;\n\n  // if no contentAvailability is specified, no tile in the subtree has\n  // content\n  const defaultContentAvailability = {\n    constant: 0,\n  };\n\n  // In 3D Tiles 1.1, content availability is provided in an array in the subtree JSON\n  // regardless of whether or not it contains multiple contents. This differs from previous\n  // schemas, where content availability is either a single object in the subtree JSON or\n  // as an array in the 3DTILES_multiple_contents extension.\n  //\n  // After identifying how availability is stored, put the results in this new array for consistent processing later\n  subtreeJson.contentAvailabilityHeaders = [];\n  if (hasExtension(subtreeJson, \"3DTILES_multiple_contents\")) {\n    subtreeJson.contentAvailabilityHeaders =\n      subtreeJson.extensions[\"3DTILES_multiple_contents\"].contentAvailability;\n  } else if (Array.isArray(subtreeJson.contentAvailability)) {\n    subtreeJson.contentAvailabilityHeaders = subtreeJson.contentAvailability;\n  } else {\n    subtreeJson.contentAvailabilityHeaders.push(\n      subtreeJson.contentAvailability ?? defaultContentAvailability,\n    );\n  }\n\n  const bufferHeaders = preprocessBuffers(subtreeJson.buffers);\n  const bufferViewHeaders = preprocessBufferViews(\n    subtreeJson.bufferViews,\n    bufferHeaders,\n  );\n\n  // Buffers and buffer views are inactive until explicitly marked active.\n  // This way we can avoid fetching buffers that will not be used.\n  markActiveBufferViews(subtreeJson, bufferViewHeaders);\n  if (defined(tilePropertyTableJson)) {\n    markActiveMetadataBufferViews(tilePropertyTableJson, bufferViewHeaders);\n  }\n\n  for (let i = 0; i < contentPropertyTableJsons.length; i++) {\n    const contentPropertyTableJson = contentPropertyTableJsons[i];\n    markActiveMetadataBufferViews(contentPropertyTableJson, bufferViewHeaders);\n  }\n\n  const buffersU8 = await requestActiveBuffers(\n    subtree,\n    bufferHeaders,\n    chunks.binary,\n  );\n  const bufferViewsU8 = parseActiveBufferViews(bufferViewHeaders, buffersU8);\n  parseAvailability(subtree, subtreeJson, implicitTileset, bufferViewsU8);\n\n  if (defined(tilePropertyTableJson)) {\n    parseTileMetadataTable(subtree, implicitTileset, bufferViewsU8);\n    makeTileJumpBuffer(subtree);\n  }\n\n  parseContentMetadataTables(subtree, implicitTileset, bufferViewsU8);\n  makeContentJumpBuffers(subtree);\n\n  subtree._ready = true;\n  return subtree;\n};\n\n/**\n * A helper object for storing the two parts of the subtree binary\n *\n * @typedef {object} SubtreeChunks\n * @property {object} json The json chunk of the subtree\n * @property {Uint8Array} binary The binary chunk of the subtree. This represents the internal buffer.\n * @private\n */\n\n/**\n * Given the binary contents of a subtree, split into JSON and binary chunks\n *\n * @param {Uint8Array} subtreeView The subtree binary\n * @returns {SubtreeChunks} An object containing the JSON and binary chunks.\n * @private\n */\nfunction parseSubtreeChunks(subtreeView) {\n  // Parse the header\n  const littleEndian = true;\n  const subtreeReader = new DataView(\n    subtreeView.buffer,\n    subtreeView.byteOffset,\n  );\n  // Skip to the chunk lengths\n  let byteOffset = 8;\n\n  // Read the bottom 32 bits of the 64-bit byte length. This is ok for now because:\n  // 1) not all browsers have native 64-bit operations\n  // 2) the data is well under 4GB\n  const jsonByteLength = subtreeReader.getUint32(byteOffset, littleEndian);\n  byteOffset += 8;\n  const binaryByteLength = subtreeReader.getUint32(byteOffset, littleEndian);\n  byteOffset += 8;\n\n  const subtreeJson = getJsonFromTypedArray(\n    subtreeView,\n    byteOffset,\n    jsonByteLength,\n  );\n  byteOffset += jsonByteLength;\n  const subtreeBinary = subtreeView.subarray(\n    byteOffset,\n    byteOffset + binaryByteLength,\n  );\n\n  return {\n    json: subtreeJson,\n    binary: subtreeBinary,\n  };\n}\n\n/**\n * A buffer header is the JSON header from the subtree JSON chunk plus\n * a couple extra boolean flags for easy reference.\n *\n * Buffers are assumed inactive until explicitly marked active. This is used\n * to avoid fetching unneeded buffers.\n *\n * @typedef {object} BufferHeader\n * @property {boolean} isExternal True if this is an external buffer\n * @property {boolean} isActive Whether this buffer is currently used.\n * @property {string} [uri] The URI of the buffer (external buffers only)\n * @property {number} byteLength The byte length of the buffer, including any padding contained within.\n * @private\n */\n\n/**\n * Iterate over the list of buffers from the subtree JSON and add the\n * isExternal and isActive fields for easier parsing later. This modifies\n * the objects in place.\n *\n * @param {Object[]} [bufferHeaders=[]] The JSON from subtreeJson.buffers.\n * @returns {BufferHeader[]} The same array of headers with additional fields.\n * @private\n */\nfunction preprocessBuffers(bufferHeaders) {\n  bufferHeaders = defined(bufferHeaders) ? bufferHeaders : [];\n  for (let i = 0; i < bufferHeaders.length; i++) {\n    const bufferHeader = bufferHeaders[i];\n    bufferHeader.isExternal = defined(bufferHeader.uri);\n    bufferHeader.isActive = false;\n  }\n\n  return bufferHeaders;\n}\n\n/**\n * A buffer header is the JSON header from the subtree JSON chunk plus\n * the isActive flag and a reference to the header for the underlying buffer\n *\n * @typedef {object} BufferViewHeader\n * @property {BufferHeader} bufferHeader A reference to the header for the underlying buffer\n * @property {boolean} isActive Whether this bufferView is currently used.\n * @property {number} buffer The index of the underlying buffer.\n * @property {number} byteOffset The start byte of the bufferView within the buffer.\n * @property {number} byteLength The length of the bufferView. No padding is included in this length.\n * @private\n */\n\n/**\n * Iterate the list of buffer views from the subtree JSON and add the\n * isActive flag. Also save a reference to the bufferHeader\n *\n * @param {Object[]} [bufferViewHeaders=[]] The JSON from subtree.bufferViews\n * @param {BufferHeader[]} bufferHeaders The preprocessed buffer headers\n * @returns {BufferViewHeader[]} The same array of bufferView headers with additional fields\n * @private\n */\nfunction preprocessBufferViews(bufferViewHeaders, bufferHeaders) {\n  bufferViewHeaders = defined(bufferViewHeaders) ? bufferViewHeaders : [];\n  for (let i = 0; i < bufferViewHeaders.length; i++) {\n    const bufferViewHeader = bufferViewHeaders[i];\n    const bufferHeader = bufferHeaders[bufferViewHeader.buffer];\n    bufferViewHeader.bufferHeader = bufferHeader;\n    bufferViewHeader.isActive = false;\n  }\n  return bufferViewHeaders;\n}\n\n/**\n * Determine which buffer views need to be loaded into memory. This includes:\n *\n * <ul>\n * <li>The tile availability bitstream (if a bitstream is defined)</li>\n * <li>The content availability bitstream(s) (if a bitstream is defined)</li>\n * <li>The child subtree availability bitstream (if a bitstream is defined)</li>\n * </ul>\n *\n * <p>\n * This function modifies the buffer view headers' isActive flags in place.\n * </p>\n *\n * @param {Object[]} subtreeJson The JSON chunk from the subtree\n * @param {BufferViewHeader[]} bufferViewHeaders The preprocessed buffer view headers\n * @private\n */\nfunction markActiveBufferViews(subtreeJson, bufferViewHeaders) {\n  let header;\n  const tileAvailabilityHeader = subtreeJson.tileAvailability;\n\n  // Check for bitstream first, which is part of the current schema.\n  // bufferView is the name of the bitstream from an older schema.\n  if (defined(tileAvailabilityHeader.bitstream)) {\n    header = bufferViewHeaders[tileAvailabilityHeader.bitstream];\n  } else if (defined(tileAvailabilityHeader.bufferView)) {\n    header = bufferViewHeaders[tileAvailabilityHeader.bufferView];\n  }\n\n  if (defined(header)) {\n    header.isActive = true;\n    header.bufferHeader.isActive = true;\n  }\n\n  const contentAvailabilityHeaders = subtreeJson.contentAvailabilityHeaders;\n  for (let i = 0; i < contentAvailabilityHeaders.length; i++) {\n    header = undefined;\n    if (defined(contentAvailabilityHeaders[i].bitstream)) {\n      header = bufferViewHeaders[contentAvailabilityHeaders[i].bitstream];\n    } else if (defined(contentAvailabilityHeaders[i].bufferView)) {\n      header = bufferViewHeaders[contentAvailabilityHeaders[i].bufferView];\n    }\n\n    if (defined(header)) {\n      header.isActive = true;\n      header.bufferHeader.isActive = true;\n    }\n  }\n\n  header = undefined;\n  const childSubtreeAvailabilityHeader = subtreeJson.childSubtreeAvailability;\n  if (defined(childSubtreeAvailabilityHeader.bitstream)) {\n    header = bufferViewHeaders[childSubtreeAvailabilityHeader.bitstream];\n  } else if (defined(childSubtreeAvailabilityHeader.bufferView)) {\n    header = bufferViewHeaders[childSubtreeAvailabilityHeader.bufferView];\n  }\n\n  if (defined(header)) {\n    header.isActive = true;\n    header.bufferHeader.isActive = true;\n  }\n}\n\n/**\n * For handling metadata, look over the tile and content metadata buffers\n * <p>\n * This always loads all of the metadata immediately. Future iterations may\n * allow filtering this to avoid downloading unneeded buffers.\n * </p>\n *\n * @param {object} propertyTableJson The property table JSON for either a tile or some content\n * @param {BufferViewHeader[]} bufferViewHeaders The preprocessed buffer view headers\n * @private\n */\nfunction markActiveMetadataBufferViews(propertyTableJson, bufferViewHeaders) {\n  const properties = propertyTableJson.properties;\n  let header;\n  for (const key in properties) {\n    if (properties.hasOwnProperty(key)) {\n      const metadataHeader = properties[key];\n\n      // An older spec used bufferView\n      const valuesBufferView =\n        metadataHeader.values ?? metadataHeader.bufferView;\n      header = bufferViewHeaders[valuesBufferView];\n      header.isActive = true;\n      header.bufferHeader.isActive = true;\n\n      // An older spec used stringOffsetBufferView\n      const stringOffsetBufferView =\n        metadataHeader.stringOffsets ?? metadataHeader.stringOffsetBufferView;\n      if (defined(stringOffsetBufferView)) {\n        header = bufferViewHeaders[stringOffsetBufferView];\n        header.isActive = true;\n        header.bufferHeader.isActive = true;\n      }\n\n      // an older spec used arrayOffsetBufferView\n      const arrayOffsetBufferView =\n        metadataHeader.arrayOffsets ?? metadataHeader.arrayOffsetBufferView;\n      if (defined(arrayOffsetBufferView)) {\n        header = bufferViewHeaders[arrayOffsetBufferView];\n        header.isActive = true;\n        header.bufferHeader.isActive = true;\n      }\n    }\n  }\n}\n\n/**\n * Go through the list of buffers and gather all the active ones into a\n * a dictionary. Since external buffers are allowed, this sometimes involves\n * fetching separate binary files. Consequently, this method returns a promise.\n * <p>\n * The results are put into a dictionary object. The keys are indices of\n * buffers, and the values are Uint8Arrays of the contents. Only buffers\n * marked with the isActive flag are fetched.\n * </p>\n * <p>\n * The internal buffer (the subtree's binary chunk) is also stored in this\n * dictionary if it is marked active.\n * </p>\n * @param {ImplicitSubtree} subtree The subtree\n * @param {BufferHeader[]} bufferHeaders The preprocessed buffer headers\n * @param {Uint8Array} internalBuffer The binary chunk of the subtree file\n * @returns {Promise<object>} A promise resolving to the dictionary of active buffers\n * @private\n */\nfunction requestActiveBuffers(subtree, bufferHeaders, internalBuffer) {\n  const promises = [];\n  for (let i = 0; i < bufferHeaders.length; i++) {\n    const bufferHeader = bufferHeaders[i];\n    if (!bufferHeader.isActive) {\n      promises.push(Promise.resolve(undefined));\n    } else if (bufferHeader.isExternal) {\n      const promise = requestExternalBuffer(subtree, bufferHeader);\n      promises.push(promise);\n    } else {\n      promises.push(Promise.resolve(internalBuffer));\n    }\n  }\n  return Promise.all(promises).then(function (bufferResults) {\n    const buffersU8 = {};\n    for (let i = 0; i < bufferResults.length; i++) {\n      const result = bufferResults[i];\n      if (defined(result)) {\n        buffersU8[i] = result;\n      }\n    }\n    return buffersU8;\n  });\n}\n\nasync function requestExternalBuffer(subtree, bufferHeader) {\n  const baseResource = subtree._resource;\n  const bufferResource = baseResource.getDerivedResource({\n    url: bufferHeader.uri,\n  });\n\n  const bufferLoader = ResourceCache.getExternalBufferLoader({\n    resource: bufferResource,\n  });\n  subtree._bufferLoader = bufferLoader;\n\n  try {\n    await bufferLoader.load();\n  } catch (error) {\n    if (bufferLoader.isDestroyed()) {\n      return;\n    }\n\n    throw error;\n  }\n\n  return bufferLoader.typedArray;\n}\n\n/**\n * Go through the list of buffer views, and if they are marked as active,\n * extract a subarray from one of the active buffers.\n *\n * @param {BufferViewHeader[]} bufferViewHeaders\n * @param {object} buffersU8 A dictionary of buffer index to a Uint8Array of its contents.\n * @returns {object} A dictionary of buffer view index to a Uint8Array of its contents.\n * @private\n */\nfunction parseActiveBufferViews(bufferViewHeaders, buffersU8) {\n  const bufferViewsU8 = {};\n  for (let i = 0; i < bufferViewHeaders.length; i++) {\n    const bufferViewHeader = bufferViewHeaders[i];\n\n    if (!bufferViewHeader.isActive) {\n      continue;\n    }\n\n    const start = bufferViewHeader.byteOffset;\n    const end = start + bufferViewHeader.byteLength;\n    const buffer = buffersU8[bufferViewHeader.buffer];\n    const bufferView = buffer.subarray(start, end);\n    bufferViewsU8[i] = bufferView;\n  }\n  return bufferViewsU8;\n}\n\n/**\n * Parse the three availability bitstreams and store them in the subtree\n *\n * @param {ImplicitSubtree} subtree The subtree to modify\n * @param {object} subtreeJson The subtree JSON\n * @param {ImplicitTileset} implicitTileset The implicit tileset this subtree belongs to\n * @param {object} bufferViewsU8 A dictionary of buffer view index to a Uint8Array of its contents.\n * @private\n */\nfunction parseAvailability(\n  subtree,\n  subtreeJson,\n  implicitTileset,\n  bufferViewsU8,\n) {\n  const branchingFactor = implicitTileset.branchingFactor;\n  const subtreeLevels = implicitTileset.subtreeLevels;\n  const tileAvailabilityBits =\n    (Math.pow(branchingFactor, subtreeLevels) - 1) / (branchingFactor - 1);\n  const childSubtreeBits = Math.pow(branchingFactor, subtreeLevels);\n\n  // availableCount is only needed for the metadata jump buffer, which\n  // corresponds to the tile availability bitstream.\n  const hasMetadataExtension = hasExtension(subtreeJson, \"3DTILES_metadata\");\n  const hasTileMetadata = defined(subtree._tilePropertyTableJson);\n  let computeAvailableCountEnabled = hasMetadataExtension || hasTileMetadata;\n\n  subtree._tileAvailability = parseAvailabilityBitstream(\n    subtreeJson.tileAvailability,\n    bufferViewsU8,\n    tileAvailabilityBits,\n    computeAvailableCountEnabled,\n  );\n\n  const hasContentMetadata = subtree._contentPropertyTableJsons.length > 0;\n  computeAvailableCountEnabled =\n    computeAvailableCountEnabled || hasContentMetadata;\n\n  for (let i = 0; i < subtreeJson.contentAvailabilityHeaders.length; i++) {\n    const bitstream = parseAvailabilityBitstream(\n      subtreeJson.contentAvailabilityHeaders[i],\n      bufferViewsU8,\n      // content availability has the same length as tile availability.\n      tileAvailabilityBits,\n      computeAvailableCountEnabled,\n    );\n    subtree._contentAvailabilityBitstreams.push(bitstream);\n  }\n\n  subtree._childSubtreeAvailability = parseAvailabilityBitstream(\n    subtreeJson.childSubtreeAvailability,\n    bufferViewsU8,\n    childSubtreeBits,\n  );\n}\n\n/**\n * Given the JSON describing an availability bitstream, turn it into an\n * in-memory representation using an {@link ImplicitAvailabilityBitstream}\n * object. This handles both constants and bitstreams from a bufferView.\n *\n * @param {object} availabilityJson A JSON object representing the availability\n * @param {object} bufferViewsU8 A dictionary of bufferView index to its Uint8Array contents.\n * @param {number} lengthBits The length of the availability bitstream in bits\n * @param {boolean} [computeAvailableCountEnabled] If true and availabilityJson.availableCount is undefined, the availableCount will be computed.\n * @returns {ImplicitAvailabilityBitstream} The parsed bitstream object\n * @private\n */\nfunction parseAvailabilityBitstream(\n  availabilityJson,\n  bufferViewsU8,\n  lengthBits,\n  computeAvailableCountEnabled,\n) {\n  if (defined(availabilityJson.constant)) {\n    return new ImplicitAvailabilityBitstream({\n      constant: Boolean(availabilityJson.constant),\n      lengthBits: lengthBits,\n      availableCount: availabilityJson.availableCount,\n    });\n  }\n\n  let bufferView;\n\n  // Check for bitstream first, which is part of the current schema.\n  // bufferView is the name of the bitstream from an older schema.\n  if (defined(availabilityJson.bitstream)) {\n    bufferView = bufferViewsU8[availabilityJson.bitstream];\n  } else if (defined(availabilityJson.bufferView)) {\n    bufferView = bufferViewsU8[availabilityJson.bufferView];\n  }\n\n  return new ImplicitAvailabilityBitstream({\n    bitstream: bufferView,\n    lengthBits: lengthBits,\n    availableCount: availabilityJson.availableCount,\n    computeAvailableCountEnabled: computeAvailableCountEnabled,\n  });\n}\n\n/**\n * Parse the metadata table for the tile metadata, storing a {@link MetadataTable}\n * in the subtree.\n *\n * @param {ImplicitSubtree} subtree The subtree\n * @param {ImplicitTileset} implicitTileset The implicit tileset this subtree belongs to.\n * @param {object} bufferViewsU8 A dictionary of bufferView index to its Uint8Array contents.\n * @private\n */\nfunction parseTileMetadataTable(subtree, implicitTileset, bufferViewsU8) {\n  const tilePropertyTableJson = subtree._tilePropertyTableJson;\n  const tileCount = subtree._tileAvailability.availableCount;\n  const metadataSchema = implicitTileset.metadataSchema;\n\n  const tileMetadataClassName = tilePropertyTableJson.class;\n  const tileMetadataClass = metadataSchema.classes[tileMetadataClassName];\n\n  subtree._tileMetadataTable = new MetadataTable({\n    class: tileMetadataClass,\n    count: tileCount,\n    properties: tilePropertyTableJson.properties,\n    bufferViews: bufferViewsU8,\n  });\n}\n\n/**\n * Parse the metadata tables for the content metadata, storing an array of\n * {@link MetadataTable}s in the subtree.\n *\n * @param {ImplicitSubtree} subtree The subtree\n * @param {ImplicitTileset} implicitTileset The implicit tileset this subtree belongs to.\n * @param {object} bufferViewsU8 A dictionary of bufferView index to its Uint8Array contents.\n * @private\n */\nfunction parseContentMetadataTables(subtree, implicitTileset, bufferViewsU8) {\n  const contentPropertyTableJsons = subtree._contentPropertyTableJsons;\n  const contentAvailabilityBitstreams = subtree._contentAvailabilityBitstreams;\n  const metadataSchema = implicitTileset.metadataSchema;\n\n  const contentMetadataTables = subtree._contentMetadataTables;\n  for (let i = 0; i < contentPropertyTableJsons.length; i++) {\n    const contentPropertyTableJson = contentPropertyTableJsons[i];\n    const contentAvailabilityBitsteam = contentAvailabilityBitstreams[i];\n\n    const contentCount = contentAvailabilityBitsteam.availableCount;\n    const contentMetadataClassName = contentPropertyTableJson.class;\n    const contentMetadataClass =\n      metadataSchema.classes[contentMetadataClassName];\n\n    const metadataTable = new MetadataTable({\n      class: contentMetadataClass,\n      count: contentCount,\n      properties: contentPropertyTableJson.properties,\n      bufferViews: bufferViewsU8,\n    });\n\n    contentMetadataTables.push(metadataTable);\n  }\n}\n\n/**\n * Make a jump buffer, i.e. a map of a bit index to the metadata entity ID.\n * <p>\n * For unavailable tiles and content, the jump buffer entries will be uninitialized.\n * Use the tile and content availability to determine whether a jump buffer value is valid.\n * </p>\n *\n * @param {ImplicitAvailabilityBitstream} availability The availability bitstream to create the jump buffer from.\n * @returns {Array} The resulting jump buffer.\n * @private\n */\nfunction makeJumpBuffer(availability) {\n  let entityId = 0;\n  const bufferLength = availability.lengthBits;\n  const availableCount = availability.availableCount;\n\n  let jumpBuffer;\n  if (availableCount < 256) {\n    jumpBuffer = new Uint8Array(bufferLength);\n  } else if (availableCount < 65536) {\n    jumpBuffer = new Uint16Array(bufferLength);\n  } else {\n    jumpBuffer = new Uint32Array(bufferLength);\n  }\n\n  for (let i = 0; i < availability.lengthBits; i++) {\n    if (availability.getBit(i)) {\n      jumpBuffer[i] = entityId;\n      entityId++;\n    }\n  }\n\n  return jumpBuffer;\n}\n\n/**\n * Make the jump buffer, i.e. a map of a bit index to the metadata entity ID,\n * for the content metadata. This is stored in the subtree.\n *\n * @param {ImplicitSubtree} subtree The subtree\n * @private\n */\nfunction makeTileJumpBuffer(subtree) {\n  const tileJumpBuffer = makeJumpBuffer(subtree._tileAvailability);\n  subtree._tileJumpBuffer = tileJumpBuffer;\n}\n\n/**\n * Make the jump buffers, i.e. maps of bit indices to the metadata entity IDs,\n * for the content metadata. This is stored in the subtree.\n *\n * @param {ImplicitSubtree} subtree The subtree\n * @private\n */\nfunction makeContentJumpBuffers(subtree) {\n  const contentJumpBuffers = subtree._contentJumpBuffers;\n  const contentAvailabilityBitstreams = subtree._contentAvailabilityBitstreams;\n  for (let i = 0; i < contentAvailabilityBitstreams.length; i++) {\n    const contentAvailability = contentAvailabilityBitstreams[i];\n    const contentJumpBuffer = makeJumpBuffer(contentAvailability);\n    contentJumpBuffers.push(contentJumpBuffer);\n  }\n}\n\n/**\n * Given the implicit tiling coordinates for a tile, get the index within the\n * subtree's tile availability bitstream.\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a tile\n * @return {number} The tile's index within the subtree.\n * @private\n */\nImplicitSubtree.prototype.getTileIndex = function (implicitCoordinates) {\n  const localLevel =\n    implicitCoordinates.level - this._implicitCoordinates.level;\n  if (localLevel < 0 || this._subtreeLevels <= localLevel) {\n    throw new RuntimeError(\"level is out of bounds for this subtree\");\n  }\n\n  const subtreeCoordinates = implicitCoordinates.getSubtreeCoordinates();\n  const offsetCoordinates =\n    subtreeCoordinates.getOffsetCoordinates(implicitCoordinates);\n  const index = offsetCoordinates.tileIndex;\n  return index;\n};\n\n/**\n * Given the implicit tiling coordinates for a child subtree, get the index within the\n * subtree's child subtree availability bitstream.\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a child subtree\n * @return {number} The child subtree's index within the subtree's child subtree availability bitstream.\n * @private\n */\nImplicitSubtree.prototype.getChildSubtreeIndex = function (\n  implicitCoordinates,\n) {\n  const localLevel =\n    implicitCoordinates.level - this._implicitCoordinates.level;\n  if (localLevel !== this._implicitCoordinates.subtreeLevels) {\n    throw new RuntimeError(\"level is out of bounds for this subtree\");\n  }\n\n  // Call getParentSubtreeCoordinates instead of getSubtreeCoordinates because the\n  // child subtree is by definition the root of its own subtree, so we need to find\n  // the parent subtree.\n  const parentSubtreeCoordinates =\n    implicitCoordinates.getParentSubtreeCoordinates();\n  const offsetCoordinates =\n    parentSubtreeCoordinates.getOffsetCoordinates(implicitCoordinates);\n  const index = offsetCoordinates.mortonIndex;\n  return index;\n};\n\n/**\n * Get the entity ID for a tile within this subtree.\n * @param {ImplicitSubtree} subtree The subtree\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a tile\n * @return {number} The entity ID for this tile for accessing tile metadata, or <code>undefined</code> if not applicable.\n *\n * @private\n */\nfunction getTileEntityId(subtree, implicitCoordinates) {\n  if (!defined(subtree._tileMetadataTable)) {\n    return undefined;\n  }\n\n  const tileIndex = subtree.getTileIndex(implicitCoordinates);\n  if (subtree._tileAvailability.getBit(tileIndex)) {\n    return subtree._tileJumpBuffer[tileIndex];\n  }\n\n  return undefined;\n}\n\n/**\n * Get the entity ID for a content within this subtree.\n * @param {ImplicitSubtree} subtree The subtree\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a content\n * @param {number} contentIndex The content index, for distinguishing between multiple contents.\n * @return {number} The entity ID for this content for accessing content metadata, or <code>undefined</code> if not applicable.\n *\n * @private\n */\nfunction getContentEntityId(subtree, implicitCoordinates, contentIndex) {\n  const metadataTables = subtree._contentMetadataTables;\n  if (!defined(metadataTables)) {\n    return undefined;\n  }\n\n  const metadataTable = metadataTables[contentIndex];\n  if (!defined(metadataTable)) {\n    return undefined;\n  }\n\n  const availability = subtree._contentAvailabilityBitstreams[contentIndex];\n  const tileIndex = subtree.getTileIndex(implicitCoordinates);\n  if (availability.getBit(tileIndex)) {\n    const contentJumpBuffer = subtree._contentJumpBuffers[contentIndex];\n    return contentJumpBuffer[tileIndex];\n  }\n\n  return undefined;\n}\n\n/**\n * Create and return a metadata table view for a tile within this subtree.\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a tile\n * @return {ImplicitMetadataView} The metadata view for this tile, or <code>undefined</code> if not applicable.\n *\n * @private\n */\nImplicitSubtree.prototype.getTileMetadataView = function (implicitCoordinates) {\n  const entityId = getTileEntityId(this, implicitCoordinates);\n  if (!defined(entityId)) {\n    return undefined;\n  }\n\n  const metadataTable = this._tileMetadataTable;\n  return new ImplicitMetadataView({\n    class: metadataTable.class,\n    metadataTable: metadataTable,\n    entityId: entityId,\n    propertyTableJson: this._tilePropertyTableJson,\n  });\n};\n\n/**\n * Create and return a metadata table view for a content within this subtree.\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a content\n * @param {number} contentIndex The index of the content used to distinguish between multiple contents\n * @return {ImplicitMetadataView} The metadata view for this content, or <code>undefined</code> if not applicable.\n *\n * @private\n */\nImplicitSubtree.prototype.getContentMetadataView = function (\n  implicitCoordinates,\n  contentIndex,\n) {\n  const entityId = getContentEntityId(this, implicitCoordinates, contentIndex);\n  if (!defined(entityId)) {\n    return undefined;\n  }\n\n  const metadataTable = this._contentMetadataTables[contentIndex];\n  const propertyTableJson = this._contentPropertyTableJsons[contentIndex];\n  return new ImplicitMetadataView({\n    class: metadataTable.class,\n    metadataTable: metadataTable,\n    entityId: entityId,\n    contentIndex: contentIndex,\n    propertyTableJson: propertyTableJson,\n  });\n};\n\n/**\n * @private\n */\nImplicitSubtree.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * @private\n */\nImplicitSubtree.prototype.destroy = function () {\n  if (defined(this._bufferLoader)) {\n    ResourceCache.unload(this._bufferLoader);\n  }\n\n  return destroyObject(this);\n};\n\nexport default ImplicitSubtree;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}