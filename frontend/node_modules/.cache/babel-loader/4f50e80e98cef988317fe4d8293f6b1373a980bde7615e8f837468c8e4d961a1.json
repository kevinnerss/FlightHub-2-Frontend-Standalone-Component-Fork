{"ast":null,"code":"import addToArray from \"./addToArray.js\";\nimport ForEach from \"./ForEach.js\";\nimport getAccessorByteStride from \"./getAccessorByteStride.js\";\nimport defined from \"../../Core/defined.js\";\nimport WebGLConstants from \"../../Core/WebGLConstants.js\";\n\n/**\n * Adds default glTF values if they don't exist.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @returns {object} The modified glTF.\n *\n * @private\n */\nfunction addDefaults(gltf) {\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView)) {\n      accessor.byteOffset = accessor.byteOffset ?? 0;\n    }\n  });\n  ForEach.bufferView(gltf, function (bufferView) {\n    if (defined(bufferView.buffer)) {\n      bufferView.byteOffset = bufferView.byteOffset ?? 0;\n    }\n  });\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      primitive.mode = primitive.mode ?? WebGLConstants.TRIANGLES;\n      if (!defined(primitive.material)) {\n        if (!defined(gltf.materials)) {\n          gltf.materials = [];\n        }\n        const defaultMaterial = {\n          name: \"default\"\n        };\n        primitive.material = addToArray(gltf.materials, defaultMaterial);\n      }\n    });\n  });\n  ForEach.accessorContainingVertexAttributeData(gltf, function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    const bufferViewId = accessor.bufferView;\n    accessor.normalized = accessor.normalized ?? false;\n    if (defined(bufferViewId)) {\n      const bufferView = gltf.bufferViews[bufferViewId];\n      bufferView.byteStride = getAccessorByteStride(gltf, accessor);\n      bufferView.target = WebGLConstants.ARRAY_BUFFER;\n    }\n  });\n  ForEach.accessorContainingIndexData(gltf, function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    const bufferViewId = accessor.bufferView;\n    if (defined(bufferViewId)) {\n      const bufferView = gltf.bufferViews[bufferViewId];\n      bufferView.target = WebGLConstants.ELEMENT_ARRAY_BUFFER;\n    }\n  });\n  ForEach.material(gltf, function (material) {\n    const extensions = material.extensions ?? {};\n    const materialsCommon = extensions.KHR_materials_common;\n    if (defined(materialsCommon)) {\n      const technique = materialsCommon.technique;\n      const values = defined(materialsCommon.values) ? materialsCommon.values : {};\n      materialsCommon.values = values;\n      values.ambient = defined(values.ambient) ? values.ambient : [0.0, 0.0, 0.0, 1.0];\n      values.emission = defined(values.emission) ? values.emission : [0.0, 0.0, 0.0, 1.0];\n      values.transparency = values.transparency ?? 1.0;\n      if (technique !== \"CONSTANT\") {\n        values.diffuse = defined(values.diffuse) ? values.diffuse : [0.0, 0.0, 0.0, 1.0];\n        if (technique !== \"LAMBERT\") {\n          values.specular = defined(values.specular) ? values.specular : [0.0, 0.0, 0.0, 1.0];\n          values.shininess = values.shininess ?? 0.0;\n        }\n      }\n\n      // These actually exist on the extension object, not the values object despite what's shown in the spec\n      materialsCommon.transparent = materialsCommon.transparent ?? false;\n      materialsCommon.doubleSided = materialsCommon.doubleSided ?? false;\n      return;\n    }\n    material.emissiveFactor = material.emissiveFactor ?? [0.0, 0.0, 0.0];\n    material.alphaMode = material.alphaMode ?? \"OPAQUE\";\n    material.doubleSided = material.doubleSided ?? false;\n    if (material.alphaMode === \"MASK\") {\n      material.alphaCutoff = material.alphaCutoff ?? 0.5;\n    }\n    const techniquesExtension = extensions.KHR_techniques_webgl;\n    if (defined(techniquesExtension)) {\n      ForEach.materialValue(material, function (materialValue) {\n        // Check if material value is a TextureInfo object\n        if (defined(materialValue.index)) {\n          addTextureDefaults(materialValue);\n        }\n      });\n    }\n    addTextureDefaults(material.emissiveTexture);\n    addTextureDefaults(material.normalTexture);\n    addTextureDefaults(material.occlusionTexture);\n    const pbrMetallicRoughness = material.pbrMetallicRoughness;\n    if (defined(pbrMetallicRoughness)) {\n      pbrMetallicRoughness.baseColorFactor = pbrMetallicRoughness.baseColorFactor ?? [1.0, 1.0, 1.0, 1.0];\n      pbrMetallicRoughness.metallicFactor = pbrMetallicRoughness.metallicFactor ?? 1.0;\n      pbrMetallicRoughness.roughnessFactor = pbrMetallicRoughness.roughnessFactor ?? 1.0;\n      addTextureDefaults(pbrMetallicRoughness.baseColorTexture);\n      addTextureDefaults(pbrMetallicRoughness.metallicRoughnessTexture);\n    }\n    const pbrSpecularGlossiness = extensions.KHR_materials_pbrSpecularGlossiness;\n    if (defined(pbrSpecularGlossiness)) {\n      pbrSpecularGlossiness.diffuseFactor = pbrSpecularGlossiness.diffuseFactor ?? [1.0, 1.0, 1.0, 1.0];\n      pbrSpecularGlossiness.specularFactor = pbrSpecularGlossiness.specularFactor ?? [1.0, 1.0, 1.0];\n      pbrSpecularGlossiness.glossinessFactor = pbrSpecularGlossiness.glossinessFactor ?? 1.0;\n      addTextureDefaults(pbrSpecularGlossiness.specularGlossinessTexture);\n    }\n  });\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      sampler.interpolation = sampler.interpolation ?? \"LINEAR\";\n    });\n  });\n  const animatedNodes = getAnimatedNodes(gltf);\n  ForEach.node(gltf, function (node, id) {\n    const animated = defined(animatedNodes[id]);\n    if (animated || defined(node.translation) || defined(node.rotation) || defined(node.scale)) {\n      node.translation = node.translation ?? [0.0, 0.0, 0.0];\n      node.rotation = node.rotation ?? [0.0, 0.0, 0.0, 1.0];\n      node.scale = node.scale ?? [1.0, 1.0, 1.0];\n    } else {\n      node.matrix = node.matrix ?? [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0];\n    }\n  });\n  ForEach.sampler(gltf, function (sampler) {\n    sampler.wrapS = sampler.wrapS ?? WebGLConstants.REPEAT;\n    sampler.wrapT = sampler.wrapT ?? WebGLConstants.REPEAT;\n  });\n  if (defined(gltf.scenes) && !defined(gltf.scene)) {\n    gltf.scene = 0;\n  }\n  return gltf;\n}\nfunction getAnimatedNodes(gltf) {\n  const nodes = {};\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationChannel(animation, function (channel) {\n      const target = channel.target;\n      const nodeId = target.node;\n      const path = target.path;\n      // Ignore animations that target 'weights'\n      if (path === \"translation\" || path === \"rotation\" || path === \"scale\") {\n        nodes[nodeId] = true;\n      }\n    });\n  });\n  return nodes;\n}\nfunction addTextureDefaults(texture) {\n  if (defined(texture)) {\n    texture.texCoord = texture.texCoord ?? 0;\n  }\n}\nexport default addDefaults;","map":{"version":3,"names":["addToArray","ForEach","getAccessorByteStride","defined","WebGLConstants","addDefaults","gltf","accessor","bufferView","byteOffset","buffer","mesh","meshPrimitive","primitive","mode","TRIANGLES","material","materials","defaultMaterial","name","accessorContainingVertexAttributeData","accessorId","accessors","bufferViewId","normalized","bufferViews","byteStride","target","ARRAY_BUFFER","accessorContainingIndexData","ELEMENT_ARRAY_BUFFER","extensions","materialsCommon","KHR_materials_common","technique","values","ambient","emission","transparency","diffuse","specular","shininess","transparent","doubleSided","emissiveFactor","alphaMode","alphaCutoff","techniquesExtension","KHR_techniques_webgl","materialValue","index","addTextureDefaults","emissiveTexture","normalTexture","occlusionTexture","pbrMetallicRoughness","baseColorFactor","metallicFactor","roughnessFactor","baseColorTexture","metallicRoughnessTexture","pbrSpecularGlossiness","KHR_materials_pbrSpecularGlossiness","diffuseFactor","specularFactor","glossinessFactor","specularGlossinessTexture","animation","animationSampler","sampler","interpolation","animatedNodes","getAnimatedNodes","node","id","animated","translation","rotation","scale","matrix","wrapS","REPEAT","wrapT","scenes","scene","nodes","animationChannel","channel","nodeId","path","texture","texCoord"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/GltfPipeline/addDefaults.js"],"sourcesContent":["import addToArray from \"./addToArray.js\";\nimport ForEach from \"./ForEach.js\";\nimport getAccessorByteStride from \"./getAccessorByteStride.js\";\nimport defined from \"../../Core/defined.js\";\nimport WebGLConstants from \"../../Core/WebGLConstants.js\";\n\n/**\n * Adds default glTF values if they don't exist.\n *\n * @param {object} gltf A javascript object containing a glTF asset.\n * @returns {object} The modified glTF.\n *\n * @private\n */\nfunction addDefaults(gltf) {\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView)) {\n      accessor.byteOffset = accessor.byteOffset ?? 0;\n    }\n  });\n\n  ForEach.bufferView(gltf, function (bufferView) {\n    if (defined(bufferView.buffer)) {\n      bufferView.byteOffset = bufferView.byteOffset ?? 0;\n    }\n  });\n\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      primitive.mode = primitive.mode ?? WebGLConstants.TRIANGLES;\n      if (!defined(primitive.material)) {\n        if (!defined(gltf.materials)) {\n          gltf.materials = [];\n        }\n        const defaultMaterial = {\n          name: \"default\",\n        };\n        primitive.material = addToArray(gltf.materials, defaultMaterial);\n      }\n    });\n  });\n\n  ForEach.accessorContainingVertexAttributeData(gltf, function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    const bufferViewId = accessor.bufferView;\n    accessor.normalized = accessor.normalized ?? false;\n    if (defined(bufferViewId)) {\n      const bufferView = gltf.bufferViews[bufferViewId];\n      bufferView.byteStride = getAccessorByteStride(gltf, accessor);\n      bufferView.target = WebGLConstants.ARRAY_BUFFER;\n    }\n  });\n\n  ForEach.accessorContainingIndexData(gltf, function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    const bufferViewId = accessor.bufferView;\n    if (defined(bufferViewId)) {\n      const bufferView = gltf.bufferViews[bufferViewId];\n      bufferView.target = WebGLConstants.ELEMENT_ARRAY_BUFFER;\n    }\n  });\n\n  ForEach.material(gltf, function (material) {\n    const extensions = material.extensions ?? {};\n    const materialsCommon = extensions.KHR_materials_common;\n    if (defined(materialsCommon)) {\n      const technique = materialsCommon.technique;\n      const values = defined(materialsCommon.values)\n        ? materialsCommon.values\n        : {};\n      materialsCommon.values = values;\n\n      values.ambient = defined(values.ambient)\n        ? values.ambient\n        : [0.0, 0.0, 0.0, 1.0];\n      values.emission = defined(values.emission)\n        ? values.emission\n        : [0.0, 0.0, 0.0, 1.0];\n\n      values.transparency = values.transparency ?? 1.0;\n\n      if (technique !== \"CONSTANT\") {\n        values.diffuse = defined(values.diffuse)\n          ? values.diffuse\n          : [0.0, 0.0, 0.0, 1.0];\n        if (technique !== \"LAMBERT\") {\n          values.specular = defined(values.specular)\n            ? values.specular\n            : [0.0, 0.0, 0.0, 1.0];\n          values.shininess = values.shininess ?? 0.0;\n        }\n      }\n\n      // These actually exist on the extension object, not the values object despite what's shown in the spec\n      materialsCommon.transparent = materialsCommon.transparent ?? false;\n      materialsCommon.doubleSided = materialsCommon.doubleSided ?? false;\n\n      return;\n    }\n\n    material.emissiveFactor = material.emissiveFactor ?? [0.0, 0.0, 0.0];\n    material.alphaMode = material.alphaMode ?? \"OPAQUE\";\n    material.doubleSided = material.doubleSided ?? false;\n\n    if (material.alphaMode === \"MASK\") {\n      material.alphaCutoff = material.alphaCutoff ?? 0.5;\n    }\n\n    const techniquesExtension = extensions.KHR_techniques_webgl;\n    if (defined(techniquesExtension)) {\n      ForEach.materialValue(material, function (materialValue) {\n        // Check if material value is a TextureInfo object\n        if (defined(materialValue.index)) {\n          addTextureDefaults(materialValue);\n        }\n      });\n    }\n\n    addTextureDefaults(material.emissiveTexture);\n    addTextureDefaults(material.normalTexture);\n    addTextureDefaults(material.occlusionTexture);\n\n    const pbrMetallicRoughness = material.pbrMetallicRoughness;\n    if (defined(pbrMetallicRoughness)) {\n      pbrMetallicRoughness.baseColorFactor =\n        pbrMetallicRoughness.baseColorFactor ?? [1.0, 1.0, 1.0, 1.0];\n      pbrMetallicRoughness.metallicFactor =\n        pbrMetallicRoughness.metallicFactor ?? 1.0;\n      pbrMetallicRoughness.roughnessFactor =\n        pbrMetallicRoughness.roughnessFactor ?? 1.0;\n      addTextureDefaults(pbrMetallicRoughness.baseColorTexture);\n      addTextureDefaults(pbrMetallicRoughness.metallicRoughnessTexture);\n    }\n\n    const pbrSpecularGlossiness =\n      extensions.KHR_materials_pbrSpecularGlossiness;\n    if (defined(pbrSpecularGlossiness)) {\n      pbrSpecularGlossiness.diffuseFactor =\n        pbrSpecularGlossiness.diffuseFactor ?? [1.0, 1.0, 1.0, 1.0];\n      pbrSpecularGlossiness.specularFactor =\n        pbrSpecularGlossiness.specularFactor ?? [1.0, 1.0, 1.0];\n      pbrSpecularGlossiness.glossinessFactor =\n        pbrSpecularGlossiness.glossinessFactor ?? 1.0;\n      addTextureDefaults(pbrSpecularGlossiness.specularGlossinessTexture);\n    }\n  });\n\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      sampler.interpolation = sampler.interpolation ?? \"LINEAR\";\n    });\n  });\n\n  const animatedNodes = getAnimatedNodes(gltf);\n  ForEach.node(gltf, function (node, id) {\n    const animated = defined(animatedNodes[id]);\n    if (\n      animated ||\n      defined(node.translation) ||\n      defined(node.rotation) ||\n      defined(node.scale)\n    ) {\n      node.translation = node.translation ?? [0.0, 0.0, 0.0];\n      node.rotation = node.rotation ?? [0.0, 0.0, 0.0, 1.0];\n      node.scale = node.scale ?? [1.0, 1.0, 1.0];\n    } else {\n      node.matrix = node.matrix ?? [\n        1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0,\n      ];\n    }\n  });\n\n  ForEach.sampler(gltf, function (sampler) {\n    sampler.wrapS = sampler.wrapS ?? WebGLConstants.REPEAT;\n    sampler.wrapT = sampler.wrapT ?? WebGLConstants.REPEAT;\n  });\n\n  if (defined(gltf.scenes) && !defined(gltf.scene)) {\n    gltf.scene = 0;\n  }\n\n  return gltf;\n}\n\nfunction getAnimatedNodes(gltf) {\n  const nodes = {};\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationChannel(animation, function (channel) {\n      const target = channel.target;\n      const nodeId = target.node;\n      const path = target.path;\n      // Ignore animations that target 'weights'\n      if (path === \"translation\" || path === \"rotation\" || path === \"scale\") {\n        nodes[nodeId] = true;\n      }\n    });\n  });\n  return nodes;\n}\n\nfunction addTextureDefaults(texture) {\n  if (defined(texture)) {\n    texture.texCoord = texture.texCoord ?? 0;\n  }\n}\n\nexport default addDefaults;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}