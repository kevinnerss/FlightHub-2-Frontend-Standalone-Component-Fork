{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Spline from \"./Spline.js\";\n\n/**\n * A spline that uses piecewise linear interpolation to create a curve.\n *\n * @alias LinearSpline\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {number[]|Cartesian3[]} options.points The array of control points.\n *\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n *\n * @example\n * const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * const spline = new Cesium.LinearSpline({\n *     times : times,\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n *\n * const p0 = spline.evaluate(times[0]);\n *\n * @see ConstantSpline\n * @see SteppedSpline\n * @see HermiteSpline\n * @see CatmullRomSpline\n * @see QuaternionSpline\n * @see MorphWeightSpline\n */\nfunction LinearSpline(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const points = options.points;\n  const times = options.times;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times)) {\n    throw new DeveloperError(\"points and times are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\"points.length must be greater than or equal to 2.\");\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  //>>includeEnd('debug');\n\n  this._times = times;\n  this._points = points;\n  this._pointType = Spline.getPointType(points[0]);\n  this._lastTimeIndex = 0;\n}\nObject.defineProperties(LinearSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof LinearSpline.prototype\n   *\n   * @type {number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    }\n  },\n  /**\n   * An array of {@link Cartesian3} control points.\n   *\n   * @memberof LinearSpline.prototype\n   *\n   * @type {number[]|Cartesian3[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    }\n  }\n});\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {number} time The time.\n * @returns {number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nLinearSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, wrapped around to the updated animation.\n */\nLinearSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, clamped to the animation period.\n */\nLinearSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {number} time The time at which to evaluate the curve.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {number|Cartesian3} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nLinearSpline.prototype.evaluate = function (time, result) {\n  const points = this.points;\n  const times = this.times;\n  const i = this._lastTimeIndex = this.findTimeInterval(time, this._lastTimeIndex);\n  const u = (time - times[i]) / (times[i + 1] - times[i]);\n  const PointType = this._pointType;\n  if (PointType === Number) {\n    return (1.0 - u) * points[i] + u * points[i + 1];\n  }\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  return Cartesian3.lerp(points[i], points[i + 1], u, result);\n};\nexport default LinearSpline;","map":{"version":3,"names":["Cartesian3","Frozen","defined","DeveloperError","Spline","LinearSpline","options","EMPTY_OBJECT","points","times","length","_times","_points","_pointType","getPointType","_lastTimeIndex","Object","defineProperties","prototype","get","findTimeInterval","wrapTime","clampTime","evaluate","time","result","i","u","PointType","Number","lerp"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/LinearSpline.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Spline from \"./Spline.js\";\n\n/**\n * A spline that uses piecewise linear interpolation to create a curve.\n *\n * @alias LinearSpline\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {number[]|Cartesian3[]} options.points The array of control points.\n *\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n *\n * @example\n * const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * const spline = new Cesium.LinearSpline({\n *     times : times,\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n *\n * const p0 = spline.evaluate(times[0]);\n *\n * @see ConstantSpline\n * @see SteppedSpline\n * @see HermiteSpline\n * @see CatmullRomSpline\n * @see QuaternionSpline\n * @see MorphWeightSpline\n */\nfunction LinearSpline(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const points = options.points;\n  const times = options.times;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times)) {\n    throw new DeveloperError(\"points and times are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\",\n    );\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  //>>includeEnd('debug');\n\n  this._times = times;\n  this._points = points;\n  this._pointType = Spline.getPointType(points[0]);\n\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(LinearSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof LinearSpline.prototype\n   *\n   * @type {number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n  },\n\n  /**\n   * An array of {@link Cartesian3} control points.\n   *\n   * @memberof LinearSpline.prototype\n   *\n   * @type {number[]|Cartesian3[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    },\n  },\n});\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {number} time The time.\n * @returns {number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nLinearSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, wrapped around to the updated animation.\n */\nLinearSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, clamped to the animation period.\n */\nLinearSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {number} time The time at which to evaluate the curve.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {number|Cartesian3} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nLinearSpline.prototype.evaluate = function (time, result) {\n  const points = this.points;\n  const times = this.times;\n\n  const i = (this._lastTimeIndex = this.findTimeInterval(\n    time,\n    this._lastTimeIndex,\n  ));\n  const u = (time - times[i]) / (times[i + 1] - times[i]);\n\n  const PointType = this._pointType;\n  if (PointType === Number) {\n    return (1.0 - u) * points[i] + u * points[i + 1];\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.lerp(points[i], points[i + 1], u, result);\n};\n\nexport default LinearSpline;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}