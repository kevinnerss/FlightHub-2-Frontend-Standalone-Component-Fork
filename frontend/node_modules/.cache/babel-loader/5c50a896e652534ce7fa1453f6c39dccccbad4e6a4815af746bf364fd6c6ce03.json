{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport MetadataComponentType from \"./MetadataComponentType.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\n\n/**\n * @alias Megatexture\n * @constructor\n *\n * @param {Context} context The context in which to create GPU resources.\n * @param {Cartesian3} dimensions The number of voxels in each dimension of the tile.\n * @param {number} channelCount The number of channels in the metadata.\n * @param {MetadataComponentType} componentType The component type of the metadata.\n * @param {number} [availableTextureMemoryBytes=134217728] An upper limit on the texture memory size in bytes.\n *\n * @private\n */\nfunction Megatexture(context, dimensions, channelCount, componentType, availableTextureMemoryBytes) {\n  const maximumTextureMemoryByteLength = 512 * 1024 * 1024;\n  availableTextureMemoryBytes = Math.min(availableTextureMemoryBytes ?? 128 * 1024 * 1024, maximumTextureMemoryByteLength);\n\n  // TODO there are a lot of texture packing rules, see https://github.com/CesiumGS/cesium/issues/9572\n  // Unsigned short textures not allowed in webgl 1, so treat as float\n  if (componentType === MetadataComponentType.UNSIGNED_SHORT) {\n    componentType = MetadataComponentType.FLOAT32;\n  }\n  if (componentType === MetadataComponentType.FLOAT32 && !context.floatingPointTexture) {\n    throw new RuntimeError(\"Floating point texture not supported\");\n  }\n  const pixelDataType = getPixelDataType(componentType);\n  const pixelFormat = getPixelFormat(channelCount, context.webgl2);\n  const componentTypeByteLength = MetadataComponentType.getSizeInBytes(componentType);\n  const textureDimension = getTextureDimension(availableTextureMemoryBytes, channelCount, componentTypeByteLength);\n  const sliceCountPerRegionX = Math.ceil(Math.sqrt(dimensions.x));\n  const sliceCountPerRegionY = Math.ceil(dimensions.z / sliceCountPerRegionX);\n  const voxelCountPerRegionX = sliceCountPerRegionX * dimensions.x;\n  const voxelCountPerRegionY = sliceCountPerRegionY * dimensions.y;\n  const regionCountPerMegatextureX = Math.floor(textureDimension / voxelCountPerRegionX);\n  const regionCountPerMegatextureY = Math.floor(textureDimension / voxelCountPerRegionY);\n  if (regionCountPerMegatextureX === 0 || regionCountPerMegatextureY === 0) {\n    throw new RuntimeError(\"Tileset is too large to fit into megatexture\");\n  }\n\n  /**\n   * @type {number}\n   * @readonly\n   */\n  this.channelCount = channelCount;\n\n  /**\n   * @type {MetadataComponentType}\n   * @readonly\n   */\n  this.componentType = componentType;\n\n  /**\n   * @type {number}\n   * @readonly\n   */\n  this.textureMemoryByteLength = componentTypeByteLength * channelCount * textureDimension ** 2;\n\n  /**\n   * @type {Cartesian3}\n   * @readonly\n   */\n  this.voxelCountPerTile = Cartesian3.clone(dimensions, new Cartesian3());\n\n  /**\n   * @type {number}\n   * @readonly\n   */\n  this.maximumTileCount = regionCountPerMegatextureX * regionCountPerMegatextureY;\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.regionCountPerMegatexture = new Cartesian2(regionCountPerMegatextureX, regionCountPerMegatextureY);\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.voxelCountPerRegion = new Cartesian2(voxelCountPerRegionX, voxelCountPerRegionY);\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.sliceCountPerRegion = new Cartesian2(sliceCountPerRegionX, sliceCountPerRegionY);\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.voxelSizeUv = new Cartesian2(1.0 / textureDimension, 1.0 / textureDimension);\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.sliceSizeUv = new Cartesian2(dimensions.x / textureDimension, dimensions.y / textureDimension);\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.regionSizeUv = new Cartesian2(voxelCountPerRegionX / textureDimension, voxelCountPerRegionY / textureDimension);\n\n  /**\n   * @type {Texture}\n   * @readonly\n   */\n  this.texture = new Texture({\n    context: context,\n    pixelFormat: pixelFormat,\n    pixelDatatype: pixelDataType,\n    flipY: false,\n    width: textureDimension,\n    height: textureDimension,\n    sampler: new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.LINEAR,\n      magnificationFilter: TextureMagnificationFilter.LINEAR\n    })\n  });\n  const componentDatatype = MetadataComponentType.toComponentDatatype(componentType);\n\n  /**\n   * @type {Array}\n   */\n  this.tileVoxelDataTemp = ComponentDatatype.createTypedArray(componentDatatype, voxelCountPerRegionX * voxelCountPerRegionY * channelCount);\n\n  /**\n   * @type {MegatextureNode[]}\n   * @readonly\n   */\n  this.nodes = new Array(this.maximumTileCount);\n  for (let tileIndex = 0; tileIndex < this.maximumTileCount; tileIndex++) {\n    this.nodes[tileIndex] = new MegatextureNode(tileIndex);\n  }\n  for (let tileIndex = 0; tileIndex < this.maximumTileCount; tileIndex++) {\n    const node = this.nodes[tileIndex];\n    node.previousNode = tileIndex > 0 ? this.nodes[tileIndex - 1] : undefined;\n    node.nextNode = tileIndex < this.maximumTileCount - 1 ? this.nodes[tileIndex + 1] : undefined;\n  }\n\n  /**\n   * @type {MegatextureNode}\n   * @readonly\n   */\n  this.occupiedList = undefined;\n\n  /**\n   * @type {MegatextureNode}\n   * @readonly\n   */\n  this.emptyList = this.nodes[0];\n\n  /**\n   * @type {number}\n   * @readonly\n   */\n  this.occupiedCount = 0;\n}\n\n/**\n * Get the pixel data type to use in a megatexture.\n * TODO support more\n *\n * @param {MetadataComponentType} componentType The component type of the metadata.\n * @returns {PixelDatatype} The pixel datatype to use for a megatexture.\n *\n * @private\n */\nfunction getPixelDataType(componentType) {\n  if (componentType === MetadataComponentType.FLOAT32 || componentType === MetadataComponentType.FLOAT64) {\n    return PixelDatatype.FLOAT;\n  } else if (componentType === MetadataComponentType.UINT8) {\n    return PixelDatatype.UNSIGNED_BYTE;\n  }\n}\n\n/**\n * Get the pixel format to use for a megatexture.\n *\n * @param {number} channelCount The number of channels in the metadata. Must be 1 to 4.\n * @param {boolean} webgl2 true if the context is using webgl2\n * @returns {PixelFormat} The pixel format to use for a megatexture.\n *\n * @private\n */\nfunction getPixelFormat(channelCount, webgl2) {\n  if (channelCount === 1) {\n    return webgl2 ? PixelFormat.RED : PixelFormat.LUMINANCE;\n  } else if (channelCount === 2) {\n    return webgl2 ? PixelFormat.RG : PixelFormat.LUMINANCE_ALPHA;\n  } else if (channelCount === 3) {\n    return PixelFormat.RGB;\n  } else if (channelCount === 4) {\n    return PixelFormat.RGBA;\n  }\n}\n\n/**\n * Compute the largest size of a square texture that will fit in the available memory.\n *\n * @param {number} availableTextureMemoryBytes An upper limit on the texture memory size.\n * @param {number} channelCount The number of metadata channels per texel.\n * @param {number} componentByteLength The byte length of each component of the metadata.\n * @returns {number} The dimension of the square texture to use for the megatexture.\n *\n * @private\n */\nfunction getTextureDimension(availableTextureMemoryBytes, channelCount, componentByteLength) {\n  // Compute how many texels will fit in the available memory\n  const texelCount = Math.floor(availableTextureMemoryBytes / (channelCount * componentByteLength));\n  // Return the largest power of two texture size that will fit in memory\n  return Math.min(ContextLimits.maximumTextureSize, CesiumMath.previousPowerOfTwo(Math.floor(Math.sqrt(texelCount))));\n}\n\n/**\n * @alias MegatextureNode\n * @constructor\n *\n * @param {number} index\n *\n * @private\n */\nfunction MegatextureNode(index) {\n  /**\n   * @type {number}\n   */\n  this.index = index;\n\n  /**\n   * @type {MegatextureNode}\n   */\n  this.nextNode = undefined;\n\n  /**\n   * @type {MegatextureNode}\n   */\n  this.previousNode = undefined;\n}\n\n/**\n * Add an array of tile metadata to the megatexture.\n * @param {Array} data The data to be added.\n * @returns {number} The index of the tile's location in the megatexture.\n */\nMegatexture.prototype.add = function (data) {\n  if (this.isFull()) {\n    throw new DeveloperError(\"Trying to add when there are no empty spots\");\n  }\n\n  // remove head of empty list\n  const node = this.emptyList;\n  this.emptyList = this.emptyList.nextNode;\n  if (defined(this.emptyList)) {\n    this.emptyList.previousNode = undefined;\n  }\n\n  // make head of occupied list\n  node.nextNode = this.occupiedList;\n  if (defined(node.nextNode)) {\n    node.nextNode.previousNode = node;\n  }\n  this.occupiedList = node;\n  const index = node.index;\n  this.writeDataToTexture(index, data);\n  this.occupiedCount++;\n  return index;\n};\n\n/**\n * @param {number} index\n */\nMegatexture.prototype.remove = function (index) {\n  if (index < 0 || index >= this.maximumTileCount) {\n    throw new DeveloperError(\"Megatexture index out of bounds\");\n  }\n\n  // remove from list\n  const node = this.nodes[index];\n  if (defined(node.previousNode)) {\n    node.previousNode.nextNode = node.nextNode;\n  }\n  if (defined(node.nextNode)) {\n    node.nextNode.previousNode = node.previousNode;\n  }\n\n  // make head of empty list\n  node.nextNode = this.emptyList;\n  if (defined(node.nextNode)) {\n    node.nextNode.previousNode = node;\n  }\n  node.previousNode = undefined;\n  this.emptyList = node;\n  this.occupiedCount--;\n};\n\n/**\n * @returns {boolean}\n */\nMegatexture.prototype.isFull = function () {\n  return this.emptyList === undefined;\n};\n\n/**\n * @param {number} tileCount The total number of tiles in the tileset.\n * @param {Cartesian3} dimensions The number of voxels in each dimension of the tile.\n * @param {number} channelCount The number of channels in the metadata.\n * @param {MetadataComponentType} componentType The type of one channel of the metadata.\n * @returns {number}\n */\nMegatexture.getApproximateTextureMemoryByteLength = function (tileCount, dimensions, channelCount, componentType) {\n  // TODO there's a lot of code duplicate with Megatexture constructor\n\n  // Unsigned short textures not allowed in webgl 1, so treat as float\n  if (componentType === MetadataComponentType.UNSIGNED_SHORT) {\n    componentType = MetadataComponentType.FLOAT32;\n  }\n  const datatypeSizeInBytes = MetadataComponentType.getSizeInBytes(componentType);\n  const voxelCountTotal = tileCount * dimensions.x * dimensions.y * dimensions.z;\n  const sliceCountPerRegionX = Math.ceil(Math.sqrt(dimensions.x));\n  const sliceCountPerRegionY = Math.ceil(dimensions.z / sliceCountPerRegionX);\n  const voxelCountPerRegionX = sliceCountPerRegionX * dimensions.x;\n  const voxelCountPerRegionY = sliceCountPerRegionY * dimensions.y;\n\n  // Find the power of two that can fit all tile data, accounting for slices.\n  // There's probably a non-iterative solution for this, but this is good enough for now.\n  let textureDimension = CesiumMath.previousPowerOfTwo(Math.floor(Math.sqrt(voxelCountTotal)));\n  for (;;) {\n    const regionCountX = Math.floor(textureDimension / voxelCountPerRegionX);\n    const regionCountY = Math.floor(textureDimension / voxelCountPerRegionY);\n    const regionCount = regionCountX * regionCountY;\n    if (regionCount >= tileCount) {\n      break;\n    } else {\n      textureDimension *= 2;\n    }\n  }\n  const textureMemoryByteLength = textureDimension * textureDimension * channelCount * datatypeSizeInBytes;\n  return textureMemoryByteLength;\n};\n\n/**\n * Write an array of tile metadata to the megatexture.\n * @param {number} index The index of the tile's location in the megatexture.\n * @param {Float32Array|Uint16Array|Uint8Array} data The data to be written.\n */\nMegatexture.prototype.writeDataToTexture = function (index, data) {\n  // Unsigned short textures not allowed in webgl 1, so treat as float\n  const tileData = data.constructor === Uint16Array ? new Float32Array(data) : data;\n  const {\n    tileVoxelDataTemp,\n    voxelCountPerTile,\n    sliceCountPerRegion,\n    voxelCountPerRegion,\n    channelCount,\n    regionCountPerMegatexture\n  } = this;\n  for (let z = 0; z < voxelCountPerTile.z; z++) {\n    const sliceVoxelOffsetX = z % sliceCountPerRegion.x * voxelCountPerTile.x;\n    const sliceVoxelOffsetY = Math.floor(z / sliceCountPerRegion.x) * voxelCountPerTile.y;\n    for (let y = 0; y < voxelCountPerTile.y; y++) {\n      const readOffset = getReadOffset(voxelCountPerTile, y, z);\n      const writeOffset = (sliceVoxelOffsetY + y) * voxelCountPerRegion.x + sliceVoxelOffsetX;\n      for (let x = 0; x < voxelCountPerTile.x; x++) {\n        const readIndex = readOffset + x;\n        const writeIndex = writeOffset + x;\n        for (let c = 0; c < channelCount; c++) {\n          tileVoxelDataTemp[writeIndex * channelCount + c] = tileData[readIndex * channelCount + c];\n        }\n      }\n    }\n  }\n  const voxelOffsetX = index % regionCountPerMegatexture.x * voxelCountPerRegion.x;\n  const voxelOffsetY = Math.floor(index / regionCountPerMegatexture.x) * voxelCountPerRegion.y;\n  const source = {\n    arrayBufferView: tileVoxelDataTemp,\n    width: voxelCountPerRegion.x,\n    height: voxelCountPerRegion.y\n  };\n  const copyOptions = {\n    source: source,\n    xOffset: voxelOffsetX,\n    yOffset: voxelOffsetY\n  };\n  this.texture.copyFrom(copyOptions);\n};\n\n/**\n * Get the offset into the data array for a given row of contiguous voxel data.\n *\n * @param {Cartesian3} dimensions The number of voxels in each dimension of the tile.\n * @param {number} y The y index of the voxel row\n * @param {number} z The z index of the voxel row\n * @returns {number} The offset into the data array\n * @private\n */\nfunction getReadOffset(dimensions, y, z) {\n  const voxelsPerInputSlice = dimensions.y * dimensions.x;\n  const sliceIndex = z;\n  const rowIndex = y;\n  return sliceIndex * voxelsPerInputSlice + rowIndex * dimensions.x;\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Megatexture#destroy\n */\nMegatexture.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see Megatexture#isDestroyed\n *\n * @example\n * megatexture = megatexture && megatexture.destroy();\n */\nMegatexture.prototype.destroy = function () {\n  this.texture = this.texture && this.texture.destroy();\n  return destroyObject(this);\n};\nexport default Megatexture;","map":{"version":3,"names":["Cartesian2","Cartesian3","ComponentDatatype","ContextLimits","defined","destroyObject","DeveloperError","CesiumMath","MetadataComponentType","PixelDatatype","PixelFormat","RuntimeError","Sampler","Texture","TextureMagnificationFilter","TextureMinificationFilter","TextureWrap","Megatexture","context","dimensions","channelCount","componentType","availableTextureMemoryBytes","maximumTextureMemoryByteLength","Math","min","UNSIGNED_SHORT","FLOAT32","floatingPointTexture","pixelDataType","getPixelDataType","pixelFormat","getPixelFormat","webgl2","componentTypeByteLength","getSizeInBytes","textureDimension","getTextureDimension","sliceCountPerRegionX","ceil","sqrt","x","sliceCountPerRegionY","z","voxelCountPerRegionX","voxelCountPerRegionY","y","regionCountPerMegatextureX","floor","regionCountPerMegatextureY","textureMemoryByteLength","voxelCountPerTile","clone","maximumTileCount","regionCountPerMegatexture","voxelCountPerRegion","sliceCountPerRegion","voxelSizeUv","sliceSizeUv","regionSizeUv","texture","pixelDatatype","flipY","width","height","sampler","wrapS","CLAMP_TO_EDGE","wrapT","minificationFilter","LINEAR","magnificationFilter","componentDatatype","toComponentDatatype","tileVoxelDataTemp","createTypedArray","nodes","Array","tileIndex","MegatextureNode","node","previousNode","undefined","nextNode","occupiedList","emptyList","occupiedCount","FLOAT64","FLOAT","UINT8","UNSIGNED_BYTE","RED","LUMINANCE","RG","LUMINANCE_ALPHA","RGB","RGBA","componentByteLength","texelCount","maximumTextureSize","previousPowerOfTwo","index","prototype","add","data","isFull","writeDataToTexture","remove","getApproximateTextureMemoryByteLength","tileCount","datatypeSizeInBytes","voxelCountTotal","regionCountX","regionCountY","regionCount","tileData","constructor","Uint16Array","Float32Array","sliceVoxelOffsetX","sliceVoxelOffsetY","readOffset","getReadOffset","writeOffset","readIndex","writeIndex","c","voxelOffsetX","voxelOffsetY","source","arrayBufferView","copyOptions","xOffset","yOffset","copyFrom","voxelsPerInputSlice","sliceIndex","rowIndex","isDestroyed","destroy"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Megatexture.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport MetadataComponentType from \"./MetadataComponentType.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\n\n/**\n * @alias Megatexture\n * @constructor\n *\n * @param {Context} context The context in which to create GPU resources.\n * @param {Cartesian3} dimensions The number of voxels in each dimension of the tile.\n * @param {number} channelCount The number of channels in the metadata.\n * @param {MetadataComponentType} componentType The component type of the metadata.\n * @param {number} [availableTextureMemoryBytes=134217728] An upper limit on the texture memory size in bytes.\n *\n * @private\n */\nfunction Megatexture(\n  context,\n  dimensions,\n  channelCount,\n  componentType,\n  availableTextureMemoryBytes,\n) {\n  const maximumTextureMemoryByteLength = 512 * 1024 * 1024;\n  availableTextureMemoryBytes = Math.min(\n    availableTextureMemoryBytes ?? 128 * 1024 * 1024,\n    maximumTextureMemoryByteLength,\n  );\n\n  // TODO there are a lot of texture packing rules, see https://github.com/CesiumGS/cesium/issues/9572\n  // Unsigned short textures not allowed in webgl 1, so treat as float\n  if (componentType === MetadataComponentType.UNSIGNED_SHORT) {\n    componentType = MetadataComponentType.FLOAT32;\n  }\n\n  if (\n    componentType === MetadataComponentType.FLOAT32 &&\n    !context.floatingPointTexture\n  ) {\n    throw new RuntimeError(\"Floating point texture not supported\");\n  }\n\n  const pixelDataType = getPixelDataType(componentType);\n  const pixelFormat = getPixelFormat(channelCount, context.webgl2);\n  const componentTypeByteLength =\n    MetadataComponentType.getSizeInBytes(componentType);\n  const textureDimension = getTextureDimension(\n    availableTextureMemoryBytes,\n    channelCount,\n    componentTypeByteLength,\n  );\n\n  const sliceCountPerRegionX = Math.ceil(Math.sqrt(dimensions.x));\n  const sliceCountPerRegionY = Math.ceil(dimensions.z / sliceCountPerRegionX);\n  const voxelCountPerRegionX = sliceCountPerRegionX * dimensions.x;\n  const voxelCountPerRegionY = sliceCountPerRegionY * dimensions.y;\n  const regionCountPerMegatextureX = Math.floor(\n    textureDimension / voxelCountPerRegionX,\n  );\n  const regionCountPerMegatextureY = Math.floor(\n    textureDimension / voxelCountPerRegionY,\n  );\n\n  if (regionCountPerMegatextureX === 0 || regionCountPerMegatextureY === 0) {\n    throw new RuntimeError(\"Tileset is too large to fit into megatexture\");\n  }\n\n  /**\n   * @type {number}\n   * @readonly\n   */\n  this.channelCount = channelCount;\n\n  /**\n   * @type {MetadataComponentType}\n   * @readonly\n   */\n  this.componentType = componentType;\n\n  /**\n   * @type {number}\n   * @readonly\n   */\n  this.textureMemoryByteLength =\n    componentTypeByteLength * channelCount * textureDimension ** 2;\n\n  /**\n   * @type {Cartesian3}\n   * @readonly\n   */\n  this.voxelCountPerTile = Cartesian3.clone(dimensions, new Cartesian3());\n\n  /**\n   * @type {number}\n   * @readonly\n   */\n  this.maximumTileCount =\n    regionCountPerMegatextureX * regionCountPerMegatextureY;\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.regionCountPerMegatexture = new Cartesian2(\n    regionCountPerMegatextureX,\n    regionCountPerMegatextureY,\n  );\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.voxelCountPerRegion = new Cartesian2(\n    voxelCountPerRegionX,\n    voxelCountPerRegionY,\n  );\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.sliceCountPerRegion = new Cartesian2(\n    sliceCountPerRegionX,\n    sliceCountPerRegionY,\n  );\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.voxelSizeUv = new Cartesian2(\n    1.0 / textureDimension,\n    1.0 / textureDimension,\n  );\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.sliceSizeUv = new Cartesian2(\n    dimensions.x / textureDimension,\n    dimensions.y / textureDimension,\n  );\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.regionSizeUv = new Cartesian2(\n    voxelCountPerRegionX / textureDimension,\n    voxelCountPerRegionY / textureDimension,\n  );\n\n  /**\n   * @type {Texture}\n   * @readonly\n   */\n  this.texture = new Texture({\n    context: context,\n    pixelFormat: pixelFormat,\n    pixelDatatype: pixelDataType,\n    flipY: false,\n    width: textureDimension,\n    height: textureDimension,\n    sampler: new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.LINEAR,\n      magnificationFilter: TextureMagnificationFilter.LINEAR,\n    }),\n  });\n\n  const componentDatatype =\n    MetadataComponentType.toComponentDatatype(componentType);\n\n  /**\n   * @type {Array}\n   */\n  this.tileVoxelDataTemp = ComponentDatatype.createTypedArray(\n    componentDatatype,\n    voxelCountPerRegionX * voxelCountPerRegionY * channelCount,\n  );\n\n  /**\n   * @type {MegatextureNode[]}\n   * @readonly\n   */\n  this.nodes = new Array(this.maximumTileCount);\n  for (let tileIndex = 0; tileIndex < this.maximumTileCount; tileIndex++) {\n    this.nodes[tileIndex] = new MegatextureNode(tileIndex);\n  }\n  for (let tileIndex = 0; tileIndex < this.maximumTileCount; tileIndex++) {\n    const node = this.nodes[tileIndex];\n    node.previousNode = tileIndex > 0 ? this.nodes[tileIndex - 1] : undefined;\n    node.nextNode =\n      tileIndex < this.maximumTileCount - 1\n        ? this.nodes[tileIndex + 1]\n        : undefined;\n  }\n\n  /**\n   * @type {MegatextureNode}\n   * @readonly\n   */\n  this.occupiedList = undefined;\n\n  /**\n   * @type {MegatextureNode}\n   * @readonly\n   */\n  this.emptyList = this.nodes[0];\n\n  /**\n   * @type {number}\n   * @readonly\n   */\n  this.occupiedCount = 0;\n}\n\n/**\n * Get the pixel data type to use in a megatexture.\n * TODO support more\n *\n * @param {MetadataComponentType} componentType The component type of the metadata.\n * @returns {PixelDatatype} The pixel datatype to use for a megatexture.\n *\n * @private\n */\nfunction getPixelDataType(componentType) {\n  if (\n    componentType === MetadataComponentType.FLOAT32 ||\n    componentType === MetadataComponentType.FLOAT64\n  ) {\n    return PixelDatatype.FLOAT;\n  } else if (componentType === MetadataComponentType.UINT8) {\n    return PixelDatatype.UNSIGNED_BYTE;\n  }\n}\n\n/**\n * Get the pixel format to use for a megatexture.\n *\n * @param {number} channelCount The number of channels in the metadata. Must be 1 to 4.\n * @param {boolean} webgl2 true if the context is using webgl2\n * @returns {PixelFormat} The pixel format to use for a megatexture.\n *\n * @private\n */\nfunction getPixelFormat(channelCount, webgl2) {\n  if (channelCount === 1) {\n    return webgl2 ? PixelFormat.RED : PixelFormat.LUMINANCE;\n  } else if (channelCount === 2) {\n    return webgl2 ? PixelFormat.RG : PixelFormat.LUMINANCE_ALPHA;\n  } else if (channelCount === 3) {\n    return PixelFormat.RGB;\n  } else if (channelCount === 4) {\n    return PixelFormat.RGBA;\n  }\n}\n\n/**\n * Compute the largest size of a square texture that will fit in the available memory.\n *\n * @param {number} availableTextureMemoryBytes An upper limit on the texture memory size.\n * @param {number} channelCount The number of metadata channels per texel.\n * @param {number} componentByteLength The byte length of each component of the metadata.\n * @returns {number} The dimension of the square texture to use for the megatexture.\n *\n * @private\n */\nfunction getTextureDimension(\n  availableTextureMemoryBytes,\n  channelCount,\n  componentByteLength,\n) {\n  // Compute how many texels will fit in the available memory\n  const texelCount = Math.floor(\n    availableTextureMemoryBytes / (channelCount * componentByteLength),\n  );\n  // Return the largest power of two texture size that will fit in memory\n  return Math.min(\n    ContextLimits.maximumTextureSize,\n    CesiumMath.previousPowerOfTwo(Math.floor(Math.sqrt(texelCount))),\n  );\n}\n\n/**\n * @alias MegatextureNode\n * @constructor\n *\n * @param {number} index\n *\n * @private\n */\nfunction MegatextureNode(index) {\n  /**\n   * @type {number}\n   */\n  this.index = index;\n\n  /**\n   * @type {MegatextureNode}\n   */\n  this.nextNode = undefined;\n\n  /**\n   * @type {MegatextureNode}\n   */\n  this.previousNode = undefined;\n}\n\n/**\n * Add an array of tile metadata to the megatexture.\n * @param {Array} data The data to be added.\n * @returns {number} The index of the tile's location in the megatexture.\n */\nMegatexture.prototype.add = function (data) {\n  if (this.isFull()) {\n    throw new DeveloperError(\"Trying to add when there are no empty spots\");\n  }\n\n  // remove head of empty list\n  const node = this.emptyList;\n  this.emptyList = this.emptyList.nextNode;\n  if (defined(this.emptyList)) {\n    this.emptyList.previousNode = undefined;\n  }\n\n  // make head of occupied list\n  node.nextNode = this.occupiedList;\n  if (defined(node.nextNode)) {\n    node.nextNode.previousNode = node;\n  }\n  this.occupiedList = node;\n\n  const index = node.index;\n  this.writeDataToTexture(index, data);\n\n  this.occupiedCount++;\n  return index;\n};\n\n/**\n * @param {number} index\n */\nMegatexture.prototype.remove = function (index) {\n  if (index < 0 || index >= this.maximumTileCount) {\n    throw new DeveloperError(\"Megatexture index out of bounds\");\n  }\n\n  // remove from list\n  const node = this.nodes[index];\n  if (defined(node.previousNode)) {\n    node.previousNode.nextNode = node.nextNode;\n  }\n  if (defined(node.nextNode)) {\n    node.nextNode.previousNode = node.previousNode;\n  }\n\n  // make head of empty list\n  node.nextNode = this.emptyList;\n  if (defined(node.nextNode)) {\n    node.nextNode.previousNode = node;\n  }\n  node.previousNode = undefined;\n  this.emptyList = node;\n  this.occupiedCount--;\n};\n\n/**\n * @returns {boolean}\n */\nMegatexture.prototype.isFull = function () {\n  return this.emptyList === undefined;\n};\n\n/**\n * @param {number} tileCount The total number of tiles in the tileset.\n * @param {Cartesian3} dimensions The number of voxels in each dimension of the tile.\n * @param {number} channelCount The number of channels in the metadata.\n * @param {MetadataComponentType} componentType The type of one channel of the metadata.\n * @returns {number}\n */\nMegatexture.getApproximateTextureMemoryByteLength = function (\n  tileCount,\n  dimensions,\n  channelCount,\n  componentType,\n) {\n  // TODO there's a lot of code duplicate with Megatexture constructor\n\n  // Unsigned short textures not allowed in webgl 1, so treat as float\n  if (componentType === MetadataComponentType.UNSIGNED_SHORT) {\n    componentType = MetadataComponentType.FLOAT32;\n  }\n\n  const datatypeSizeInBytes =\n    MetadataComponentType.getSizeInBytes(componentType);\n  const voxelCountTotal =\n    tileCount * dimensions.x * dimensions.y * dimensions.z;\n\n  const sliceCountPerRegionX = Math.ceil(Math.sqrt(dimensions.x));\n  const sliceCountPerRegionY = Math.ceil(dimensions.z / sliceCountPerRegionX);\n  const voxelCountPerRegionX = sliceCountPerRegionX * dimensions.x;\n  const voxelCountPerRegionY = sliceCountPerRegionY * dimensions.y;\n\n  // Find the power of two that can fit all tile data, accounting for slices.\n  // There's probably a non-iterative solution for this, but this is good enough for now.\n  let textureDimension = CesiumMath.previousPowerOfTwo(\n    Math.floor(Math.sqrt(voxelCountTotal)),\n  );\n  for (;;) {\n    const regionCountX = Math.floor(textureDimension / voxelCountPerRegionX);\n    const regionCountY = Math.floor(textureDimension / voxelCountPerRegionY);\n    const regionCount = regionCountX * regionCountY;\n    if (regionCount >= tileCount) {\n      break;\n    } else {\n      textureDimension *= 2;\n    }\n  }\n\n  const textureMemoryByteLength =\n    textureDimension * textureDimension * channelCount * datatypeSizeInBytes;\n  return textureMemoryByteLength;\n};\n\n/**\n * Write an array of tile metadata to the megatexture.\n * @param {number} index The index of the tile's location in the megatexture.\n * @param {Float32Array|Uint16Array|Uint8Array} data The data to be written.\n */\nMegatexture.prototype.writeDataToTexture = function (index, data) {\n  // Unsigned short textures not allowed in webgl 1, so treat as float\n  const tileData =\n    data.constructor === Uint16Array ? new Float32Array(data) : data;\n\n  const {\n    tileVoxelDataTemp,\n    voxelCountPerTile,\n    sliceCountPerRegion,\n    voxelCountPerRegion,\n    channelCount,\n    regionCountPerMegatexture,\n  } = this;\n\n  for (let z = 0; z < voxelCountPerTile.z; z++) {\n    const sliceVoxelOffsetX = (z % sliceCountPerRegion.x) * voxelCountPerTile.x;\n    const sliceVoxelOffsetY =\n      Math.floor(z / sliceCountPerRegion.x) * voxelCountPerTile.y;\n    for (let y = 0; y < voxelCountPerTile.y; y++) {\n      const readOffset = getReadOffset(voxelCountPerTile, y, z);\n      const writeOffset =\n        (sliceVoxelOffsetY + y) * voxelCountPerRegion.x + sliceVoxelOffsetX;\n      for (let x = 0; x < voxelCountPerTile.x; x++) {\n        const readIndex = readOffset + x;\n        const writeIndex = writeOffset + x;\n        for (let c = 0; c < channelCount; c++) {\n          tileVoxelDataTemp[writeIndex * channelCount + c] =\n            tileData[readIndex * channelCount + c];\n        }\n      }\n    }\n  }\n\n  const voxelOffsetX =\n    (index % regionCountPerMegatexture.x) * voxelCountPerRegion.x;\n  const voxelOffsetY =\n    Math.floor(index / regionCountPerMegatexture.x) * voxelCountPerRegion.y;\n\n  const source = {\n    arrayBufferView: tileVoxelDataTemp,\n    width: voxelCountPerRegion.x,\n    height: voxelCountPerRegion.y,\n  };\n\n  const copyOptions = {\n    source: source,\n    xOffset: voxelOffsetX,\n    yOffset: voxelOffsetY,\n  };\n\n  this.texture.copyFrom(copyOptions);\n};\n\n/**\n * Get the offset into the data array for a given row of contiguous voxel data.\n *\n * @param {Cartesian3} dimensions The number of voxels in each dimension of the tile.\n * @param {number} y The y index of the voxel row\n * @param {number} z The z index of the voxel row\n * @returns {number} The offset into the data array\n * @private\n */\nfunction getReadOffset(dimensions, y, z) {\n  const voxelsPerInputSlice = dimensions.y * dimensions.x;\n  const sliceIndex = z;\n  const rowIndex = y;\n  return sliceIndex * voxelsPerInputSlice + rowIndex * dimensions.x;\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Megatexture#destroy\n */\nMegatexture.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see Megatexture#isDestroyed\n *\n * @example\n * megatexture = megatexture && megatexture.destroy();\n */\nMegatexture.prototype.destroy = function () {\n  this.texture = this.texture && this.texture.destroy();\n  return destroyObject(this);\n};\n\nexport default Megatexture;\n"],"mappings":";;;;AAAA,OAAOA,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,iBAAiB,MAAM,8BAA8B;AAC5D,OAAOC,aAAa,MAAM,8BAA8B;AACxD,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,aAAa,MAAM,0BAA0B;AACpD,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,qBAAqB,MAAM,4BAA4B;AAC9D,OAAOC,aAAa,MAAM,8BAA8B;AACxD,OAAOC,WAAW,MAAM,wBAAwB;AAChD,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,OAAO,MAAM,wBAAwB;AAC5C,OAAOC,OAAO,MAAM,wBAAwB;AAC5C,OAAOC,0BAA0B,MAAM,2CAA2C;AAClF,OAAOC,yBAAyB,MAAM,0CAA0C;AAChF,OAAOC,WAAW,MAAM,4BAA4B;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,WAAWA,CAClBC,OAAO,EACPC,UAAU,EACVC,YAAY,EACZC,aAAa,EACbC,2BAA2B,EAC3B;EACA,MAAMC,8BAA8B,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI;EACxDD,2BAA2B,GAAGE,IAAI,CAACC,GAAG,CACpCH,2BAA2B,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,EAChDC,8BACF,CAAC;;EAED;EACA;EACA,IAAIF,aAAa,KAAKb,qBAAqB,CAACkB,cAAc,EAAE;IAC1DL,aAAa,GAAGb,qBAAqB,CAACmB,OAAO;EAC/C;EAEA,IACEN,aAAa,KAAKb,qBAAqB,CAACmB,OAAO,IAC/C,CAACT,OAAO,CAACU,oBAAoB,EAC7B;IACA,MAAM,IAAIjB,YAAY,CAAC,sCAAsC,CAAC;EAChE;EAEA,MAAMkB,aAAa,GAAGC,gBAAgB,CAACT,aAAa,CAAC;EACrD,MAAMU,WAAW,GAAGC,cAAc,CAACZ,YAAY,EAAEF,OAAO,CAACe,MAAM,CAAC;EAChE,MAAMC,uBAAuB,GAC3B1B,qBAAqB,CAAC2B,cAAc,CAACd,aAAa,CAAC;EACrD,MAAMe,gBAAgB,GAAGC,mBAAmB,CAC1Cf,2BAA2B,EAC3BF,YAAY,EACZc,uBACF,CAAC;EAED,MAAMI,oBAAoB,GAAGd,IAAI,CAACe,IAAI,CAACf,IAAI,CAACgB,IAAI,CAACrB,UAAU,CAACsB,CAAC,CAAC,CAAC;EAC/D,MAAMC,oBAAoB,GAAGlB,IAAI,CAACe,IAAI,CAACpB,UAAU,CAACwB,CAAC,GAAGL,oBAAoB,CAAC;EAC3E,MAAMM,oBAAoB,GAAGN,oBAAoB,GAAGnB,UAAU,CAACsB,CAAC;EAChE,MAAMI,oBAAoB,GAAGH,oBAAoB,GAAGvB,UAAU,CAAC2B,CAAC;EAChE,MAAMC,0BAA0B,GAAGvB,IAAI,CAACwB,KAAK,CAC3CZ,gBAAgB,GAAGQ,oBACrB,CAAC;EACD,MAAMK,0BAA0B,GAAGzB,IAAI,CAACwB,KAAK,CAC3CZ,gBAAgB,GAAGS,oBACrB,CAAC;EAED,IAAIE,0BAA0B,KAAK,CAAC,IAAIE,0BAA0B,KAAK,CAAC,EAAE;IACxE,MAAM,IAAItC,YAAY,CAAC,8CAA8C,CAAC;EACxE;;EAEA;AACF;AACA;AACA;EACE,IAAI,CAACS,YAAY,GAAGA,YAAY;;EAEhC;AACF;AACA;AACA;EACE,IAAI,CAACC,aAAa,GAAGA,aAAa;;EAElC;AACF;AACA;AACA;EACE,IAAI,CAAC6B,uBAAuB,GAC1BhB,uBAAuB,GAAGd,YAAY,GAAGgB,gBAAgB,IAAI,CAAC;;EAEhE;AACF;AACA;AACA;EACE,IAAI,CAACe,iBAAiB,GAAGlD,UAAU,CAACmD,KAAK,CAACjC,UAAU,EAAE,IAAIlB,UAAU,CAAC,CAAC,CAAC;;EAEvE;AACF;AACA;AACA;EACE,IAAI,CAACoD,gBAAgB,GACnBN,0BAA0B,GAAGE,0BAA0B;;EAEzD;AACF;AACA;AACA;EACE,IAAI,CAACK,yBAAyB,GAAG,IAAItD,UAAU,CAC7C+C,0BAA0B,EAC1BE,0BACF,CAAC;;EAED;AACF;AACA;AACA;EACE,IAAI,CAACM,mBAAmB,GAAG,IAAIvD,UAAU,CACvC4C,oBAAoB,EACpBC,oBACF,CAAC;;EAED;AACF;AACA;AACA;EACE,IAAI,CAACW,mBAAmB,GAAG,IAAIxD,UAAU,CACvCsC,oBAAoB,EACpBI,oBACF,CAAC;;EAED;AACF;AACA;AACA;EACE,IAAI,CAACe,WAAW,GAAG,IAAIzD,UAAU,CAC/B,GAAG,GAAGoC,gBAAgB,EACtB,GAAG,GAAGA,gBACR,CAAC;;EAED;AACF;AACA;AACA;EACE,IAAI,CAACsB,WAAW,GAAG,IAAI1D,UAAU,CAC/BmB,UAAU,CAACsB,CAAC,GAAGL,gBAAgB,EAC/BjB,UAAU,CAAC2B,CAAC,GAAGV,gBACjB,CAAC;;EAED;AACF;AACA;AACA;EACE,IAAI,CAACuB,YAAY,GAAG,IAAI3D,UAAU,CAChC4C,oBAAoB,GAAGR,gBAAgB,EACvCS,oBAAoB,GAAGT,gBACzB,CAAC;;EAED;AACF;AACA;AACA;EACE,IAAI,CAACwB,OAAO,GAAG,IAAI/C,OAAO,CAAC;IACzBK,OAAO,EAAEA,OAAO;IAChBa,WAAW,EAAEA,WAAW;IACxB8B,aAAa,EAAEhC,aAAa;IAC5BiC,KAAK,EAAE,KAAK;IACZC,KAAK,EAAE3B,gBAAgB;IACvB4B,MAAM,EAAE5B,gBAAgB;IACxB6B,OAAO,EAAE,IAAIrD,OAAO,CAAC;MACnBsD,KAAK,EAAElD,WAAW,CAACmD,aAAa;MAChCC,KAAK,EAAEpD,WAAW,CAACmD,aAAa;MAChCE,kBAAkB,EAAEtD,yBAAyB,CAACuD,MAAM;MACpDC,mBAAmB,EAAEzD,0BAA0B,CAACwD;IAClD,CAAC;EACH,CAAC,CAAC;EAEF,MAAME,iBAAiB,GACrBhE,qBAAqB,CAACiE,mBAAmB,CAACpD,aAAa,CAAC;;EAE1D;AACF;AACA;EACE,IAAI,CAACqD,iBAAiB,GAAGxE,iBAAiB,CAACyE,gBAAgB,CACzDH,iBAAiB,EACjB5B,oBAAoB,GAAGC,oBAAoB,GAAGzB,YAChD,CAAC;;EAED;AACF;AACA;AACA;EACE,IAAI,CAACwD,KAAK,GAAG,IAAIC,KAAK,CAAC,IAAI,CAACxB,gBAAgB,CAAC;EAC7C,KAAK,IAAIyB,SAAS,GAAG,CAAC,EAAEA,SAAS,GAAG,IAAI,CAACzB,gBAAgB,EAAEyB,SAAS,EAAE,EAAE;IACtE,IAAI,CAACF,KAAK,CAACE,SAAS,CAAC,GAAG,IAAIC,eAAe,CAACD,SAAS,CAAC;EACxD;EACA,KAAK,IAAIA,SAAS,GAAG,CAAC,EAAEA,SAAS,GAAG,IAAI,CAACzB,gBAAgB,EAAEyB,SAAS,EAAE,EAAE;IACtE,MAAME,IAAI,GAAG,IAAI,CAACJ,KAAK,CAACE,SAAS,CAAC;IAClCE,IAAI,CAACC,YAAY,GAAGH,SAAS,GAAG,CAAC,GAAG,IAAI,CAACF,KAAK,CAACE,SAAS,GAAG,CAAC,CAAC,GAAGI,SAAS;IACzEF,IAAI,CAACG,QAAQ,GACXL,SAAS,GAAG,IAAI,CAACzB,gBAAgB,GAAG,CAAC,GACjC,IAAI,CAACuB,KAAK,CAACE,SAAS,GAAG,CAAC,CAAC,GACzBI,SAAS;EACjB;;EAEA;AACF;AACA;AACA;EACE,IAAI,CAACE,YAAY,GAAGF,SAAS;;EAE7B;AACF;AACA;AACA;EACE,IAAI,CAACG,SAAS,GAAG,IAAI,CAACT,KAAK,CAAC,CAAC,CAAC;;EAE9B;AACF;AACA;AACA;EACE,IAAI,CAACU,aAAa,GAAG,CAAC;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASxD,gBAAgBA,CAACT,aAAa,EAAE;EACvC,IACEA,aAAa,KAAKb,qBAAqB,CAACmB,OAAO,IAC/CN,aAAa,KAAKb,qBAAqB,CAAC+E,OAAO,EAC/C;IACA,OAAO9E,aAAa,CAAC+E,KAAK;EAC5B,CAAC,MAAM,IAAInE,aAAa,KAAKb,qBAAqB,CAACiF,KAAK,EAAE;IACxD,OAAOhF,aAAa,CAACiF,aAAa;EACpC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS1D,cAAcA,CAACZ,YAAY,EAAEa,MAAM,EAAE;EAC5C,IAAIb,YAAY,KAAK,CAAC,EAAE;IACtB,OAAOa,MAAM,GAAGvB,WAAW,CAACiF,GAAG,GAAGjF,WAAW,CAACkF,SAAS;EACzD,CAAC,MAAM,IAAIxE,YAAY,KAAK,CAAC,EAAE;IAC7B,OAAOa,MAAM,GAAGvB,WAAW,CAACmF,EAAE,GAAGnF,WAAW,CAACoF,eAAe;EAC9D,CAAC,MAAM,IAAI1E,YAAY,KAAK,CAAC,EAAE;IAC7B,OAAOV,WAAW,CAACqF,GAAG;EACxB,CAAC,MAAM,IAAI3E,YAAY,KAAK,CAAC,EAAE;IAC7B,OAAOV,WAAW,CAACsF,IAAI;EACzB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS3D,mBAAmBA,CAC1Bf,2BAA2B,EAC3BF,YAAY,EACZ6E,mBAAmB,EACnB;EACA;EACA,MAAMC,UAAU,GAAG1E,IAAI,CAACwB,KAAK,CAC3B1B,2BAA2B,IAAIF,YAAY,GAAG6E,mBAAmB,CACnE,CAAC;EACD;EACA,OAAOzE,IAAI,CAACC,GAAG,CACbtB,aAAa,CAACgG,kBAAkB,EAChC5F,UAAU,CAAC6F,kBAAkB,CAAC5E,IAAI,CAACwB,KAAK,CAACxB,IAAI,CAACgB,IAAI,CAAC0D,UAAU,CAAC,CAAC,CACjE,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASnB,eAAeA,CAACsB,KAAK,EAAE;EAC9B;AACF;AACA;EACE,IAAI,CAACA,KAAK,GAAGA,KAAK;;EAElB;AACF;AACA;EACE,IAAI,CAAClB,QAAQ,GAAGD,SAAS;;EAEzB;AACF;AACA;EACE,IAAI,CAACD,YAAY,GAAGC,SAAS;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACAjE,WAAW,CAACqF,SAAS,CAACC,GAAG,GAAG,UAAUC,IAAI,EAAE;EAC1C,IAAI,IAAI,CAACC,MAAM,CAAC,CAAC,EAAE;IACjB,MAAM,IAAInG,cAAc,CAAC,6CAA6C,CAAC;EACzE;;EAEA;EACA,MAAM0E,IAAI,GAAG,IAAI,CAACK,SAAS;EAC3B,IAAI,CAACA,SAAS,GAAG,IAAI,CAACA,SAAS,CAACF,QAAQ;EACxC,IAAI/E,OAAO,CAAC,IAAI,CAACiF,SAAS,CAAC,EAAE;IAC3B,IAAI,CAACA,SAAS,CAACJ,YAAY,GAAGC,SAAS;EACzC;;EAEA;EACAF,IAAI,CAACG,QAAQ,GAAG,IAAI,CAACC,YAAY;EACjC,IAAIhF,OAAO,CAAC4E,IAAI,CAACG,QAAQ,CAAC,EAAE;IAC1BH,IAAI,CAACG,QAAQ,CAACF,YAAY,GAAGD,IAAI;EACnC;EACA,IAAI,CAACI,YAAY,GAAGJ,IAAI;EAExB,MAAMqB,KAAK,GAAGrB,IAAI,CAACqB,KAAK;EACxB,IAAI,CAACK,kBAAkB,CAACL,KAAK,EAAEG,IAAI,CAAC;EAEpC,IAAI,CAAClB,aAAa,EAAE;EACpB,OAAOe,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACApF,WAAW,CAACqF,SAAS,CAACK,MAAM,GAAG,UAAUN,KAAK,EAAE;EAC9C,IAAIA,KAAK,GAAG,CAAC,IAAIA,KAAK,IAAI,IAAI,CAAChD,gBAAgB,EAAE;IAC/C,MAAM,IAAI/C,cAAc,CAAC,iCAAiC,CAAC;EAC7D;;EAEA;EACA,MAAM0E,IAAI,GAAG,IAAI,CAACJ,KAAK,CAACyB,KAAK,CAAC;EAC9B,IAAIjG,OAAO,CAAC4E,IAAI,CAACC,YAAY,CAAC,EAAE;IAC9BD,IAAI,CAACC,YAAY,CAACE,QAAQ,GAAGH,IAAI,CAACG,QAAQ;EAC5C;EACA,IAAI/E,OAAO,CAAC4E,IAAI,CAACG,QAAQ,CAAC,EAAE;IAC1BH,IAAI,CAACG,QAAQ,CAACF,YAAY,GAAGD,IAAI,CAACC,YAAY;EAChD;;EAEA;EACAD,IAAI,CAACG,QAAQ,GAAG,IAAI,CAACE,SAAS;EAC9B,IAAIjF,OAAO,CAAC4E,IAAI,CAACG,QAAQ,CAAC,EAAE;IAC1BH,IAAI,CAACG,QAAQ,CAACF,YAAY,GAAGD,IAAI;EACnC;EACAA,IAAI,CAACC,YAAY,GAAGC,SAAS;EAC7B,IAAI,CAACG,SAAS,GAAGL,IAAI;EACrB,IAAI,CAACM,aAAa,EAAE;AACtB,CAAC;;AAED;AACA;AACA;AACArE,WAAW,CAACqF,SAAS,CAACG,MAAM,GAAG,YAAY;EACzC,OAAO,IAAI,CAACpB,SAAS,KAAKH,SAAS;AACrC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAjE,WAAW,CAAC2F,qCAAqC,GAAG,UAClDC,SAAS,EACT1F,UAAU,EACVC,YAAY,EACZC,aAAa,EACb;EACA;;EAEA;EACA,IAAIA,aAAa,KAAKb,qBAAqB,CAACkB,cAAc,EAAE;IAC1DL,aAAa,GAAGb,qBAAqB,CAACmB,OAAO;EAC/C;EAEA,MAAMmF,mBAAmB,GACvBtG,qBAAqB,CAAC2B,cAAc,CAACd,aAAa,CAAC;EACrD,MAAM0F,eAAe,GACnBF,SAAS,GAAG1F,UAAU,CAACsB,CAAC,GAAGtB,UAAU,CAAC2B,CAAC,GAAG3B,UAAU,CAACwB,CAAC;EAExD,MAAML,oBAAoB,GAAGd,IAAI,CAACe,IAAI,CAACf,IAAI,CAACgB,IAAI,CAACrB,UAAU,CAACsB,CAAC,CAAC,CAAC;EAC/D,MAAMC,oBAAoB,GAAGlB,IAAI,CAACe,IAAI,CAACpB,UAAU,CAACwB,CAAC,GAAGL,oBAAoB,CAAC;EAC3E,MAAMM,oBAAoB,GAAGN,oBAAoB,GAAGnB,UAAU,CAACsB,CAAC;EAChE,MAAMI,oBAAoB,GAAGH,oBAAoB,GAAGvB,UAAU,CAAC2B,CAAC;;EAEhE;EACA;EACA,IAAIV,gBAAgB,GAAG7B,UAAU,CAAC6F,kBAAkB,CAClD5E,IAAI,CAACwB,KAAK,CAACxB,IAAI,CAACgB,IAAI,CAACuE,eAAe,CAAC,CACvC,CAAC;EACD,SAAS;IACP,MAAMC,YAAY,GAAGxF,IAAI,CAACwB,KAAK,CAACZ,gBAAgB,GAAGQ,oBAAoB,CAAC;IACxE,MAAMqE,YAAY,GAAGzF,IAAI,CAACwB,KAAK,CAACZ,gBAAgB,GAAGS,oBAAoB,CAAC;IACxE,MAAMqE,WAAW,GAAGF,YAAY,GAAGC,YAAY;IAC/C,IAAIC,WAAW,IAAIL,SAAS,EAAE;MAC5B;IACF,CAAC,MAAM;MACLzE,gBAAgB,IAAI,CAAC;IACvB;EACF;EAEA,MAAMc,uBAAuB,GAC3Bd,gBAAgB,GAAGA,gBAAgB,GAAGhB,YAAY,GAAG0F,mBAAmB;EAC1E,OAAO5D,uBAAuB;AAChC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAjC,WAAW,CAACqF,SAAS,CAACI,kBAAkB,GAAG,UAAUL,KAAK,EAAEG,IAAI,EAAE;EAChE;EACA,MAAMW,QAAQ,GACZX,IAAI,CAACY,WAAW,KAAKC,WAAW,GAAG,IAAIC,YAAY,CAACd,IAAI,CAAC,GAAGA,IAAI;EAElE,MAAM;IACJ9B,iBAAiB;IACjBvB,iBAAiB;IACjBK,mBAAmB;IACnBD,mBAAmB;IACnBnC,YAAY;IACZkC;EACF,CAAC,GAAG,IAAI;EAER,KAAK,IAAIX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGQ,iBAAiB,CAACR,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC5C,MAAM4E,iBAAiB,GAAI5E,CAAC,GAAGa,mBAAmB,CAACf,CAAC,GAAIU,iBAAiB,CAACV,CAAC;IAC3E,MAAM+E,iBAAiB,GACrBhG,IAAI,CAACwB,KAAK,CAACL,CAAC,GAAGa,mBAAmB,CAACf,CAAC,CAAC,GAAGU,iBAAiB,CAACL,CAAC;IAC7D,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGK,iBAAiB,CAACL,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC5C,MAAM2E,UAAU,GAAGC,aAAa,CAACvE,iBAAiB,EAAEL,CAAC,EAAEH,CAAC,CAAC;MACzD,MAAMgF,WAAW,GACf,CAACH,iBAAiB,GAAG1E,CAAC,IAAIS,mBAAmB,CAACd,CAAC,GAAG8E,iBAAiB;MACrE,KAAK,IAAI9E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGU,iBAAiB,CAACV,CAAC,EAAEA,CAAC,EAAE,EAAE;QAC5C,MAAMmF,SAAS,GAAGH,UAAU,GAAGhF,CAAC;QAChC,MAAMoF,UAAU,GAAGF,WAAW,GAAGlF,CAAC;QAClC,KAAK,IAAIqF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG1G,YAAY,EAAE0G,CAAC,EAAE,EAAE;UACrCpD,iBAAiB,CAACmD,UAAU,GAAGzG,YAAY,GAAG0G,CAAC,CAAC,GAC9CX,QAAQ,CAACS,SAAS,GAAGxG,YAAY,GAAG0G,CAAC,CAAC;QAC1C;MACF;IACF;EACF;EAEA,MAAMC,YAAY,GACf1B,KAAK,GAAG/C,yBAAyB,CAACb,CAAC,GAAIc,mBAAmB,CAACd,CAAC;EAC/D,MAAMuF,YAAY,GAChBxG,IAAI,CAACwB,KAAK,CAACqD,KAAK,GAAG/C,yBAAyB,CAACb,CAAC,CAAC,GAAGc,mBAAmB,CAACT,CAAC;EAEzE,MAAMmF,MAAM,GAAG;IACbC,eAAe,EAAExD,iBAAiB;IAClCX,KAAK,EAAER,mBAAmB,CAACd,CAAC;IAC5BuB,MAAM,EAAET,mBAAmB,CAACT;EAC9B,CAAC;EAED,MAAMqF,WAAW,GAAG;IAClBF,MAAM,EAAEA,MAAM;IACdG,OAAO,EAAEL,YAAY;IACrBM,OAAO,EAAEL;EACX,CAAC;EAED,IAAI,CAACpE,OAAO,CAAC0E,QAAQ,CAACH,WAAW,CAAC;AACpC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAST,aAAaA,CAACvG,UAAU,EAAE2B,CAAC,EAAEH,CAAC,EAAE;EACvC,MAAM4F,mBAAmB,GAAGpH,UAAU,CAAC2B,CAAC,GAAG3B,UAAU,CAACsB,CAAC;EACvD,MAAM+F,UAAU,GAAG7F,CAAC;EACpB,MAAM8F,QAAQ,GAAG3F,CAAC;EAClB,OAAO0F,UAAU,GAAGD,mBAAmB,GAAGE,QAAQ,GAAGtH,UAAU,CAACsB,CAAC;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAxB,WAAW,CAACqF,SAAS,CAACoC,WAAW,GAAG,YAAY;EAC9C,OAAO,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzH,WAAW,CAACqF,SAAS,CAACqC,OAAO,GAAG,YAAY;EAC1C,IAAI,CAAC/E,OAAO,GAAG,IAAI,CAACA,OAAO,IAAI,IAAI,CAACA,OAAO,CAAC+E,OAAO,CAAC,CAAC;EACrD,OAAOtI,aAAa,CAAC,IAAI,CAAC;AAC5B,CAAC;AAED,eAAeY,WAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}