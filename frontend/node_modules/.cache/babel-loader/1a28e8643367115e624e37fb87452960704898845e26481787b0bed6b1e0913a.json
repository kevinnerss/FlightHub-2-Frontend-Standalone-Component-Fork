{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-hex.js\";\nimport \"core-js/modules/esnext.uint8-array.to-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.to-hex.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport CullingVolume from \"../Core/CullingVolume.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DoubleEndedPriorityQueue from \"../Core/DoubleEndedPriorityQueue.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport KeyframeNode from \"./KeyframeNode.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport Megatexture from \"./Megatexture.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport SpatialNode from \"./SpatialNode.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport VoxelMetadataOrder from \"./VoxelMetadataOrder.js\";\n\n/**\n * Handles tileset traversal, tile requests, and GPU resources. Intended to be\n * private and paired with a {@link VoxelPrimitive}, which has a user-facing API.\n *\n * @alias VoxelTraversal\n * @constructor\n *\n * @param {VoxelPrimitive} primitive The voxel primitive for which this traversal will be used.\n * @param {Context} context The context in which to create GPU resources.\n * @param {number} keyframeCount The number of keyframes in the tileset.\n * @param {number} [maximumTextureMemoryByteLength] The maximum amount of memory to use for textures.\n *\n * @private\n */\nfunction VoxelTraversal(primitive, context, keyframeCount, maximumTextureMemoryByteLength) {\n  const {\n    provider,\n    dimensions,\n    paddingBefore,\n    paddingAfter\n  } = primitive;\n  const {\n    types,\n    componentTypes,\n    metadataOrder\n  } = provider;\n  const inputDimensions = Cartesian3.add(dimensions, paddingBefore, new Cartesian3());\n  Cartesian3.add(inputDimensions, paddingAfter, inputDimensions);\n  if (metadataOrder === VoxelMetadataOrder.Y_UP) {\n    const inputDimensionsY = inputDimensions.y;\n    inputDimensions.y = inputDimensions.z;\n    inputDimensions.z = inputDimensionsY;\n  }\n  if (!defined(maximumTextureMemoryByteLength) && defined(provider.maximumTileCount)) {\n    maximumTextureMemoryByteLength = getApproximateTextureMemoryByteLength(provider.maximumTileCount, inputDimensions, types, componentTypes);\n  }\n\n  /**\n   * @type {VoxelPrimitive}\n   * @private\n   */\n  this._primitive = primitive;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.textureMemoryByteLength = 0;\n\n  /**\n   * @type {Megatexture[]}\n   * @readonly\n   */\n  this.megatextures = new Array(types.length);\n\n  // TODO make sure to split the maximumTextureMemoryByteLength across all the megatextures\n  for (let i = 0; i < types.length; i++) {\n    const type = types[i];\n    const componentCount = MetadataType.getComponentCount(type);\n    const componentType = componentTypes[i];\n    this.megatextures[i] = new Megatexture(context, inputDimensions, componentCount, componentType, maximumTextureMemoryByteLength);\n    this.textureMemoryByteLength += this.megatextures[i].textureMemoryByteLength;\n  }\n  const maximumTileCount = this.megatextures[0].maximumTileCount;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._simultaneousRequestCount = 0;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._debugPrint = false;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._calculateStatistics = this._primitive._calculateStatistics ?? false;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._frameNumber = 0;\n  const shape = primitive._shape;\n\n  /**\n   * @type {SpatialNode}\n   * @readonly\n   */\n  this.rootNode = new SpatialNode(0, 0, 0, 0, undefined, shape, dimensions);\n\n  /**\n   * @type {DoubleEndedPriorityQueue}\n   * @private\n   */\n  this._priorityQueue = new DoubleEndedPriorityQueue({\n    maximumLength: maximumTileCount,\n    comparator: KeyframeNode.priorityComparator\n  });\n\n  /**\n   * @type {KeyframeNode[]}\n   * @private\n   */\n  this._highPriorityKeyframeNodes = new Array(maximumTileCount);\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._highPriorityKeyframeNodeCount = 0;\n\n  /**\n   * @type {KeyframeNode[]}\n   * @private\n   */\n  this._keyframeNodesInMegatexture = new Array(maximumTileCount);\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._keyframeCount = keyframeCount;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._sampleCount = undefined;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._keyframeLocation = 0;\n\n  /**\n   * @type {number[]}\n   * @private\n   */\n  this._binaryTreeKeyframeWeighting = new Array(keyframeCount);\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._initialTilesLoaded = false;\n  const binaryTreeKeyframeWeighting = this._binaryTreeKeyframeWeighting;\n  binaryTreeKeyframeWeighting[0] = 0;\n  binaryTreeKeyframeWeighting[keyframeCount - 1] = 0;\n  binaryTreeWeightingRecursive(binaryTreeKeyframeWeighting, 1, keyframeCount - 2, 0);\n  const internalNodeTexelCount = 9;\n  const internalNodeTextureDimensionX = 2048;\n  const internalNodeTilesPerRow = Math.floor(internalNodeTextureDimensionX / internalNodeTexelCount);\n  const internalNodeTextureDimensionY = Math.ceil(maximumTileCount / internalNodeTilesPerRow);\n\n  /**\n   * @type {Texture}\n   * @readonly\n   */\n  this.internalNodeTexture = new Texture({\n    context: context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    flipY: false,\n    width: internalNodeTextureDimensionX,\n    height: internalNodeTextureDimensionY,\n    sampler: new Sampler({\n      minificationFilter: TextureMinificationFilter.NEAREST,\n      magnificationFilter: TextureMagnificationFilter.NEAREST\n    })\n  });\n\n  /**\n   * @type {number}\n   * @readonly\n   */\n  this.internalNodeTilesPerRow = internalNodeTilesPerRow;\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.internalNodeTexelSizeUv = new Cartesian2(1.0 / internalNodeTextureDimensionX, 1.0 / internalNodeTextureDimensionY);\n\n  /**\n   * Only generated when there are two or more samples.\n   * @type {Texture}\n   * @readonly\n   */\n  this.leafNodeTexture = undefined;\n\n  /**\n   * Only generated when there are two or more samples.\n   * @type {number}\n   * @readonly\n   */\n  this.leafNodeTilesPerRow = undefined;\n\n  /**\n   * Only generated when there are two or more samples.\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.leafNodeTexelSizeUv = new Cartesian2();\n}\n\n/**\n * Finds a keyframe node in the traversal\n *\n * @param {number} megatextureIndex\n * @returns {KeyframeNode}\n */\nVoxelTraversal.prototype.findKeyframeNode = function (megatextureIndex) {\n  return this._keyframeNodesInMegatexture.find(function (keyframeNode) {\n    return keyframeNode.megatextureIndex === megatextureIndex;\n  });\n};\nfunction binaryTreeWeightingRecursive(arr, start, end, depth) {\n  if (start > end) {\n    return;\n  }\n  const mid = Math.floor((start + end) / 2);\n  arr[mid] = depth;\n  binaryTreeWeightingRecursive(arr, start, mid - 1, depth + 1);\n  binaryTreeWeightingRecursive(arr, mid + 1, end, depth + 1);\n}\nVoxelTraversal.simultaneousRequestCountMaximum = 50;\n\n/**\n * @param {FrameState} frameState\n * @param {number} keyframeLocation\n * @param {boolean} recomputeBoundingVolumes\n * @param {boolean} pauseUpdate\n */\nVoxelTraversal.prototype.update = function (frameState, keyframeLocation, recomputeBoundingVolumes, pauseUpdate) {\n  const primitive = this._primitive;\n  const context = frameState.context;\n  const maximumTileCount = this.megatextures[0].maximumTileCount;\n  const keyframeCount = this._keyframeCount;\n  const levelBlendFactor = primitive._levelBlendFactor;\n  const hasLevelBlendFactor = levelBlendFactor > 0.0;\n  const hasKeyframes = keyframeCount > 1;\n  const sampleCount = (hasLevelBlendFactor ? 2 : 1) * (hasKeyframes ? 2 : 1);\n  this._sampleCount = sampleCount;\n  const useLeafNodes = sampleCount >= 2;\n  if (useLeafNodes && !defined(this.leafNodeTexture)) {\n    const leafNodeTexelCount = 2;\n    const leafNodeTextureDimensionX = 1024;\n    const leafNodeTilesPerRow = Math.floor(leafNodeTextureDimensionX / leafNodeTexelCount);\n    const leafNodeTextureDimensionY = Math.ceil(maximumTileCount / leafNodeTilesPerRow);\n    this.leafNodeTexture = new Texture({\n      context: context,\n      pixelFormat: PixelFormat.RGBA,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      flipY: false,\n      width: leafNodeTextureDimensionX,\n      height: leafNodeTextureDimensionY,\n      sampler: new Sampler({\n        minificationFilter: TextureMinificationFilter.NEAREST,\n        magnificationFilter: TextureMagnificationFilter.NEAREST\n      })\n    });\n    this.leafNodeTexelSizeUv = Cartesian2.fromElements(1.0 / leafNodeTextureDimensionX, 1.0 / leafNodeTextureDimensionY, this.leafNodeTexelSizeUv);\n    this.leafNodeTilesPerRow = leafNodeTilesPerRow;\n  } else if (!useLeafNodes && defined(this.leafNodeTexture)) {\n    this.leafNodeTexture = this.leafNodeTexture.destroy();\n  }\n  this._keyframeLocation = CesiumMath.clamp(keyframeLocation, 0.0, keyframeCount - 1);\n  if (recomputeBoundingVolumes) {\n    recomputeBoundingVolumesRecursive(this, this.rootNode);\n  }\n  if (pauseUpdate) {\n    return;\n  }\n  this._frameNumber = frameState.frameNumber;\n  const timestamp0 = getTimestamp();\n  selectKeyframeNodes(this, frameState);\n  updateKeyframeNodes(this, frameState);\n  const timestamp1 = getTimestamp();\n  generateOctree(this, sampleCount, levelBlendFactor);\n  const timestamp2 = getTimestamp();\n  const checkEventListeners = primitive.loadProgress.numberOfListeners > 0 || primitive.allTilesLoaded.numberOfListeners > 0 || primitive.initialTilesLoaded.numberOfListeners > 0;\n  if (this._debugPrint || this._calculateStatistics || checkEventListeners) {\n    const loadAndUnloadTimeMs = timestamp1 - timestamp0;\n    const generateOctreeTimeMs = timestamp2 - timestamp1;\n    const totalTimeMs = timestamp2 - timestamp0;\n    postPassesUpdate(this, frameState, loadAndUnloadTimeMs, generateOctreeTimeMs, totalTimeMs);\n  }\n};\n\n/**\n * Check if a node is renderable.\n * @param {SpatialNode} tile\n * @returns {boolean}\n */\nVoxelTraversal.prototype.isRenderable = function (tile) {\n  return tile.isRenderable(this._frameNumber);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see VoxelTraversal#destroy\n */\nVoxelTraversal.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see VoxelTraversal#isDestroyed\n *\n * @example\n * voxelTraversal = voxelTraversal && voxelTraversal.destroy();\n */\nVoxelTraversal.prototype.destroy = function () {\n  const megatextures = this.megatextures;\n  const megatextureLength = megatextures.length;\n  for (let i = 0; i < megatextureLength; i++) {\n    megatextures[i] = megatextures[i] && megatextures[i].destroy();\n  }\n  this.textureMemoryByteLength = 0;\n  this.internalNodeTexture = this.internalNodeTexture && this.internalNodeTexture.destroy();\n  this.leafNodeTexture = this.leafNodeTexture && this.leafNodeTexture.destroy();\n  return destroyObject(this);\n};\n\n/**\n * @function\n *\n * @param {VoxelTraversal} that\n * @param {SpatialNode} node\n *\n * @private\n */\nfunction recomputeBoundingVolumesRecursive(that, node) {\n  node.computeBoundingVolumes(that._primitive._shape);\n  if (defined(node.children)) {\n    for (let i = 0; i < 8; i++) {\n      const child = node.children[i];\n      recomputeBoundingVolumesRecursive(that, child);\n    }\n  }\n}\n\n/**\n * @function\n *\n * @param {VoxelTraversal} that\n * @param {KeyframeNode} keyframeNode\n *\n * @private\n */\nfunction requestData(that, keyframeNode) {\n  if (that._simultaneousRequestCount >= VoxelTraversal.simultaneousRequestCountMaximum) {\n    return;\n  }\n  const primitive = that._primitive;\n  const provider = primitive.provider;\n  const {\n    keyframe,\n    spatialNode\n  } = keyframeNode;\n  if (defined(provider.availableLevels) && spatialNode.level >= provider.availableLevels) {\n    return;\n  }\n  function postRequestSuccess(result) {\n    that._simultaneousRequestCount--;\n    keyframeNode.content = result;\n    keyframeNode.state = defined(result) ? KeyframeNode.LoadState.PROCESSING : KeyframeNode.LoadState.UNAVAILABLE;\n  }\n  function postRequestFailure(error) {\n    that._simultaneousRequestCount--;\n    keyframeNode.state = KeyframeNode.LoadState.FAILED;\n    that._primitive.tileFailed.raiseEvent();\n  }\n  const requestParameters = {\n    tileLevel: spatialNode.level,\n    tileX: spatialNode.x,\n    tileY: spatialNode.y,\n    tileZ: spatialNode.z,\n    keyframe: keyframe\n  };\n  const promise = provider.requestData(requestParameters);\n  if (!defined(promise)) {\n    return;\n  }\n  that._simultaneousRequestCount++;\n  keyframeNode.state = KeyframeNode.LoadState.RECEIVING;\n  promise.then(postRequestSuccess).catch(postRequestFailure);\n}\n\n/**\n * @function\n *\n * @param {number} x\n * @returns {number}\n *\n * @private\n */\nfunction mapInfiniteRangeToZeroOne(x) {\n  return x / (1.0 + x);\n}\n\n/**\n * @param {VoxelTraversal} that\n * @param {FrameState} frameState\n *\n * @private\n */\nfunction selectKeyframeNodes(that, frameState) {\n  const frameNumber = that._frameNumber;\n  const priorityQueue = that._priorityQueue;\n\n  // Add all the nodes to the queue, to sort them by priority.\n  priorityQueue.reset();\n  addToQueueRecursive(that.rootNode, CullingVolume.MASK_INDETERMINATE, that, frameState);\n\n  // Move the nodes from the queue to array of high priority nodes.\n  const highPriorityKeyframeNodes = that._highPriorityKeyframeNodes;\n  let highPriorityKeyframeNodeCount = 0;\n  let highPriorityKeyframeNode;\n  while (priorityQueue.length > 0) {\n    highPriorityKeyframeNode = priorityQueue.removeMaximum();\n    highPriorityKeyframeNode.highPriorityFrameNumber = frameNumber;\n    highPriorityKeyframeNodes[highPriorityKeyframeNodeCount] = highPriorityKeyframeNode;\n    highPriorityKeyframeNodeCount++;\n  }\n  that._highPriorityKeyframeNodeCount = highPriorityKeyframeNodeCount;\n}\n\n/**\n * @param {VoxelTraversal} that\n * @param {FrameState} frameState\n *\n * @private\n */\nfunction updateKeyframeNodes(that, frameState) {\n  const megatexture = that.megatextures[0];\n  const keyframeNodesInMegatextureCount = megatexture.occupiedCount;\n\n  // Sort the list of keyframe nodes in the megatexture by priority, so\n  // we can remove the lowest priority nodes if we need space.\n  const keyframeNodesInMegatexture = that._keyframeNodesInMegatexture;\n  keyframeNodesInMegatexture.length = keyframeNodesInMegatextureCount;\n  keyframeNodesInMegatexture.sort(keyframeNodeSort);\n\n  // Add the high priority nodes to the megatexture,\n  // removing existing lower-priority nodes if necessary.\n  const highPriorityKeyframeNodes = that._highPriorityKeyframeNodes;\n  const highPriorityKeyframeNodeCount = that._highPriorityKeyframeNodeCount;\n  let destroyedCount = 0;\n  let addedCount = 0;\n  for (let highPriorityKeyframeNodeIndex = 0; highPriorityKeyframeNodeIndex < highPriorityKeyframeNodeCount; highPriorityKeyframeNodeIndex++) {\n    const highPriorityKeyframeNode = highPriorityKeyframeNodes[highPriorityKeyframeNodeIndex];\n    if (highPriorityKeyframeNode.state === KeyframeNode.LoadState.LOADED || highPriorityKeyframeNode.spatialNode === undefined) {\n      // Already loaded, so nothing to do.\n      // Or destroyed when adding a higher priority node\n      continue;\n    }\n    if (highPriorityKeyframeNode.state === KeyframeNode.LoadState.UNLOADED) {\n      requestData(that, highPriorityKeyframeNode);\n    }\n    if (highPriorityKeyframeNode.state === KeyframeNode.LoadState.PROCESSING) {\n      const {\n        content\n      } = highPriorityKeyframeNode;\n      content.update(that._primitive, frameState);\n      if (!content.ready) {\n        continue;\n      }\n      if (!validateMetadata(content.metadata, that)) {\n        highPriorityKeyframeNode.content = undefined;\n        highPriorityKeyframeNode.state = KeyframeNode.LoadState.FAILED;\n        that._primitive.tileFailed.raiseEvent();\n        continue;\n      }\n      let addNodeIndex = 0;\n      if (megatexture.isFull()) {\n        // If the megatexture is full, try removing a discardable node with the lowest priority.\n        addNodeIndex = keyframeNodesInMegatextureCount - 1 - destroyedCount;\n        destroyedCount++;\n        const discardNode = keyframeNodesInMegatexture[addNodeIndex];\n        that._primitive.tileUnload.raiseEvent();\n        discardNode.spatialNode.destroyKeyframeNode(discardNode, that.megatextures);\n      } else {\n        addNodeIndex = keyframeNodesInMegatextureCount + addedCount;\n        addedCount++;\n      }\n      highPriorityKeyframeNode.spatialNode.addKeyframeNodeToMegatextures(highPriorityKeyframeNode, that.megatextures);\n      highPriorityKeyframeNode.state = KeyframeNode.LoadState.LOADED;\n      keyframeNodesInMegatexture[addNodeIndex] = highPriorityKeyframeNode;\n      that._primitive.tileLoad.raiseEvent();\n    }\n  }\n}\nfunction keyframeNodeSort(a, b) {\n  if (a.highPriorityFrameNumber === b.highPriorityFrameNumber) {\n    return b.priority - a.priority;\n  }\n  return b.highPriorityFrameNumber - a.highPriorityFrameNumber;\n}\n\n/**\n * Check if an array of metadata is of the expected type and size\n *\n * @param {TypedArray[]} metadata The metadata to validate\n * @param {VoxelTraversal} traversal The traversal to validate against\n * @returns {boolean} <code>true</code> if the metadata is valid, <code>false</code> otherwise\n *\n * @private\n */\nfunction validateMetadata(metadata, traversal) {\n  const length = traversal._primitive.provider.types.length;\n  if (!Array.isArray(metadata) || metadata.length !== length) {\n    return false;\n  }\n  const {\n    megatextures\n  } = traversal;\n  for (let i = 0; i < length; i++) {\n    const {\n      voxelCountPerTile,\n      channelCount\n    } = megatextures[i];\n    const {\n      x,\n      y,\n      z\n    } = voxelCountPerTile;\n    const tileVoxelCount = x * y * z;\n    const data = metadata[i];\n    const expectedLength = tileVoxelCount * channelCount;\n    if (data.length !== expectedLength) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @param {SpatialNode} spatialNode\n * @param {number} visibilityPlaneMask\n * @param {VoxelTraversal} that\n * @param {FrameState} frameState\n *\n * @private\n */\nfunction addToQueueRecursive(spatialNode, visibilityPlaneMask, that, frameState) {\n  const {\n    camera,\n    context,\n    pixelRatio,\n    frameNumber\n  } = frameState;\n  const {\n    positionWC,\n    frustum\n  } = camera;\n  const screenHeight = context.drawingBufferHeight / pixelRatio;\n  const screenSpaceErrorMultiplier = screenHeight / frustum.sseDenominator;\n  spatialNode.computeScreenSpaceError(positionWC, screenSpaceErrorMultiplier);\n  visibilityPlaneMask = spatialNode.visibility(frameState, visibilityPlaneMask);\n  if (visibilityPlaneMask === CullingVolume.MASK_OUTSIDE) {\n    return;\n  }\n  spatialNode.visitedFrameNumber = frameNumber;\n  const primitive = that._primitive;\n  const shape = primitive._shape;\n  const targetScreenSpaceError = primitive.screenSpaceError;\n  const priorityQueue = that._priorityQueue;\n  const keyframeCount = that._keyframeCount;\n  const previousKeyframe = CesiumMath.clamp(Math.floor(that._keyframeLocation), 0, keyframeCount - 2);\n  const nextKeyframe = previousKeyframe + 1;\n\n  // Create keyframe nodes at the playhead.\n  // If they already exist, nothing will be created.\n  if (keyframeCount === 1) {\n    spatialNode.createKeyframeNode(0);\n  } else if (spatialNode.keyframeNodes.length !== keyframeCount) {\n    for (let k = 0; k < keyframeCount; k++) {\n      spatialNode.createKeyframeNode(k);\n    }\n  }\n  const {\n    screenSpaceError,\n    keyframeNodes\n  } = spatialNode;\n  const ssePriority = mapInfiniteRangeToZeroOne(screenSpaceError);\n  let hasLoadedKeyframe = false;\n  for (let i = 0; i < keyframeNodes.length; i++) {\n    const keyframeNode = keyframeNodes[i];\n    keyframeNode.priority = 10.0 * ssePriority + keyframePriority(previousKeyframe, keyframeNode.keyframe, nextKeyframe, that);\n    if (keyframeNode.state !== KeyframeNode.LoadState.UNAVAILABLE && keyframeNode.state !== KeyframeNode.LoadState.FAILED && keyframeNode.priority !== -Number.MAX_VALUE) {\n      priorityQueue.insert(keyframeNode);\n    }\n    if (keyframeNode.state === KeyframeNode.LoadState.LOADED) {\n      hasLoadedKeyframe = true;\n    }\n  }\n  if (screenSpaceError < targetScreenSpaceError || !hasLoadedKeyframe) {\n    // Free up memory\n    spatialNode.children = undefined;\n    return;\n  }\n  if (!defined(spatialNode.children)) {\n    spatialNode.constructChildNodes(shape);\n  }\n  for (let childIndex = 0; childIndex < 8; childIndex++) {\n    const child = spatialNode.children[childIndex];\n    addToQueueRecursive(child, visibilityPlaneMask, that, frameState);\n  }\n}\n\n/**\n * Compute a priority for a keyframe node.\n *\n * @private\n * @param {number} previousKeyframe\n * @param {number} keyframe\n * @param {number} nextKeyframe\n * @param {VoxelTraversal} traversal\n * @returns {number} The computed priority\n */\nfunction keyframePriority(previousKeyframe, keyframe, nextKeyframe, traversal) {\n  const keyframeDifference = Math.min(Math.abs(keyframe - previousKeyframe), Math.abs(keyframe - nextKeyframe));\n  const maxKeyframeDifference = Math.max(previousKeyframe, traversal._keyframeCount - nextKeyframe - 1, 1);\n  const keyframeFactor = Math.pow(1.0 - keyframeDifference / maxKeyframeDifference, 4.0);\n  const binaryTreeFactor = Math.exp(-traversal._binaryTreeKeyframeWeighting[keyframe]);\n  return CesiumMath.lerp(binaryTreeFactor, keyframeFactor, 0.15 + 0.85 * keyframeFactor);\n}\n\n/**\n * @function\n *\n * @param {VoxelTraversal} that\n *\n * @private\n */\nfunction postPassesUpdate(that, frameState, loadAndUnloadTimeMs, generateOctreeTimeMs, totalTimeMs) {\n  const keyframeCount = that._keyframeCount;\n  const rootNode = that.rootNode;\n  const loadStateCount = Object.keys(KeyframeNode.LoadState).length;\n  const loadStatesByKeyframe = new Array(loadStateCount);\n  const loadStateByCount = new Array(loadStateCount);\n  let nodeCountTotal = 0;\n  for (let loadStateIndex = 0; loadStateIndex < loadStateCount; loadStateIndex++) {\n    const keyframeArray = new Array(keyframeCount).fill(0);\n    loadStatesByKeyframe[loadStateIndex] = keyframeArray;\n    loadStateByCount[loadStateIndex] = 0;\n  }\n\n  /**\n   * @param {SpatialNode} node\n   */\n  function traverseRecursive(node) {\n    const keyframeNodes = node.keyframeNodes;\n    for (let keyframeIndex = 0; keyframeIndex < keyframeNodes.length; keyframeIndex++) {\n      const keyframeNode = keyframeNodes[keyframeIndex];\n      const keyframe = keyframeNode.keyframe;\n      const state = keyframeNode.state;\n      loadStatesByKeyframe[state][keyframe] += 1;\n      loadStateByCount[state] += 1;\n      nodeCountTotal++;\n    }\n    if (defined(node.children)) {\n      for (let childIndex = 0; childIndex < 8; childIndex++) {\n        const child = node.children[childIndex];\n        traverseRecursive(child);\n      }\n    }\n  }\n  traverseRecursive(rootNode);\n  that._primitive.statistics.numberOfTilesWithContentReady = loadStateByCount[KeyframeNode.LoadState.LOADED];\n  that._primitive.statistics.visited = nodeCountTotal;\n  const numberOfPendingRequests = loadStateByCount[KeyframeNode.LoadState.RECEIVING];\n  const numberOfTilesProcessing = loadStateByCount[KeyframeNode.LoadState.PROCESSING];\n  const progressChanged = numberOfPendingRequests !== that._primitive.statistics.numberOfPendingRequests || numberOfTilesProcessing !== that._primitive.statistics.numberOfTilesProcessing;\n  if (progressChanged) {\n    frameState.afterRender.push(function () {\n      that._primitive.loadProgress.raiseEvent(numberOfPendingRequests, numberOfTilesProcessing);\n      return true;\n    });\n  }\n  that._primitive.statistics.numberOfPendingRequests = numberOfPendingRequests;\n  that._primitive.statistics.numberOfTilesProcessing = numberOfTilesProcessing;\n  const tilesLoaded = numberOfPendingRequests === 0 && numberOfTilesProcessing === 0;\n\n  // Events are raised (added to the afterRender queue) here since promises\n  // may resolve outside of the update loop that then raise events, e.g.,\n  // model's readyEvent\n  if (progressChanged && tilesLoaded) {\n    frameState.afterRender.push(function () {\n      that._primitive.allTilesLoaded.raiseEvent();\n      return true;\n    });\n    if (!that._initialTilesLoaded) {\n      that._initialTilesLoaded = true;\n      frameState.afterRender.push(function () {\n        that._primitive.initialTilesLoaded.raiseEvent();\n        return true;\n      });\n    }\n  }\n  if (!that._debugPrint) {\n    return;\n  }\n  const loadedKeyframeStatistics = `KEYFRAMES: ${loadStatesByKeyframe[KeyframeNode.LoadState.LOADED]}`;\n  const loadStateStatistics = `UNLOADED: ${loadStateByCount[KeyframeNode.LoadState.UNLOADED]} | ` + `RECEIVING: ${loadStateByCount[KeyframeNode.LoadState.RECEIVING]} | ` + `PROCESSING: ${loadStateByCount[KeyframeNode.LoadState.PROCESSING]} | ` + `LOADED: ${loadStateByCount[KeyframeNode.LoadState.LOADED]} | ` + `FAILED: ${loadStateByCount[KeyframeNode.LoadState.FAILED]} | ` + `UNAVAILABLE: ${loadStateByCount[KeyframeNode.LoadState.UNAVAILABLE]} | ` + `TOTAL: ${nodeCountTotal}`;\n  const loadAndUnloadTimeMsRounded = Math.round(loadAndUnloadTimeMs * 100) / 100;\n  const generateOctreeTimeMsRounded = Math.round(generateOctreeTimeMs * 100) / 100;\n  const totalTimeMsRounded = Math.round(totalTimeMs * 100) / 100;\n  const timerStatistics = `LOAD: ${loadAndUnloadTimeMsRounded} | ` + `OCT: ${generateOctreeTimeMsRounded} | ` + `ALL: ${totalTimeMsRounded}`;\n  console.log(`${loadedKeyframeStatistics} || ${loadStateStatistics} || ${timerStatistics}`);\n}\n\n// GPU Octree Layout\n// (shown as binary tree instead of octree for demonstration purposes)\n//\n// Tree representation:\n//           0\n//          / \\\n//         /   \\\n//        /     \\\n//       1       3\n//      / \\     / \\\n//     L0  2   L3 L4\n//        / \\\n//       L1 L2\n//\n//\n// Array representation:\n// L = leaf index\n// * = index to parent node\n// index:   0_______  1________  2________  3_________\n// array:  [*0, 1, 3, *0, L0, 2, *1 L1, L2, *0, L3, L4]\n//\n// The array is generated from a depth-first traversal. The end result could be an unbalanced tree,\n// so the parent index is stored at each node to make it possible to traverse upwards.\n\nconst GpuOctreeFlag = {\n  // Data is an octree index.\n  INTERNAL: 0,\n  // Data is a leaf node.\n  LEAF: 1,\n  // When leaf data is packed in the octree and there's a node that is forced to\n  // render but has no data of its own (such as when its siblings are renderable but it\n  // is not), signal that it's using its parent's data.\n  PACKED_LEAF_FROM_PARENT: 2\n};\n\n/**\n * @function\n *\n * @param {VoxelTraversal} that\n * @param {number} sampleCount\n * @param {number} levelBlendFactor\n * @private\n */\nfunction generateOctree(that, sampleCount, levelBlendFactor) {\n  const targetSse = that._primitive._screenSpaceError;\n  const keyframeLocation = that._keyframeLocation;\n  const frameNumber = that._frameNumber;\n  const useLeafNodes = sampleCount >= 2;\n  let internalNodeCount = 0;\n  let leafNodeCount = 0;\n  const internalNodeOctreeData = [];\n  const leafNodeOctreeData = [];\n\n  /**\n   * @param {SpatialNode} node\n   * @param {number} childOctreeIndex\n   * @param {number} childEntryIndex\n   * @param {number} parentOctreeIndex\n   * @param {number} parentEntryIndex\n   */\n  function buildOctree(node, childOctreeIndex, childEntryIndex, parentOctreeIndex, parentEntryIndex) {\n    let hasRenderableChildren = false;\n    if (defined(node.children)) {\n      for (let c = 0; c < 8; c++) {\n        const childNode = node.children[c];\n        childNode.computeSurroundingRenderableKeyframeNodes(keyframeLocation);\n        if (childNode.isRenderable(frameNumber)) {\n          hasRenderableChildren = true;\n        }\n      }\n    }\n    if (hasRenderableChildren) {\n      // Point the parent and child octree indexes at each other\n      internalNodeOctreeData[parentEntryIndex] = GpuOctreeFlag.INTERNAL << 16 | childOctreeIndex;\n      internalNodeOctreeData[childEntryIndex] = parentOctreeIndex;\n      internalNodeCount++;\n\n      // Recurse over children\n      parentOctreeIndex = childOctreeIndex;\n      parentEntryIndex = parentOctreeIndex * 9 + 1;\n      for (let cc = 0; cc < 8; cc++) {\n        const child = node.children[cc];\n        childOctreeIndex = internalNodeCount;\n        childEntryIndex = childOctreeIndex * 9 + 0;\n        buildOctree(child, childOctreeIndex, childEntryIndex, parentOctreeIndex, parentEntryIndex + cc);\n      }\n    } else {\n      // Store the leaf node information instead\n      // Recursion stops here because there are no renderable children\n      that._primitive.tileVisible.raiseEvent();\n      if (useLeafNodes) {\n        const baseIdx = leafNodeCount * 5;\n        const keyframeNode = node.renderableKeyframeNodePrevious;\n        const levelDifference = node.level - keyframeNode.spatialNode.level;\n        const parentNode = keyframeNode.spatialNode.parent;\n        const parentKeyframeNode = defined(parentNode) ? parentNode.renderableKeyframeNodePrevious : keyframeNode;\n        const lodLerp = getLodLerp(node, targetSse, levelBlendFactor);\n        const levelDifferenceChild = levelDifference;\n        const levelDifferenceParent = 1;\n        const megatextureIndexChild = keyframeNode.megatextureIndex;\n        const megatextureIndexParent = parentKeyframeNode.megatextureIndex;\n        leafNodeOctreeData[baseIdx + 0] = lodLerp;\n        leafNodeOctreeData[baseIdx + 1] = levelDifferenceChild;\n        leafNodeOctreeData[baseIdx + 2] = levelDifferenceParent;\n        leafNodeOctreeData[baseIdx + 3] = megatextureIndexChild;\n        leafNodeOctreeData[baseIdx + 4] = megatextureIndexParent;\n        internalNodeOctreeData[parentEntryIndex] = GpuOctreeFlag.LEAF << 16 | leafNodeCount;\n      } else {\n        const keyframeNode = node.renderableKeyframeNodePrevious;\n        const levelDifference = node.level - keyframeNode.spatialNode.level;\n        const flag = levelDifference === 0 ? GpuOctreeFlag.LEAF : GpuOctreeFlag.PACKED_LEAF_FROM_PARENT;\n        internalNodeOctreeData[parentEntryIndex] = flag << 16 | keyframeNode.megatextureIndex;\n      }\n      leafNodeCount++;\n    }\n  }\n  const rootNode = that.rootNode;\n  rootNode.computeSurroundingRenderableKeyframeNodes(keyframeLocation);\n  if (rootNode.isRenderable(frameNumber)) {\n    buildOctree(rootNode, 0, 0, 0, 0);\n  }\n  copyToInternalNodeTexture(internalNodeOctreeData, 9, that.internalNodeTilesPerRow, that.internalNodeTexture);\n  if (useLeafNodes) {\n    copyToLeafNodeTexture(leafNodeOctreeData, 2, that.leafNodeTilesPerRow, that.leafNodeTexture);\n  }\n}\n\n/**\n * Compute an interpolation factor between a node and its parent\n * @param {SpatialNode} node\n * @param {number} targetSse\n * @param {number} levelBlendFactor\n * @returns {number}\n * @private\n */\nfunction getLodLerp(node, targetSse, levelBlendFactor) {\n  if (node.parent === undefined) {\n    return 0.0;\n  }\n  const sse = node.screenSpaceError;\n  const parentSse = node.parent.screenSpaceError;\n  const lodLerp = (targetSse - sse) / (parentSse - sse);\n  const blended = (lodLerp + levelBlendFactor - 1.0) / levelBlendFactor;\n  return CesiumMath.clamp(blended, 0.0, 1.0);\n}\n\n/**\n *\n * @param {number[]} data\n * @param {number} texelsPerTile\n * @param {number} tilesPerRow\n * @param {Texture} texture\n * @private\n */\nfunction copyToInternalNodeTexture(data, texelsPerTile, tilesPerRow, texture) {\n  const channelCount = PixelFormat.componentsLength(texture.pixelFormat);\n  const tileCount = Math.ceil(data.length / texelsPerTile);\n  const copyWidth = Math.max(1, texelsPerTile * Math.min(tileCount, tilesPerRow));\n  const copyHeight = Math.max(1, Math.ceil(tileCount / tilesPerRow));\n  const textureData = new Uint8Array(copyWidth * copyHeight * channelCount);\n  for (let i = 0; i < data.length; i++) {\n    const val = data[i];\n    const startIndex = i * channelCount;\n    for (let j = 0; j < channelCount; j++) {\n      textureData[startIndex + j] = val >>> j * 8 & 0xff;\n    }\n  }\n  const source = {\n    arrayBufferView: textureData,\n    width: copyWidth,\n    height: copyHeight\n  };\n  const copyOptions = {\n    source: source,\n    xOffset: 0,\n    yOffset: 0\n  };\n  texture.copyFrom(copyOptions);\n}\n\n/**\n *\n * @param {number[]} data\n * @param {number} texelsPerTile\n * @param {number} tilesPerRow\n * @param {Texture} texture\n * @private\n */\nfunction copyToLeafNodeTexture(data, texelsPerTile, tilesPerRow, texture) {\n  const channelCount = PixelFormat.componentsLength(texture.pixelFormat);\n  const datasPerTile = 5;\n  const tileCount = Math.ceil(data.length / datasPerTile);\n  const copyWidth = Math.max(1, texelsPerTile * Math.min(tileCount, tilesPerRow));\n  const copyHeight = Math.max(1, Math.ceil(tileCount / tilesPerRow));\n  const textureData = new Uint8Array(copyWidth * copyHeight * channelCount);\n  for (let tileIndex = 0; tileIndex < tileCount; tileIndex++) {\n    const timeLerp = data[tileIndex * datasPerTile + 0];\n    const previousKeyframeLevelsAbove = data[tileIndex * datasPerTile + 1];\n    const nextKeyframeLevelsAbove = data[tileIndex * datasPerTile + 2];\n    const previousKeyframeMegatextureIndex = data[tileIndex * datasPerTile + 3];\n    const nextKeyframeMegatextureIndex = data[tileIndex * datasPerTile + 4];\n    const timeLerpCompressed = CesiumMath.clamp(Math.floor(65536 * timeLerp), 0, 65535);\n    textureData[tileIndex * 8 + 0] = timeLerpCompressed >>> 0 & 0xff;\n    textureData[tileIndex * 8 + 1] = timeLerpCompressed >>> 8 & 0xff;\n    textureData[tileIndex * 8 + 2] = previousKeyframeLevelsAbove & 0xff;\n    textureData[tileIndex * 8 + 3] = nextKeyframeLevelsAbove & 0xff;\n    textureData[tileIndex * 8 + 4] = previousKeyframeMegatextureIndex >>> 0 & 0xff;\n    textureData[tileIndex * 8 + 5] = previousKeyframeMegatextureIndex >>> 8 & 0xff;\n    textureData[tileIndex * 8 + 6] = nextKeyframeMegatextureIndex >>> 0 & 0xff;\n    textureData[tileIndex * 8 + 7] = nextKeyframeMegatextureIndex >>> 8 & 0xff;\n  }\n  const source = {\n    arrayBufferView: textureData,\n    width: copyWidth,\n    height: copyHeight\n  };\n  const copyOptions = {\n    source: source,\n    xOffset: 0,\n    yOffset: 0\n  };\n  texture.copyFrom(copyOptions);\n}\n\n/**\n * @param {number} tileCount\n * @param {Cartesian3} dimensions\n * @param {MetadataType[]} types\n * @param {MetadataComponentType[]} componentTypes\n * @private\n */\nfunction getApproximateTextureMemoryByteLength(tileCount, dimensions, types, componentTypes) {\n  let textureMemoryByteLength = 0;\n  const length = types.length;\n  for (let i = 0; i < length; i++) {\n    const type = types[i];\n    const componentType = componentTypes[i];\n    const componentCount = MetadataType.getComponentCount(type);\n    textureMemoryByteLength += Megatexture.getApproximateTextureMemoryByteLength(tileCount, dimensions, componentCount, componentType);\n  }\n  return textureMemoryByteLength;\n}\nexport default VoxelTraversal;","map":{"version":3,"names":["Cartesian2","Cartesian3","CesiumMath","CullingVolume","defined","destroyObject","DoubleEndedPriorityQueue","getTimestamp","KeyframeNode","MetadataType","Megatexture","PixelFormat","PixelDatatype","Sampler","SpatialNode","Texture","TextureMagnificationFilter","TextureMinificationFilter","VoxelMetadataOrder","VoxelTraversal","primitive","context","keyframeCount","maximumTextureMemoryByteLength","provider","dimensions","paddingBefore","paddingAfter","types","componentTypes","metadataOrder","inputDimensions","add","Y_UP","inputDimensionsY","y","z","maximumTileCount","getApproximateTextureMemoryByteLength","_primitive","textureMemoryByteLength","megatextures","Array","length","i","type","componentCount","getComponentCount","componentType","_simultaneousRequestCount","_debugPrint","_calculateStatistics","_frameNumber","shape","_shape","rootNode","undefined","_priorityQueue","maximumLength","comparator","priorityComparator","_highPriorityKeyframeNodes","_highPriorityKeyframeNodeCount","_keyframeNodesInMegatexture","_keyframeCount","_sampleCount","_keyframeLocation","_binaryTreeKeyframeWeighting","_initialTilesLoaded","binaryTreeKeyframeWeighting","binaryTreeWeightingRecursive","internalNodeTexelCount","internalNodeTextureDimensionX","internalNodeTilesPerRow","Math","floor","internalNodeTextureDimensionY","ceil","internalNodeTexture","pixelFormat","RGBA","pixelDatatype","UNSIGNED_BYTE","flipY","width","height","sampler","minificationFilter","NEAREST","magnificationFilter","internalNodeTexelSizeUv","leafNodeTexture","leafNodeTilesPerRow","leafNodeTexelSizeUv","prototype","findKeyframeNode","megatextureIndex","find","keyframeNode","arr","start","end","depth","mid","simultaneousRequestCountMaximum","update","frameState","keyframeLocation","recomputeBoundingVolumes","pauseUpdate","levelBlendFactor","_levelBlendFactor","hasLevelBlendFactor","hasKeyframes","sampleCount","useLeafNodes","leafNodeTexelCount","leafNodeTextureDimensionX","leafNodeTextureDimensionY","fromElements","destroy","clamp","recomputeBoundingVolumesRecursive","frameNumber","timestamp0","selectKeyframeNodes","updateKeyframeNodes","timestamp1","generateOctree","timestamp2","checkEventListeners","loadProgress","numberOfListeners","allTilesLoaded","initialTilesLoaded","loadAndUnloadTimeMs","generateOctreeTimeMs","totalTimeMs","postPassesUpdate","isRenderable","tile","isDestroyed","megatextureLength","that","node","computeBoundingVolumes","children","child","requestData","keyframe","spatialNode","availableLevels","level","postRequestSuccess","result","content","state","LoadState","PROCESSING","UNAVAILABLE","postRequestFailure","error","FAILED","tileFailed","raiseEvent","requestParameters","tileLevel","tileX","x","tileY","tileZ","promise","RECEIVING","then","catch","mapInfiniteRangeToZeroOne","priorityQueue","reset","addToQueueRecursive","MASK_INDETERMINATE","highPriorityKeyframeNodes","highPriorityKeyframeNodeCount","highPriorityKeyframeNode","removeMaximum","highPriorityFrameNumber","megatexture","keyframeNodesInMegatextureCount","occupiedCount","keyframeNodesInMegatexture","sort","keyframeNodeSort","destroyedCount","addedCount","highPriorityKeyframeNodeIndex","LOADED","UNLOADED","ready","validateMetadata","metadata","addNodeIndex","isFull","discardNode","tileUnload","destroyKeyframeNode","addKeyframeNodeToMegatextures","tileLoad","a","b","priority","traversal","isArray","voxelCountPerTile","channelCount","tileVoxelCount","data","expectedLength","visibilityPlaneMask","camera","pixelRatio","positionWC","frustum","screenHeight","drawingBufferHeight","screenSpaceErrorMultiplier","sseDenominator","computeScreenSpaceError","visibility","MASK_OUTSIDE","visitedFrameNumber","targetScreenSpaceError","screenSpaceError","previousKeyframe","nextKeyframe","createKeyframeNode","keyframeNodes","k","ssePriority","hasLoadedKeyframe","keyframePriority","Number","MAX_VALUE","insert","constructChildNodes","childIndex","keyframeDifference","min","abs","maxKeyframeDifference","max","keyframeFactor","pow","binaryTreeFactor","exp","lerp","loadStateCount","Object","keys","loadStatesByKeyframe","loadStateByCount","nodeCountTotal","loadStateIndex","keyframeArray","fill","traverseRecursive","keyframeIndex","statistics","numberOfTilesWithContentReady","visited","numberOfPendingRequests","numberOfTilesProcessing","progressChanged","afterRender","push","tilesLoaded","loadedKeyframeStatistics","loadStateStatistics","loadAndUnloadTimeMsRounded","round","generateOctreeTimeMsRounded","totalTimeMsRounded","timerStatistics","console","log","GpuOctreeFlag","INTERNAL","LEAF","PACKED_LEAF_FROM_PARENT","targetSse","_screenSpaceError","internalNodeCount","leafNodeCount","internalNodeOctreeData","leafNodeOctreeData","buildOctree","childOctreeIndex","childEntryIndex","parentOctreeIndex","parentEntryIndex","hasRenderableChildren","c","childNode","computeSurroundingRenderableKeyframeNodes","cc","tileVisible","baseIdx","renderableKeyframeNodePrevious","levelDifference","parentNode","parent","parentKeyframeNode","lodLerp","getLodLerp","levelDifferenceChild","levelDifferenceParent","megatextureIndexChild","megatextureIndexParent","flag","copyToInternalNodeTexture","copyToLeafNodeTexture","sse","parentSse","blended","texelsPerTile","tilesPerRow","texture","componentsLength","tileCount","copyWidth","copyHeight","textureData","Uint8Array","val","startIndex","j","source","arrayBufferView","copyOptions","xOffset","yOffset","copyFrom","datasPerTile","tileIndex","timeLerp","previousKeyframeLevelsAbove","nextKeyframeLevelsAbove","previousKeyframeMegatextureIndex","nextKeyframeMegatextureIndex","timeLerpCompressed"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/VoxelTraversal.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport CullingVolume from \"../Core/CullingVolume.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DoubleEndedPriorityQueue from \"../Core/DoubleEndedPriorityQueue.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport KeyframeNode from \"./KeyframeNode.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport Megatexture from \"./Megatexture.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport SpatialNode from \"./SpatialNode.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport VoxelMetadataOrder from \"./VoxelMetadataOrder.js\";\n\n/**\n * Handles tileset traversal, tile requests, and GPU resources. Intended to be\n * private and paired with a {@link VoxelPrimitive}, which has a user-facing API.\n *\n * @alias VoxelTraversal\n * @constructor\n *\n * @param {VoxelPrimitive} primitive The voxel primitive for which this traversal will be used.\n * @param {Context} context The context in which to create GPU resources.\n * @param {number} keyframeCount The number of keyframes in the tileset.\n * @param {number} [maximumTextureMemoryByteLength] The maximum amount of memory to use for textures.\n *\n * @private\n */\nfunction VoxelTraversal(\n  primitive,\n  context,\n  keyframeCount,\n  maximumTextureMemoryByteLength,\n) {\n  const { provider, dimensions, paddingBefore, paddingAfter } = primitive;\n  const { types, componentTypes, metadataOrder } = provider;\n\n  const inputDimensions = Cartesian3.add(\n    dimensions,\n    paddingBefore,\n    new Cartesian3(),\n  );\n  Cartesian3.add(inputDimensions, paddingAfter, inputDimensions);\n\n  if (metadataOrder === VoxelMetadataOrder.Y_UP) {\n    const inputDimensionsY = inputDimensions.y;\n    inputDimensions.y = inputDimensions.z;\n    inputDimensions.z = inputDimensionsY;\n  }\n\n  if (\n    !defined(maximumTextureMemoryByteLength) &&\n    defined(provider.maximumTileCount)\n  ) {\n    maximumTextureMemoryByteLength = getApproximateTextureMemoryByteLength(\n      provider.maximumTileCount,\n      inputDimensions,\n      types,\n      componentTypes,\n    );\n  }\n\n  /**\n   * @type {VoxelPrimitive}\n   * @private\n   */\n  this._primitive = primitive;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.textureMemoryByteLength = 0;\n\n  /**\n   * @type {Megatexture[]}\n   * @readonly\n   */\n  this.megatextures = new Array(types.length);\n\n  // TODO make sure to split the maximumTextureMemoryByteLength across all the megatextures\n  for (let i = 0; i < types.length; i++) {\n    const type = types[i];\n    const componentCount = MetadataType.getComponentCount(type);\n    const componentType = componentTypes[i];\n\n    this.megatextures[i] = new Megatexture(\n      context,\n      inputDimensions,\n      componentCount,\n      componentType,\n      maximumTextureMemoryByteLength,\n    );\n\n    this.textureMemoryByteLength +=\n      this.megatextures[i].textureMemoryByteLength;\n  }\n\n  const maximumTileCount = this.megatextures[0].maximumTileCount;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._simultaneousRequestCount = 0;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._debugPrint = false;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._calculateStatistics = this._primitive._calculateStatistics ?? false;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._frameNumber = 0;\n\n  const shape = primitive._shape;\n\n  /**\n   * @type {SpatialNode}\n   * @readonly\n   */\n  this.rootNode = new SpatialNode(0, 0, 0, 0, undefined, shape, dimensions);\n\n  /**\n   * @type {DoubleEndedPriorityQueue}\n   * @private\n   */\n  this._priorityQueue = new DoubleEndedPriorityQueue({\n    maximumLength: maximumTileCount,\n    comparator: KeyframeNode.priorityComparator,\n  });\n\n  /**\n   * @type {KeyframeNode[]}\n   * @private\n   */\n  this._highPriorityKeyframeNodes = new Array(maximumTileCount);\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._highPriorityKeyframeNodeCount = 0;\n\n  /**\n   * @type {KeyframeNode[]}\n   * @private\n   */\n  this._keyframeNodesInMegatexture = new Array(maximumTileCount);\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._keyframeCount = keyframeCount;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._sampleCount = undefined;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._keyframeLocation = 0;\n\n  /**\n   * @type {number[]}\n   * @private\n   */\n  this._binaryTreeKeyframeWeighting = new Array(keyframeCount);\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._initialTilesLoaded = false;\n\n  const binaryTreeKeyframeWeighting = this._binaryTreeKeyframeWeighting;\n  binaryTreeKeyframeWeighting[0] = 0;\n  binaryTreeKeyframeWeighting[keyframeCount - 1] = 0;\n  binaryTreeWeightingRecursive(\n    binaryTreeKeyframeWeighting,\n    1,\n    keyframeCount - 2,\n    0,\n  );\n\n  const internalNodeTexelCount = 9;\n  const internalNodeTextureDimensionX = 2048;\n  const internalNodeTilesPerRow = Math.floor(\n    internalNodeTextureDimensionX / internalNodeTexelCount,\n  );\n  const internalNodeTextureDimensionY = Math.ceil(\n    maximumTileCount / internalNodeTilesPerRow,\n  );\n\n  /**\n   * @type {Texture}\n   * @readonly\n   */\n  this.internalNodeTexture = new Texture({\n    context: context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    flipY: false,\n    width: internalNodeTextureDimensionX,\n    height: internalNodeTextureDimensionY,\n    sampler: new Sampler({\n      minificationFilter: TextureMinificationFilter.NEAREST,\n      magnificationFilter: TextureMagnificationFilter.NEAREST,\n    }),\n  });\n\n  /**\n   * @type {number}\n   * @readonly\n   */\n  this.internalNodeTilesPerRow = internalNodeTilesPerRow;\n\n  /**\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.internalNodeTexelSizeUv = new Cartesian2(\n    1.0 / internalNodeTextureDimensionX,\n    1.0 / internalNodeTextureDimensionY,\n  );\n\n  /**\n   * Only generated when there are two or more samples.\n   * @type {Texture}\n   * @readonly\n   */\n  this.leafNodeTexture = undefined;\n\n  /**\n   * Only generated when there are two or more samples.\n   * @type {number}\n   * @readonly\n   */\n  this.leafNodeTilesPerRow = undefined;\n\n  /**\n   * Only generated when there are two or more samples.\n   * @type {Cartesian2}\n   * @readonly\n   */\n  this.leafNodeTexelSizeUv = new Cartesian2();\n}\n\n/**\n * Finds a keyframe node in the traversal\n *\n * @param {number} megatextureIndex\n * @returns {KeyframeNode}\n */\nVoxelTraversal.prototype.findKeyframeNode = function (megatextureIndex) {\n  return this._keyframeNodesInMegatexture.find(function (keyframeNode) {\n    return keyframeNode.megatextureIndex === megatextureIndex;\n  });\n};\n\nfunction binaryTreeWeightingRecursive(arr, start, end, depth) {\n  if (start > end) {\n    return;\n  }\n  const mid = Math.floor((start + end) / 2);\n  arr[mid] = depth;\n  binaryTreeWeightingRecursive(arr, start, mid - 1, depth + 1);\n  binaryTreeWeightingRecursive(arr, mid + 1, end, depth + 1);\n}\n\nVoxelTraversal.simultaneousRequestCountMaximum = 50;\n\n/**\n * @param {FrameState} frameState\n * @param {number} keyframeLocation\n * @param {boolean} recomputeBoundingVolumes\n * @param {boolean} pauseUpdate\n */\nVoxelTraversal.prototype.update = function (\n  frameState,\n  keyframeLocation,\n  recomputeBoundingVolumes,\n  pauseUpdate,\n) {\n  const primitive = this._primitive;\n  const context = frameState.context;\n  const maximumTileCount = this.megatextures[0].maximumTileCount;\n  const keyframeCount = this._keyframeCount;\n\n  const levelBlendFactor = primitive._levelBlendFactor;\n  const hasLevelBlendFactor = levelBlendFactor > 0.0;\n  const hasKeyframes = keyframeCount > 1;\n  const sampleCount = (hasLevelBlendFactor ? 2 : 1) * (hasKeyframes ? 2 : 1);\n  this._sampleCount = sampleCount;\n\n  const useLeafNodes = sampleCount >= 2;\n  if (useLeafNodes && !defined(this.leafNodeTexture)) {\n    const leafNodeTexelCount = 2;\n    const leafNodeTextureDimensionX = 1024;\n    const leafNodeTilesPerRow = Math.floor(\n      leafNodeTextureDimensionX / leafNodeTexelCount,\n    );\n    const leafNodeTextureDimensionY = Math.ceil(\n      maximumTileCount / leafNodeTilesPerRow,\n    );\n\n    this.leafNodeTexture = new Texture({\n      context: context,\n      pixelFormat: PixelFormat.RGBA,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      flipY: false,\n      width: leafNodeTextureDimensionX,\n      height: leafNodeTextureDimensionY,\n      sampler: new Sampler({\n        minificationFilter: TextureMinificationFilter.NEAREST,\n        magnificationFilter: TextureMagnificationFilter.NEAREST,\n      }),\n    });\n    this.leafNodeTexelSizeUv = Cartesian2.fromElements(\n      1.0 / leafNodeTextureDimensionX,\n      1.0 / leafNodeTextureDimensionY,\n      this.leafNodeTexelSizeUv,\n    );\n    this.leafNodeTilesPerRow = leafNodeTilesPerRow;\n  } else if (!useLeafNodes && defined(this.leafNodeTexture)) {\n    this.leafNodeTexture = this.leafNodeTexture.destroy();\n  }\n\n  this._keyframeLocation = CesiumMath.clamp(\n    keyframeLocation,\n    0.0,\n    keyframeCount - 1,\n  );\n\n  if (recomputeBoundingVolumes) {\n    recomputeBoundingVolumesRecursive(this, this.rootNode);\n  }\n\n  if (pauseUpdate) {\n    return;\n  }\n\n  this._frameNumber = frameState.frameNumber;\n  const timestamp0 = getTimestamp();\n  selectKeyframeNodes(this, frameState);\n  updateKeyframeNodes(this, frameState);\n  const timestamp1 = getTimestamp();\n  generateOctree(this, sampleCount, levelBlendFactor);\n  const timestamp2 = getTimestamp();\n\n  const checkEventListeners =\n    primitive.loadProgress.numberOfListeners > 0 ||\n    primitive.allTilesLoaded.numberOfListeners > 0 ||\n    primitive.initialTilesLoaded.numberOfListeners > 0;\n\n  if (this._debugPrint || this._calculateStatistics || checkEventListeners) {\n    const loadAndUnloadTimeMs = timestamp1 - timestamp0;\n    const generateOctreeTimeMs = timestamp2 - timestamp1;\n    const totalTimeMs = timestamp2 - timestamp0;\n    postPassesUpdate(\n      this,\n      frameState,\n      loadAndUnloadTimeMs,\n      generateOctreeTimeMs,\n      totalTimeMs,\n    );\n  }\n};\n\n/**\n * Check if a node is renderable.\n * @param {SpatialNode} tile\n * @returns {boolean}\n */\nVoxelTraversal.prototype.isRenderable = function (tile) {\n  return tile.isRenderable(this._frameNumber);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see VoxelTraversal#destroy\n */\nVoxelTraversal.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see VoxelTraversal#isDestroyed\n *\n * @example\n * voxelTraversal = voxelTraversal && voxelTraversal.destroy();\n */\nVoxelTraversal.prototype.destroy = function () {\n  const megatextures = this.megatextures;\n  const megatextureLength = megatextures.length;\n  for (let i = 0; i < megatextureLength; i++) {\n    megatextures[i] = megatextures[i] && megatextures[i].destroy();\n  }\n  this.textureMemoryByteLength = 0;\n\n  this.internalNodeTexture =\n    this.internalNodeTexture && this.internalNodeTexture.destroy();\n\n  this.leafNodeTexture = this.leafNodeTexture && this.leafNodeTexture.destroy();\n\n  return destroyObject(this);\n};\n\n/**\n * @function\n *\n * @param {VoxelTraversal} that\n * @param {SpatialNode} node\n *\n * @private\n */\nfunction recomputeBoundingVolumesRecursive(that, node) {\n  node.computeBoundingVolumes(that._primitive._shape);\n  if (defined(node.children)) {\n    for (let i = 0; i < 8; i++) {\n      const child = node.children[i];\n      recomputeBoundingVolumesRecursive(that, child);\n    }\n  }\n}\n\n/**\n * @function\n *\n * @param {VoxelTraversal} that\n * @param {KeyframeNode} keyframeNode\n *\n * @private\n */\nfunction requestData(that, keyframeNode) {\n  if (\n    that._simultaneousRequestCount >=\n    VoxelTraversal.simultaneousRequestCountMaximum\n  ) {\n    return;\n  }\n\n  const primitive = that._primitive;\n  const provider = primitive.provider;\n  const { keyframe, spatialNode } = keyframeNode;\n  if (\n    defined(provider.availableLevels) &&\n    spatialNode.level >= provider.availableLevels\n  ) {\n    return;\n  }\n\n  function postRequestSuccess(result) {\n    that._simultaneousRequestCount--;\n    keyframeNode.content = result;\n    keyframeNode.state = defined(result)\n      ? KeyframeNode.LoadState.PROCESSING\n      : KeyframeNode.LoadState.UNAVAILABLE;\n  }\n\n  function postRequestFailure(error) {\n    that._simultaneousRequestCount--;\n    keyframeNode.state = KeyframeNode.LoadState.FAILED;\n    that._primitive.tileFailed.raiseEvent();\n  }\n\n  const requestParameters = {\n    tileLevel: spatialNode.level,\n    tileX: spatialNode.x,\n    tileY: spatialNode.y,\n    tileZ: spatialNode.z,\n    keyframe: keyframe,\n  };\n  const promise = provider.requestData(requestParameters);\n  if (!defined(promise)) {\n    return;\n  }\n  that._simultaneousRequestCount++;\n  keyframeNode.state = KeyframeNode.LoadState.RECEIVING;\n  promise.then(postRequestSuccess).catch(postRequestFailure);\n}\n\n/**\n * @function\n *\n * @param {number} x\n * @returns {number}\n *\n * @private\n */\nfunction mapInfiniteRangeToZeroOne(x) {\n  return x / (1.0 + x);\n}\n\n/**\n * @param {VoxelTraversal} that\n * @param {FrameState} frameState\n *\n * @private\n */\nfunction selectKeyframeNodes(that, frameState) {\n  const frameNumber = that._frameNumber;\n  const priorityQueue = that._priorityQueue;\n\n  // Add all the nodes to the queue, to sort them by priority.\n  priorityQueue.reset();\n  addToQueueRecursive(\n    that.rootNode,\n    CullingVolume.MASK_INDETERMINATE,\n    that,\n    frameState,\n  );\n\n  // Move the nodes from the queue to array of high priority nodes.\n  const highPriorityKeyframeNodes = that._highPriorityKeyframeNodes;\n  let highPriorityKeyframeNodeCount = 0;\n  let highPriorityKeyframeNode;\n  while (priorityQueue.length > 0) {\n    highPriorityKeyframeNode = priorityQueue.removeMaximum();\n    highPriorityKeyframeNode.highPriorityFrameNumber = frameNumber;\n    highPriorityKeyframeNodes[highPriorityKeyframeNodeCount] =\n      highPriorityKeyframeNode;\n    highPriorityKeyframeNodeCount++;\n  }\n  that._highPriorityKeyframeNodeCount = highPriorityKeyframeNodeCount;\n}\n\n/**\n * @param {VoxelTraversal} that\n * @param {FrameState} frameState\n *\n * @private\n */\nfunction updateKeyframeNodes(that, frameState) {\n  const megatexture = that.megatextures[0];\n  const keyframeNodesInMegatextureCount = megatexture.occupiedCount;\n\n  // Sort the list of keyframe nodes in the megatexture by priority, so\n  // we can remove the lowest priority nodes if we need space.\n  const keyframeNodesInMegatexture = that._keyframeNodesInMegatexture;\n  keyframeNodesInMegatexture.length = keyframeNodesInMegatextureCount;\n  keyframeNodesInMegatexture.sort(keyframeNodeSort);\n\n  // Add the high priority nodes to the megatexture,\n  // removing existing lower-priority nodes if necessary.\n  const highPriorityKeyframeNodes = that._highPriorityKeyframeNodes;\n  const highPriorityKeyframeNodeCount = that._highPriorityKeyframeNodeCount;\n  let destroyedCount = 0;\n  let addedCount = 0;\n\n  for (\n    let highPriorityKeyframeNodeIndex = 0;\n    highPriorityKeyframeNodeIndex < highPriorityKeyframeNodeCount;\n    highPriorityKeyframeNodeIndex++\n  ) {\n    const highPriorityKeyframeNode =\n      highPriorityKeyframeNodes[highPriorityKeyframeNodeIndex];\n\n    if (\n      highPriorityKeyframeNode.state === KeyframeNode.LoadState.LOADED ||\n      highPriorityKeyframeNode.spatialNode === undefined\n    ) {\n      // Already loaded, so nothing to do.\n      // Or destroyed when adding a higher priority node\n      continue;\n    }\n    if (highPriorityKeyframeNode.state === KeyframeNode.LoadState.UNLOADED) {\n      requestData(that, highPriorityKeyframeNode);\n    }\n    if (highPriorityKeyframeNode.state === KeyframeNode.LoadState.PROCESSING) {\n      const { content } = highPriorityKeyframeNode;\n      content.update(that._primitive, frameState);\n      if (!content.ready) {\n        continue;\n      }\n      if (!validateMetadata(content.metadata, that)) {\n        highPriorityKeyframeNode.content = undefined;\n        highPriorityKeyframeNode.state = KeyframeNode.LoadState.FAILED;\n        that._primitive.tileFailed.raiseEvent();\n        continue;\n      }\n      let addNodeIndex = 0;\n      if (megatexture.isFull()) {\n        // If the megatexture is full, try removing a discardable node with the lowest priority.\n        addNodeIndex = keyframeNodesInMegatextureCount - 1 - destroyedCount;\n        destroyedCount++;\n\n        const discardNode = keyframeNodesInMegatexture[addNodeIndex];\n        that._primitive.tileUnload.raiseEvent();\n        discardNode.spatialNode.destroyKeyframeNode(\n          discardNode,\n          that.megatextures,\n        );\n      } else {\n        addNodeIndex = keyframeNodesInMegatextureCount + addedCount;\n        addedCount++;\n      }\n      highPriorityKeyframeNode.spatialNode.addKeyframeNodeToMegatextures(\n        highPriorityKeyframeNode,\n        that.megatextures,\n      );\n      highPriorityKeyframeNode.state = KeyframeNode.LoadState.LOADED;\n      keyframeNodesInMegatexture[addNodeIndex] = highPriorityKeyframeNode;\n      that._primitive.tileLoad.raiseEvent();\n    }\n  }\n}\n\nfunction keyframeNodeSort(a, b) {\n  if (a.highPriorityFrameNumber === b.highPriorityFrameNumber) {\n    return b.priority - a.priority;\n  }\n  return b.highPriorityFrameNumber - a.highPriorityFrameNumber;\n}\n\n/**\n * Check if an array of metadata is of the expected type and size\n *\n * @param {TypedArray[]} metadata The metadata to validate\n * @param {VoxelTraversal} traversal The traversal to validate against\n * @returns {boolean} <code>true</code> if the metadata is valid, <code>false</code> otherwise\n *\n * @private\n */\nfunction validateMetadata(metadata, traversal) {\n  const length = traversal._primitive.provider.types.length;\n  if (!Array.isArray(metadata) || metadata.length !== length) {\n    return false;\n  }\n  const { megatextures } = traversal;\n  for (let i = 0; i < length; i++) {\n    const { voxelCountPerTile, channelCount } = megatextures[i];\n    const { x, y, z } = voxelCountPerTile;\n    const tileVoxelCount = x * y * z;\n\n    const data = metadata[i];\n    const expectedLength = tileVoxelCount * channelCount;\n    if (data.length !== expectedLength) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @param {SpatialNode} spatialNode\n * @param {number} visibilityPlaneMask\n * @param {VoxelTraversal} that\n * @param {FrameState} frameState\n *\n * @private\n */\nfunction addToQueueRecursive(\n  spatialNode,\n  visibilityPlaneMask,\n  that,\n  frameState,\n) {\n  const { camera, context, pixelRatio, frameNumber } = frameState;\n  const { positionWC, frustum } = camera;\n  const screenHeight = context.drawingBufferHeight / pixelRatio;\n  const screenSpaceErrorMultiplier = screenHeight / frustum.sseDenominator;\n\n  spatialNode.computeScreenSpaceError(positionWC, screenSpaceErrorMultiplier);\n\n  visibilityPlaneMask = spatialNode.visibility(frameState, visibilityPlaneMask);\n  if (visibilityPlaneMask === CullingVolume.MASK_OUTSIDE) {\n    return;\n  }\n  spatialNode.visitedFrameNumber = frameNumber;\n\n  const primitive = that._primitive;\n  const shape = primitive._shape;\n  const targetScreenSpaceError = primitive.screenSpaceError;\n  const priorityQueue = that._priorityQueue;\n  const keyframeCount = that._keyframeCount;\n  const previousKeyframe = CesiumMath.clamp(\n    Math.floor(that._keyframeLocation),\n    0,\n    keyframeCount - 2,\n  );\n  const nextKeyframe = previousKeyframe + 1;\n\n  // Create keyframe nodes at the playhead.\n  // If they already exist, nothing will be created.\n  if (keyframeCount === 1) {\n    spatialNode.createKeyframeNode(0);\n  } else if (spatialNode.keyframeNodes.length !== keyframeCount) {\n    for (let k = 0; k < keyframeCount; k++) {\n      spatialNode.createKeyframeNode(k);\n    }\n  }\n  const { screenSpaceError, keyframeNodes } = spatialNode;\n  const ssePriority = mapInfiniteRangeToZeroOne(screenSpaceError);\n\n  let hasLoadedKeyframe = false;\n  for (let i = 0; i < keyframeNodes.length; i++) {\n    const keyframeNode = keyframeNodes[i];\n\n    keyframeNode.priority =\n      10.0 * ssePriority +\n      keyframePriority(\n        previousKeyframe,\n        keyframeNode.keyframe,\n        nextKeyframe,\n        that,\n      );\n\n    if (\n      keyframeNode.state !== KeyframeNode.LoadState.UNAVAILABLE &&\n      keyframeNode.state !== KeyframeNode.LoadState.FAILED &&\n      keyframeNode.priority !== -Number.MAX_VALUE\n    ) {\n      priorityQueue.insert(keyframeNode);\n    }\n    if (keyframeNode.state === KeyframeNode.LoadState.LOADED) {\n      hasLoadedKeyframe = true;\n    }\n  }\n\n  if (screenSpaceError < targetScreenSpaceError || !hasLoadedKeyframe) {\n    // Free up memory\n    spatialNode.children = undefined;\n    return;\n  }\n\n  if (!defined(spatialNode.children)) {\n    spatialNode.constructChildNodes(shape);\n  }\n  for (let childIndex = 0; childIndex < 8; childIndex++) {\n    const child = spatialNode.children[childIndex];\n    addToQueueRecursive(child, visibilityPlaneMask, that, frameState);\n  }\n}\n\n/**\n * Compute a priority for a keyframe node.\n *\n * @private\n * @param {number} previousKeyframe\n * @param {number} keyframe\n * @param {number} nextKeyframe\n * @param {VoxelTraversal} traversal\n * @returns {number} The computed priority\n */\nfunction keyframePriority(previousKeyframe, keyframe, nextKeyframe, traversal) {\n  const keyframeDifference = Math.min(\n    Math.abs(keyframe - previousKeyframe),\n    Math.abs(keyframe - nextKeyframe),\n  );\n  const maxKeyframeDifference = Math.max(\n    previousKeyframe,\n    traversal._keyframeCount - nextKeyframe - 1,\n    1,\n  );\n  const keyframeFactor = Math.pow(\n    1.0 - keyframeDifference / maxKeyframeDifference,\n    4.0,\n  );\n  const binaryTreeFactor = Math.exp(\n    -traversal._binaryTreeKeyframeWeighting[keyframe],\n  );\n  return CesiumMath.lerp(\n    binaryTreeFactor,\n    keyframeFactor,\n    0.15 + 0.85 * keyframeFactor,\n  );\n}\n\n/**\n * @function\n *\n * @param {VoxelTraversal} that\n *\n * @private\n */\nfunction postPassesUpdate(\n  that,\n  frameState,\n  loadAndUnloadTimeMs,\n  generateOctreeTimeMs,\n  totalTimeMs,\n) {\n  const keyframeCount = that._keyframeCount;\n  const rootNode = that.rootNode;\n\n  const loadStateCount = Object.keys(KeyframeNode.LoadState).length;\n  const loadStatesByKeyframe = new Array(loadStateCount);\n  const loadStateByCount = new Array(loadStateCount);\n  let nodeCountTotal = 0;\n\n  for (\n    let loadStateIndex = 0;\n    loadStateIndex < loadStateCount;\n    loadStateIndex++\n  ) {\n    const keyframeArray = new Array(keyframeCount).fill(0);\n    loadStatesByKeyframe[loadStateIndex] = keyframeArray;\n    loadStateByCount[loadStateIndex] = 0;\n  }\n\n  /**\n   * @param {SpatialNode} node\n   */\n  function traverseRecursive(node) {\n    const keyframeNodes = node.keyframeNodes;\n    for (\n      let keyframeIndex = 0;\n      keyframeIndex < keyframeNodes.length;\n      keyframeIndex++\n    ) {\n      const keyframeNode = keyframeNodes[keyframeIndex];\n      const keyframe = keyframeNode.keyframe;\n      const state = keyframeNode.state;\n      loadStatesByKeyframe[state][keyframe] += 1;\n      loadStateByCount[state] += 1;\n      nodeCountTotal++;\n    }\n\n    if (defined(node.children)) {\n      for (let childIndex = 0; childIndex < 8; childIndex++) {\n        const child = node.children[childIndex];\n        traverseRecursive(child);\n      }\n    }\n  }\n  traverseRecursive(rootNode);\n\n  that._primitive.statistics.numberOfTilesWithContentReady =\n    loadStateByCount[KeyframeNode.LoadState.LOADED];\n  that._primitive.statistics.visited = nodeCountTotal;\n\n  const numberOfPendingRequests =\n    loadStateByCount[KeyframeNode.LoadState.RECEIVING];\n  const numberOfTilesProcessing =\n    loadStateByCount[KeyframeNode.LoadState.PROCESSING];\n\n  const progressChanged =\n    numberOfPendingRequests !==\n      that._primitive.statistics.numberOfPendingRequests ||\n    numberOfTilesProcessing !==\n      that._primitive.statistics.numberOfTilesProcessing;\n\n  if (progressChanged) {\n    frameState.afterRender.push(function () {\n      that._primitive.loadProgress.raiseEvent(\n        numberOfPendingRequests,\n        numberOfTilesProcessing,\n      );\n\n      return true;\n    });\n  }\n\n  that._primitive.statistics.numberOfPendingRequests = numberOfPendingRequests;\n  that._primitive.statistics.numberOfTilesProcessing = numberOfTilesProcessing;\n\n  const tilesLoaded =\n    numberOfPendingRequests === 0 && numberOfTilesProcessing === 0;\n\n  // Events are raised (added to the afterRender queue) here since promises\n  // may resolve outside of the update loop that then raise events, e.g.,\n  // model's readyEvent\n  if (progressChanged && tilesLoaded) {\n    frameState.afterRender.push(function () {\n      that._primitive.allTilesLoaded.raiseEvent();\n      return true;\n    });\n    if (!that._initialTilesLoaded) {\n      that._initialTilesLoaded = true;\n      frameState.afterRender.push(function () {\n        that._primitive.initialTilesLoaded.raiseEvent();\n        return true;\n      });\n    }\n  }\n\n  if (!that._debugPrint) {\n    return;\n  }\n\n  const loadedKeyframeStatistics = `KEYFRAMES: ${\n    loadStatesByKeyframe[KeyframeNode.LoadState.LOADED]\n  }`;\n  const loadStateStatistics =\n    `UNLOADED: ${loadStateByCount[KeyframeNode.LoadState.UNLOADED]} | ` +\n    `RECEIVING: ${loadStateByCount[KeyframeNode.LoadState.RECEIVING]} | ` +\n    `PROCESSING: ${loadStateByCount[KeyframeNode.LoadState.PROCESSING]} | ` +\n    `LOADED: ${loadStateByCount[KeyframeNode.LoadState.LOADED]} | ` +\n    `FAILED: ${loadStateByCount[KeyframeNode.LoadState.FAILED]} | ` +\n    `UNAVAILABLE: ${loadStateByCount[KeyframeNode.LoadState.UNAVAILABLE]} | ` +\n    `TOTAL: ${nodeCountTotal}`;\n\n  const loadAndUnloadTimeMsRounded =\n    Math.round(loadAndUnloadTimeMs * 100) / 100;\n  const generateOctreeTimeMsRounded =\n    Math.round(generateOctreeTimeMs * 100) / 100;\n  const totalTimeMsRounded = Math.round(totalTimeMs * 100) / 100;\n\n  const timerStatistics =\n    `LOAD: ${loadAndUnloadTimeMsRounded} | ` +\n    `OCT: ${generateOctreeTimeMsRounded} | ` +\n    `ALL: ${totalTimeMsRounded}`;\n\n  console.log(\n    `${loadedKeyframeStatistics} || ${loadStateStatistics} || ${timerStatistics}`,\n  );\n}\n\n// GPU Octree Layout\n// (shown as binary tree instead of octree for demonstration purposes)\n//\n// Tree representation:\n//           0\n//          / \\\n//         /   \\\n//        /     \\\n//       1       3\n//      / \\     / \\\n//     L0  2   L3 L4\n//        / \\\n//       L1 L2\n//\n//\n// Array representation:\n// L = leaf index\n// * = index to parent node\n// index:   0_______  1________  2________  3_________\n// array:  [*0, 1, 3, *0, L0, 2, *1 L1, L2, *0, L3, L4]\n//\n// The array is generated from a depth-first traversal. The end result could be an unbalanced tree,\n// so the parent index is stored at each node to make it possible to traverse upwards.\n\nconst GpuOctreeFlag = {\n  // Data is an octree index.\n  INTERNAL: 0,\n  // Data is a leaf node.\n  LEAF: 1,\n  // When leaf data is packed in the octree and there's a node that is forced to\n  // render but has no data of its own (such as when its siblings are renderable but it\n  // is not), signal that it's using its parent's data.\n  PACKED_LEAF_FROM_PARENT: 2,\n};\n\n/**\n * @function\n *\n * @param {VoxelTraversal} that\n * @param {number} sampleCount\n * @param {number} levelBlendFactor\n * @private\n */\nfunction generateOctree(that, sampleCount, levelBlendFactor) {\n  const targetSse = that._primitive._screenSpaceError;\n  const keyframeLocation = that._keyframeLocation;\n  const frameNumber = that._frameNumber;\n  const useLeafNodes = sampleCount >= 2;\n\n  let internalNodeCount = 0;\n  let leafNodeCount = 0;\n  const internalNodeOctreeData = [];\n  const leafNodeOctreeData = [];\n\n  /**\n   * @param {SpatialNode} node\n   * @param {number} childOctreeIndex\n   * @param {number} childEntryIndex\n   * @param {number} parentOctreeIndex\n   * @param {number} parentEntryIndex\n   */\n  function buildOctree(\n    node,\n    childOctreeIndex,\n    childEntryIndex,\n    parentOctreeIndex,\n    parentEntryIndex,\n  ) {\n    let hasRenderableChildren = false;\n    if (defined(node.children)) {\n      for (let c = 0; c < 8; c++) {\n        const childNode = node.children[c];\n        childNode.computeSurroundingRenderableKeyframeNodes(keyframeLocation);\n        if (childNode.isRenderable(frameNumber)) {\n          hasRenderableChildren = true;\n        }\n      }\n    }\n\n    if (hasRenderableChildren) {\n      // Point the parent and child octree indexes at each other\n      internalNodeOctreeData[parentEntryIndex] =\n        (GpuOctreeFlag.INTERNAL << 16) | childOctreeIndex;\n      internalNodeOctreeData[childEntryIndex] = parentOctreeIndex;\n      internalNodeCount++;\n\n      // Recurse over children\n      parentOctreeIndex = childOctreeIndex;\n      parentEntryIndex = parentOctreeIndex * 9 + 1;\n      for (let cc = 0; cc < 8; cc++) {\n        const child = node.children[cc];\n        childOctreeIndex = internalNodeCount;\n        childEntryIndex = childOctreeIndex * 9 + 0;\n        buildOctree(\n          child,\n          childOctreeIndex,\n          childEntryIndex,\n          parentOctreeIndex,\n          parentEntryIndex + cc,\n        );\n      }\n    } else {\n      // Store the leaf node information instead\n      // Recursion stops here because there are no renderable children\n      that._primitive.tileVisible.raiseEvent();\n      if (useLeafNodes) {\n        const baseIdx = leafNodeCount * 5;\n        const keyframeNode = node.renderableKeyframeNodePrevious;\n        const levelDifference = node.level - keyframeNode.spatialNode.level;\n\n        const parentNode = keyframeNode.spatialNode.parent;\n        const parentKeyframeNode = defined(parentNode)\n          ? parentNode.renderableKeyframeNodePrevious\n          : keyframeNode;\n\n        const lodLerp = getLodLerp(node, targetSse, levelBlendFactor);\n        const levelDifferenceChild = levelDifference;\n        const levelDifferenceParent = 1;\n        const megatextureIndexChild = keyframeNode.megatextureIndex;\n        const megatextureIndexParent = parentKeyframeNode.megatextureIndex;\n\n        leafNodeOctreeData[baseIdx + 0] = lodLerp;\n        leafNodeOctreeData[baseIdx + 1] = levelDifferenceChild;\n        leafNodeOctreeData[baseIdx + 2] = levelDifferenceParent;\n        leafNodeOctreeData[baseIdx + 3] = megatextureIndexChild;\n        leafNodeOctreeData[baseIdx + 4] = megatextureIndexParent;\n\n        internalNodeOctreeData[parentEntryIndex] =\n          (GpuOctreeFlag.LEAF << 16) | leafNodeCount;\n      } else {\n        const keyframeNode = node.renderableKeyframeNodePrevious;\n        const levelDifference = node.level - keyframeNode.spatialNode.level;\n        const flag =\n          levelDifference === 0\n            ? GpuOctreeFlag.LEAF\n            : GpuOctreeFlag.PACKED_LEAF_FROM_PARENT;\n        internalNodeOctreeData[parentEntryIndex] =\n          (flag << 16) | keyframeNode.megatextureIndex;\n      }\n      leafNodeCount++;\n    }\n  }\n\n  const rootNode = that.rootNode;\n  rootNode.computeSurroundingRenderableKeyframeNodes(keyframeLocation);\n  if (rootNode.isRenderable(frameNumber)) {\n    buildOctree(rootNode, 0, 0, 0, 0);\n  }\n\n  copyToInternalNodeTexture(\n    internalNodeOctreeData,\n    9,\n    that.internalNodeTilesPerRow,\n    that.internalNodeTexture,\n  );\n  if (useLeafNodes) {\n    copyToLeafNodeTexture(\n      leafNodeOctreeData,\n      2,\n      that.leafNodeTilesPerRow,\n      that.leafNodeTexture,\n    );\n  }\n}\n\n/**\n * Compute an interpolation factor between a node and its parent\n * @param {SpatialNode} node\n * @param {number} targetSse\n * @param {number} levelBlendFactor\n * @returns {number}\n * @private\n */\nfunction getLodLerp(node, targetSse, levelBlendFactor) {\n  if (node.parent === undefined) {\n    return 0.0;\n  }\n  const sse = node.screenSpaceError;\n  const parentSse = node.parent.screenSpaceError;\n  const lodLerp = (targetSse - sse) / (parentSse - sse);\n  const blended = (lodLerp + levelBlendFactor - 1.0) / levelBlendFactor;\n\n  return CesiumMath.clamp(blended, 0.0, 1.0);\n}\n\n/**\n *\n * @param {number[]} data\n * @param {number} texelsPerTile\n * @param {number} tilesPerRow\n * @param {Texture} texture\n * @private\n */\nfunction copyToInternalNodeTexture(data, texelsPerTile, tilesPerRow, texture) {\n  const channelCount = PixelFormat.componentsLength(texture.pixelFormat);\n  const tileCount = Math.ceil(data.length / texelsPerTile);\n  const copyWidth = Math.max(\n    1,\n    texelsPerTile * Math.min(tileCount, tilesPerRow),\n  );\n  const copyHeight = Math.max(1, Math.ceil(tileCount / tilesPerRow));\n\n  const textureData = new Uint8Array(copyWidth * copyHeight * channelCount);\n  for (let i = 0; i < data.length; i++) {\n    const val = data[i];\n    const startIndex = i * channelCount;\n    for (let j = 0; j < channelCount; j++) {\n      textureData[startIndex + j] = (val >>> (j * 8)) & 0xff;\n    }\n  }\n\n  const source = {\n    arrayBufferView: textureData,\n    width: copyWidth,\n    height: copyHeight,\n  };\n\n  const copyOptions = {\n    source: source,\n    xOffset: 0,\n    yOffset: 0,\n  };\n\n  texture.copyFrom(copyOptions);\n}\n\n/**\n *\n * @param {number[]} data\n * @param {number} texelsPerTile\n * @param {number} tilesPerRow\n * @param {Texture} texture\n * @private\n */\nfunction copyToLeafNodeTexture(data, texelsPerTile, tilesPerRow, texture) {\n  const channelCount = PixelFormat.componentsLength(texture.pixelFormat);\n  const datasPerTile = 5;\n  const tileCount = Math.ceil(data.length / datasPerTile);\n  const copyWidth = Math.max(\n    1,\n    texelsPerTile * Math.min(tileCount, tilesPerRow),\n  );\n  const copyHeight = Math.max(1, Math.ceil(tileCount / tilesPerRow));\n\n  const textureData = new Uint8Array(copyWidth * copyHeight * channelCount);\n  for (let tileIndex = 0; tileIndex < tileCount; tileIndex++) {\n    const timeLerp = data[tileIndex * datasPerTile + 0];\n    const previousKeyframeLevelsAbove = data[tileIndex * datasPerTile + 1];\n    const nextKeyframeLevelsAbove = data[tileIndex * datasPerTile + 2];\n    const previousKeyframeMegatextureIndex = data[tileIndex * datasPerTile + 3];\n    const nextKeyframeMegatextureIndex = data[tileIndex * datasPerTile + 4];\n\n    const timeLerpCompressed = CesiumMath.clamp(\n      Math.floor(65536 * timeLerp),\n      0,\n      65535,\n    );\n    textureData[tileIndex * 8 + 0] = (timeLerpCompressed >>> 0) & 0xff;\n    textureData[tileIndex * 8 + 1] = (timeLerpCompressed >>> 8) & 0xff;\n    textureData[tileIndex * 8 + 2] = previousKeyframeLevelsAbove & 0xff;\n    textureData[tileIndex * 8 + 3] = nextKeyframeLevelsAbove & 0xff;\n    textureData[tileIndex * 8 + 4] =\n      (previousKeyframeMegatextureIndex >>> 0) & 0xff;\n    textureData[tileIndex * 8 + 5] =\n      (previousKeyframeMegatextureIndex >>> 8) & 0xff;\n    textureData[tileIndex * 8 + 6] =\n      (nextKeyframeMegatextureIndex >>> 0) & 0xff;\n    textureData[tileIndex * 8 + 7] =\n      (nextKeyframeMegatextureIndex >>> 8) & 0xff;\n  }\n\n  const source = {\n    arrayBufferView: textureData,\n    width: copyWidth,\n    height: copyHeight,\n  };\n\n  const copyOptions = {\n    source: source,\n    xOffset: 0,\n    yOffset: 0,\n  };\n\n  texture.copyFrom(copyOptions);\n}\n\n/**\n * @param {number} tileCount\n * @param {Cartesian3} dimensions\n * @param {MetadataType[]} types\n * @param {MetadataComponentType[]} componentTypes\n * @private\n */\nfunction getApproximateTextureMemoryByteLength(\n  tileCount,\n  dimensions,\n  types,\n  componentTypes,\n) {\n  let textureMemoryByteLength = 0;\n\n  const length = types.length;\n  for (let i = 0; i < length; i++) {\n    const type = types[i];\n    const componentType = componentTypes[i];\n    const componentCount = MetadataType.getComponentCount(type);\n\n    textureMemoryByteLength +=\n      Megatexture.getApproximateTextureMemoryByteLength(\n        tileCount,\n        dimensions,\n        componentCount,\n        componentType,\n      );\n  }\n\n  return textureMemoryByteLength;\n}\n\nexport default VoxelTraversal;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}