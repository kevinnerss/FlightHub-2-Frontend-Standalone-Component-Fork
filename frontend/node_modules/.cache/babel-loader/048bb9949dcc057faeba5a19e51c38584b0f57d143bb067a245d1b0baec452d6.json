{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-hex.js\";\nimport \"core-js/modules/esnext.uint8-array.to-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.to-hex.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\n\n/**\n * Creates a texture to look up per instance attributes for batched primitives. For example, store each primitive's pick color in the texture.\n *\n * @alias BatchTable\n * @constructor\n * @private\n *\n * @param {Context} context The context in which the batch table is created.\n * @param {Object[]} attributes An array of objects describing a per instance attribute. Each object contains a datatype, components per attributes, whether it is normalized and a function name\n *     to retrieve the value in the vertex shader.\n * @param {number} numberOfInstances The number of instances in a batch table.\n *\n * @example\n * // create the batch table\n * const attributes = [{\n *     functionName : 'getShow',\n *     componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n *     componentsPerAttribute : 1\n * }, {\n *     functionName : 'getPickColor',\n *     componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n *     componentsPerAttribute : 4,\n *     normalize : true\n * }];\n * const batchTable = new BatchTable(context, attributes, 5);\n *\n * // when creating the draw commands, update the uniform map and the vertex shader\n * vertexShaderSource = batchTable.getVertexShaderCallback()(vertexShaderSource);\n * const shaderProgram = ShaderProgram.fromCache({\n *    // ...\n *    vertexShaderSource : vertexShaderSource,\n * });\n *\n * drawCommand.shaderProgram = shaderProgram;\n * drawCommand.uniformMap = batchTable.getUniformMapCallback()(uniformMap);\n *\n * // use the attribute function names in the shader to retrieve the instance values\n * // ...\n * attribute float batchId;\n *\n * void main() {\n *     // ...\n *     float show = getShow(batchId);\n *     vec3 pickColor = getPickColor(batchId);\n *     // ...\n * }\n */\nfunction BatchTable(context, attributes, numberOfInstances) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(context)) {\n    throw new DeveloperError(\"context is required\");\n  }\n  if (!defined(attributes)) {\n    throw new DeveloperError(\"attributes is required\");\n  }\n  if (!defined(numberOfInstances)) {\n    throw new DeveloperError(\"numberOfInstances is required\");\n  }\n  //>>includeEnd('debug');\n\n  this._attributes = attributes;\n  this._numberOfInstances = numberOfInstances;\n  if (attributes.length === 0) {\n    return;\n  }\n\n  // PERFORMANCE_IDEA: We may be able to arrange the attributes so they can be packing into fewer texels.\n  // Right now, an attribute with one component uses an entire texel when 4 single component attributes can\n  // be packed into a texel.\n  //\n  // Packing floats into unsigned byte textures makes the problem worse. A single component float attribute\n  // will be packed into a single texel leaving 3 texels unused. 4 texels are reserved for each float attribute\n  // regardless of how many components it has.\n  const pixelDatatype = getDatatype(attributes);\n  const textureFloatSupported = context.floatingPointTexture;\n  const packFloats = pixelDatatype === PixelDatatype.FLOAT && !textureFloatSupported;\n  const offsets = createOffsets(attributes, packFloats);\n  const stride = getStride(offsets, attributes, packFloats);\n  const maxNumberOfInstancesPerRow = Math.floor(ContextLimits.maximumTextureSize / stride);\n  const instancesPerWidth = Math.min(numberOfInstances, maxNumberOfInstancesPerRow);\n  const width = stride * instancesPerWidth;\n  const height = Math.ceil(numberOfInstances / instancesPerWidth);\n  const stepX = 1.0 / width;\n  const centerX = stepX * 0.5;\n  const stepY = 1.0 / height;\n  const centerY = stepY * 0.5;\n  this._textureDimensions = new Cartesian2(width, height);\n  this._textureStep = new Cartesian4(stepX, centerX, stepY, centerY);\n  this._pixelDatatype = !packFloats ? pixelDatatype : PixelDatatype.UNSIGNED_BYTE;\n  this._packFloats = packFloats;\n  this._offsets = offsets;\n  this._stride = stride;\n  this._texture = undefined;\n  const batchLength = 4 * width * height;\n  this._batchValues = pixelDatatype === PixelDatatype.FLOAT && !packFloats ? new Float32Array(batchLength) : new Uint8Array(batchLength);\n  this._batchValuesDirty = false;\n}\nObject.defineProperties(BatchTable.prototype, {\n  /**\n   * The attribute descriptions.\n   * @memberOf BatchTable.prototype\n   * @type {Object[]}\n   * @readonly\n   */\n  attributes: {\n    get: function () {\n      return this._attributes;\n    }\n  },\n  /**\n   * The number of instances.\n   * @memberOf BatchTable.prototype\n   * @type {number}\n   * @readonly\n   */\n  numberOfInstances: {\n    get: function () {\n      return this._numberOfInstances;\n    }\n  }\n});\nfunction getDatatype(attributes) {\n  let foundFloatDatatype = false;\n  const length = attributes.length;\n  for (let i = 0; i < length; ++i) {\n    if (attributes[i].componentDatatype !== ComponentDatatype.UNSIGNED_BYTE) {\n      foundFloatDatatype = true;\n      break;\n    }\n  }\n  return foundFloatDatatype ? PixelDatatype.FLOAT : PixelDatatype.UNSIGNED_BYTE;\n}\nfunction getAttributeType(attributes, attributeIndex) {\n  const componentsPerAttribute = attributes[attributeIndex].componentsPerAttribute;\n  if (componentsPerAttribute === 2) {\n    return Cartesian2;\n  } else if (componentsPerAttribute === 3) {\n    return Cartesian3;\n  } else if (componentsPerAttribute === 4) {\n    return Cartesian4;\n  }\n  return Number;\n}\nfunction createOffsets(attributes, packFloats) {\n  const offsets = new Array(attributes.length);\n  let currentOffset = 0;\n  const attributesLength = attributes.length;\n  for (let i = 0; i < attributesLength; ++i) {\n    const attribute = attributes[i];\n    const componentDatatype = attribute.componentDatatype;\n    offsets[i] = currentOffset;\n    if (componentDatatype !== ComponentDatatype.UNSIGNED_BYTE && packFloats) {\n      currentOffset += 4;\n    } else {\n      ++currentOffset;\n    }\n  }\n  return offsets;\n}\nfunction getStride(offsets, attributes, packFloats) {\n  const length = offsets.length;\n  const lastOffset = offsets[length - 1];\n  const lastAttribute = attributes[length - 1];\n  const componentDatatype = lastAttribute.componentDatatype;\n  if (componentDatatype !== ComponentDatatype.UNSIGNED_BYTE && packFloats) {\n    return lastOffset + 4;\n  }\n  return lastOffset + 1;\n}\nconst scratchPackedFloatCartesian4 = new Cartesian4();\nfunction getPackedFloat(array, index, result) {\n  let packed = Cartesian4.unpack(array, index, scratchPackedFloatCartesian4);\n  const x = Cartesian4.unpackFloat(packed);\n  packed = Cartesian4.unpack(array, index + 4, scratchPackedFloatCartesian4);\n  const y = Cartesian4.unpackFloat(packed);\n  packed = Cartesian4.unpack(array, index + 8, scratchPackedFloatCartesian4);\n  const z = Cartesian4.unpackFloat(packed);\n  packed = Cartesian4.unpack(array, index + 12, scratchPackedFloatCartesian4);\n  const w = Cartesian4.unpackFloat(packed);\n  return Cartesian4.fromElements(x, y, z, w, result);\n}\nfunction setPackedAttribute(value, array, index) {\n  let packed = Cartesian4.packFloat(value.x, scratchPackedFloatCartesian4);\n  Cartesian4.pack(packed, array, index);\n  packed = Cartesian4.packFloat(value.y, packed);\n  Cartesian4.pack(packed, array, index + 4);\n  packed = Cartesian4.packFloat(value.z, packed);\n  Cartesian4.pack(packed, array, index + 8);\n  packed = Cartesian4.packFloat(value.w, packed);\n  Cartesian4.pack(packed, array, index + 12);\n}\nconst scratchGetAttributeCartesian4 = new Cartesian4();\n\n/**\n * Gets the value of an attribute in the table.\n *\n * @param {number} instanceIndex The index of the instance.\n * @param {number} attributeIndex The index of the attribute.\n * @param {undefined|Cartesian2|Cartesian3|Cartesian4} [result] The object onto which to store the result. The type is dependent on the attribute's number of components.\n * @returns {number|Cartesian2|Cartesian3|Cartesian4} The attribute value stored for the instance.\n *\n * @exception {DeveloperError} instanceIndex is out of range.\n * @exception {DeveloperError} attributeIndex is out of range.\n */\nBatchTable.prototype.getBatchedAttribute = function (instanceIndex, attributeIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (instanceIndex < 0 || instanceIndex >= this._numberOfInstances) {\n    throw new DeveloperError(\"instanceIndex is out of range.\");\n  }\n  if (attributeIndex < 0 || attributeIndex >= this._attributes.length) {\n    throw new DeveloperError(\"attributeIndex is out of range\");\n  }\n  //>>includeEnd('debug');\n\n  const attributes = this._attributes;\n  const offset = this._offsets[attributeIndex];\n  const stride = this._stride;\n  const index = 4 * stride * instanceIndex + 4 * offset;\n  let value;\n  if (this._packFloats && attributes[attributeIndex].componentDatatype !== PixelDatatype.UNSIGNED_BYTE) {\n    value = getPackedFloat(this._batchValues, index, scratchGetAttributeCartesian4);\n  } else {\n    value = Cartesian4.unpack(this._batchValues, index, scratchGetAttributeCartesian4);\n  }\n  const attributeType = getAttributeType(attributes, attributeIndex);\n  if (defined(attributeType.fromCartesian4)) {\n    return attributeType.fromCartesian4(value, result);\n  } else if (defined(attributeType.clone)) {\n    return attributeType.clone(value, result);\n  }\n  return value.x;\n};\nconst setAttributeScratchValues = [undefined, undefined, new Cartesian2(), new Cartesian3(), new Cartesian4()];\nconst setAttributeScratchCartesian4 = new Cartesian4();\n\n/**\n * Sets the value of an attribute in the table.\n *\n * @param {number} instanceIndex The index of the instance.\n * @param {number} attributeIndex The index of the attribute.\n * @param {number|Cartesian2|Cartesian3|Cartesian4} value The value to be stored in the table. The type of value will depend on the number of components of the attribute.\n *\n * @exception {DeveloperError} instanceIndex is out of range.\n * @exception {DeveloperError} attributeIndex is out of range.\n */\nBatchTable.prototype.setBatchedAttribute = function (instanceIndex, attributeIndex, value) {\n  //>>includeStart('debug', pragmas.debug);\n  if (instanceIndex < 0 || instanceIndex >= this._numberOfInstances) {\n    throw new DeveloperError(\"instanceIndex is out of range.\");\n  }\n  if (attributeIndex < 0 || attributeIndex >= this._attributes.length) {\n    throw new DeveloperError(\"attributeIndex is out of range\");\n  }\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const attributes = this._attributes;\n  const result = setAttributeScratchValues[attributes[attributeIndex].componentsPerAttribute];\n  const currentAttribute = this.getBatchedAttribute(instanceIndex, attributeIndex, result);\n  const attributeType = getAttributeType(this._attributes, attributeIndex);\n  const entriesEqual = defined(attributeType.equals) ? attributeType.equals(currentAttribute, value) : currentAttribute === value;\n  if (entriesEqual) {\n    return;\n  }\n  const attributeValue = setAttributeScratchCartesian4;\n  attributeValue.x = defined(value.x) ? value.x : value;\n  attributeValue.y = defined(value.y) ? value.y : 0.0;\n  attributeValue.z = defined(value.z) ? value.z : 0.0;\n  attributeValue.w = defined(value.w) ? value.w : 0.0;\n  const offset = this._offsets[attributeIndex];\n  const stride = this._stride;\n  const index = 4 * stride * instanceIndex + 4 * offset;\n  if (this._packFloats && attributes[attributeIndex].componentDatatype !== PixelDatatype.UNSIGNED_BYTE) {\n    setPackedAttribute(attributeValue, this._batchValues, index);\n  } else {\n    Cartesian4.pack(attributeValue, this._batchValues, index);\n  }\n  this._batchValuesDirty = true;\n};\nfunction createTexture(batchTable, context) {\n  const dimensions = batchTable._textureDimensions;\n  batchTable._texture = new Texture({\n    context: context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: batchTable._pixelDatatype,\n    width: dimensions.x,\n    height: dimensions.y,\n    sampler: Sampler.NEAREST,\n    flipY: false\n  });\n}\nfunction updateTexture(batchTable) {\n  const dimensions = batchTable._textureDimensions;\n  batchTable._texture.copyFrom({\n    source: {\n      width: dimensions.x,\n      height: dimensions.y,\n      arrayBufferView: batchTable._batchValues\n    }\n  });\n}\n\n/**\n * Creates/updates the batch table texture.\n * @param {FrameState} frameState The frame state.\n *\n * @exception {RuntimeError} The floating point texture extension is required but not supported.\n */\nBatchTable.prototype.update = function (frameState) {\n  if (defined(this._texture) && !this._batchValuesDirty || this._attributes.length === 0) {\n    return;\n  }\n  this._batchValuesDirty = false;\n  if (!defined(this._texture)) {\n    createTexture(this, frameState.context);\n  }\n  updateTexture(this);\n};\n\n/**\n * Gets a function that will update a uniform map to contain values for looking up values in the batch table.\n *\n * @returns {BatchTable.updateUniformMapCallback} A callback for updating uniform maps.\n */\nBatchTable.prototype.getUniformMapCallback = function () {\n  const that = this;\n  return function (uniformMap) {\n    if (that._attributes.length === 0) {\n      return uniformMap;\n    }\n    const batchUniformMap = {\n      batchTexture: function () {\n        return that._texture;\n      },\n      batchTextureDimensions: function () {\n        return that._textureDimensions;\n      },\n      batchTextureStep: function () {\n        return that._textureStep;\n      }\n    };\n    return combine(uniformMap, batchUniformMap);\n  };\n};\nfunction getGlslComputeSt(batchTable) {\n  const stride = batchTable._stride;\n\n  // GLSL batchId is zero-based: [0, numberOfInstances - 1]\n  if (batchTable._textureDimensions.y === 1) {\n    return `${\"uniform vec4 batchTextureStep; \\n\" + \"vec2 computeSt(float batchId) \\n\" + \"{ \\n\" + \"    float stepX = batchTextureStep.x; \\n\" + \"    float centerX = batchTextureStep.y; \\n\" + \"    float numberOfAttributes = float(\"}${stride}); \\n` + `    return vec2(centerX + (batchId * numberOfAttributes * stepX), 0.5); \\n` + `} \\n`;\n  }\n  return `${\"uniform vec4 batchTextureStep; \\n\" + \"uniform vec2 batchTextureDimensions; \\n\" + \"vec2 computeSt(float batchId) \\n\" + \"{ \\n\" + \"    float stepX = batchTextureStep.x; \\n\" + \"    float centerX = batchTextureStep.y; \\n\" + \"    float stepY = batchTextureStep.z; \\n\" + \"    float centerY = batchTextureStep.w; \\n\" + \"    float numberOfAttributes = float(\"}${stride}); \\n` + `    float xId = mod(batchId * numberOfAttributes, batchTextureDimensions.x); \\n` + `    float yId = floor(batchId * numberOfAttributes / batchTextureDimensions.x); \\n` + `    return vec2(centerX + (xId * stepX), centerY + (yId * stepY)); \\n` + `} \\n`;\n}\nfunction getComponentType(componentsPerAttribute) {\n  if (componentsPerAttribute === 1) {\n    return \"float\";\n  }\n  return `vec${componentsPerAttribute}`;\n}\nfunction getComponentSwizzle(componentsPerAttribute) {\n  if (componentsPerAttribute === 1) {\n    return \".x\";\n  } else if (componentsPerAttribute === 2) {\n    return \".xy\";\n  } else if (componentsPerAttribute === 3) {\n    return \".xyz\";\n  }\n  return \"\";\n}\nfunction getGlslAttributeFunction(batchTable, attributeIndex) {\n  const attributes = batchTable._attributes;\n  const attribute = attributes[attributeIndex];\n  const componentsPerAttribute = attribute.componentsPerAttribute;\n  const functionName = attribute.functionName;\n  const functionReturnType = getComponentType(componentsPerAttribute);\n  const functionReturnValue = getComponentSwizzle(componentsPerAttribute);\n  const offset = batchTable._offsets[attributeIndex];\n  let glslFunction = `${functionReturnType} ${functionName}(float batchId) \\n` + `{ \\n` + `    vec2 st = computeSt(batchId); \\n` + `    st.x += batchTextureStep.x * float(${offset}); \\n`;\n  if (batchTable._packFloats && attribute.componentDatatype !== PixelDatatype.UNSIGNED_BYTE) {\n    glslFunction += \"vec4 textureValue; \\n\" + \"textureValue.x = czm_unpackFloat(texture(batchTexture, st)); \\n\" + \"textureValue.y = czm_unpackFloat(texture(batchTexture, st + vec2(batchTextureStep.x, 0.0))); \\n\" + \"textureValue.z = czm_unpackFloat(texture(batchTexture, st + vec2(batchTextureStep.x * 2.0, 0.0))); \\n\" + \"textureValue.w = czm_unpackFloat(texture(batchTexture, st + vec2(batchTextureStep.x * 3.0, 0.0))); \\n\";\n  } else {\n    glslFunction += \"    vec4 textureValue = texture(batchTexture, st); \\n\";\n  }\n  glslFunction += `    ${functionReturnType} value = textureValue${functionReturnValue}; \\n`;\n  if (batchTable._pixelDatatype === PixelDatatype.UNSIGNED_BYTE && attribute.componentDatatype === ComponentDatatype.UNSIGNED_BYTE && !attribute.normalize) {\n    glslFunction += \"value *= 255.0; \\n\";\n  } else if (batchTable._pixelDatatype === PixelDatatype.FLOAT && attribute.componentDatatype === ComponentDatatype.UNSIGNED_BYTE && attribute.normalize) {\n    glslFunction += \"value /= 255.0; \\n\";\n  }\n  glslFunction += \"    return value; \\n\" + \"} \\n\";\n  return glslFunction;\n}\n\n/**\n * Gets a function that will update a vertex shader to contain functions for looking up values in the batch table.\n *\n * @returns {BatchTable.updateVertexShaderSourceCallback} A callback for updating a vertex shader source.\n */\nBatchTable.prototype.getVertexShaderCallback = function () {\n  const attributes = this._attributes;\n  if (attributes.length === 0) {\n    return function (source) {\n      return source;\n    };\n  }\n  let batchTableShader = \"uniform highp sampler2D batchTexture; \\n\";\n  batchTableShader += `${getGlslComputeSt(this)}\\n`;\n  const length = attributes.length;\n  for (let i = 0; i < length; ++i) {\n    batchTableShader += getGlslAttributeFunction(this, i);\n  }\n  return function (source) {\n    const mainIndex = source.indexOf(\"void main\");\n    const beforeMain = source.substring(0, mainIndex);\n    const afterMain = source.substring(mainIndex);\n    return `${beforeMain}\\n${batchTableShader}\\n${afterMain}`;\n  };\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see BatchTable#destroy\n */\nBatchTable.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see BatchTable#isDestroyed\n */\nBatchTable.prototype.destroy = function () {\n  this._texture = this._texture && this._texture.destroy();\n  return destroyObject(this);\n};\n\n/**\n * A callback for updating uniform maps.\n * @callback BatchTable.updateUniformMapCallback\n *\n * @param {object} uniformMap The uniform map.\n * @returns {object} The new uniform map with properties for retrieving values from the batch table.\n */\n\n/**\n * A callback for updating a vertex shader source.\n * @callback BatchTable.updateVertexShaderSourceCallback\n *\n * @param {string} vertexShaderSource The vertex shader source.\n * @returns {string} The new vertex shader source with the functions for retrieving batch table values injected.\n */\nexport default BatchTable;","map":{"version":3,"names":["Cartesian2","Cartesian3","Cartesian4","combine","ComponentDatatype","defined","destroyObject","DeveloperError","PixelFormat","ContextLimits","PixelDatatype","Sampler","Texture","BatchTable","context","attributes","numberOfInstances","_attributes","_numberOfInstances","length","pixelDatatype","getDatatype","textureFloatSupported","floatingPointTexture","packFloats","FLOAT","offsets","createOffsets","stride","getStride","maxNumberOfInstancesPerRow","Math","floor","maximumTextureSize","instancesPerWidth","min","width","height","ceil","stepX","centerX","stepY","centerY","_textureDimensions","_textureStep","_pixelDatatype","UNSIGNED_BYTE","_packFloats","_offsets","_stride","_texture","undefined","batchLength","_batchValues","Float32Array","Uint8Array","_batchValuesDirty","Object","defineProperties","prototype","get","foundFloatDatatype","i","componentDatatype","getAttributeType","attributeIndex","componentsPerAttribute","Number","Array","currentOffset","attributesLength","attribute","lastOffset","lastAttribute","scratchPackedFloatCartesian4","getPackedFloat","array","index","result","packed","unpack","x","unpackFloat","y","z","w","fromElements","setPackedAttribute","value","packFloat","pack","scratchGetAttributeCartesian4","getBatchedAttribute","instanceIndex","offset","attributeType","fromCartesian4","clone","setAttributeScratchValues","setAttributeScratchCartesian4","setBatchedAttribute","currentAttribute","entriesEqual","equals","attributeValue","createTexture","batchTable","dimensions","pixelFormat","RGBA","sampler","NEAREST","flipY","updateTexture","copyFrom","source","arrayBufferView","update","frameState","getUniformMapCallback","that","uniformMap","batchUniformMap","batchTexture","batchTextureDimensions","batchTextureStep","getGlslComputeSt","getComponentType","getComponentSwizzle","getGlslAttributeFunction","functionName","functionReturnType","functionReturnValue","glslFunction","normalize","getVertexShaderCallback","batchTableShader","mainIndex","indexOf","beforeMain","substring","afterMain","isDestroyed","destroy"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/BatchTable.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\n\n/**\n * Creates a texture to look up per instance attributes for batched primitives. For example, store each primitive's pick color in the texture.\n *\n * @alias BatchTable\n * @constructor\n * @private\n *\n * @param {Context} context The context in which the batch table is created.\n * @param {Object[]} attributes An array of objects describing a per instance attribute. Each object contains a datatype, components per attributes, whether it is normalized and a function name\n *     to retrieve the value in the vertex shader.\n * @param {number} numberOfInstances The number of instances in a batch table.\n *\n * @example\n * // create the batch table\n * const attributes = [{\n *     functionName : 'getShow',\n *     componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n *     componentsPerAttribute : 1\n * }, {\n *     functionName : 'getPickColor',\n *     componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n *     componentsPerAttribute : 4,\n *     normalize : true\n * }];\n * const batchTable = new BatchTable(context, attributes, 5);\n *\n * // when creating the draw commands, update the uniform map and the vertex shader\n * vertexShaderSource = batchTable.getVertexShaderCallback()(vertexShaderSource);\n * const shaderProgram = ShaderProgram.fromCache({\n *    // ...\n *    vertexShaderSource : vertexShaderSource,\n * });\n *\n * drawCommand.shaderProgram = shaderProgram;\n * drawCommand.uniformMap = batchTable.getUniformMapCallback()(uniformMap);\n *\n * // use the attribute function names in the shader to retrieve the instance values\n * // ...\n * attribute float batchId;\n *\n * void main() {\n *     // ...\n *     float show = getShow(batchId);\n *     vec3 pickColor = getPickColor(batchId);\n *     // ...\n * }\n */\nfunction BatchTable(context, attributes, numberOfInstances) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(context)) {\n    throw new DeveloperError(\"context is required\");\n  }\n  if (!defined(attributes)) {\n    throw new DeveloperError(\"attributes is required\");\n  }\n  if (!defined(numberOfInstances)) {\n    throw new DeveloperError(\"numberOfInstances is required\");\n  }\n  //>>includeEnd('debug');\n\n  this._attributes = attributes;\n  this._numberOfInstances = numberOfInstances;\n\n  if (attributes.length === 0) {\n    return;\n  }\n\n  // PERFORMANCE_IDEA: We may be able to arrange the attributes so they can be packing into fewer texels.\n  // Right now, an attribute with one component uses an entire texel when 4 single component attributes can\n  // be packed into a texel.\n  //\n  // Packing floats into unsigned byte textures makes the problem worse. A single component float attribute\n  // will be packed into a single texel leaving 3 texels unused. 4 texels are reserved for each float attribute\n  // regardless of how many components it has.\n  const pixelDatatype = getDatatype(attributes);\n  const textureFloatSupported = context.floatingPointTexture;\n  const packFloats =\n    pixelDatatype === PixelDatatype.FLOAT && !textureFloatSupported;\n  const offsets = createOffsets(attributes, packFloats);\n\n  const stride = getStride(offsets, attributes, packFloats);\n  const maxNumberOfInstancesPerRow = Math.floor(\n    ContextLimits.maximumTextureSize / stride,\n  );\n\n  const instancesPerWidth = Math.min(\n    numberOfInstances,\n    maxNumberOfInstancesPerRow,\n  );\n  const width = stride * instancesPerWidth;\n  const height = Math.ceil(numberOfInstances / instancesPerWidth);\n\n  const stepX = 1.0 / width;\n  const centerX = stepX * 0.5;\n  const stepY = 1.0 / height;\n  const centerY = stepY * 0.5;\n\n  this._textureDimensions = new Cartesian2(width, height);\n  this._textureStep = new Cartesian4(stepX, centerX, stepY, centerY);\n  this._pixelDatatype = !packFloats\n    ? pixelDatatype\n    : PixelDatatype.UNSIGNED_BYTE;\n  this._packFloats = packFloats;\n  this._offsets = offsets;\n  this._stride = stride;\n  this._texture = undefined;\n\n  const batchLength = 4 * width * height;\n  this._batchValues =\n    pixelDatatype === PixelDatatype.FLOAT && !packFloats\n      ? new Float32Array(batchLength)\n      : new Uint8Array(batchLength);\n  this._batchValuesDirty = false;\n}\n\nObject.defineProperties(BatchTable.prototype, {\n  /**\n   * The attribute descriptions.\n   * @memberOf BatchTable.prototype\n   * @type {Object[]}\n   * @readonly\n   */\n  attributes: {\n    get: function () {\n      return this._attributes;\n    },\n  },\n  /**\n   * The number of instances.\n   * @memberOf BatchTable.prototype\n   * @type {number}\n   * @readonly\n   */\n  numberOfInstances: {\n    get: function () {\n      return this._numberOfInstances;\n    },\n  },\n});\n\nfunction getDatatype(attributes) {\n  let foundFloatDatatype = false;\n  const length = attributes.length;\n  for (let i = 0; i < length; ++i) {\n    if (attributes[i].componentDatatype !== ComponentDatatype.UNSIGNED_BYTE) {\n      foundFloatDatatype = true;\n      break;\n    }\n  }\n  return foundFloatDatatype ? PixelDatatype.FLOAT : PixelDatatype.UNSIGNED_BYTE;\n}\n\nfunction getAttributeType(attributes, attributeIndex) {\n  const componentsPerAttribute =\n    attributes[attributeIndex].componentsPerAttribute;\n  if (componentsPerAttribute === 2) {\n    return Cartesian2;\n  } else if (componentsPerAttribute === 3) {\n    return Cartesian3;\n  } else if (componentsPerAttribute === 4) {\n    return Cartesian4;\n  }\n  return Number;\n}\n\nfunction createOffsets(attributes, packFloats) {\n  const offsets = new Array(attributes.length);\n\n  let currentOffset = 0;\n  const attributesLength = attributes.length;\n  for (let i = 0; i < attributesLength; ++i) {\n    const attribute = attributes[i];\n    const componentDatatype = attribute.componentDatatype;\n\n    offsets[i] = currentOffset;\n\n    if (componentDatatype !== ComponentDatatype.UNSIGNED_BYTE && packFloats) {\n      currentOffset += 4;\n    } else {\n      ++currentOffset;\n    }\n  }\n\n  return offsets;\n}\n\nfunction getStride(offsets, attributes, packFloats) {\n  const length = offsets.length;\n  const lastOffset = offsets[length - 1];\n  const lastAttribute = attributes[length - 1];\n  const componentDatatype = lastAttribute.componentDatatype;\n\n  if (componentDatatype !== ComponentDatatype.UNSIGNED_BYTE && packFloats) {\n    return lastOffset + 4;\n  }\n  return lastOffset + 1;\n}\n\nconst scratchPackedFloatCartesian4 = new Cartesian4();\n\nfunction getPackedFloat(array, index, result) {\n  let packed = Cartesian4.unpack(array, index, scratchPackedFloatCartesian4);\n  const x = Cartesian4.unpackFloat(packed);\n\n  packed = Cartesian4.unpack(array, index + 4, scratchPackedFloatCartesian4);\n  const y = Cartesian4.unpackFloat(packed);\n\n  packed = Cartesian4.unpack(array, index + 8, scratchPackedFloatCartesian4);\n  const z = Cartesian4.unpackFloat(packed);\n\n  packed = Cartesian4.unpack(array, index + 12, scratchPackedFloatCartesian4);\n  const w = Cartesian4.unpackFloat(packed);\n\n  return Cartesian4.fromElements(x, y, z, w, result);\n}\n\nfunction setPackedAttribute(value, array, index) {\n  let packed = Cartesian4.packFloat(value.x, scratchPackedFloatCartesian4);\n  Cartesian4.pack(packed, array, index);\n\n  packed = Cartesian4.packFloat(value.y, packed);\n  Cartesian4.pack(packed, array, index + 4);\n\n  packed = Cartesian4.packFloat(value.z, packed);\n  Cartesian4.pack(packed, array, index + 8);\n\n  packed = Cartesian4.packFloat(value.w, packed);\n  Cartesian4.pack(packed, array, index + 12);\n}\n\nconst scratchGetAttributeCartesian4 = new Cartesian4();\n\n/**\n * Gets the value of an attribute in the table.\n *\n * @param {number} instanceIndex The index of the instance.\n * @param {number} attributeIndex The index of the attribute.\n * @param {undefined|Cartesian2|Cartesian3|Cartesian4} [result] The object onto which to store the result. The type is dependent on the attribute's number of components.\n * @returns {number|Cartesian2|Cartesian3|Cartesian4} The attribute value stored for the instance.\n *\n * @exception {DeveloperError} instanceIndex is out of range.\n * @exception {DeveloperError} attributeIndex is out of range.\n */\nBatchTable.prototype.getBatchedAttribute = function (\n  instanceIndex,\n  attributeIndex,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (instanceIndex < 0 || instanceIndex >= this._numberOfInstances) {\n    throw new DeveloperError(\"instanceIndex is out of range.\");\n  }\n  if (attributeIndex < 0 || attributeIndex >= this._attributes.length) {\n    throw new DeveloperError(\"attributeIndex is out of range\");\n  }\n  //>>includeEnd('debug');\n\n  const attributes = this._attributes;\n  const offset = this._offsets[attributeIndex];\n  const stride = this._stride;\n\n  const index = 4 * stride * instanceIndex + 4 * offset;\n  let value;\n\n  if (\n    this._packFloats &&\n    attributes[attributeIndex].componentDatatype !== PixelDatatype.UNSIGNED_BYTE\n  ) {\n    value = getPackedFloat(\n      this._batchValues,\n      index,\n      scratchGetAttributeCartesian4,\n    );\n  } else {\n    value = Cartesian4.unpack(\n      this._batchValues,\n      index,\n      scratchGetAttributeCartesian4,\n    );\n  }\n\n  const attributeType = getAttributeType(attributes, attributeIndex);\n  if (defined(attributeType.fromCartesian4)) {\n    return attributeType.fromCartesian4(value, result);\n  } else if (defined(attributeType.clone)) {\n    return attributeType.clone(value, result);\n  }\n\n  return value.x;\n};\n\nconst setAttributeScratchValues = [\n  undefined,\n  undefined,\n  new Cartesian2(),\n  new Cartesian3(),\n  new Cartesian4(),\n];\nconst setAttributeScratchCartesian4 = new Cartesian4();\n\n/**\n * Sets the value of an attribute in the table.\n *\n * @param {number} instanceIndex The index of the instance.\n * @param {number} attributeIndex The index of the attribute.\n * @param {number|Cartesian2|Cartesian3|Cartesian4} value The value to be stored in the table. The type of value will depend on the number of components of the attribute.\n *\n * @exception {DeveloperError} instanceIndex is out of range.\n * @exception {DeveloperError} attributeIndex is out of range.\n */\nBatchTable.prototype.setBatchedAttribute = function (\n  instanceIndex,\n  attributeIndex,\n  value,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (instanceIndex < 0 || instanceIndex >= this._numberOfInstances) {\n    throw new DeveloperError(\"instanceIndex is out of range.\");\n  }\n  if (attributeIndex < 0 || attributeIndex >= this._attributes.length) {\n    throw new DeveloperError(\"attributeIndex is out of range\");\n  }\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const attributes = this._attributes;\n  const result =\n    setAttributeScratchValues[\n      attributes[attributeIndex].componentsPerAttribute\n    ];\n  const currentAttribute = this.getBatchedAttribute(\n    instanceIndex,\n    attributeIndex,\n    result,\n  );\n  const attributeType = getAttributeType(this._attributes, attributeIndex);\n  const entriesEqual = defined(attributeType.equals)\n    ? attributeType.equals(currentAttribute, value)\n    : currentAttribute === value;\n  if (entriesEqual) {\n    return;\n  }\n\n  const attributeValue = setAttributeScratchCartesian4;\n  attributeValue.x = defined(value.x) ? value.x : value;\n  attributeValue.y = defined(value.y) ? value.y : 0.0;\n  attributeValue.z = defined(value.z) ? value.z : 0.0;\n  attributeValue.w = defined(value.w) ? value.w : 0.0;\n\n  const offset = this._offsets[attributeIndex];\n  const stride = this._stride;\n  const index = 4 * stride * instanceIndex + 4 * offset;\n\n  if (\n    this._packFloats &&\n    attributes[attributeIndex].componentDatatype !== PixelDatatype.UNSIGNED_BYTE\n  ) {\n    setPackedAttribute(attributeValue, this._batchValues, index);\n  } else {\n    Cartesian4.pack(attributeValue, this._batchValues, index);\n  }\n\n  this._batchValuesDirty = true;\n};\n\nfunction createTexture(batchTable, context) {\n  const dimensions = batchTable._textureDimensions;\n  batchTable._texture = new Texture({\n    context: context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: batchTable._pixelDatatype,\n    width: dimensions.x,\n    height: dimensions.y,\n    sampler: Sampler.NEAREST,\n    flipY: false,\n  });\n}\n\nfunction updateTexture(batchTable) {\n  const dimensions = batchTable._textureDimensions;\n  batchTable._texture.copyFrom({\n    source: {\n      width: dimensions.x,\n      height: dimensions.y,\n      arrayBufferView: batchTable._batchValues,\n    },\n  });\n}\n\n/**\n * Creates/updates the batch table texture.\n * @param {FrameState} frameState The frame state.\n *\n * @exception {RuntimeError} The floating point texture extension is required but not supported.\n */\nBatchTable.prototype.update = function (frameState) {\n  if (\n    (defined(this._texture) && !this._batchValuesDirty) ||\n    this._attributes.length === 0\n  ) {\n    return;\n  }\n\n  this._batchValuesDirty = false;\n\n  if (!defined(this._texture)) {\n    createTexture(this, frameState.context);\n  }\n  updateTexture(this);\n};\n\n/**\n * Gets a function that will update a uniform map to contain values for looking up values in the batch table.\n *\n * @returns {BatchTable.updateUniformMapCallback} A callback for updating uniform maps.\n */\nBatchTable.prototype.getUniformMapCallback = function () {\n  const that = this;\n  return function (uniformMap) {\n    if (that._attributes.length === 0) {\n      return uniformMap;\n    }\n\n    const batchUniformMap = {\n      batchTexture: function () {\n        return that._texture;\n      },\n      batchTextureDimensions: function () {\n        return that._textureDimensions;\n      },\n      batchTextureStep: function () {\n        return that._textureStep;\n      },\n    };\n    return combine(uniformMap, batchUniformMap);\n  };\n};\n\nfunction getGlslComputeSt(batchTable) {\n  const stride = batchTable._stride;\n\n  // GLSL batchId is zero-based: [0, numberOfInstances - 1]\n  if (batchTable._textureDimensions.y === 1) {\n    return (\n      `${\n        \"uniform vec4 batchTextureStep; \\n\" +\n        \"vec2 computeSt(float batchId) \\n\" +\n        \"{ \\n\" +\n        \"    float stepX = batchTextureStep.x; \\n\" +\n        \"    float centerX = batchTextureStep.y; \\n\" +\n        \"    float numberOfAttributes = float(\"\n      }${stride}); \\n` +\n      `    return vec2(centerX + (batchId * numberOfAttributes * stepX), 0.5); \\n` +\n      `} \\n`\n    );\n  }\n\n  return (\n    `${\n      \"uniform vec4 batchTextureStep; \\n\" +\n      \"uniform vec2 batchTextureDimensions; \\n\" +\n      \"vec2 computeSt(float batchId) \\n\" +\n      \"{ \\n\" +\n      \"    float stepX = batchTextureStep.x; \\n\" +\n      \"    float centerX = batchTextureStep.y; \\n\" +\n      \"    float stepY = batchTextureStep.z; \\n\" +\n      \"    float centerY = batchTextureStep.w; \\n\" +\n      \"    float numberOfAttributes = float(\"\n    }${stride}); \\n` +\n    `    float xId = mod(batchId * numberOfAttributes, batchTextureDimensions.x); \\n` +\n    `    float yId = floor(batchId * numberOfAttributes / batchTextureDimensions.x); \\n` +\n    `    return vec2(centerX + (xId * stepX), centerY + (yId * stepY)); \\n` +\n    `} \\n`\n  );\n}\n\nfunction getComponentType(componentsPerAttribute) {\n  if (componentsPerAttribute === 1) {\n    return \"float\";\n  }\n  return `vec${componentsPerAttribute}`;\n}\n\nfunction getComponentSwizzle(componentsPerAttribute) {\n  if (componentsPerAttribute === 1) {\n    return \".x\";\n  } else if (componentsPerAttribute === 2) {\n    return \".xy\";\n  } else if (componentsPerAttribute === 3) {\n    return \".xyz\";\n  }\n  return \"\";\n}\n\nfunction getGlslAttributeFunction(batchTable, attributeIndex) {\n  const attributes = batchTable._attributes;\n  const attribute = attributes[attributeIndex];\n  const componentsPerAttribute = attribute.componentsPerAttribute;\n  const functionName = attribute.functionName;\n  const functionReturnType = getComponentType(componentsPerAttribute);\n  const functionReturnValue = getComponentSwizzle(componentsPerAttribute);\n\n  const offset = batchTable._offsets[attributeIndex];\n\n  let glslFunction =\n    `${functionReturnType} ${functionName}(float batchId) \\n` +\n    `{ \\n` +\n    `    vec2 st = computeSt(batchId); \\n` +\n    `    st.x += batchTextureStep.x * float(${offset}); \\n`;\n\n  if (\n    batchTable._packFloats &&\n    attribute.componentDatatype !== PixelDatatype.UNSIGNED_BYTE\n  ) {\n    glslFunction +=\n      \"vec4 textureValue; \\n\" +\n      \"textureValue.x = czm_unpackFloat(texture(batchTexture, st)); \\n\" +\n      \"textureValue.y = czm_unpackFloat(texture(batchTexture, st + vec2(batchTextureStep.x, 0.0))); \\n\" +\n      \"textureValue.z = czm_unpackFloat(texture(batchTexture, st + vec2(batchTextureStep.x * 2.0, 0.0))); \\n\" +\n      \"textureValue.w = czm_unpackFloat(texture(batchTexture, st + vec2(batchTextureStep.x * 3.0, 0.0))); \\n\";\n  } else {\n    glslFunction += \"    vec4 textureValue = texture(batchTexture, st); \\n\";\n  }\n\n  glslFunction += `    ${functionReturnType} value = textureValue${functionReturnValue}; \\n`;\n\n  if (\n    batchTable._pixelDatatype === PixelDatatype.UNSIGNED_BYTE &&\n    attribute.componentDatatype === ComponentDatatype.UNSIGNED_BYTE &&\n    !attribute.normalize\n  ) {\n    glslFunction += \"value *= 255.0; \\n\";\n  } else if (\n    batchTable._pixelDatatype === PixelDatatype.FLOAT &&\n    attribute.componentDatatype === ComponentDatatype.UNSIGNED_BYTE &&\n    attribute.normalize\n  ) {\n    glslFunction += \"value /= 255.0; \\n\";\n  }\n\n  glslFunction += \"    return value; \\n\" + \"} \\n\";\n  return glslFunction;\n}\n\n/**\n * Gets a function that will update a vertex shader to contain functions for looking up values in the batch table.\n *\n * @returns {BatchTable.updateVertexShaderSourceCallback} A callback for updating a vertex shader source.\n */\nBatchTable.prototype.getVertexShaderCallback = function () {\n  const attributes = this._attributes;\n  if (attributes.length === 0) {\n    return function (source) {\n      return source;\n    };\n  }\n\n  let batchTableShader = \"uniform highp sampler2D batchTexture; \\n\";\n  batchTableShader += `${getGlslComputeSt(this)}\\n`;\n\n  const length = attributes.length;\n  for (let i = 0; i < length; ++i) {\n    batchTableShader += getGlslAttributeFunction(this, i);\n  }\n\n  return function (source) {\n    const mainIndex = source.indexOf(\"void main\");\n    const beforeMain = source.substring(0, mainIndex);\n    const afterMain = source.substring(mainIndex);\n    return `${beforeMain}\\n${batchTableShader}\\n${afterMain}`;\n  };\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see BatchTable#destroy\n */\nBatchTable.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see BatchTable#isDestroyed\n */\nBatchTable.prototype.destroy = function () {\n  this._texture = this._texture && this._texture.destroy();\n  return destroyObject(this);\n};\n\n/**\n * A callback for updating uniform maps.\n * @callback BatchTable.updateUniformMapCallback\n *\n * @param {object} uniformMap The uniform map.\n * @returns {object} The new uniform map with properties for retrieving values from the batch table.\n */\n\n/**\n * A callback for updating a vertex shader source.\n * @callback BatchTable.updateVertexShaderSourceCallback\n *\n * @param {string} vertexShaderSource The vertex shader source.\n * @returns {string} The new vertex shader source with the functions for retrieving batch table values injected.\n */\nexport default BatchTable;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}