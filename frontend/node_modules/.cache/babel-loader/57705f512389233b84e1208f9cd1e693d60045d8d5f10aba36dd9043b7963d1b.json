{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Request from \"../Core/Request.js\";\nimport RequestScheduler from \"../Core/RequestScheduler.js\";\nimport RequestState from \"../Core/RequestState.js\";\nimport RequestType from \"../Core/RequestType.js\";\nimport Cesium3DContentGroup from \"./Cesium3DContentGroup.js\";\nimport Cesium3DTileContentType from \"./Cesium3DTileContentType.js\";\nimport Cesium3DTileContentFactory from \"./Cesium3DTileContentFactory.js\";\nimport findContentMetadata from \"./findContentMetadata.js\";\nimport findGroupMetadata from \"./findGroupMetadata.js\";\nimport preprocess3DTileContent from \"./preprocess3DTileContent.js\";\n\n/**\n * A collection of contents for tiles that have multiple contents, either via the tile JSON (3D Tiles 1.1) or the <code>3DTILES_multiple_contents</code> extension.\n * <p>\n * Implements the {@link Cesium3DTileContent} interface.\n * </p>\n *\n * @see {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_multiple_contents|3DTILES_multiple_contents extension}\n *\n * @alias Multiple3DTileContent\n * @constructor\n *\n * @param {Cesium3DTileset} tileset The tileset this content belongs to\n * @param {Cesium3DTile} tile The content this content belongs to\n * @param {Resource} tilesetResource The resource that points to the tileset. This will be used to derive each inner content's resource.\n * @param {object} contentsJson Either the tile JSON containing the contents array (3D Tiles 1.1), or <code>3DTILES_multiple_contents</code> extension JSON\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction Multiple3DTileContent(tileset, tile, tilesetResource, contentsJson) {\n  this._tileset = tileset;\n  this._tile = tile;\n  this._tilesetResource = tilesetResource;\n  this._contents = [];\n  this._contentsCreated = false;\n\n  // An older version of 3DTILES_multiple_contents used \"content\" instead of \"contents\"\n  const contentHeaders = defined(contentsJson.contents) ? contentsJson.contents : contentsJson.content;\n  this._innerContentHeaders = contentHeaders;\n  this._requestsInFlight = 0;\n\n  // How many times cancelPendingRequests() has been called. This is\n  // used to help short-circuit computations after a tile was canceled.\n  this._cancelCount = 0;\n\n  // The number of contents that turned out to be external tilesets\n  // in createInnerContent. When all contents are external tilesets,\n  // then tile.hasRenderableContent will become `false`\n  this._externalTilesetCount = 0;\n  const contentCount = this._innerContentHeaders.length;\n  this._arrayFetchPromises = new Array(contentCount);\n  this._requests = new Array(contentCount);\n  this._ready = false;\n  this._innerContentResources = new Array(contentCount);\n  this._serverKeys = new Array(contentCount);\n  for (let i = 0; i < contentCount; i++) {\n    const contentResource = tilesetResource.getDerivedResource({\n      url: contentHeaders[i].uri\n    });\n    const serverKey = RequestScheduler.getServerKey(contentResource.getUrlComponent());\n    this._innerContentResources[i] = contentResource;\n    this._serverKeys[i] = serverKey;\n  }\n}\nObject.defineProperties(Multiple3DTileContent.prototype, {\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code> checks if any of the inner contents have dirty featurePropertiesDirty.\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {boolean}\n   *\n   * @private\n   */\n  featurePropertiesDirty: {\n    get: function () {\n      const contents = this._contents;\n      const length = contents.length;\n      for (let i = 0; i < length; ++i) {\n        if (contents[i].featurePropertiesDirty) {\n          return true;\n        }\n      }\n      return false;\n    },\n    set: function (value) {\n      const contents = this._contents;\n      const length = contents.length;\n      for (let i = 0; i < length; ++i) {\n        contents[i].featurePropertiesDirty = value;\n      }\n    }\n  },\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code>\n   * always returns <code>0</code>.  Instead call <code>featuresLength</code> for a specific inner content.\n   *\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  featuresLength: {\n    get: function () {\n      return 0;\n    }\n  },\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code>\n   * always returns <code>0</code>.  Instead, call <code>pointsLength</code> for a specific inner content.\n   *\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  pointsLength: {\n    get: function () {\n      return 0;\n    }\n  },\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code>\n   * always returns <code>0</code>.  Instead call <code>trianglesLength</code> for a specific inner content.\n   *\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  trianglesLength: {\n    get: function () {\n      return 0;\n    }\n  },\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code>\n   * always returns <code>0</code>.  Instead call <code>geometryByteLength</code> for a specific inner content.\n   *\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  geometryByteLength: {\n    get: function () {\n      return 0;\n    }\n  },\n  /**\n   * Part of the {@link Cesium3DTileContent} interface. <code>Multiple3DTileContent</code>\n   * always returns <code>0</code>.  Instead call <code>texturesByteLength</code> for a specific inner content.\n   *\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  texturesByteLength: {\n    get: function () {\n      return 0;\n    }\n  },\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code>\n   * always returns <code>0</code>.  Instead call <code>batchTableByteLength</code> for a specific inner content.\n   *\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  batchTableByteLength: {\n    get: function () {\n      return 0;\n    }\n  },\n  innerContents: {\n    get: function () {\n      return this._contents;\n    }\n  },\n  /**\n   * Returns true when the tile's content is ready to render; otherwise false\n   *\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  ready: {\n    get: function () {\n      if (!this._contentsCreated) {\n        return false;\n      }\n      return this._ready;\n    }\n  },\n  tileset: {\n    get: function () {\n      return this._tileset;\n    }\n  },\n  tile: {\n    get: function () {\n      return this._tile;\n    }\n  },\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.\n   * Unlike other content types, <code>Multiple3DTileContent</code> does not\n   * have a single URL, so this returns undefined.\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  url: {\n    get: function () {\n      return undefined;\n    }\n  },\n  /**\n   * Part of the {@link Cesium3DTileContent} interface. <code>Multiple3DTileContent</code>\n   * always returns <code>undefined</code>.  Instead call <code>metadata</code> for a specific inner content.\n   * @memberof Multiple3DTileContent.prototype\n   * @private\n   */\n  metadata: {\n    get: function () {\n      return undefined;\n    },\n    set: function () {\n      //>>includeStart('debug', pragmas.debug);\n      throw new DeveloperError(\"Multiple3DTileContent cannot have metadata\");\n      //>>includeEnd('debug');\n    }\n  },\n  /**\n   * Part of the {@link Cesium3DTileContent} interface. <code>Multiple3DTileContent</code>\n   * always returns <code>undefined</code>.  Instead call <code>batchTable</code> for a specific inner content.\n   * @memberof Multiple3DTileContent.prototype\n   * @private\n   */\n  batchTable: {\n    get: function () {\n      return undefined;\n    }\n  },\n  /**\n   * Part of the {@link Cesium3DTileContent} interface. <code>Multiple3DTileContent</code>\n   * always returns <code>undefined</code>.  Instead call <code>group</code> for a specific inner content.\n   * @memberof Multiple3DTileContent.prototype\n   * @private\n   */\n  group: {\n    get: function () {\n      return undefined;\n    },\n    set: function () {\n      //>>includeStart('debug', pragmas.debug);\n      throw new DeveloperError(\"Multiple3DTileContent cannot have group metadata\");\n      //>>includeEnd('debug');\n    }\n  },\n  /**\n   * Get an array of the inner content URLs, regardless of whether they've\n   * been fetched or not. This is intended for use with\n   * {@link Cesium3DTileset#debugShowUrl}.\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {string[]}\n   * @readonly\n   * @private\n   */\n  innerContentUrls: {\n    get: function () {\n      return this._innerContentHeaders.map(function (contentHeader) {\n        return contentHeader.uri;\n      });\n    }\n  }\n});\nfunction updatePendingRequests(multipleContents, deltaRequestCount) {\n  multipleContents._requestsInFlight += deltaRequestCount;\n  multipleContents.tileset.statistics.numberOfPendingRequests += deltaRequestCount;\n}\nfunction cancelPendingRequests(multipleContents, originalContentState) {\n  multipleContents._cancelCount++;\n\n  // reset the tile's content state to try again later.\n  multipleContents._tile._contentState = originalContentState;\n  const statistics = multipleContents.tileset.statistics;\n  statistics.numberOfPendingRequests -= multipleContents._requestsInFlight;\n  statistics.numberOfAttemptedRequests += multipleContents._requestsInFlight;\n  multipleContents._requestsInFlight = 0;\n\n  // Discard the request promises.\n  const contentCount = multipleContents._innerContentHeaders.length;\n  multipleContents._arrayFetchPromises = new Array(contentCount);\n}\n\n/**\n * Request the inner contents of this <code>Multiple3DTileContent</code>. This must be called once a frame until\n * {@link Multiple3DTileContent#contentsFetchedPromise} is defined. This promise\n * becomes available as soon as all requests are scheduled.\n * <p>\n * This method also updates the tile statistics' pending request count if the\n * requests are successfully scheduled.\n * </p>\n *\n * @return {Promise<void>|undefined} A promise that resolves when the request completes, or undefined if there is no request needed, or the request cannot be scheduled.\n * @private\n */\nMultiple3DTileContent.prototype.requestInnerContents = function () {\n  // It's possible for these promises to leak content array buffers if the\n  // camera moves before they all are scheduled. To prevent this leak, check\n  // if we can schedule all the requests at once. If not, no requests are\n  // scheduled\n  if (!canScheduleAllRequests(this._serverKeys)) {\n    this.tileset.statistics.numberOfAttemptedRequests += this._serverKeys.length;\n    return;\n  }\n  const contentHeaders = this._innerContentHeaders;\n  updatePendingRequests(this, contentHeaders.length);\n  const originalCancelCount = this._cancelCount;\n  for (let i = 0; i < contentHeaders.length; i++) {\n    // The cancel count is needed to avoid a race condition where a content\n    // is canceled multiple times.\n    this._arrayFetchPromises[i] = requestInnerContent(this, i, originalCancelCount, this._tile._contentState);\n  }\n  return createInnerContents(this);\n};\n\n/**\n * Check if all requests for inner contents can be scheduled at once. This is slower, but it avoids a potential memory leak.\n * @param {string[]} serverKeys The server keys for all of the inner contents\n * @return {boolean} True if the request scheduler has enough open slots for all inner contents\n * @private\n */\nfunction canScheduleAllRequests(serverKeys) {\n  const requestCountsByServer = {};\n  for (let i = 0; i < serverKeys.length; i++) {\n    const serverKey = serverKeys[i];\n    if (defined(requestCountsByServer[serverKey])) {\n      requestCountsByServer[serverKey]++;\n    } else {\n      requestCountsByServer[serverKey] = 1;\n    }\n  }\n  for (const key in requestCountsByServer) {\n    if (requestCountsByServer.hasOwnProperty(key) && !RequestScheduler.serverHasOpenSlots(key, requestCountsByServer[key])) {\n      return false;\n    }\n  }\n  return RequestScheduler.heapHasOpenSlots(serverKeys.length);\n}\nfunction requestInnerContent(multipleContents, index, originalCancelCount, originalContentState) {\n  // it is important to clone here. The fetchArrayBuffer() below here uses\n  // throttling, but other uses of the resources do not.\n  const contentResource = multipleContents._innerContentResources[index].clone();\n  const tile = multipleContents.tile;\n\n  // Always create a new request. If the tile gets canceled, this\n  // avoids getting stuck in the canceled state.\n  const priorityFunction = function () {\n    return tile._priority;\n  };\n  const serverKey = multipleContents._serverKeys[index];\n  const request = new Request({\n    throttle: true,\n    throttleByServer: true,\n    type: RequestType.TILES3D,\n    priorityFunction: priorityFunction,\n    serverKey: serverKey\n  });\n  contentResource.request = request;\n  multipleContents._requests[index] = request;\n  const promise = contentResource.fetchArrayBuffer();\n  if (!defined(promise)) {\n    return;\n  }\n  return promise.then(function (arrayBuffer) {\n    // Pending requests have already been canceled.\n    if (originalCancelCount < multipleContents._cancelCount) {\n      return;\n    }\n    if (contentResource.request.cancelled || contentResource.request.state === RequestState.CANCELLED) {\n      cancelPendingRequests(multipleContents, originalContentState);\n      return;\n    }\n    updatePendingRequests(multipleContents, -1);\n    return arrayBuffer;\n  }).catch(function (error) {\n    // Pending requests have already been canceled.\n    if (originalCancelCount < multipleContents._cancelCount) {\n      return;\n    }\n    if (contentResource.request.cancelled || contentResource.request.state === RequestState.CANCELLED) {\n      cancelPendingRequests(multipleContents, originalContentState);\n      return;\n    }\n    updatePendingRequests(multipleContents, -1);\n    handleInnerContentFailed(multipleContents, index, error);\n  });\n}\nasync function createInnerContents(multipleContents) {\n  const originalCancelCount = multipleContents._cancelCount;\n  const arrayBuffers = await Promise.all(multipleContents._arrayFetchPromises);\n  // Request have been cancelled\n  if (originalCancelCount < multipleContents._cancelCount) {\n    return;\n  }\n  const promises = arrayBuffers.map((arrayBuffer, i) => createInnerContent(multipleContents, arrayBuffer, i));\n\n  // Even if we had a partial success (in which case the inner promise will be handled, but the content will not be returned), mark that we finished creating\n  // contents\n  const contents = await Promise.all(promises);\n  multipleContents._contentsCreated = true;\n  multipleContents._contents = contents.filter(defined);\n\n  // If each content is an external tileset, then the tile\n  // itself does not have any renderable content\n  if (multipleContents._externalTilesetCount === multipleContents._contents.length) {\n    const tile = multipleContents._tile;\n    tile.hasRenderableContent = false;\n  }\n  return contents;\n}\nasync function createInnerContent(multipleContents, arrayBuffer, index) {\n  if (!defined(arrayBuffer)) {\n    // Content was not fetched. The error was handled in\n    // the fetch promise. Return undefined to indicate partial failure.\n    return;\n  }\n  try {\n    const preprocessed = preprocess3DTileContent(arrayBuffer);\n    const tileset = multipleContents._tileset;\n    const resource = multipleContents._innerContentResources[index];\n    const tile = multipleContents._tile;\n    if (preprocessed.contentType === Cesium3DTileContentType.EXTERNAL_TILESET) {\n      multipleContents._externalTilesetCount++;\n      tile.hasTilesetContent = true;\n    }\n    multipleContents._disableSkipLevelOfDetail = multipleContents._disableSkipLevelOfDetail || preprocessed.contentType === Cesium3DTileContentType.GEOMETRY || preprocessed.contentType === Cesium3DTileContentType.VECTOR;\n    let content;\n    const contentFactory = Cesium3DTileContentFactory[preprocessed.contentType];\n    if (defined(preprocessed.binaryPayload)) {\n      content = await Promise.resolve(contentFactory(tileset, tile, resource, preprocessed.binaryPayload.buffer, 0));\n    } else {\n      // JSON formats\n      content = await Promise.resolve(contentFactory(tileset, tile, resource, preprocessed.jsonPayload));\n    }\n    const contentHeader = multipleContents._innerContentHeaders[index];\n    if (tile.hasImplicitContentMetadata) {\n      const subtree = tile.implicitSubtree;\n      const coordinates = tile.implicitCoordinates;\n      content.metadata = subtree.getContentMetadataView(coordinates, index);\n    } else if (!tile.hasImplicitContent) {\n      content.metadata = findContentMetadata(tileset, contentHeader);\n    }\n    const groupMetadata = findGroupMetadata(tileset, contentHeader);\n    if (defined(groupMetadata)) {\n      content.group = new Cesium3DContentGroup({\n        metadata: groupMetadata\n      });\n    }\n    return content;\n  } catch (error) {\n    handleInnerContentFailed(multipleContents, index, error);\n  }\n}\nfunction handleInnerContentFailed(multipleContents, index, error) {\n  const tileset = multipleContents._tileset;\n  const url = multipleContents._innerContentResources[index].url;\n  const message = defined(error.message) ? error.message : error.toString();\n  if (tileset.tileFailed.numberOfListeners > 0) {\n    tileset.tileFailed.raiseEvent({\n      url: url,\n      message: message\n    });\n  } else {\n    console.log(`A content failed to load: ${url}`);\n    console.log(`Error: ${message}`);\n  }\n}\n\n/**\n * Cancel all requests for inner contents. This is called by the tile\n * when a tile goes out of view.\n *\n * @private\n */\nMultiple3DTileContent.prototype.cancelRequests = function () {\n  for (let i = 0; i < this._requests.length; i++) {\n    const request = this._requests[i];\n    if (defined(request)) {\n      request.cancel();\n    }\n  }\n};\n\n/**\n * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code>\n * always returns <code>false</code>.  Instead call <code>hasProperty</code> for a specific inner content\n * @private\n */\nMultiple3DTileContent.prototype.hasProperty = function (batchId, name) {\n  return false;\n};\n\n/**\n * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code>\n * always returns <code>undefined</code>.  Instead call <code>getFeature</code> for a specific inner content\n * @private\n */\nMultiple3DTileContent.prototype.getFeature = function (batchId) {\n  return undefined;\n};\nMultiple3DTileContent.prototype.applyDebugSettings = function (enabled, color) {\n  const contents = this._contents;\n  const length = contents.length;\n  for (let i = 0; i < length; ++i) {\n    contents[i].applyDebugSettings(enabled, color);\n  }\n};\nMultiple3DTileContent.prototype.applyStyle = function (style) {\n  const contents = this._contents;\n  const length = contents.length;\n  for (let i = 0; i < length; ++i) {\n    contents[i].applyStyle(style);\n  }\n};\nMultiple3DTileContent.prototype.update = function (tileset, frameState) {\n  const contents = this._contents;\n  const length = contents.length;\n  let ready = true;\n  for (let i = 0; i < length; ++i) {\n    contents[i].update(tileset, frameState);\n    ready = ready && contents[i].ready;\n  }\n  if (!this._ready && ready) {\n    this._ready = true;\n  }\n};\n\n/**\n * Find an intersection between a ray and the tile content surface that was rendered. The ray must be given in world coordinates.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {FrameState} frameState The frame state.\n * @param {Cartesian3|undefined} [result] The intersection or <code>undefined</code> if none was found.\n * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.\n *\n * @private\n */\nMultiple3DTileContent.prototype.pick = function (ray, frameState, result) {\n  if (!this._ready) {\n    return undefined;\n  }\n  let intersection;\n  let minDistance = Number.POSITIVE_INFINITY;\n  const contents = this._contents;\n  const length = contents.length;\n  for (let i = 0; i < length; ++i) {\n    const candidate = contents[i].pick(ray, frameState, result);\n    if (!defined(candidate)) {\n      continue;\n    }\n    const distance = Cartesian3.distance(ray.origin, candidate);\n    if (distance < minDistance) {\n      intersection = candidate;\n      minDistance = distance;\n    }\n  }\n  if (!defined(intersection)) {\n    return undefined;\n  }\n  return result;\n};\nMultiple3DTileContent.prototype.isDestroyed = function () {\n  return false;\n};\nMultiple3DTileContent.prototype.destroy = function () {\n  const contents = this._contents;\n  const length = contents.length;\n  for (let i = 0; i < length; ++i) {\n    contents[i].destroy();\n  }\n  return destroyObject(this);\n};\nexport default Multiple3DTileContent;","map":{"version":3,"names":["Cartesian3","defined","destroyObject","DeveloperError","Request","RequestScheduler","RequestState","RequestType","Cesium3DContentGroup","Cesium3DTileContentType","Cesium3DTileContentFactory","findContentMetadata","findGroupMetadata","preprocess3DTileContent","Multiple3DTileContent","tileset","tile","tilesetResource","contentsJson","_tileset","_tile","_tilesetResource","_contents","_contentsCreated","contentHeaders","contents","content","_innerContentHeaders","_requestsInFlight","_cancelCount","_externalTilesetCount","contentCount","length","_arrayFetchPromises","Array","_requests","_ready","_innerContentResources","_serverKeys","i","contentResource","getDerivedResource","url","uri","serverKey","getServerKey","getUrlComponent","Object","defineProperties","prototype","featurePropertiesDirty","get","set","value","featuresLength","pointsLength","trianglesLength","geometryByteLength","texturesByteLength","batchTableByteLength","innerContents","ready","undefined","metadata","batchTable","group","innerContentUrls","map","contentHeader","updatePendingRequests","multipleContents","deltaRequestCount","statistics","numberOfPendingRequests","cancelPendingRequests","originalContentState","_contentState","numberOfAttemptedRequests","requestInnerContents","canScheduleAllRequests","originalCancelCount","requestInnerContent","createInnerContents","serverKeys","requestCountsByServer","key","hasOwnProperty","serverHasOpenSlots","heapHasOpenSlots","index","clone","priorityFunction","_priority","request","throttle","throttleByServer","type","TILES3D","promise","fetchArrayBuffer","then","arrayBuffer","cancelled","state","CANCELLED","catch","error","handleInnerContentFailed","arrayBuffers","Promise","all","promises","createInnerContent","filter","hasRenderableContent","preprocessed","resource","contentType","EXTERNAL_TILESET","hasTilesetContent","_disableSkipLevelOfDetail","GEOMETRY","VECTOR","contentFactory","binaryPayload","resolve","buffer","jsonPayload","hasImplicitContentMetadata","subtree","implicitSubtree","coordinates","implicitCoordinates","getContentMetadataView","hasImplicitContent","groupMetadata","message","toString","tileFailed","numberOfListeners","raiseEvent","console","log","cancelRequests","cancel","hasProperty","batchId","name","getFeature","applyDebugSettings","enabled","color","applyStyle","style","update","frameState","pick","ray","result","intersection","minDistance","Number","POSITIVE_INFINITY","candidate","distance","origin","isDestroyed","destroy"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Multiple3DTileContent.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Request from \"../Core/Request.js\";\nimport RequestScheduler from \"../Core/RequestScheduler.js\";\nimport RequestState from \"../Core/RequestState.js\";\nimport RequestType from \"../Core/RequestType.js\";\nimport Cesium3DContentGroup from \"./Cesium3DContentGroup.js\";\nimport Cesium3DTileContentType from \"./Cesium3DTileContentType.js\";\nimport Cesium3DTileContentFactory from \"./Cesium3DTileContentFactory.js\";\nimport findContentMetadata from \"./findContentMetadata.js\";\nimport findGroupMetadata from \"./findGroupMetadata.js\";\nimport preprocess3DTileContent from \"./preprocess3DTileContent.js\";\n\n/**\n * A collection of contents for tiles that have multiple contents, either via the tile JSON (3D Tiles 1.1) or the <code>3DTILES_multiple_contents</code> extension.\n * <p>\n * Implements the {@link Cesium3DTileContent} interface.\n * </p>\n *\n * @see {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_multiple_contents|3DTILES_multiple_contents extension}\n *\n * @alias Multiple3DTileContent\n * @constructor\n *\n * @param {Cesium3DTileset} tileset The tileset this content belongs to\n * @param {Cesium3DTile} tile The content this content belongs to\n * @param {Resource} tilesetResource The resource that points to the tileset. This will be used to derive each inner content's resource.\n * @param {object} contentsJson Either the tile JSON containing the contents array (3D Tiles 1.1), or <code>3DTILES_multiple_contents</code> extension JSON\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction Multiple3DTileContent(tileset, tile, tilesetResource, contentsJson) {\n  this._tileset = tileset;\n  this._tile = tile;\n  this._tilesetResource = tilesetResource;\n  this._contents = [];\n  this._contentsCreated = false;\n\n  // An older version of 3DTILES_multiple_contents used \"content\" instead of \"contents\"\n  const contentHeaders = defined(contentsJson.contents)\n    ? contentsJson.contents\n    : contentsJson.content;\n\n  this._innerContentHeaders = contentHeaders;\n  this._requestsInFlight = 0;\n\n  // How many times cancelPendingRequests() has been called. This is\n  // used to help short-circuit computations after a tile was canceled.\n  this._cancelCount = 0;\n\n  // The number of contents that turned out to be external tilesets\n  // in createInnerContent. When all contents are external tilesets,\n  // then tile.hasRenderableContent will become `false`\n  this._externalTilesetCount = 0;\n\n  const contentCount = this._innerContentHeaders.length;\n  this._arrayFetchPromises = new Array(contentCount);\n  this._requests = new Array(contentCount);\n  this._ready = false;\n\n  this._innerContentResources = new Array(contentCount);\n  this._serverKeys = new Array(contentCount);\n\n  for (let i = 0; i < contentCount; i++) {\n    const contentResource = tilesetResource.getDerivedResource({\n      url: contentHeaders[i].uri,\n    });\n\n    const serverKey = RequestScheduler.getServerKey(\n      contentResource.getUrlComponent(),\n    );\n\n    this._innerContentResources[i] = contentResource;\n    this._serverKeys[i] = serverKey;\n  }\n}\n\nObject.defineProperties(Multiple3DTileContent.prototype, {\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code> checks if any of the inner contents have dirty featurePropertiesDirty.\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {boolean}\n   *\n   * @private\n   */\n  featurePropertiesDirty: {\n    get: function () {\n      const contents = this._contents;\n      const length = contents.length;\n      for (let i = 0; i < length; ++i) {\n        if (contents[i].featurePropertiesDirty) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    set: function (value) {\n      const contents = this._contents;\n      const length = contents.length;\n      for (let i = 0; i < length; ++i) {\n        contents[i].featurePropertiesDirty = value;\n      }\n    },\n  },\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code>\n   * always returns <code>0</code>.  Instead call <code>featuresLength</code> for a specific inner content.\n   *\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  featuresLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code>\n   * always returns <code>0</code>.  Instead, call <code>pointsLength</code> for a specific inner content.\n   *\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  pointsLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code>\n   * always returns <code>0</code>.  Instead call <code>trianglesLength</code> for a specific inner content.\n   *\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  trianglesLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code>\n   * always returns <code>0</code>.  Instead call <code>geometryByteLength</code> for a specific inner content.\n   *\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  geometryByteLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface. <code>Multiple3DTileContent</code>\n   * always returns <code>0</code>.  Instead call <code>texturesByteLength</code> for a specific inner content.\n   *\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  texturesByteLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code>\n   * always returns <code>0</code>.  Instead call <code>batchTableByteLength</code> for a specific inner content.\n   *\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  batchTableByteLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  innerContents: {\n    get: function () {\n      return this._contents;\n    },\n  },\n\n  /**\n   * Returns true when the tile's content is ready to render; otherwise false\n   *\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  ready: {\n    get: function () {\n      if (!this._contentsCreated) {\n        return false;\n      }\n\n      return this._ready;\n    },\n  },\n\n  tileset: {\n    get: function () {\n      return this._tileset;\n    },\n  },\n\n  tile: {\n    get: function () {\n      return this._tile;\n    },\n  },\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.\n   * Unlike other content types, <code>Multiple3DTileContent</code> does not\n   * have a single URL, so this returns undefined.\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  url: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface. <code>Multiple3DTileContent</code>\n   * always returns <code>undefined</code>.  Instead call <code>metadata</code> for a specific inner content.\n   * @memberof Multiple3DTileContent.prototype\n   * @private\n   */\n  metadata: {\n    get: function () {\n      return undefined;\n    },\n    set: function () {\n      //>>includeStart('debug', pragmas.debug);\n      throw new DeveloperError(\"Multiple3DTileContent cannot have metadata\");\n      //>>includeEnd('debug');\n    },\n  },\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface. <code>Multiple3DTileContent</code>\n   * always returns <code>undefined</code>.  Instead call <code>batchTable</code> for a specific inner content.\n   * @memberof Multiple3DTileContent.prototype\n   * @private\n   */\n  batchTable: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface. <code>Multiple3DTileContent</code>\n   * always returns <code>undefined</code>.  Instead call <code>group</code> for a specific inner content.\n   * @memberof Multiple3DTileContent.prototype\n   * @private\n   */\n  group: {\n    get: function () {\n      return undefined;\n    },\n    set: function () {\n      //>>includeStart('debug', pragmas.debug);\n      throw new DeveloperError(\n        \"Multiple3DTileContent cannot have group metadata\",\n      );\n      //>>includeEnd('debug');\n    },\n  },\n\n  /**\n   * Get an array of the inner content URLs, regardless of whether they've\n   * been fetched or not. This is intended for use with\n   * {@link Cesium3DTileset#debugShowUrl}.\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {string[]}\n   * @readonly\n   * @private\n   */\n  innerContentUrls: {\n    get: function () {\n      return this._innerContentHeaders.map(function (contentHeader) {\n        return contentHeader.uri;\n      });\n    },\n  },\n});\n\nfunction updatePendingRequests(multipleContents, deltaRequestCount) {\n  multipleContents._requestsInFlight += deltaRequestCount;\n  multipleContents.tileset.statistics.numberOfPendingRequests +=\n    deltaRequestCount;\n}\n\nfunction cancelPendingRequests(multipleContents, originalContentState) {\n  multipleContents._cancelCount++;\n\n  // reset the tile's content state to try again later.\n  multipleContents._tile._contentState = originalContentState;\n\n  const statistics = multipleContents.tileset.statistics;\n\n  statistics.numberOfPendingRequests -= multipleContents._requestsInFlight;\n  statistics.numberOfAttemptedRequests += multipleContents._requestsInFlight;\n  multipleContents._requestsInFlight = 0;\n\n  // Discard the request promises.\n  const contentCount = multipleContents._innerContentHeaders.length;\n  multipleContents._arrayFetchPromises = new Array(contentCount);\n}\n\n/**\n * Request the inner contents of this <code>Multiple3DTileContent</code>. This must be called once a frame until\n * {@link Multiple3DTileContent#contentsFetchedPromise} is defined. This promise\n * becomes available as soon as all requests are scheduled.\n * <p>\n * This method also updates the tile statistics' pending request count if the\n * requests are successfully scheduled.\n * </p>\n *\n * @return {Promise<void>|undefined} A promise that resolves when the request completes, or undefined if there is no request needed, or the request cannot be scheduled.\n * @private\n */\nMultiple3DTileContent.prototype.requestInnerContents = function () {\n  // It's possible for these promises to leak content array buffers if the\n  // camera moves before they all are scheduled. To prevent this leak, check\n  // if we can schedule all the requests at once. If not, no requests are\n  // scheduled\n  if (!canScheduleAllRequests(this._serverKeys)) {\n    this.tileset.statistics.numberOfAttemptedRequests +=\n      this._serverKeys.length;\n    return;\n  }\n\n  const contentHeaders = this._innerContentHeaders;\n  updatePendingRequests(this, contentHeaders.length);\n\n  const originalCancelCount = this._cancelCount;\n  for (let i = 0; i < contentHeaders.length; i++) {\n    // The cancel count is needed to avoid a race condition where a content\n    // is canceled multiple times.\n    this._arrayFetchPromises[i] = requestInnerContent(\n      this,\n      i,\n      originalCancelCount,\n      this._tile._contentState,\n    );\n  }\n\n  return createInnerContents(this);\n};\n\n/**\n * Check if all requests for inner contents can be scheduled at once. This is slower, but it avoids a potential memory leak.\n * @param {string[]} serverKeys The server keys for all of the inner contents\n * @return {boolean} True if the request scheduler has enough open slots for all inner contents\n * @private\n */\nfunction canScheduleAllRequests(serverKeys) {\n  const requestCountsByServer = {};\n  for (let i = 0; i < serverKeys.length; i++) {\n    const serverKey = serverKeys[i];\n    if (defined(requestCountsByServer[serverKey])) {\n      requestCountsByServer[serverKey]++;\n    } else {\n      requestCountsByServer[serverKey] = 1;\n    }\n  }\n\n  for (const key in requestCountsByServer) {\n    if (\n      requestCountsByServer.hasOwnProperty(key) &&\n      !RequestScheduler.serverHasOpenSlots(key, requestCountsByServer[key])\n    ) {\n      return false;\n    }\n  }\n  return RequestScheduler.heapHasOpenSlots(serverKeys.length);\n}\n\nfunction requestInnerContent(\n  multipleContents,\n  index,\n  originalCancelCount,\n  originalContentState,\n) {\n  // it is important to clone here. The fetchArrayBuffer() below here uses\n  // throttling, but other uses of the resources do not.\n  const contentResource =\n    multipleContents._innerContentResources[index].clone();\n  const tile = multipleContents.tile;\n\n  // Always create a new request. If the tile gets canceled, this\n  // avoids getting stuck in the canceled state.\n  const priorityFunction = function () {\n    return tile._priority;\n  };\n  const serverKey = multipleContents._serverKeys[index];\n  const request = new Request({\n    throttle: true,\n    throttleByServer: true,\n    type: RequestType.TILES3D,\n    priorityFunction: priorityFunction,\n    serverKey: serverKey,\n  });\n  contentResource.request = request;\n  multipleContents._requests[index] = request;\n\n  const promise = contentResource.fetchArrayBuffer();\n  if (!defined(promise)) {\n    return;\n  }\n\n  return promise\n    .then(function (arrayBuffer) {\n      // Pending requests have already been canceled.\n      if (originalCancelCount < multipleContents._cancelCount) {\n        return;\n      }\n\n      if (\n        contentResource.request.cancelled ||\n        contentResource.request.state === RequestState.CANCELLED\n      ) {\n        cancelPendingRequests(multipleContents, originalContentState);\n        return;\n      }\n\n      updatePendingRequests(multipleContents, -1);\n      return arrayBuffer;\n    })\n    .catch(function (error) {\n      // Pending requests have already been canceled.\n      if (originalCancelCount < multipleContents._cancelCount) {\n        return;\n      }\n\n      if (\n        contentResource.request.cancelled ||\n        contentResource.request.state === RequestState.CANCELLED\n      ) {\n        cancelPendingRequests(multipleContents, originalContentState);\n        return;\n      }\n\n      updatePendingRequests(multipleContents, -1);\n      handleInnerContentFailed(multipleContents, index, error);\n    });\n}\n\nasync function createInnerContents(multipleContents) {\n  const originalCancelCount = multipleContents._cancelCount;\n  const arrayBuffers = await Promise.all(multipleContents._arrayFetchPromises);\n  // Request have been cancelled\n  if (originalCancelCount < multipleContents._cancelCount) {\n    return;\n  }\n\n  const promises = arrayBuffers.map((arrayBuffer, i) =>\n    createInnerContent(multipleContents, arrayBuffer, i),\n  );\n\n  // Even if we had a partial success (in which case the inner promise will be handled, but the content will not be returned), mark that we finished creating\n  // contents\n  const contents = await Promise.all(promises);\n  multipleContents._contentsCreated = true;\n  multipleContents._contents = contents.filter(defined);\n\n  // If each content is an external tileset, then the tile\n  // itself does not have any renderable content\n  if (\n    multipleContents._externalTilesetCount === multipleContents._contents.length\n  ) {\n    const tile = multipleContents._tile;\n    tile.hasRenderableContent = false;\n  }\n\n  return contents;\n}\n\nasync function createInnerContent(multipleContents, arrayBuffer, index) {\n  if (!defined(arrayBuffer)) {\n    // Content was not fetched. The error was handled in\n    // the fetch promise. Return undefined to indicate partial failure.\n    return;\n  }\n\n  try {\n    const preprocessed = preprocess3DTileContent(arrayBuffer);\n\n    const tileset = multipleContents._tileset;\n    const resource = multipleContents._innerContentResources[index];\n    const tile = multipleContents._tile;\n\n    if (preprocessed.contentType === Cesium3DTileContentType.EXTERNAL_TILESET) {\n      multipleContents._externalTilesetCount++;\n      tile.hasTilesetContent = true;\n    }\n\n    multipleContents._disableSkipLevelOfDetail =\n      multipleContents._disableSkipLevelOfDetail ||\n      preprocessed.contentType === Cesium3DTileContentType.GEOMETRY ||\n      preprocessed.contentType === Cesium3DTileContentType.VECTOR;\n\n    let content;\n    const contentFactory = Cesium3DTileContentFactory[preprocessed.contentType];\n    if (defined(preprocessed.binaryPayload)) {\n      content = await Promise.resolve(\n        contentFactory(\n          tileset,\n          tile,\n          resource,\n          preprocessed.binaryPayload.buffer,\n          0,\n        ),\n      );\n    } else {\n      // JSON formats\n      content = await Promise.resolve(\n        contentFactory(tileset, tile, resource, preprocessed.jsonPayload),\n      );\n    }\n\n    const contentHeader = multipleContents._innerContentHeaders[index];\n\n    if (tile.hasImplicitContentMetadata) {\n      const subtree = tile.implicitSubtree;\n      const coordinates = tile.implicitCoordinates;\n      content.metadata = subtree.getContentMetadataView(coordinates, index);\n    } else if (!tile.hasImplicitContent) {\n      content.metadata = findContentMetadata(tileset, contentHeader);\n    }\n\n    const groupMetadata = findGroupMetadata(tileset, contentHeader);\n    if (defined(groupMetadata)) {\n      content.group = new Cesium3DContentGroup({\n        metadata: groupMetadata,\n      });\n    }\n    return content;\n  } catch (error) {\n    handleInnerContentFailed(multipleContents, index, error);\n  }\n}\n\nfunction handleInnerContentFailed(multipleContents, index, error) {\n  const tileset = multipleContents._tileset;\n  const url = multipleContents._innerContentResources[index].url;\n  const message = defined(error.message) ? error.message : error.toString();\n  if (tileset.tileFailed.numberOfListeners > 0) {\n    tileset.tileFailed.raiseEvent({\n      url: url,\n      message: message,\n    });\n  } else {\n    console.log(`A content failed to load: ${url}`);\n    console.log(`Error: ${message}`);\n  }\n}\n\n/**\n * Cancel all requests for inner contents. This is called by the tile\n * when a tile goes out of view.\n *\n * @private\n */\nMultiple3DTileContent.prototype.cancelRequests = function () {\n  for (let i = 0; i < this._requests.length; i++) {\n    const request = this._requests[i];\n    if (defined(request)) {\n      request.cancel();\n    }\n  }\n};\n\n/**\n * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code>\n * always returns <code>false</code>.  Instead call <code>hasProperty</code> for a specific inner content\n * @private\n */\nMultiple3DTileContent.prototype.hasProperty = function (batchId, name) {\n  return false;\n};\n\n/**\n * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code>\n * always returns <code>undefined</code>.  Instead call <code>getFeature</code> for a specific inner content\n * @private\n */\nMultiple3DTileContent.prototype.getFeature = function (batchId) {\n  return undefined;\n};\n\nMultiple3DTileContent.prototype.applyDebugSettings = function (enabled, color) {\n  const contents = this._contents;\n  const length = contents.length;\n  for (let i = 0; i < length; ++i) {\n    contents[i].applyDebugSettings(enabled, color);\n  }\n};\n\nMultiple3DTileContent.prototype.applyStyle = function (style) {\n  const contents = this._contents;\n  const length = contents.length;\n  for (let i = 0; i < length; ++i) {\n    contents[i].applyStyle(style);\n  }\n};\n\nMultiple3DTileContent.prototype.update = function (tileset, frameState) {\n  const contents = this._contents;\n  const length = contents.length;\n  let ready = true;\n  for (let i = 0; i < length; ++i) {\n    contents[i].update(tileset, frameState);\n    ready = ready && contents[i].ready;\n  }\n\n  if (!this._ready && ready) {\n    this._ready = true;\n  }\n};\n\n/**\n * Find an intersection between a ray and the tile content surface that was rendered. The ray must be given in world coordinates.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {FrameState} frameState The frame state.\n * @param {Cartesian3|undefined} [result] The intersection or <code>undefined</code> if none was found.\n * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.\n *\n * @private\n */\nMultiple3DTileContent.prototype.pick = function (ray, frameState, result) {\n  if (!this._ready) {\n    return undefined;\n  }\n\n  let intersection;\n  let minDistance = Number.POSITIVE_INFINITY;\n  const contents = this._contents;\n  const length = contents.length;\n\n  for (let i = 0; i < length; ++i) {\n    const candidate = contents[i].pick(ray, frameState, result);\n\n    if (!defined(candidate)) {\n      continue;\n    }\n\n    const distance = Cartesian3.distance(ray.origin, candidate);\n    if (distance < minDistance) {\n      intersection = candidate;\n      minDistance = distance;\n    }\n  }\n\n  if (!defined(intersection)) {\n    return undefined;\n  }\n\n  return result;\n};\n\nMultiple3DTileContent.prototype.isDestroyed = function () {\n  return false;\n};\n\nMultiple3DTileContent.prototype.destroy = function () {\n  const contents = this._contents;\n  const length = contents.length;\n  for (let i = 0; i < length; ++i) {\n    contents[i].destroy();\n  }\n  return destroyObject(this);\n};\n\nexport default Multiple3DTileContent;\n"],"mappings":"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ACA;AACA;AACA;AACA;AACA;EACEC,cAAc,EAAE;IACdH,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,CAAC;IACV;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEI,YAAY,EAAE;IACZJ,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,CAAC;IACV;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEK,eAAe,EAAE;IACfL,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,CAAC;IACV;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEM,kBAAkB,EAAE;IAClBN,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,CAAC;IACV;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEO,kBAAkB,EAAE;IAClBP,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,CAAC;IACV;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEQ,oBAAoB,EAAE;IACpBR,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,CAAC;IACV;EACF,CAAC;EAEDS,aAAa,EAAE;IACbT,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC7B,SAAS;IACvB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEuC,KAAK,EAAE;IACLV,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,IAAI,CAAC,IAAI,CAAC5B,gBAAgB,EAAE;QAC1B,OAAO,KAAK;MACd;MAEA,OAAO,IAAI,CAACa,MAAM;IACpB;EACF,CAAC;EAEDrB,OAAO,EAAE;IACPoC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAChC,QAAQ;IACtB;EACF,CAAC;EAEDH,IAAI,EAAE;IACJmC,GAAG,EAAE,SAAAA,CAAA,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}