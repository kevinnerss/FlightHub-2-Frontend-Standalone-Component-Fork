{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-hex.js\";\nimport \"core-js/modules/esnext.uint8-array.to-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.to-hex.js\";\nimport Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport DracoLoader from \"./DracoLoader.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\nimport VertexAttributeSemantic from \"./VertexAttributeSemantic.js\";\n\n/**\n * Load a draco buffer from a glTF.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfDracoLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {object} options Object with the following properties:\n * @param {ResourceCache} options.resourceCache The {@link ResourceCache} (to avoid circular dependencies).\n * @param {object} options.gltf The glTF JSON.\n * @param {object} options.primitive The primitive containing the Draco extension.\n * @param {object} options.draco The Draco extension object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {string} [options.cacheKey] The cache key of the resource.\n *\n * @private\n */\nfunction GltfDracoLoader(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const resourceCache = options.resourceCache;\n  const gltf = options.gltf;\n  const primitive = options.primitive;\n  const draco = options.draco;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const cacheKey = options.cacheKey;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"options.resourceCache\", resourceCache);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.primitive\", primitive);\n  Check.typeOf.object(\"options.draco\", draco);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  this._resourceCache = resourceCache;\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._gltf = gltf;\n  this._primitive = primitive;\n  this._draco = draco;\n  this._cacheKey = cacheKey;\n  this._bufferViewLoader = undefined;\n  this._bufferViewTypedArray = undefined;\n  this._decodePromise = undefined;\n  this._decodedData = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n  this._dracoError = undefined;\n}\nif (defined(Object.create)) {\n  GltfDracoLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfDracoLoader.prototype.constructor = GltfDracoLoader;\n}\nObject.defineProperties(GltfDracoLoader.prototype, {\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfDracoLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    }\n  },\n  /**\n   * The decoded data.\n   *\n   * @memberof GltfDracoLoader.prototype\n   *\n   * @type {object}\n   * @readonly\n   * @private\n   */\n  decodedData: {\n    get: function () {\n      return this._decodedData;\n    }\n  }\n});\nasync function loadResources(loader) {\n  const resourceCache = loader._resourceCache;\n  try {\n    const bufferViewLoader = resourceCache.getBufferViewLoader({\n      gltf: loader._gltf,\n      bufferViewId: loader._draco.bufferView,\n      gltfResource: loader._gltfResource,\n      baseResource: loader._baseResource\n    });\n    loader._bufferViewLoader = bufferViewLoader;\n    await bufferViewLoader.load();\n    if (loader.isDestroyed()) {\n      return;\n    }\n    loader._bufferViewTypedArray = bufferViewLoader.typedArray;\n    loader._state = ResourceLoaderState.PROCESSING;\n    return loader;\n  } catch (error) {\n    if (loader.isDestroyed()) {\n      return;\n    }\n    handleError(loader, error);\n  }\n}\n\n/**\n * Loads the resource.\n * @returns {Promise<GltfDracoLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfDracoLoader.prototype.load = async function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n  this._state = ResourceLoaderState.LOADING;\n  this._promise = loadResources(this);\n  return this._promise;\n};\nfunction handleError(dracoLoader, error) {\n  dracoLoader.unload();\n  dracoLoader._state = ResourceLoaderState.FAILED;\n  const errorMessage = \"Failed to load Draco\";\n  throw dracoLoader.getError(errorMessage, error);\n}\nasync function processDecode(loader, decodePromise) {\n  try {\n    const results = await decodePromise;\n    if (loader.isDestroyed()) {\n      return;\n    }\n\n    // Unload everything except the decoded data\n    loader.unload();\n    loader._decodedData = {\n      indices: results.indexArray,\n      vertexAttributes: results.attributeData\n    };\n    loader._state = ResourceLoaderState.READY;\n    return loader._baseResource;\n  } catch (error) {\n    if (loader.isDestroyed()) {\n      return;\n    }\n\n    // Capture this error so it can be thrown on the next `process` call\n    loader._dracoError = error;\n  }\n}\nconst SemanticToDracoAttributeType = {};\nSemanticToDracoAttributeType[VertexAttributeSemantic.POSITION] = \"POSITION\";\nSemanticToDracoAttributeType[VertexAttributeSemantic.NORMAL] = \"NORMAL\";\nSemanticToDracoAttributeType[VertexAttributeSemantic.COLOR] = \"COLOR\";\nSemanticToDracoAttributeType[VertexAttributeSemantic.TEXCOORD] = \"TEX_COORD\";\nfunction getDracoAttributeType(attribute) {\n  for (const semantic in SemanticToDracoAttributeType) {\n    if (SemanticToDracoAttributeType.hasOwnProperty(semantic)) {\n      if (attribute.startsWith(semantic)) {\n        return SemanticToDracoAttributeType[semantic];\n      }\n    }\n  }\n  return undefined;\n}\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfDracoLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === ResourceLoaderState.READY) {\n    return true;\n  }\n  if (this._state !== ResourceLoaderState.PROCESSING) {\n    return false;\n  }\n  if (defined(this._dracoError)) {\n    handleError(this, this._dracoError);\n  }\n  if (!defined(this._bufferViewTypedArray)) {\n    // Not ready to decode the Draco buffer\n    return false;\n  }\n  if (defined(this._decodePromise)) {\n    // Currently decoding\n    return false;\n  }\n  const draco = this._draco;\n  const primitive = this._primitive;\n  const gltf = this._gltf;\n  const bufferViews = gltf.bufferViews;\n  const bufferViewId = draco.bufferView;\n  const bufferView = bufferViews[bufferViewId];\n  const compressedAttributes = draco.attributes;\n\n  // Skip de-quantization transform if present for floating point attributes.\n  // They will stay quantized in memory and be dequantized in the shader.\n  const attributesToSkipTransform = [];\n  for (const attribute in primitive.attributes) {\n    if (primitive.attributes.hasOwnProperty(attribute)) {\n      const dracoAttributeType = getDracoAttributeType(attribute);\n      if (defined(dracoAttributeType)) {\n        const accessor = gltf.accessors[primitive.attributes[attribute]];\n        if (accessor.componentType === ComponentDatatype.FLOAT) {\n          if (!attributesToSkipTransform.includes(dracoAttributeType)) {\n            attributesToSkipTransform.push(dracoAttributeType);\n          }\n        }\n      }\n    }\n  }\n  const decodeOptions = {\n    // Need to make a copy of the typed array otherwise the underlying\n    // ArrayBuffer may be accessed on both the worker and the main thread. This\n    // leads to errors such as \"ArrayBuffer at index 0 is already detached\".\n    // PERFORMANCE_IDEA: Look into SharedArrayBuffer to get around this.\n    array: new Uint8Array(this._bufferViewTypedArray),\n    bufferView: bufferView,\n    compressedAttributes: compressedAttributes,\n    dequantizeInShader: true,\n    attributesToSkipTransform: attributesToSkipTransform\n  };\n  const decodePromise = DracoLoader.decodeBufferView(decodeOptions);\n  if (!defined(decodePromise)) {\n    // Cannot schedule task this frame\n    return false;\n  }\n  this._decodePromise = processDecode(this, decodePromise);\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfDracoLoader.prototype.unload = function () {\n  if (defined(this._bufferViewLoader)) {\n    this._resourceCache.unload(this._bufferViewLoader);\n  }\n  this._bufferViewLoader = undefined;\n  this._bufferViewTypedArray = undefined;\n  this._decodedData = undefined;\n  this._gltf = undefined;\n  this._primitive = undefined;\n};\nexport default GltfDracoLoader;","map":{"version":3,"names":["Check","ComponentDatatype","Frozen","defined","DracoLoader","ResourceLoader","ResourceLoaderState","VertexAttributeSemantic","GltfDracoLoader","options","EMPTY_OBJECT","resourceCache","gltf","primitive","draco","gltfResource","baseResource","cacheKey","typeOf","func","object","_resourceCache","_gltfResource","_baseResource","_gltf","_primitive","_draco","_cacheKey","_bufferViewLoader","undefined","_bufferViewTypedArray","_decodePromise","_decodedData","_state","UNLOADED","_promise","_dracoError","Object","create","prototype","constructor","defineProperties","get","decodedData","loadResources","loader","bufferViewLoader","getBufferViewLoader","bufferViewId","bufferView","load","isDestroyed","typedArray","PROCESSING","error","handleError","LOADING","dracoLoader","unload","FAILED","errorMessage","getError","processDecode","decodePromise","results","indices","indexArray","vertexAttributes","attributeData","READY","SemanticToDracoAttributeType","POSITION","NORMAL","COLOR","TEXCOORD","getDracoAttributeType","attribute","semantic","hasOwnProperty","startsWith","process","frameState","bufferViews","compressedAttributes","attributes","attributesToSkipTransform","dracoAttributeType","accessor","accessors","componentType","FLOAT","includes","push","decodeOptions","array","Uint8Array","dequantizeInShader","decodeBufferView"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/GltfDracoLoader.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport DracoLoader from \"./DracoLoader.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\nimport VertexAttributeSemantic from \"./VertexAttributeSemantic.js\";\n\n/**\n * Load a draco buffer from a glTF.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfDracoLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {object} options Object with the following properties:\n * @param {ResourceCache} options.resourceCache The {@link ResourceCache} (to avoid circular dependencies).\n * @param {object} options.gltf The glTF JSON.\n * @param {object} options.primitive The primitive containing the Draco extension.\n * @param {object} options.draco The Draco extension object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {string} [options.cacheKey] The cache key of the resource.\n *\n * @private\n */\nfunction GltfDracoLoader(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const resourceCache = options.resourceCache;\n  const gltf = options.gltf;\n  const primitive = options.primitive;\n  const draco = options.draco;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const cacheKey = options.cacheKey;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"options.resourceCache\", resourceCache);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.primitive\", primitive);\n  Check.typeOf.object(\"options.draco\", draco);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  this._resourceCache = resourceCache;\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._gltf = gltf;\n  this._primitive = primitive;\n  this._draco = draco;\n  this._cacheKey = cacheKey;\n  this._bufferViewLoader = undefined;\n  this._bufferViewTypedArray = undefined;\n  this._decodePromise = undefined;\n  this._decodedData = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n  this._dracoError = undefined;\n}\n\nif (defined(Object.create)) {\n  GltfDracoLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfDracoLoader.prototype.constructor = GltfDracoLoader;\n}\n\nObject.defineProperties(GltfDracoLoader.prototype, {\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfDracoLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    },\n  },\n  /**\n   * The decoded data.\n   *\n   * @memberof GltfDracoLoader.prototype\n   *\n   * @type {object}\n   * @readonly\n   * @private\n   */\n  decodedData: {\n    get: function () {\n      return this._decodedData;\n    },\n  },\n});\n\nasync function loadResources(loader) {\n  const resourceCache = loader._resourceCache;\n  try {\n    const bufferViewLoader = resourceCache.getBufferViewLoader({\n      gltf: loader._gltf,\n      bufferViewId: loader._draco.bufferView,\n      gltfResource: loader._gltfResource,\n      baseResource: loader._baseResource,\n    });\n    loader._bufferViewLoader = bufferViewLoader;\n    await bufferViewLoader.load();\n\n    if (loader.isDestroyed()) {\n      return;\n    }\n\n    loader._bufferViewTypedArray = bufferViewLoader.typedArray;\n    loader._state = ResourceLoaderState.PROCESSING;\n    return loader;\n  } catch (error) {\n    if (loader.isDestroyed()) {\n      return;\n    }\n\n    handleError(loader, error);\n  }\n}\n\n/**\n * Loads the resource.\n * @returns {Promise<GltfDracoLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfDracoLoader.prototype.load = async function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n\n  this._state = ResourceLoaderState.LOADING;\n  this._promise = loadResources(this);\n  return this._promise;\n};\n\nfunction handleError(dracoLoader, error) {\n  dracoLoader.unload();\n  dracoLoader._state = ResourceLoaderState.FAILED;\n  const errorMessage = \"Failed to load Draco\";\n  throw dracoLoader.getError(errorMessage, error);\n}\n\nasync function processDecode(loader, decodePromise) {\n  try {\n    const results = await decodePromise;\n    if (loader.isDestroyed()) {\n      return;\n    }\n\n    // Unload everything except the decoded data\n    loader.unload();\n\n    loader._decodedData = {\n      indices: results.indexArray,\n      vertexAttributes: results.attributeData,\n    };\n    loader._state = ResourceLoaderState.READY;\n    return loader._baseResource;\n  } catch (error) {\n    if (loader.isDestroyed()) {\n      return;\n    }\n\n    // Capture this error so it can be thrown on the next `process` call\n    loader._dracoError = error;\n  }\n}\n\nconst SemanticToDracoAttributeType = {};\nSemanticToDracoAttributeType[VertexAttributeSemantic.POSITION] = \"POSITION\";\nSemanticToDracoAttributeType[VertexAttributeSemantic.NORMAL] = \"NORMAL\";\nSemanticToDracoAttributeType[VertexAttributeSemantic.COLOR] = \"COLOR\";\nSemanticToDracoAttributeType[VertexAttributeSemantic.TEXCOORD] = \"TEX_COORD\";\n\nfunction getDracoAttributeType(attribute) {\n  for (const semantic in SemanticToDracoAttributeType) {\n    if (SemanticToDracoAttributeType.hasOwnProperty(semantic)) {\n      if (attribute.startsWith(semantic)) {\n        return SemanticToDracoAttributeType[semantic];\n      }\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfDracoLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === ResourceLoaderState.READY) {\n    return true;\n  }\n\n  if (this._state !== ResourceLoaderState.PROCESSING) {\n    return false;\n  }\n\n  if (defined(this._dracoError)) {\n    handleError(this, this._dracoError);\n  }\n\n  if (!defined(this._bufferViewTypedArray)) {\n    // Not ready to decode the Draco buffer\n    return false;\n  }\n\n  if (defined(this._decodePromise)) {\n    // Currently decoding\n    return false;\n  }\n\n  const draco = this._draco;\n  const primitive = this._primitive;\n  const gltf = this._gltf;\n  const bufferViews = gltf.bufferViews;\n  const bufferViewId = draco.bufferView;\n  const bufferView = bufferViews[bufferViewId];\n  const compressedAttributes = draco.attributes;\n\n  // Skip de-quantization transform if present for floating point attributes.\n  // They will stay quantized in memory and be dequantized in the shader.\n  const attributesToSkipTransform = [];\n\n  for (const attribute in primitive.attributes) {\n    if (primitive.attributes.hasOwnProperty(attribute)) {\n      const dracoAttributeType = getDracoAttributeType(attribute);\n      if (defined(dracoAttributeType)) {\n        const accessor = gltf.accessors[primitive.attributes[attribute]];\n        if (accessor.componentType === ComponentDatatype.FLOAT) {\n          if (!attributesToSkipTransform.includes(dracoAttributeType)) {\n            attributesToSkipTransform.push(dracoAttributeType);\n          }\n        }\n      }\n    }\n  }\n\n  const decodeOptions = {\n    // Need to make a copy of the typed array otherwise the underlying\n    // ArrayBuffer may be accessed on both the worker and the main thread. This\n    // leads to errors such as \"ArrayBuffer at index 0 is already detached\".\n    // PERFORMANCE_IDEA: Look into SharedArrayBuffer to get around this.\n    array: new Uint8Array(this._bufferViewTypedArray),\n    bufferView: bufferView,\n    compressedAttributes: compressedAttributes,\n    dequantizeInShader: true,\n    attributesToSkipTransform: attributesToSkipTransform,\n  };\n\n  const decodePromise = DracoLoader.decodeBufferView(decodeOptions);\n\n  if (!defined(decodePromise)) {\n    // Cannot schedule task this frame\n    return false;\n  }\n\n  this._decodePromise = processDecode(this, decodePromise);\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfDracoLoader.prototype.unload = function () {\n  if (defined(this._bufferViewLoader)) {\n    this._resourceCache.unload(this._bufferViewLoader);\n  }\n\n  this._bufferViewLoader = undefined;\n  this._bufferViewTypedArray = undefined;\n  this._decodedData = undefined;\n  this._gltf = undefined;\n  this._primitive = undefined;\n};\n\nexport default GltfDracoLoader;\n"],"mappings":";;;;;;;;;AAAA,OAAOA,KAAK,MAAM,kBAAkB;AACpC,OAAOC,iBAAiB,MAAM,8BAA8B;AAC5D,OAAOC,MAAM,MAAM,mBAAmB;AACtC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,WAAW,MAAM,kBAAkB;AAC1C,OAAOC,cAAc,MAAM,qBAAqB;AAChD,OAAOC,mBAAmB,MAAM,0BAA0B;AAC1D,OAAOC,uBAAuB,MAAM,8BAA8B;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,eAAeA,CAACC,OAAO,EAAE;EAChCA,OAAO,GAAGA,OAAO,IAAIP,MAAM,CAACQ,YAAY;EACxC,MAAMC,aAAa,GAAGF,OAAO,CAACE,aAAa;EAC3C,MAAMC,IAAI,GAAGH,OAAO,CAACG,IAAI;EACzB,MAAMC,SAAS,GAAGJ,OAAO,CAACI,SAAS;EACnC,MAAMC,KAAK,GAAGL,OAAO,CAACK,KAAK;EAC3B,MAAMC,YAAY,GAAGN,OAAO,CAACM,YAAY;EACzC,MAAMC,YAAY,GAAGP,OAAO,CAACO,YAAY;EACzC,MAAMC,QAAQ,GAAGR,OAAO,CAACQ,QAAQ;;EAEjC;EACAjB,KAAK,CAACkB,MAAM,CAACC,IAAI,CAAC,uBAAuB,EAAER,aAAa,CAAC;EACzDX,KAAK,CAACkB,MAAM,CAACE,MAAM,CAAC,cAAc,EAAER,IAAI,CAAC;EACzCZ,KAAK,CAACkB,MAAM,CAACE,MAAM,CAAC,mBAAmB,EAAEP,SAAS,CAAC;EACnDb,KAAK,CAACkB,MAAM,CAACE,MAAM,CAAC,eAAe,EAAEN,KAAK,CAAC;EAC3Cd,KAAK,CAACkB,MAAM,CAACE,MAAM,CAAC,sBAAsB,EAAEL,YAAY,CAAC;EACzDf,KAAK,CAACkB,MAAM,CAACE,MAAM,CAAC,sBAAsB,EAAEJ,YAAY,CAAC;EACzD;;EAEA,IAAI,CAACK,cAAc,GAAGV,aAAa;EACnC,IAAI,CAACW,aAAa,GAAGP,YAAY;EACjC,IAAI,CAACQ,aAAa,GAAGP,YAAY;EACjC,IAAI,CAACQ,KAAK,GAAGZ,IAAI;EACjB,IAAI,CAACa,UAAU,GAAGZ,SAAS;EAC3B,IAAI,CAACa,MAAM,GAAGZ,KAAK;EACnB,IAAI,CAACa,SAAS,GAAGV,QAAQ;EACzB,IAAI,CAACW,iBAAiB,GAAGC,SAAS;EAClC,IAAI,CAACC,qBAAqB,GAAGD,SAAS;EACtC,IAAI,CAACE,cAAc,GAAGF,SAAS;EAC/B,IAAI,CAACG,YAAY,GAAGH,SAAS;EAC7B,IAAI,CAACI,MAAM,GAAG3B,mBAAmB,CAAC4B,QAAQ;EAC1C,IAAI,CAACC,QAAQ,GAAGN,SAAS;EACzB,IAAI,CAACO,WAAW,GAAGP,SAAS;AAC9B;AAEA,IAAI1B,OAAO,CAACkC,MAAM,CAACC,MAAM,CAAC,EAAE;EAC1B9B,eAAe,CAAC+B,SAAS,GAAGF,MAAM,CAACC,MAAM,CAACjC,cAAc,CAACkC,SAAS,CAAC;EACnE/B,eAAe,CAAC+B,SAAS,CAACC,WAAW,GAAGhC,eAAe;AACzD;AAEA6B,MAAM,CAACI,gBAAgB,CAACjC,eAAe,CAAC+B,SAAS,EAAE;EACjD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEtB,QAAQ,EAAE;IACRyB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACf,SAAS;IACvB;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEgB,WAAW,EAAE;IACXD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACV,YAAY;IAC1B;EACF;AACF,CAAC,CAAC;AAEF,eAAeY,aAAaA,CAACC,MAAM,EAAE;EACnC,MAAMlC,aAAa,GAAGkC,MAAM,CAACxB,cAAc;EAC3C,IAAI;IACF,MAAMyB,gBAAgB,GAAGnC,aAAa,CAACoC,mBAAmB,CAAC;MACzDnC,IAAI,EAAEiC,MAAM,CAACrB,KAAK;MAClBwB,YAAY,EAAEH,MAAM,CAACnB,MAAM,CAACuB,UAAU;MACtClC,YAAY,EAAE8B,MAAM,CAACvB,aAAa;MAClCN,YAAY,EAAE6B,MAAM,CAACtB;IACvB,CAAC,CAAC;IACFsB,MAAM,CAACjB,iBAAiB,GAAGkB,gBAAgB;IAC3C,MAAMA,gBAAgB,CAACI,IAAI,CAAC,CAAC;IAE7B,IAAIL,MAAM,CAACM,WAAW,CAAC,CAAC,EAAE;MACxB;IACF;IAEAN,MAAM,CAACf,qBAAqB,GAAGgB,gBAAgB,CAACM,UAAU;IAC1DP,MAAM,CAACZ,MAAM,GAAG3B,mBAAmB,CAAC+C,UAAU;IAC9C,OAAOR,MAAM;EACf,CAAC,CAAC,OAAOS,KAAK,EAAE;IACd,IAAIT,MAAM,CAACM,WAAW,CAAC,CAAC,EAAE;MACxB;IACF;IAEAI,WAAW,CAACV,MAAM,EAAES,KAAK,CAAC;EAC5B;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA9C,eAAe,CAAC+B,SAAS,CAACW,IAAI,GAAG,kBAAkB;EACjD,IAAI/C,OAAO,CAAC,IAAI,CAACgC,QAAQ,CAAC,EAAE;IAC1B,OAAO,IAAI,CAACA,QAAQ;EACtB;EAEA,IAAI,CAACF,MAAM,GAAG3B,mBAAmB,CAACkD,OAAO;EACzC,IAAI,CAACrB,QAAQ,GAAGS,aAAa,CAAC,IAAI,CAAC;EACnC,OAAO,IAAI,CAACT,QAAQ;AACtB,CAAC;AAED,SAASoB,WAAWA,CAACE,WAAW,EAAEH,KAAK,EAAE;EACvCG,WAAW,CAACC,MAAM,CAAC,CAAC;EACpBD,WAAW,CAACxB,MAAM,GAAG3B,mBAAmB,CAACqD,MAAM;EAC/C,MAAMC,YAAY,GAAG,sBAAsB;EAC3C,MAAMH,WAAW,CAACI,QAAQ,CAACD,YAAY,EAAEN,KAAK,CAAC;AACjD;AAEA,eAAeQ,aAAaA,CAACjB,MAAM,EAAEkB,aAAa,EAAE;EAClD,IAAI;IACF,MAAMC,OAAO,GAAG,MAAMD,aAAa;IACnC,IAAIlB,MAAM,CAACM,WAAW,CAAC,CAAC,EAAE;MACxB;IACF;;IAEA;IACAN,MAAM,CAACa,MAAM,CAAC,CAAC;IAEfb,MAAM,CAACb,YAAY,GAAG;MACpBiC,OAAO,EAAED,OAAO,CAACE,UAAU;MAC3BC,gBAAgB,EAAEH,OAAO,CAACI;IAC5B,CAAC;IACDvB,MAAM,CAACZ,MAAM,GAAG3B,mBAAmB,CAAC+D,KAAK;IACzC,OAAOxB,MAAM,CAACtB,aAAa;EAC7B,CAAC,CAAC,OAAO+B,KAAK,EAAE;IACd,IAAIT,MAAM,CAACM,WAAW,CAAC,CAAC,EAAE;MACxB;IACF;;IAEA;IACAN,MAAM,CAACT,WAAW,GAAGkB,KAAK;EAC5B;AACF;AAEA,MAAMgB,4BAA4B,GAAG,CAAC,CAAC;AACvCA,4BAA4B,CAAC/D,uBAAuB,CAACgE,QAAQ,CAAC,GAAG,UAAU;AAC3ED,4BAA4B,CAAC/D,uBAAuB,CAACiE,MAAM,CAAC,GAAG,QAAQ;AACvEF,4BAA4B,CAAC/D,uBAAuB,CAACkE,KAAK,CAAC,GAAG,OAAO;AACrEH,4BAA4B,CAAC/D,uBAAuB,CAACmE,QAAQ,CAAC,GAAG,WAAW;AAE5E,SAASC,qBAAqBA,CAACC,SAAS,EAAE;EACxC,KAAK,MAAMC,QAAQ,IAAIP,4BAA4B,EAAE;IACnD,IAAIA,4BAA4B,CAACQ,cAAc,CAACD,QAAQ,CAAC,EAAE;MACzD,IAAID,SAAS,CAACG,UAAU,CAACF,QAAQ,CAAC,EAAE;QAClC,OAAOP,4BAA4B,CAACO,QAAQ,CAAC;MAC/C;IACF;EACF;EAEA,OAAOhD,SAAS;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACArB,eAAe,CAAC+B,SAAS,CAACyC,OAAO,GAAG,UAAUC,UAAU,EAAE;EACxD;EACAjF,KAAK,CAACkB,MAAM,CAACE,MAAM,CAAC,YAAY,EAAE6D,UAAU,CAAC;EAC7C;;EAEA,IAAI,IAAI,CAAChD,MAAM,KAAK3B,mBAAmB,CAAC+D,KAAK,EAAE;IAC7C,OAAO,IAAI;EACb;EAEA,IAAI,IAAI,CAACpC,MAAM,KAAK3B,mBAAmB,CAAC+C,UAAU,EAAE;IAClD,OAAO,KAAK;EACd;EAEA,IAAIlD,OAAO,CAAC,IAAI,CAACiC,WAAW,CAAC,EAAE;IAC7BmB,WAAW,CAAC,IAAI,EAAE,IAAI,CAACnB,WAAW,CAAC;EACrC;EAEA,IAAI,CAACjC,OAAO,CAAC,IAAI,CAAC2B,qBAAqB,CAAC,EAAE;IACxC;IACA,OAAO,KAAK;EACd;EAEA,IAAI3B,OAAO,CAAC,IAAI,CAAC4B,cAAc,CAAC,EAAE;IAChC;IACA,OAAO,KAAK;EACd;EAEA,MAAMjB,KAAK,GAAG,IAAI,CAACY,MAAM;EACzB,MAAMb,SAAS,GAAG,IAAI,CAACY,UAAU;EACjC,MAAMb,IAAI,GAAG,IAAI,CAACY,KAAK;EACvB,MAAM0D,WAAW,GAAGtE,IAAI,CAACsE,WAAW;EACpC,MAAMlC,YAAY,GAAGlC,KAAK,CAACmC,UAAU;EACrC,MAAMA,UAAU,GAAGiC,WAAW,CAAClC,YAAY,CAAC;EAC5C,MAAMmC,oBAAoB,GAAGrE,KAAK,CAACsE,UAAU;;EAE7C;EACA;EACA,MAAMC,yBAAyB,GAAG,EAAE;EAEpC,KAAK,MAAMT,SAAS,IAAI/D,SAAS,CAACuE,UAAU,EAAE;IAC5C,IAAIvE,SAAS,CAACuE,UAAU,CAACN,cAAc,CAACF,SAAS,CAAC,EAAE;MAClD,MAAMU,kBAAkB,GAAGX,qBAAqB,CAACC,SAAS,CAAC;MAC3D,IAAIzE,OAAO,CAACmF,kBAAkB,CAAC,EAAE;QAC/B,MAAMC,QAAQ,GAAG3E,IAAI,CAAC4E,SAAS,CAAC3E,SAAS,CAACuE,UAAU,CAACR,SAAS,CAAC,CAAC;QAChE,IAAIW,QAAQ,CAACE,aAAa,KAAKxF,iBAAiB,CAACyF,KAAK,EAAE;UACtD,IAAI,CAACL,yBAAyB,CAACM,QAAQ,CAACL,kBAAkB,CAAC,EAAE;YAC3DD,yBAAyB,CAACO,IAAI,CAACN,kBAAkB,CAAC;UACpD;QACF;MACF;IACF;EACF;EAEA,MAAMO,aAAa,GAAG;IACpB;IACA;IACA;IACA;IACAC,KAAK,EAAE,IAAIC,UAAU,CAAC,IAAI,CAACjE,qBAAqB,CAAC;IACjDmB,UAAU,EAAEA,UAAU;IACtBkC,oBAAoB,EAAEA,oBAAoB;IAC1Ca,kBAAkB,EAAE,IAAI;IACxBX,yBAAyB,EAAEA;EAC7B,CAAC;EAED,MAAMtB,aAAa,GAAG3D,WAAW,CAAC6F,gBAAgB,CAACJ,aAAa,CAAC;EAEjE,IAAI,CAAC1F,OAAO,CAAC4D,aAAa,CAAC,EAAE;IAC3B;IACA,OAAO,KAAK;EACd;EAEA,IAAI,CAAChC,cAAc,GAAG+B,aAAa,CAAC,IAAI,EAAEC,aAAa,CAAC;AAC1D,CAAC;;AAED;AACA;AACA;AACA;AACAvD,eAAe,CAAC+B,SAAS,CAACmB,MAAM,GAAG,YAAY;EAC7C,IAAIvD,OAAO,CAAC,IAAI,CAACyB,iBAAiB,CAAC,EAAE;IACnC,IAAI,CAACP,cAAc,CAACqC,MAAM,CAAC,IAAI,CAAC9B,iBAAiB,CAAC;EACpD;EAEA,IAAI,CAACA,iBAAiB,GAAGC,SAAS;EAClC,IAAI,CAACC,qBAAqB,GAAGD,SAAS;EACtC,IAAI,CAACG,YAAY,GAAGH,SAAS;EAC7B,IAAI,CAACL,KAAK,GAAGK,SAAS;EACtB,IAAI,CAACJ,UAAU,GAAGI,SAAS;AAC7B,CAAC;AAED,eAAerB,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}