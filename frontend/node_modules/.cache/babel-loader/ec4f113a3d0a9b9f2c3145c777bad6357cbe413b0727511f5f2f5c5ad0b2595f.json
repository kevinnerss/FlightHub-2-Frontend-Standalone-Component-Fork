{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArrayFacade from \"../Renderer/VertexArrayFacade.js\";\nimport PointPrimitiveCollectionFS from \"../Shaders/PointPrimitiveCollectionFS.js\";\nimport PointPrimitiveCollectionVS from \"../Shaders/PointPrimitiveCollectionVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport BlendOption from \"./BlendOption.js\";\nimport PointPrimitive from \"./PointPrimitive.js\";\nimport SceneMode from \"./SceneMode.js\";\nconst SHOW_INDEX = PointPrimitive.SHOW_INDEX;\nconst POSITION_INDEX = PointPrimitive.POSITION_INDEX;\nconst COLOR_INDEX = PointPrimitive.COLOR_INDEX;\nconst OUTLINE_COLOR_INDEX = PointPrimitive.OUTLINE_COLOR_INDEX;\nconst OUTLINE_WIDTH_INDEX = PointPrimitive.OUTLINE_WIDTH_INDEX;\nconst PIXEL_SIZE_INDEX = PointPrimitive.PIXEL_SIZE_INDEX;\nconst SCALE_BY_DISTANCE_INDEX = PointPrimitive.SCALE_BY_DISTANCE_INDEX;\nconst TRANSLUCENCY_BY_DISTANCE_INDEX = PointPrimitive.TRANSLUCENCY_BY_DISTANCE_INDEX;\nconst DISTANCE_DISPLAY_CONDITION_INDEX = PointPrimitive.DISTANCE_DISPLAY_CONDITION_INDEX;\nconst DISABLE_DEPTH_DISTANCE_INDEX = PointPrimitive.DISABLE_DEPTH_DISTANCE_INDEX;\nconst SPLIT_DIRECTION_INDEX = PointPrimitive.SPLIT_DIRECTION_INDEX;\nconst NUMBER_OF_PROPERTIES = PointPrimitive.NUMBER_OF_PROPERTIES;\nconst attributeLocations = {\n  positionHighAndSize: 0,\n  positionLowAndOutline: 1,\n  compressedAttribute0: 2,\n  // color, outlineColor, pick color\n  compressedAttribute1: 3,\n  // show, translucency by distance, some free space\n  scaleByDistance: 4,\n  distanceDisplayConditionAndDisableDepthAndSplitDirection: 5\n};\n\n/**\n * A renderable collection of points.\n * <br /><br />\n * Points are added and removed from the collection using {@link PointPrimitiveCollection#add}\n * and {@link PointPrimitiveCollection#remove}.\n *\n * @alias PointPrimitiveCollection\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each point from model to world coordinates.\n * @param {boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {BlendOption} [options.blendOption=BlendOption.OPAQUE_AND_TRANSLUCENT] The point blending option. The default\n * is used for rendering both opaque and translucent points. However, if either all of the points are completely opaque or all are completely translucent,\n * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.\n * @param {boolean} [options.show=true] Determines if the primitives in the collection will be shown.\n *\n * @performance For best performance, prefer a few collections, each with many points, to\n * many collections with only a few points each.  Organize collections so that points\n * with the same update frequency are in the same collection, i.e., points that do not\n * change should be in one collection; points that change every frame should be in another\n * collection; and so on.\n *\n *\n * @example\n * // Create a pointPrimitive collection with two points\n * const points = scene.primitives.add(new Cesium.PointPrimitiveCollection());\n * points.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   color : Cesium.Color.YELLOW\n * });\n * points.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   color : Cesium.Color.CYAN\n * });\n *\n * @see PointPrimitiveCollection#add\n * @see PointPrimitiveCollection#remove\n * @see PointPrimitive\n */\nfunction PointPrimitiveCollection(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  this._sp = undefined;\n  this._spTranslucent = undefined;\n  this._rsOpaque = undefined;\n  this._rsTranslucent = undefined;\n  this._vaf = undefined;\n  this._pointPrimitives = [];\n  this._pointPrimitivesToUpdate = [];\n  this._pointPrimitivesToUpdateIndex = 0;\n  this._pointPrimitivesRemoved = false;\n  this._createVertexArray = false;\n  this._shaderScaleByDistance = false;\n  this._compiledShaderScaleByDistance = false;\n  this._shaderTranslucencyByDistance = false;\n  this._compiledShaderTranslucencyByDistance = false;\n  this._shaderDistanceDisplayCondition = false;\n  this._compiledShaderDistanceDisplayCondition = false;\n  this._shaderDisableDepthDistance = false;\n  this._compiledShaderDisableDepthDistance = false;\n  this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);\n  this._maxPixelSize = 1.0;\n  this._baseVolume = new BoundingSphere();\n  this._baseVolumeWC = new BoundingSphere();\n  this._baseVolume2D = new BoundingSphere();\n  this._boundingVolume = new BoundingSphere();\n  this._boundingVolumeDirty = false;\n  this._colorCommands = [];\n\n  /**\n   * Determines if primitives in this collection will be shown.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.show = options.show ?? true;\n\n  /**\n   * The 4x4 transformation matrix that transforms each point in this collection from model to world coordinates.\n   * When this is the identity matrix, the pointPrimitives are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   * @default {@link Matrix4.IDENTITY}\n   *\n   *\n   * @example\n   * const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * pointPrimitives.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * pointPrimitives.add({\n   *   color : Cesium.Color.ORANGE,\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0) // center\n   * });\n   * pointPrimitives.add({\n   *   color : Cesium.Color.YELLOW,\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0) // east\n   * });\n   * pointPrimitives.add({\n   *   color : Cesium.Color.GREEN,\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0) // north\n   * });\n   * pointPrimitives.add({\n   *   color : Cesium.Color.CYAN,\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0) // up\n   * });\n   *\n   * @see Transforms.eastNorthUpToFixedFrame\n   */\n  this.modelMatrix = Matrix4.clone(options.modelMatrix ?? Matrix4.IDENTITY);\n  this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = options.debugShowBoundingVolume ?? false;\n\n  /**\n   * The point blending option. The default is used for rendering both opaque and translucent points.\n   * However, if either all of the points are completely opaque or all are completely translucent,\n   * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve\n   * performance by up to 2x.\n   * @type {BlendOption}\n   * @default BlendOption.OPAQUE_AND_TRANSLUCENT\n   */\n  this.blendOption = options.blendOption ?? BlendOption.OPAQUE_AND_TRANSLUCENT;\n  this._blendOption = undefined;\n  this._mode = SceneMode.SCENE3D;\n  this._maxTotalPointSize = 1;\n\n  // The buffer usage for each attribute is determined based on the usage of the attribute over time.\n  this._buffersUsage = [BufferUsage.STATIC_DRAW,\n  // SHOW_INDEX\n  BufferUsage.STATIC_DRAW,\n  // POSITION_INDEX\n  BufferUsage.STATIC_DRAW,\n  // COLOR_INDEX\n  BufferUsage.STATIC_DRAW,\n  // OUTLINE_COLOR_INDEX\n  BufferUsage.STATIC_DRAW,\n  // OUTLINE_WIDTH_INDEX\n  BufferUsage.STATIC_DRAW,\n  // PIXEL_SIZE_INDEX\n  BufferUsage.STATIC_DRAW,\n  // SCALE_BY_DISTANCE_INDEX\n  BufferUsage.STATIC_DRAW,\n  // TRANSLUCENCY_BY_DISTANCE_INDEX\n  BufferUsage.STATIC_DRAW // DISTANCE_DISPLAY_CONDITION_INDEX\n  ];\n  const that = this;\n  this._uniforms = {\n    u_maxTotalPointSize: function () {\n      return that._maxTotalPointSize;\n    }\n  };\n}\nObject.defineProperties(PointPrimitiveCollection.prototype, {\n  /**\n   * Returns the number of points in this collection.  This is commonly used with\n   * {@link PointPrimitiveCollection#get} to iterate over all the points\n   * in the collection.\n   * @memberof PointPrimitiveCollection.prototype\n   * @type {number}\n   */\n  length: {\n    get: function () {\n      removePointPrimitives(this);\n      return this._pointPrimitives.length;\n    }\n  }\n});\nfunction destroyPointPrimitives(pointPrimitives) {\n  const length = pointPrimitives.length;\n  for (let i = 0; i < length; ++i) {\n    if (pointPrimitives[i]) {\n      pointPrimitives[i]._destroy();\n    }\n  }\n}\n\n/**\n * Creates and adds a point with the specified initial properties to the collection.\n * The added point is returned so it can be modified or removed from the collection later.\n *\n * @param {object}[options] A template describing the point's properties as shown in Example 1.\n * @returns {PointPrimitive} The point that was added to the collection.\n *\n * @performance Calling <code>add</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, add as many pointPrimitives as possible before calling <code>update</code>.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Example 1:  Add a point, specifying all the default values.\n * const p = pointPrimitives.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   pixelSize : 10.0,\n *   color : Cesium.Color.WHITE,\n *   outlineColor : Cesium.Color.TRANSPARENT,\n *   outlineWidth : 0.0,\n *   id : undefined\n * });\n *\n * @example\n * // Example 2:  Specify only the point's cartographic position.\n * const p = pointPrimitives.add({\n *   position : Cesium.Cartesian3.fromDegrees(longitude, latitude, height)\n * });\n *\n * @see PointPrimitiveCollection#remove\n * @see PointPrimitiveCollection#removeAll\n */\nPointPrimitiveCollection.prototype.add = function (options) {\n  const p = new PointPrimitive(options, this);\n  p._index = this._pointPrimitives.length;\n  this._pointPrimitives.push(p);\n  this._createVertexArray = true;\n  return p;\n};\n\n/**\n * Removes a point from the collection.\n *\n * @param {PointPrimitive} pointPrimitive The point to remove.\n * @returns {boolean} <code>true</code> if the point was removed; <code>false</code> if the point was not found in the collection.\n *\n * @performance Calling <code>remove</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, remove as many points as possible before calling <code>update</code>.\n * If you intend to temporarily hide a point, it is usually more efficient to call\n * {@link PointPrimitive#show} instead of removing and re-adding the point.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * const p = pointPrimitives.add(...);\n * pointPrimitives.remove(p);  // Returns true\n *\n * @see PointPrimitiveCollection#add\n * @see PointPrimitiveCollection#removeAll\n * @see PointPrimitive#show\n */\nPointPrimitiveCollection.prototype.remove = function (pointPrimitive) {\n  if (this.contains(pointPrimitive)) {\n    this._pointPrimitives[pointPrimitive._index] = null; // Removed later\n    this._pointPrimitivesRemoved = true;\n    this._createVertexArray = true;\n    pointPrimitive._destroy();\n    return true;\n  }\n  return false;\n};\n\n/**\n * Removes all points from the collection.\n *\n * @performance <code>O(n)</code>.  It is more efficient to remove all the points\n * from a collection and then add new ones than to create a new collection entirely.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * pointPrimitives.add(...);\n * pointPrimitives.add(...);\n * pointPrimitives.removeAll();\n *\n * @see PointPrimitiveCollection#add\n * @see PointPrimitiveCollection#remove\n */\nPointPrimitiveCollection.prototype.removeAll = function () {\n  destroyPointPrimitives(this._pointPrimitives);\n  this._pointPrimitives = [];\n  this._pointPrimitivesToUpdate = [];\n  this._pointPrimitivesToUpdateIndex = 0;\n  this._pointPrimitivesRemoved = false;\n  this._createVertexArray = true;\n};\nfunction removePointPrimitives(pointPrimitiveCollection) {\n  if (pointPrimitiveCollection._pointPrimitivesRemoved) {\n    pointPrimitiveCollection._pointPrimitivesRemoved = false;\n    const newPointPrimitives = [];\n    const pointPrimitives = pointPrimitiveCollection._pointPrimitives;\n    const length = pointPrimitives.length;\n    for (let i = 0, j = 0; i < length; ++i) {\n      const pointPrimitive = pointPrimitives[i];\n      if (pointPrimitive) {\n        pointPrimitive._index = j++;\n        newPointPrimitives.push(pointPrimitive);\n      }\n    }\n    pointPrimitiveCollection._pointPrimitives = newPointPrimitives;\n  }\n}\nPointPrimitiveCollection.prototype._updatePointPrimitive = function (pointPrimitive, propertyChanged) {\n  if (!pointPrimitive._dirty) {\n    this._pointPrimitivesToUpdate[this._pointPrimitivesToUpdateIndex++] = pointPrimitive;\n  }\n  ++this._propertiesChanged[propertyChanged];\n};\n\n/**\n * Check whether this collection contains a given point.\n *\n * @param {PointPrimitive} [pointPrimitive] The point to check for.\n * @returns {boolean} true if this collection contains the point, false otherwise.\n *\n * @see PointPrimitiveCollection#get\n */\nPointPrimitiveCollection.prototype.contains = function (pointPrimitive) {\n  return defined(pointPrimitive) && pointPrimitive._pointPrimitiveCollection === this;\n};\n\n/**\n * Returns the point in the collection at the specified index.  Indices are zero-based\n * and increase as points are added.  Removing a point shifts all points after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link PointPrimitiveCollection#length} to iterate over all the points\n * in the collection.\n *\n * @param {number} index The zero-based index of the point.\n * @returns {PointPrimitive} The point at the specified index.\n *\n * @performance Expected constant time.  If points were removed from the collection and\n * {@link PointPrimitiveCollection#update} was not called, an implicit <code>O(n)</code>\n * operation is performed.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Toggle the show property of every point in the collection\n * const len = pointPrimitives.length;\n * for (let i = 0; i < len; ++i) {\n *   const p = pointPrimitives.get(i);\n *   p.show = !p.show;\n * }\n *\n * @see PointPrimitiveCollection#length\n */\nPointPrimitiveCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n  //>>includeEnd('debug');\n\n  removePointPrimitives(this);\n  return this._pointPrimitives[index];\n};\nPointPrimitiveCollection.prototype.computeNewBuffersUsage = function () {\n  const buffersUsage = this._buffersUsage;\n  let usageChanged = false;\n  const properties = this._propertiesChanged;\n  for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n    const newUsage = properties[k] === 0 ? BufferUsage.STATIC_DRAW : BufferUsage.STREAM_DRAW;\n    usageChanged = usageChanged || buffersUsage[k] !== newUsage;\n    buffersUsage[k] = newUsage;\n  }\n  return usageChanged;\n};\nfunction createVAF(context, numberOfPointPrimitives, buffersUsage) {\n  return new VertexArrayFacade(context, [{\n    index: attributeLocations.positionHighAndSize,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[POSITION_INDEX]\n  }, {\n    index: attributeLocations.positionLowAndShow,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[POSITION_INDEX]\n  }, {\n    index: attributeLocations.compressedAttribute0,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[COLOR_INDEX]\n  }, {\n    index: attributeLocations.compressedAttribute1,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[TRANSLUCENCY_BY_DISTANCE_INDEX]\n  }, {\n    index: attributeLocations.scaleByDistance,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[SCALE_BY_DISTANCE_INDEX]\n  }, {\n    index: attributeLocations.distanceDisplayConditionAndDisableDepthAndSplitDirection,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.FLOAT,\n    usage: buffersUsage[DISTANCE_DISPLAY_CONDITION_INDEX]\n  }], numberOfPointPrimitives); // 1 vertex per pointPrimitive\n}\n\n///////////////////////////////////////////////////////////////////////////\n\n// PERFORMANCE_IDEA:  Save memory if a property is the same for all pointPrimitives, use a latched attribute state,\n// instead of storing it in a vertex buffer.\n\nconst writePositionScratch = new EncodedCartesian3();\nfunction writePositionSizeAndOutline(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {\n  const i = pointPrimitive._index;\n  const position = pointPrimitive._getActualPosition();\n  if (pointPrimitiveCollection._mode === SceneMode.SCENE3D) {\n    BoundingSphere.expand(pointPrimitiveCollection._baseVolume, position, pointPrimitiveCollection._baseVolume);\n    pointPrimitiveCollection._boundingVolumeDirty = true;\n  }\n  EncodedCartesian3.fromCartesian(position, writePositionScratch);\n  const pixelSize = pointPrimitive.pixelSize;\n  const outlineWidth = pointPrimitive.outlineWidth;\n  pointPrimitiveCollection._maxPixelSize = Math.max(pointPrimitiveCollection._maxPixelSize, pixelSize + outlineWidth);\n  const positionHighWriter = vafWriters[attributeLocations.positionHighAndSize];\n  const high = writePositionScratch.high;\n  positionHighWriter(i, high.x, high.y, high.z, pixelSize);\n  const positionLowWriter = vafWriters[attributeLocations.positionLowAndOutline];\n  const low = writePositionScratch.low;\n  positionLowWriter(i, low.x, low.y, low.z, outlineWidth);\n}\nconst LEFT_SHIFT16 = 65536.0; // 2^16\nconst LEFT_SHIFT8 = 256.0; // 2^8\n\nfunction writeCompressedAttrib0(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {\n  const i = pointPrimitive._index;\n  const color = pointPrimitive.color;\n  const pickColor = pointPrimitive.getPickId(context).color;\n  const outlineColor = pointPrimitive.outlineColor;\n  let red = Color.floatToByte(color.red);\n  let green = Color.floatToByte(color.green);\n  let blue = Color.floatToByte(color.blue);\n  const compressed0 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n  red = Color.floatToByte(outlineColor.red);\n  green = Color.floatToByte(outlineColor.green);\n  blue = Color.floatToByte(outlineColor.blue);\n  const compressed1 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n  red = Color.floatToByte(pickColor.red);\n  green = Color.floatToByte(pickColor.green);\n  blue = Color.floatToByte(pickColor.blue);\n  const compressed2 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n  const compressed3 = Color.floatToByte(color.alpha) * LEFT_SHIFT16 + Color.floatToByte(outlineColor.alpha) * LEFT_SHIFT8 + Color.floatToByte(pickColor.alpha);\n  const writer = vafWriters[attributeLocations.compressedAttribute0];\n  writer(i, compressed0, compressed1, compressed2, compressed3);\n}\nfunction writeCompressedAttrib1(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {\n  const i = pointPrimitive._index;\n  let near = 0.0;\n  let nearValue = 1.0;\n  let far = 1.0;\n  let farValue = 1.0;\n  const translucency = pointPrimitive.translucencyByDistance;\n  if (defined(translucency)) {\n    near = translucency.near;\n    nearValue = translucency.nearValue;\n    far = translucency.far;\n    farValue = translucency.farValue;\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // translucency by distance calculation in shader need not be enabled\n      // until a pointPrimitive with near and far !== 1.0 is found\n      pointPrimitiveCollection._shaderTranslucencyByDistance = true;\n    }\n  }\n  let show = pointPrimitive.show && pointPrimitive.clusterShow;\n\n  // If the color alphas are zero, do not show this pointPrimitive.  This lets us avoid providing\n  // color during the pick pass and also eliminates a discard in the fragment shader.\n  if (pointPrimitive.color.alpha === 0.0 && pointPrimitive.outlineColor.alpha === 0.0) {\n    show = false;\n  }\n  nearValue = CesiumMath.clamp(nearValue, 0.0, 1.0);\n  nearValue = nearValue === 1.0 ? 255.0 : nearValue * 255.0 | 0;\n  const compressed0 = (show ? 1.0 : 0.0) * LEFT_SHIFT8 + nearValue;\n  farValue = CesiumMath.clamp(farValue, 0.0, 1.0);\n  farValue = farValue === 1.0 ? 255.0 : farValue * 255.0 | 0;\n  const compressed1 = farValue;\n  const writer = vafWriters[attributeLocations.compressedAttribute1];\n  writer(i, compressed0, compressed1, near, far);\n}\nfunction writeScaleByDistance(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {\n  const i = pointPrimitive._index;\n  const writer = vafWriters[attributeLocations.scaleByDistance];\n  let near = 0.0;\n  let nearValue = 1.0;\n  let far = 1.0;\n  let farValue = 1.0;\n  const scale = pointPrimitive.scaleByDistance;\n  if (defined(scale)) {\n    near = scale.near;\n    nearValue = scale.nearValue;\n    far = scale.far;\n    farValue = scale.farValue;\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // scale by distance calculation in shader need not be enabled\n      // until a pointPrimitive with near and far !== 1.0 is found\n      pointPrimitiveCollection._shaderScaleByDistance = true;\n    }\n  }\n  writer(i, near, nearValue, far, farValue);\n}\nfunction writeDistanceDisplayConditionAndDepthDisableAndSplitDirection(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {\n  const i = pointPrimitive._index;\n  const writer = vafWriters[attributeLocations.distanceDisplayConditionAndDisableDepthAndSplitDirection];\n  let near = 0.0;\n  let far = Number.MAX_VALUE;\n  const distanceDisplayCondition = pointPrimitive.distanceDisplayCondition;\n  if (defined(distanceDisplayCondition)) {\n    near = distanceDisplayCondition.near;\n    far = distanceDisplayCondition.far;\n    near *= near;\n    far *= far;\n    pointPrimitiveCollection._shaderDistanceDisplayCondition = true;\n  }\n  let disableDepthTestDistance = pointPrimitive.disableDepthTestDistance;\n  disableDepthTestDistance *= disableDepthTestDistance;\n  if (disableDepthTestDistance > 0.0) {\n    pointPrimitiveCollection._shaderDisableDepthDistance = true;\n    if (disableDepthTestDistance === Number.POSITIVE_INFINITY) {\n      disableDepthTestDistance = -1.0;\n    }\n  }\n  let direction = 0.0;\n  const split = pointPrimitive.splitDirection;\n  if (defined(split)) {\n    direction = split;\n  }\n  writer(i, near, far, disableDepthTestDistance, direction);\n}\nfunction writePointPrimitive(pointPrimitiveCollection, context, vafWriters, pointPrimitive) {\n  writePositionSizeAndOutline(pointPrimitiveCollection, context, vafWriters, pointPrimitive);\n  writeCompressedAttrib0(pointPrimitiveCollection, context, vafWriters, pointPrimitive);\n  writeCompressedAttrib1(pointPrimitiveCollection, context, vafWriters, pointPrimitive);\n  writeScaleByDistance(pointPrimitiveCollection, context, vafWriters, pointPrimitive);\n  writeDistanceDisplayConditionAndDepthDisableAndSplitDirection(pointPrimitiveCollection, context, vafWriters, pointPrimitive);\n}\nfunction recomputeActualPositions(pointPrimitiveCollection, pointPrimitives, length, frameState, modelMatrix, recomputeBoundingVolume) {\n  let boundingVolume;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingVolume = pointPrimitiveCollection._baseVolume;\n    pointPrimitiveCollection._boundingVolumeDirty = true;\n  } else {\n    boundingVolume = pointPrimitiveCollection._baseVolume2D;\n  }\n  const positions = [];\n  for (let i = 0; i < length; ++i) {\n    const pointPrimitive = pointPrimitives[i];\n    const position = pointPrimitive.position;\n    const actualPosition = PointPrimitive._computeActualPosition(position, frameState, modelMatrix);\n    if (defined(actualPosition)) {\n      pointPrimitive._setActualPosition(actualPosition);\n      if (recomputeBoundingVolume) {\n        positions.push(actualPosition);\n      } else {\n        BoundingSphere.expand(boundingVolume, actualPosition, boundingVolume);\n      }\n    }\n  }\n  if (recomputeBoundingVolume) {\n    BoundingSphere.fromPoints(positions, boundingVolume);\n  }\n}\nfunction updateMode(pointPrimitiveCollection, frameState) {\n  const mode = frameState.mode;\n  const pointPrimitives = pointPrimitiveCollection._pointPrimitives;\n  const pointPrimitivesToUpdate = pointPrimitiveCollection._pointPrimitivesToUpdate;\n  const modelMatrix = pointPrimitiveCollection._modelMatrix;\n  if (pointPrimitiveCollection._createVertexArray || pointPrimitiveCollection._mode !== mode || mode !== SceneMode.SCENE3D && !Matrix4.equals(modelMatrix, pointPrimitiveCollection.modelMatrix)) {\n    pointPrimitiveCollection._mode = mode;\n    Matrix4.clone(pointPrimitiveCollection.modelMatrix, modelMatrix);\n    pointPrimitiveCollection._createVertexArray = true;\n    if (mode === SceneMode.SCENE3D || mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {\n      recomputeActualPositions(pointPrimitiveCollection, pointPrimitives, pointPrimitives.length, frameState, modelMatrix, true);\n    }\n  } else if (mode === SceneMode.MORPHING) {\n    recomputeActualPositions(pointPrimitiveCollection, pointPrimitives, pointPrimitives.length, frameState, modelMatrix, true);\n  } else if (mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {\n    recomputeActualPositions(pointPrimitiveCollection, pointPrimitivesToUpdate, pointPrimitiveCollection._pointPrimitivesToUpdateIndex, frameState, modelMatrix, false);\n  }\n}\nfunction updateBoundingVolume(collection, frameState, boundingVolume) {\n  const pixelSize = frameState.camera.getPixelSize(boundingVolume, frameState.context.drawingBufferWidth, frameState.context.drawingBufferHeight);\n  const size = pixelSize * collection._maxPixelSize;\n  boundingVolume.radius += size;\n}\nconst scratchWriterArray = [];\n\n/**\n * @private\n */\nPointPrimitiveCollection.prototype.update = function (frameState) {\n  removePointPrimitives(this);\n  if (!this.show) {\n    return;\n  }\n  this._maxTotalPointSize = ContextLimits.maximumAliasedPointSize;\n  updateMode(this, frameState);\n  const pointPrimitives = this._pointPrimitives;\n  const pointPrimitivesLength = pointPrimitives.length;\n  const pointPrimitivesToUpdate = this._pointPrimitivesToUpdate;\n  const pointPrimitivesToUpdateLength = this._pointPrimitivesToUpdateIndex;\n  const properties = this._propertiesChanged;\n  const createVertexArray = this._createVertexArray;\n  let vafWriters;\n  const context = frameState.context;\n  const pass = frameState.passes;\n  const picking = pass.pick;\n\n  // PERFORMANCE_IDEA: Round robin multiple buffers.\n  if (createVertexArray || !picking && this.computeNewBuffersUsage()) {\n    this._createVertexArray = false;\n    for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n      properties[k] = 0;\n    }\n    this._vaf = this._vaf && this._vaf.destroy();\n    if (pointPrimitivesLength > 0) {\n      // PERFORMANCE_IDEA:  Instead of creating a new one, resize like std::vector.\n      this._vaf = createVAF(context, pointPrimitivesLength, this._buffersUsage);\n      vafWriters = this._vaf.writers;\n\n      // Rewrite entire buffer if pointPrimitives were added or removed.\n      for (let i = 0; i < pointPrimitivesLength; ++i) {\n        const pointPrimitive = this._pointPrimitives[i];\n        pointPrimitive._dirty = false; // In case it needed an update.\n        writePointPrimitive(this, context, vafWriters, pointPrimitive);\n      }\n      this._vaf.commit();\n    }\n    this._pointPrimitivesToUpdateIndex = 0;\n  } else if (pointPrimitivesToUpdateLength > 0) {\n    // PointPrimitives were modified, but none were added or removed.\n    const writers = scratchWriterArray;\n    writers.length = 0;\n    if (properties[POSITION_INDEX] || properties[OUTLINE_WIDTH_INDEX] || properties[PIXEL_SIZE_INDEX]) {\n      writers.push(writePositionSizeAndOutline);\n    }\n    if (properties[COLOR_INDEX] || properties[OUTLINE_COLOR_INDEX]) {\n      writers.push(writeCompressedAttrib0);\n    }\n    if (properties[SHOW_INDEX] || properties[TRANSLUCENCY_BY_DISTANCE_INDEX]) {\n      writers.push(writeCompressedAttrib1);\n    }\n    if (properties[SCALE_BY_DISTANCE_INDEX]) {\n      writers.push(writeScaleByDistance);\n    }\n    if (properties[DISTANCE_DISPLAY_CONDITION_INDEX] || properties[DISABLE_DEPTH_DISTANCE_INDEX] || properties[SPLIT_DIRECTION_INDEX]) {\n      writers.push(writeDistanceDisplayConditionAndDepthDisableAndSplitDirection);\n    }\n    const numWriters = writers.length;\n    vafWriters = this._vaf.writers;\n    if (pointPrimitivesToUpdateLength / pointPrimitivesLength > 0.1) {\n      // If more than 10% of pointPrimitive change, rewrite the entire buffer.\n\n      // PERFORMANCE_IDEA:  I totally made up 10% :).\n\n      for (let m = 0; m < pointPrimitivesToUpdateLength; ++m) {\n        const b = pointPrimitivesToUpdate[m];\n        b._dirty = false;\n        for (let n = 0; n < numWriters; ++n) {\n          writers[n](this, context, vafWriters, b);\n        }\n      }\n      this._vaf.commit();\n    } else {\n      for (let h = 0; h < pointPrimitivesToUpdateLength; ++h) {\n        const bb = pointPrimitivesToUpdate[h];\n        bb._dirty = false;\n        for (let o = 0; o < numWriters; ++o) {\n          writers[o](this, context, vafWriters, bb);\n        }\n        this._vaf.subCommit(bb._index, 1);\n      }\n      this._vaf.endSubCommits();\n    }\n    this._pointPrimitivesToUpdateIndex = 0;\n  }\n\n  // If the number of total pointPrimitives ever shrinks considerably\n  // Truncate pointPrimitivesToUpdate so that we free memory that we're\n  // not going to be using.\n  if (pointPrimitivesToUpdateLength > pointPrimitivesLength * 1.5) {\n    pointPrimitivesToUpdate.length = pointPrimitivesLength;\n  }\n  if (!defined(this._vaf) || !defined(this._vaf.va)) {\n    return;\n  }\n  if (this._boundingVolumeDirty) {\n    this._boundingVolumeDirty = false;\n    BoundingSphere.transform(this._baseVolume, this.modelMatrix, this._baseVolumeWC);\n  }\n  let boundingVolume;\n  let modelMatrix = Matrix4.IDENTITY;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    modelMatrix = this.modelMatrix;\n    boundingVolume = BoundingSphere.clone(this._baseVolumeWC, this._boundingVolume);\n  } else {\n    boundingVolume = BoundingSphere.clone(this._baseVolume2D, this._boundingVolume);\n  }\n  updateBoundingVolume(this, frameState, boundingVolume);\n  const blendOptionChanged = this._blendOption !== this.blendOption;\n  this._blendOption = this.blendOption;\n  if (blendOptionChanged) {\n    if (this._blendOption === BlendOption.OPAQUE || this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT) {\n      this._rsOpaque = RenderState.fromCache({\n        depthTest: {\n          enabled: true,\n          func: WebGLConstants.LEQUAL\n        },\n        depthMask: true\n      });\n    } else {\n      this._rsOpaque = undefined;\n    }\n    if (this._blendOption === BlendOption.TRANSLUCENT || this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT) {\n      this._rsTranslucent = RenderState.fromCache({\n        depthTest: {\n          enabled: true,\n          func: WebGLConstants.LEQUAL\n        },\n        depthMask: false,\n        blending: BlendingState.ALPHA_BLEND\n      });\n    } else {\n      this._rsTranslucent = undefined;\n    }\n  }\n  this._shaderDisableDepthDistance = this._shaderDisableDepthDistance || frameState.minimumDisableDepthTestDistance !== 0.0;\n  let vs;\n  let fs;\n  if (blendOptionChanged || this._shaderScaleByDistance && !this._compiledShaderScaleByDistance || this._shaderTranslucencyByDistance && !this._compiledShaderTranslucencyByDistance || this._shaderDistanceDisplayCondition && !this._compiledShaderDistanceDisplayCondition || this._shaderDisableDepthDistance !== this._compiledShaderDisableDepthDistance) {\n    vs = new ShaderSource({\n      sources: [PointPrimitiveCollectionVS]\n    });\n    if (this._shaderScaleByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_SCALING\");\n    }\n    if (this._shaderTranslucencyByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_TRANSLUCENCY\");\n    }\n    if (this._shaderDistanceDisplayCondition) {\n      vs.defines.push(\"DISTANCE_DISPLAY_CONDITION\");\n    }\n    if (this._shaderDisableDepthDistance) {\n      vs.defines.push(\"DISABLE_DEPTH_DISTANCE\");\n    }\n    if (this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT) {\n      fs = new ShaderSource({\n        defines: [\"OPAQUE\"],\n        sources: [PointPrimitiveCollectionFS]\n      });\n      this._sp = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._sp,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations\n      });\n      fs = new ShaderSource({\n        defines: [\"TRANSLUCENT\"],\n        sources: [PointPrimitiveCollectionFS]\n      });\n      this._spTranslucent = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._spTranslucent,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations\n      });\n    }\n    if (this._blendOption === BlendOption.OPAQUE) {\n      fs = new ShaderSource({\n        sources: [PointPrimitiveCollectionFS]\n      });\n      this._sp = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._sp,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations\n      });\n    }\n    if (this._blendOption === BlendOption.TRANSLUCENT) {\n      fs = new ShaderSource({\n        sources: [PointPrimitiveCollectionFS]\n      });\n      this._spTranslucent = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._spTranslucent,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations\n      });\n    }\n    this._compiledShaderScaleByDistance = this._shaderScaleByDistance;\n    this._compiledShaderTranslucencyByDistance = this._shaderTranslucencyByDistance;\n    this._compiledShaderDistanceDisplayCondition = this._shaderDistanceDisplayCondition;\n    this._compiledShaderDisableDepthDistance = this._shaderDisableDepthDistance;\n  }\n  let va;\n  let vaLength;\n  let command;\n  let j;\n  const commandList = frameState.commandList;\n  if (pass.render || picking) {\n    const colorList = this._colorCommands;\n    const opaque = this._blendOption === BlendOption.OPAQUE;\n    const opaqueAndTranslucent = this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT;\n    va = this._vaf.va;\n    vaLength = va.length;\n    colorList.length = vaLength;\n    const totalLength = opaqueAndTranslucent ? vaLength * 2 : vaLength;\n    for (j = 0; j < totalLength; ++j) {\n      const opaqueCommand = opaque || opaqueAndTranslucent && j % 2 === 0;\n      command = colorList[j];\n      if (!defined(command)) {\n        command = colorList[j] = new DrawCommand();\n      }\n      command.primitiveType = PrimitiveType.POINTS;\n      command.pass = opaqueCommand || !opaqueAndTranslucent ? Pass.OPAQUE : Pass.TRANSLUCENT;\n      command.owner = this;\n      const index = opaqueAndTranslucent ? Math.floor(j / 2.0) : j;\n      command.boundingVolume = boundingVolume;\n      command.modelMatrix = modelMatrix;\n      command.shaderProgram = opaqueCommand ? this._sp : this._spTranslucent;\n      command.uniformMap = this._uniforms;\n      command.vertexArray = va[index].va;\n      command.renderState = opaqueCommand ? this._rsOpaque : this._rsTranslucent;\n      command.debugShowBoundingVolume = this.debugShowBoundingVolume;\n      command.pickId = \"v_pickColor\";\n      commandList.push(command);\n    }\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PointPrimitiveCollection#destroy\n */\nPointPrimitiveCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * pointPrimitives = pointPrimitives && pointPrimitives.destroy();\n *\n * @see PointPrimitiveCollection#isDestroyed\n */\nPointPrimitiveCollection.prototype.destroy = function () {\n  this._sp = this._sp && this._sp.destroy();\n  this._spTranslucent = this._spTranslucent && this._spTranslucent.destroy();\n  this._spPick = this._spPick && this._spPick.destroy();\n  this._vaf = this._vaf && this._vaf.destroy();\n  destroyPointPrimitives(this._pointPrimitives);\n  return destroyObject(this);\n};\nexport default PointPrimitiveCollection;","map":{"version":3,"names":["BoundingSphere","Color","ComponentDatatype","Frozen","defined","destroyObject","DeveloperError","EncodedCartesian3","CesiumMath","Matrix4","PrimitiveType","WebGLConstants","BufferUsage","ContextLimits","DrawCommand","Pass","RenderState","ShaderProgram","ShaderSource","VertexArrayFacade","PointPrimitiveCollectionFS","PointPrimitiveCollectionVS","BlendingState","BlendOption","PointPrimitive","SceneMode","SHOW_INDEX","POSITION_INDEX","COLOR_INDEX","OUTLINE_COLOR_INDEX","OUTLINE_WIDTH_INDEX","PIXEL_SIZE_INDEX","SCALE_BY_DISTANCE_INDEX","TRANSLUCENCY_BY_DISTANCE_INDEX","DISTANCE_DISPLAY_CONDITION_INDEX","DISABLE_DEPTH_DISTANCE_INDEX","SPLIT_DIRECTION_INDEX","NUMBER_OF_PROPERTIES","attributeLocations","positionHighAndSize","positionLowAndOutline","compressedAttribute0","compressedAttribute1","scaleByDistance","distanceDisplayConditionAndDisableDepthAndSplitDirection","PointPrimitiveCollection","options","EMPTY_OBJECT","_sp","undefined","_spTranslucent","_rsOpaque","_rsTranslucent","_vaf","_pointPrimitives","_pointPrimitivesToUpdate","_pointPrimitivesToUpdateIndex","_pointPrimitivesRemoved","_createVertexArray","_shaderScaleByDistance","_compiledShaderScaleByDistance","_shaderTranslucencyByDistance","_compiledShaderTranslucencyByDistance","_shaderDistanceDisplayCondition","_compiledShaderDistanceDisplayCondition","_shaderDisableDepthDistance","_compiledShaderDisableDepthDistance","_propertiesChanged","Uint32Array","_maxPixelSize","_baseVolume","_baseVolumeWC","_baseVolume2D","_boundingVolume","_boundingVolumeDirty","_colorCommands","show","modelMatrix","clone","IDENTITY","_modelMatrix","debugShowBoundingVolume","blendOption","OPAQUE_AND_TRANSLUCENT","_blendOption","_mode","SCENE3D","_maxTotalPointSize","_buffersUsage","STATIC_DRAW","that","_uniforms","u_maxTotalPointSize","Object","defineProperties","prototype","length","get","removePointPrimitives","destroyPointPrimitives","pointPrimitives","i","_destroy","add","p","_index","push","remove","pointPrimitive","contains","removeAll","pointPrimitiveCollection","newPointPrimitives","j","_updatePointPrimitive","propertyChanged","_dirty","_pointPrimitiveCollection","index","computeNewBuffersUsage","buffersUsage","usageChanged","properties","k","newUsage","STREAM_DRAW","createVAF","context","numberOfPointPrimitives","componentsPerAttribute","componentDatatype","FLOAT","usage","positionLowAndShow","writePositionScratch","writePositionSizeAndOutline","vafWriters","position","_getActualPosition","expand","fromCartesian","pixelSize","outlineWidth","Math","max","positionHighWriter","high","x","y","z","positionLowWriter","low","LEFT_SHIFT16","LEFT_SHIFT8","writeCompressedAttrib0","color","pickColor","getPickId","outlineColor","red","floatToByte","green","blue","compressed0","compressed1","compressed2","compressed3","alpha","writer","writeCompressedAttrib1","near","nearValue","far","farValue","translucency","translucencyByDistance","clusterShow","clamp","writeScaleByDistance","scale","writeDistanceDisplayConditionAndDepthDisableAndSplitDirection","Number","MAX_VALUE","distanceDisplayCondition","disableDepthTestDistance","POSITIVE_INFINITY","direction","split","splitDirection","writePointPrimitive","recomputeActualPositions","frameState","recomputeBoundingVolume","boundingVolume","mode","positions","actualPosition","_computeActualPosition","_setActualPosition","fromPoints","updateMode","pointPrimitivesToUpdate","equals","SCENE2D","COLUMBUS_VIEW","MORPHING","updateBoundingVolume","collection","camera","getPixelSize","drawingBufferWidth","drawingBufferHeight","size","radius","scratchWriterArray","update","maximumAliasedPointSize","pointPrimitivesLength","pointPrimitivesToUpdateLength","createVertexArray","pass","passes","picking","pick","destroy","writers","commit","numWriters","m","b","n","h","bb","o","subCommit","endSubCommits","va","transform","blendOptionChanged","OPAQUE","fromCache","depthTest","enabled","func","LEQUAL","depthMask","TRANSLUCENT","blending","ALPHA_BLEND","minimumDisableDepthTestDistance","vs","fs","sources","defines","replaceCache","shaderProgram","vertexShaderSource","fragmentShaderSource","vaLength","command","commandList","render","colorList","opaque","opaqueAndTranslucent","totalLength","opaqueCommand","primitiveType","POINTS","owner","floor","uniformMap","vertexArray","renderState","pickId","isDestroyed","_spPick"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/PointPrimitiveCollection.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArrayFacade from \"../Renderer/VertexArrayFacade.js\";\nimport PointPrimitiveCollectionFS from \"../Shaders/PointPrimitiveCollectionFS.js\";\nimport PointPrimitiveCollectionVS from \"../Shaders/PointPrimitiveCollectionVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport BlendOption from \"./BlendOption.js\";\nimport PointPrimitive from \"./PointPrimitive.js\";\nimport SceneMode from \"./SceneMode.js\";\n\nconst SHOW_INDEX = PointPrimitive.SHOW_INDEX;\nconst POSITION_INDEX = PointPrimitive.POSITION_INDEX;\nconst COLOR_INDEX = PointPrimitive.COLOR_INDEX;\nconst OUTLINE_COLOR_INDEX = PointPrimitive.OUTLINE_COLOR_INDEX;\nconst OUTLINE_WIDTH_INDEX = PointPrimitive.OUTLINE_WIDTH_INDEX;\nconst PIXEL_SIZE_INDEX = PointPrimitive.PIXEL_SIZE_INDEX;\nconst SCALE_BY_DISTANCE_INDEX = PointPrimitive.SCALE_BY_DISTANCE_INDEX;\nconst TRANSLUCENCY_BY_DISTANCE_INDEX =\n  PointPrimitive.TRANSLUCENCY_BY_DISTANCE_INDEX;\nconst DISTANCE_DISPLAY_CONDITION_INDEX =\n  PointPrimitive.DISTANCE_DISPLAY_CONDITION_INDEX;\nconst DISABLE_DEPTH_DISTANCE_INDEX =\n  PointPrimitive.DISABLE_DEPTH_DISTANCE_INDEX;\nconst SPLIT_DIRECTION_INDEX = PointPrimitive.SPLIT_DIRECTION_INDEX;\nconst NUMBER_OF_PROPERTIES = PointPrimitive.NUMBER_OF_PROPERTIES;\n\nconst attributeLocations = {\n  positionHighAndSize: 0,\n  positionLowAndOutline: 1,\n  compressedAttribute0: 2, // color, outlineColor, pick color\n  compressedAttribute1: 3, // show, translucency by distance, some free space\n  scaleByDistance: 4,\n  distanceDisplayConditionAndDisableDepthAndSplitDirection: 5,\n};\n\n/**\n * A renderable collection of points.\n * <br /><br />\n * Points are added and removed from the collection using {@link PointPrimitiveCollection#add}\n * and {@link PointPrimitiveCollection#remove}.\n *\n * @alias PointPrimitiveCollection\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each point from model to world coordinates.\n * @param {boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {BlendOption} [options.blendOption=BlendOption.OPAQUE_AND_TRANSLUCENT] The point blending option. The default\n * is used for rendering both opaque and translucent points. However, if either all of the points are completely opaque or all are completely translucent,\n * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.\n * @param {boolean} [options.show=true] Determines if the primitives in the collection will be shown.\n *\n * @performance For best performance, prefer a few collections, each with many points, to\n * many collections with only a few points each.  Organize collections so that points\n * with the same update frequency are in the same collection, i.e., points that do not\n * change should be in one collection; points that change every frame should be in another\n * collection; and so on.\n *\n *\n * @example\n * // Create a pointPrimitive collection with two points\n * const points = scene.primitives.add(new Cesium.PointPrimitiveCollection());\n * points.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   color : Cesium.Color.YELLOW\n * });\n * points.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   color : Cesium.Color.CYAN\n * });\n *\n * @see PointPrimitiveCollection#add\n * @see PointPrimitiveCollection#remove\n * @see PointPrimitive\n */\nfunction PointPrimitiveCollection(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  this._sp = undefined;\n  this._spTranslucent = undefined;\n  this._rsOpaque = undefined;\n  this._rsTranslucent = undefined;\n  this._vaf = undefined;\n\n  this._pointPrimitives = [];\n  this._pointPrimitivesToUpdate = [];\n  this._pointPrimitivesToUpdateIndex = 0;\n  this._pointPrimitivesRemoved = false;\n  this._createVertexArray = false;\n\n  this._shaderScaleByDistance = false;\n  this._compiledShaderScaleByDistance = false;\n\n  this._shaderTranslucencyByDistance = false;\n  this._compiledShaderTranslucencyByDistance = false;\n\n  this._shaderDistanceDisplayCondition = false;\n  this._compiledShaderDistanceDisplayCondition = false;\n\n  this._shaderDisableDepthDistance = false;\n  this._compiledShaderDisableDepthDistance = false;\n\n  this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);\n\n  this._maxPixelSize = 1.0;\n\n  this._baseVolume = new BoundingSphere();\n  this._baseVolumeWC = new BoundingSphere();\n  this._baseVolume2D = new BoundingSphere();\n  this._boundingVolume = new BoundingSphere();\n  this._boundingVolumeDirty = false;\n\n  this._colorCommands = [];\n\n  /**\n   * Determines if primitives in this collection will be shown.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.show = options.show ?? true;\n\n  /**\n   * The 4x4 transformation matrix that transforms each point in this collection from model to world coordinates.\n   * When this is the identity matrix, the pointPrimitives are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   * @default {@link Matrix4.IDENTITY}\n   *\n   *\n   * @example\n   * const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * pointPrimitives.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * pointPrimitives.add({\n   *   color : Cesium.Color.ORANGE,\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0) // center\n   * });\n   * pointPrimitives.add({\n   *   color : Cesium.Color.YELLOW,\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0) // east\n   * });\n   * pointPrimitives.add({\n   *   color : Cesium.Color.GREEN,\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0) // north\n   * });\n   * pointPrimitives.add({\n   *   color : Cesium.Color.CYAN,\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0) // up\n   * });\n   *\n   * @see Transforms.eastNorthUpToFixedFrame\n   */\n  this.modelMatrix = Matrix4.clone(options.modelMatrix ?? Matrix4.IDENTITY);\n  this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = options.debugShowBoundingVolume ?? false;\n\n  /**\n   * The point blending option. The default is used for rendering both opaque and translucent points.\n   * However, if either all of the points are completely opaque or all are completely translucent,\n   * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve\n   * performance by up to 2x.\n   * @type {BlendOption}\n   * @default BlendOption.OPAQUE_AND_TRANSLUCENT\n   */\n  this.blendOption = options.blendOption ?? BlendOption.OPAQUE_AND_TRANSLUCENT;\n  this._blendOption = undefined;\n\n  this._mode = SceneMode.SCENE3D;\n  this._maxTotalPointSize = 1;\n\n  // The buffer usage for each attribute is determined based on the usage of the attribute over time.\n  this._buffersUsage = [\n    BufferUsage.STATIC_DRAW, // SHOW_INDEX\n    BufferUsage.STATIC_DRAW, // POSITION_INDEX\n    BufferUsage.STATIC_DRAW, // COLOR_INDEX\n    BufferUsage.STATIC_DRAW, // OUTLINE_COLOR_INDEX\n    BufferUsage.STATIC_DRAW, // OUTLINE_WIDTH_INDEX\n    BufferUsage.STATIC_DRAW, // PIXEL_SIZE_INDEX\n    BufferUsage.STATIC_DRAW, // SCALE_BY_DISTANCE_INDEX\n    BufferUsage.STATIC_DRAW, // TRANSLUCENCY_BY_DISTANCE_INDEX\n    BufferUsage.STATIC_DRAW, // DISTANCE_DISPLAY_CONDITION_INDEX\n  ];\n\n  const that = this;\n  this._uniforms = {\n    u_maxTotalPointSize: function () {\n      return that._maxTotalPointSize;\n    },\n  };\n}\n\nObject.defineProperties(PointPrimitiveCollection.prototype, {\n  /**\n   * Returns the number of points in this collection.  This is commonly used with\n   * {@link PointPrimitiveCollection#get} to iterate over all the points\n   * in the collection.\n   * @memberof PointPrimitiveCollection.prototype\n   * @type {number}\n   */\n  length: {\n    get: function () {\n      removePointPrimitives(this);\n      return this._pointPrimitives.length;\n    },\n  },\n});\n\nfunction destroyPointPrimitives(pointPrimitives) {\n  const length = pointPrimitives.length;\n  for (let i = 0; i < length; ++i) {\n    if (pointPrimitives[i]) {\n      pointPrimitives[i]._destroy();\n    }\n  }\n}\n\n/**\n * Creates and adds a point with the specified initial properties to the collection.\n * The added point is returned so it can be modified or removed from the collection later.\n *\n * @param {object}[options] A template describing the point's properties as shown in Example 1.\n * @returns {PointPrimitive} The point that was added to the collection.\n *\n * @performance Calling <code>add</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, add as many pointPrimitives as possible before calling <code>update</code>.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Example 1:  Add a point, specifying all the default values.\n * const p = pointPrimitives.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   pixelSize : 10.0,\n *   color : Cesium.Color.WHITE,\n *   outlineColor : Cesium.Color.TRANSPARENT,\n *   outlineWidth : 0.0,\n *   id : undefined\n * });\n *\n * @example\n * // Example 2:  Specify only the point's cartographic position.\n * const p = pointPrimitives.add({\n *   position : Cesium.Cartesian3.fromDegrees(longitude, latitude, height)\n * });\n *\n * @see PointPrimitiveCollection#remove\n * @see PointPrimitiveCollection#removeAll\n */\nPointPrimitiveCollection.prototype.add = function (options) {\n  const p = new PointPrimitive(options, this);\n  p._index = this._pointPrimitives.length;\n\n  this._pointPrimitives.push(p);\n  this._createVertexArray = true;\n\n  return p;\n};\n\n/**\n * Removes a point from the collection.\n *\n * @param {PointPrimitive} pointPrimitive The point to remove.\n * @returns {boolean} <code>true</code> if the point was removed; <code>false</code> if the point was not found in the collection.\n *\n * @performance Calling <code>remove</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, remove as many points as possible before calling <code>update</code>.\n * If you intend to temporarily hide a point, it is usually more efficient to call\n * {@link PointPrimitive#show} instead of removing and re-adding the point.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * const p = pointPrimitives.add(...);\n * pointPrimitives.remove(p);  // Returns true\n *\n * @see PointPrimitiveCollection#add\n * @see PointPrimitiveCollection#removeAll\n * @see PointPrimitive#show\n */\nPointPrimitiveCollection.prototype.remove = function (pointPrimitive) {\n  if (this.contains(pointPrimitive)) {\n    this._pointPrimitives[pointPrimitive._index] = null; // Removed later\n    this._pointPrimitivesRemoved = true;\n    this._createVertexArray = true;\n    pointPrimitive._destroy();\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Removes all points from the collection.\n *\n * @performance <code>O(n)</code>.  It is more efficient to remove all the points\n * from a collection and then add new ones than to create a new collection entirely.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * pointPrimitives.add(...);\n * pointPrimitives.add(...);\n * pointPrimitives.removeAll();\n *\n * @see PointPrimitiveCollection#add\n * @see PointPrimitiveCollection#remove\n */\nPointPrimitiveCollection.prototype.removeAll = function () {\n  destroyPointPrimitives(this._pointPrimitives);\n  this._pointPrimitives = [];\n  this._pointPrimitivesToUpdate = [];\n  this._pointPrimitivesToUpdateIndex = 0;\n  this._pointPrimitivesRemoved = false;\n\n  this._createVertexArray = true;\n};\n\nfunction removePointPrimitives(pointPrimitiveCollection) {\n  if (pointPrimitiveCollection._pointPrimitivesRemoved) {\n    pointPrimitiveCollection._pointPrimitivesRemoved = false;\n\n    const newPointPrimitives = [];\n    const pointPrimitives = pointPrimitiveCollection._pointPrimitives;\n    const length = pointPrimitives.length;\n    for (let i = 0, j = 0; i < length; ++i) {\n      const pointPrimitive = pointPrimitives[i];\n      if (pointPrimitive) {\n        pointPrimitive._index = j++;\n        newPointPrimitives.push(pointPrimitive);\n      }\n    }\n\n    pointPrimitiveCollection._pointPrimitives = newPointPrimitives;\n  }\n}\n\nPointPrimitiveCollection.prototype._updatePointPrimitive = function (\n  pointPrimitive,\n  propertyChanged,\n) {\n  if (!pointPrimitive._dirty) {\n    this._pointPrimitivesToUpdate[this._pointPrimitivesToUpdateIndex++] =\n      pointPrimitive;\n  }\n\n  ++this._propertiesChanged[propertyChanged];\n};\n\n/**\n * Check whether this collection contains a given point.\n *\n * @param {PointPrimitive} [pointPrimitive] The point to check for.\n * @returns {boolean} true if this collection contains the point, false otherwise.\n *\n * @see PointPrimitiveCollection#get\n */\nPointPrimitiveCollection.prototype.contains = function (pointPrimitive) {\n  return (\n    defined(pointPrimitive) && pointPrimitive._pointPrimitiveCollection === this\n  );\n};\n\n/**\n * Returns the point in the collection at the specified index.  Indices are zero-based\n * and increase as points are added.  Removing a point shifts all points after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link PointPrimitiveCollection#length} to iterate over all the points\n * in the collection.\n *\n * @param {number} index The zero-based index of the point.\n * @returns {PointPrimitive} The point at the specified index.\n *\n * @performance Expected constant time.  If points were removed from the collection and\n * {@link PointPrimitiveCollection#update} was not called, an implicit <code>O(n)</code>\n * operation is performed.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Toggle the show property of every point in the collection\n * const len = pointPrimitives.length;\n * for (let i = 0; i < len; ++i) {\n *   const p = pointPrimitives.get(i);\n *   p.show = !p.show;\n * }\n *\n * @see PointPrimitiveCollection#length\n */\nPointPrimitiveCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n  //>>includeEnd('debug');\n\n  removePointPrimitives(this);\n  return this._pointPrimitives[index];\n};\n\nPointPrimitiveCollection.prototype.computeNewBuffersUsage = function () {\n  const buffersUsage = this._buffersUsage;\n  let usageChanged = false;\n\n  const properties = this._propertiesChanged;\n  for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n    const newUsage =\n      properties[k] === 0 ? BufferUsage.STATIC_DRAW : BufferUsage.STREAM_DRAW;\n    usageChanged = usageChanged || buffersUsage[k] !== newUsage;\n    buffersUsage[k] = newUsage;\n  }\n\n  return usageChanged;\n};\n\nfunction createVAF(context, numberOfPointPrimitives, buffersUsage) {\n  return new VertexArrayFacade(\n    context,\n    [\n      {\n        index: attributeLocations.positionHighAndSize,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        usage: buffersUsage[POSITION_INDEX],\n      },\n      {\n        index: attributeLocations.positionLowAndShow,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        usage: buffersUsage[POSITION_INDEX],\n      },\n      {\n        index: attributeLocations.compressedAttribute0,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        usage: buffersUsage[COLOR_INDEX],\n      },\n      {\n        index: attributeLocations.compressedAttribute1,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        usage: buffersUsage[TRANSLUCENCY_BY_DISTANCE_INDEX],\n      },\n      {\n        index: attributeLocations.scaleByDistance,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        usage: buffersUsage[SCALE_BY_DISTANCE_INDEX],\n      },\n      {\n        index:\n          attributeLocations.distanceDisplayConditionAndDisableDepthAndSplitDirection,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        usage: buffersUsage[DISTANCE_DISPLAY_CONDITION_INDEX],\n      },\n    ],\n    numberOfPointPrimitives,\n  ); // 1 vertex per pointPrimitive\n}\n\n///////////////////////////////////////////////////////////////////////////\n\n// PERFORMANCE_IDEA:  Save memory if a property is the same for all pointPrimitives, use a latched attribute state,\n// instead of storing it in a vertex buffer.\n\nconst writePositionScratch = new EncodedCartesian3();\n\nfunction writePositionSizeAndOutline(\n  pointPrimitiveCollection,\n  context,\n  vafWriters,\n  pointPrimitive,\n) {\n  const i = pointPrimitive._index;\n  const position = pointPrimitive._getActualPosition();\n\n  if (pointPrimitiveCollection._mode === SceneMode.SCENE3D) {\n    BoundingSphere.expand(\n      pointPrimitiveCollection._baseVolume,\n      position,\n      pointPrimitiveCollection._baseVolume,\n    );\n    pointPrimitiveCollection._boundingVolumeDirty = true;\n  }\n\n  EncodedCartesian3.fromCartesian(position, writePositionScratch);\n  const pixelSize = pointPrimitive.pixelSize;\n  const outlineWidth = pointPrimitive.outlineWidth;\n\n  pointPrimitiveCollection._maxPixelSize = Math.max(\n    pointPrimitiveCollection._maxPixelSize,\n    pixelSize + outlineWidth,\n  );\n\n  const positionHighWriter = vafWriters[attributeLocations.positionHighAndSize];\n  const high = writePositionScratch.high;\n  positionHighWriter(i, high.x, high.y, high.z, pixelSize);\n\n  const positionLowWriter =\n    vafWriters[attributeLocations.positionLowAndOutline];\n  const low = writePositionScratch.low;\n  positionLowWriter(i, low.x, low.y, low.z, outlineWidth);\n}\n\nconst LEFT_SHIFT16 = 65536.0; // 2^16\nconst LEFT_SHIFT8 = 256.0; // 2^8\n\nfunction writeCompressedAttrib0(\n  pointPrimitiveCollection,\n  context,\n  vafWriters,\n  pointPrimitive,\n) {\n  const i = pointPrimitive._index;\n\n  const color = pointPrimitive.color;\n  const pickColor = pointPrimitive.getPickId(context).color;\n  const outlineColor = pointPrimitive.outlineColor;\n\n  let red = Color.floatToByte(color.red);\n  let green = Color.floatToByte(color.green);\n  let blue = Color.floatToByte(color.blue);\n  const compressed0 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n\n  red = Color.floatToByte(outlineColor.red);\n  green = Color.floatToByte(outlineColor.green);\n  blue = Color.floatToByte(outlineColor.blue);\n  const compressed1 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n\n  red = Color.floatToByte(pickColor.red);\n  green = Color.floatToByte(pickColor.green);\n  blue = Color.floatToByte(pickColor.blue);\n  const compressed2 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n\n  const compressed3 =\n    Color.floatToByte(color.alpha) * LEFT_SHIFT16 +\n    Color.floatToByte(outlineColor.alpha) * LEFT_SHIFT8 +\n    Color.floatToByte(pickColor.alpha);\n\n  const writer = vafWriters[attributeLocations.compressedAttribute0];\n  writer(i, compressed0, compressed1, compressed2, compressed3);\n}\n\nfunction writeCompressedAttrib1(\n  pointPrimitiveCollection,\n  context,\n  vafWriters,\n  pointPrimitive,\n) {\n  const i = pointPrimitive._index;\n\n  let near = 0.0;\n  let nearValue = 1.0;\n  let far = 1.0;\n  let farValue = 1.0;\n\n  const translucency = pointPrimitive.translucencyByDistance;\n  if (defined(translucency)) {\n    near = translucency.near;\n    nearValue = translucency.nearValue;\n    far = translucency.far;\n    farValue = translucency.farValue;\n\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // translucency by distance calculation in shader need not be enabled\n      // until a pointPrimitive with near and far !== 1.0 is found\n      pointPrimitiveCollection._shaderTranslucencyByDistance = true;\n    }\n  }\n\n  let show = pointPrimitive.show && pointPrimitive.clusterShow;\n\n  // If the color alphas are zero, do not show this pointPrimitive.  This lets us avoid providing\n  // color during the pick pass and also eliminates a discard in the fragment shader.\n  if (\n    pointPrimitive.color.alpha === 0.0 &&\n    pointPrimitive.outlineColor.alpha === 0.0\n  ) {\n    show = false;\n  }\n\n  nearValue = CesiumMath.clamp(nearValue, 0.0, 1.0);\n  nearValue = nearValue === 1.0 ? 255.0 : (nearValue * 255.0) | 0;\n  const compressed0 = (show ? 1.0 : 0.0) * LEFT_SHIFT8 + nearValue;\n\n  farValue = CesiumMath.clamp(farValue, 0.0, 1.0);\n  farValue = farValue === 1.0 ? 255.0 : (farValue * 255.0) | 0;\n  const compressed1 = farValue;\n\n  const writer = vafWriters[attributeLocations.compressedAttribute1];\n  writer(i, compressed0, compressed1, near, far);\n}\n\nfunction writeScaleByDistance(\n  pointPrimitiveCollection,\n  context,\n  vafWriters,\n  pointPrimitive,\n) {\n  const i = pointPrimitive._index;\n  const writer = vafWriters[attributeLocations.scaleByDistance];\n  let near = 0.0;\n  let nearValue = 1.0;\n  let far = 1.0;\n  let farValue = 1.0;\n\n  const scale = pointPrimitive.scaleByDistance;\n  if (defined(scale)) {\n    near = scale.near;\n    nearValue = scale.nearValue;\n    far = scale.far;\n    farValue = scale.farValue;\n\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // scale by distance calculation in shader need not be enabled\n      // until a pointPrimitive with near and far !== 1.0 is found\n      pointPrimitiveCollection._shaderScaleByDistance = true;\n    }\n  }\n\n  writer(i, near, nearValue, far, farValue);\n}\n\nfunction writeDistanceDisplayConditionAndDepthDisableAndSplitDirection(\n  pointPrimitiveCollection,\n  context,\n  vafWriters,\n  pointPrimitive,\n) {\n  const i = pointPrimitive._index;\n  const writer =\n    vafWriters[\n      attributeLocations\n        .distanceDisplayConditionAndDisableDepthAndSplitDirection\n    ];\n  let near = 0.0;\n  let far = Number.MAX_VALUE;\n\n  const distanceDisplayCondition = pointPrimitive.distanceDisplayCondition;\n  if (defined(distanceDisplayCondition)) {\n    near = distanceDisplayCondition.near;\n    far = distanceDisplayCondition.far;\n\n    near *= near;\n    far *= far;\n\n    pointPrimitiveCollection._shaderDistanceDisplayCondition = true;\n  }\n\n  let disableDepthTestDistance = pointPrimitive.disableDepthTestDistance;\n  disableDepthTestDistance *= disableDepthTestDistance;\n  if (disableDepthTestDistance > 0.0) {\n    pointPrimitiveCollection._shaderDisableDepthDistance = true;\n    if (disableDepthTestDistance === Number.POSITIVE_INFINITY) {\n      disableDepthTestDistance = -1.0;\n    }\n  }\n\n  let direction = 0.0;\n  const split = pointPrimitive.splitDirection;\n  if (defined(split)) {\n    direction = split;\n  }\n  writer(i, near, far, disableDepthTestDistance, direction);\n}\n\nfunction writePointPrimitive(\n  pointPrimitiveCollection,\n  context,\n  vafWriters,\n  pointPrimitive,\n) {\n  writePositionSizeAndOutline(\n    pointPrimitiveCollection,\n    context,\n    vafWriters,\n    pointPrimitive,\n  );\n  writeCompressedAttrib0(\n    pointPrimitiveCollection,\n    context,\n    vafWriters,\n    pointPrimitive,\n  );\n  writeCompressedAttrib1(\n    pointPrimitiveCollection,\n    context,\n    vafWriters,\n    pointPrimitive,\n  );\n  writeScaleByDistance(\n    pointPrimitiveCollection,\n    context,\n    vafWriters,\n    pointPrimitive,\n  );\n  writeDistanceDisplayConditionAndDepthDisableAndSplitDirection(\n    pointPrimitiveCollection,\n    context,\n    vafWriters,\n    pointPrimitive,\n  );\n}\n\nfunction recomputeActualPositions(\n  pointPrimitiveCollection,\n  pointPrimitives,\n  length,\n  frameState,\n  modelMatrix,\n  recomputeBoundingVolume,\n) {\n  let boundingVolume;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingVolume = pointPrimitiveCollection._baseVolume;\n    pointPrimitiveCollection._boundingVolumeDirty = true;\n  } else {\n    boundingVolume = pointPrimitiveCollection._baseVolume2D;\n  }\n\n  const positions = [];\n  for (let i = 0; i < length; ++i) {\n    const pointPrimitive = pointPrimitives[i];\n    const position = pointPrimitive.position;\n    const actualPosition = PointPrimitive._computeActualPosition(\n      position,\n      frameState,\n      modelMatrix,\n    );\n    if (defined(actualPosition)) {\n      pointPrimitive._setActualPosition(actualPosition);\n\n      if (recomputeBoundingVolume) {\n        positions.push(actualPosition);\n      } else {\n        BoundingSphere.expand(boundingVolume, actualPosition, boundingVolume);\n      }\n    }\n  }\n\n  if (recomputeBoundingVolume) {\n    BoundingSphere.fromPoints(positions, boundingVolume);\n  }\n}\n\nfunction updateMode(pointPrimitiveCollection, frameState) {\n  const mode = frameState.mode;\n\n  const pointPrimitives = pointPrimitiveCollection._pointPrimitives;\n  const pointPrimitivesToUpdate =\n    pointPrimitiveCollection._pointPrimitivesToUpdate;\n  const modelMatrix = pointPrimitiveCollection._modelMatrix;\n\n  if (\n    pointPrimitiveCollection._createVertexArray ||\n    pointPrimitiveCollection._mode !== mode ||\n    (mode !== SceneMode.SCENE3D &&\n      !Matrix4.equals(modelMatrix, pointPrimitiveCollection.modelMatrix))\n  ) {\n    pointPrimitiveCollection._mode = mode;\n    Matrix4.clone(pointPrimitiveCollection.modelMatrix, modelMatrix);\n    pointPrimitiveCollection._createVertexArray = true;\n\n    if (\n      mode === SceneMode.SCENE3D ||\n      mode === SceneMode.SCENE2D ||\n      mode === SceneMode.COLUMBUS_VIEW\n    ) {\n      recomputeActualPositions(\n        pointPrimitiveCollection,\n        pointPrimitives,\n        pointPrimitives.length,\n        frameState,\n        modelMatrix,\n        true,\n      );\n    }\n  } else if (mode === SceneMode.MORPHING) {\n    recomputeActualPositions(\n      pointPrimitiveCollection,\n      pointPrimitives,\n      pointPrimitives.length,\n      frameState,\n      modelMatrix,\n      true,\n    );\n  } else if (mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {\n    recomputeActualPositions(\n      pointPrimitiveCollection,\n      pointPrimitivesToUpdate,\n      pointPrimitiveCollection._pointPrimitivesToUpdateIndex,\n      frameState,\n      modelMatrix,\n      false,\n    );\n  }\n}\n\nfunction updateBoundingVolume(collection, frameState, boundingVolume) {\n  const pixelSize = frameState.camera.getPixelSize(\n    boundingVolume,\n    frameState.context.drawingBufferWidth,\n    frameState.context.drawingBufferHeight,\n  );\n  const size = pixelSize * collection._maxPixelSize;\n  boundingVolume.radius += size;\n}\n\nconst scratchWriterArray = [];\n\n/**\n * @private\n */\nPointPrimitiveCollection.prototype.update = function (frameState) {\n  removePointPrimitives(this);\n\n  if (!this.show) {\n    return;\n  }\n\n  this._maxTotalPointSize = ContextLimits.maximumAliasedPointSize;\n\n  updateMode(this, frameState);\n\n  const pointPrimitives = this._pointPrimitives;\n  const pointPrimitivesLength = pointPrimitives.length;\n  const pointPrimitivesToUpdate = this._pointPrimitivesToUpdate;\n  const pointPrimitivesToUpdateLength = this._pointPrimitivesToUpdateIndex;\n\n  const properties = this._propertiesChanged;\n\n  const createVertexArray = this._createVertexArray;\n\n  let vafWriters;\n  const context = frameState.context;\n  const pass = frameState.passes;\n  const picking = pass.pick;\n\n  // PERFORMANCE_IDEA: Round robin multiple buffers.\n  if (createVertexArray || (!picking && this.computeNewBuffersUsage())) {\n    this._createVertexArray = false;\n\n    for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n      properties[k] = 0;\n    }\n\n    this._vaf = this._vaf && this._vaf.destroy();\n\n    if (pointPrimitivesLength > 0) {\n      // PERFORMANCE_IDEA:  Instead of creating a new one, resize like std::vector.\n      this._vaf = createVAF(context, pointPrimitivesLength, this._buffersUsage);\n      vafWriters = this._vaf.writers;\n\n      // Rewrite entire buffer if pointPrimitives were added or removed.\n      for (let i = 0; i < pointPrimitivesLength; ++i) {\n        const pointPrimitive = this._pointPrimitives[i];\n        pointPrimitive._dirty = false; // In case it needed an update.\n        writePointPrimitive(this, context, vafWriters, pointPrimitive);\n      }\n\n      this._vaf.commit();\n    }\n\n    this._pointPrimitivesToUpdateIndex = 0;\n  } else if (pointPrimitivesToUpdateLength > 0) {\n    // PointPrimitives were modified, but none were added or removed.\n    const writers = scratchWriterArray;\n    writers.length = 0;\n\n    if (\n      properties[POSITION_INDEX] ||\n      properties[OUTLINE_WIDTH_INDEX] ||\n      properties[PIXEL_SIZE_INDEX]\n    ) {\n      writers.push(writePositionSizeAndOutline);\n    }\n\n    if (properties[COLOR_INDEX] || properties[OUTLINE_COLOR_INDEX]) {\n      writers.push(writeCompressedAttrib0);\n    }\n\n    if (properties[SHOW_INDEX] || properties[TRANSLUCENCY_BY_DISTANCE_INDEX]) {\n      writers.push(writeCompressedAttrib1);\n    }\n\n    if (properties[SCALE_BY_DISTANCE_INDEX]) {\n      writers.push(writeScaleByDistance);\n    }\n\n    if (\n      properties[DISTANCE_DISPLAY_CONDITION_INDEX] ||\n      properties[DISABLE_DEPTH_DISTANCE_INDEX] ||\n      properties[SPLIT_DIRECTION_INDEX]\n    ) {\n      writers.push(\n        writeDistanceDisplayConditionAndDepthDisableAndSplitDirection,\n      );\n    }\n\n    const numWriters = writers.length;\n\n    vafWriters = this._vaf.writers;\n\n    if (pointPrimitivesToUpdateLength / pointPrimitivesLength > 0.1) {\n      // If more than 10% of pointPrimitive change, rewrite the entire buffer.\n\n      // PERFORMANCE_IDEA:  I totally made up 10% :).\n\n      for (let m = 0; m < pointPrimitivesToUpdateLength; ++m) {\n        const b = pointPrimitivesToUpdate[m];\n        b._dirty = false;\n\n        for (let n = 0; n < numWriters; ++n) {\n          writers[n](this, context, vafWriters, b);\n        }\n      }\n      this._vaf.commit();\n    } else {\n      for (let h = 0; h < pointPrimitivesToUpdateLength; ++h) {\n        const bb = pointPrimitivesToUpdate[h];\n        bb._dirty = false;\n\n        for (let o = 0; o < numWriters; ++o) {\n          writers[o](this, context, vafWriters, bb);\n        }\n        this._vaf.subCommit(bb._index, 1);\n      }\n      this._vaf.endSubCommits();\n    }\n\n    this._pointPrimitivesToUpdateIndex = 0;\n  }\n\n  // If the number of total pointPrimitives ever shrinks considerably\n  // Truncate pointPrimitivesToUpdate so that we free memory that we're\n  // not going to be using.\n  if (pointPrimitivesToUpdateLength > pointPrimitivesLength * 1.5) {\n    pointPrimitivesToUpdate.length = pointPrimitivesLength;\n  }\n\n  if (!defined(this._vaf) || !defined(this._vaf.va)) {\n    return;\n  }\n\n  if (this._boundingVolumeDirty) {\n    this._boundingVolumeDirty = false;\n    BoundingSphere.transform(\n      this._baseVolume,\n      this.modelMatrix,\n      this._baseVolumeWC,\n    );\n  }\n\n  let boundingVolume;\n  let modelMatrix = Matrix4.IDENTITY;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    modelMatrix = this.modelMatrix;\n    boundingVolume = BoundingSphere.clone(\n      this._baseVolumeWC,\n      this._boundingVolume,\n    );\n  } else {\n    boundingVolume = BoundingSphere.clone(\n      this._baseVolume2D,\n      this._boundingVolume,\n    );\n  }\n  updateBoundingVolume(this, frameState, boundingVolume);\n\n  const blendOptionChanged = this._blendOption !== this.blendOption;\n  this._blendOption = this.blendOption;\n\n  if (blendOptionChanged) {\n    if (\n      this._blendOption === BlendOption.OPAQUE ||\n      this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT\n    ) {\n      this._rsOpaque = RenderState.fromCache({\n        depthTest: {\n          enabled: true,\n          func: WebGLConstants.LEQUAL,\n        },\n        depthMask: true,\n      });\n    } else {\n      this._rsOpaque = undefined;\n    }\n\n    if (\n      this._blendOption === BlendOption.TRANSLUCENT ||\n      this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT\n    ) {\n      this._rsTranslucent = RenderState.fromCache({\n        depthTest: {\n          enabled: true,\n          func: WebGLConstants.LEQUAL,\n        },\n        depthMask: false,\n        blending: BlendingState.ALPHA_BLEND,\n      });\n    } else {\n      this._rsTranslucent = undefined;\n    }\n  }\n\n  this._shaderDisableDepthDistance =\n    this._shaderDisableDepthDistance ||\n    frameState.minimumDisableDepthTestDistance !== 0.0;\n  let vs;\n  let fs;\n\n  if (\n    blendOptionChanged ||\n    (this._shaderScaleByDistance && !this._compiledShaderScaleByDistance) ||\n    (this._shaderTranslucencyByDistance &&\n      !this._compiledShaderTranslucencyByDistance) ||\n    (this._shaderDistanceDisplayCondition &&\n      !this._compiledShaderDistanceDisplayCondition) ||\n    this._shaderDisableDepthDistance !==\n      this._compiledShaderDisableDepthDistance\n  ) {\n    vs = new ShaderSource({\n      sources: [PointPrimitiveCollectionVS],\n    });\n    if (this._shaderScaleByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_SCALING\");\n    }\n    if (this._shaderTranslucencyByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_TRANSLUCENCY\");\n    }\n    if (this._shaderDistanceDisplayCondition) {\n      vs.defines.push(\"DISTANCE_DISPLAY_CONDITION\");\n    }\n    if (this._shaderDisableDepthDistance) {\n      vs.defines.push(\"DISABLE_DEPTH_DISTANCE\");\n    }\n\n    if (this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT) {\n      fs = new ShaderSource({\n        defines: [\"OPAQUE\"],\n        sources: [PointPrimitiveCollectionFS],\n      });\n      this._sp = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._sp,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n\n      fs = new ShaderSource({\n        defines: [\"TRANSLUCENT\"],\n        sources: [PointPrimitiveCollectionFS],\n      });\n      this._spTranslucent = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._spTranslucent,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n    }\n\n    if (this._blendOption === BlendOption.OPAQUE) {\n      fs = new ShaderSource({\n        sources: [PointPrimitiveCollectionFS],\n      });\n      this._sp = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._sp,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n    }\n\n    if (this._blendOption === BlendOption.TRANSLUCENT) {\n      fs = new ShaderSource({\n        sources: [PointPrimitiveCollectionFS],\n      });\n      this._spTranslucent = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._spTranslucent,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n    }\n\n    this._compiledShaderScaleByDistance = this._shaderScaleByDistance;\n    this._compiledShaderTranslucencyByDistance =\n      this._shaderTranslucencyByDistance;\n    this._compiledShaderDistanceDisplayCondition =\n      this._shaderDistanceDisplayCondition;\n    this._compiledShaderDisableDepthDistance = this._shaderDisableDepthDistance;\n  }\n\n  let va;\n  let vaLength;\n  let command;\n  let j;\n\n  const commandList = frameState.commandList;\n\n  if (pass.render || picking) {\n    const colorList = this._colorCommands;\n\n    const opaque = this._blendOption === BlendOption.OPAQUE;\n    const opaqueAndTranslucent =\n      this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT;\n\n    va = this._vaf.va;\n    vaLength = va.length;\n\n    colorList.length = vaLength;\n    const totalLength = opaqueAndTranslucent ? vaLength * 2 : vaLength;\n    for (j = 0; j < totalLength; ++j) {\n      const opaqueCommand = opaque || (opaqueAndTranslucent && j % 2 === 0);\n\n      command = colorList[j];\n      if (!defined(command)) {\n        command = colorList[j] = new DrawCommand();\n      }\n\n      command.primitiveType = PrimitiveType.POINTS;\n      command.pass =\n        opaqueCommand || !opaqueAndTranslucent ? Pass.OPAQUE : Pass.TRANSLUCENT;\n      command.owner = this;\n\n      const index = opaqueAndTranslucent ? Math.floor(j / 2.0) : j;\n      command.boundingVolume = boundingVolume;\n      command.modelMatrix = modelMatrix;\n      command.shaderProgram = opaqueCommand ? this._sp : this._spTranslucent;\n      command.uniformMap = this._uniforms;\n      command.vertexArray = va[index].va;\n      command.renderState = opaqueCommand\n        ? this._rsOpaque\n        : this._rsTranslucent;\n      command.debugShowBoundingVolume = this.debugShowBoundingVolume;\n      command.pickId = \"v_pickColor\";\n\n      commandList.push(command);\n    }\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PointPrimitiveCollection#destroy\n */\nPointPrimitiveCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * pointPrimitives = pointPrimitives && pointPrimitives.destroy();\n *\n * @see PointPrimitiveCollection#isDestroyed\n */\nPointPrimitiveCollection.prototype.destroy = function () {\n  this._sp = this._sp && this._sp.destroy();\n  this._spTranslucent = this._spTranslucent && this._spTranslucent.destroy();\n  this._spPick = this._spPick && this._spPick.destroy();\n  this._vaf = this._vaf && this._vaf.destroy();\n  destroyPointPrimitives(this._pointPrimitives);\n\n  return destroyObject(this);\n};\nexport default PointPrimitiveCollection;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}