{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport defined from \"../../Core/defined.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Check from \"../../Core/Check.js\";\nimport destroyObject from \"../../Core/destroyObject.js\";\nimport ImageryState from \"../ImageryState.js\";\nimport ImageryCoverage from \"./ImageryCoverage.js\";\nimport ModelImageryMapping from \"./ModelImageryMapping.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport MappedPositions from \"./MappedPositions.js\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\n\n/**\n * A class managing the draping of imagery on a single model primitive.\n *\n * The <code>ModelImagery</code> class creates one instance of this\n * class for each primitive that appears in the model.\n *\n * It is responsible for computing\n * - the mapped (cartographic) positions of the primitive\n * - the imagery tiles that are covered by these mapped positions\n * - the texture coordinates (attributes) that correspond to these mapped positions\n *\n * @private\n */\nclass ModelPrimitiveImagery {\n  /**\n   * Creates a new instance\n   *\n   * @param {Model} model The model\n   * @param {ModelRuntimeNode} runtimeNode The node that the primitive is attached to\n   * @param {ModelRuntimePrimitive} runtimePrimitive The primitive\n   * @throws {DeveloperError} If any argument is not defined\n   */\n  constructor(model, runtimeNode, runtimePrimitive) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"model\", model);\n    Check.defined(\"runtimeNode\", runtimeNode);\n    Check.defined(\"runtimePrimitive\", runtimePrimitive);\n    //>>includeEnd('debug');\n\n    /**\n     * The model that this instance was created for.\n     *\n     * @type {Model}\n     * @readonly\n     * @private\n     */\n    this._model = model;\n\n    /**\n     * The node that the primitive is attached to\n     *\n     * @type {ModelRuntimeNode}\n     * @readonly\n     * @private\n     */\n    this._runtimeNode = runtimeNode;\n\n    /**\n     * The primitive that this instance was created for.\n     *\n     * @type {ModelRuntimePrimitive}\n     * @readonly\n     * @private\n     */\n    this._runtimePrimitive = runtimePrimitive;\n\n    /**\n     * The <code>MappedPositions</code> objects, one for each ellipsoid\n     * of one of the imagery layers\n     *\n     * These objects are just plain structures that summarize the\n     * cartographic positions of the primitive for one specific\n     * ellipsoid\n     *\n     * @type {MappedPositions[]|undefined}\n     * @private\n     */\n    this._mappedPositionsPerEllipsoid = undefined;\n\n    /**\n     * The last <code>model.modelMatrix</code> for which the mapped\n     * positions have been computed.\n     *\n     * This is used for detecting changes in the model matrix that\n     * make it necessary to re-compute the mapped positions.\n     *\n     * @type {Matrix4}\n     * @readonly\n     * @private\n     */\n    this._mappedPositionsModelMatrix = new Matrix4();\n\n    /**\n     * The value that the <code>Cesium3DTileset.imageryLayersModificationCounter</code>\n     * had during the last update call. This is used for triggering updates when the\n     * imagery layer collection in the tileset changes.\n     */\n    this._lastImageryLayersModificationCounter = 0;\n\n    /**\n     * The texture coordinate attributes, one for each projection.\n     *\n     * This contains one <code>ModelComponents.Attribute</code> for each\n     * unique projection that is used in the imagery layers. These\n     * texture coordinate attributes are computed based on the mapped\n     * positions for the respective ellipsoid of that projection.\n     */\n    this._imageryTexCoordAttributesPerProjection = undefined;\n\n    /**\n     * The current imagery layers.\n     *\n     * This is initialized when the _coveragesPerLayer are computed,\n     * and tracked to that the reference counters of the imageries\n     * can be decreased when the coverages per layer are deleted.\n     *\n     * @type {ImageryLayer[]|undefined}\n     * @private\n     */\n    this._currentImageryLayers = undefined;\n\n    /**\n     * Information about the imagery tiles that are covered by the positions\n     * of the primitive.\n     *\n     * This is computed in the <code>update</code> function, based on the\n     * mapped positions of the primitive. After this computation,\n     * <code>_coveragesPerLayer[layerIndex]</code> is an array that contains\n     * the <code>ImageryCoverage</code> objects that describe the imagery\n     * tiles that are covered, including their texture coordinate rectangle.\n     *\n     * @type {ImageryCoverage[][]|undefined}\n     * @private\n     */\n    this._coveragesPerLayer = undefined;\n\n    /**\n     * A flag indicating whether all imagery objects that are covered\n     * are \"ready\".\n     *\n     * This is initially <code>false</code>. During the calls to the\n     * <code>update</code> function (which are triggered from the\n     * <code>Model.update</code> function, each frame), the\n     * <code>_updateImageries</code> function will be called, and\n     * process the imagery tiles, until all them them are in a\n     * state like <code>ImageryState.READY</code>, at which point\n     * this flag is set to <code>true</code>.\n     *\n     * @type {boolean}\n     * @private\n     */\n    this._allImageriesReady = false;\n  }\n\n  /**\n   * Returns the <code>ImageryCoverage</code> array that has been\n   * computed for the given imagery layer.\n   *\n   * This assumes that the given imagery layer is part of the\n   * imagery layer collection of the model, and that this\n   * model primitive imagery is \"ready\", meaning that the\n   * coverages have already been computed.\n   *\n   * Clients may <b>not</b> modify the returned array or any\n   * of its objects!\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @returns {ImageryCoverage[]} The coverage information\n   */\n  coveragesForImageryLayer(imageryLayer) {\n    const model = this._model;\n    const imageryLayers = model.imageryLayers;\n    const index = imageryLayers.indexOf(imageryLayer);\n    if (index === -1) {\n      throw new DeveloperError(\"Imagery layer is not part of the model\");\n    }\n    const coveragesPerLayer = this._coveragesPerLayer;\n    if (!defined(coveragesPerLayer)) {\n      throw new DeveloperError(`The coveragesPerLayer have not been computed yet`);\n    }\n    return coveragesPerLayer[index];\n  }\n\n  /**\n   * Update the state of this instance.\n   *\n   * This is called as part of <code>ModelImagery.update</code>, which in\n   * turn is part of the <code>Model.update</code> that is called in each\n   * frame.\n   *\n   * This will perform the computations that are required to establish\n   * the mapping between the imagery and the primitive. It will...\n   * <ul>\n   *   <li>\n   *     Compute the <code>MappedPositions</code> of the primitive,\n   *     one instance for each ellipsoid\n   *   </li>\n   *   <li>\n   *     Compute the \"coverages per layer\", containing the information\n   *     about which parts of the respective imagery layer are covered\n   *     by the mapped positions\n   *   </li>\n   *   <li>\n   *     Compute the texture coordinate attributes for the imagery, one\n   *     for each projection, and store them as the\n   *     <code>_imageryTexCoordAttributesPerProjection</code>\n   *   </li>\n   *   <li>\n   *     Update the imageries (i.e. processing their state machine by\n   *     calling <code>Imagery.processStateMachine</code>) until they\n   *     are in the <code>ImageryState.READY</code> state\n   *   </li>\n   * </ul>\n   *\n   * @param {FrameState} frameState The frame state\n   */\n  update(frameState) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"frameState\", frameState);\n    //>>includeEnd('debug');\n\n    // If the imagery layers have been modified since the last call\n    // to this function, then re-build everything\n    const model = this._model;\n    const content = model.content;\n    const tileset = content.tileset;\n    const modificationCounter = tileset.imageryLayersModificationCounter;\n    if (this._lastImageryLayersModificationCounter !== modificationCounter) {\n      delete this._mappedPositionsPerEllipsoid;\n      this._lastImageryLayersModificationCounter = modificationCounter;\n    }\n    if (this._mappedPositionsNeedUpdate) {\n      model.resetDrawCommands();\n      this._mappedPositionsPerEllipsoid = this._computeMappedPositionsPerEllipsoid();\n      this._deleteCoveragesPerLayer();\n      this._destroyImageryTexCoordAttributes();\n    }\n    if (!defined(this._imageryTexCoordAttributesPerProjection)) {\n      this._imageryTexCoordAttributesPerProjection = this._computeImageryTexCoordsAttributesPerProjection();\n      this._uploadImageryTexCoordAttributes(frameState.context);\n    }\n    if (!defined(this._coveragesPerLayer)) {\n      this._computeCoveragesPerLayer();\n      this._allImageriesReady = false;\n    }\n    if (!this._allImageriesReady) {\n      this._updateImageries(frameState);\n    }\n  }\n\n  /**\n   * Delete the <code>_coveragesPerLayer</code> if they are defined.\n   *\n   * This will call <code>deleteCoverages</code> for each set of coverages,\n   * and eventually delete the <code>_coveragesPerLayer</code>.\n   *\n   * This will cause the reference counters of the imageries to be\n   * decreased.\n   */\n  _deleteCoveragesPerLayer() {\n    const coveragesPerLayer = this._coveragesPerLayer;\n    if (!defined(coveragesPerLayer)) {\n      return;\n    }\n    const imageryLayers = this._currentImageryLayers;\n    const length = coveragesPerLayer.length;\n    for (let i = 0; i < length; i++) {\n      const imageryLayer = imageryLayers[i];\n      const coverages = coveragesPerLayer[i];\n      this._deleteCoverages(imageryLayer, coverages);\n    }\n    delete this._currentImageryLayers;\n    delete this._coveragesPerLayer;\n  }\n\n  /**\n   * Delete the given imagery coverage objects for the given imagery\n   * layer, meaning that it will cause the reference counters of the\n   * imageries to be decreased.\n   *\n   * If the imagery layer already has been destroyed, then nothing\n   * will be done.\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @param {ImageryCoverage[]} coverages The coverages\n   */\n  _deleteCoverages(imageryLayer, coverages) {\n    if (imageryLayer.isDestroyed()) {\n      return;\n    }\n    const length = coverages.length;\n    for (let i = 0; i < length; i++) {\n      const coverage = coverages[i];\n      const imagery = coverage.imagery;\n      imagery.releaseReference();\n    }\n  }\n\n  /**\n   * Create the GPU buffers for the typed arrays that are contained\n   * in the <code>_imageryTexCoordAttributesPerProjection</code>\n   *\n   * @param {Context} context The GL context\n   */\n  _uploadImageryTexCoordAttributes(context) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"context\", context);\n    //>>includeEnd('debug');\n\n    const attributes = this._imageryTexCoordAttributesPerProjection;\n    if (!defined(attributes)) {\n      return;\n    }\n    const n = attributes.length;\n    for (let i = 0; i < n; i++) {\n      const attribute = attributes[i];\n\n      // Allocate the GL resources for the new attribute\n      const imageryTexCoordBuffer = Buffer.createVertexBuffer({\n        context: context,\n        typedArray: attribute.typedArray,\n        usage: BufferUsage.STATIC_DRAW\n      });\n\n      // TODO_DRAPING Review this. Probably, some cleanup\n      // has to happen somewhere else after setting this.\n      // Check that the call to \"destroy\" in\n      // _destroyImageryTexCoordAttributes is the right\n      // thing to do here.\n      imageryTexCoordBuffer.vertexArrayDestroyable = false;\n      attribute.buffer = imageryTexCoordBuffer;\n    }\n  }\n\n  /**\n   * Destroy the <code>_imageryTexCoordAttributesPerProjection</code>\n   * array.\n   *\n   * This is called for cleaning up the allocated GPU resources, before\n   * they are supposed to be re-computed with\n   * <code>_computeImageryTexCoordsAttributesPerProjection</code>\n   */\n  _destroyImageryTexCoordAttributes() {\n    const attributes = this._imageryTexCoordAttributesPerProjection;\n    if (!defined(attributes)) {\n      return;\n    }\n    const n = attributes.length;\n    for (let i = 0; i < n; i++) {\n      const attribute = attributes[i];\n      if (defined(attribute)) {\n        if (defined(attribute.buffer)) {\n          if (!attribute.buffer.isDestroyed()) {\n            attribute.buffer.destroy();\n          }\n        }\n        attributes[i] = undefined;\n      }\n    }\n    delete this._imageryTexCoordAttributesPerProjection;\n  }\n\n  /**\n   * Returns whether the <code>MappedPositions</code> have to be\n   * re-computed with <code>_computeMappedPositionsPerEllipsoid</code>.\n   *\n   * This is <code>true</code> when the positions have not yet been\n   * computed, or when the <code>modelMatrix</code> of the model\n   * changed since the previous call.\n   *\n   * @returns {boolean} Whether the mapped positions need an update\n   * @private\n   */\n  get _mappedPositionsNeedUpdate() {\n    if (!defined(this._mappedPositionsPerEllipsoid)) {\n      return true;\n    }\n    const model = this._model;\n    const lastModelMatrix = this._mappedPositionsModelMatrix;\n    if (!Matrix4.equals(model.modelMatrix, lastModelMatrix)) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Computes the mapped positions of the primitive, one for each ellipsoid.\n   *\n   * This computes the <i>unique</i> ellipsoids that appear in the imagery\n   * layers of the model, and creates one <code>MappedPositions</code>\n   * object for each of them.\n   *\n   * The respective <code>MappedPositions</code> objects will contain\n   * the cartographic positions that are computed from the positions\n   * of the primitive. These will serve as the basis for computing the\n   * part of the imagery that is covered by the primitive.\n   *\n   * These mapped positions depend on the current <code>modelMatrix</code>\n   * of the model. So they have to be re-computed when the model matrix\n   * changes.\n   *\n   * @returns {MappedPositions[]} The mapped positions\n   * @private\n   */\n  _computeMappedPositionsPerEllipsoid() {\n    const model = this._model;\n    const runtimeNode = this._runtimeNode;\n    const runtimePrimitive = this._runtimePrimitive;\n    const primitivePositionAttribute = ModelPrimitiveImagery._obtainPrimitivePositionAttribute(runtimePrimitive.primitive);\n    const numPositions = primitivePositionAttribute.count;\n    const primitivePositionTransform = ModelPrimitiveImagery._computePrimitivePositionTransform(model, runtimeNode, undefined);\n    const mappedPositionsPerEllipsoid = [];\n    const ellipsoids = ModelPrimitiveImagery._computeUniqueEllipsoids(model.imageryLayers);\n    const length = ellipsoids.length;\n    for (let i = 0; i < length; i++) {\n      const ellipsoid = ellipsoids[i];\n      const cartographicPositions = ModelImageryMapping.createCartographicPositions(primitivePositionAttribute, primitivePositionTransform, ellipsoid);\n      const cartographicBoundingRectangle = ModelImageryMapping.computeCartographicBoundingRectangle(cartographicPositions);\n      const mappedPositions = new MappedPositions(cartographicPositions, numPositions, cartographicBoundingRectangle, ellipsoid);\n      mappedPositionsPerEllipsoid.push(mappedPositions);\n    }\n    Matrix4.clone(model.modelMatrix, this._mappedPositionsModelMatrix);\n    return mappedPositionsPerEllipsoid;\n  }\n\n  /**\n   * Computes an array containing the <i>unique</i> ellipsoids that\n   * appear in the imagery layers of the given collection.\n   *\n   * @param {ImageryLayerCollection} imageryLayers\n   * @returns {Ellipsoid[]} The ellipsoids\n   * @private\n   */\n  static _computeUniqueEllipsoids(imageryLayers) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"imageryLayers\", imageryLayers);\n    //>>includeEnd('debug');\n\n    const ellipsoidsSet = new Set();\n    const length = imageryLayers.length;\n    for (let i = 0; i < length; i++) {\n      const imageryLayer = imageryLayers.get(i);\n      const ellipsoid = ModelPrimitiveImagery._getEllipsoid(imageryLayer);\n      ellipsoidsSet.add(ellipsoid);\n    }\n    return [...ellipsoidsSet];\n  }\n\n  /**\n   * Computes one coordinate attribute for each unique projection\n   * that is used in the imagery layers.\n   *\n   * This is taking the mapped positions, projecting them with\n   * the respective projection, and creating a texture coordinate\n   * attribute that describes the texture coordinates of these\n   * positions, relative to the cartographic bounding rectangle\n   * of the mapped positions.\n   *\n   * @returns {ModelComponents.Attribute[]} The attributes\n   */\n  _computeImageryTexCoordsAttributesPerProjection() {\n    const model = this._model;\n    const imageryLayers = model.imageryLayers;\n\n    // Compute the arrays containing ALL projections and the array\n    // containing the UNIQUE projections from the imagery layers.\n    // Texture coordinate attributes only have to be created once\n    // for each projection.\n    const allProjections = ModelPrimitiveImagery._extractProjections(imageryLayers);\n    const uniqueProjections = [...new Set(allProjections)];\n\n    // Create one texture coordinate attribute for each distinct\n    // projection that is used in the imagery layers\n    const attributes = this._createImageryTexCoordAttributes(uniqueProjections);\n    return attributes;\n  }\n\n  /**\n   * Computes an array containing the projections that are used in\n   * the given imagery layers.\n   *\n   * (Note that this array may contain duplicates)\n   *\n   * @param {ImageryLayerCollection} imageryLayers The imagery layers\n   * @returns {MapProjection[]} The projections\n   * @private\n   */\n  static _extractProjections(imageryLayers) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"imageryLayers\", imageryLayers);\n    //>>includeEnd('debug');\n\n    const projections = [];\n    const length = imageryLayers.length;\n    for (let i = 0; i < length; i++) {\n      const imageryLayer = imageryLayers.get(i);\n      const projection = ModelPrimitiveImagery._getProjection(imageryLayer);\n      projections.push(projection);\n    }\n    return projections;\n  }\n\n  /**\n   * Returns the projection of the given imagery layer.\n   *\n   * This only exists to hide a train wreck\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @returns {MapProjection} The projection\n   * @private\n   */\n  static _getProjection(imageryLayer) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"imageryLayer\", imageryLayer);\n    //>>includeEnd('debug');\n    const projection = imageryLayer.imageryProvider.tilingScheme.projection;\n    return projection;\n  }\n\n  /**\n   * Create texture coordinates, one for each projection.\n   *\n   * This will create a texture coordinate attribute for each of the given projections,\n   * using <code>ModelImageryMapping.createTextureCoordinatesAttributeForMappedPositions</code>,\n   *\n   * (This means that the given projections should indeed be unique,\n   * i.e. contain no duplicates)\n   *\n   * @param {MapProjection[]} uniqueProjections The projections\n   * @returns {ModelComponents.Attribute[]} The attributes\n   */\n  _createImageryTexCoordAttributes(uniqueProjections) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"uniqueProjections\", uniqueProjections);\n    //>>includeEnd('debug');\n\n    const imageryTexCoordAttributePerUniqueProjection = [];\n    const length = uniqueProjections.length;\n    for (let i = 0; i < length; i++) {\n      // Obtain the mapped positions for the ellipsoid that is used\n      // in the projection (i.e. the cartographic positions of the\n      // primitive, for the respective ellipsoid)\n      const projection = uniqueProjections[i];\n      const ellipsoid = projection.ellipsoid;\n      const mappedPositions = this.mappedPositionsForEllipsoid(ellipsoid);\n\n      // Create the actual attribute\n      const imageryTexCoordAttribute = ModelImageryMapping.createTextureCoordinatesAttributeForMappedPositions(mappedPositions, projection);\n      imageryTexCoordAttributePerUniqueProjection.push(imageryTexCoordAttribute);\n    }\n    return imageryTexCoordAttributePerUniqueProjection;\n  }\n\n  /**\n   * Compute the coverage information for the primitive, based on the\n   * imagery layers that are associated with the model.\n   *\n   * This updates the <code>_coveragesPerLayer[layerIndex]</code>, which\n   * is an array that contains the <code>ImageryCoverage</code> objects that\n   * describe the imagery tiles that are covered by the primitive, including\n   * their texture coordinate rectangle.\n   *\n   * This has to be called after the mapped positions for the primitive\n   * have been computed with <code>_computeMappedPositionsPerEllipsoid</code>.\n   *\n   * @private\n   */\n  _computeCoveragesPerLayer() {\n    const coveragesPerLayer = [];\n    const currentImageryLayers = [];\n    const model = this._model;\n    const imageryLayers = model.imageryLayers;\n    const length = imageryLayers.length;\n    for (let i = 0; i < length; i++) {\n      const imageryLayer = imageryLayers.get(i);\n      const coverages = this._computeCoverage(imageryLayer);\n      coveragesPerLayer.push(coverages);\n      currentImageryLayers.push(imageryLayer);\n    }\n    this._coveragesPerLayer = coveragesPerLayer;\n    this._currentImageryLayers = currentImageryLayers;\n  }\n\n  /**\n   * Compute the coverage information for the primitive, based on the\n   * given imagery layer.\n   *\n   * This returns an array that contains the <code>ImageryCoverage</code>\n   * objects that describe the imagery tiles that are covered by the\n   * primitive, including their texture coordinate rectangle.\n   *\n   * This has to be called after the mapped positions for the primitive\n   * have been computed with <code>_computeMappedPositionsPerEllipsoid</code>.\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @returns {ImageryCoverage[]} The coverage information\n   * @private\n   */\n  _computeCoverage(imageryLayer) {\n    const mappedPositions = this.mappedPositionsForImageryLayer(imageryLayer);\n    const cartographicBoundingRectangle = mappedPositions.cartographicBoundingRectangle;\n    const imageryLevel = this._computeImageryLevel(imageryLayer, cartographicBoundingRectangle);\n    const coverages = ImageryCoverage.createImageryCoverages(cartographicBoundingRectangle, imageryLayer, imageryLevel);\n    return coverages;\n  }\n\n  /**\n   * Compute a <code>level</code> for accessing the imagery from the given\n   * imagery layer that is suitable for a primitive with the given bounding\n   * rectangle.\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @param {Rectangle} cartographicBoundingRectangle The cartographic\n   * bounding rectangle, as obtained from the MappedPositions for\n   * the given imagery layer\n   * @returns {number} The imagery level\n   */\n  _computeImageryLevel(imageryLayer, cartographicBoundingRectangle) {\n    const imageryProvider = imageryLayer.imageryProvider;\n    const tilingScheme = imageryProvider.tilingScheme;\n    const rectangle = tilingScheme.rectangle;\n\n    // The number of tiles covered by the boundingRectangle (b)\n    // for a certain level, based on the tiling scheme rectangle (r) is\n    // numberOfTilesCovered = b / (r / 2^level)\n    // Solving for \"level\" yields\n    // level = log2( numberOfTilesCovered * r / b)\n\n    // The goal here is to drape approximately (!) one imagery\n    // tile on each primitive. In practice, it may be more\n    // (up to 9 in theory)\n    const desiredNumberOfTilesCovered = 1;\n\n    // Perform the computation of the desired level, based on the\n    // number of tiles that should be covered (by whatever is\n    // larger, the width or the height)\n    let boundingRectangleSize = cartographicBoundingRectangle.width;\n    let rectangleSize = rectangle.width;\n    if (cartographicBoundingRectangle.height > cartographicBoundingRectangle.width) {\n      boundingRectangleSize = cartographicBoundingRectangle.height;\n      rectangleSize = rectangle.height;\n    }\n    const desiredLevel = Math.log2(desiredNumberOfTilesCovered * rectangleSize / boundingRectangleSize);\n\n    // Clamp the level to a valid range, and an integer value\n    const imageryLevel = ImageryCoverage._clampImageryLevel(imageryProvider, desiredLevel);\n    return imageryLevel;\n  }\n\n  /**\n   * Update all <code>Imagery</code> objects.\n   *\n   * This is called as part of <code>update</code>, until all required\n   * imagery tiles are \"ready\", as indicated by their <code>state</code>\n   * being <code>ImageryState.READY</code>.\n   *\n   * This is called after it has been determined which imagery tiles are\n   * covered by the primitive (i.e. after the <code>_coveragesPerLayer</code>\n   * have been computed by calling <code>_computeCoverages</code>).\n   *\n   * For each covered imagery tile, this will call\n   * <code>Imagery.processStateMachine</code> until they are either\n   * READY, FAILED, or INVALID.\n   *\n   * Once they all are in one of these final states, it will set the\n   * <code>_allImageriesReady</code> flag to <code>true</code>.\n   *\n   * @param {FrameState} frameState The frame state, to be passed to\n   * <code>imagery.processStateMachine</code>\n   * @private\n   */\n  _updateImageries(frameState) {\n    const model = this._model;\n    const coveragesPerLayer = this._coveragesPerLayer;\n    const length = coveragesPerLayer.length;\n    let allImageriesReady = true;\n    for (let i = 0; i < length; i++) {\n      const coverages = coveragesPerLayer[i];\n      const n = coverages.length;\n      for (let j = 0; j < n; j++) {\n        const coverage = coverages[j];\n        const imagery = coverage.imagery;\n\n        // In the context of loading the imagery for draping\n        // it over the primitive, the imagery counts as \"ready\"\n        // when it is really ready, but also when it failed\n        // or was invalid (otherwise, the primitive would\n        // never turn \"ready\"\n        const countsAsReady = imagery.state === ImageryState.READY || imagery.state === ImageryState.FAILED || imagery.state === ImageryState.INVALID;\n        if (!countsAsReady) {\n          allImageriesReady = false;\n          imagery.processStateMachine(frameState, false, false);\n        }\n      }\n    }\n\n    // When the imageries turned ready, reset the draw commands\n    // to trigger a rendering with the updated draw commands\n    // that include the imagery now.\n    if (allImageriesReady) {\n      model.resetDrawCommands();\n    }\n    this._allImageriesReady = allImageriesReady;\n  }\n\n  /**\n   * Returns the <code>MappedPositions</code> object that contains\n   * information about the primitive positions that have been computed\n   * for the given imagery layer.\n   *\n   * This assumes that <code>_computeMappedPositionsPerEllipsoid</code> has\n   * already been called.\n   *\n   * @param {ImageryLayer} imageryLayer The imageryLayer\n   * @returns {MappedPositions} The mapped positions\n   * @throws {DeveloperError} If the mapped positions for the\n   * ellipsoid could not be found.\n   */\n  mappedPositionsForImageryLayer(imageryLayer) {\n    const ellipsoid = ModelPrimitiveImagery._getEllipsoid(imageryLayer);\n    return this.mappedPositionsForEllipsoid(ellipsoid);\n  }\n\n  /**\n   * Returns the <code>MappedPositions</code> object that contains\n   * information about the primitive positions that have been computed\n   * from the given ellipsoid.\n   *\n   * This assumes that <code>_computeMappedPositions</code> has\n   * already been called.\n   *\n   * @param {Ellipsoid} ellipsoid The ellipsoid\n   * @returns {MappedPositions} The mapped positions\n   * @throws {DeveloperError} If the mapped positions for the\n   * given ellipsoid could not be found.\n   */\n  mappedPositionsForEllipsoid(ellipsoid) {\n    const mappedPositionsPerEllipsoid = this._mappedPositionsPerEllipsoid;\n    if (!defined(mappedPositionsPerEllipsoid)) {\n      throw new DeveloperError(`The mappedPositions have not been computed yet`);\n    }\n    const length = mappedPositionsPerEllipsoid.length;\n    for (let i = 0; i < length; i++) {\n      const mappedPositions = mappedPositionsPerEllipsoid[i];\n      if (mappedPositions.ellipsoid === ellipsoid) {\n        return mappedPositions;\n      }\n    }\n    throw new DeveloperError(`Could not find mapped positions for ellipsoid ${ellipsoid}`);\n  }\n\n  /**\n   * Returns the texture coordinate attributes for the primitive that\n   * are used for draping the imagery.\n   *\n   * This will be available when this object is <code>ready</code>, and\n   * will contain one attribute for each unique projection that appears\n   * in the imagery layers.\n   *\n   * @returns {ModelComponents.Attribute[]} The attributes\n   */\n  imageryTexCoordAttributesPerProjection() {\n    const imageryTexCoordAttributesPerProjection = this._imageryTexCoordAttributesPerProjection;\n    if (!defined(imageryTexCoordAttributesPerProjection)) {\n      throw new DeveloperError(`The imagery texture coordinate attributes have not been computed yet`);\n    }\n    return this._imageryTexCoordAttributesPerProjection;\n  }\n\n  /**\n   * Returns whether the draping computations are \"ready\".\n   *\n   * This means that the <code>coveragesPerLayer</code> information\n   * has been computed, which describes the set of imagery tiles\n   * that are covered by the primitive, <b>and</b> that all the\n   * covered imagery tiles are in a state that counts as \"ready\"\n   * (i.e. <code>ImageryState.READY</code>, <code>FAILED</code>,\n   * or <code>INVALID</code>).\n   *\n   * @returns {boolean} Whether the draping computations are ready\n   */\n  get ready() {\n    const coveragesPerLayer = this._coveragesPerLayer;\n    if (!defined(coveragesPerLayer)) {\n      return false;\n    }\n    return this._allImageriesReady;\n  }\n\n  /**\n   * Returns whether this object was destroyed.\n   *\n   * If this object was destroyed, calling any function other than\n   * <code>isDestroyed</code> will result in a {@link DeveloperError}.\n   *\n   * @returns {boolean} Whether this object was destroyed\n   */\n  isDestroyed() {\n    return false;\n  }\n\n  /**\n   * Destroys this object and all its resources.\n   */\n  destroy() {\n    if (this.isDestroyed()) {\n      return;\n    }\n    this._deleteCoveragesPerLayer();\n    this._destroyImageryTexCoordAttributes();\n    return destroyObject(this);\n  }\n\n  /**\n   * Compute the transform that apparently has to be applied to\n   * the positions attribute of a primitive, to compute the\n   * actual, final positions in ECEF coordinates.\n   *\n   * This is based on the computation of the bounding\n   * sphere that is done at the end of buildDrawCommands\n   *\n   * @param {Model} model The model\n   * @param {ModelComponents.Node} runtimeNode The runtime node\n   * that the primitive is attached to\n   * @param {Matrix4} [result] The result\n   * @returns {Matrix4} The result\n   * @private\n   */\n  static _computePrimitivePositionTransform(model, runtimeNode, result) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"model\", model);\n    Check.defined(\"runtimeNode\", runtimeNode);\n    //>>includeEnd('debug');\n\n    if (!defined(result)) {\n      result = new Matrix4();\n    }\n    const modelSceneGraph = model.sceneGraph;\n    Matrix4.clone(Matrix4.IDENTITY, result);\n    Matrix4.multiply(result, model.modelMatrix, result);\n    Matrix4.multiply(result, modelSceneGraph.components.transform, result);\n    Matrix4.multiply(result, modelSceneGraph.axisCorrectionMatrix, result);\n    Matrix4.multiply(result, runtimeNode.computedTransform, result);\n    return result;\n  }\n\n  /**\n   * Returns the <code>\"POSITION\"</code> attribute from the given primitive.\n   *\n   * The <code>\"POSITION\"</code> attribute is required. If it is not\n   * defined for the given primitive, then a <code>DeveloperError</code>\n   * is thrown.\n   *\n   * @param {ModelComponents.Primitive} primitive The primitive\n   * @returns {ModelComponents.Attribute} The position attribute\n   * @throws {DeveloperError} If there is no position attribute\n   * @private\n   */\n  static _obtainPrimitivePositionAttribute(primitive) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"primitive\", primitive);\n    //>>includeEnd('debug');\n\n    const primitivePositionAttribute = ModelUtility.getAttributeBySemantic(primitive, \"POSITION\");\n    if (!defined(primitivePositionAttribute)) {\n      throw new DeveloperError(\"The primitive does not have a POSITION attribute\");\n    }\n    return primitivePositionAttribute;\n  }\n\n  /**\n   * Returns the ellipsoid of the given imagery layer.\n   *\n   * This only exists to hide a train wreck\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @returns {Ellipsoid} The ellipsoid\n   * @private\n   */\n  static _getEllipsoid(imageryLayer) {\n    const ellipsoid = imageryLayer.imageryProvider.tilingScheme.projection.ellipsoid;\n    return ellipsoid;\n  }\n}\nexport default ModelPrimitiveImagery;","map":{"version":3,"names":["defined","DeveloperError","Matrix4","Check","destroyObject","ImageryState","ImageryCoverage","ModelImageryMapping","ModelUtility","MappedPositions","Buffer","BufferUsage","ModelPrimitiveImagery","constructor","model","runtimeNode","runtimePrimitive","_model","_runtimeNode","_runtimePrimitive","_mappedPositionsPerEllipsoid","undefined","_mappedPositionsModelMatrix","_lastImageryLayersModificationCounter","_imageryTexCoordAttributesPerProjection","_currentImageryLayers","_coveragesPerLayer","_allImageriesReady","coveragesForImageryLayer","imageryLayer","imageryLayers","index","indexOf","coveragesPerLayer","update","frameState","content","tileset","modificationCounter","imageryLayersModificationCounter","_mappedPositionsNeedUpdate","resetDrawCommands","_computeMappedPositionsPerEllipsoid","_deleteCoveragesPerLayer","_destroyImageryTexCoordAttributes","_computeImageryTexCoordsAttributesPerProjection","_uploadImageryTexCoordAttributes","context","_computeCoveragesPerLayer","_updateImageries","length","i","coverages","_deleteCoverages","isDestroyed","coverage","imagery","releaseReference","attributes","n","attribute","imageryTexCoordBuffer","createVertexBuffer","typedArray","usage","STATIC_DRAW","vertexArrayDestroyable","buffer","destroy","lastModelMatrix","equals","modelMatrix","primitivePositionAttribute","_obtainPrimitivePositionAttribute","primitive","numPositions","count","primitivePositionTransform","_computePrimitivePositionTransform","mappedPositionsPerEllipsoid","ellipsoids","_computeUniqueEllipsoids","ellipsoid","cartographicPositions","createCartographicPositions","cartographicBoundingRectangle","computeCartographicBoundingRectangle","mappedPositions","push","clone","ellipsoidsSet","Set","get","_getEllipsoid","add","allProjections","_extractProjections","uniqueProjections","_createImageryTexCoordAttributes","projections","projection","_getProjection","imageryProvider","tilingScheme","imageryTexCoordAttributePerUniqueProjection","mappedPositionsForEllipsoid","imageryTexCoordAttribute","createTextureCoordinatesAttributeForMappedPositions","currentImageryLayers","_computeCoverage","mappedPositionsForImageryLayer","imageryLevel","_computeImageryLevel","createImageryCoverages","rectangle","desiredNumberOfTilesCovered","boundingRectangleSize","width","rectangleSize","height","desiredLevel","Math","log2","_clampImageryLevel","allImageriesReady","j","countsAsReady","state","READY","FAILED","INVALID","processStateMachine","imageryTexCoordAttributesPerProjection","ready","result","modelSceneGraph","sceneGraph","IDENTITY","multiply","components","transform","axisCorrectionMatrix","computedTransform","getAttributeBySemantic"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Model/ModelPrimitiveImagery.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Check from \"../../Core/Check.js\";\nimport destroyObject from \"../../Core/destroyObject.js\";\n\nimport ImageryState from \"../ImageryState.js\";\nimport ImageryCoverage from \"./ImageryCoverage.js\";\nimport ModelImageryMapping from \"./ModelImageryMapping.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport MappedPositions from \"./MappedPositions.js\";\n\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\n\n/**\n * A class managing the draping of imagery on a single model primitive.\n *\n * The <code>ModelImagery</code> class creates one instance of this\n * class for each primitive that appears in the model.\n *\n * It is responsible for computing\n * - the mapped (cartographic) positions of the primitive\n * - the imagery tiles that are covered by these mapped positions\n * - the texture coordinates (attributes) that correspond to these mapped positions\n *\n * @private\n */\nclass ModelPrimitiveImagery {\n  /**\n   * Creates a new instance\n   *\n   * @param {Model} model The model\n   * @param {ModelRuntimeNode} runtimeNode The node that the primitive is attached to\n   * @param {ModelRuntimePrimitive} runtimePrimitive The primitive\n   * @throws {DeveloperError} If any argument is not defined\n   */\n  constructor(model, runtimeNode, runtimePrimitive) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"model\", model);\n    Check.defined(\"runtimeNode\", runtimeNode);\n    Check.defined(\"runtimePrimitive\", runtimePrimitive);\n    //>>includeEnd('debug');\n\n    /**\n     * The model that this instance was created for.\n     *\n     * @type {Model}\n     * @readonly\n     * @private\n     */\n    this._model = model;\n\n    /**\n     * The node that the primitive is attached to\n     *\n     * @type {ModelRuntimeNode}\n     * @readonly\n     * @private\n     */\n    this._runtimeNode = runtimeNode;\n\n    /**\n     * The primitive that this instance was created for.\n     *\n     * @type {ModelRuntimePrimitive}\n     * @readonly\n     * @private\n     */\n    this._runtimePrimitive = runtimePrimitive;\n\n    /**\n     * The <code>MappedPositions</code> objects, one for each ellipsoid\n     * of one of the imagery layers\n     *\n     * These objects are just plain structures that summarize the\n     * cartographic positions of the primitive for one specific\n     * ellipsoid\n     *\n     * @type {MappedPositions[]|undefined}\n     * @private\n     */\n    this._mappedPositionsPerEllipsoid = undefined;\n\n    /**\n     * The last <code>model.modelMatrix</code> for which the mapped\n     * positions have been computed.\n     *\n     * This is used for detecting changes in the model matrix that\n     * make it necessary to re-compute the mapped positions.\n     *\n     * @type {Matrix4}\n     * @readonly\n     * @private\n     */\n    this._mappedPositionsModelMatrix = new Matrix4();\n\n    /**\n     * The value that the <code>Cesium3DTileset.imageryLayersModificationCounter</code>\n     * had during the last update call. This is used for triggering updates when the\n     * imagery layer collection in the tileset changes.\n     */\n    this._lastImageryLayersModificationCounter = 0;\n\n    /**\n     * The texture coordinate attributes, one for each projection.\n     *\n     * This contains one <code>ModelComponents.Attribute</code> for each\n     * unique projection that is used in the imagery layers. These\n     * texture coordinate attributes are computed based on the mapped\n     * positions for the respective ellipsoid of that projection.\n     */\n    this._imageryTexCoordAttributesPerProjection = undefined;\n\n    /**\n     * The current imagery layers.\n     *\n     * This is initialized when the _coveragesPerLayer are computed,\n     * and tracked to that the reference counters of the imageries\n     * can be decreased when the coverages per layer are deleted.\n     *\n     * @type {ImageryLayer[]|undefined}\n     * @private\n     */\n    this._currentImageryLayers = undefined;\n\n    /**\n     * Information about the imagery tiles that are covered by the positions\n     * of the primitive.\n     *\n     * This is computed in the <code>update</code> function, based on the\n     * mapped positions of the primitive. After this computation,\n     * <code>_coveragesPerLayer[layerIndex]</code> is an array that contains\n     * the <code>ImageryCoverage</code> objects that describe the imagery\n     * tiles that are covered, including their texture coordinate rectangle.\n     *\n     * @type {ImageryCoverage[][]|undefined}\n     * @private\n     */\n    this._coveragesPerLayer = undefined;\n\n    /**\n     * A flag indicating whether all imagery objects that are covered\n     * are \"ready\".\n     *\n     * This is initially <code>false</code>. During the calls to the\n     * <code>update</code> function (which are triggered from the\n     * <code>Model.update</code> function, each frame), the\n     * <code>_updateImageries</code> function will be called, and\n     * process the imagery tiles, until all them them are in a\n     * state like <code>ImageryState.READY</code>, at which point\n     * this flag is set to <code>true</code>.\n     *\n     * @type {boolean}\n     * @private\n     */\n    this._allImageriesReady = false;\n  }\n\n  /**\n   * Returns the <code>ImageryCoverage</code> array that has been\n   * computed for the given imagery layer.\n   *\n   * This assumes that the given imagery layer is part of the\n   * imagery layer collection of the model, and that this\n   * model primitive imagery is \"ready\", meaning that the\n   * coverages have already been computed.\n   *\n   * Clients may <b>not</b> modify the returned array or any\n   * of its objects!\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @returns {ImageryCoverage[]} The coverage information\n   */\n  coveragesForImageryLayer(imageryLayer) {\n    const model = this._model;\n    const imageryLayers = model.imageryLayers;\n    const index = imageryLayers.indexOf(imageryLayer);\n    if (index === -1) {\n      throw new DeveloperError(\"Imagery layer is not part of the model\");\n    }\n    const coveragesPerLayer = this._coveragesPerLayer;\n    if (!defined(coveragesPerLayer)) {\n      throw new DeveloperError(\n        `The coveragesPerLayer have not been computed yet`,\n      );\n    }\n    return coveragesPerLayer[index];\n  }\n\n  /**\n   * Update the state of this instance.\n   *\n   * This is called as part of <code>ModelImagery.update</code>, which in\n   * turn is part of the <code>Model.update</code> that is called in each\n   * frame.\n   *\n   * This will perform the computations that are required to establish\n   * the mapping between the imagery and the primitive. It will...\n   * <ul>\n   *   <li>\n   *     Compute the <code>MappedPositions</code> of the primitive,\n   *     one instance for each ellipsoid\n   *   </li>\n   *   <li>\n   *     Compute the \"coverages per layer\", containing the information\n   *     about which parts of the respective imagery layer are covered\n   *     by the mapped positions\n   *   </li>\n   *   <li>\n   *     Compute the texture coordinate attributes for the imagery, one\n   *     for each projection, and store them as the\n   *     <code>_imageryTexCoordAttributesPerProjection</code>\n   *   </li>\n   *   <li>\n   *     Update the imageries (i.e. processing their state machine by\n   *     calling <code>Imagery.processStateMachine</code>) until they\n   *     are in the <code>ImageryState.READY</code> state\n   *   </li>\n   * </ul>\n   *\n   * @param {FrameState} frameState The frame state\n   */\n  update(frameState) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"frameState\", frameState);\n    //>>includeEnd('debug');\n\n    // If the imagery layers have been modified since the last call\n    // to this function, then re-build everything\n    const model = this._model;\n    const content = model.content;\n    const tileset = content.tileset;\n    const modificationCounter = tileset.imageryLayersModificationCounter;\n    if (this._lastImageryLayersModificationCounter !== modificationCounter) {\n      delete this._mappedPositionsPerEllipsoid;\n      this._lastImageryLayersModificationCounter = modificationCounter;\n    }\n\n    if (this._mappedPositionsNeedUpdate) {\n      model.resetDrawCommands();\n      this._mappedPositionsPerEllipsoid =\n        this._computeMappedPositionsPerEllipsoid();\n      this._deleteCoveragesPerLayer();\n      this._destroyImageryTexCoordAttributes();\n    }\n\n    if (!defined(this._imageryTexCoordAttributesPerProjection)) {\n      this._imageryTexCoordAttributesPerProjection =\n        this._computeImageryTexCoordsAttributesPerProjection();\n      this._uploadImageryTexCoordAttributes(frameState.context);\n    }\n\n    if (!defined(this._coveragesPerLayer)) {\n      this._computeCoveragesPerLayer();\n      this._allImageriesReady = false;\n    }\n    if (!this._allImageriesReady) {\n      this._updateImageries(frameState);\n    }\n  }\n\n  /**\n   * Delete the <code>_coveragesPerLayer</code> if they are defined.\n   *\n   * This will call <code>deleteCoverages</code> for each set of coverages,\n   * and eventually delete the <code>_coveragesPerLayer</code>.\n   *\n   * This will cause the reference counters of the imageries to be\n   * decreased.\n   */\n  _deleteCoveragesPerLayer() {\n    const coveragesPerLayer = this._coveragesPerLayer;\n    if (!defined(coveragesPerLayer)) {\n      return;\n    }\n    const imageryLayers = this._currentImageryLayers;\n    const length = coveragesPerLayer.length;\n    for (let i = 0; i < length; i++) {\n      const imageryLayer = imageryLayers[i];\n      const coverages = coveragesPerLayer[i];\n      this._deleteCoverages(imageryLayer, coverages);\n    }\n    delete this._currentImageryLayers;\n    delete this._coveragesPerLayer;\n  }\n\n  /**\n   * Delete the given imagery coverage objects for the given imagery\n   * layer, meaning that it will cause the reference counters of the\n   * imageries to be decreased.\n   *\n   * If the imagery layer already has been destroyed, then nothing\n   * will be done.\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @param {ImageryCoverage[]} coverages The coverages\n   */\n  _deleteCoverages(imageryLayer, coverages) {\n    if (imageryLayer.isDestroyed()) {\n      return;\n    }\n    const length = coverages.length;\n    for (let i = 0; i < length; i++) {\n      const coverage = coverages[i];\n      const imagery = coverage.imagery;\n      imagery.releaseReference();\n    }\n  }\n\n  /**\n   * Create the GPU buffers for the typed arrays that are contained\n   * in the <code>_imageryTexCoordAttributesPerProjection</code>\n   *\n   * @param {Context} context The GL context\n   */\n  _uploadImageryTexCoordAttributes(context) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"context\", context);\n    //>>includeEnd('debug');\n\n    const attributes = this._imageryTexCoordAttributesPerProjection;\n    if (!defined(attributes)) {\n      return;\n    }\n    const n = attributes.length;\n    for (let i = 0; i < n; i++) {\n      const attribute = attributes[i];\n\n      // Allocate the GL resources for the new attribute\n      const imageryTexCoordBuffer = Buffer.createVertexBuffer({\n        context: context,\n        typedArray: attribute.typedArray,\n        usage: BufferUsage.STATIC_DRAW,\n      });\n\n      // TODO_DRAPING Review this. Probably, some cleanup\n      // has to happen somewhere else after setting this.\n      // Check that the call to \"destroy\" in\n      // _destroyImageryTexCoordAttributes is the right\n      // thing to do here.\n      imageryTexCoordBuffer.vertexArrayDestroyable = false;\n\n      attribute.buffer = imageryTexCoordBuffer;\n    }\n  }\n\n  /**\n   * Destroy the <code>_imageryTexCoordAttributesPerProjection</code>\n   * array.\n   *\n   * This is called for cleaning up the allocated GPU resources, before\n   * they are supposed to be re-computed with\n   * <code>_computeImageryTexCoordsAttributesPerProjection</code>\n   */\n  _destroyImageryTexCoordAttributes() {\n    const attributes = this._imageryTexCoordAttributesPerProjection;\n    if (!defined(attributes)) {\n      return;\n    }\n    const n = attributes.length;\n    for (let i = 0; i < n; i++) {\n      const attribute = attributes[i];\n      if (defined(attribute)) {\n        if (defined(attribute.buffer)) {\n          if (!attribute.buffer.isDestroyed()) {\n            attribute.buffer.destroy();\n          }\n        }\n        attributes[i] = undefined;\n      }\n    }\n    delete this._imageryTexCoordAttributesPerProjection;\n  }\n\n  /**\n   * Returns whether the <code>MappedPositions</code> have to be\n   * re-computed with <code>_computeMappedPositionsPerEllipsoid</code>.\n   *\n   * This is <code>true</code> when the positions have not yet been\n   * computed, or when the <code>modelMatrix</code> of the model\n   * changed since the previous call.\n   *\n   * @returns {boolean} Whether the mapped positions need an update\n   * @private\n   */\n  get _mappedPositionsNeedUpdate() {\n    if (!defined(this._mappedPositionsPerEllipsoid)) {\n      return true;\n    }\n    const model = this._model;\n    const lastModelMatrix = this._mappedPositionsModelMatrix;\n    if (!Matrix4.equals(model.modelMatrix, lastModelMatrix)) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Computes the mapped positions of the primitive, one for each ellipsoid.\n   *\n   * This computes the <i>unique</i> ellipsoids that appear in the imagery\n   * layers of the model, and creates one <code>MappedPositions</code>\n   * object for each of them.\n   *\n   * The respective <code>MappedPositions</code> objects will contain\n   * the cartographic positions that are computed from the positions\n   * of the primitive. These will serve as the basis for computing the\n   * part of the imagery that is covered by the primitive.\n   *\n   * These mapped positions depend on the current <code>modelMatrix</code>\n   * of the model. So they have to be re-computed when the model matrix\n   * changes.\n   *\n   * @returns {MappedPositions[]} The mapped positions\n   * @private\n   */\n  _computeMappedPositionsPerEllipsoid() {\n    const model = this._model;\n    const runtimeNode = this._runtimeNode;\n    const runtimePrimitive = this._runtimePrimitive;\n\n    const primitivePositionAttribute =\n      ModelPrimitiveImagery._obtainPrimitivePositionAttribute(\n        runtimePrimitive.primitive,\n      );\n    const numPositions = primitivePositionAttribute.count;\n\n    const primitivePositionTransform =\n      ModelPrimitiveImagery._computePrimitivePositionTransform(\n        model,\n        runtimeNode,\n        undefined,\n      );\n\n    const mappedPositionsPerEllipsoid = [];\n    const ellipsoids = ModelPrimitiveImagery._computeUniqueEllipsoids(\n      model.imageryLayers,\n    );\n\n    const length = ellipsoids.length;\n    for (let i = 0; i < length; i++) {\n      const ellipsoid = ellipsoids[i];\n      const cartographicPositions =\n        ModelImageryMapping.createCartographicPositions(\n          primitivePositionAttribute,\n          primitivePositionTransform,\n          ellipsoid,\n        );\n      const cartographicBoundingRectangle =\n        ModelImageryMapping.computeCartographicBoundingRectangle(\n          cartographicPositions,\n        );\n\n      const mappedPositions = new MappedPositions(\n        cartographicPositions,\n        numPositions,\n        cartographicBoundingRectangle,\n        ellipsoid,\n      );\n      mappedPositionsPerEllipsoid.push(mappedPositions);\n    }\n    Matrix4.clone(model.modelMatrix, this._mappedPositionsModelMatrix);\n    return mappedPositionsPerEllipsoid;\n  }\n\n  /**\n   * Computes an array containing the <i>unique</i> ellipsoids that\n   * appear in the imagery layers of the given collection.\n   *\n   * @param {ImageryLayerCollection} imageryLayers\n   * @returns {Ellipsoid[]} The ellipsoids\n   * @private\n   */\n  static _computeUniqueEllipsoids(imageryLayers) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"imageryLayers\", imageryLayers);\n    //>>includeEnd('debug');\n\n    const ellipsoidsSet = new Set();\n    const length = imageryLayers.length;\n    for (let i = 0; i < length; i++) {\n      const imageryLayer = imageryLayers.get(i);\n      const ellipsoid = ModelPrimitiveImagery._getEllipsoid(imageryLayer);\n      ellipsoidsSet.add(ellipsoid);\n    }\n    return [...ellipsoidsSet];\n  }\n\n  /**\n   * Computes one coordinate attribute for each unique projection\n   * that is used in the imagery layers.\n   *\n   * This is taking the mapped positions, projecting them with\n   * the respective projection, and creating a texture coordinate\n   * attribute that describes the texture coordinates of these\n   * positions, relative to the cartographic bounding rectangle\n   * of the mapped positions.\n   *\n   * @returns {ModelComponents.Attribute[]} The attributes\n   */\n  _computeImageryTexCoordsAttributesPerProjection() {\n    const model = this._model;\n    const imageryLayers = model.imageryLayers;\n\n    // Compute the arrays containing ALL projections and the array\n    // containing the UNIQUE projections from the imagery layers.\n    // Texture coordinate attributes only have to be created once\n    // for each projection.\n    const allProjections =\n      ModelPrimitiveImagery._extractProjections(imageryLayers);\n    const uniqueProjections = [...new Set(allProjections)];\n\n    // Create one texture coordinate attribute for each distinct\n    // projection that is used in the imagery layers\n    const attributes = this._createImageryTexCoordAttributes(uniqueProjections);\n    return attributes;\n  }\n\n  /**\n   * Computes an array containing the projections that are used in\n   * the given imagery layers.\n   *\n   * (Note that this array may contain duplicates)\n   *\n   * @param {ImageryLayerCollection} imageryLayers The imagery layers\n   * @returns {MapProjection[]} The projections\n   * @private\n   */\n  static _extractProjections(imageryLayers) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"imageryLayers\", imageryLayers);\n    //>>includeEnd('debug');\n\n    const projections = [];\n    const length = imageryLayers.length;\n    for (let i = 0; i < length; i++) {\n      const imageryLayer = imageryLayers.get(i);\n      const projection = ModelPrimitiveImagery._getProjection(imageryLayer);\n      projections.push(projection);\n    }\n    return projections;\n  }\n\n  /**\n   * Returns the projection of the given imagery layer.\n   *\n   * This only exists to hide a train wreck\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @returns {MapProjection} The projection\n   * @private\n   */\n  static _getProjection(imageryLayer) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"imageryLayer\", imageryLayer);\n    //>>includeEnd('debug');\n    const projection = imageryLayer.imageryProvider.tilingScheme.projection;\n    return projection;\n  }\n\n  /**\n   * Create texture coordinates, one for each projection.\n   *\n   * This will create a texture coordinate attribute for each of the given projections,\n   * using <code>ModelImageryMapping.createTextureCoordinatesAttributeForMappedPositions</code>,\n   *\n   * (This means that the given projections should indeed be unique,\n   * i.e. contain no duplicates)\n   *\n   * @param {MapProjection[]} uniqueProjections The projections\n   * @returns {ModelComponents.Attribute[]} The attributes\n   */\n  _createImageryTexCoordAttributes(uniqueProjections) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"uniqueProjections\", uniqueProjections);\n    //>>includeEnd('debug');\n\n    const imageryTexCoordAttributePerUniqueProjection = [];\n    const length = uniqueProjections.length;\n    for (let i = 0; i < length; i++) {\n      // Obtain the mapped positions for the ellipsoid that is used\n      // in the projection (i.e. the cartographic positions of the\n      // primitive, for the respective ellipsoid)\n      const projection = uniqueProjections[i];\n      const ellipsoid = projection.ellipsoid;\n      const mappedPositions = this.mappedPositionsForEllipsoid(ellipsoid);\n\n      // Create the actual attribute\n      const imageryTexCoordAttribute =\n        ModelImageryMapping.createTextureCoordinatesAttributeForMappedPositions(\n          mappedPositions,\n          projection,\n        );\n      imageryTexCoordAttributePerUniqueProjection.push(\n        imageryTexCoordAttribute,\n      );\n    }\n    return imageryTexCoordAttributePerUniqueProjection;\n  }\n\n  /**\n   * Compute the coverage information for the primitive, based on the\n   * imagery layers that are associated with the model.\n   *\n   * This updates the <code>_coveragesPerLayer[layerIndex]</code>, which\n   * is an array that contains the <code>ImageryCoverage</code> objects that\n   * describe the imagery tiles that are covered by the primitive, including\n   * their texture coordinate rectangle.\n   *\n   * This has to be called after the mapped positions for the primitive\n   * have been computed with <code>_computeMappedPositionsPerEllipsoid</code>.\n   *\n   * @private\n   */\n  _computeCoveragesPerLayer() {\n    const coveragesPerLayer = [];\n    const currentImageryLayers = [];\n\n    const model = this._model;\n    const imageryLayers = model.imageryLayers;\n    const length = imageryLayers.length;\n    for (let i = 0; i < length; i++) {\n      const imageryLayer = imageryLayers.get(i);\n      const coverages = this._computeCoverage(imageryLayer);\n      coveragesPerLayer.push(coverages);\n      currentImageryLayers.push(imageryLayer);\n    }\n\n    this._coveragesPerLayer = coveragesPerLayer;\n    this._currentImageryLayers = currentImageryLayers;\n  }\n\n  /**\n   * Compute the coverage information for the primitive, based on the\n   * given imagery layer.\n   *\n   * This returns an array that contains the <code>ImageryCoverage</code>\n   * objects that describe the imagery tiles that are covered by the\n   * primitive, including their texture coordinate rectangle.\n   *\n   * This has to be called after the mapped positions for the primitive\n   * have been computed with <code>_computeMappedPositionsPerEllipsoid</code>.\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @returns {ImageryCoverage[]} The coverage information\n   * @private\n   */\n  _computeCoverage(imageryLayer) {\n    const mappedPositions = this.mappedPositionsForImageryLayer(imageryLayer);\n    const cartographicBoundingRectangle =\n      mappedPositions.cartographicBoundingRectangle;\n\n    const imageryLevel = this._computeImageryLevel(\n      imageryLayer,\n      cartographicBoundingRectangle,\n    );\n\n    const coverages = ImageryCoverage.createImageryCoverages(\n      cartographicBoundingRectangle,\n      imageryLayer,\n      imageryLevel,\n    );\n    return coverages;\n  }\n\n  /**\n   * Compute a <code>level</code> for accessing the imagery from the given\n   * imagery layer that is suitable for a primitive with the given bounding\n   * rectangle.\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @param {Rectangle} cartographicBoundingRectangle The cartographic\n   * bounding rectangle, as obtained from the MappedPositions for\n   * the given imagery layer\n   * @returns {number} The imagery level\n   */\n  _computeImageryLevel(imageryLayer, cartographicBoundingRectangle) {\n    const imageryProvider = imageryLayer.imageryProvider;\n    const tilingScheme = imageryProvider.tilingScheme;\n    const rectangle = tilingScheme.rectangle;\n\n    // The number of tiles covered by the boundingRectangle (b)\n    // for a certain level, based on the tiling scheme rectangle (r) is\n    // numberOfTilesCovered = b / (r / 2^level)\n    // Solving for \"level\" yields\n    // level = log2( numberOfTilesCovered * r / b)\n\n    // The goal here is to drape approximately (!) one imagery\n    // tile on each primitive. In practice, it may be more\n    // (up to 9 in theory)\n    const desiredNumberOfTilesCovered = 1;\n\n    // Perform the computation of the desired level, based on the\n    // number of tiles that should be covered (by whatever is\n    // larger, the width or the height)\n    let boundingRectangleSize = cartographicBoundingRectangle.width;\n    let rectangleSize = rectangle.width;\n    if (\n      cartographicBoundingRectangle.height > cartographicBoundingRectangle.width\n    ) {\n      boundingRectangleSize = cartographicBoundingRectangle.height;\n      rectangleSize = rectangle.height;\n    }\n    const desiredLevel = Math.log2(\n      (desiredNumberOfTilesCovered * rectangleSize) / boundingRectangleSize,\n    );\n\n    // Clamp the level to a valid range, and an integer value\n    const imageryLevel = ImageryCoverage._clampImageryLevel(\n      imageryProvider,\n      desiredLevel,\n    );\n    return imageryLevel;\n  }\n\n  /**\n   * Update all <code>Imagery</code> objects.\n   *\n   * This is called as part of <code>update</code>, until all required\n   * imagery tiles are \"ready\", as indicated by their <code>state</code>\n   * being <code>ImageryState.READY</code>.\n   *\n   * This is called after it has been determined which imagery tiles are\n   * covered by the primitive (i.e. after the <code>_coveragesPerLayer</code>\n   * have been computed by calling <code>_computeCoverages</code>).\n   *\n   * For each covered imagery tile, this will call\n   * <code>Imagery.processStateMachine</code> until they are either\n   * READY, FAILED, or INVALID.\n   *\n   * Once they all are in one of these final states, it will set the\n   * <code>_allImageriesReady</code> flag to <code>true</code>.\n   *\n   * @param {FrameState} frameState The frame state, to be passed to\n   * <code>imagery.processStateMachine</code>\n   * @private\n   */\n  _updateImageries(frameState) {\n    const model = this._model;\n    const coveragesPerLayer = this._coveragesPerLayer;\n    const length = coveragesPerLayer.length;\n    let allImageriesReady = true;\n    for (let i = 0; i < length; i++) {\n      const coverages = coveragesPerLayer[i];\n      const n = coverages.length;\n      for (let j = 0; j < n; j++) {\n        const coverage = coverages[j];\n        const imagery = coverage.imagery;\n\n        // In the context of loading the imagery for draping\n        // it over the primitive, the imagery counts as \"ready\"\n        // when it is really ready, but also when it failed\n        // or was invalid (otherwise, the primitive would\n        // never turn \"ready\"\n        const countsAsReady =\n          imagery.state === ImageryState.READY ||\n          imagery.state === ImageryState.FAILED ||\n          imagery.state === ImageryState.INVALID;\n        if (!countsAsReady) {\n          allImageriesReady = false;\n          imagery.processStateMachine(frameState, false, false);\n        }\n      }\n    }\n\n    // When the imageries turned ready, reset the draw commands\n    // to trigger a rendering with the updated draw commands\n    // that include the imagery now.\n    if (allImageriesReady) {\n      model.resetDrawCommands();\n    }\n    this._allImageriesReady = allImageriesReady;\n  }\n\n  /**\n   * Returns the <code>MappedPositions</code> object that contains\n   * information about the primitive positions that have been computed\n   * for the given imagery layer.\n   *\n   * This assumes that <code>_computeMappedPositionsPerEllipsoid</code> has\n   * already been called.\n   *\n   * @param {ImageryLayer} imageryLayer The imageryLayer\n   * @returns {MappedPositions} The mapped positions\n   * @throws {DeveloperError} If the mapped positions for the\n   * ellipsoid could not be found.\n   */\n  mappedPositionsForImageryLayer(imageryLayer) {\n    const ellipsoid = ModelPrimitiveImagery._getEllipsoid(imageryLayer);\n    return this.mappedPositionsForEllipsoid(ellipsoid);\n  }\n\n  /**\n   * Returns the <code>MappedPositions</code> object that contains\n   * information about the primitive positions that have been computed\n   * from the given ellipsoid.\n   *\n   * This assumes that <code>_computeMappedPositions</code> has\n   * already been called.\n   *\n   * @param {Ellipsoid} ellipsoid The ellipsoid\n   * @returns {MappedPositions} The mapped positions\n   * @throws {DeveloperError} If the mapped positions for the\n   * given ellipsoid could not be found.\n   */\n  mappedPositionsForEllipsoid(ellipsoid) {\n    const mappedPositionsPerEllipsoid = this._mappedPositionsPerEllipsoid;\n    if (!defined(mappedPositionsPerEllipsoid)) {\n      throw new DeveloperError(\n        `The mappedPositions have not been computed yet`,\n      );\n    }\n\n    const length = mappedPositionsPerEllipsoid.length;\n    for (let i = 0; i < length; i++) {\n      const mappedPositions = mappedPositionsPerEllipsoid[i];\n      if (mappedPositions.ellipsoid === ellipsoid) {\n        return mappedPositions;\n      }\n    }\n    throw new DeveloperError(\n      `Could not find mapped positions for ellipsoid ${ellipsoid}`,\n    );\n  }\n\n  /**\n   * Returns the texture coordinate attributes for the primitive that\n   * are used for draping the imagery.\n   *\n   * This will be available when this object is <code>ready</code>, and\n   * will contain one attribute for each unique projection that appears\n   * in the imagery layers.\n   *\n   * @returns {ModelComponents.Attribute[]} The attributes\n   */\n  imageryTexCoordAttributesPerProjection() {\n    const imageryTexCoordAttributesPerProjection =\n      this._imageryTexCoordAttributesPerProjection;\n    if (!defined(imageryTexCoordAttributesPerProjection)) {\n      throw new DeveloperError(\n        `The imagery texture coordinate attributes have not been computed yet`,\n      );\n    }\n    return this._imageryTexCoordAttributesPerProjection;\n  }\n\n  /**\n   * Returns whether the draping computations are \"ready\".\n   *\n   * This means that the <code>coveragesPerLayer</code> information\n   * has been computed, which describes the set of imagery tiles\n   * that are covered by the primitive, <b>and</b> that all the\n   * covered imagery tiles are in a state that counts as \"ready\"\n   * (i.e. <code>ImageryState.READY</code>, <code>FAILED</code>,\n   * or <code>INVALID</code>).\n   *\n   * @returns {boolean} Whether the draping computations are ready\n   */\n  get ready() {\n    const coveragesPerLayer = this._coveragesPerLayer;\n    if (!defined(coveragesPerLayer)) {\n      return false;\n    }\n    return this._allImageriesReady;\n  }\n\n  /**\n   * Returns whether this object was destroyed.\n   *\n   * If this object was destroyed, calling any function other than\n   * <code>isDestroyed</code> will result in a {@link DeveloperError}.\n   *\n   * @returns {boolean} Whether this object was destroyed\n   */\n  isDestroyed() {\n    return false;\n  }\n\n  /**\n   * Destroys this object and all its resources.\n   */\n  destroy() {\n    if (this.isDestroyed()) {\n      return;\n    }\n    this._deleteCoveragesPerLayer();\n    this._destroyImageryTexCoordAttributes();\n    return destroyObject(this);\n  }\n\n  /**\n   * Compute the transform that apparently has to be applied to\n   * the positions attribute of a primitive, to compute the\n   * actual, final positions in ECEF coordinates.\n   *\n   * This is based on the computation of the bounding\n   * sphere that is done at the end of buildDrawCommands\n   *\n   * @param {Model} model The model\n   * @param {ModelComponents.Node} runtimeNode The runtime node\n   * that the primitive is attached to\n   * @param {Matrix4} [result] The result\n   * @returns {Matrix4} The result\n   * @private\n   */\n  static _computePrimitivePositionTransform(model, runtimeNode, result) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"model\", model);\n    Check.defined(\"runtimeNode\", runtimeNode);\n    //>>includeEnd('debug');\n\n    if (!defined(result)) {\n      result = new Matrix4();\n    }\n\n    const modelSceneGraph = model.sceneGraph;\n\n    Matrix4.clone(Matrix4.IDENTITY, result);\n    Matrix4.multiply(result, model.modelMatrix, result);\n    Matrix4.multiply(result, modelSceneGraph.components.transform, result);\n    Matrix4.multiply(result, modelSceneGraph.axisCorrectionMatrix, result);\n    Matrix4.multiply(result, runtimeNode.computedTransform, result);\n    return result;\n  }\n\n  /**\n   * Returns the <code>\"POSITION\"</code> attribute from the given primitive.\n   *\n   * The <code>\"POSITION\"</code> attribute is required. If it is not\n   * defined for the given primitive, then a <code>DeveloperError</code>\n   * is thrown.\n   *\n   * @param {ModelComponents.Primitive} primitive The primitive\n   * @returns {ModelComponents.Attribute} The position attribute\n   * @throws {DeveloperError} If there is no position attribute\n   * @private\n   */\n  static _obtainPrimitivePositionAttribute(primitive) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"primitive\", primitive);\n    //>>includeEnd('debug');\n\n    const primitivePositionAttribute = ModelUtility.getAttributeBySemantic(\n      primitive,\n      \"POSITION\",\n    );\n    if (!defined(primitivePositionAttribute)) {\n      throw new DeveloperError(\n        \"The primitive does not have a POSITION attribute\",\n      );\n    }\n    return primitivePositionAttribute;\n  }\n\n  /**\n   * Returns the ellipsoid of the given imagery layer.\n   *\n   * This only exists to hide a train wreck\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @returns {Ellipsoid} The ellipsoid\n   * @private\n   */\n  static _getEllipsoid(imageryLayer) {\n    const ellipsoid =\n      imageryLayer.imageryProvider.tilingScheme.projection.ellipsoid;\n    return ellipsoid;\n  }\n}\n\nexport default ModelPrimitiveImagery;\n"],"mappings":";;;;;;;;AAAA,OAAOA,OAAO,MAAM,uBAAuB;AAC3C,OAAOC,cAAc,MAAM,8BAA8B;AACzD,OAAOC,OAAO,MAAM,uBAAuB;AAC3C,OAAOC,KAAK,MAAM,qBAAqB;AACvC,OAAOC,aAAa,MAAM,6BAA6B;AAEvD,OAAOC,YAAY,MAAM,oBAAoB;AAC7C,OAAOC,eAAe,MAAM,sBAAsB;AAClD,OAAOC,mBAAmB,MAAM,0BAA0B;AAC1D,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,eAAe,MAAM,sBAAsB;AAElD,OAAOC,MAAM,MAAM,0BAA0B;AAC7C,OAAOC,WAAW,MAAM,+BAA+B;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,qBAAqB,CAAC;EAC1B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,WAAWA,CAACC,KAAK,EAAEC,WAAW,EAAEC,gBAAgB,EAAE;IAChD;IACAb,KAAK,CAACH,OAAO,CAAC,OAAO,EAAEc,KAAK,CAAC;IAC7BX,KAAK,CAACH,OAAO,CAAC,aAAa,EAAEe,WAAW,CAAC;IACzCZ,KAAK,CAACH,OAAO,CAAC,kBAAkB,EAAEgB,gBAAgB,CAAC;IACnD;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,MAAM,GAAGH,KAAK;;IAEnB;AACJ;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACI,YAAY,GAAGH,WAAW;;IAE/B;AACJ;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACI,iBAAiB,GAAGH,gBAAgB;;IAEzC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACI,4BAA4B,GAAGC,SAAS;;IAE7C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,2BAA2B,GAAG,IAAIpB,OAAO,CAAC,CAAC;;IAEhD;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACqB,qCAAqC,GAAG,CAAC;;IAE9C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACC,uCAAuC,GAAGH,SAAS;;IAExD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACI,qBAAqB,GAAGJ,SAAS;;IAEtC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACK,kBAAkB,GAAGL,SAAS;;IAEnC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IAAI,CAACM,kBAAkB,GAAG,KAAK;EACjC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,wBAAwBA,CAACC,YAAY,EAAE;IACrC,MAAMf,KAAK,GAAG,IAAI,CAACG,MAAM;IACzB,MAAMa,aAAa,GAAGhB,KAAK,CAACgB,aAAa;IACzC,MAAMC,KAAK,GAAGD,aAAa,CAACE,OAAO,CAACH,YAAY,CAAC;IACjD,IAAIE,KAAK,KAAK,CAAC,CAAC,EAAE;MAChB,MAAM,IAAI9B,cAAc,CAAC,wCAAwC,CAAC;IACpE;IACA,MAAMgC,iBAAiB,GAAG,IAAI,CAACP,kBAAkB;IACjD,IAAI,CAAC1B,OAAO,CAACiC,iBAAiB,CAAC,EAAE;MAC/B,MAAM,IAAIhC,cAAc,CACtB,kDACF,CAAC;IACH;IACA,OAAOgC,iBAAiB,CAACF,KAAK,CAAC;EACjC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEG,MAAMA,CAACC,UAAU,EAAE;IACjB;IACAhC,KAAK,CAACH,OAAO,CAAC,YAAY,EAAEmC,UAAU,CAAC;IACvC;;IAEA;IACA;IACA,MAAMrB,KAAK,GAAG,IAAI,CAACG,MAAM;IACzB,MAAMmB,OAAO,GAAGtB,KAAK,CAACsB,OAAO;IAC7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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}