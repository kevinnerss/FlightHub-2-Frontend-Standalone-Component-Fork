{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-hex.js\";\nimport \"core-js/modules/esnext.uint8-array.to-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.to-hex.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport ModelUtility from \"./Model/ModelUtility.js\";\nimport GaussianSplatSorter from \"./GaussianSplatSorter.js\";\nimport GaussianSplatTextureGenerator from \"./GaussianSplatTextureGenerator.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport GaussianSplatRenderResources from \"./GaussianSplatRenderResources.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport ShaderDestination from \"../Renderer/ShaderDestination.js\";\nimport GaussianSplatVS from \"../Shaders/PrimitiveGaussianSplatVS.js\";\nimport GaussianSplatFS from \"../Shaders/PrimitiveGaussianSplatFS.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport GeometryAttribute from \"../Core/GeometryAttribute.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport clone from \"../Core/clone.js\";\nimport defined from \"../Core/defined.js\";\nimport VertexAttributeSemantic from \"./VertexAttributeSemantic.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport ModelComponents from \"./ModelComponents.js\";\nimport Axis from \"./Axis.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport SplitDirection from \"./SplitDirection.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nconst scratchMatrix4A = new Matrix4();\nconst scratchMatrix4B = new Matrix4();\nconst scratchMatrix4C = new Matrix4();\nconst scratchMatrix4D = new Matrix4();\nconst GaussianSplatSortingState = {\n  IDLE: 0,\n  WAITING: 1,\n  SORTING: 2,\n  SORTED: 3,\n  ERROR: 4\n};\nfunction createSphericalHarmonicsTexture(context, shData) {\n  const texture = new Texture({\n    context: context,\n    source: {\n      width: shData.width,\n      height: shData.height,\n      arrayBufferView: shData.data\n    },\n    preMultiplyAlpha: false,\n    skipColorSpaceConversion: true,\n    pixelFormat: PixelFormat.RG_INTEGER,\n    pixelDatatype: PixelDatatype.UNSIGNED_INT,\n    flipY: false,\n    sampler: Sampler.NEAREST\n  });\n  return texture;\n}\nfunction createGaussianSplatTexture(context, splatTextureData) {\n  return new Texture({\n    context: context,\n    source: {\n      width: splatTextureData.width,\n      height: splatTextureData.height,\n      arrayBufferView: splatTextureData.data\n    },\n    preMultiplyAlpha: false,\n    skipColorSpaceConversion: true,\n    pixelFormat: PixelFormat.RGBA_INTEGER,\n    pixelDatatype: PixelDatatype.UNSIGNED_INT,\n    flipY: false,\n    sampler: Sampler.NEAREST\n  });\n}\n\n/** A primitive that renders Gaussian splats.\n * <p>\n * This primitive is used to render Gaussian splats in a 3D Tileset.\n * It is designed to work with the KHR_gaussian_splatting and KHR_gaussian_splatting_compression_spz_2 extensions.\n * </p>\n * @alias GaussianSplatPrimitive\n * @constructor\n * @param {Object} options An object with the following properties:\n * @param {Cesium3DTileset} options.tileset The tileset that this primitive belongs to.\n * @param {boolean} [options.debugShowBoundingVolume=false] Whether to show the bounding volume of the primitive for debugging purposes.\n * @private\n */\n\nfunction GaussianSplatPrimitive(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  /**\n   * The positions of the Gaussian splats in the primitive.\n   * @type {undefined|Float32Array}\n   * @private\n   */\n  this._positions = undefined;\n  /**\n   * The rotations of the Gaussian splats in the primitive.\n   * @type {undefined|Float32Array}\n   * @private\n   */\n  this._rotations = undefined;\n  /**\n   * The scales of the Gaussian splats in the primitive.\n   * @type {undefined|Float32Array}\n   * @private\n   */\n  this._scales = undefined;\n  /**\n   * The colors of the Gaussian splats in the primitive.\n   * @type {undefined|Uint8Array}\n   * @private\n   */\n  this._colors = undefined;\n  /**\n   * The indexes of the Gaussian splats in the primitive.\n   * Used to index into the splat attribute texture in the vertex shader.\n   * @type {undefined|Uint32Array}\n   * @private\n   */\n  this._indexes = undefined;\n  /**\n   * The number of splats in the primitive.\n   * This is the total number of splats across all selected tiles.\n   * @type {number}\n   * @private\n   */\n  this._numSplats = 0;\n  /**\n   * Indicates whether or not the primitive needs a Gaussian splat texture.\n   * This is set to true when the primitive is first created or when the splat attributes change.\n   * @type {boolean}\n   * @private\n   */\n  this._needsGaussianSplatTexture = true;\n\n  /**\n   * The previous view matrix used to determine if the primitive needs to be updated.\n   * This is used to avoid unnecessary updates when the view matrix hasn't changed.\n   * @type {Matrix4}\n   * @private\n   */\n  this._prevViewMatrix = new Matrix4();\n\n  /**\n   * Indicates whether or not to show the bounding volume of the primitive for debugging purposes.\n   * This is used to visualize the bounding volume of the primitive in the scene.\n   * @type {boolean}\n   * @private\n   */\n  this._debugShowBoundingVolume = options.debugShowBoundingVolume ?? false;\n\n  /**\n   * The texture used to store the Gaussian splat attributes.\n   * This texture is created from the splat attributes (positions, scales, rotations, colors)\n   * and is used in the vertex shader to render the splats.\n   * @type {undefined|Texture}\n   * @private\n   * @see {@link GaussianSplatTextureGenerator}\n   */\n  this.gaussianSplatTexture = undefined;\n\n  /**\n   * The texture used to store the spherical harmonics coefficients for the Gaussian splats.\n   * @type {undefined|Texture}\n   * @private\n   */\n  this.sphericalHarmonicsTexture = undefined;\n\n  /**\n   * The last width of the Gaussian splat texture.\n   * This is used to track changes in the texture size and update the primitive accordingly.\n   * @type {number}\n   * @private\n   */\n  this._lastTextureWidth = 0;\n  /**\n   * The last height of the Gaussian splat texture.\n   * This is used to track changes in the texture size and update the primitive accordingly.\n   * @type {number}\n   * @private\n   */\n  this._lastTextureHeight = 0;\n  /**\n   * The vertex array used to render the Gaussian splats.\n   * This vertex array contains the attributes needed to render the splats, such as positions and indexes.\n   * @type {undefined|VertexArray}\n   * @private\n   */\n  this._vertexArray = undefined;\n  /**\n   * The length of the vertex array, used to track changes in the number of splats.\n   * This is used to determine if the vertex array needs to be rebuilt.\n   * @type {number}\n   * @private\n   */\n  this._vertexArrayLen = -1;\n  this._splitDirection = SplitDirection.NONE;\n\n  /**\n   * The dirty flag forces the primitive to render this frame.\n   * @type {boolean}\n   * @private\n   */\n  this._dirty = false;\n  this._tileset = options.tileset;\n  this._baseTilesetUpdate = this._tileset.update;\n  this._tileset.update = this._wrappedUpdate.bind(this);\n  this._tileset.tileLoad.addEventListener(this.onTileLoad, this);\n  this._tileset.tileVisible.addEventListener(this.onTileVisible, this);\n\n  /**\n   * Tracks current count of selected tiles.\n   * This is used to determine if the primitive needs to be rebuilt.\n   * @type {number}\n   * @private\n   */\n  this.selectedTileLength = 0;\n\n  /**\n   * Indicates whether or not the primitive is ready for use.\n   * @type {boolean}\n   * @private\n   */\n  this._ready = false;\n\n  /**\n   * Indicates whether or not the primitive has a Gaussian splat texture.\n   * @type {boolean}\n   * @private\n   */\n  this._hasGaussianSplatTexture = false;\n\n  /**\n   * Indicates whether or not the primitive is currently generating a Gaussian splat texture.\n   * @type {boolean}\n   * @private\n   */\n  this._gaussianSplatTexturePending = false;\n\n  /**\n   * The draw command used to render the Gaussian splats.\n   * @type {undefined|DrawCommand}\n   * @private\n   */\n  this._drawCommand = undefined;\n  /**\n   * The root transform of the tileset.\n   * This is used to transform the splats into world space.\n   * @type {undefined|Matrix4}\n   * @private\n   */\n  this._rootTransform = undefined;\n\n  /**\n   * The axis correction matrix to transform the splats from Y-up to Z-up.\n   * @type {Matrix4}\n   * @private\n   */\n  this._axisCorrectionMatrix = ModelUtility.getAxisCorrectionMatrix(Axis.Y, Axis.X, new Matrix4());\n\n  /**\n   * Indicates whether or not the primitive has been destroyed.\n   * @type {boolean}\n   * @private\n   */\n  this._isDestroyed = false;\n\n  /**\n   * The state of the Gaussian splat sorting process.\n   * This is used to track the progress of the sorting operation.\n   * @type {GaussianSplatSortingState}\n   * @private\n   */\n  this._sorterState = GaussianSplatSortingState.IDLE;\n  /**\n   * A promise that resolves when the Gaussian splat sorting operation is complete.\n   * This is used to track the progress of the sorting operation.\n   * @type {undefined|Promise}\n   * @private\n   */\n  this._sorterPromise = undefined;\n\n  /**\n   * An error that occurred during the Gaussian splat sorting operation.\n   * Thrown when state is ERROR.\n   * @type {undefined|Error}\n   * @private\n   */\n  this._sorterError = undefined;\n}\nObject.defineProperties(GaussianSplatPrimitive.prototype, {\n  /**\n   * Indicates whether the primitive is ready for use.\n   * @memberof GaussianSplatPrimitive.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n  /**\n   * The {@link SplitDirection} to apply to this point.\n   * @memberof GaussianSplatPrimitive.prototype\n   * @type {SplitDirection}\n   * @default {@link SplitDirection.NONE}\n   */\n  splitDirection: {\n    get: function () {\n      return this._splitDirection;\n    },\n    set: function (value) {\n      if (this._splitDirection !== value) {\n        this._splitDirection = value;\n        this._dirty = true;\n      }\n    }\n  }\n});\n\n/**\n * Since we aren't visible at the scene level, we need to wrap the tileset update\n * so we not only get called but ensure we update immediately after the tileset.\n * @param {FrameState} frameState\n * @private\n *\n */\nGaussianSplatPrimitive.prototype._wrappedUpdate = function (frameState) {\n  this._baseTilesetUpdate.call(this._tileset, frameState);\n  this.update(frameState);\n};\n\n/**\n * Destroys the primitive and releases its resources in a deterministic manner.\n * @private\n */\nGaussianSplatPrimitive.prototype.destroy = function () {\n  this._positions = undefined;\n  this._rotations = undefined;\n  this._scales = undefined;\n  this._colors = undefined;\n  this._indexes = undefined;\n  if (defined(this.gaussianSplatTexture)) {\n    this.gaussianSplatTexture.destroy();\n    this.gaussianSplatTexture = undefined;\n  }\n  const drawCommand = this._drawCommand;\n  if (defined(drawCommand)) {\n    drawCommand.shaderProgram = drawCommand.shaderProgram && drawCommand.shaderProgram.destroy();\n  }\n  if (defined(this._vertexArray)) {\n    this._vertexArray.destroy();\n    this._vertexArray = undefined;\n  }\n  this._tileset.update = this._baseTilesetUpdate.bind(this._tileset);\n  return destroyObject(this);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * @returns {boolean} Returns true if the primitive has been destroyed, otherwise false.\n * @private\n */\nGaussianSplatPrimitive.prototype.isDestroyed = function () {\n  return this._isDestroyed;\n};\n\n/**\n * Event callback for when a tile is loaded.\n * This method is called when a tile is loaded and the primitive needs to be updated.\n * It sets the dirty flag to true, indicating that the primitive needs to be rebuilt.\n * @param {Cesium3DTile} tile\n * @private\n */\nGaussianSplatPrimitive.prototype.onTileLoad = function (tile) {\n  this._dirty = true;\n};\n\n/**\n * Callback for visible tiles.\n * @param {Cesium3DTile} tile\n * @private\n */\nGaussianSplatPrimitive.prototype.onTileVisible = function (tile) {};\n\n/**\n * Transforms the tile's splat primitive attributes into world space.\n * <br /><br />\n * This method applies the computed transform of the tile and the tileset's bounding sphere\n * to the splat primitive's position, rotation, and scale attributes.\n * It modifies the attributes in place, transforming them from local space to world space.\n *\n * @param {Cesium3DTile} tile\n * @private\n */\nGaussianSplatPrimitive.transformTile = function (tile) {\n  const computedTransform = tile.computedTransform;\n  const gltfPrimitive = tile.content.gltfPrimitive;\n  const gaussianSplatPrimitive = tile.tileset.gaussianSplatPrimitive;\n  const computedModelMatrix = Matrix4.multiplyTransformation(computedTransform, gaussianSplatPrimitive._axisCorrectionMatrix, scratchMatrix4A);\n  Matrix4.multiplyTransformation(computedModelMatrix, tile.content.worldTransform, computedModelMatrix);\n  const toGlobal = Matrix4.multiply(tile.tileset.modelMatrix, Matrix4.fromArray(tile.tileset.root.transform), scratchMatrix4B);\n  const toLocal = Matrix4.inverse(toGlobal, scratchMatrix4C);\n  const transform = Matrix4.multiplyTransformation(toLocal, computedModelMatrix, scratchMatrix4A);\n  const positions = tile.content.positions;\n  const rotations = tile.content.rotations;\n  const scales = tile.content.scales;\n  const attributePositions = ModelUtility.getAttributeBySemantic(gltfPrimitive, VertexAttributeSemantic.POSITION).typedArray;\n  const attributeRotations = ModelUtility.getAttributeBySemantic(gltfPrimitive, VertexAttributeSemantic.ROTATION).typedArray;\n  const attributeScales = ModelUtility.getAttributeBySemantic(gltfPrimitive, VertexAttributeSemantic.SCALE).typedArray;\n  const position = new Cartesian3();\n  const rotation = new Quaternion();\n  const scale = new Cartesian3();\n  for (let i = 0; i < attributePositions.length / 3; ++i) {\n    position.x = attributePositions[i * 3];\n    position.y = attributePositions[i * 3 + 1];\n    position.z = attributePositions[i * 3 + 2];\n    rotation.x = attributeRotations[i * 4];\n    rotation.y = attributeRotations[i * 4 + 1];\n    rotation.z = attributeRotations[i * 4 + 2];\n    rotation.w = attributeRotations[i * 4 + 3];\n    scale.x = attributeScales[i * 3];\n    scale.y = attributeScales[i * 3 + 1];\n    scale.z = attributeScales[i * 3 + 2];\n    Matrix4.fromTranslationQuaternionRotationScale(position, rotation, scale, scratchMatrix4C);\n    Matrix4.multiplyTransformation(transform, scratchMatrix4C, scratchMatrix4C);\n    Matrix4.getTranslation(scratchMatrix4C, position);\n    Matrix4.getRotation(scratchMatrix4C, rotation);\n    Matrix4.getScale(scratchMatrix4C, scale);\n    positions[i * 3] = position.x;\n    positions[i * 3 + 1] = position.y;\n    positions[i * 3 + 2] = position.z;\n    rotations[i * 4] = rotation.x;\n    rotations[i * 4 + 1] = rotation.y;\n    rotations[i * 4 + 2] = rotation.z;\n    rotations[i * 4 + 3] = rotation.w;\n    scales[i * 3] = scale.x;\n    scales[i * 3 + 1] = scale.y;\n    scales[i * 3 + 2] = scale.z;\n  }\n};\n\n/**\n * Generates the Gaussian splat texture for the primitive.\n * This method creates a texture from the splat attributes (positions, scales, rotations, colors)\n * and updates the primitive's state accordingly.\n *\n * @see {@link GaussianSplatTextureGenerator}\n *\n * @param {GaussianSplatPrimitive} primitive\n * @param {FrameState} frameState\n * @private\n */\nGaussianSplatPrimitive.generateSplatTexture = function (primitive, frameState) {\n  primitive._gaussianSplatTexturePending = true;\n  const promise = GaussianSplatTextureGenerator.generateFromAttributes({\n    attributes: {\n      positions: new Float32Array(primitive._positions),\n      scales: new Float32Array(primitive._scales),\n      rotations: new Float32Array(primitive._rotations),\n      colors: new Uint8Array(primitive._colors)\n    },\n    count: primitive._numSplats\n  });\n  if (!defined(promise)) {\n    primitive._gaussianSplatTexturePending = false;\n    return;\n  }\n  promise.then(splatTextureData => {\n    if (!primitive._gaussianSplatTexture) {\n      // First frame, so create the texture.\n      primitive.gaussianSplatTexture = createGaussianSplatTexture(frameState.context, splatTextureData);\n    } else if (primitive._lastTextureHeight !== splatTextureData.height || primitive._lastTextureWidth !== splatTextureData.width) {\n      const oldTex = primitive.gaussianSplatTexture;\n      primitive._gaussianSplatTexture = createGaussianSplatTexture(frameState.context, splatTextureData);\n      oldTex.destroy();\n    } else {\n      primitive.gaussianSplatTexture.copyFrom({\n        source: {\n          width: splatTextureData.width,\n          height: splatTextureData.height,\n          arrayBufferView: splatTextureData.data\n        }\n      });\n    }\n    primitive._vertexArray = undefined;\n    primitive._lastTextureHeight = splatTextureData.height;\n    primitive._lastTextureWidth = splatTextureData.width;\n    primitive._hasGaussianSplatTexture = true;\n    primitive._needsGaussianSplatTexture = false;\n    primitive._gaussianSplatTexturePending = false;\n    if (!defined(primitive._indexes) || primitive._indexes.length < primitive._numSplats) {\n      primitive._indexes = new Uint32Array(primitive._numSplats);\n    }\n    for (let i = 0; i < primitive._numSplats; ++i) {\n      primitive._indexes[i] = i;\n    }\n  }).catch(error => {\n    console.error(\"Error generating Gaussian splat texture:\", error);\n    primitive._gaussianSplatTexturePending = false;\n  });\n};\n\n/**\n * Builds the draw command for the Gaussian splat primitive.\n * This method sets up the shader program, render state, and vertex array for rendering the Gaussian splats.\n * It also configures the attributes and uniforms required for rendering.\n *\n * @param {GaussianSplatPrimitive} primitive\n * @param {FrameState} frameState\n *\n * @private\n */\nGaussianSplatPrimitive.buildGSplatDrawCommand = function (primitive, frameState) {\n  const tileset = primitive._tileset;\n  const renderResources = new GaussianSplatRenderResources(primitive);\n  const {\n    shaderBuilder\n  } = renderResources;\n  const renderStateOptions = renderResources.renderStateOptions;\n  renderStateOptions.cull.enabled = false;\n  renderStateOptions.depthMask = false;\n  renderStateOptions.depthTest.enabled = true;\n  renderStateOptions.blending = BlendingState.PRE_MULTIPLIED_ALPHA_BLEND;\n  renderResources.alphaOptions.pass = Pass.GAUSSIAN_SPLATS;\n  shaderBuilder.addAttribute(\"vec2\", \"a_screenQuadPosition\");\n  shaderBuilder.addAttribute(\"float\", \"a_splatIndex\");\n  shaderBuilder.addVarying(\"vec4\", \"v_splatColor\");\n  shaderBuilder.addVarying(\"vec2\", \"v_vertPos\");\n  shaderBuilder.addUniform(\"float\", \"u_splitDirection\", ShaderDestination.VERTEX);\n  shaderBuilder.addVarying(\"float\", \"v_splitDirection\");\n  shaderBuilder.addUniform(\"highp usampler2D\", \"u_splatAttributeTexture\", ShaderDestination.VERTEX);\n  shaderBuilder.addUniform(\"float\", \"u_sphericalHarmonicsDegree\", ShaderDestination.VERTEX);\n  shaderBuilder.addUniform(\"float\", \"u_splatScale\", ShaderDestination.VERTEX);\n  shaderBuilder.addUniform(\"vec3\", \"u_cameraPositionWC\", ShaderDestination.VERTEX);\n  shaderBuilder.addUniform(\"mat3\", \"u_inverseModelRotation\", ShaderDestination.VERTEX);\n  const uniformMap = renderResources.uniformMap;\n  const textureCache = primitive.gaussianSplatTexture;\n  uniformMap.u_splatAttributeTexture = function () {\n    return textureCache;\n  };\n  if (primitive._sphericalHarmonicsDegree > 0) {\n    shaderBuilder.addDefine(\"HAS_SPHERICAL_HARMONICS\", \"1\", ShaderDestination.VERTEX);\n    shaderBuilder.addUniform(\"highp usampler2D\", \"u_sphericalHarmonicsTexture\", ShaderDestination.VERTEX);\n    uniformMap.u_sphericalHarmonicsTexture = function () {\n      return primitive.sphericalHarmonicsTexture;\n    };\n  }\n  uniformMap.u_sphericalHarmonicsDegree = function () {\n    return primitive._sphericalHarmonicsDegree;\n  };\n  uniformMap.u_cameraPositionWC = function () {\n    return Cartesian3.clone(frameState.camera.positionWC);\n  };\n  uniformMap.u_inverseModelRotation = function () {\n    const tileset = primitive._tileset;\n    const modelMatrix = Matrix4.multiply(tileset.modelMatrix, Matrix4.fromArray(tileset.root.transform), scratchMatrix4A);\n    const inverseModelRotation = Matrix4.getRotation(Matrix4.inverse(modelMatrix, scratchMatrix4C), scratchMatrix4D);\n    return inverseModelRotation;\n  };\n  uniformMap.u_splitDirection = function () {\n    return primitive.splitDirection;\n  };\n  renderResources.instanceCount = primitive._numSplats;\n  renderResources.count = 4;\n  renderResources.primitiveType = PrimitiveType.TRIANGLE_STRIP;\n  shaderBuilder.addVertexLines(GaussianSplatVS);\n  shaderBuilder.addFragmentLines(GaussianSplatFS);\n  const shaderProgram = shaderBuilder.buildShaderProgram(frameState.context);\n  let renderState = clone(RenderState.fromCache(renderResources.renderStateOptions), true);\n  renderState.cull.face = ModelUtility.getCullFace(tileset.modelMatrix, PrimitiveType.TRIANGLE_STRIP);\n  renderState = RenderState.fromCache(renderState);\n  const splatQuadAttrLocations = {\n    screenQuadPosition: 0,\n    splatIndex: 2\n  };\n  const idxAttr = new ModelComponents.Attribute();\n  idxAttr.name = \"_SPLAT_INDEXES\";\n  idxAttr.typedArray = primitive._indexes;\n  idxAttr.componentDatatype = ComponentDatatype.UNSIGNED_INT;\n  idxAttr.type = AttributeType.SCALAR;\n  idxAttr.normalized = false;\n  idxAttr.count = renderResources.instanceCount;\n  idxAttr.constant = 0;\n  idxAttr.instanceDivisor = 1;\n  if (!defined(primitive._vertexArray) || primitive._indexes.length > primitive._vertexArrayLen) {\n    const geometry = new Geometry({\n      attributes: {\n        screenQuadPosition: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.FLOAT,\n          componentsPerAttribute: 2,\n          values: [-1, -1, 1, -1, 1, 1, -1, 1],\n          name: \"_SCREEN_QUAD_POS\",\n          variableName: \"screenQuadPosition\"\n        }),\n        splatIndex: {\n          ...idxAttr,\n          variableName: \"splatIndex\"\n        }\n      },\n      primitiveType: PrimitiveType.TRIANGLE_STRIP\n    });\n    primitive._vertexArray = VertexArray.fromGeometry({\n      context: frameState.context,\n      geometry: geometry,\n      attributeLocations: splatQuadAttrLocations,\n      bufferUsage: BufferUsage.DYNAMIC_DRAW,\n      interleave: false\n    });\n  } else {\n    primitive._vertexArray.getAttribute(1).vertexBuffer.copyFromArrayView(primitive._indexes);\n  }\n  primitive._vertexArrayLen = primitive._indexes.length;\n  const modelMatrix = Matrix4.multiply(tileset.modelMatrix, Matrix4.fromArray(tileset.root.transform), scratchMatrix4B);\n  const vertexArrayCache = primitive._vertexArray;\n  const command = new DrawCommand({\n    boundingVolume: tileset.boundingSphere,\n    modelMatrix: modelMatrix,\n    uniformMap: uniformMap,\n    renderState: renderState,\n    vertexArray: vertexArrayCache,\n    shaderProgram: shaderProgram,\n    cull: renderStateOptions.cull.enabled,\n    pass: Pass.GAUSSIAN_SPLATS,\n    count: renderResources.count,\n    owner: this,\n    instanceCount: renderResources.instanceCount,\n    primitiveType: PrimitiveType.TRIANGLE_STRIP,\n    debugShowBoundingVolume: tileset.debugShowBoundingVolume,\n    castShadows: false,\n    receiveShadows: false\n  });\n  primitive._drawCommand = command;\n};\n\n/**\n * Updates the Gaussian splat primitive for the current frame.\n * This method checks if the primitive needs to be updated based on the current frame state,\n * and if so, it processes the selected tiles, aggregates their attributes,\n * and generates the Gaussian splat texture if necessary.\n * It also handles the sorting of splat indexes and builds the draw command for rendering.\n *\n * @param {FrameState} frameState\n * @private\n */\nGaussianSplatPrimitive.prototype.update = function (frameState) {\n  const tileset = this._tileset;\n  if (!defined(this._rootTransform)) {\n    this._rootTransform = tileset.root.computedTransform;\n  }\n  if (!tileset.show || tileset._selectedTiles.length === 0) {\n    return;\n  }\n  if (this._drawCommand) {\n    frameState.commandList.push(this._drawCommand);\n  }\n  if (tileset._modelMatrixChanged) {\n    this._dirty = true;\n    return;\n  }\n  if (frameState.passes.pick === true) {\n    return;\n  }\n  if (this.splitDirection !== tileset.splitDirection) {\n    this.splitDirection = tileset.splitDirection;\n  }\n  if (this._sorterState === GaussianSplatSortingState.IDLE) {\n    if (!this._dirty && Matrix4.equals(frameState.camera.viewMatrix, this._prevViewMatrix)) {\n      // No need to update if the view matrix hasn't changed and the primitive isn't dirty.\n      return;\n    }\n    if (tileset._selectedTiles.length !== 0 && tileset._selectedTiles.length !== this.selectedTileLength) {\n      this._numSplats = 0;\n      this._positions = undefined;\n      this._rotations = undefined;\n      this._scales = undefined;\n      this._colors = undefined;\n      this._indexes = undefined;\n      this._shData = undefined;\n      this._needsGaussianSplatTexture = true;\n      this._gaussianSplatTexturePending = false;\n      const tiles = tileset._selectedTiles;\n      const totalElements = tiles.reduce((total, tile) => total + tile.content.pointsLength, 0);\n      const aggregateAttributeValues = (componentDatatype, getAttributeCallback, numberOfComponents) => {\n        let aggregate;\n        let offset = 0;\n        for (const tile of tiles) {\n          const content = tile.content;\n          const attribute = getAttributeCallback(content);\n          const componentsPerAttribute = defined(numberOfComponents) ? numberOfComponents : AttributeType.getNumberOfComponents(attribute.type);\n          const buffer = defined(attribute.typedArray) ? attribute.typedArray : attribute;\n          if (!defined(aggregate)) {\n            aggregate = ComponentDatatype.createTypedArray(componentDatatype, totalElements * componentsPerAttribute);\n          }\n          aggregate.set(buffer, offset);\n          offset += buffer.length;\n        }\n        return aggregate;\n      };\n      const aggregateShData = () => {\n        let offset = 0;\n        for (const tile of tiles) {\n          const shData = tile.content.packedSphericalHarmonicsData;\n          if (tile.content.sphericalHarmonicsDegree > 0) {\n            if (!defined(this._shData)) {\n              let coefs;\n              switch (tile.content.sphericalHarmonicsDegree) {\n                case 1:\n                  coefs = 9;\n                  break;\n                case 2:\n                  coefs = 24;\n                  break;\n                case 3:\n                  coefs = 45;\n              }\n              this._shData = new Uint32Array(totalElements * (coefs * (2 / 3)));\n            }\n            this._shData.set(shData, offset);\n            offset += shData.length;\n          }\n        }\n      };\n      this._positions = aggregateAttributeValues(ComponentDatatype.FLOAT, content => content.positions, 3);\n      this._scales = aggregateAttributeValues(ComponentDatatype.FLOAT, content => content.scales, 3);\n      this._rotations = aggregateAttributeValues(ComponentDatatype.FLOAT, content => content.rotations, 4);\n      this._colors = aggregateAttributeValues(ComponentDatatype.UNSIGNED_BYTE, content => ModelUtility.getAttributeBySemantic(content.gltfPrimitive, VertexAttributeSemantic.COLOR));\n      aggregateShData();\n      this._sphericalHarmonicsDegree = tiles[0].content.sphericalHarmonicsDegree;\n      this._numSplats = totalElements;\n      this.selectedTileLength = tileset._selectedTiles.length;\n    }\n    if (this._numSplats === 0) {\n      return;\n    }\n    if (this._needsGaussianSplatTexture) {\n      if (!this._gaussianSplatTexturePending) {\n        GaussianSplatPrimitive.generateSplatTexture(this, frameState);\n        if (defined(this._shData)) {\n          const oldTex = this.sphericalHarmonicsTexture;\n          const width = ContextLimits.maximumTextureSize;\n          const dims = tileset._selectedTiles[0].content.sphericalHarmonicsCoefficientCount / 3;\n          const splatsPerRow = Math.floor(width / dims);\n          const floatsPerRow = splatsPerRow * (dims * 2);\n          const texBuf = new Uint32Array(width * Math.ceil(this._numSplats / splatsPerRow) * 2);\n          let dataIndex = 0;\n          for (let i = 0; dataIndex < this._shData.length; i += width * 2) {\n            texBuf.set(this._shData.subarray(dataIndex, dataIndex + floatsPerRow), i);\n            dataIndex += floatsPerRow;\n          }\n          this.sphericalHarmonicsTexture = createSphericalHarmonicsTexture(frameState.context, {\n            data: texBuf,\n            width: width,\n            height: Math.ceil(this._numSplats / splatsPerRow)\n          });\n          if (defined(oldTex)) {\n            oldTex.destroy();\n          }\n        }\n      }\n      return;\n    }\n    Matrix4.clone(frameState.camera.viewMatrix, this._prevViewMatrix);\n    Matrix4.multiply(frameState.camera.viewMatrix, this._rootTransform, scratchMatrix4A);\n    if (!defined(this._sorterPromise)) {\n      this._sorterPromise = GaussianSplatSorter.radixSortIndexes({\n        primitive: {\n          positions: new Float32Array(this._positions),\n          modelView: Float32Array.from(scratchMatrix4A),\n          count: this._numSplats\n        },\n        sortType: \"Index\"\n      });\n    }\n    if (!defined(this._sorterPromise)) {\n      this._sorterState = GaussianSplatSortingState.WAITING;\n      return;\n    }\n    this._sorterPromise.catch(err => {\n      this._sorterState = GaussianSplatSortingState.ERROR;\n      this._sorterError = err;\n    });\n    this._sorterPromise.then(sortedData => {\n      this._indexes = sortedData;\n      this._sorterState = GaussianSplatSortingState.SORTED;\n    });\n  } else if (this._sorterState === GaussianSplatSortingState.WAITING) {\n    if (!defined(this._sorterPromise)) {\n      this._sorterPromise = GaussianSplatSorter.radixSortIndexes({\n        primitive: {\n          positions: new Float32Array(this._positions),\n          modelView: Float32Array.from(scratchMatrix4A),\n          count: this._numSplats\n        },\n        sortType: \"Index\"\n      });\n    }\n    if (!defined(this._sorterPromise)) {\n      this._sorterState = GaussianSplatSortingState.WAITING;\n      return;\n    }\n    this._sorterPromise.catch(err => {\n      this._sorterState = GaussianSplatSortingState.ERROR;\n      this._sorterError = err;\n    });\n    this._sorterPromise.then(sortedData => {\n      this._indexes = sortedData;\n      this._sorterState = GaussianSplatSortingState.SORTED;\n    });\n    this._sorterState = GaussianSplatSortingState.SORTING; //set state to sorting\n  } else if (this._sorterState === GaussianSplatSortingState.SORTING) {\n    return; //still sorting, wait for next frame\n  } else if (this._sorterState === GaussianSplatSortingState.SORTED) {\n    //update the draw command if sorted\n    GaussianSplatPrimitive.buildGSplatDrawCommand(this, frameState);\n    this._sorterState = GaussianSplatSortingState.IDLE; //reset state for next frame\n    this._dirty = false;\n    this._sorterPromise = undefined; //reset promise for next frame\n  } else if (this._sorterState === GaussianSplatSortingState.ERROR) {\n    throw this._sorterError;\n  }\n  this._dirty = false;\n};\nexport default GaussianSplatPrimitive;","map":{"version":3,"names":["Frozen","Matrix4","ModelUtility","GaussianSplatSorter","GaussianSplatTextureGenerator","ComponentDatatype","PixelDatatype","PixelFormat","Sampler","Texture","GaussianSplatRenderResources","BlendingState","Pass","ShaderDestination","GaussianSplatVS","GaussianSplatFS","PrimitiveType","DrawCommand","Geometry","GeometryAttribute","VertexArray","BufferUsage","RenderState","clone","defined","VertexAttributeSemantic","AttributeType","ModelComponents","Axis","Cartesian3","Quaternion","SplitDirection","destroyObject","ContextLimits","scratchMatrix4A","scratchMatrix4B","scratchMatrix4C","scratchMatrix4D","GaussianSplatSortingState","IDLE","WAITING","SORTING","SORTED","ERROR","createSphericalHarmonicsTexture","context","shData","texture","source","width","height","arrayBufferView","data","preMultiplyAlpha","skipColorSpaceConversion","pixelFormat","RG_INTEGER","pixelDatatype","UNSIGNED_INT","flipY","sampler","NEAREST","createGaussianSplatTexture","splatTextureData","RGBA_INTEGER","GaussianSplatPrimitive","options","EMPTY_OBJECT","_positions","undefined","_rotations","_scales","_colors","_indexes","_numSplats","_needsGaussianSplatTexture","_prevViewMatrix","_debugShowBoundingVolume","debugShowBoundingVolume","gaussianSplatTexture","sphericalHarmonicsTexture","_lastTextureWidth","_lastTextureHeight","_vertexArray","_vertexArrayLen","_splitDirection","NONE","_dirty","_tileset","tileset","_baseTilesetUpdate","update","_wrappedUpdate","bind","tileLoad","addEventListener","onTileLoad","tileVisible","onTileVisible","selectedTileLength","_ready","_hasGaussianSplatTexture","_gaussianSplatTexturePending","_drawCommand","_rootTransform","_axisCorrectionMatrix","getAxisCorrectionMatrix","Y","X","_isDestroyed","_sorterState","_sorterPromise","_sorterError","Object","defineProperties","prototype","ready","get","splitDirection","set","value","frameState","call","destroy","drawCommand","shaderProgram","isDestroyed","tile","transformTile","computedTransform","gltfPrimitive","content","gaussianSplatPrimitive","computedModelMatrix","multiplyTransformation","worldTransform","toGlobal","multiply","modelMatrix","fromArray","root","transform","toLocal","inverse","positions","rotations","scales","attributePositions","getAttributeBySemantic","POSITION","typedArray","attributeRotations","ROTATION","attributeScales","SCALE","position","rotation","scale","i","length","x","y","z","w","fromTranslationQuaternionRotationScale","getTranslation","getRotation","getScale","generateSplatTexture","primitive","promise","generateFromAttributes","attributes","Float32Array","colors","Uint8Array","count","then","_gaussianSplatTexture","oldTex","copyFrom","Uint32Array","catch","error","console","buildGSplatDrawCommand","renderResources","shaderBuilder","renderStateOptions","cull","enabled","depthMask","depthTest","blending","PRE_MULTIPLIED_ALPHA_BLEND","alphaOptions","pass","GAUSSIAN_SPLATS","addAttribute","addVarying","addUniform","VERTEX","uniformMap","textureCache","u_splatAttributeTexture","_sphericalHarmonicsDegree","addDefine","u_sphericalHarmonicsTexture","u_sphericalHarmonicsDegree","u_cameraPositionWC","camera","positionWC","u_inverseModelRotation","inverseModelRotation","u_splitDirection","instanceCount","primitiveType","TRIANGLE_STRIP","addVertexLines","addFragmentLines","buildShaderProgram","renderState","fromCache","face","getCullFace","splatQuadAttrLocations","screenQuadPosition","splatIndex","idxAttr","Attribute","name","componentDatatype","type","SCALAR","normalized","constant","instanceDivisor","geometry","FLOAT","componentsPerAttribute","values","variableName","fromGeometry","attributeLocations","bufferUsage","DYNAMIC_DRAW","interleave","getAttribute","vertexBuffer","copyFromArrayView","vertexArrayCache","command","boundingVolume","boundingSphere","vertexArray","owner","castShadows","receiveShadows","show","_selectedTiles","commandList","push","_modelMatrixChanged","passes","pick","equals","viewMatrix","_shData","tiles","totalElements","reduce","total","pointsLength","aggregateAttributeValues","getAttributeCallback","numberOfComponents","aggregate","offset","attribute","getNumberOfComponents","buffer","createTypedArray","aggregateShData","packedSphericalHarmonicsData","sphericalHarmonicsDegree","coefs","UNSIGNED_BYTE","COLOR","maximumTextureSize","dims","sphericalHarmonicsCoefficientCount","splatsPerRow","Math","floor","floatsPerRow","texBuf","ceil","dataIndex","subarray","radixSortIndexes","modelView","from","sortType","err","sortedData"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/GaussianSplatPrimitive.js"],"sourcesContent":["import Frozen from \"../Core/Frozen.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport ModelUtility from \"./Model/ModelUtility.js\";\nimport GaussianSplatSorter from \"./GaussianSplatSorter.js\";\nimport GaussianSplatTextureGenerator from \"./GaussianSplatTextureGenerator.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport GaussianSplatRenderResources from \"./GaussianSplatRenderResources.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport ShaderDestination from \"../Renderer/ShaderDestination.js\";\nimport GaussianSplatVS from \"../Shaders/PrimitiveGaussianSplatVS.js\";\nimport GaussianSplatFS from \"../Shaders/PrimitiveGaussianSplatFS.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport GeometryAttribute from \"../Core/GeometryAttribute.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport clone from \"../Core/clone.js\";\nimport defined from \"../Core/defined.js\";\nimport VertexAttributeSemantic from \"./VertexAttributeSemantic.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport ModelComponents from \"./ModelComponents.js\";\nimport Axis from \"./Axis.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport SplitDirection from \"./SplitDirection.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\n\nconst scratchMatrix4A = new Matrix4();\nconst scratchMatrix4B = new Matrix4();\nconst scratchMatrix4C = new Matrix4();\nconst scratchMatrix4D = new Matrix4();\n\nconst GaussianSplatSortingState = {\n  IDLE: 0,\n  WAITING: 1,\n  SORTING: 2,\n  SORTED: 3,\n  ERROR: 4,\n};\n\nfunction createSphericalHarmonicsTexture(context, shData) {\n  const texture = new Texture({\n    context: context,\n    source: {\n      width: shData.width,\n      height: shData.height,\n      arrayBufferView: shData.data,\n    },\n    preMultiplyAlpha: false,\n    skipColorSpaceConversion: true,\n    pixelFormat: PixelFormat.RG_INTEGER,\n    pixelDatatype: PixelDatatype.UNSIGNED_INT,\n    flipY: false,\n    sampler: Sampler.NEAREST,\n  });\n\n  return texture;\n}\n\nfunction createGaussianSplatTexture(context, splatTextureData) {\n  return new Texture({\n    context: context,\n    source: {\n      width: splatTextureData.width,\n      height: splatTextureData.height,\n      arrayBufferView: splatTextureData.data,\n    },\n    preMultiplyAlpha: false,\n    skipColorSpaceConversion: true,\n    pixelFormat: PixelFormat.RGBA_INTEGER,\n    pixelDatatype: PixelDatatype.UNSIGNED_INT,\n    flipY: false,\n    sampler: Sampler.NEAREST,\n  });\n}\n\n/** A primitive that renders Gaussian splats.\n * <p>\n * This primitive is used to render Gaussian splats in a 3D Tileset.\n * It is designed to work with the KHR_gaussian_splatting and KHR_gaussian_splatting_compression_spz_2 extensions.\n * </p>\n * @alias GaussianSplatPrimitive\n * @constructor\n * @param {Object} options An object with the following properties:\n * @param {Cesium3DTileset} options.tileset The tileset that this primitive belongs to.\n * @param {boolean} [options.debugShowBoundingVolume=false] Whether to show the bounding volume of the primitive for debugging purposes.\n * @private\n */\n\nfunction GaussianSplatPrimitive(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  /**\n   * The positions of the Gaussian splats in the primitive.\n   * @type {undefined|Float32Array}\n   * @private\n   */\n  this._positions = undefined;\n  /**\n   * The rotations of the Gaussian splats in the primitive.\n   * @type {undefined|Float32Array}\n   * @private\n   */\n  this._rotations = undefined;\n  /**\n   * The scales of the Gaussian splats in the primitive.\n   * @type {undefined|Float32Array}\n   * @private\n   */\n  this._scales = undefined;\n  /**\n   * The colors of the Gaussian splats in the primitive.\n   * @type {undefined|Uint8Array}\n   * @private\n   */\n  this._colors = undefined;\n  /**\n   * The indexes of the Gaussian splats in the primitive.\n   * Used to index into the splat attribute texture in the vertex shader.\n   * @type {undefined|Uint32Array}\n   * @private\n   */\n  this._indexes = undefined;\n  /**\n   * The number of splats in the primitive.\n   * This is the total number of splats across all selected tiles.\n   * @type {number}\n   * @private\n   */\n  this._numSplats = 0;\n  /**\n   * Indicates whether or not the primitive needs a Gaussian splat texture.\n   * This is set to true when the primitive is first created or when the splat attributes change.\n   * @type {boolean}\n   * @private\n   */\n  this._needsGaussianSplatTexture = true;\n\n  /**\n   * The previous view matrix used to determine if the primitive needs to be updated.\n   * This is used to avoid unnecessary updates when the view matrix hasn't changed.\n   * @type {Matrix4}\n   * @private\n   */\n  this._prevViewMatrix = new Matrix4();\n\n  /**\n   * Indicates whether or not to show the bounding volume of the primitive for debugging purposes.\n   * This is used to visualize the bounding volume of the primitive in the scene.\n   * @type {boolean}\n   * @private\n   */\n  this._debugShowBoundingVolume = options.debugShowBoundingVolume ?? false;\n\n  /**\n   * The texture used to store the Gaussian splat attributes.\n   * This texture is created from the splat attributes (positions, scales, rotations, colors)\n   * and is used in the vertex shader to render the splats.\n   * @type {undefined|Texture}\n   * @private\n   * @see {@link GaussianSplatTextureGenerator}\n   */\n  this.gaussianSplatTexture = undefined;\n\n  /**\n   * The texture used to store the spherical harmonics coefficients for the Gaussian splats.\n   * @type {undefined|Texture}\n   * @private\n   */\n  this.sphericalHarmonicsTexture = undefined;\n\n  /**\n   * The last width of the Gaussian splat texture.\n   * This is used to track changes in the texture size and update the primitive accordingly.\n   * @type {number}\n   * @private\n   */\n  this._lastTextureWidth = 0;\n  /**\n   * The last height of the Gaussian splat texture.\n   * This is used to track changes in the texture size and update the primitive accordingly.\n   * @type {number}\n   * @private\n   */\n  this._lastTextureHeight = 0;\n  /**\n   * The vertex array used to render the Gaussian splats.\n   * This vertex array contains the attributes needed to render the splats, such as positions and indexes.\n   * @type {undefined|VertexArray}\n   * @private\n   */\n  this._vertexArray = undefined;\n  /**\n   * The length of the vertex array, used to track changes in the number of splats.\n   * This is used to determine if the vertex array needs to be rebuilt.\n   * @type {number}\n   * @private\n   */\n  this._vertexArrayLen = -1;\n  this._splitDirection = SplitDirection.NONE;\n\n  /**\n   * The dirty flag forces the primitive to render this frame.\n   * @type {boolean}\n   * @private\n   */\n  this._dirty = false;\n\n  this._tileset = options.tileset;\n\n  this._baseTilesetUpdate = this._tileset.update;\n  this._tileset.update = this._wrappedUpdate.bind(this);\n\n  this._tileset.tileLoad.addEventListener(this.onTileLoad, this);\n  this._tileset.tileVisible.addEventListener(this.onTileVisible, this);\n\n  /**\n   * Tracks current count of selected tiles.\n   * This is used to determine if the primitive needs to be rebuilt.\n   * @type {number}\n   * @private\n   */\n  this.selectedTileLength = 0;\n\n  /**\n   * Indicates whether or not the primitive is ready for use.\n   * @type {boolean}\n   * @private\n   */\n  this._ready = false;\n\n  /**\n   * Indicates whether or not the primitive has a Gaussian splat texture.\n   * @type {boolean}\n   * @private\n   */\n  this._hasGaussianSplatTexture = false;\n\n  /**\n   * Indicates whether or not the primitive is currently generating a Gaussian splat texture.\n   * @type {boolean}\n   * @private\n   */\n  this._gaussianSplatTexturePending = false;\n\n  /**\n   * The draw command used to render the Gaussian splats.\n   * @type {undefined|DrawCommand}\n   * @private\n   */\n  this._drawCommand = undefined;\n  /**\n   * The root transform of the tileset.\n   * This is used to transform the splats into world space.\n   * @type {undefined|Matrix4}\n   * @private\n   */\n  this._rootTransform = undefined;\n\n  /**\n   * The axis correction matrix to transform the splats from Y-up to Z-up.\n   * @type {Matrix4}\n   * @private\n   */\n  this._axisCorrectionMatrix = ModelUtility.getAxisCorrectionMatrix(\n    Axis.Y,\n    Axis.X,\n    new Matrix4(),\n  );\n\n  /**\n   * Indicates whether or not the primitive has been destroyed.\n   * @type {boolean}\n   * @private\n   */\n  this._isDestroyed = false;\n\n  /**\n   * The state of the Gaussian splat sorting process.\n   * This is used to track the progress of the sorting operation.\n   * @type {GaussianSplatSortingState}\n   * @private\n   */\n  this._sorterState = GaussianSplatSortingState.IDLE;\n  /**\n   * A promise that resolves when the Gaussian splat sorting operation is complete.\n   * This is used to track the progress of the sorting operation.\n   * @type {undefined|Promise}\n   * @private\n   */\n  this._sorterPromise = undefined;\n\n  /**\n   * An error that occurred during the Gaussian splat sorting operation.\n   * Thrown when state is ERROR.\n   * @type {undefined|Error}\n   * @private\n   */\n  this._sorterError = undefined;\n}\n\nObject.defineProperties(GaussianSplatPrimitive.prototype, {\n  /**\n   * Indicates whether the primitive is ready for use.\n   * @memberof GaussianSplatPrimitive.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * The {@link SplitDirection} to apply to this point.\n   * @memberof GaussianSplatPrimitive.prototype\n   * @type {SplitDirection}\n   * @default {@link SplitDirection.NONE}\n   */\n  splitDirection: {\n    get: function () {\n      return this._splitDirection;\n    },\n    set: function (value) {\n      if (this._splitDirection !== value) {\n        this._splitDirection = value;\n        this._dirty = true;\n      }\n    },\n  },\n});\n\n/**\n * Since we aren't visible at the scene level, we need to wrap the tileset update\n * so we not only get called but ensure we update immediately after the tileset.\n * @param {FrameState} frameState\n * @private\n *\n */\nGaussianSplatPrimitive.prototype._wrappedUpdate = function (frameState) {\n  this._baseTilesetUpdate.call(this._tileset, frameState);\n  this.update(frameState);\n};\n\n/**\n * Destroys the primitive and releases its resources in a deterministic manner.\n * @private\n */\nGaussianSplatPrimitive.prototype.destroy = function () {\n  this._positions = undefined;\n  this._rotations = undefined;\n  this._scales = undefined;\n  this._colors = undefined;\n  this._indexes = undefined;\n  if (defined(this.gaussianSplatTexture)) {\n    this.gaussianSplatTexture.destroy();\n    this.gaussianSplatTexture = undefined;\n  }\n\n  const drawCommand = this._drawCommand;\n  if (defined(drawCommand)) {\n    drawCommand.shaderProgram =\n      drawCommand.shaderProgram && drawCommand.shaderProgram.destroy();\n  }\n\n  if (defined(this._vertexArray)) {\n    this._vertexArray.destroy();\n    this._vertexArray = undefined;\n  }\n\n  this._tileset.update = this._baseTilesetUpdate.bind(this._tileset);\n\n  return destroyObject(this);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * @returns {boolean} Returns true if the primitive has been destroyed, otherwise false.\n * @private\n */\nGaussianSplatPrimitive.prototype.isDestroyed = function () {\n  return this._isDestroyed;\n};\n\n/**\n * Event callback for when a tile is loaded.\n * This method is called when a tile is loaded and the primitive needs to be updated.\n * It sets the dirty flag to true, indicating that the primitive needs to be rebuilt.\n * @param {Cesium3DTile} tile\n * @private\n */\nGaussianSplatPrimitive.prototype.onTileLoad = function (tile) {\n  this._dirty = true;\n};\n\n/**\n * Callback for visible tiles.\n * @param {Cesium3DTile} tile\n * @private\n */\nGaussianSplatPrimitive.prototype.onTileVisible = function (tile) {};\n\n/**\n * Transforms the tile's splat primitive attributes into world space.\n * <br /><br />\n * This method applies the computed transform of the tile and the tileset's bounding sphere\n * to the splat primitive's position, rotation, and scale attributes.\n * It modifies the attributes in place, transforming them from local space to world space.\n *\n * @param {Cesium3DTile} tile\n * @private\n */\nGaussianSplatPrimitive.transformTile = function (tile) {\n  const computedTransform = tile.computedTransform;\n  const gltfPrimitive = tile.content.gltfPrimitive;\n  const gaussianSplatPrimitive = tile.tileset.gaussianSplatPrimitive;\n\n  const computedModelMatrix = Matrix4.multiplyTransformation(\n    computedTransform,\n    gaussianSplatPrimitive._axisCorrectionMatrix,\n    scratchMatrix4A,\n  );\n\n  Matrix4.multiplyTransformation(\n    computedModelMatrix,\n    tile.content.worldTransform,\n    computedModelMatrix,\n  );\n\n  const toGlobal = Matrix4.multiply(\n    tile.tileset.modelMatrix,\n    Matrix4.fromArray(tile.tileset.root.transform),\n    scratchMatrix4B,\n  );\n  const toLocal = Matrix4.inverse(toGlobal, scratchMatrix4C);\n  const transform = Matrix4.multiplyTransformation(\n    toLocal,\n    computedModelMatrix,\n    scratchMatrix4A,\n  );\n  const positions = tile.content.positions;\n  const rotations = tile.content.rotations;\n  const scales = tile.content.scales;\n  const attributePositions = ModelUtility.getAttributeBySemantic(\n    gltfPrimitive,\n    VertexAttributeSemantic.POSITION,\n  ).typedArray;\n\n  const attributeRotations = ModelUtility.getAttributeBySemantic(\n    gltfPrimitive,\n    VertexAttributeSemantic.ROTATION,\n  ).typedArray;\n\n  const attributeScales = ModelUtility.getAttributeBySemantic(\n    gltfPrimitive,\n    VertexAttributeSemantic.SCALE,\n  ).typedArray;\n\n  const position = new Cartesian3();\n  const rotation = new Quaternion();\n  const scale = new Cartesian3();\n  for (let i = 0; i < attributePositions.length / 3; ++i) {\n    position.x = attributePositions[i * 3];\n    position.y = attributePositions[i * 3 + 1];\n    position.z = attributePositions[i * 3 + 2];\n\n    rotation.x = attributeRotations[i * 4];\n    rotation.y = attributeRotations[i * 4 + 1];\n    rotation.z = attributeRotations[i * 4 + 2];\n    rotation.w = attributeRotations[i * 4 + 3];\n\n    scale.x = attributeScales[i * 3];\n    scale.y = attributeScales[i * 3 + 1];\n    scale.z = attributeScales[i * 3 + 2];\n\n    Matrix4.fromTranslationQuaternionRotationScale(\n      position,\n      rotation,\n      scale,\n      scratchMatrix4C,\n    );\n\n    Matrix4.multiplyTransformation(transform, scratchMatrix4C, scratchMatrix4C);\n\n    Matrix4.getTranslation(scratchMatrix4C, position);\n    Matrix4.getRotation(scratchMatrix4C, rotation);\n    Matrix4.getScale(scratchMatrix4C, scale);\n\n    positions[i * 3] = position.x;\n    positions[i * 3 + 1] = position.y;\n    positions[i * 3 + 2] = position.z;\n\n    rotations[i * 4] = rotation.x;\n    rotations[i * 4 + 1] = rotation.y;\n    rotations[i * 4 + 2] = rotation.z;\n    rotations[i * 4 + 3] = rotation.w;\n\n    scales[i * 3] = scale.x;\n    scales[i * 3 + 1] = scale.y;\n    scales[i * 3 + 2] = scale.z;\n  }\n};\n\n/**\n * Generates the Gaussian splat texture for the primitive.\n * This method creates a texture from the splat attributes (positions, scales, rotations, colors)\n * and updates the primitive's state accordingly.\n *\n * @see {@link GaussianSplatTextureGenerator}\n *\n * @param {GaussianSplatPrimitive} primitive\n * @param {FrameState} frameState\n * @private\n */\nGaussianSplatPrimitive.generateSplatTexture = function (primitive, frameState) {\n  primitive._gaussianSplatTexturePending = true;\n  const promise = GaussianSplatTextureGenerator.generateFromAttributes({\n    attributes: {\n      positions: new Float32Array(primitive._positions),\n      scales: new Float32Array(primitive._scales),\n      rotations: new Float32Array(primitive._rotations),\n      colors: new Uint8Array(primitive._colors),\n    },\n    count: primitive._numSplats,\n  });\n  if (!defined(promise)) {\n    primitive._gaussianSplatTexturePending = false;\n    return;\n  }\n  promise\n    .then((splatTextureData) => {\n      if (!primitive._gaussianSplatTexture) {\n        // First frame, so create the texture.\n        primitive.gaussianSplatTexture = createGaussianSplatTexture(\n          frameState.context,\n          splatTextureData,\n        );\n      } else if (\n        primitive._lastTextureHeight !== splatTextureData.height ||\n        primitive._lastTextureWidth !== splatTextureData.width\n      ) {\n        const oldTex = primitive.gaussianSplatTexture;\n        primitive._gaussianSplatTexture = createGaussianSplatTexture(\n          frameState.context,\n          splatTextureData,\n        );\n        oldTex.destroy();\n      } else {\n        primitive.gaussianSplatTexture.copyFrom({\n          source: {\n            width: splatTextureData.width,\n            height: splatTextureData.height,\n            arrayBufferView: splatTextureData.data,\n          },\n        });\n      }\n      primitive._vertexArray = undefined;\n      primitive._lastTextureHeight = splatTextureData.height;\n      primitive._lastTextureWidth = splatTextureData.width;\n\n      primitive._hasGaussianSplatTexture = true;\n      primitive._needsGaussianSplatTexture = false;\n      primitive._gaussianSplatTexturePending = false;\n\n      if (\n        !defined(primitive._indexes) ||\n        primitive._indexes.length < primitive._numSplats\n      ) {\n        primitive._indexes = new Uint32Array(primitive._numSplats);\n      }\n      for (let i = 0; i < primitive._numSplats; ++i) {\n        primitive._indexes[i] = i;\n      }\n    })\n    .catch((error) => {\n      console.error(\"Error generating Gaussian splat texture:\", error);\n      primitive._gaussianSplatTexturePending = false;\n    });\n};\n\n/**\n * Builds the draw command for the Gaussian splat primitive.\n * This method sets up the shader program, render state, and vertex array for rendering the Gaussian splats.\n * It also configures the attributes and uniforms required for rendering.\n *\n * @param {GaussianSplatPrimitive} primitive\n * @param {FrameState} frameState\n *\n * @private\n */\nGaussianSplatPrimitive.buildGSplatDrawCommand = function (\n  primitive,\n  frameState,\n) {\n  const tileset = primitive._tileset;\n  const renderResources = new GaussianSplatRenderResources(primitive);\n  const { shaderBuilder } = renderResources;\n  const renderStateOptions = renderResources.renderStateOptions;\n  renderStateOptions.cull.enabled = false;\n  renderStateOptions.depthMask = false;\n  renderStateOptions.depthTest.enabled = true;\n  renderStateOptions.blending = BlendingState.PRE_MULTIPLIED_ALPHA_BLEND;\n  renderResources.alphaOptions.pass = Pass.GAUSSIAN_SPLATS;\n\n  shaderBuilder.addAttribute(\"vec2\", \"a_screenQuadPosition\");\n  shaderBuilder.addAttribute(\"float\", \"a_splatIndex\");\n  shaderBuilder.addVarying(\"vec4\", \"v_splatColor\");\n  shaderBuilder.addVarying(\"vec2\", \"v_vertPos\");\n  shaderBuilder.addUniform(\n    \"float\",\n    \"u_splitDirection\",\n    ShaderDestination.VERTEX,\n  );\n  shaderBuilder.addVarying(\"float\", \"v_splitDirection\");\n  shaderBuilder.addUniform(\n    \"highp usampler2D\",\n    \"u_splatAttributeTexture\",\n    ShaderDestination.VERTEX,\n  );\n\n  shaderBuilder.addUniform(\n    \"float\",\n    \"u_sphericalHarmonicsDegree\",\n    ShaderDestination.VERTEX,\n  );\n\n  shaderBuilder.addUniform(\"float\", \"u_splatScale\", ShaderDestination.VERTEX);\n\n  shaderBuilder.addUniform(\n    \"vec3\",\n    \"u_cameraPositionWC\",\n    ShaderDestination.VERTEX,\n  );\n\n  shaderBuilder.addUniform(\n    \"mat3\",\n    \"u_inverseModelRotation\",\n    ShaderDestination.VERTEX,\n  );\n\n  const uniformMap = renderResources.uniformMap;\n\n  const textureCache = primitive.gaussianSplatTexture;\n  uniformMap.u_splatAttributeTexture = function () {\n    return textureCache;\n  };\n\n  if (primitive._sphericalHarmonicsDegree > 0) {\n    shaderBuilder.addDefine(\n      \"HAS_SPHERICAL_HARMONICS\",\n      \"1\",\n      ShaderDestination.VERTEX,\n    );\n    shaderBuilder.addUniform(\n      \"highp usampler2D\",\n      \"u_sphericalHarmonicsTexture\",\n      ShaderDestination.VERTEX,\n    );\n    uniformMap.u_sphericalHarmonicsTexture = function () {\n      return primitive.sphericalHarmonicsTexture;\n    };\n  }\n  uniformMap.u_sphericalHarmonicsDegree = function () {\n    return primitive._sphericalHarmonicsDegree;\n  };\n\n  uniformMap.u_cameraPositionWC = function () {\n    return Cartesian3.clone(frameState.camera.positionWC);\n  };\n\n  uniformMap.u_inverseModelRotation = function () {\n    const tileset = primitive._tileset;\n    const modelMatrix = Matrix4.multiply(\n      tileset.modelMatrix,\n      Matrix4.fromArray(tileset.root.transform),\n      scratchMatrix4A,\n    );\n    const inverseModelRotation = Matrix4.getRotation(\n      Matrix4.inverse(modelMatrix, scratchMatrix4C),\n      scratchMatrix4D,\n    );\n    return inverseModelRotation;\n  };\n\n  uniformMap.u_splitDirection = function () {\n    return primitive.splitDirection;\n  };\n\n  renderResources.instanceCount = primitive._numSplats;\n  renderResources.count = 4;\n  renderResources.primitiveType = PrimitiveType.TRIANGLE_STRIP;\n  shaderBuilder.addVertexLines(GaussianSplatVS);\n  shaderBuilder.addFragmentLines(GaussianSplatFS);\n  const shaderProgram = shaderBuilder.buildShaderProgram(frameState.context);\n  let renderState = clone(\n    RenderState.fromCache(renderResources.renderStateOptions),\n    true,\n  );\n\n  renderState.cull.face = ModelUtility.getCullFace(\n    tileset.modelMatrix,\n    PrimitiveType.TRIANGLE_STRIP,\n  );\n\n  renderState = RenderState.fromCache(renderState);\n  const splatQuadAttrLocations = {\n    screenQuadPosition: 0,\n    splatIndex: 2,\n  };\n\n  const idxAttr = new ModelComponents.Attribute();\n  idxAttr.name = \"_SPLAT_INDEXES\";\n  idxAttr.typedArray = primitive._indexes;\n  idxAttr.componentDatatype = ComponentDatatype.UNSIGNED_INT;\n  idxAttr.type = AttributeType.SCALAR;\n  idxAttr.normalized = false;\n  idxAttr.count = renderResources.instanceCount;\n  idxAttr.constant = 0;\n  idxAttr.instanceDivisor = 1;\n\n  if (\n    !defined(primitive._vertexArray) ||\n    primitive._indexes.length > primitive._vertexArrayLen\n  ) {\n    const geometry = new Geometry({\n      attributes: {\n        screenQuadPosition: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.FLOAT,\n          componentsPerAttribute: 2,\n          values: [-1, -1, 1, -1, 1, 1, -1, 1],\n          name: \"_SCREEN_QUAD_POS\",\n          variableName: \"screenQuadPosition\",\n        }),\n        splatIndex: { ...idxAttr, variableName: \"splatIndex\" },\n      },\n      primitiveType: PrimitiveType.TRIANGLE_STRIP,\n    });\n\n    primitive._vertexArray = VertexArray.fromGeometry({\n      context: frameState.context,\n      geometry: geometry,\n      attributeLocations: splatQuadAttrLocations,\n      bufferUsage: BufferUsage.DYNAMIC_DRAW,\n      interleave: false,\n    });\n  } else {\n    primitive._vertexArray\n      .getAttribute(1)\n      .vertexBuffer.copyFromArrayView(primitive._indexes);\n  }\n\n  primitive._vertexArrayLen = primitive._indexes.length;\n\n  const modelMatrix = Matrix4.multiply(\n    tileset.modelMatrix,\n    Matrix4.fromArray(tileset.root.transform),\n    scratchMatrix4B,\n  );\n\n  const vertexArrayCache = primitive._vertexArray;\n  const command = new DrawCommand({\n    boundingVolume: tileset.boundingSphere,\n    modelMatrix: modelMatrix,\n    uniformMap: uniformMap,\n    renderState: renderState,\n    vertexArray: vertexArrayCache,\n    shaderProgram: shaderProgram,\n    cull: renderStateOptions.cull.enabled,\n    pass: Pass.GAUSSIAN_SPLATS,\n    count: renderResources.count,\n    owner: this,\n    instanceCount: renderResources.instanceCount,\n    primitiveType: PrimitiveType.TRIANGLE_STRIP,\n    debugShowBoundingVolume: tileset.debugShowBoundingVolume,\n    castShadows: false,\n    receiveShadows: false,\n  });\n\n  primitive._drawCommand = command;\n};\n\n/**\n * Updates the Gaussian splat primitive for the current frame.\n * This method checks if the primitive needs to be updated based on the current frame state,\n * and if so, it processes the selected tiles, aggregates their attributes,\n * and generates the Gaussian splat texture if necessary.\n * It also handles the sorting of splat indexes and builds the draw command for rendering.\n *\n * @param {FrameState} frameState\n * @private\n */\nGaussianSplatPrimitive.prototype.update = function (frameState) {\n  const tileset = this._tileset;\n\n  if (!defined(this._rootTransform)) {\n    this._rootTransform = tileset.root.computedTransform;\n  }\n\n  if (!tileset.show || tileset._selectedTiles.length === 0) {\n    return;\n  }\n\n  if (this._drawCommand) {\n    frameState.commandList.push(this._drawCommand);\n  }\n\n  if (tileset._modelMatrixChanged) {\n    this._dirty = true;\n    return;\n  }\n\n  if (frameState.passes.pick === true) {\n    return;\n  }\n\n  if (this.splitDirection !== tileset.splitDirection) {\n    this.splitDirection = tileset.splitDirection;\n  }\n\n  if (this._sorterState === GaussianSplatSortingState.IDLE) {\n    if (\n      !this._dirty &&\n      Matrix4.equals(frameState.camera.viewMatrix, this._prevViewMatrix)\n    ) {\n      // No need to update if the view matrix hasn't changed and the primitive isn't dirty.\n      return;\n    }\n\n    if (\n      tileset._selectedTiles.length !== 0 &&\n      tileset._selectedTiles.length !== this.selectedTileLength\n    ) {\n      this._numSplats = 0;\n      this._positions = undefined;\n      this._rotations = undefined;\n      this._scales = undefined;\n      this._colors = undefined;\n      this._indexes = undefined;\n      this._shData = undefined;\n      this._needsGaussianSplatTexture = true;\n      this._gaussianSplatTexturePending = false;\n\n      const tiles = tileset._selectedTiles;\n      const totalElements = tiles.reduce(\n        (total, tile) => total + tile.content.pointsLength,\n        0,\n      );\n      const aggregateAttributeValues = (\n        componentDatatype,\n        getAttributeCallback,\n        numberOfComponents,\n      ) => {\n        let aggregate;\n        let offset = 0;\n        for (const tile of tiles) {\n          const content = tile.content;\n          const attribute = getAttributeCallback(content);\n          const componentsPerAttribute = defined(numberOfComponents)\n            ? numberOfComponents\n            : AttributeType.getNumberOfComponents(attribute.type);\n          const buffer = defined(attribute.typedArray)\n            ? attribute.typedArray\n            : attribute;\n          if (!defined(aggregate)) {\n            aggregate = ComponentDatatype.createTypedArray(\n              componentDatatype,\n              totalElements * componentsPerAttribute,\n            );\n          }\n          aggregate.set(buffer, offset);\n          offset += buffer.length;\n        }\n        return aggregate;\n      };\n\n      const aggregateShData = () => {\n        let offset = 0;\n        for (const tile of tiles) {\n          const shData = tile.content.packedSphericalHarmonicsData;\n          if (tile.content.sphericalHarmonicsDegree > 0) {\n            if (!defined(this._shData)) {\n              let coefs;\n              switch (tile.content.sphericalHarmonicsDegree) {\n                case 1:\n                  coefs = 9;\n                  break;\n                case 2:\n                  coefs = 24;\n                  break;\n                case 3:\n                  coefs = 45;\n              }\n              this._shData = new Uint32Array(totalElements * (coefs * (2 / 3)));\n            }\n            this._shData.set(shData, offset);\n            offset += shData.length;\n          }\n        }\n      };\n\n      this._positions = aggregateAttributeValues(\n        ComponentDatatype.FLOAT,\n        (content) => content.positions,\n        3,\n      );\n\n      this._scales = aggregateAttributeValues(\n        ComponentDatatype.FLOAT,\n        (content) => content.scales,\n        3,\n      );\n\n      this._rotations = aggregateAttributeValues(\n        ComponentDatatype.FLOAT,\n        (content) => content.rotations,\n        4,\n      );\n\n      this._colors = aggregateAttributeValues(\n        ComponentDatatype.UNSIGNED_BYTE,\n        (content) =>\n          ModelUtility.getAttributeBySemantic(\n            content.gltfPrimitive,\n            VertexAttributeSemantic.COLOR,\n          ),\n      );\n\n      aggregateShData();\n      this._sphericalHarmonicsDegree =\n        tiles[0].content.sphericalHarmonicsDegree;\n\n      this._numSplats = totalElements;\n      this.selectedTileLength = tileset._selectedTiles.length;\n    }\n\n    if (this._numSplats === 0) {\n      return;\n    }\n\n    if (this._needsGaussianSplatTexture) {\n      if (!this._gaussianSplatTexturePending) {\n        GaussianSplatPrimitive.generateSplatTexture(this, frameState);\n        if (defined(this._shData)) {\n          const oldTex = this.sphericalHarmonicsTexture;\n          const width = ContextLimits.maximumTextureSize;\n          const dims =\n            tileset._selectedTiles[0].content\n              .sphericalHarmonicsCoefficientCount / 3;\n          const splatsPerRow = Math.floor(width / dims);\n          const floatsPerRow = splatsPerRow * (dims * 2);\n          const texBuf = new Uint32Array(\n            width * Math.ceil(this._numSplats / splatsPerRow) * 2,\n          );\n\n          let dataIndex = 0;\n          for (let i = 0; dataIndex < this._shData.length; i += width * 2) {\n            texBuf.set(\n              this._shData.subarray(dataIndex, dataIndex + floatsPerRow),\n              i,\n            );\n            dataIndex += floatsPerRow;\n          }\n          this.sphericalHarmonicsTexture = createSphericalHarmonicsTexture(\n            frameState.context,\n            {\n              data: texBuf,\n              width: width,\n              height: Math.ceil(this._numSplats / splatsPerRow),\n            },\n          );\n          if (defined(oldTex)) {\n            oldTex.destroy();\n          }\n        }\n      }\n      return;\n    }\n\n    Matrix4.clone(frameState.camera.viewMatrix, this._prevViewMatrix);\n    Matrix4.multiply(\n      frameState.camera.viewMatrix,\n      this._rootTransform,\n      scratchMatrix4A,\n    );\n\n    if (!defined(this._sorterPromise)) {\n      this._sorterPromise = GaussianSplatSorter.radixSortIndexes({\n        primitive: {\n          positions: new Float32Array(this._positions),\n          modelView: Float32Array.from(scratchMatrix4A),\n          count: this._numSplats,\n        },\n        sortType: \"Index\",\n      });\n    }\n\n    if (!defined(this._sorterPromise)) {\n      this._sorterState = GaussianSplatSortingState.WAITING;\n      return;\n    }\n    this._sorterPromise.catch((err) => {\n      this._sorterState = GaussianSplatSortingState.ERROR;\n      this._sorterError = err;\n    });\n    this._sorterPromise.then((sortedData) => {\n      this._indexes = sortedData;\n      this._sorterState = GaussianSplatSortingState.SORTED;\n    });\n  } else if (this._sorterState === GaussianSplatSortingState.WAITING) {\n    if (!defined(this._sorterPromise)) {\n      this._sorterPromise = GaussianSplatSorter.radixSortIndexes({\n        primitive: {\n          positions: new Float32Array(this._positions),\n          modelView: Float32Array.from(scratchMatrix4A),\n          count: this._numSplats,\n        },\n        sortType: \"Index\",\n      });\n    }\n    if (!defined(this._sorterPromise)) {\n      this._sorterState = GaussianSplatSortingState.WAITING;\n      return;\n    }\n    this._sorterPromise.catch((err) => {\n      this._sorterState = GaussianSplatSortingState.ERROR;\n      this._sorterError = err;\n    });\n    this._sorterPromise.then((sortedData) => {\n      this._indexes = sortedData;\n      this._sorterState = GaussianSplatSortingState.SORTED;\n    });\n\n    this._sorterState = GaussianSplatSortingState.SORTING; //set state to sorting\n  } else if (this._sorterState === GaussianSplatSortingState.SORTING) {\n    return; //still sorting, wait for next frame\n  } else if (this._sorterState === GaussianSplatSortingState.SORTED) {\n    //update the draw command if sorted\n    GaussianSplatPrimitive.buildGSplatDrawCommand(this, frameState);\n    this._sorterState = GaussianSplatSortingState.IDLE; //reset state for next frame\n    this._dirty = false;\n    this._sorterPromise = undefined; //reset promise for next frame\n  } else if (this._sorterState === GaussianSplatSortingState.ERROR) {\n    throw this._sorterError;\n  }\n\n  this._dirty = false;\n};\n\nexport default GaussianSplatPrimitive;\n"],"mappings":"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CF;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAGD,SAAS;EAC3B;AACF;AACA;AACA;AACA;EACE,IAAI,CAACE,OAAO,GAAGF,SAAS;EACxB;AACF;AACA;AACA;AACA;EACE,IAAI,CAACG,OAAO,GAAGH,SAAS;EACxB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACI,QAAQ,GAAGJ,SAAS;EACzB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACK,UAAU,GAAG,CAAC;EACnB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,0BAA0B,GAAG,IAAI;;EAEtC;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,eAAe,GAAG,IAAI3E,OAAO,CAAC,CAAC;;EAEpC;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAAC4E,wBAAwB,GAAGX,OAAO,CAACY,uBAAuB,IAAI,KAAK;;EAExE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,oBAAoB,GAAGV,SAAS;;EAErC;AACF;AACA;AACA;AACA;EACE,IAAI,CAACW,yBAAyB,GAAGX,SAAS;;EAE1C;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACY,iBAAiB,GAAG,CAAC;EAC1B;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,kBAAkB,GAAG,CAAC;EAC3B;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,YAAY,GAAGd,SAAS;EAC7B;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACe,eAAe,GAAG,CAAC,CAAC;EACzB,IAAI,CAACC,eAAe,GAAGtD,cAAc,CAACuD,IAAI;;EAE1C;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,MAAM,GAAG,KAAK;EAEnB,IAAI,CAACC,QAAQ,GAAGtB,OAAO,CAACuB,OAAO;EAE/B,IAAI,CAACC,kBAAkB,GAAG,IAAI,CAACF,QAAQ,CAACG,MAAM;EAC9C,IAAI,CAACH,QAAQ,CAACG,MAAM,GAAG,IAAI,CAACC,cAAc,CAACC,IAAI,CAAC,IAA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}