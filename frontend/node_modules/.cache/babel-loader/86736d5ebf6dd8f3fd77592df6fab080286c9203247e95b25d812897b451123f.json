{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport defined from \"../../Core/defined.js\";\nimport Event from \"../../Core/Event.js\";\nimport JulianDate from \"../../Core/JulianDate.js\";\nimport ModelAnimationLoop from \"../ModelAnimationLoop.js\";\nimport ModelAnimationState from \"../ModelAnimationState.js\";\nimport ModelAnimationChannel from \"./ModelAnimationChannel.js\";\n\n/**\n * <div class=\"notice\">\n * Create animations by calling {@link ModelAnimationCollection#add}. Do not call the constructor directly.\n * </div>\n *\n * An active animation derived from a glTF asset. An active animation is an\n * animation that is either currently playing or scheduled to be played due to\n * being added to a model's {@link ModelAnimationCollection}. An active animation\n * is an instance of an animation; for example, there can be multiple active\n * animations for the same glTF animation, each with a different start time.\n *\n * @alias ModelAnimation\n * @internalConstructor\n * @class\n *\n * @see ModelAnimationCollection#add\n */\nfunction ModelAnimation(model, animation, options) {\n  this._animation = animation;\n  this._name = animation.name;\n  this._runtimeChannels = undefined;\n  this._startTime = JulianDate.clone(options.startTime);\n  this._delay = options.delay ?? 0.0; // in seconds\n  this._stopTime = JulianDate.clone(options.stopTime);\n\n  /**\n   * When <code>true</code>, the animation is removed after it stops playing.\n   * This is slightly more efficient that not removing it, but if, for example,\n   * time is reversed, the animation is not played again.\n   *\n   * @type {boolean}\n   * @default false\n   */\n  this.removeOnStop = options.removeOnStop ?? false;\n  this._multiplier = options.multiplier ?? 1.0;\n  this._reverse = options.reverse ?? false;\n  this._loop = options.loop ?? ModelAnimationLoop.NONE;\n  this._animationTime = options.animationTime;\n  this._prevAnimationDelta = undefined;\n\n  /**\n   * The event fired when this animation is started.  This can be used, for\n   * example, to play a sound or start a particle system, when the animation starts.\n   * <p>\n   * This event is fired at the end of the frame after the scene is rendered.\n   * </p>\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * animation.start.addEventListener(function(model, animation) {\n   *   console.log(`Animation started: ${animation.name}`);\n   * });\n   */\n  this.start = new Event();\n\n  /**\n   * The event fired when on each frame when this animation is updated.  The\n   * current time of the animation, relative to the glTF animation time span, is\n   * passed to the event, which allows, for example, starting new animations at a\n   * specific time relative to a playing animation.\n   * <p>\n   * This event is fired at the end of the frame after the scene is rendered.\n   * </p>\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * animation.update.addEventListener(function(model, animation, time) {\n   *   console.log(`Animation updated: ${animation.name}. glTF animation time: ${time}`);\n   * });\n   */\n  this.update = new Event();\n\n  /**\n   * The event fired when this animation is stopped.  This can be used, for\n   * example, to play a sound or start a particle system, when the animation stops.\n   * <p>\n   * This event is fired at the end of the frame after the scene is rendered.\n   * </p>\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * animation.stop.addEventListener(function(model, animation) {\n   *   console.log(`Animation stopped: ${animation.name}`);\n   * });\n   */\n  this.stop = new Event();\n  this._state = ModelAnimationState.STOPPED;\n\n  // Set during animation update\n  this._computedStartTime = undefined;\n  this._duration = undefined;\n\n  // To avoid allocations in ModelAnimationCollection.update\n  const that = this;\n  this._raiseStartEvent = function () {\n    that.start.raiseEvent(model, that);\n  };\n  this._updateEventTime = 0.0;\n  this._raiseUpdateEvent = function () {\n    that.update.raiseEvent(model, that, that._updateEventTime);\n  };\n  this._raiseStopEvent = function () {\n    that.stop.raiseEvent(model, that);\n  };\n  this._model = model;\n  this._localStartTime = undefined;\n  this._localStopTime = undefined;\n  initialize(this);\n}\nObject.defineProperties(ModelAnimation.prototype, {\n  /**\n   * The glTF animation.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {ModelComponents.Animation}\n   * @readonly\n   *\n   * @private\n   */\n  animation: {\n    get: function () {\n      return this._animation;\n    }\n  },\n  /**\n   * The name that identifies this animation in the model, if it exists.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {string}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    }\n  },\n  /**\n   * The runtime animation channels for this animation.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {ModelAnimationChannel[]}\n   * @readonly\n   *\n   * @private\n   */\n  runtimeChannels: {\n    get: function () {\n      return this._runtimeChannels;\n    }\n  },\n  /**\n   * The {@link Model} that owns this animation.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {Model}\n   * @readonly\n   *\n   * @private\n   */\n  model: {\n    get: function () {\n      return this._model;\n    }\n  },\n  /**\n   * The starting point of the animation in local animation time. This is the minimum\n   * time value across all of the keyframes belonging to this animation.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  localStartTime: {\n    get: function () {\n      return this._localStartTime;\n    }\n  },\n  /**\n   * The stopping point of the animation in local animation time. This is the maximum\n   * time value across all of the keyframes belonging to this animation.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  localStopTime: {\n    get: function () {\n      return this._localStopTime;\n    }\n  },\n  /**\n   * The scene time to start playing this animation. When this is <code>undefined</code>,\n   * the animation starts at the next frame.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {JulianDate}\n   * @readonly\n   *\n   * @default undefined\n   */\n  startTime: {\n    get: function () {\n      return this._startTime;\n    }\n  },\n  /**\n   * The delay, in seconds, from {@link ModelAnimation#startTime} to start playing.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @default undefined\n   */\n  delay: {\n    get: function () {\n      return this._delay;\n    }\n  },\n  /**\n   * The scene time to stop playing this animation. When this is <code>undefined</code>,\n   * the animation is played for its full duration and perhaps repeated depending on\n   * {@link ModelAnimation#loop}.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {JulianDate}\n   * @readonly\n   *\n   * @default undefined\n   */\n  stopTime: {\n    get: function () {\n      return this._stopTime;\n    }\n  },\n  /**\n   * Values greater than <code>1.0</code> increase the speed that the animation is played relative\n   * to the scene clock speed; values less than <code>1.0</code> decrease the speed.  A value of\n   * <code>1.0</code> plays the animation at the speed in the glTF animation mapped to the scene\n   * clock speed.  For example, if the scene is played at 2x real-time, a two-second glTF animation\n   * will play in one second even if <code>multiplier</code> is <code>1.0</code>.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @default 1.0\n   */\n  multiplier: {\n    get: function () {\n      return this._multiplier;\n    }\n  },\n  /**\n   * When <code>true</code>, the animation is played in reverse.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  reverse: {\n    get: function () {\n      return this._reverse;\n    }\n  },\n  /**\n   * Determines if and how the animation is looped.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {ModelAnimationLoop}\n   * @readonly\n   *\n   * @default {@link ModelAnimationLoop.NONE}\n   */\n  loop: {\n    get: function () {\n      return this._loop;\n    }\n  },\n  /**\n   * If this is defined, it will be used to compute the local animation time\n   * instead of the scene's time.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {ModelAnimation.AnimationTimeCallback}\n   * @default undefined\n   */\n  animationTime: {\n    get: function () {\n      return this._animationTime;\n    }\n  }\n});\nfunction initialize(runtimeAnimation) {\n  let localStartTime = Number.MAX_VALUE;\n  let localStopTime = -Number.MAX_VALUE;\n  const sceneGraph = runtimeAnimation._model.sceneGraph;\n  const animation = runtimeAnimation._animation;\n  const channels = animation.channels;\n  const length = channels.length;\n  const runtimeChannels = [];\n  for (let i = 0; i < length; i++) {\n    const channel = channels[i];\n    const target = channel.target;\n\n    // Ignore this channel if the target is invalid, i.e. if the node\n    // it references doesn't exist.\n    if (!defined(target)) {\n      continue;\n    }\n    const nodeIndex = target.node.index;\n    const runtimeNode = sceneGraph._runtimeNodes[nodeIndex];\n    const runtimeChannel = new ModelAnimationChannel({\n      channel: channel,\n      runtimeAnimation: runtimeAnimation,\n      runtimeNode: runtimeNode\n    });\n    const times = channel.sampler.input;\n    localStartTime = Math.min(localStartTime, times[0]);\n    localStopTime = Math.max(localStopTime, times[times.length - 1]);\n    runtimeChannels.push(runtimeChannel);\n  }\n  runtimeAnimation._runtimeChannels = runtimeChannels;\n  runtimeAnimation._localStartTime = localStartTime;\n  runtimeAnimation._localStopTime = localStopTime;\n}\n\n/**\n * Evaluate all animation channels to advance this animation.\n *\n * @param {number} time The local animation time.\n *\n * @private\n */\nModelAnimation.prototype.animate = function (time) {\n  const runtimeChannels = this._runtimeChannels;\n  const length = runtimeChannels.length;\n  for (let i = 0; i < length; i++) {\n    runtimeChannels[i].animate(time);\n  }\n};\n\n/**\n * A function used to compute the local animation time for a ModelAnimation.\n * @callback ModelAnimation.AnimationTimeCallback\n *\n * @param {number} duration The animation's original duration in seconds.\n * @param {number} seconds The seconds since the animation started, in scene time.\n * @returns {number} Returns the local animation time.\n *\n * @example\n * // Use real time for model animation (assuming animateWhilePaused was set to true)\n * function animationTime(duration) {\n *     return Date.now() / 1000 / duration;\n * }\n *\n * @example\n * // Offset the phase of the animation, so it starts halfway through its cycle.\n * function animationTime(duration, seconds) {\n *     return seconds / duration + 0.5;\n * }\n */\nexport default ModelAnimation;","map":{"version":3,"names":["defined","Event","JulianDate","ModelAnimationLoop","ModelAnimationState","ModelAnimationChannel","ModelAnimation","model","animation","options","_animation","_name","name","_runtimeChannels","undefined","_startTime","clone","startTime","_delay","delay","_stopTime","stopTime","removeOnStop","_multiplier","multiplier","_reverse","reverse","_loop","loop","NONE","_animationTime","animationTime","_prevAnimationDelta","start","update","stop","_state","STOPPED","_computedStartTime","_duration","that","_raiseStartEvent","raiseEvent","_updateEventTime","_raiseUpdateEvent","_raiseStopEvent","_model","_localStartTime","_localStopTime","initialize","Object","defineProperties","prototype","get","runtimeChannels","localStartTime","localStopTime","runtimeAnimation","Number","MAX_VALUE","sceneGraph","channels","length","i","channel","target","nodeIndex","node","index","runtimeNode","_runtimeNodes","runtimeChannel","times","sampler","input","Math","min","max","push","animate","time"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Model/ModelAnimation.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport Event from \"../../Core/Event.js\";\nimport JulianDate from \"../../Core/JulianDate.js\";\nimport ModelAnimationLoop from \"../ModelAnimationLoop.js\";\nimport ModelAnimationState from \"../ModelAnimationState.js\";\nimport ModelAnimationChannel from \"./ModelAnimationChannel.js\";\n\n/**\n * <div class=\"notice\">\n * Create animations by calling {@link ModelAnimationCollection#add}. Do not call the constructor directly.\n * </div>\n *\n * An active animation derived from a glTF asset. An active animation is an\n * animation that is either currently playing or scheduled to be played due to\n * being added to a model's {@link ModelAnimationCollection}. An active animation\n * is an instance of an animation; for example, there can be multiple active\n * animations for the same glTF animation, each with a different start time.\n *\n * @alias ModelAnimation\n * @internalConstructor\n * @class\n *\n * @see ModelAnimationCollection#add\n */\nfunction ModelAnimation(model, animation, options) {\n  this._animation = animation;\n  this._name = animation.name;\n  this._runtimeChannels = undefined;\n\n  this._startTime = JulianDate.clone(options.startTime);\n  this._delay = options.delay ?? 0.0; // in seconds\n  this._stopTime = JulianDate.clone(options.stopTime);\n\n  /**\n   * When <code>true</code>, the animation is removed after it stops playing.\n   * This is slightly more efficient that not removing it, but if, for example,\n   * time is reversed, the animation is not played again.\n   *\n   * @type {boolean}\n   * @default false\n   */\n  this.removeOnStop = options.removeOnStop ?? false;\n  this._multiplier = options.multiplier ?? 1.0;\n  this._reverse = options.reverse ?? false;\n  this._loop = options.loop ?? ModelAnimationLoop.NONE;\n  this._animationTime = options.animationTime;\n  this._prevAnimationDelta = undefined;\n\n  /**\n   * The event fired when this animation is started.  This can be used, for\n   * example, to play a sound or start a particle system, when the animation starts.\n   * <p>\n   * This event is fired at the end of the frame after the scene is rendered.\n   * </p>\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * animation.start.addEventListener(function(model, animation) {\n   *   console.log(`Animation started: ${animation.name}`);\n   * });\n   */\n  this.start = new Event();\n\n  /**\n   * The event fired when on each frame when this animation is updated.  The\n   * current time of the animation, relative to the glTF animation time span, is\n   * passed to the event, which allows, for example, starting new animations at a\n   * specific time relative to a playing animation.\n   * <p>\n   * This event is fired at the end of the frame after the scene is rendered.\n   * </p>\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * animation.update.addEventListener(function(model, animation, time) {\n   *   console.log(`Animation updated: ${animation.name}. glTF animation time: ${time}`);\n   * });\n   */\n  this.update = new Event();\n\n  /**\n   * The event fired when this animation is stopped.  This can be used, for\n   * example, to play a sound or start a particle system, when the animation stops.\n   * <p>\n   * This event is fired at the end of the frame after the scene is rendered.\n   * </p>\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * animation.stop.addEventListener(function(model, animation) {\n   *   console.log(`Animation stopped: ${animation.name}`);\n   * });\n   */\n  this.stop = new Event();\n\n  this._state = ModelAnimationState.STOPPED;\n\n  // Set during animation update\n  this._computedStartTime = undefined;\n  this._duration = undefined;\n\n  // To avoid allocations in ModelAnimationCollection.update\n  const that = this;\n  this._raiseStartEvent = function () {\n    that.start.raiseEvent(model, that);\n  };\n  this._updateEventTime = 0.0;\n  this._raiseUpdateEvent = function () {\n    that.update.raiseEvent(model, that, that._updateEventTime);\n  };\n  this._raiseStopEvent = function () {\n    that.stop.raiseEvent(model, that);\n  };\n\n  this._model = model;\n\n  this._localStartTime = undefined;\n  this._localStopTime = undefined;\n\n  initialize(this);\n}\n\nObject.defineProperties(ModelAnimation.prototype, {\n  /**\n   * The glTF animation.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {ModelComponents.Animation}\n   * @readonly\n   *\n   * @private\n   */\n  animation: {\n    get: function () {\n      return this._animation;\n    },\n  },\n\n  /**\n   * The name that identifies this animation in the model, if it exists.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {string}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * The runtime animation channels for this animation.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {ModelAnimationChannel[]}\n   * @readonly\n   *\n   * @private\n   */\n  runtimeChannels: {\n    get: function () {\n      return this._runtimeChannels;\n    },\n  },\n\n  /**\n   * The {@link Model} that owns this animation.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {Model}\n   * @readonly\n   *\n   * @private\n   */\n  model: {\n    get: function () {\n      return this._model;\n    },\n  },\n\n  /**\n   * The starting point of the animation in local animation time. This is the minimum\n   * time value across all of the keyframes belonging to this animation.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  localStartTime: {\n    get: function () {\n      return this._localStartTime;\n    },\n  },\n\n  /**\n   * The stopping point of the animation in local animation time. This is the maximum\n   * time value across all of the keyframes belonging to this animation.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @private\n   */\n  localStopTime: {\n    get: function () {\n      return this._localStopTime;\n    },\n  },\n\n  /**\n   * The scene time to start playing this animation. When this is <code>undefined</code>,\n   * the animation starts at the next frame.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {JulianDate}\n   * @readonly\n   *\n   * @default undefined\n   */\n  startTime: {\n    get: function () {\n      return this._startTime;\n    },\n  },\n\n  /**\n   * The delay, in seconds, from {@link ModelAnimation#startTime} to start playing.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @default undefined\n   */\n  delay: {\n    get: function () {\n      return this._delay;\n    },\n  },\n\n  /**\n   * The scene time to stop playing this animation. When this is <code>undefined</code>,\n   * the animation is played for its full duration and perhaps repeated depending on\n   * {@link ModelAnimation#loop}.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {JulianDate}\n   * @readonly\n   *\n   * @default undefined\n   */\n  stopTime: {\n    get: function () {\n      return this._stopTime;\n    },\n  },\n\n  /**\n   * Values greater than <code>1.0</code> increase the speed that the animation is played relative\n   * to the scene clock speed; values less than <code>1.0</code> decrease the speed.  A value of\n   * <code>1.0</code> plays the animation at the speed in the glTF animation mapped to the scene\n   * clock speed.  For example, if the scene is played at 2x real-time, a two-second glTF animation\n   * will play in one second even if <code>multiplier</code> is <code>1.0</code>.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {number}\n   * @readonly\n   *\n   * @default 1.0\n   */\n  multiplier: {\n    get: function () {\n      return this._multiplier;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the animation is played in reverse.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  reverse: {\n    get: function () {\n      return this._reverse;\n    },\n  },\n\n  /**\n   * Determines if and how the animation is looped.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {ModelAnimationLoop}\n   * @readonly\n   *\n   * @default {@link ModelAnimationLoop.NONE}\n   */\n  loop: {\n    get: function () {\n      return this._loop;\n    },\n  },\n\n  /**\n   * If this is defined, it will be used to compute the local animation time\n   * instead of the scene's time.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {ModelAnimation.AnimationTimeCallback}\n   * @default undefined\n   */\n  animationTime: {\n    get: function () {\n      return this._animationTime;\n    },\n  },\n});\n\nfunction initialize(runtimeAnimation) {\n  let localStartTime = Number.MAX_VALUE;\n  let localStopTime = -Number.MAX_VALUE;\n\n  const sceneGraph = runtimeAnimation._model.sceneGraph;\n  const animation = runtimeAnimation._animation;\n  const channels = animation.channels;\n  const length = channels.length;\n\n  const runtimeChannels = [];\n  for (let i = 0; i < length; i++) {\n    const channel = channels[i];\n    const target = channel.target;\n\n    // Ignore this channel if the target is invalid, i.e. if the node\n    // it references doesn't exist.\n    if (!defined(target)) {\n      continue;\n    }\n\n    const nodeIndex = target.node.index;\n    const runtimeNode = sceneGraph._runtimeNodes[nodeIndex];\n\n    const runtimeChannel = new ModelAnimationChannel({\n      channel: channel,\n      runtimeAnimation: runtimeAnimation,\n      runtimeNode: runtimeNode,\n    });\n\n    const times = channel.sampler.input;\n    localStartTime = Math.min(localStartTime, times[0]);\n    localStopTime = Math.max(localStopTime, times[times.length - 1]);\n\n    runtimeChannels.push(runtimeChannel);\n  }\n\n  runtimeAnimation._runtimeChannels = runtimeChannels;\n  runtimeAnimation._localStartTime = localStartTime;\n  runtimeAnimation._localStopTime = localStopTime;\n}\n\n/**\n * Evaluate all animation channels to advance this animation.\n *\n * @param {number} time The local animation time.\n *\n * @private\n */\nModelAnimation.prototype.animate = function (time) {\n  const runtimeChannels = this._runtimeChannels;\n  const length = runtimeChannels.length;\n  for (let i = 0; i < length; i++) {\n    runtimeChannels[i].animate(time);\n  }\n};\n\n/**\n * A function used to compute the local animation time for a ModelAnimation.\n * @callback ModelAnimation.AnimationTimeCallback\n *\n * @param {number} duration The animation's original duration in seconds.\n * @param {number} seconds The seconds since the animation started, in scene time.\n * @returns {number} Returns the local animation time.\n *\n * @example\n * // Use real time for model animation (assuming animateWhilePaused was set to true)\n * function animationTime(duration) {\n *     return Date.now() / 1000 / duration;\n * }\n *\n * @example\n * // Offset the phase of the animation, so it starts halfway through its cycle.\n * function animationTime(duration, seconds) {\n *     return seconds / duration + 0.5;\n * }\n */\nexport default ModelAnimation;\n"],"mappings":"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F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE2C,eAAe,EAAE;IACfD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACxC,gBAAgB;IAC9B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEN,KAAK,EAAE;IACL8C,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACP,MAAM;IACpB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACES,cAAc,EAAE;IACdF,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACN,eAAe;IAC7B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACES,aAAa,EAAE;IACbH,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACL,cAAc;IAC5B;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE/B,SAAS,EAAE;IACToC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACtC,UAAU;IACxB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEI,KAAK,EAAE;IACLkC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACnC,MAAM;IACpB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEG,QAAQ,EAAE;IACRgC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACjC,SAAS;IACvB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEI,UAAU,EAAE;IACV6B,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAAC9B,WAAW;IACzB;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}