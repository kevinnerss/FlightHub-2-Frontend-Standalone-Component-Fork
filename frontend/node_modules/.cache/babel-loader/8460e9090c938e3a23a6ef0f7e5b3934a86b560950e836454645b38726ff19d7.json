{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport clone from \"../Core/clone.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Context from \"./Context.js\";\n\n/**\n * Enables a single WebGL context to be used by any number of {@link Scene}s.\n * You can pass a SharedContext in place of a {@link ContextOptions} to the constructors of {@link Scene}, {@link CesiumWidget}, and {@link Viewer}.\n * {@link Primitive}s associated with the shared WebGL context can be displayed in any Scene that uses the same context.\n * The context renders each Scene to an off-screen canvas, then blits the result to that Scene's on-screen canvas.\n *\n * @private\n * @alias SharedContext\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {ContextOptions} [options.contextOptions] Context and WebGL creation properties.\n * @param {boolean} [options.autoDestroy=true] Destroys this context and all of its WebGL resources after all Scenes using the context are destroyed.\n\n * @see {@link http://www.khronos.org/registry/webgl/specs/latest/#5.2|WebGLContextAttributes}\n *\n * @example\n * // Create two Scenes sharing a single WebGL context\n * const context = new Cesium.SharedContext();\n * const scene1 = new Cesium.Scene({\n *   canvas: canvas1,\n *   contextOptions: context,\n * });\n * const scene2 = new Cesium.Scene({\n *   canvas: canvas2,\n *   contextOptions: context,\n * });\n */\nfunction SharedContext(options) {\n  this._autoDestroy = options?.autoDestroy ?? true;\n  this._canvas = document.createElement(\"canvas\");\n  this._context = new Context(this._canvas, clone(options?.contextOptions));\n  this._canvases = [];\n}\n\n/**\n * Creates an instance of {@link Context} that manages the shared WebGL context for a specific canvas.\n * @param {HTMLCanvasElement} canvas The canvas element to which the context will be associated\n * @returns {Context} The created context instance\n * @private\n */\nSharedContext.prototype.createSceneContext = function (canvas) {\n  const context2d = canvas.getContext(\"2d\", {\n    alpha: true\n  });\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!context2d) {\n    throw new DeveloperError(\"canvas used with SharedContext must provide a 2d context\");\n  }\n  if (this._canvases.includes(canvas)) {\n    throw new DeveloperError(\"canvas is already associated with a scene\");\n  }\n  //>>includeEnd('debug');\n\n  const sharedContext = this;\n  sharedContext._canvases.push(canvas);\n  let isDestroyed = false;\n  const destroy = function () {\n    isDestroyed = true;\n    const index = sharedContext._canvases.indexOf(canvas);\n    if (-1 !== index) {\n      sharedContext._canvases.splice(index, 1);\n      if (sharedContext._autoDestroy && sharedContext._canvases.length === 0) {\n        sharedContext.destroy();\n      }\n    }\n  };\n  const beginFrame = function () {\n    // Ensure the off-screen canvas is at least as large as the on-screen canvas.\n    const sharedCanvas = sharedContext._context.canvas;\n    const width = this.drawingBufferWidth;\n    if (sharedCanvas.width < width) {\n      sharedCanvas.width = width;\n    }\n    const height = this.drawingBufferHeight;\n    if (sharedCanvas.height < height) {\n      sharedCanvas.height = height;\n    }\n  };\n  const endFrame = function () {\n    // Blit the image from the off-screen canvas to the on-screen canvas.\n    const w = this.drawingBufferWidth;\n    const h = this.drawingBufferHeight;\n    const yOffset = sharedContext._context.canvas.height - h; // drawImage has top as Y=0, GL has bottom as Y=0\n    context2d.drawImage(sharedContext._context.canvas, 0, yOffset, w, h, 0, 0, w, h);\n\n    // Do normal post-frame cleanup.\n    sharedContext._context.endFrame();\n  };\n  const proxy = new Proxy(this._context, {\n    get(target, prop, receiver) {\n      if (prop === \"isDestroyed\") {\n        return function () {\n          return isDestroyed;\n        };\n      } else if (isDestroyed) {\n        //>>includeStart('debug', pragmas.debug);\n        throw new DeveloperError(\"This object was destroyed, i.e., destroy() was called.\");\n        //>>includeEnd('debug');\n      }\n      switch (prop) {\n        case \"_canvas\":\n          return canvas;\n        case \"destroy\":\n          return destroy;\n        case \"drawingBufferWidth\":\n          return canvas.width;\n        case \"drawingBufferHeight\":\n          return canvas.height;\n        case \"beginFrame\":\n          return beginFrame;\n        case \"endFrame\":\n          return endFrame;\n        default:\n          return Reflect.get(target, prop, receiver);\n      }\n    }\n  });\n  return proxy;\n};\n\n/**\n * Destroys the WebGL resources held by this object. Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception. Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * <br /><br />\n * By default, a SharedContext is destroyed automatically once the last Scene using it is destroyed, in which case it\n * is not necessary to call this method directly.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * context = context && context.destroy();\n *\n * @see SharedContext#isDestroyed\n */\nSharedContext.prototype.destroy = function () {\n  this._context.destroy();\n  destroyObject(this);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see SharedContext#destroy\n */\nSharedContext.prototype.isDestroyed = function () {\n  return false;\n};\nexport default SharedContext;","map":{"version":3,"names":["clone","destroyObject","DeveloperError","Context","SharedContext","options","_autoDestroy","autoDestroy","_canvas","document","createElement","_context","contextOptions","_canvases","prototype","createSceneContext","canvas","context2d","getContext","alpha","includes","sharedContext","push","isDestroyed","destroy","index","indexOf","splice","length","beginFrame","sharedCanvas","width","drawingBufferWidth","height","drawingBufferHeight","endFrame","w","h","yOffset","drawImage","proxy","Proxy","get","target","prop","receiver","Reflect"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Renderer/SharedContext.js"],"sourcesContent":["import clone from \"../Core/clone.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Context from \"./Context.js\";\n\n/**\n * Enables a single WebGL context to be used by any number of {@link Scene}s.\n * You can pass a SharedContext in place of a {@link ContextOptions} to the constructors of {@link Scene}, {@link CesiumWidget}, and {@link Viewer}.\n * {@link Primitive}s associated with the shared WebGL context can be displayed in any Scene that uses the same context.\n * The context renders each Scene to an off-screen canvas, then blits the result to that Scene's on-screen canvas.\n *\n * @private\n * @alias SharedContext\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {ContextOptions} [options.contextOptions] Context and WebGL creation properties.\n * @param {boolean} [options.autoDestroy=true] Destroys this context and all of its WebGL resources after all Scenes using the context are destroyed.\n\n * @see {@link http://www.khronos.org/registry/webgl/specs/latest/#5.2|WebGLContextAttributes}\n *\n * @example\n * // Create two Scenes sharing a single WebGL context\n * const context = new Cesium.SharedContext();\n * const scene1 = new Cesium.Scene({\n *   canvas: canvas1,\n *   contextOptions: context,\n * });\n * const scene2 = new Cesium.Scene({\n *   canvas: canvas2,\n *   contextOptions: context,\n * });\n */\nfunction SharedContext(options) {\n  this._autoDestroy = options?.autoDestroy ?? true;\n  this._canvas = document.createElement(\"canvas\");\n  this._context = new Context(this._canvas, clone(options?.contextOptions));\n  this._canvases = [];\n}\n\n/**\n * Creates an instance of {@link Context} that manages the shared WebGL context for a specific canvas.\n * @param {HTMLCanvasElement} canvas The canvas element to which the context will be associated\n * @returns {Context} The created context instance\n * @private\n */\nSharedContext.prototype.createSceneContext = function (canvas) {\n  const context2d = canvas.getContext(\"2d\", { alpha: true });\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!context2d) {\n    throw new DeveloperError(\n      \"canvas used with SharedContext must provide a 2d context\",\n    );\n  }\n\n  if (this._canvases.includes(canvas)) {\n    throw new DeveloperError(\"canvas is already associated with a scene\");\n  }\n  //>>includeEnd('debug');\n\n  const sharedContext = this;\n  sharedContext._canvases.push(canvas);\n\n  let isDestroyed = false;\n  const destroy = function () {\n    isDestroyed = true;\n    const index = sharedContext._canvases.indexOf(canvas);\n    if (-1 !== index) {\n      sharedContext._canvases.splice(index, 1);\n      if (sharedContext._autoDestroy && sharedContext._canvases.length === 0) {\n        sharedContext.destroy();\n      }\n    }\n  };\n\n  const beginFrame = function () {\n    // Ensure the off-screen canvas is at least as large as the on-screen canvas.\n    const sharedCanvas = sharedContext._context.canvas;\n\n    const width = this.drawingBufferWidth;\n    if (sharedCanvas.width < width) {\n      sharedCanvas.width = width;\n    }\n\n    const height = this.drawingBufferHeight;\n    if (sharedCanvas.height < height) {\n      sharedCanvas.height = height;\n    }\n  };\n\n  const endFrame = function () {\n    // Blit the image from the off-screen canvas to the on-screen canvas.\n    const w = this.drawingBufferWidth;\n    const h = this.drawingBufferHeight;\n    const yOffset = sharedContext._context.canvas.height - h; // drawImage has top as Y=0, GL has bottom as Y=0\n    context2d.drawImage(\n      sharedContext._context.canvas,\n      0,\n      yOffset,\n      w,\n      h,\n      0,\n      0,\n      w,\n      h,\n    );\n\n    // Do normal post-frame cleanup.\n    sharedContext._context.endFrame();\n  };\n\n  const proxy = new Proxy(this._context, {\n    get(target, prop, receiver) {\n      if (prop === \"isDestroyed\") {\n        return function () {\n          return isDestroyed;\n        };\n      } else if (isDestroyed) {\n        //>>includeStart('debug', pragmas.debug);\n        throw new DeveloperError(\n          \"This object was destroyed, i.e., destroy() was called.\",\n        );\n        //>>includeEnd('debug');\n      }\n\n      switch (prop) {\n        case \"_canvas\":\n          return canvas;\n        case \"destroy\":\n          return destroy;\n        case \"drawingBufferWidth\":\n          return canvas.width;\n        case \"drawingBufferHeight\":\n          return canvas.height;\n        case \"beginFrame\":\n          return beginFrame;\n        case \"endFrame\":\n          return endFrame;\n        default:\n          return Reflect.get(target, prop, receiver);\n      }\n    },\n  });\n\n  return proxy;\n};\n\n/**\n * Destroys the WebGL resources held by this object. Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception. Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * <br /><br />\n * By default, a SharedContext is destroyed automatically once the last Scene using it is destroyed, in which case it\n * is not necessary to call this method directly.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * context = context && context.destroy();\n *\n * @see SharedContext#isDestroyed\n */\nSharedContext.prototype.destroy = function () {\n  this._context.destroy();\n  destroyObject(this);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see SharedContext#destroy\n */\nSharedContext.prototype.isDestroyed = function () {\n  return false;\n};\n\nexport default SharedContext;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}