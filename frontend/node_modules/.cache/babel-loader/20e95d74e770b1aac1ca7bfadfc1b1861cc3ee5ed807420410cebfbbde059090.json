{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport ConstantProperty from \"./ConstantProperty.js\";\nimport createPropertyDescriptor from \"./createPropertyDescriptor.js\";\nimport Property from \"./Property.js\";\n\n/**\n * A {@link Property} whose value is a key-value mapping of property names to the computed value of other properties.\n *\n * @alias PropertyBag\n * @implements Record<string, any>\n * @constructor\n *\n * @param {object} [value] An object, containing key-value mapping of property names to properties.\n * @param {Function} [createPropertyCallback] A function that will be called when the value of any of the properties in value are not a Property.\n */\nfunction PropertyBag(value, createPropertyCallback) {\n  this._propertyNames = [];\n  this._definitionChanged = new Event();\n  if (defined(value)) {\n    this.merge(value, createPropertyCallback);\n  }\n}\nObject.defineProperties(PropertyBag.prototype, {\n  /**\n   * Gets the names of all properties registered on this instance.\n   * @memberof PropertyBag.prototype\n   * @type {Array}\n   */\n  propertyNames: {\n    get: function () {\n      return this._propertyNames;\n    }\n  },\n  /**\n   * Gets a value indicating if this property is constant.  This property\n   * is considered constant if all property items in this object are constant.\n   * @memberof PropertyBag.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  isConstant: {\n    get: function () {\n      const propertyNames = this._propertyNames;\n      for (let i = 0, len = propertyNames.length; i < len; i++) {\n        if (!Property.isConstant(this[propertyNames[i]])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  },\n  /**\n   * Gets the event that is raised whenever the set of properties contained in this\n   * object changes, or one of the properties itself changes.\n   *\n   * @memberof PropertyBag.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  definitionChanged: {\n    get: function () {\n      return this._definitionChanged;\n    }\n  }\n});\n\n/**\n * Determines if this object has defined a property with the given name.\n *\n * @param {string} propertyName The name of the property to check for.\n *\n * @returns {boolean} True if this object has defined a property with the given name, false otherwise.\n */\nPropertyBag.prototype.hasProperty = function (propertyName) {\n  return this._propertyNames.indexOf(propertyName) !== -1;\n};\nfunction createConstantProperty(value) {\n  return new ConstantProperty(value);\n}\n\n/**\n * Adds a property to this object.\n *\n * @param {string} propertyName The name of the property to add.\n * @param {*} [value] The value of the new property, if provided.\n * @param {Function} [createPropertyCallback] A function that will be called when the value of this new property is set to a value that is not a Property.\n *\n * @exception {DeveloperError} \"propertyName\" is already a registered property.\n */\nPropertyBag.prototype.addProperty = function (propertyName, value, createPropertyCallback) {\n  const propertyNames = this._propertyNames;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(propertyName)) {\n    throw new DeveloperError(\"propertyName is required.\");\n  }\n  if (propertyNames.indexOf(propertyName) !== -1) {\n    throw new DeveloperError(`${propertyName} is already a registered property.`);\n  }\n  //>>includeEnd('debug');\n\n  propertyNames.push(propertyName);\n  Object.defineProperty(this, propertyName, createPropertyDescriptor(propertyName, true, createPropertyCallback ?? createConstantProperty));\n  if (defined(value)) {\n    this[propertyName] = value;\n  }\n  this._definitionChanged.raiseEvent(this);\n};\n\n/**\n * Removed a property previously added with addProperty.\n *\n * @param {string} propertyName The name of the property to remove.\n *\n * @exception {DeveloperError} \"propertyName\" is not a registered property.\n */\nPropertyBag.prototype.removeProperty = function (propertyName) {\n  const propertyNames = this._propertyNames;\n  const index = propertyNames.indexOf(propertyName);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(propertyName)) {\n    throw new DeveloperError(\"propertyName is required.\");\n  }\n  if (index === -1) {\n    throw new DeveloperError(`${propertyName} is not a registered property.`);\n  }\n  //>>includeEnd('debug');\n\n  this._propertyNames.splice(index, 1);\n  delete this[propertyName];\n  this._definitionChanged.raiseEvent(this);\n};\nconst timeScratch = new JulianDate();\n\n/**\n * Gets the value of this property.  Each contained property will be evaluated at the given time, and the overall\n * result will be an object, mapping property names to those values.\n *\n * @param {JulianDate} [time=JulianDate.now()] The time for which to retrieve the value. If omitted, the current system time is used.\n * @param {object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n * Note that any properties in result which are not part of this PropertyBag will be left as-is.\n * @returns {object} The modified result parameter or a new instance if the result parameter was not supplied.\n */\nPropertyBag.prototype.getValue = function (time, result) {\n  if (!defined(time)) {\n    time = JulianDate.now(timeScratch);\n  }\n  if (!defined(result)) {\n    result = {};\n  }\n  const propertyNames = this._propertyNames;\n  for (let i = 0, len = propertyNames.length; i < len; i++) {\n    const propertyName = propertyNames[i];\n    result[propertyName] = Property.getValueOrUndefined(this[propertyName], time, result[propertyName]);\n  }\n  return result;\n};\n\n/**\n * Assigns each unassigned property on this object to the value\n * of the same property on the provided source object.\n *\n * @param {object} source The object to be merged into this object.\n * @param {Function} [createPropertyCallback] A function that will be called when the value of any of the properties in value are not a Property.\n */\nPropertyBag.prototype.merge = function (source, createPropertyCallback) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(source)) {\n    throw new DeveloperError(\"source is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const propertyNames = this._propertyNames;\n  const sourcePropertyNames = defined(source._propertyNames) ? source._propertyNames : Object.keys(source);\n  for (let i = 0, len = sourcePropertyNames.length; i < len; i++) {\n    const name = sourcePropertyNames[i];\n    const targetProperty = this[name];\n    const sourceProperty = source[name];\n\n    //Custom properties that are registered on the source must also be added to this.\n    if (targetProperty === undefined && propertyNames.indexOf(name) === -1) {\n      this.addProperty(name, undefined, createPropertyCallback);\n    }\n    if (sourceProperty !== undefined) {\n      if (targetProperty !== undefined) {\n        if (defined(targetProperty) && defined(targetProperty.merge)) {\n          targetProperty.merge(sourceProperty);\n        }\n      } else if (defined(sourceProperty) && defined(sourceProperty.merge) && defined(sourceProperty.clone)) {\n        this[name] = sourceProperty.clone();\n      } else {\n        this[name] = sourceProperty;\n      }\n    }\n  }\n};\nfunction propertiesEqual(a, b) {\n  const aPropertyNames = a._propertyNames;\n  const bPropertyNames = b._propertyNames;\n  const len = aPropertyNames.length;\n  if (len !== bPropertyNames.length) {\n    return false;\n  }\n  for (let aIndex = 0; aIndex < len; ++aIndex) {\n    const name = aPropertyNames[aIndex];\n    const bIndex = bPropertyNames.indexOf(name);\n    if (bIndex === -1) {\n      return false;\n    }\n    if (!Property.equals(a[name], b[name])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Compares this property to the provided property and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Property} [other] The other property.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nPropertyBag.prototype.equals = function (other) {\n  return this === other ||\n  //\n  other instanceof PropertyBag &&\n  //\n  propertiesEqual(this, other);\n};\nexport default PropertyBag;","map":{"version":3,"names":["defined","DeveloperError","Event","JulianDate","ConstantProperty","createPropertyDescriptor","Property","PropertyBag","value","createPropertyCallback","_propertyNames","_definitionChanged","merge","Object","defineProperties","prototype","propertyNames","get","isConstant","i","len","length","definitionChanged","hasProperty","propertyName","indexOf","createConstantProperty","addProperty","push","defineProperty","raiseEvent","removeProperty","index","splice","timeScratch","getValue","time","result","now","getValueOrUndefined","source","sourcePropertyNames","keys","name","targetProperty","sourceProperty","undefined","clone","propertiesEqual","a","b","aPropertyNames","bPropertyNames","aIndex","bIndex","equals","other"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/DataSources/PropertyBag.js"],"sourcesContent":["import defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport ConstantProperty from \"./ConstantProperty.js\";\nimport createPropertyDescriptor from \"./createPropertyDescriptor.js\";\nimport Property from \"./Property.js\";\n\n/**\n * A {@link Property} whose value is a key-value mapping of property names to the computed value of other properties.\n *\n * @alias PropertyBag\n * @implements Record<string, any>\n * @constructor\n *\n * @param {object} [value] An object, containing key-value mapping of property names to properties.\n * @param {Function} [createPropertyCallback] A function that will be called when the value of any of the properties in value are not a Property.\n */\nfunction PropertyBag(value, createPropertyCallback) {\n  this._propertyNames = [];\n  this._definitionChanged = new Event();\n\n  if (defined(value)) {\n    this.merge(value, createPropertyCallback);\n  }\n}\n\nObject.defineProperties(PropertyBag.prototype, {\n  /**\n   * Gets the names of all properties registered on this instance.\n   * @memberof PropertyBag.prototype\n   * @type {Array}\n   */\n  propertyNames: {\n    get: function () {\n      return this._propertyNames;\n    },\n  },\n  /**\n   * Gets a value indicating if this property is constant.  This property\n   * is considered constant if all property items in this object are constant.\n   * @memberof PropertyBag.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  isConstant: {\n    get: function () {\n      const propertyNames = this._propertyNames;\n      for (let i = 0, len = propertyNames.length; i < len; i++) {\n        if (!Property.isConstant(this[propertyNames[i]])) {\n          return false;\n        }\n      }\n      return true;\n    },\n  },\n  /**\n   * Gets the event that is raised whenever the set of properties contained in this\n   * object changes, or one of the properties itself changes.\n   *\n   * @memberof PropertyBag.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  definitionChanged: {\n    get: function () {\n      return this._definitionChanged;\n    },\n  },\n});\n\n/**\n * Determines if this object has defined a property with the given name.\n *\n * @param {string} propertyName The name of the property to check for.\n *\n * @returns {boolean} True if this object has defined a property with the given name, false otherwise.\n */\nPropertyBag.prototype.hasProperty = function (propertyName) {\n  return this._propertyNames.indexOf(propertyName) !== -1;\n};\n\nfunction createConstantProperty(value) {\n  return new ConstantProperty(value);\n}\n\n/**\n * Adds a property to this object.\n *\n * @param {string} propertyName The name of the property to add.\n * @param {*} [value] The value of the new property, if provided.\n * @param {Function} [createPropertyCallback] A function that will be called when the value of this new property is set to a value that is not a Property.\n *\n * @exception {DeveloperError} \"propertyName\" is already a registered property.\n */\nPropertyBag.prototype.addProperty = function (\n  propertyName,\n  value,\n  createPropertyCallback,\n) {\n  const propertyNames = this._propertyNames;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(propertyName)) {\n    throw new DeveloperError(\"propertyName is required.\");\n  }\n  if (propertyNames.indexOf(propertyName) !== -1) {\n    throw new DeveloperError(\n      `${propertyName} is already a registered property.`,\n    );\n  }\n  //>>includeEnd('debug');\n\n  propertyNames.push(propertyName);\n  Object.defineProperty(\n    this,\n    propertyName,\n    createPropertyDescriptor(\n      propertyName,\n      true,\n      createPropertyCallback ?? createConstantProperty,\n    ),\n  );\n\n  if (defined(value)) {\n    this[propertyName] = value;\n  }\n\n  this._definitionChanged.raiseEvent(this);\n};\n\n/**\n * Removed a property previously added with addProperty.\n *\n * @param {string} propertyName The name of the property to remove.\n *\n * @exception {DeveloperError} \"propertyName\" is not a registered property.\n */\nPropertyBag.prototype.removeProperty = function (propertyName) {\n  const propertyNames = this._propertyNames;\n  const index = propertyNames.indexOf(propertyName);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(propertyName)) {\n    throw new DeveloperError(\"propertyName is required.\");\n  }\n  if (index === -1) {\n    throw new DeveloperError(`${propertyName} is not a registered property.`);\n  }\n  //>>includeEnd('debug');\n\n  this._propertyNames.splice(index, 1);\n  delete this[propertyName];\n\n  this._definitionChanged.raiseEvent(this);\n};\n\nconst timeScratch = new JulianDate();\n\n/**\n * Gets the value of this property.  Each contained property will be evaluated at the given time, and the overall\n * result will be an object, mapping property names to those values.\n *\n * @param {JulianDate} [time=JulianDate.now()] The time for which to retrieve the value. If omitted, the current system time is used.\n * @param {object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n * Note that any properties in result which are not part of this PropertyBag will be left as-is.\n * @returns {object} The modified result parameter or a new instance if the result parameter was not supplied.\n */\nPropertyBag.prototype.getValue = function (time, result) {\n  if (!defined(time)) {\n    time = JulianDate.now(timeScratch);\n  }\n\n  if (!defined(result)) {\n    result = {};\n  }\n\n  const propertyNames = this._propertyNames;\n  for (let i = 0, len = propertyNames.length; i < len; i++) {\n    const propertyName = propertyNames[i];\n    result[propertyName] = Property.getValueOrUndefined(\n      this[propertyName],\n      time,\n      result[propertyName],\n    );\n  }\n  return result;\n};\n\n/**\n * Assigns each unassigned property on this object to the value\n * of the same property on the provided source object.\n *\n * @param {object} source The object to be merged into this object.\n * @param {Function} [createPropertyCallback] A function that will be called when the value of any of the properties in value are not a Property.\n */\nPropertyBag.prototype.merge = function (source, createPropertyCallback) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(source)) {\n    throw new DeveloperError(\"source is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const propertyNames = this._propertyNames;\n  const sourcePropertyNames = defined(source._propertyNames)\n    ? source._propertyNames\n    : Object.keys(source);\n  for (let i = 0, len = sourcePropertyNames.length; i < len; i++) {\n    const name = sourcePropertyNames[i];\n\n    const targetProperty = this[name];\n    const sourceProperty = source[name];\n\n    //Custom properties that are registered on the source must also be added to this.\n    if (targetProperty === undefined && propertyNames.indexOf(name) === -1) {\n      this.addProperty(name, undefined, createPropertyCallback);\n    }\n\n    if (sourceProperty !== undefined) {\n      if (targetProperty !== undefined) {\n        if (defined(targetProperty) && defined(targetProperty.merge)) {\n          targetProperty.merge(sourceProperty);\n        }\n      } else if (\n        defined(sourceProperty) &&\n        defined(sourceProperty.merge) &&\n        defined(sourceProperty.clone)\n      ) {\n        this[name] = sourceProperty.clone();\n      } else {\n        this[name] = sourceProperty;\n      }\n    }\n  }\n};\n\nfunction propertiesEqual(a, b) {\n  const aPropertyNames = a._propertyNames;\n  const bPropertyNames = b._propertyNames;\n\n  const len = aPropertyNames.length;\n  if (len !== bPropertyNames.length) {\n    return false;\n  }\n\n  for (let aIndex = 0; aIndex < len; ++aIndex) {\n    const name = aPropertyNames[aIndex];\n    const bIndex = bPropertyNames.indexOf(name);\n    if (bIndex === -1) {\n      return false;\n    }\n    if (!Property.equals(a[name], b[name])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Compares this property to the provided property and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Property} [other] The other property.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nPropertyBag.prototype.equals = function (other) {\n  return (\n    this === other || //\n    (other instanceof PropertyBag && //\n      propertiesEqual(this, other))\n  );\n};\nexport default PropertyBag;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}