{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"// Main intersection function for Voxel scenes.\\n\\\n// See IntersectBox.glsl, IntersectCylinder.glsl, or IntersectEllipsoid.glsl\\n\\\n// for the definition of intersectShape. The appropriate function is selected\\n\\\n// based on the VoxelPrimitive shape type, and added to the shader in\\n\\\n// Scene/VoxelRenderResources.js.\\n\\\n// See also IntersectClippingPlane.glsl and IntersectDepth.glsl.\\n\\\n// See IntersectionUtils.glsl for the definitions of Ray, NO_HIT,\\n\\\n// getFirstIntersection, initializeIntersections, nextIntersection.\\n\\\n\\n\\\n/* Intersection defines (set in Scene/VoxelRenderResources.js)\\n\\\n#define INTERSECTION_COUNT ###\\n\\\n*/\\n\\\n\\n\\\nRayShapeIntersection intersectScene(in vec2 screenCoord, in Ray ray, in Ray rayEC, out Intersections ix) {\\n\\\n    // Do a ray-shape intersection to find the exact starting and ending points.\\n\\\n    intersectShape(ray, rayEC, ix);\\n\\\n\\n\\\n    // Exit early if the positive shape was completely missed or behind the ray.\\n\\\n    RayShapeIntersection intersection = getFirstIntersection(ix);\\n\\\n    if (intersection.entry.w == NO_HIT) {\\n\\\n        // Positive shape was completely missed - so exit early.\\n\\\n        return intersection;\\n\\\n    }\\n\\\n\\n\\\n    // Clipping planes\\n\\\n    #if defined(CLIPPING_PLANES)\\n\\\n        intersectClippingPlanes(ray, ix);\\n\\\n    #endif\\n\\\n\\n\\\n    // Depth\\n\\\n    intersectDepth(screenCoord, rayEC, ix);\\n\\\n\\n\\\n    // Find the first intersection that's in front of the ray\\n\\\n    #if (INTERSECTION_COUNT > 1)\\n\\\n        initializeIntersections(ix);\\n\\\n        for (int i = 0; i < INTERSECTION_COUNT; ++i) {\\n\\\n            intersection = nextIntersection(ix);\\n\\\n            if (intersection.exit.w > 0.0) {\\n\\\n                // Set start to 0.0 when ray is inside the shape.\\n\\\n                intersection.entry.w = max(intersection.entry.w, 0.0);\\n\\\n                break;\\n\\\n            }\\n\\\n        }\\n\\\n    #else\\n\\\n        // Set start to 0.0 when ray is inside the shape.\\n\\\n        intersection.entry.w = max(intersection.entry.w, 0.0);\\n\\\n    #endif\\n\\\n\\n\\\n    return intersection;\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Shaders/Voxels/Intersection.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"// Main intersection function for Voxel scenes.\\n\\\n// See IntersectBox.glsl, IntersectCylinder.glsl, or IntersectEllipsoid.glsl\\n\\\n// for the definition of intersectShape. The appropriate function is selected\\n\\\n// based on the VoxelPrimitive shape type, and added to the shader in\\n\\\n// Scene/VoxelRenderResources.js.\\n\\\n// See also IntersectClippingPlane.glsl and IntersectDepth.glsl.\\n\\\n// See IntersectionUtils.glsl for the definitions of Ray, NO_HIT,\\n\\\n// getFirstIntersection, initializeIntersections, nextIntersection.\\n\\\n\\n\\\n/* Intersection defines (set in Scene/VoxelRenderResources.js)\\n\\\n#define INTERSECTION_COUNT ###\\n\\\n*/\\n\\\n\\n\\\nRayShapeIntersection intersectScene(in vec2 screenCoord, in Ray ray, in Ray rayEC, out Intersections ix) {\\n\\\n    // Do a ray-shape intersection to find the exact starting and ending points.\\n\\\n    intersectShape(ray, rayEC, ix);\\n\\\n\\n\\\n    // Exit early if the positive shape was completely missed or behind the ray.\\n\\\n    RayShapeIntersection intersection = getFirstIntersection(ix);\\n\\\n    if (intersection.entry.w == NO_HIT) {\\n\\\n        // Positive shape was completely missed - so exit early.\\n\\\n        return intersection;\\n\\\n    }\\n\\\n\\n\\\n    // Clipping planes\\n\\\n    #if defined(CLIPPING_PLANES)\\n\\\n        intersectClippingPlanes(ray, ix);\\n\\\n    #endif\\n\\\n\\n\\\n    // Depth\\n\\\n    intersectDepth(screenCoord, rayEC, ix);\\n\\\n\\n\\\n    // Find the first intersection that's in front of the ray\\n\\\n    #if (INTERSECTION_COUNT > 1)\\n\\\n        initializeIntersections(ix);\\n\\\n        for (int i = 0; i < INTERSECTION_COUNT; ++i) {\\n\\\n            intersection = nextIntersection(ix);\\n\\\n            if (intersection.exit.w > 0.0) {\\n\\\n                // Set start to 0.0 when ray is inside the shape.\\n\\\n                intersection.entry.w = max(intersection.entry.w, 0.0);\\n\\\n                break;\\n\\\n            }\\n\\\n        }\\n\\\n    #else\\n\\\n        // Set start to 0.0 when ray is inside the shape.\\n\\\n        intersection.entry.w = max(intersection.entry.w, 0.0);\\n\\\n    #endif\\n\\\n\\n\\\n    return intersection;\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}