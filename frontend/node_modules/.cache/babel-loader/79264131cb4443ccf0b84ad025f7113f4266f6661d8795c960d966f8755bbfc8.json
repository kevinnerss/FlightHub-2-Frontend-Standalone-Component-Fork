{"ast":null,"code":"import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * Functions that do scene-dependent transforms between rendering-related coordinate systems.\n *\n * @namespace SceneTransforms\n */\nconst SceneTransforms = {};\nconst actualPositionScratch = new Cartesian4(0, 0, 0, 1);\nlet positionCC = new Cartesian4();\nconst scratchViewport = new BoundingRectangle();\nconst scratchWindowCoord0 = new Cartesian2();\nconst scratchWindowCoord1 = new Cartesian2();\n\n/**\n * Transforms a position in world (WGS84 or alternative ellipsoid) coordinates to window coordinates.  This is commonly used to place an\n * HTML element at the same screen position as an object in the scene.\n *\n * @param {Scene} scene The scene.\n * @param {Cartesian3} position The position in world (WGS84 or alternative ellipsoid) coordinates.\n * @param {Cartesian2} [result] An optional object to return the input position transformed to window coordinates.\n * @returns {Cartesian2|undefined} The modified result parameter or a new Cartesian2 instance if one was not provided.  This may be <code>undefined</code> if the input position is near the center of the ellipsoid.\n *\n * @example\n * // Output the window position of longitude/latitude (0, 0) every time the mouse moves.\n * const position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);\n * handler.setInputAction(function(movement) {\n *     console.log(Cesium.SceneTransforms.worldToWindowCoordinates(scene, position));\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n */\nSceneTransforms.worldToWindowCoordinates = function (scene, position, result) {\n  return SceneTransforms.worldWithEyeOffsetToWindowCoordinates(scene, position, Cartesian3.ZERO, result);\n};\nconst scratchCartesian4 = new Cartesian4();\nconst scratchEyeOffset = new Cartesian3();\nfunction worldToClip(position, eyeOffset, camera, result) {\n  const viewMatrix = camera.viewMatrix;\n  const positionEC = Matrix4.multiplyByVector(viewMatrix, Cartesian4.fromElements(position.x, position.y, position.z, 1, scratchCartesian4), scratchCartesian4);\n  const zEyeOffset = Cartesian3.multiplyComponents(eyeOffset, Cartesian3.normalize(positionEC, scratchEyeOffset), scratchEyeOffset);\n  positionEC.x += eyeOffset.x + zEyeOffset.x;\n  positionEC.y += eyeOffset.y + zEyeOffset.y;\n  positionEC.z += zEyeOffset.z;\n  return Matrix4.multiplyByVector(camera.frustum.projectionMatrix, positionEC, result);\n}\nconst scratchMaxCartographic = new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO);\nconst scratchProjectedCartesian = new Cartesian3();\nconst scratchCameraPosition = new Cartesian3();\n\n/**\n * @private\n */\nSceneTransforms.worldWithEyeOffsetToWindowCoordinates = function (scene, position, eyeOffset, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // Transform for 3D, 2D, or Columbus view\n  const frameState = scene.frameState;\n  const actualPosition = SceneTransforms.computeActualEllipsoidPosition(frameState, position, actualPositionScratch);\n  if (!defined(actualPosition)) {\n    return undefined;\n  }\n\n  // Assuming viewport takes up the entire canvas...\n  const canvas = scene.canvas;\n  const viewport = scratchViewport;\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = canvas.clientWidth;\n  viewport.height = canvas.clientHeight;\n  const camera = scene.camera;\n  let cameraCentered = false;\n  if (frameState.mode === SceneMode.SCENE2D) {\n    const projection = scene.mapProjection;\n    const maxCartographic = scratchMaxCartographic;\n    const maxCoord = projection.project(maxCartographic, scratchProjectedCartesian);\n    const cameraPosition = Cartesian3.clone(camera.position, scratchCameraPosition);\n    const frustum = camera.frustum.clone();\n    const viewportTransformation = Matrix4.computeViewportTransformation(viewport, 0.0, 1.0, new Matrix4());\n    const projectionMatrix = camera.frustum.projectionMatrix;\n    const x = camera.positionWC.y;\n    const eyePoint = Cartesian3.fromElements(CesiumMath.sign(x) * maxCoord.x - x, 0.0, -camera.positionWC.x);\n    const windowCoordinates = Transforms.pointToGLWindowCoordinates(projectionMatrix, viewportTransformation, eyePoint);\n    if (x === 0.0 || windowCoordinates.x <= 0.0 || windowCoordinates.x >= canvas.clientWidth) {\n      cameraCentered = true;\n    } else {\n      if (windowCoordinates.x > canvas.clientWidth * 0.5) {\n        viewport.width = windowCoordinates.x;\n        camera.frustum.right = maxCoord.x - x;\n        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n        SceneTransforms.clipToGLWindowCoordinates(viewport, positionCC, scratchWindowCoord0);\n        viewport.x += windowCoordinates.x;\n        camera.position.x = -camera.position.x;\n        const right = camera.frustum.right;\n        camera.frustum.right = -camera.frustum.left;\n        camera.frustum.left = -right;\n        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n        SceneTransforms.clipToGLWindowCoordinates(viewport, positionCC, scratchWindowCoord1);\n      } else {\n        viewport.x += windowCoordinates.x;\n        viewport.width -= windowCoordinates.x;\n        camera.frustum.left = -maxCoord.x - x;\n        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n        SceneTransforms.clipToGLWindowCoordinates(viewport, positionCC, scratchWindowCoord0);\n        viewport.x = viewport.x - viewport.width;\n        camera.position.x = -camera.position.x;\n        const left = camera.frustum.left;\n        camera.frustum.left = -camera.frustum.right;\n        camera.frustum.right = -left;\n        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n        SceneTransforms.clipToGLWindowCoordinates(viewport, positionCC, scratchWindowCoord1);\n      }\n      Cartesian3.clone(cameraPosition, camera.position);\n      camera.frustum = frustum.clone();\n      result = Cartesian2.clone(scratchWindowCoord0, result);\n      if (result.x < 0.0 || result.x > canvas.clientWidth) {\n        result.x = scratchWindowCoord1.x;\n      }\n    }\n  }\n  if (frameState.mode !== SceneMode.SCENE2D || cameraCentered) {\n    // View-projection matrix to transform from world coordinates to clip coordinates\n    positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n    if (positionCC.z < 0 && !(camera.frustum instanceof OrthographicFrustum) && !(camera.frustum instanceof OrthographicOffCenterFrustum)) {\n      return undefined;\n    }\n    result = SceneTransforms.clipToGLWindowCoordinates(viewport, positionCC, result);\n  }\n  result.y = canvas.clientHeight - result.y;\n  return result;\n};\n\n/**\n * Transforms a position in world coordinates to drawing buffer coordinates.  This may produce different\n * results from SceneTransforms.worldToWindowCoordinates when the browser zoom is not 100%, or on high-DPI displays.\n *\n * @param {Scene} scene The scene.\n * @param {Cartesian3} position The position in world (WGS84 or alternative ellipsoid) coordinates.\n * @param {Cartesian2} [result] An optional object to return the input position transformed to window coordinates.\n * @returns {Cartesian2|undefined} The modified result parameter or a new Cartesian2 instance if one was not provided.  This may be <code>undefined</code> if the input position is near the center of the ellipsoid.\n *\n * @example\n * // Output the window position of longitude/latitude (0, 0) every time the mouse moves.\n * const position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);\n * handler.setInputAction(function(movement) {\n *     console.log(Cesium.SceneTransforms.worldToDrawingBufferCoordinates(scene, position));\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n */\nSceneTransforms.worldToDrawingBufferCoordinates = function (scene, position, result) {\n  result = SceneTransforms.worldToWindowCoordinates(scene, position, result);\n  if (!defined(result)) {\n    return undefined;\n  }\n  return SceneTransforms.transformWindowToDrawingBuffer(scene, result, result);\n};\nconst projectedPosition = new Cartesian3();\nconst positionInCartographic = new Cartographic();\n\n/**\n * @private\n */\nSceneTransforms.computeActualEllipsoidPosition = function (frameState, position, result) {\n  const mode = frameState.mode;\n  if (mode === SceneMode.SCENE3D) {\n    return Cartesian3.clone(position, result);\n  }\n  const projection = frameState.mapProjection;\n  const cartographic = projection.ellipsoid.cartesianToCartographic(position, positionInCartographic);\n  if (!defined(cartographic)) {\n    return undefined;\n  }\n  projection.project(cartographic, projectedPosition);\n  if (mode === SceneMode.COLUMBUS_VIEW) {\n    return Cartesian3.fromElements(projectedPosition.z, projectedPosition.x, projectedPosition.y, result);\n  }\n  if (mode === SceneMode.SCENE2D) {\n    return Cartesian3.fromElements(0.0, projectedPosition.x, projectedPosition.y, result);\n  }\n\n  // mode === SceneMode.MORPHING\n  const morphTime = frameState.morphTime;\n  return Cartesian3.fromElements(CesiumMath.lerp(projectedPosition.z, position.x, morphTime), CesiumMath.lerp(projectedPosition.x, position.y, morphTime), CesiumMath.lerp(projectedPosition.y, position.z, morphTime), result);\n};\nconst positionNDC = new Cartesian3();\nconst positionWC = new Cartesian3();\nconst viewportTransform = new Matrix4();\n\n/**\n * @private\n */\nSceneTransforms.clipToGLWindowCoordinates = function (viewport, position, result) {\n  // Perspective divide to transform from clip coordinates to normalized device coordinates\n  Cartesian3.divideByScalar(position, position.w, positionNDC);\n\n  // Viewport transform to transform from clip coordinates to window coordinates\n  Matrix4.computeViewportTransformation(viewport, 0.0, 1.0, viewportTransform);\n  Matrix4.multiplyByPoint(viewportTransform, positionNDC, positionWC);\n  return Cartesian2.fromCartesian3(positionWC, result);\n};\n\n/**\n * @private\n */\nSceneTransforms.transformWindowToDrawingBuffer = function (scene, windowPosition, result) {\n  const canvas = scene.canvas;\n  const xScale = scene.drawingBufferWidth / canvas.clientWidth;\n  const yScale = scene.drawingBufferHeight / canvas.clientHeight;\n  return Cartesian2.fromElements(windowPosition.x * xScale, windowPosition.y * yScale, result);\n};\nconst scratchNDC = new Cartesian4();\nconst scratchWorldCoords = new Cartesian4();\n\n/**\n * @private\n */\nSceneTransforms.drawingBufferToWorldCoordinates = function (scene, drawingBufferPosition, depth, result) {\n  const context = scene.context;\n  const uniformState = context.uniformState;\n  const currentFrustum = uniformState.currentFrustum;\n  const near = currentFrustum.x;\n  const far = currentFrustum.y;\n  if (scene.frameState.useLogDepth) {\n    // transforming logarithmic depth of form\n    // log2(z + 1) / log2( far + 1);\n    // to perspective form\n    // (far - far * near / z) / (far - near)\n    const log2Depth = depth * uniformState.log2FarDepthFromNearPlusOne;\n    const depthFromNear = Math.pow(2.0, log2Depth) - 1.0;\n    depth = far * (1.0 - near / (depthFromNear + near)) / (far - near);\n  }\n  const viewport = scene.view.passState.viewport;\n  const ndc = Cartesian4.clone(Cartesian4.UNIT_W, scratchNDC);\n  ndc.x = (drawingBufferPosition.x - viewport.x) / viewport.width * 2.0 - 1.0;\n  ndc.y = (drawingBufferPosition.y - viewport.y) / viewport.height * 2.0 - 1.0;\n  ndc.z = depth * 2.0 - 1.0;\n  ndc.w = 1.0;\n  let worldCoords;\n  let frustum = scene.camera.frustum;\n  if (!defined(frustum.fovy)) {\n    const offCenterFrustum = frustum.offCenterFrustum;\n    if (defined(offCenterFrustum)) {\n      frustum = offCenterFrustum;\n    }\n    worldCoords = scratchWorldCoords;\n    worldCoords.x = (ndc.x * (frustum.right - frustum.left) + frustum.left + frustum.right) * 0.5;\n    worldCoords.y = (ndc.y * (frustum.top - frustum.bottom) + frustum.bottom + frustum.top) * 0.5;\n    worldCoords.z = (ndc.z * (near - far) - near - far) * 0.5;\n    worldCoords.w = 1.0;\n    worldCoords = Matrix4.multiplyByVector(uniformState.inverseView, worldCoords, worldCoords);\n  } else {\n    worldCoords = Matrix4.multiplyByVector(uniformState.inverseViewProjection, ndc, scratchWorldCoords);\n\n    // Reverse perspective divide\n    const w = 1.0 / worldCoords.w;\n    Cartesian3.multiplyByScalar(worldCoords, w, worldCoords);\n  }\n  return Cartesian3.fromCartesian4(worldCoords, result);\n};\nexport default SceneTransforms;","map":{"version":3,"names":["BoundingRectangle","Cartesian2","Cartesian3","Cartesian4","Cartographic","defined","DeveloperError","CesiumMath","Matrix4","OrthographicFrustum","OrthographicOffCenterFrustum","Transforms","SceneMode","SceneTransforms","actualPositionScratch","positionCC","scratchViewport","scratchWindowCoord0","scratchWindowCoord1","worldToWindowCoordinates","scene","position","result","worldWithEyeOffsetToWindowCoordinates","ZERO","scratchCartesian4","scratchEyeOffset","worldToClip","eyeOffset","camera","viewMatrix","positionEC","multiplyByVector","fromElements","x","y","z","zEyeOffset","multiplyComponents","normalize","frustum","projectionMatrix","scratchMaxCartographic","Math","PI","PI_OVER_TWO","scratchProjectedCartesian","scratchCameraPosition","frameState","actualPosition","computeActualEllipsoidPosition","undefined","canvas","viewport","width","clientWidth","height","clientHeight","cameraCentered","mode","SCENE2D","projection","mapProjection","maxCartographic","maxCoord","project","cameraPosition","clone","viewportTransformation","computeViewportTransformation","positionWC","eyePoint","sign","windowCoordinates","pointToGLWindowCoordinates","right","clipToGLWindowCoordinates","left","worldToDrawingBufferCoordinates","transformWindowToDrawingBuffer","projectedPosition","positionInCartographic","SCENE3D","cartographic","ellipsoid","cartesianToCartographic","COLUMBUS_VIEW","morphTime","lerp","positionNDC","viewportTransform","divideByScalar","w","multiplyByPoint","fromCartesian3","windowPosition","xScale","drawingBufferWidth","yScale","drawingBufferHeight","scratchNDC","scratchWorldCoords","drawingBufferToWorldCoordinates","drawingBufferPosition","depth","context","uniformState","currentFrustum","near","far","useLogDepth","log2Depth","log2FarDepthFromNearPlusOne","depthFromNear","pow","view","passState","ndc","UNIT_W","worldCoords","fovy","offCenterFrustum","top","bottom","inverseView","inverseViewProjection","multiplyByScalar","fromCartesian4"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/SceneTransforms.js"],"sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * Functions that do scene-dependent transforms between rendering-related coordinate systems.\n *\n * @namespace SceneTransforms\n */\nconst SceneTransforms = {};\n\nconst actualPositionScratch = new Cartesian4(0, 0, 0, 1);\nlet positionCC = new Cartesian4();\nconst scratchViewport = new BoundingRectangle();\n\nconst scratchWindowCoord0 = new Cartesian2();\nconst scratchWindowCoord1 = new Cartesian2();\n\n/**\n * Transforms a position in world (WGS84 or alternative ellipsoid) coordinates to window coordinates.  This is commonly used to place an\n * HTML element at the same screen position as an object in the scene.\n *\n * @param {Scene} scene The scene.\n * @param {Cartesian3} position The position in world (WGS84 or alternative ellipsoid) coordinates.\n * @param {Cartesian2} [result] An optional object to return the input position transformed to window coordinates.\n * @returns {Cartesian2|undefined} The modified result parameter or a new Cartesian2 instance if one was not provided.  This may be <code>undefined</code> if the input position is near the center of the ellipsoid.\n *\n * @example\n * // Output the window position of longitude/latitude (0, 0) every time the mouse moves.\n * const position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);\n * handler.setInputAction(function(movement) {\n *     console.log(Cesium.SceneTransforms.worldToWindowCoordinates(scene, position));\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n */\nSceneTransforms.worldToWindowCoordinates = function (scene, position, result) {\n  return SceneTransforms.worldWithEyeOffsetToWindowCoordinates(\n    scene,\n    position,\n    Cartesian3.ZERO,\n    result,\n  );\n};\n\nconst scratchCartesian4 = new Cartesian4();\nconst scratchEyeOffset = new Cartesian3();\n\nfunction worldToClip(position, eyeOffset, camera, result) {\n  const viewMatrix = camera.viewMatrix;\n\n  const positionEC = Matrix4.multiplyByVector(\n    viewMatrix,\n    Cartesian4.fromElements(\n      position.x,\n      position.y,\n      position.z,\n      1,\n      scratchCartesian4,\n    ),\n    scratchCartesian4,\n  );\n\n  const zEyeOffset = Cartesian3.multiplyComponents(\n    eyeOffset,\n    Cartesian3.normalize(positionEC, scratchEyeOffset),\n    scratchEyeOffset,\n  );\n  positionEC.x += eyeOffset.x + zEyeOffset.x;\n  positionEC.y += eyeOffset.y + zEyeOffset.y;\n  positionEC.z += zEyeOffset.z;\n\n  return Matrix4.multiplyByVector(\n    camera.frustum.projectionMatrix,\n    positionEC,\n    result,\n  );\n}\n\nconst scratchMaxCartographic = new Cartographic(\n  Math.PI,\n  CesiumMath.PI_OVER_TWO,\n);\nconst scratchProjectedCartesian = new Cartesian3();\nconst scratchCameraPosition = new Cartesian3();\n\n/**\n * @private\n */\nSceneTransforms.worldWithEyeOffsetToWindowCoordinates = function (\n  scene,\n  position,\n  eyeOffset,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // Transform for 3D, 2D, or Columbus view\n  const frameState = scene.frameState;\n  const actualPosition = SceneTransforms.computeActualEllipsoidPosition(\n    frameState,\n    position,\n    actualPositionScratch,\n  );\n\n  if (!defined(actualPosition)) {\n    return undefined;\n  }\n\n  // Assuming viewport takes up the entire canvas...\n  const canvas = scene.canvas;\n  const viewport = scratchViewport;\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = canvas.clientWidth;\n  viewport.height = canvas.clientHeight;\n\n  const camera = scene.camera;\n  let cameraCentered = false;\n\n  if (frameState.mode === SceneMode.SCENE2D) {\n    const projection = scene.mapProjection;\n    const maxCartographic = scratchMaxCartographic;\n    const maxCoord = projection.project(\n      maxCartographic,\n      scratchProjectedCartesian,\n    );\n\n    const cameraPosition = Cartesian3.clone(\n      camera.position,\n      scratchCameraPosition,\n    );\n    const frustum = camera.frustum.clone();\n\n    const viewportTransformation = Matrix4.computeViewportTransformation(\n      viewport,\n      0.0,\n      1.0,\n      new Matrix4(),\n    );\n    const projectionMatrix = camera.frustum.projectionMatrix;\n\n    const x = camera.positionWC.y;\n    const eyePoint = Cartesian3.fromElements(\n      CesiumMath.sign(x) * maxCoord.x - x,\n      0.0,\n      -camera.positionWC.x,\n    );\n    const windowCoordinates = Transforms.pointToGLWindowCoordinates(\n      projectionMatrix,\n      viewportTransformation,\n      eyePoint,\n    );\n\n    if (\n      x === 0.0 ||\n      windowCoordinates.x <= 0.0 ||\n      windowCoordinates.x >= canvas.clientWidth\n    ) {\n      cameraCentered = true;\n    } else {\n      if (windowCoordinates.x > canvas.clientWidth * 0.5) {\n        viewport.width = windowCoordinates.x;\n\n        camera.frustum.right = maxCoord.x - x;\n\n        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n        SceneTransforms.clipToGLWindowCoordinates(\n          viewport,\n          positionCC,\n          scratchWindowCoord0,\n        );\n\n        viewport.x += windowCoordinates.x;\n\n        camera.position.x = -camera.position.x;\n\n        const right = camera.frustum.right;\n        camera.frustum.right = -camera.frustum.left;\n        camera.frustum.left = -right;\n\n        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n        SceneTransforms.clipToGLWindowCoordinates(\n          viewport,\n          positionCC,\n          scratchWindowCoord1,\n        );\n      } else {\n        viewport.x += windowCoordinates.x;\n        viewport.width -= windowCoordinates.x;\n\n        camera.frustum.left = -maxCoord.x - x;\n\n        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n        SceneTransforms.clipToGLWindowCoordinates(\n          viewport,\n          positionCC,\n          scratchWindowCoord0,\n        );\n\n        viewport.x = viewport.x - viewport.width;\n\n        camera.position.x = -camera.position.x;\n\n        const left = camera.frustum.left;\n        camera.frustum.left = -camera.frustum.right;\n        camera.frustum.right = -left;\n\n        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n        SceneTransforms.clipToGLWindowCoordinates(\n          viewport,\n          positionCC,\n          scratchWindowCoord1,\n        );\n      }\n\n      Cartesian3.clone(cameraPosition, camera.position);\n      camera.frustum = frustum.clone();\n\n      result = Cartesian2.clone(scratchWindowCoord0, result);\n      if (result.x < 0.0 || result.x > canvas.clientWidth) {\n        result.x = scratchWindowCoord1.x;\n      }\n    }\n  }\n\n  if (frameState.mode !== SceneMode.SCENE2D || cameraCentered) {\n    // View-projection matrix to transform from world coordinates to clip coordinates\n    positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n    if (\n      positionCC.z < 0 &&\n      !(camera.frustum instanceof OrthographicFrustum) &&\n      !(camera.frustum instanceof OrthographicOffCenterFrustum)\n    ) {\n      return undefined;\n    }\n\n    result = SceneTransforms.clipToGLWindowCoordinates(\n      viewport,\n      positionCC,\n      result,\n    );\n  }\n\n  result.y = canvas.clientHeight - result.y;\n  return result;\n};\n\n/**\n * Transforms a position in world coordinates to drawing buffer coordinates.  This may produce different\n * results from SceneTransforms.worldToWindowCoordinates when the browser zoom is not 100%, or on high-DPI displays.\n *\n * @param {Scene} scene The scene.\n * @param {Cartesian3} position The position in world (WGS84 or alternative ellipsoid) coordinates.\n * @param {Cartesian2} [result] An optional object to return the input position transformed to window coordinates.\n * @returns {Cartesian2|undefined} The modified result parameter or a new Cartesian2 instance if one was not provided.  This may be <code>undefined</code> if the input position is near the center of the ellipsoid.\n *\n * @example\n * // Output the window position of longitude/latitude (0, 0) every time the mouse moves.\n * const position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);\n * handler.setInputAction(function(movement) {\n *     console.log(Cesium.SceneTransforms.worldToDrawingBufferCoordinates(scene, position));\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n */\nSceneTransforms.worldToDrawingBufferCoordinates = function (\n  scene,\n  position,\n  result,\n) {\n  result = SceneTransforms.worldToWindowCoordinates(scene, position, result);\n  if (!defined(result)) {\n    return undefined;\n  }\n\n  return SceneTransforms.transformWindowToDrawingBuffer(scene, result, result);\n};\n\nconst projectedPosition = new Cartesian3();\nconst positionInCartographic = new Cartographic();\n\n/**\n * @private\n */\nSceneTransforms.computeActualEllipsoidPosition = function (\n  frameState,\n  position,\n  result,\n) {\n  const mode = frameState.mode;\n\n  if (mode === SceneMode.SCENE3D) {\n    return Cartesian3.clone(position, result);\n  }\n\n  const projection = frameState.mapProjection;\n  const cartographic = projection.ellipsoid.cartesianToCartographic(\n    position,\n    positionInCartographic,\n  );\n  if (!defined(cartographic)) {\n    return undefined;\n  }\n\n  projection.project(cartographic, projectedPosition);\n\n  if (mode === SceneMode.COLUMBUS_VIEW) {\n    return Cartesian3.fromElements(\n      projectedPosition.z,\n      projectedPosition.x,\n      projectedPosition.y,\n      result,\n    );\n  }\n\n  if (mode === SceneMode.SCENE2D) {\n    return Cartesian3.fromElements(\n      0.0,\n      projectedPosition.x,\n      projectedPosition.y,\n      result,\n    );\n  }\n\n  // mode === SceneMode.MORPHING\n  const morphTime = frameState.morphTime;\n  return Cartesian3.fromElements(\n    CesiumMath.lerp(projectedPosition.z, position.x, morphTime),\n    CesiumMath.lerp(projectedPosition.x, position.y, morphTime),\n    CesiumMath.lerp(projectedPosition.y, position.z, morphTime),\n    result,\n  );\n};\n\nconst positionNDC = new Cartesian3();\nconst positionWC = new Cartesian3();\nconst viewportTransform = new Matrix4();\n\n/**\n * @private\n */\nSceneTransforms.clipToGLWindowCoordinates = function (\n  viewport,\n  position,\n  result,\n) {\n  // Perspective divide to transform from clip coordinates to normalized device coordinates\n  Cartesian3.divideByScalar(position, position.w, positionNDC);\n\n  // Viewport transform to transform from clip coordinates to window coordinates\n  Matrix4.computeViewportTransformation(viewport, 0.0, 1.0, viewportTransform);\n  Matrix4.multiplyByPoint(viewportTransform, positionNDC, positionWC);\n\n  return Cartesian2.fromCartesian3(positionWC, result);\n};\n\n/**\n * @private\n */\nSceneTransforms.transformWindowToDrawingBuffer = function (\n  scene,\n  windowPosition,\n  result,\n) {\n  const canvas = scene.canvas;\n  const xScale = scene.drawingBufferWidth / canvas.clientWidth;\n  const yScale = scene.drawingBufferHeight / canvas.clientHeight;\n  return Cartesian2.fromElements(\n    windowPosition.x * xScale,\n    windowPosition.y * yScale,\n    result,\n  );\n};\n\nconst scratchNDC = new Cartesian4();\nconst scratchWorldCoords = new Cartesian4();\n\n/**\n * @private\n */\nSceneTransforms.drawingBufferToWorldCoordinates = function (\n  scene,\n  drawingBufferPosition,\n  depth,\n  result,\n) {\n  const context = scene.context;\n  const uniformState = context.uniformState;\n\n  const currentFrustum = uniformState.currentFrustum;\n  const near = currentFrustum.x;\n  const far = currentFrustum.y;\n\n  if (scene.frameState.useLogDepth) {\n    // transforming logarithmic depth of form\n    // log2(z + 1) / log2( far + 1);\n    // to perspective form\n    // (far - far * near / z) / (far - near)\n    const log2Depth = depth * uniformState.log2FarDepthFromNearPlusOne;\n    const depthFromNear = Math.pow(2.0, log2Depth) - 1.0;\n    depth = (far * (1.0 - near / (depthFromNear + near))) / (far - near);\n  }\n\n  const viewport = scene.view.passState.viewport;\n  const ndc = Cartesian4.clone(Cartesian4.UNIT_W, scratchNDC);\n  ndc.x = ((drawingBufferPosition.x - viewport.x) / viewport.width) * 2.0 - 1.0;\n  ndc.y =\n    ((drawingBufferPosition.y - viewport.y) / viewport.height) * 2.0 - 1.0;\n  ndc.z = depth * 2.0 - 1.0;\n  ndc.w = 1.0;\n\n  let worldCoords;\n  let frustum = scene.camera.frustum;\n  if (!defined(frustum.fovy)) {\n    const offCenterFrustum = frustum.offCenterFrustum;\n    if (defined(offCenterFrustum)) {\n      frustum = offCenterFrustum;\n    }\n    worldCoords = scratchWorldCoords;\n    worldCoords.x =\n      (ndc.x * (frustum.right - frustum.left) + frustum.left + frustum.right) *\n      0.5;\n    worldCoords.y =\n      (ndc.y * (frustum.top - frustum.bottom) + frustum.bottom + frustum.top) *\n      0.5;\n    worldCoords.z = (ndc.z * (near - far) - near - far) * 0.5;\n    worldCoords.w = 1.0;\n\n    worldCoords = Matrix4.multiplyByVector(\n      uniformState.inverseView,\n      worldCoords,\n      worldCoords,\n    );\n  } else {\n    worldCoords = Matrix4.multiplyByVector(\n      uniformState.inverseViewProjection,\n      ndc,\n      scratchWorldCoords,\n    );\n\n    // Reverse perspective divide\n    const w = 1.0 / worldCoords.w;\n    Cartesian3.multiplyByScalar(worldCoords, w, worldCoords);\n  }\n  return Cartesian3.fromCartesian4(worldCoords, result);\n};\nexport default SceneTransforms;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}