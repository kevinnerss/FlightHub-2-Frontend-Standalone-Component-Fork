{"ast":null,"code":"import Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Spline from \"./Spline.js\";\nfunction createEvaluateFunction(spline) {\n  const points = spline.points;\n  const times = spline.times;\n\n  // use slerp interpolation\n  return function (time, result) {\n    if (!defined(result)) {\n      result = new Quaternion();\n    }\n    const i = spline._lastTimeIndex = spline.findTimeInterval(time, spline._lastTimeIndex);\n    const u = (time - times[i]) / (times[i + 1] - times[i]);\n    const q0 = points[i];\n    const q1 = points[i + 1];\n    return Quaternion.fastSlerp(q0, q1, u, result);\n  };\n}\n\n/**\n * A spline that uses spherical linear (slerp) interpolation to create a quaternion curve.\n * The generated curve is in the class C<sup>1</sup>.\n *\n * @alias QuaternionSpline\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Quaternion[]} options.points The array of {@link Quaternion} control points.\n *\n * @exception {DeveloperError} points and times are required\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n\n * @see ConstantSpline\n * @see SteppedSpline\n * @see HermiteSpline\n * @see CatmullRomSpline\n * @see LinearSpline\n * @see MorphWeightSpline\n */\nfunction QuaternionSpline(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const points = options.points;\n  const times = options.times;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times)) {\n    throw new DeveloperError(\"points and times are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\"points.length must be greater than or equal to 2.\");\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  //>>includeEnd('debug');\n\n  this._times = times;\n  this._points = points;\n  this._evaluateFunction = createEvaluateFunction(this);\n  this._lastTimeIndex = 0;\n}\nObject.defineProperties(QuaternionSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof QuaternionSpline.prototype\n   *\n   * @type {number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    }\n  },\n  /**\n   * An array of {@link Quaternion} control points.\n   *\n   * @memberof QuaternionSpline.prototype\n   *\n   * @type {Quaternion[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    }\n  }\n});\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {number} time The time.\n * @returns {number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nQuaternionSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, wrapped around to the updated animation.\n */\nQuaternionSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, clamped to the animation period.\n */\nQuaternionSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {number} time The time at which to evaluate the curve.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nQuaternionSpline.prototype.evaluate = function (time, result) {\n  return this._evaluateFunction(time, result);\n};\nexport default QuaternionSpline;","map":{"version":3,"names":["Frozen","defined","DeveloperError","Quaternion","Spline","createEvaluateFunction","spline","points","times","time","result","i","_lastTimeIndex","findTimeInterval","u","q0","q1","fastSlerp","QuaternionSpline","options","EMPTY_OBJECT","length","_times","_points","_evaluateFunction","Object","defineProperties","prototype","get","wrapTime","clampTime","evaluate"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/QuaternionSpline.js"],"sourcesContent":["import Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Spline from \"./Spline.js\";\n\nfunction createEvaluateFunction(spline) {\n  const points = spline.points;\n  const times = spline.times;\n\n  // use slerp interpolation\n  return function (time, result) {\n    if (!defined(result)) {\n      result = new Quaternion();\n    }\n    const i = (spline._lastTimeIndex = spline.findTimeInterval(\n      time,\n      spline._lastTimeIndex,\n    ));\n    const u = (time - times[i]) / (times[i + 1] - times[i]);\n\n    const q0 = points[i];\n    const q1 = points[i + 1];\n\n    return Quaternion.fastSlerp(q0, q1, u, result);\n  };\n}\n\n/**\n * A spline that uses spherical linear (slerp) interpolation to create a quaternion curve.\n * The generated curve is in the class C<sup>1</sup>.\n *\n * @alias QuaternionSpline\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Quaternion[]} options.points The array of {@link Quaternion} control points.\n *\n * @exception {DeveloperError} points and times are required\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n\n * @see ConstantSpline\n * @see SteppedSpline\n * @see HermiteSpline\n * @see CatmullRomSpline\n * @see LinearSpline\n * @see MorphWeightSpline\n */\nfunction QuaternionSpline(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const points = options.points;\n  const times = options.times;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times)) {\n    throw new DeveloperError(\"points and times are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\",\n    );\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  //>>includeEnd('debug');\n\n  this._times = times;\n  this._points = points;\n\n  this._evaluateFunction = createEvaluateFunction(this);\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(QuaternionSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof QuaternionSpline.prototype\n   *\n   * @type {number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n  },\n\n  /**\n   * An array of {@link Quaternion} control points.\n   *\n   * @memberof QuaternionSpline.prototype\n   *\n   * @type {Quaternion[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    },\n  },\n});\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {number} time The time.\n * @returns {number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nQuaternionSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, wrapped around to the updated animation.\n */\nQuaternionSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, clamped to the animation period.\n */\nQuaternionSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {number} time The time at which to evaluate the curve.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nQuaternionSpline.prototype.evaluate = function (time, result) {\n  return this._evaluateFunction(time, result);\n};\nexport default QuaternionSpline;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}