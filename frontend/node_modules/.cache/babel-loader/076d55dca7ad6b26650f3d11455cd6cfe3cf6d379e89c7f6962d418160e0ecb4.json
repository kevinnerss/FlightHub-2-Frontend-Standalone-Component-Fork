{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport combine from \"../Core/combine.js\";\nimport defined from \"../Core/defined.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport CullFace from \"./CullFace.js\";\nimport SceneMode from \"./SceneMode.js\";\nconst DerivedCommandType = {\n  OPAQUE_FRONT_FACE: 0,\n  OPAQUE_BACK_FACE: 1,\n  DEPTH_ONLY_FRONT_FACE: 2,\n  DEPTH_ONLY_BACK_FACE: 3,\n  DEPTH_ONLY_FRONT_AND_BACK_FACE: 4,\n  TRANSLUCENT_FRONT_FACE: 5,\n  TRANSLUCENT_BACK_FACE: 6,\n  TRANSLUCENT_FRONT_FACE_MANUAL_DEPTH_TEST: 7,\n  TRANSLUCENT_BACK_FACE_MANUAL_DEPTH_TEST: 8,\n  PICK_FRONT_FACE: 9,\n  PICK_BACK_FACE: 10,\n  DERIVED_COMMANDS_MAXIMUM_LENGTH: 11\n};\nconst derivedCommandsMaximumLength = DerivedCommandType.DERIVED_COMMANDS_MAXIMUM_LENGTH;\nconst DerivedCommandNames = [\"opaqueFrontFaceCommand\", \"opaqueBackFaceCommand\", \"depthOnlyFrontFaceCommand\", \"depthOnlyBackFaceCommand\", \"depthOnlyFrontAndBackFaceCommand\", \"translucentFrontFaceCommand\", \"translucentBackFaceCommand\", \"translucentFrontFaceManualDepthTestCommand\", \"translucentBackFaceManualDepthTestCommand\", \"pickFrontFaceCommand\", \"pickBackFaceCommand\"];\n\n/**\n * @private\n */\nfunction GlobeTranslucencyState() {\n  this._frontFaceAlphaByDistance = new NearFarScalar(0.0, 1.0, 0.0, 1.0);\n  this._backFaceAlphaByDistance = new NearFarScalar(0.0, 1.0, 0.0, 1.0);\n  this._frontFaceTranslucent = false;\n  this._backFaceTranslucent = false;\n  this._requiresManualDepthTest = false;\n  this._sunVisibleThroughGlobe = false;\n  this._environmentVisible = false;\n  this._useDepthPlane = false;\n  this._numberOfTextureUniforms = 0;\n  this._globeTranslucencyFramebuffer = undefined;\n  this._rectangle = Rectangle.clone(Rectangle.MAX_VALUE);\n  this._derivedCommandKey = 0;\n  this._derivedCommandsDirty = false;\n  this._derivedCommandPacks = undefined;\n  this._derivedCommandTypes = new Array(derivedCommandsMaximumLength);\n  this._derivedBlendCommandTypes = new Array(derivedCommandsMaximumLength);\n  this._derivedPickCommandTypes = new Array(derivedCommandsMaximumLength);\n  this._derivedCommandTypesToUpdate = new Array(derivedCommandsMaximumLength);\n  this._derivedCommandsLength = 0;\n  this._derivedBlendCommandsLength = 0;\n  this._derivedPickCommandsLength = 0;\n  this._derivedCommandsToUpdateLength = 0;\n}\nObject.defineProperties(GlobeTranslucencyState.prototype, {\n  frontFaceAlphaByDistance: {\n    get: function () {\n      return this._frontFaceAlphaByDistance;\n    }\n  },\n  backFaceAlphaByDistance: {\n    get: function () {\n      return this._backFaceAlphaByDistance;\n    }\n  },\n  translucent: {\n    get: function () {\n      return this._frontFaceTranslucent;\n    }\n  },\n  sunVisibleThroughGlobe: {\n    get: function () {\n      return this._sunVisibleThroughGlobe;\n    }\n  },\n  environmentVisible: {\n    get: function () {\n      return this._environmentVisible;\n    }\n  },\n  useDepthPlane: {\n    get: function () {\n      return this._useDepthPlane;\n    }\n  },\n  numberOfTextureUniforms: {\n    get: function () {\n      return this._numberOfTextureUniforms;\n    }\n  },\n  rectangle: {\n    get: function () {\n      return this._rectangle;\n    }\n  }\n});\nGlobeTranslucencyState.prototype.update = function (scene) {\n  const globe = scene.globe;\n  if (!defined(globe) || !globe.show) {\n    this._frontFaceTranslucent = false;\n    this._backFaceTranslucent = false;\n    this._sunVisibleThroughGlobe = true;\n    this._environmentVisible = true;\n    this._useDepthPlane = false;\n    return;\n  }\n  this._frontFaceAlphaByDistance = updateAlphaByDistance(globe.translucency.enabled, globe.translucency.frontFaceAlpha, globe.translucency.frontFaceAlphaByDistance, this._frontFaceAlphaByDistance);\n  this._backFaceAlphaByDistance = updateAlphaByDistance(globe.translucency.enabled, globe.translucency.backFaceAlpha, globe.translucency.backFaceAlphaByDistance, this._backFaceAlphaByDistance);\n  this._frontFaceTranslucent = isFaceTranslucent(globe.translucency.enabled, this._frontFaceAlphaByDistance, globe);\n  this._backFaceTranslucent = isFaceTranslucent(globe.translucency.enabled, this._backFaceAlphaByDistance, globe);\n  this._requiresManualDepthTest = requiresManualDepthTest(this, scene, globe);\n  this._sunVisibleThroughGlobe = isSunVisibleThroughGlobe(this, scene);\n  this._environmentVisible = isEnvironmentVisible(this, scene);\n  this._useDepthPlane = useDepthPlane(this, scene);\n  this._numberOfTextureUniforms = getNumberOfTextureUniforms(this);\n  this._rectangle = Rectangle.clone(globe.translucency.rectangle, this._rectangle);\n  gatherDerivedCommandRequirements(this, scene);\n};\nfunction updateAlphaByDistance(enabled, alpha, alphaByDistance, result) {\n  if (!enabled) {\n    result.nearValue = 1.0;\n    result.farValue = 1.0;\n    return result;\n  }\n  if (!defined(alphaByDistance)) {\n    result.nearValue = alpha;\n    result.farValue = alpha;\n    return result;\n  }\n  NearFarScalar.clone(alphaByDistance, result);\n  result.nearValue *= alpha;\n  result.farValue *= alpha;\n  return result;\n}\nfunction isFaceTranslucent(translucencyEnabled, alphaByDistance, globe) {\n  return translucencyEnabled && (globe.baseColor.alpha < 1.0 || alphaByDistance.nearValue < 1.0 || alphaByDistance.farValue < 1.0);\n}\nfunction isSunVisibleThroughGlobe(state, scene) {\n  // The sun is visible through the globe if the front and back faces are translucent when above ground\n  // or if front faces are translucent when below ground\n  const frontTranslucent = state._frontFaceTranslucent;\n  const backTranslucent = state._backFaceTranslucent;\n  return frontTranslucent && (scene.cameraUnderground || backTranslucent);\n}\nfunction isEnvironmentVisible(state, scene) {\n  // The environment is visible if the camera is above ground or underground with translucency\n  return !scene.cameraUnderground || state._frontFaceTranslucent;\n}\nfunction useDepthPlane(state, scene) {\n  // Use the depth plane when the camera is above ground and the globe is opaque\n  return !scene.cameraUnderground && !state._frontFaceTranslucent;\n}\nfunction requiresManualDepthTest(state, scene, globe) {\n  return state._frontFaceTranslucent && !state._backFaceTranslucent && !globe.depthTestAgainstTerrain && scene.mode !== SceneMode.SCENE2D && scene.context.depthTexture;\n}\nfunction getNumberOfTextureUniforms(state) {\n  let numberOfTextureUniforms = 0;\n  if (state._frontFaceTranslucent) {\n    ++numberOfTextureUniforms; // classification texture\n  }\n  if (state._requiresManualDepthTest) {\n    ++numberOfTextureUniforms; // czm_globeDepthTexture for manual depth testing\n  }\n  return numberOfTextureUniforms;\n}\nfunction gatherDerivedCommandRequirements(state, scene) {\n  state._derivedCommandsLength = getDerivedCommandTypes(state, scene, false, false, state._derivedCommandTypes);\n  state._derivedBlendCommandsLength = getDerivedCommandTypes(state, scene, true, false, state._derivedBlendCommandTypes);\n  state._derivedPickCommandsLength = getDerivedCommandTypes(state, scene, false, true, state._derivedPickCommandTypes);\n  let i;\n  let derivedCommandKey = 0;\n  for (i = 0; i < state._derivedCommandsLength; ++i) {\n    derivedCommandKey |= 1 << state._derivedCommandTypes[i];\n  }\n  for (i = 0; i < state._derivedBlendCommandsLength; ++i) {\n    derivedCommandKey |= 1 << state._derivedBlendCommandTypes[i];\n  }\n  for (i = 0; i < state._derivedPickCommandsLength; ++i) {\n    derivedCommandKey |= 1 << state._derivedPickCommandTypes[i];\n  }\n  let derivedCommandsToUpdateLength = 0;\n  for (i = 0; i < derivedCommandsMaximumLength; ++i) {\n    if ((derivedCommandKey & 1 << i) > 0) {\n      state._derivedCommandTypesToUpdate[derivedCommandsToUpdateLength++] = i;\n    }\n  }\n  state._derivedCommandsToUpdateLength = derivedCommandsToUpdateLength;\n  const derivedCommandsDirty = derivedCommandKey !== state._derivedCommandKey;\n  state._derivedCommandKey = derivedCommandKey;\n  state._derivedCommandsDirty = derivedCommandsDirty;\n  if (!defined(state._derivedCommandPacks) && state._frontFaceTranslucent) {\n    state._derivedCommandPacks = createDerivedCommandPacks();\n  }\n}\nfunction getDerivedCommandTypes(state, scene, isBlendCommand, isPickCommand, types) {\n  let length = 0;\n  const frontTranslucent = state._frontFaceTranslucent;\n  const backTranslucent = state._backFaceTranslucent;\n  if (!frontTranslucent) {\n    // Don't use derived commands if the globe is opaque\n    return length;\n  }\n  const cameraUnderground = scene.cameraUnderground;\n  const requiresManualDepthTest = state._requiresManualDepthTest;\n  const translucentFrontFaceCommandType = isPickCommand ? DerivedCommandType.PICK_FRONT_FACE : requiresManualDepthTest ? DerivedCommandType.TRANSLUCENT_FRONT_FACE_MANUAL_DEPTH_TEST : DerivedCommandType.TRANSLUCENT_FRONT_FACE;\n  const translucentBackFaceCommandType = isPickCommand ? DerivedCommandType.PICK_BACK_FACE : requiresManualDepthTest ? DerivedCommandType.TRANSLUCENT_BACK_FACE_MANUAL_DEPTH_TEST : DerivedCommandType.TRANSLUCENT_BACK_FACE;\n  if (scene.mode === SceneMode.SCENE2D) {\n    types[length++] = DerivedCommandType.DEPTH_ONLY_FRONT_FACE;\n    types[length++] = translucentFrontFaceCommandType;\n    return length;\n  }\n  if (backTranslucent) {\n    // Push depth-only command for classification. Blend commands do not need to write depth.\n    // Push translucent commands for front and back faces.\n    if (!isBlendCommand) {\n      types[length++] = DerivedCommandType.DEPTH_ONLY_FRONT_AND_BACK_FACE;\n    }\n    if (cameraUnderground) {\n      types[length++] = translucentFrontFaceCommandType;\n      types[length++] = translucentBackFaceCommandType;\n    } else {\n      types[length++] = translucentBackFaceCommandType;\n      types[length++] = translucentFrontFaceCommandType;\n    }\n  } else {\n    // Push opaque command for the face that appears in back.\n    // Push depth-only command and translucent command for the face that appears in front.\n    // eslint-disable-next-line no-lonely-if\n    if (cameraUnderground) {\n      if (!isBlendCommand) {\n        types[length++] = DerivedCommandType.DEPTH_ONLY_BACK_FACE;\n      }\n      types[length++] = DerivedCommandType.OPAQUE_FRONT_FACE;\n      types[length++] = translucentBackFaceCommandType;\n    } else {\n      if (!isBlendCommand) {\n        types[length++] = DerivedCommandType.DEPTH_ONLY_FRONT_FACE;\n      }\n      types[length++] = DerivedCommandType.OPAQUE_BACK_FACE;\n      types[length++] = translucentFrontFaceCommandType;\n    }\n  }\n  return length;\n}\nfunction removeDefine(defines, defineToRemove) {\n  const index = defines.indexOf(defineToRemove);\n  if (index > -1) {\n    defines.splice(index, 1);\n  }\n}\nfunction hasDefine(defines, define) {\n  return defines.indexOf(define) > -1;\n}\nfunction getOpaqueFrontFaceShaderProgram(vs, fs) {\n  removeDefine(vs.defines, \"TRANSLUCENT\");\n  removeDefine(fs.defines, \"TRANSLUCENT\");\n}\nfunction getOpaqueBackFaceShaderProgram(vs, fs) {\n  removeDefine(vs.defines, \"GROUND_ATMOSPHERE\");\n  removeDefine(fs.defines, \"GROUND_ATMOSPHERE\");\n  removeDefine(vs.defines, \"FOG\");\n  removeDefine(fs.defines, \"FOG\");\n  removeDefine(vs.defines, \"TRANSLUCENT\");\n  removeDefine(fs.defines, \"TRANSLUCENT\");\n}\nfunction getDepthOnlyShaderProgram(vs, fs) {\n  if (hasDefine(fs.defines, \"TILE_LIMIT_RECTANGLE\") || hasDefine(fs.defines, \"ENABLE_CLIPPING_PLANES\")) {\n    // Need to execute the full shader if discard is called\n    return;\n  }\n  const depthOnlyShader = \"void main() \\n\" + \"{ \\n\" + \"    out_FragColor = vec4(1.0); \\n\" + \"} \\n\";\n  fs.sources = [depthOnlyShader];\n}\nfunction getTranslucentShaderProgram(vs, fs) {\n  const sources = fs.sources;\n  const length = sources.length;\n  for (let i = 0; i < length; ++i) {\n    sources[i] = ShaderSource.replaceMain(sources[i], \"czm_globe_translucency_main\");\n  }\n  const globeTranslucencyMain = \"\\n\\n\" + \"uniform sampler2D u_classificationTexture; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    vec2 st = gl_FragCoord.xy / czm_viewport.zw; \\n\" + \"#ifdef MANUAL_DEPTH_TEST \\n\" + \"    float logDepthOrDepth = czm_unpackDepth(texture(czm_globeDepthTexture, st)); \\n\" + \"    if (logDepthOrDepth != 0.0) \\n\" + \"    { \\n\" + \"        vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth); \\n\" + \"        float depthEC = eyeCoordinate.z / eyeCoordinate.w; \\n\" + \"        if (v_positionEC.z < depthEC) \\n\" + \"        { \\n\" + \"            discard; \\n\" + \"        } \\n\" + \"    } \\n\" + \"#endif \\n\" + \"    czm_globe_translucency_main(); \\n\" + \"    vec4 classificationColor = texture(u_classificationTexture, st); \\n\" + \"    if (classificationColor.a > 0.0) \\n\" + \"    { \\n\" + \"        // Reverse premultiplication process to get the correct composited result of the classification primitives \\n\" + \"        classificationColor.rgb /= classificationColor.a; \\n\" + \"    } \\n\" + \"    out_FragColor = classificationColor * vec4(classificationColor.aaa, 1.0) + out_FragColor * (1.0 - classificationColor.a); \\n\" + \"} \\n\";\n  sources.push(globeTranslucencyMain);\n}\nfunction getTranslucentBackFaceShaderProgram(vs, fs) {\n  getTranslucentShaderProgram(vs, fs);\n  removeDefine(vs.defines, \"GROUND_ATMOSPHERE\");\n  removeDefine(fs.defines, \"GROUND_ATMOSPHERE\");\n  removeDefine(vs.defines, \"FOG\");\n  removeDefine(fs.defines, \"FOG\");\n}\nfunction getTranslucentFrontFaceManualDepthTestShaderProgram(vs, fs) {\n  getTranslucentShaderProgram(vs, fs);\n  vs.defines.push(\"GENERATE_POSITION\");\n  fs.defines.push(\"MANUAL_DEPTH_TEST\");\n}\nfunction getTranslucentBackFaceManualDepthTestShaderProgram(vs, fs) {\n  getTranslucentBackFaceShaderProgram(vs, fs);\n  vs.defines.push(\"GENERATE_POSITION\");\n  fs.defines.push(\"MANUAL_DEPTH_TEST\");\n}\nfunction getPickShaderProgram(vs, fs) {\n  const pickShader = \"uniform sampler2D u_classificationTexture; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    vec2 st = gl_FragCoord.xy / czm_viewport.zw; \\n\" + \"    vec4 pickColor = texture(u_classificationTexture, st); \\n\" + \"    if (pickColor == vec4(0.0)) \\n\" + \"    { \\n\" + \"        discard; \\n\" + \"    } \\n\" + \"    out_FragColor = pickColor; \\n\" + \"} \\n\";\n  fs.sources = [pickShader];\n}\nfunction getDerivedShaderProgram(context, shaderProgram, derivedShaderProgram, shaderProgramDirty, getShaderProgramFunction, cacheName) {\n  if (!defined(getShaderProgramFunction)) {\n    return shaderProgram;\n  }\n  if (!shaderProgramDirty && defined(derivedShaderProgram)) {\n    return derivedShaderProgram;\n  }\n  let shader = context.shaderCache.getDerivedShaderProgram(shaderProgram, cacheName);\n  if (!defined(shader)) {\n    const attributeLocations = shaderProgram._attributeLocations;\n    const vs = shaderProgram.vertexShaderSource.clone();\n    const fs = shaderProgram.fragmentShaderSource.clone();\n    vs.defines = defined(vs.defines) ? vs.defines.slice(0) : [];\n    fs.defines = defined(fs.defines) ? fs.defines.slice(0) : [];\n    getShaderProgramFunction(vs, fs);\n    shader = context.shaderCache.createDerivedShaderProgram(shaderProgram, cacheName, {\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: attributeLocations\n    });\n  }\n  return shader;\n}\nfunction getOpaqueFrontFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.BACK;\n  renderState.cull.enabled = true;\n}\nfunction getOpaqueBackFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.FRONT;\n  renderState.cull.enabled = true;\n}\nfunction getDepthOnlyFrontFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.BACK;\n  renderState.cull.enabled = true;\n  renderState.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false\n  };\n}\nfunction getDepthOnlyBackFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.FRONT;\n  renderState.cull.enabled = true;\n  renderState.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false\n  };\n}\nfunction getDepthOnlyFrontAndBackFaceRenderState(renderState) {\n  renderState.cull.enabled = false;\n  renderState.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false\n  };\n}\nfunction getTranslucentFrontFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.BACK;\n  renderState.cull.enabled = true;\n  renderState.depthMask = false;\n  renderState.blending = BlendingState.ALPHA_BLEND;\n}\nfunction getTranslucentBackFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.FRONT;\n  renderState.cull.enabled = true;\n  renderState.depthMask = false;\n  renderState.blending = BlendingState.ALPHA_BLEND;\n}\nfunction getPickFrontFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.BACK;\n  renderState.cull.enabled = true;\n  renderState.blending.enabled = false;\n}\nfunction getPickBackFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.FRONT;\n  renderState.cull.enabled = true;\n  renderState.blending.enabled = false;\n}\nfunction getDerivedRenderState(renderState, derivedRenderState, renderStateDirty, getRenderStateFunction, cache) {\n  if (!defined(getRenderStateFunction)) {\n    return renderState;\n  }\n  if (!renderStateDirty && defined(derivedRenderState)) {\n    return derivedRenderState;\n  }\n  let cachedRenderState = cache[renderState.id];\n  if (!defined(cachedRenderState)) {\n    const rs = RenderState.getState(renderState);\n    getRenderStateFunction(rs);\n    cachedRenderState = RenderState.fromCache(rs);\n    cache[renderState.id] = cachedRenderState;\n  }\n  return cachedRenderState;\n}\nfunction getTranslucencyUniformMap(state) {\n  return {\n    u_classificationTexture: function () {\n      return state._globeTranslucencyFramebuffer.classificationTexture;\n    }\n  };\n}\nfunction getDerivedUniformMap(state, uniformMap, derivedUniformMap, uniformMapDirty, getDerivedUniformMapFunction) {\n  if (!defined(getDerivedUniformMapFunction)) {\n    return uniformMap;\n  }\n  if (!uniformMapDirty && defined(derivedUniformMap)) {\n    return derivedUniformMap;\n  }\n  return combine(uniformMap, getDerivedUniformMapFunction(state), false);\n}\nfunction DerivedCommandPack(options) {\n  this.pass = options.pass;\n  this.pickOnly = options.pickOnly;\n  this.getShaderProgramFunction = options.getShaderProgramFunction;\n  this.getRenderStateFunction = options.getRenderStateFunction;\n  this.getUniformMapFunction = options.getUniformMapFunction;\n  this.renderStateCache = {};\n}\nfunction createDerivedCommandPacks() {\n  return [\n  // opaqueFrontFaceCommand\n  new DerivedCommandPack({\n    pass: Pass.GLOBE,\n    pickOnly: false,\n    getShaderProgramFunction: getOpaqueFrontFaceShaderProgram,\n    getRenderStateFunction: getOpaqueFrontFaceRenderState,\n    getUniformMapFunction: undefined\n  }),\n  // opaqueBackFaceCommand\n  new DerivedCommandPack({\n    pass: Pass.GLOBE,\n    pickOnly: false,\n    getShaderProgramFunction: getOpaqueBackFaceShaderProgram,\n    getRenderStateFunction: getOpaqueBackFaceRenderState,\n    getUniformMapFunction: undefined\n  }),\n  // depthOnlyFrontFaceCommand\n  new DerivedCommandPack({\n    pass: Pass.GLOBE,\n    pickOnly: false,\n    getShaderProgramFunction: getDepthOnlyShaderProgram,\n    getRenderStateFunction: getDepthOnlyFrontFaceRenderState,\n    getUniformMapFunction: undefined\n  }),\n  // depthOnlyBackFaceCommand\n  new DerivedCommandPack({\n    pass: Pass.GLOBE,\n    pickOnly: false,\n    getShaderProgramFunction: getDepthOnlyShaderProgram,\n    getRenderStateFunction: getDepthOnlyBackFaceRenderState,\n    getUniformMapFunction: undefined\n  }),\n  // depthOnlyFrontAndBackFaceCommand\n  new DerivedCommandPack({\n    pass: Pass.GLOBE,\n    pickOnly: false,\n    getShaderProgramFunction: getDepthOnlyShaderProgram,\n    getRenderStateFunction: getDepthOnlyFrontAndBackFaceRenderState,\n    getUniformMapFunction: undefined\n  }),\n  // translucentFrontFaceCommand\n  new DerivedCommandPack({\n    pass: Pass.TRANSLUCENT,\n    pickOnly: false,\n    getShaderProgramFunction: getTranslucentShaderProgram,\n    getRenderStateFunction: getTranslucentFrontFaceRenderState,\n    getUniformMapFunction: getTranslucencyUniformMap\n  }),\n  // translucentBackFaceCommand\n  new DerivedCommandPack({\n    pass: Pass.TRANSLUCENT,\n    pickOnly: false,\n    getShaderProgramFunction: getTranslucentBackFaceShaderProgram,\n    getRenderStateFunction: getTranslucentBackFaceRenderState,\n    getUniformMapFunction: getTranslucencyUniformMap\n  }),\n  // translucentFrontFaceManualDepthTestCommand\n  new DerivedCommandPack({\n    pass: Pass.TRANSLUCENT,\n    pickOnly: false,\n    getShaderProgramFunction: getTranslucentFrontFaceManualDepthTestShaderProgram,\n    getRenderStateFunction: getTranslucentFrontFaceRenderState,\n    getUniformMapFunction: getTranslucencyUniformMap\n  }),\n  // translucentBackFaceManualDepthTestCommand\n  new DerivedCommandPack({\n    pass: Pass.TRANSLUCENT,\n    pickOnly: false,\n    getShaderProgramFunction: getTranslucentBackFaceManualDepthTestShaderProgram,\n    getRenderStateFunction: getTranslucentBackFaceRenderState,\n    getUniformMapFunction: getTranslucencyUniformMap\n  }),\n  // pickFrontFaceCommand\n  new DerivedCommandPack({\n    pass: Pass.TRANSLUCENT,\n    pickOnly: true,\n    getShaderProgramFunction: getPickShaderProgram,\n    getRenderStateFunction: getPickFrontFaceRenderState,\n    getUniformMapFunction: getTranslucencyUniformMap\n  }),\n  // pickBackFaceCommand\n  new DerivedCommandPack({\n    pass: Pass.TRANSLUCENT,\n    pickOnly: true,\n    getShaderProgramFunction: getPickShaderProgram,\n    getRenderStateFunction: getPickBackFaceRenderState,\n    getUniformMapFunction: getTranslucencyUniformMap\n  })];\n}\nconst derivedCommandNames = new Array(derivedCommandsMaximumLength);\nconst derivedCommandPacks = new Array(derivedCommandsMaximumLength);\nGlobeTranslucencyState.prototype.updateDerivedCommands = function (command, frameState) {\n  const derivedCommandTypes = this._derivedCommandTypesToUpdate;\n  const derivedCommandsLength = this._derivedCommandsToUpdateLength;\n  if (derivedCommandsLength === 0) {\n    return;\n  }\n  for (let i = 0; i < derivedCommandsLength; ++i) {\n    derivedCommandPacks[i] = this._derivedCommandPacks[derivedCommandTypes[i]];\n    derivedCommandNames[i] = DerivedCommandNames[derivedCommandTypes[i]];\n  }\n  updateDerivedCommands(this, command, derivedCommandsLength, derivedCommandTypes, derivedCommandNames, derivedCommandPacks, frameState);\n};\nfunction updateDerivedCommands(state, command, derivedCommandsLength, derivedCommandTypes, derivedCommandNames, derivedCommandPacks, frameState) {\n  let derivedCommandsObject = command.derivedCommands.globeTranslucency;\n  const derivedCommandsDirty = state._derivedCommandsDirty;\n  if (command.dirty || !defined(derivedCommandsObject) || derivedCommandsDirty) {\n    command.dirty = false;\n    if (!defined(derivedCommandsObject)) {\n      derivedCommandsObject = {};\n      command.derivedCommands.globeTranslucency = derivedCommandsObject;\n    }\n    const frameNumber = frameState.frameNumber;\n    const uniformMapDirtyFrame = derivedCommandsObject.uniformMapDirtyFrame ?? 0;\n    const shaderProgramDirtyFrame = derivedCommandsObject.shaderProgramDirtyFrame ?? 0;\n    const renderStateDirtyFrame = derivedCommandsObject.renderStateDirtyFrame ?? 0;\n    const uniformMapDirty = derivedCommandsObject.uniformMap !== command.uniformMap;\n    const shaderProgramDirty = derivedCommandsObject.shaderProgramId !== command.shaderProgram.id;\n    const renderStateDirty = derivedCommandsObject.renderStateId !== command.renderState.id;\n    if (uniformMapDirty) {\n      derivedCommandsObject.uniformMapDirtyFrame = frameNumber;\n    }\n    if (shaderProgramDirty) {\n      derivedCommandsObject.shaderProgramDirtyFrame = frameNumber;\n    }\n    if (renderStateDirty) {\n      derivedCommandsObject.renderStateDirtyFrame = frameNumber;\n    }\n    derivedCommandsObject.uniformMap = command.uniformMap;\n    derivedCommandsObject.shaderProgramId = command.shaderProgram.id;\n    derivedCommandsObject.renderStateId = command.renderState.id;\n    for (let i = 0; i < derivedCommandsLength; ++i) {\n      const derivedCommandPack = derivedCommandPacks[i];\n      const derivedCommandType = derivedCommandTypes[i];\n      const derivedCommandName = derivedCommandNames[i];\n      let derivedCommand = derivedCommandsObject[derivedCommandName];\n      let derivedUniformMap;\n      let derivedShaderProgram;\n      let derivedRenderState;\n      if (defined(derivedCommand)) {\n        derivedUniformMap = derivedCommand.uniformMap;\n        derivedShaderProgram = derivedCommand.shaderProgram;\n        derivedRenderState = derivedCommand.renderState;\n      } else {\n        derivedUniformMap = undefined;\n        derivedShaderProgram = undefined;\n        derivedRenderState = undefined;\n      }\n      derivedCommand = DrawCommand.shallowClone(command, derivedCommand);\n      derivedCommandsObject[derivedCommandName] = derivedCommand;\n      const derivedUniformMapDirtyFrame = derivedCommand.derivedCommands.uniformMapDirtyFrame ?? 0;\n      const derivedShaderProgramDirtyFrame = derivedCommand.derivedCommands.shaderProgramDirtyFrame ?? 0;\n      const derivedRenderStateDirtyFrame = derivedCommand.derivedCommands.renderStateDirtyFrame ?? 0;\n      const derivedUniformMapDirty = uniformMapDirty || derivedUniformMapDirtyFrame < uniformMapDirtyFrame;\n      const derivedShaderProgramDirty = shaderProgramDirty || derivedShaderProgramDirtyFrame < shaderProgramDirtyFrame;\n      const derivedRenderStateDirty = renderStateDirty || derivedRenderStateDirtyFrame < renderStateDirtyFrame;\n      if (derivedUniformMapDirty) {\n        derivedCommand.derivedCommands.uniformMapDirtyFrame = frameNumber;\n      }\n      if (derivedShaderProgramDirty) {\n        derivedCommand.derivedCommands.shaderProgramDirtyFrame = frameNumber;\n      }\n      if (derivedRenderStateDirty) {\n        derivedCommand.derivedCommands.renderStateDirtyFrame = frameNumber;\n      }\n      derivedCommand.derivedCommands.type = derivedCommandType;\n      derivedCommand.pass = derivedCommandPack.pass;\n      derivedCommand.pickOnly = derivedCommandPack.pickOnly;\n      derivedCommand.uniformMap = getDerivedUniformMap(state, command.uniformMap, derivedUniformMap, derivedUniformMapDirty, derivedCommandPack.getUniformMapFunction);\n      derivedCommand.shaderProgram = getDerivedShaderProgram(frameState.context, command.shaderProgram, derivedShaderProgram, derivedShaderProgramDirty, derivedCommandPack.getShaderProgramFunction, derivedCommandName);\n      derivedCommand.renderState = getDerivedRenderState(command.renderState, derivedRenderState, derivedRenderStateDirty, derivedCommandPack.getRenderStateFunction, derivedCommandPack.renderStateCache);\n    }\n  }\n}\nGlobeTranslucencyState.prototype.pushDerivedCommands = function (command, isBlendCommand, frameState) {\n  const picking = frameState.passes.pick || frameState.passes.pickVoxel;\n  if (picking && isBlendCommand) {\n    // No need to push blend commands in the pick pass\n    return;\n  }\n  let derivedCommandTypes = this._derivedCommandTypes;\n  let derivedCommandsLength = this._derivedCommandsLength;\n  if (picking) {\n    derivedCommandTypes = this._derivedPickCommandTypes;\n    derivedCommandsLength = this._derivedPickCommandsLength;\n  } else if (isBlendCommand) {\n    derivedCommandTypes = this._derivedBlendCommandTypes;\n    derivedCommandsLength = this._derivedBlendCommandsLength;\n  }\n  if (derivedCommandsLength === 0) {\n    // No derived commands to push so just push the globe command\n    frameState.commandList.push(command);\n    return;\n  }\n\n  // Push derived commands\n  const derivedCommands = command.derivedCommands.globeTranslucency;\n  for (let i = 0; i < derivedCommandsLength; ++i) {\n    const derivedCommandName = DerivedCommandNames[derivedCommandTypes[i]];\n    frameState.commandList.push(derivedCommands[derivedCommandName]);\n  }\n};\nfunction executeCommandsMatchingType(commands, commandsLength, executeCommandFunction, scene, passState, types) {\n  for (let i = 0; i < commandsLength; ++i) {\n    const command = commands[i];\n    const type = command.derivedCommands.type;\n    if (!defined(types) || types.indexOf(type) > -1) {\n      executeCommandFunction(command, scene, passState);\n    }\n  }\n}\nfunction executeCommands(commands, commandsLength, executeCommandFunction, scene, passState) {\n  for (let i = 0; i < commandsLength; ++i) {\n    executeCommandFunction(commands[i], scene, passState);\n  }\n}\nconst opaqueTypes = [DerivedCommandType.OPAQUE_FRONT_FACE, DerivedCommandType.OPAQUE_BACK_FACE];\nconst depthOnlyTypes = [DerivedCommandType.DEPTH_ONLY_FRONT_FACE, DerivedCommandType.DEPTH_ONLY_BACK_FACE, DerivedCommandType.DEPTH_ONLY_FRONT_AND_BACK_FACE];\nGlobeTranslucencyState.prototype.executeGlobeCommands = function (frustumCommands, executeCommandFunction, globeTranslucencyFramebuffer, scene, passState) {\n  const context = scene.context;\n  const globeCommands = frustumCommands.commands[Pass.GLOBE];\n  const globeCommandsLength = frustumCommands.indices[Pass.GLOBE];\n  if (globeCommandsLength === 0) {\n    return;\n  }\n  this._globeTranslucencyFramebuffer = globeTranslucencyFramebuffer;\n  globeTranslucencyFramebuffer.clearClassification(context, passState);\n\n  // Render opaque commands like normal\n  executeCommandsMatchingType(globeCommands, globeCommandsLength, executeCommandFunction, scene, passState, opaqueTypes);\n};\nGlobeTranslucencyState.prototype.executeGlobeClassificationCommands = function (frustumCommands, executeCommandFunction, globeTranslucencyFramebuffer, scene, passState) {\n  const {\n    context\n  } = scene;\n  const {\n    uniformState\n  } = context;\n  const globeCommands = frustumCommands.commands[Pass.GLOBE];\n  const globeCommandsLength = frustumCommands.indices[Pass.GLOBE];\n  const classificationCommands = frustumCommands.commands[Pass.TERRAIN_CLASSIFICATION];\n  const classificationCommandsLength = frustumCommands.indices[Pass.TERRAIN_CLASSIFICATION];\n  if (globeCommandsLength === 0 || classificationCommandsLength === 0) {\n    return;\n  }\n  const frontTranslucent = this._frontFaceTranslucent;\n  const backTranslucent = this._backFaceTranslucent;\n  if (!frontTranslucent || !backTranslucent) {\n    // Render classification on opaque faces like normal\n    executeCommands(classificationCommands, classificationCommandsLength, executeCommandFunction, scene, passState);\n  }\n  if (!frontTranslucent && !backTranslucent) {\n    // No translucent commands to render. Skip translucent classification.\n    return;\n  }\n  this._globeTranslucencyFramebuffer = globeTranslucencyFramebuffer;\n  const originalGlobeDepthTexture = uniformState.globeDepthTexture;\n  const originalFramebuffer = passState.framebuffer;\n\n  // Render to internal framebuffer and get the first depth peel\n  passState.framebuffer = globeTranslucencyFramebuffer.classificationFramebuffer;\n  executeCommandsMatchingType(globeCommands, globeCommandsLength, executeCommandFunction, scene, passState, depthOnlyTypes);\n  if (context.depthTexture) {\n    // Pack depth into separate texture for ground polylines and textured ground primitives\n    const packedDepthTexture = globeTranslucencyFramebuffer.packDepth(context, passState);\n    uniformState.globeDepthTexture = packedDepthTexture;\n  }\n\n  // Render classification on translucent faces\n  executeCommands(classificationCommands, classificationCommandsLength, executeCommandFunction, scene, passState);\n\n  // Unset temporary state\n  uniformState.globeDepthTexture = originalGlobeDepthTexture;\n  passState.framebuffer = originalFramebuffer;\n};\nexport default GlobeTranslucencyState;","map":{"version":3,"names":["combine","defined","NearFarScalar","Rectangle","DrawCommand","Pass","RenderState","ShaderSource","BlendingState","CullFace","SceneMode","DerivedCommandType","OPAQUE_FRONT_FACE","OPAQUE_BACK_FACE","DEPTH_ONLY_FRONT_FACE","DEPTH_ONLY_BACK_FACE","DEPTH_ONLY_FRONT_AND_BACK_FACE","TRANSLUCENT_FRONT_FACE","TRANSLUCENT_BACK_FACE","TRANSLUCENT_FRONT_FACE_MANUAL_DEPTH_TEST","TRANSLUCENT_BACK_FACE_MANUAL_DEPTH_TEST","PICK_FRONT_FACE","PICK_BACK_FACE","DERIVED_COMMANDS_MAXIMUM_LENGTH","derivedCommandsMaximumLength","DerivedCommandNames","GlobeTranslucencyState","_frontFaceAlphaByDistance","_backFaceAlphaByDistance","_frontFaceTranslucent","_backFaceTranslucent","_requiresManualDepthTest","_sunVisibleThroughGlobe","_environmentVisible","_useDepthPlane","_numberOfTextureUniforms","_globeTranslucencyFramebuffer","undefined","_rectangle","clone","MAX_VALUE","_derivedCommandKey","_derivedCommandsDirty","_derivedCommandPacks","_derivedCommandTypes","Array","_derivedBlendCommandTypes","_derivedPickCommandTypes","_derivedCommandTypesToUpdate","_derivedCommandsLength","_derivedBlendCommandsLength","_derivedPickCommandsLength","_derivedCommandsToUpdateLength","Object","defineProperties","prototype","frontFaceAlphaByDistance","get","backFaceAlphaByDistance","translucent","sunVisibleThroughGlobe","environmentVisible","useDepthPlane","numberOfTextureUniforms","rectangle","update","scene","globe","show","updateAlphaByDistance","translucency","enabled","frontFaceAlpha","backFaceAlpha","isFaceTranslucent","requiresManualDepthTest","isSunVisibleThroughGlobe","isEnvironmentVisible","getNumberOfTextureUniforms","gatherDerivedCommandRequirements","alpha","alphaByDistance","result","nearValue","farValue","translucencyEnabled","baseColor","state","frontTranslucent","backTranslucent","cameraUnderground","depthTestAgainstTerrain","mode","SCENE2D","context","depthTexture","getDerivedCommandTypes","i","derivedCommandKey","derivedCommandsToUpdateLength","derivedCommandsDirty","createDerivedCommandPacks","isBlendCommand","isPickCommand","types","length","translucentFrontFaceCommandType","translucentBackFaceCommandType","removeDefine","defines","defineToRemove","index","indexOf","splice","hasDefine","define","getOpaqueFrontFaceShaderProgram","vs","fs","getOpaqueBackFaceShaderProgram","getDepthOnlyShaderProgram","depthOnlyShader","sources","getTranslucentShaderProgram","replaceMain","globeTranslucencyMain","push","getTranslucentBackFaceShaderProgram","getTranslucentFrontFaceManualDepthTestShaderProgram","getTranslucentBackFaceManualDepthTestShaderProgram","getPickShaderProgram","pickShader","getDerivedShaderProgram","shaderProgram","derivedShaderProgram","shaderProgramDirty","getShaderProgramFunction","cacheName","shader","shaderCache","attributeLocations","_attributeLocations","vertexShaderSource","fragmentShaderSource","slice","createDerivedShaderProgram","getOpaqueFrontFaceRenderState","renderState","cull","face","BACK","getOpaqueBackFaceRenderState","FRONT","getDepthOnlyFrontFaceRenderState","colorMask","red","green","blue","getDepthOnlyBackFaceRenderState","getDepthOnlyFrontAndBackFaceRenderState","getTranslucentFrontFaceRenderState","depthMask","blending","ALPHA_BLEND","getTranslucentBackFaceRenderState","getPickFrontFaceRenderState","getPickBackFaceRenderState","getDerivedRenderState","derivedRenderState","renderStateDirty","getRenderStateFunction","cache","cachedRenderState","id","rs","getState","fromCache","getTranslucencyUniformMap","u_classificationTexture","classificationTexture","getDerivedUniformMap","uniformMap","derivedUniformMap","uniformMapDirty","getDerivedUniformMapFunction","DerivedCommandPack","options","pass","pickOnly","getUniformMapFunction","renderStateCache","GLOBE","TRANSLUCENT","derivedCommandNames","derivedCommandPacks","updateDerivedCommands","command","frameState","derivedCommandTypes","derivedCommandsLength","derivedCommandsObject","derivedCommands","globeTranslucency","dirty","frameNumber","uniformMapDirtyFrame","shaderProgramDirtyFrame","renderStateDirtyFrame","shaderProgramId","renderStateId","derivedCommandPack","derivedCommandType","derivedCommandName","derivedCommand","shallowClone","derivedUniformMapDirtyFrame","derivedShaderProgramDirtyFrame","derivedRenderStateDirtyFrame","derivedUniformMapDirty","derivedShaderProgramDirty","derivedRenderStateDirty","type","pushDerivedCommands","picking","passes","pick","pickVoxel","commandList","executeCommandsMatchingType","commands","commandsLength","executeCommandFunction","passState","executeCommands","opaqueTypes","depthOnlyTypes","executeGlobeCommands","frustumCommands","globeTranslucencyFramebuffer","globeCommands","globeCommandsLength","indices","clearClassification","executeGlobeClassificationCommands","uniformState","classificationCommands","TERRAIN_CLASSIFICATION","classificationCommandsLength","originalGlobeDepthTexture","globeDepthTexture","originalFramebuffer","framebuffer","classificationFramebuffer","packedDepthTexture","packDepth"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/GlobeTranslucencyState.js"],"sourcesContent":["import combine from \"../Core/combine.js\";\nimport defined from \"../Core/defined.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport CullFace from \"./CullFace.js\";\nimport SceneMode from \"./SceneMode.js\";\n\nconst DerivedCommandType = {\n  OPAQUE_FRONT_FACE: 0,\n  OPAQUE_BACK_FACE: 1,\n  DEPTH_ONLY_FRONT_FACE: 2,\n  DEPTH_ONLY_BACK_FACE: 3,\n  DEPTH_ONLY_FRONT_AND_BACK_FACE: 4,\n  TRANSLUCENT_FRONT_FACE: 5,\n  TRANSLUCENT_BACK_FACE: 6,\n  TRANSLUCENT_FRONT_FACE_MANUAL_DEPTH_TEST: 7,\n  TRANSLUCENT_BACK_FACE_MANUAL_DEPTH_TEST: 8,\n  PICK_FRONT_FACE: 9,\n  PICK_BACK_FACE: 10,\n  DERIVED_COMMANDS_MAXIMUM_LENGTH: 11,\n};\n\nconst derivedCommandsMaximumLength =\n  DerivedCommandType.DERIVED_COMMANDS_MAXIMUM_LENGTH;\n\nconst DerivedCommandNames = [\n  \"opaqueFrontFaceCommand\",\n  \"opaqueBackFaceCommand\",\n  \"depthOnlyFrontFaceCommand\",\n  \"depthOnlyBackFaceCommand\",\n  \"depthOnlyFrontAndBackFaceCommand\",\n  \"translucentFrontFaceCommand\",\n  \"translucentBackFaceCommand\",\n  \"translucentFrontFaceManualDepthTestCommand\",\n  \"translucentBackFaceManualDepthTestCommand\",\n  \"pickFrontFaceCommand\",\n  \"pickBackFaceCommand\",\n];\n\n/**\n * @private\n */\nfunction GlobeTranslucencyState() {\n  this._frontFaceAlphaByDistance = new NearFarScalar(0.0, 1.0, 0.0, 1.0);\n  this._backFaceAlphaByDistance = new NearFarScalar(0.0, 1.0, 0.0, 1.0);\n\n  this._frontFaceTranslucent = false;\n  this._backFaceTranslucent = false;\n  this._requiresManualDepthTest = false;\n  this._sunVisibleThroughGlobe = false;\n  this._environmentVisible = false;\n  this._useDepthPlane = false;\n  this._numberOfTextureUniforms = 0;\n  this._globeTranslucencyFramebuffer = undefined;\n  this._rectangle = Rectangle.clone(Rectangle.MAX_VALUE);\n\n  this._derivedCommandKey = 0;\n  this._derivedCommandsDirty = false;\n  this._derivedCommandPacks = undefined;\n\n  this._derivedCommandTypes = new Array(derivedCommandsMaximumLength);\n  this._derivedBlendCommandTypes = new Array(derivedCommandsMaximumLength);\n  this._derivedPickCommandTypes = new Array(derivedCommandsMaximumLength);\n  this._derivedCommandTypesToUpdate = new Array(derivedCommandsMaximumLength);\n\n  this._derivedCommandsLength = 0;\n  this._derivedBlendCommandsLength = 0;\n  this._derivedPickCommandsLength = 0;\n  this._derivedCommandsToUpdateLength = 0;\n}\n\nObject.defineProperties(GlobeTranslucencyState.prototype, {\n  frontFaceAlphaByDistance: {\n    get: function () {\n      return this._frontFaceAlphaByDistance;\n    },\n  },\n  backFaceAlphaByDistance: {\n    get: function () {\n      return this._backFaceAlphaByDistance;\n    },\n  },\n  translucent: {\n    get: function () {\n      return this._frontFaceTranslucent;\n    },\n  },\n  sunVisibleThroughGlobe: {\n    get: function () {\n      return this._sunVisibleThroughGlobe;\n    },\n  },\n  environmentVisible: {\n    get: function () {\n      return this._environmentVisible;\n    },\n  },\n  useDepthPlane: {\n    get: function () {\n      return this._useDepthPlane;\n    },\n  },\n  numberOfTextureUniforms: {\n    get: function () {\n      return this._numberOfTextureUniforms;\n    },\n  },\n  rectangle: {\n    get: function () {\n      return this._rectangle;\n    },\n  },\n});\n\nGlobeTranslucencyState.prototype.update = function (scene) {\n  const globe = scene.globe;\n  if (!defined(globe) || !globe.show) {\n    this._frontFaceTranslucent = false;\n    this._backFaceTranslucent = false;\n    this._sunVisibleThroughGlobe = true;\n    this._environmentVisible = true;\n    this._useDepthPlane = false;\n    return;\n  }\n\n  this._frontFaceAlphaByDistance = updateAlphaByDistance(\n    globe.translucency.enabled,\n    globe.translucency.frontFaceAlpha,\n    globe.translucency.frontFaceAlphaByDistance,\n    this._frontFaceAlphaByDistance,\n  );\n  this._backFaceAlphaByDistance = updateAlphaByDistance(\n    globe.translucency.enabled,\n    globe.translucency.backFaceAlpha,\n    globe.translucency.backFaceAlphaByDistance,\n    this._backFaceAlphaByDistance,\n  );\n\n  this._frontFaceTranslucent = isFaceTranslucent(\n    globe.translucency.enabled,\n    this._frontFaceAlphaByDistance,\n    globe,\n  );\n  this._backFaceTranslucent = isFaceTranslucent(\n    globe.translucency.enabled,\n    this._backFaceAlphaByDistance,\n    globe,\n  );\n\n  this._requiresManualDepthTest = requiresManualDepthTest(this, scene, globe);\n\n  this._sunVisibleThroughGlobe = isSunVisibleThroughGlobe(this, scene);\n  this._environmentVisible = isEnvironmentVisible(this, scene);\n  this._useDepthPlane = useDepthPlane(this, scene);\n  this._numberOfTextureUniforms = getNumberOfTextureUniforms(this);\n\n  this._rectangle = Rectangle.clone(\n    globe.translucency.rectangle,\n    this._rectangle,\n  );\n\n  gatherDerivedCommandRequirements(this, scene);\n};\n\nfunction updateAlphaByDistance(enabled, alpha, alphaByDistance, result) {\n  if (!enabled) {\n    result.nearValue = 1.0;\n    result.farValue = 1.0;\n    return result;\n  }\n\n  if (!defined(alphaByDistance)) {\n    result.nearValue = alpha;\n    result.farValue = alpha;\n    return result;\n  }\n\n  NearFarScalar.clone(alphaByDistance, result);\n  result.nearValue *= alpha;\n  result.farValue *= alpha;\n  return result;\n}\n\nfunction isFaceTranslucent(translucencyEnabled, alphaByDistance, globe) {\n  return (\n    translucencyEnabled &&\n    (globe.baseColor.alpha < 1.0 ||\n      alphaByDistance.nearValue < 1.0 ||\n      alphaByDistance.farValue < 1.0)\n  );\n}\n\nfunction isSunVisibleThroughGlobe(state, scene) {\n  // The sun is visible through the globe if the front and back faces are translucent when above ground\n  // or if front faces are translucent when below ground\n  const frontTranslucent = state._frontFaceTranslucent;\n  const backTranslucent = state._backFaceTranslucent;\n  return frontTranslucent && (scene.cameraUnderground || backTranslucent);\n}\n\nfunction isEnvironmentVisible(state, scene) {\n  // The environment is visible if the camera is above ground or underground with translucency\n  return !scene.cameraUnderground || state._frontFaceTranslucent;\n}\n\nfunction useDepthPlane(state, scene) {\n  // Use the depth plane when the camera is above ground and the globe is opaque\n  return !scene.cameraUnderground && !state._frontFaceTranslucent;\n}\n\nfunction requiresManualDepthTest(state, scene, globe) {\n  return (\n    state._frontFaceTranslucent &&\n    !state._backFaceTranslucent &&\n    !globe.depthTestAgainstTerrain &&\n    scene.mode !== SceneMode.SCENE2D &&\n    scene.context.depthTexture\n  );\n}\n\nfunction getNumberOfTextureUniforms(state) {\n  let numberOfTextureUniforms = 0;\n\n  if (state._frontFaceTranslucent) {\n    ++numberOfTextureUniforms; // classification texture\n  }\n\n  if (state._requiresManualDepthTest) {\n    ++numberOfTextureUniforms; // czm_globeDepthTexture for manual depth testing\n  }\n\n  return numberOfTextureUniforms;\n}\n\nfunction gatherDerivedCommandRequirements(state, scene) {\n  state._derivedCommandsLength = getDerivedCommandTypes(\n    state,\n    scene,\n    false,\n    false,\n    state._derivedCommandTypes,\n  );\n\n  state._derivedBlendCommandsLength = getDerivedCommandTypes(\n    state,\n    scene,\n    true,\n    false,\n    state._derivedBlendCommandTypes,\n  );\n\n  state._derivedPickCommandsLength = getDerivedCommandTypes(\n    state,\n    scene,\n    false,\n    true,\n    state._derivedPickCommandTypes,\n  );\n\n  let i;\n\n  let derivedCommandKey = 0;\n  for (i = 0; i < state._derivedCommandsLength; ++i) {\n    derivedCommandKey |= 1 << state._derivedCommandTypes[i];\n  }\n  for (i = 0; i < state._derivedBlendCommandsLength; ++i) {\n    derivedCommandKey |= 1 << state._derivedBlendCommandTypes[i];\n  }\n  for (i = 0; i < state._derivedPickCommandsLength; ++i) {\n    derivedCommandKey |= 1 << state._derivedPickCommandTypes[i];\n  }\n\n  let derivedCommandsToUpdateLength = 0;\n  for (i = 0; i < derivedCommandsMaximumLength; ++i) {\n    if ((derivedCommandKey & (1 << i)) > 0) {\n      state._derivedCommandTypesToUpdate[derivedCommandsToUpdateLength++] = i;\n    }\n  }\n  state._derivedCommandsToUpdateLength = derivedCommandsToUpdateLength;\n\n  const derivedCommandsDirty = derivedCommandKey !== state._derivedCommandKey;\n  state._derivedCommandKey = derivedCommandKey;\n  state._derivedCommandsDirty = derivedCommandsDirty;\n\n  if (!defined(state._derivedCommandPacks) && state._frontFaceTranslucent) {\n    state._derivedCommandPacks = createDerivedCommandPacks();\n  }\n}\n\nfunction getDerivedCommandTypes(\n  state,\n  scene,\n  isBlendCommand,\n  isPickCommand,\n  types,\n) {\n  let length = 0;\n\n  const frontTranslucent = state._frontFaceTranslucent;\n  const backTranslucent = state._backFaceTranslucent;\n\n  if (!frontTranslucent) {\n    // Don't use derived commands if the globe is opaque\n    return length;\n  }\n\n  const cameraUnderground = scene.cameraUnderground;\n  const requiresManualDepthTest = state._requiresManualDepthTest;\n\n  const translucentFrontFaceCommandType = isPickCommand\n    ? DerivedCommandType.PICK_FRONT_FACE\n    : requiresManualDepthTest\n      ? DerivedCommandType.TRANSLUCENT_FRONT_FACE_MANUAL_DEPTH_TEST\n      : DerivedCommandType.TRANSLUCENT_FRONT_FACE;\n\n  const translucentBackFaceCommandType = isPickCommand\n    ? DerivedCommandType.PICK_BACK_FACE\n    : requiresManualDepthTest\n      ? DerivedCommandType.TRANSLUCENT_BACK_FACE_MANUAL_DEPTH_TEST\n      : DerivedCommandType.TRANSLUCENT_BACK_FACE;\n\n  if (scene.mode === SceneMode.SCENE2D) {\n    types[length++] = DerivedCommandType.DEPTH_ONLY_FRONT_FACE;\n    types[length++] = translucentFrontFaceCommandType;\n    return length;\n  }\n\n  if (backTranslucent) {\n    // Push depth-only command for classification. Blend commands do not need to write depth.\n    // Push translucent commands for front and back faces.\n    if (!isBlendCommand) {\n      types[length++] = DerivedCommandType.DEPTH_ONLY_FRONT_AND_BACK_FACE;\n    }\n    if (cameraUnderground) {\n      types[length++] = translucentFrontFaceCommandType;\n      types[length++] = translucentBackFaceCommandType;\n    } else {\n      types[length++] = translucentBackFaceCommandType;\n      types[length++] = translucentFrontFaceCommandType;\n    }\n  } else {\n    // Push opaque command for the face that appears in back.\n    // Push depth-only command and translucent command for the face that appears in front.\n    // eslint-disable-next-line no-lonely-if\n    if (cameraUnderground) {\n      if (!isBlendCommand) {\n        types[length++] = DerivedCommandType.DEPTH_ONLY_BACK_FACE;\n      }\n      types[length++] = DerivedCommandType.OPAQUE_FRONT_FACE;\n      types[length++] = translucentBackFaceCommandType;\n    } else {\n      if (!isBlendCommand) {\n        types[length++] = DerivedCommandType.DEPTH_ONLY_FRONT_FACE;\n      }\n      types[length++] = DerivedCommandType.OPAQUE_BACK_FACE;\n      types[length++] = translucentFrontFaceCommandType;\n    }\n  }\n\n  return length;\n}\n\nfunction removeDefine(defines, defineToRemove) {\n  const index = defines.indexOf(defineToRemove);\n  if (index > -1) {\n    defines.splice(index, 1);\n  }\n}\n\nfunction hasDefine(defines, define) {\n  return defines.indexOf(define) > -1;\n}\n\nfunction getOpaqueFrontFaceShaderProgram(vs, fs) {\n  removeDefine(vs.defines, \"TRANSLUCENT\");\n  removeDefine(fs.defines, \"TRANSLUCENT\");\n}\n\nfunction getOpaqueBackFaceShaderProgram(vs, fs) {\n  removeDefine(vs.defines, \"GROUND_ATMOSPHERE\");\n  removeDefine(fs.defines, \"GROUND_ATMOSPHERE\");\n  removeDefine(vs.defines, \"FOG\");\n  removeDefine(fs.defines, \"FOG\");\n  removeDefine(vs.defines, \"TRANSLUCENT\");\n  removeDefine(fs.defines, \"TRANSLUCENT\");\n}\n\nfunction getDepthOnlyShaderProgram(vs, fs) {\n  if (\n    hasDefine(fs.defines, \"TILE_LIMIT_RECTANGLE\") ||\n    hasDefine(fs.defines, \"ENABLE_CLIPPING_PLANES\")\n  ) {\n    // Need to execute the full shader if discard is called\n    return;\n  }\n\n  const depthOnlyShader =\n    \"void main() \\n\" + \"{ \\n\" + \"    out_FragColor = vec4(1.0); \\n\" + \"} \\n\";\n\n  fs.sources = [depthOnlyShader];\n}\n\nfunction getTranslucentShaderProgram(vs, fs) {\n  const sources = fs.sources;\n  const length = sources.length;\n  for (let i = 0; i < length; ++i) {\n    sources[i] = ShaderSource.replaceMain(\n      sources[i],\n      \"czm_globe_translucency_main\",\n    );\n  }\n\n  const globeTranslucencyMain =\n    \"\\n\\n\" +\n    \"uniform sampler2D u_classificationTexture; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    vec2 st = gl_FragCoord.xy / czm_viewport.zw; \\n\" +\n    \"#ifdef MANUAL_DEPTH_TEST \\n\" +\n    \"    float logDepthOrDepth = czm_unpackDepth(texture(czm_globeDepthTexture, st)); \\n\" +\n    \"    if (logDepthOrDepth != 0.0) \\n\" +\n    \"    { \\n\" +\n    \"        vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth); \\n\" +\n    \"        float depthEC = eyeCoordinate.z / eyeCoordinate.w; \\n\" +\n    \"        if (v_positionEC.z < depthEC) \\n\" +\n    \"        { \\n\" +\n    \"            discard; \\n\" +\n    \"        } \\n\" +\n    \"    } \\n\" +\n    \"#endif \\n\" +\n    \"    czm_globe_translucency_main(); \\n\" +\n    \"    vec4 classificationColor = texture(u_classificationTexture, st); \\n\" +\n    \"    if (classificationColor.a > 0.0) \\n\" +\n    \"    { \\n\" +\n    \"        // Reverse premultiplication process to get the correct composited result of the classification primitives \\n\" +\n    \"        classificationColor.rgb /= classificationColor.a; \\n\" +\n    \"    } \\n\" +\n    \"    out_FragColor = classificationColor * vec4(classificationColor.aaa, 1.0) + out_FragColor * (1.0 - classificationColor.a); \\n\" +\n    \"} \\n\";\n\n  sources.push(globeTranslucencyMain);\n}\n\nfunction getTranslucentBackFaceShaderProgram(vs, fs) {\n  getTranslucentShaderProgram(vs, fs);\n  removeDefine(vs.defines, \"GROUND_ATMOSPHERE\");\n  removeDefine(fs.defines, \"GROUND_ATMOSPHERE\");\n  removeDefine(vs.defines, \"FOG\");\n  removeDefine(fs.defines, \"FOG\");\n}\n\nfunction getTranslucentFrontFaceManualDepthTestShaderProgram(vs, fs) {\n  getTranslucentShaderProgram(vs, fs);\n  vs.defines.push(\"GENERATE_POSITION\");\n  fs.defines.push(\"MANUAL_DEPTH_TEST\");\n}\n\nfunction getTranslucentBackFaceManualDepthTestShaderProgram(vs, fs) {\n  getTranslucentBackFaceShaderProgram(vs, fs);\n  vs.defines.push(\"GENERATE_POSITION\");\n  fs.defines.push(\"MANUAL_DEPTH_TEST\");\n}\n\nfunction getPickShaderProgram(vs, fs) {\n  const pickShader =\n    \"uniform sampler2D u_classificationTexture; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    vec2 st = gl_FragCoord.xy / czm_viewport.zw; \\n\" +\n    \"    vec4 pickColor = texture(u_classificationTexture, st); \\n\" +\n    \"    if (pickColor == vec4(0.0)) \\n\" +\n    \"    { \\n\" +\n    \"        discard; \\n\" +\n    \"    } \\n\" +\n    \"    out_FragColor = pickColor; \\n\" +\n    \"} \\n\";\n\n  fs.sources = [pickShader];\n}\n\nfunction getDerivedShaderProgram(\n  context,\n  shaderProgram,\n  derivedShaderProgram,\n  shaderProgramDirty,\n  getShaderProgramFunction,\n  cacheName,\n) {\n  if (!defined(getShaderProgramFunction)) {\n    return shaderProgram;\n  }\n\n  if (!shaderProgramDirty && defined(derivedShaderProgram)) {\n    return derivedShaderProgram;\n  }\n\n  let shader = context.shaderCache.getDerivedShaderProgram(\n    shaderProgram,\n    cacheName,\n  );\n  if (!defined(shader)) {\n    const attributeLocations = shaderProgram._attributeLocations;\n    const vs = shaderProgram.vertexShaderSource.clone();\n    const fs = shaderProgram.fragmentShaderSource.clone();\n    vs.defines = defined(vs.defines) ? vs.defines.slice(0) : [];\n    fs.defines = defined(fs.defines) ? fs.defines.slice(0) : [];\n\n    getShaderProgramFunction(vs, fs);\n\n    shader = context.shaderCache.createDerivedShaderProgram(\n      shaderProgram,\n      cacheName,\n      {\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      },\n    );\n  }\n\n  return shader;\n}\n\nfunction getOpaqueFrontFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.BACK;\n  renderState.cull.enabled = true;\n}\n\nfunction getOpaqueBackFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.FRONT;\n  renderState.cull.enabled = true;\n}\n\nfunction getDepthOnlyFrontFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.BACK;\n  renderState.cull.enabled = true;\n  renderState.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false,\n  };\n}\n\nfunction getDepthOnlyBackFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.FRONT;\n  renderState.cull.enabled = true;\n  renderState.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false,\n  };\n}\n\nfunction getDepthOnlyFrontAndBackFaceRenderState(renderState) {\n  renderState.cull.enabled = false;\n  renderState.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false,\n  };\n}\n\nfunction getTranslucentFrontFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.BACK;\n  renderState.cull.enabled = true;\n  renderState.depthMask = false;\n  renderState.blending = BlendingState.ALPHA_BLEND;\n}\n\nfunction getTranslucentBackFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.FRONT;\n  renderState.cull.enabled = true;\n  renderState.depthMask = false;\n  renderState.blending = BlendingState.ALPHA_BLEND;\n}\n\nfunction getPickFrontFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.BACK;\n  renderState.cull.enabled = true;\n  renderState.blending.enabled = false;\n}\n\nfunction getPickBackFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.FRONT;\n  renderState.cull.enabled = true;\n  renderState.blending.enabled = false;\n}\n\nfunction getDerivedRenderState(\n  renderState,\n  derivedRenderState,\n  renderStateDirty,\n  getRenderStateFunction,\n  cache,\n) {\n  if (!defined(getRenderStateFunction)) {\n    return renderState;\n  }\n\n  if (!renderStateDirty && defined(derivedRenderState)) {\n    return derivedRenderState;\n  }\n\n  let cachedRenderState = cache[renderState.id];\n  if (!defined(cachedRenderState)) {\n    const rs = RenderState.getState(renderState);\n    getRenderStateFunction(rs);\n    cachedRenderState = RenderState.fromCache(rs);\n    cache[renderState.id] = cachedRenderState;\n  }\n\n  return cachedRenderState;\n}\n\nfunction getTranslucencyUniformMap(state) {\n  return {\n    u_classificationTexture: function () {\n      return state._globeTranslucencyFramebuffer.classificationTexture;\n    },\n  };\n}\n\nfunction getDerivedUniformMap(\n  state,\n  uniformMap,\n  derivedUniformMap,\n  uniformMapDirty,\n  getDerivedUniformMapFunction,\n) {\n  if (!defined(getDerivedUniformMapFunction)) {\n    return uniformMap;\n  }\n\n  if (!uniformMapDirty && defined(derivedUniformMap)) {\n    return derivedUniformMap;\n  }\n\n  return combine(uniformMap, getDerivedUniformMapFunction(state), false);\n}\n\nfunction DerivedCommandPack(options) {\n  this.pass = options.pass;\n  this.pickOnly = options.pickOnly;\n  this.getShaderProgramFunction = options.getShaderProgramFunction;\n  this.getRenderStateFunction = options.getRenderStateFunction;\n  this.getUniformMapFunction = options.getUniformMapFunction;\n  this.renderStateCache = {};\n}\n\nfunction createDerivedCommandPacks() {\n  return [\n    // opaqueFrontFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.GLOBE,\n      pickOnly: false,\n      getShaderProgramFunction: getOpaqueFrontFaceShaderProgram,\n      getRenderStateFunction: getOpaqueFrontFaceRenderState,\n      getUniformMapFunction: undefined,\n    }),\n    // opaqueBackFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.GLOBE,\n      pickOnly: false,\n      getShaderProgramFunction: getOpaqueBackFaceShaderProgram,\n      getRenderStateFunction: getOpaqueBackFaceRenderState,\n      getUniformMapFunction: undefined,\n    }),\n    // depthOnlyFrontFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.GLOBE,\n      pickOnly: false,\n      getShaderProgramFunction: getDepthOnlyShaderProgram,\n      getRenderStateFunction: getDepthOnlyFrontFaceRenderState,\n      getUniformMapFunction: undefined,\n    }),\n    // depthOnlyBackFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.GLOBE,\n      pickOnly: false,\n      getShaderProgramFunction: getDepthOnlyShaderProgram,\n      getRenderStateFunction: getDepthOnlyBackFaceRenderState,\n      getUniformMapFunction: undefined,\n    }),\n    // depthOnlyFrontAndBackFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.GLOBE,\n      pickOnly: false,\n      getShaderProgramFunction: getDepthOnlyShaderProgram,\n      getRenderStateFunction: getDepthOnlyFrontAndBackFaceRenderState,\n      getUniformMapFunction: undefined,\n    }),\n    // translucentFrontFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.TRANSLUCENT,\n      pickOnly: false,\n      getShaderProgramFunction: getTranslucentShaderProgram,\n      getRenderStateFunction: getTranslucentFrontFaceRenderState,\n      getUniformMapFunction: getTranslucencyUniformMap,\n    }),\n    // translucentBackFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.TRANSLUCENT,\n      pickOnly: false,\n      getShaderProgramFunction: getTranslucentBackFaceShaderProgram,\n      getRenderStateFunction: getTranslucentBackFaceRenderState,\n      getUniformMapFunction: getTranslucencyUniformMap,\n    }),\n    // translucentFrontFaceManualDepthTestCommand\n    new DerivedCommandPack({\n      pass: Pass.TRANSLUCENT,\n      pickOnly: false,\n      getShaderProgramFunction:\n        getTranslucentFrontFaceManualDepthTestShaderProgram,\n      getRenderStateFunction: getTranslucentFrontFaceRenderState,\n      getUniformMapFunction: getTranslucencyUniformMap,\n    }),\n    // translucentBackFaceManualDepthTestCommand\n    new DerivedCommandPack({\n      pass: Pass.TRANSLUCENT,\n      pickOnly: false,\n      getShaderProgramFunction:\n        getTranslucentBackFaceManualDepthTestShaderProgram,\n      getRenderStateFunction: getTranslucentBackFaceRenderState,\n      getUniformMapFunction: getTranslucencyUniformMap,\n    }),\n    // pickFrontFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.TRANSLUCENT,\n      pickOnly: true,\n      getShaderProgramFunction: getPickShaderProgram,\n      getRenderStateFunction: getPickFrontFaceRenderState,\n      getUniformMapFunction: getTranslucencyUniformMap,\n    }),\n    // pickBackFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.TRANSLUCENT,\n      pickOnly: true,\n      getShaderProgramFunction: getPickShaderProgram,\n      getRenderStateFunction: getPickBackFaceRenderState,\n      getUniformMapFunction: getTranslucencyUniformMap,\n    }),\n  ];\n}\n\nconst derivedCommandNames = new Array(derivedCommandsMaximumLength);\nconst derivedCommandPacks = new Array(derivedCommandsMaximumLength);\n\nGlobeTranslucencyState.prototype.updateDerivedCommands = function (\n  command,\n  frameState,\n) {\n  const derivedCommandTypes = this._derivedCommandTypesToUpdate;\n  const derivedCommandsLength = this._derivedCommandsToUpdateLength;\n\n  if (derivedCommandsLength === 0) {\n    return;\n  }\n\n  for (let i = 0; i < derivedCommandsLength; ++i) {\n    derivedCommandPacks[i] = this._derivedCommandPacks[derivedCommandTypes[i]];\n    derivedCommandNames[i] = DerivedCommandNames[derivedCommandTypes[i]];\n  }\n\n  updateDerivedCommands(\n    this,\n    command,\n    derivedCommandsLength,\n    derivedCommandTypes,\n    derivedCommandNames,\n    derivedCommandPacks,\n    frameState,\n  );\n};\n\nfunction updateDerivedCommands(\n  state,\n  command,\n  derivedCommandsLength,\n  derivedCommandTypes,\n  derivedCommandNames,\n  derivedCommandPacks,\n  frameState,\n) {\n  let derivedCommandsObject = command.derivedCommands.globeTranslucency;\n  const derivedCommandsDirty = state._derivedCommandsDirty;\n\n  if (\n    command.dirty ||\n    !defined(derivedCommandsObject) ||\n    derivedCommandsDirty\n  ) {\n    command.dirty = false;\n\n    if (!defined(derivedCommandsObject)) {\n      derivedCommandsObject = {};\n      command.derivedCommands.globeTranslucency = derivedCommandsObject;\n    }\n\n    const frameNumber = frameState.frameNumber;\n\n    const uniformMapDirtyFrame =\n      derivedCommandsObject.uniformMapDirtyFrame ?? 0;\n    const shaderProgramDirtyFrame =\n      derivedCommandsObject.shaderProgramDirtyFrame ?? 0;\n    const renderStateDirtyFrame =\n      derivedCommandsObject.renderStateDirtyFrame ?? 0;\n\n    const uniformMapDirty =\n      derivedCommandsObject.uniformMap !== command.uniformMap;\n\n    const shaderProgramDirty =\n      derivedCommandsObject.shaderProgramId !== command.shaderProgram.id;\n\n    const renderStateDirty =\n      derivedCommandsObject.renderStateId !== command.renderState.id;\n\n    if (uniformMapDirty) {\n      derivedCommandsObject.uniformMapDirtyFrame = frameNumber;\n    }\n    if (shaderProgramDirty) {\n      derivedCommandsObject.shaderProgramDirtyFrame = frameNumber;\n    }\n    if (renderStateDirty) {\n      derivedCommandsObject.renderStateDirtyFrame = frameNumber;\n    }\n\n    derivedCommandsObject.uniformMap = command.uniformMap;\n    derivedCommandsObject.shaderProgramId = command.shaderProgram.id;\n    derivedCommandsObject.renderStateId = command.renderState.id;\n\n    for (let i = 0; i < derivedCommandsLength; ++i) {\n      const derivedCommandPack = derivedCommandPacks[i];\n      const derivedCommandType = derivedCommandTypes[i];\n      const derivedCommandName = derivedCommandNames[i];\n      let derivedCommand = derivedCommandsObject[derivedCommandName];\n\n      let derivedUniformMap;\n      let derivedShaderProgram;\n      let derivedRenderState;\n\n      if (defined(derivedCommand)) {\n        derivedUniformMap = derivedCommand.uniformMap;\n        derivedShaderProgram = derivedCommand.shaderProgram;\n        derivedRenderState = derivedCommand.renderState;\n      } else {\n        derivedUniformMap = undefined;\n        derivedShaderProgram = undefined;\n        derivedRenderState = undefined;\n      }\n\n      derivedCommand = DrawCommand.shallowClone(command, derivedCommand);\n      derivedCommandsObject[derivedCommandName] = derivedCommand;\n\n      const derivedUniformMapDirtyFrame =\n        derivedCommand.derivedCommands.uniformMapDirtyFrame ?? 0;\n      const derivedShaderProgramDirtyFrame =\n        derivedCommand.derivedCommands.shaderProgramDirtyFrame ?? 0;\n      const derivedRenderStateDirtyFrame =\n        derivedCommand.derivedCommands.renderStateDirtyFrame ?? 0;\n\n      const derivedUniformMapDirty =\n        uniformMapDirty || derivedUniformMapDirtyFrame < uniformMapDirtyFrame;\n      const derivedShaderProgramDirty =\n        shaderProgramDirty ||\n        derivedShaderProgramDirtyFrame < shaderProgramDirtyFrame;\n      const derivedRenderStateDirty =\n        renderStateDirty ||\n        derivedRenderStateDirtyFrame < renderStateDirtyFrame;\n\n      if (derivedUniformMapDirty) {\n        derivedCommand.derivedCommands.uniformMapDirtyFrame = frameNumber;\n      }\n      if (derivedShaderProgramDirty) {\n        derivedCommand.derivedCommands.shaderProgramDirtyFrame = frameNumber;\n      }\n      if (derivedRenderStateDirty) {\n        derivedCommand.derivedCommands.renderStateDirtyFrame = frameNumber;\n      }\n\n      derivedCommand.derivedCommands.type = derivedCommandType;\n      derivedCommand.pass = derivedCommandPack.pass;\n      derivedCommand.pickOnly = derivedCommandPack.pickOnly;\n      derivedCommand.uniformMap = getDerivedUniformMap(\n        state,\n        command.uniformMap,\n        derivedUniformMap,\n        derivedUniformMapDirty,\n        derivedCommandPack.getUniformMapFunction,\n      );\n      derivedCommand.shaderProgram = getDerivedShaderProgram(\n        frameState.context,\n        command.shaderProgram,\n        derivedShaderProgram,\n        derivedShaderProgramDirty,\n        derivedCommandPack.getShaderProgramFunction,\n        derivedCommandName,\n      );\n      derivedCommand.renderState = getDerivedRenderState(\n        command.renderState,\n        derivedRenderState,\n        derivedRenderStateDirty,\n        derivedCommandPack.getRenderStateFunction,\n        derivedCommandPack.renderStateCache,\n      );\n    }\n  }\n}\n\nGlobeTranslucencyState.prototype.pushDerivedCommands = function (\n  command,\n  isBlendCommand,\n  frameState,\n) {\n  const picking = frameState.passes.pick || frameState.passes.pickVoxel;\n  if (picking && isBlendCommand) {\n    // No need to push blend commands in the pick pass\n    return;\n  }\n\n  let derivedCommandTypes = this._derivedCommandTypes;\n  let derivedCommandsLength = this._derivedCommandsLength;\n\n  if (picking) {\n    derivedCommandTypes = this._derivedPickCommandTypes;\n    derivedCommandsLength = this._derivedPickCommandsLength;\n  } else if (isBlendCommand) {\n    derivedCommandTypes = this._derivedBlendCommandTypes;\n    derivedCommandsLength = this._derivedBlendCommandsLength;\n  }\n\n  if (derivedCommandsLength === 0) {\n    // No derived commands to push so just push the globe command\n    frameState.commandList.push(command);\n    return;\n  }\n\n  // Push derived commands\n  const derivedCommands = command.derivedCommands.globeTranslucency;\n  for (let i = 0; i < derivedCommandsLength; ++i) {\n    const derivedCommandName = DerivedCommandNames[derivedCommandTypes[i]];\n    frameState.commandList.push(derivedCommands[derivedCommandName]);\n  }\n};\n\nfunction executeCommandsMatchingType(\n  commands,\n  commandsLength,\n  executeCommandFunction,\n  scene,\n  passState,\n  types,\n) {\n  for (let i = 0; i < commandsLength; ++i) {\n    const command = commands[i];\n    const type = command.derivedCommands.type;\n    if (!defined(types) || types.indexOf(type) > -1) {\n      executeCommandFunction(command, scene, passState);\n    }\n  }\n}\n\nfunction executeCommands(\n  commands,\n  commandsLength,\n  executeCommandFunction,\n  scene,\n  passState,\n) {\n  for (let i = 0; i < commandsLength; ++i) {\n    executeCommandFunction(commands[i], scene, passState);\n  }\n}\n\nconst opaqueTypes = [\n  DerivedCommandType.OPAQUE_FRONT_FACE,\n  DerivedCommandType.OPAQUE_BACK_FACE,\n];\nconst depthOnlyTypes = [\n  DerivedCommandType.DEPTH_ONLY_FRONT_FACE,\n  DerivedCommandType.DEPTH_ONLY_BACK_FACE,\n  DerivedCommandType.DEPTH_ONLY_FRONT_AND_BACK_FACE,\n];\n\nGlobeTranslucencyState.prototype.executeGlobeCommands = function (\n  frustumCommands,\n  executeCommandFunction,\n  globeTranslucencyFramebuffer,\n  scene,\n  passState,\n) {\n  const context = scene.context;\n  const globeCommands = frustumCommands.commands[Pass.GLOBE];\n  const globeCommandsLength = frustumCommands.indices[Pass.GLOBE];\n\n  if (globeCommandsLength === 0) {\n    return;\n  }\n\n  this._globeTranslucencyFramebuffer = globeTranslucencyFramebuffer;\n  globeTranslucencyFramebuffer.clearClassification(context, passState);\n\n  // Render opaque commands like normal\n  executeCommandsMatchingType(\n    globeCommands,\n    globeCommandsLength,\n    executeCommandFunction,\n    scene,\n    passState,\n    opaqueTypes,\n  );\n};\n\nGlobeTranslucencyState.prototype.executeGlobeClassificationCommands = function (\n  frustumCommands,\n  executeCommandFunction,\n  globeTranslucencyFramebuffer,\n  scene,\n  passState,\n) {\n  const { context } = scene;\n  const { uniformState } = context;\n\n  const globeCommands = frustumCommands.commands[Pass.GLOBE];\n  const globeCommandsLength = frustumCommands.indices[Pass.GLOBE];\n  const classificationCommands =\n    frustumCommands.commands[Pass.TERRAIN_CLASSIFICATION];\n  const classificationCommandsLength =\n    frustumCommands.indices[Pass.TERRAIN_CLASSIFICATION];\n\n  if (globeCommandsLength === 0 || classificationCommandsLength === 0) {\n    return;\n  }\n\n  const frontTranslucent = this._frontFaceTranslucent;\n  const backTranslucent = this._backFaceTranslucent;\n\n  if (!frontTranslucent || !backTranslucent) {\n    // Render classification on opaque faces like normal\n    executeCommands(\n      classificationCommands,\n      classificationCommandsLength,\n      executeCommandFunction,\n      scene,\n      passState,\n    );\n  }\n\n  if (!frontTranslucent && !backTranslucent) {\n    // No translucent commands to render. Skip translucent classification.\n    return;\n  }\n\n  this._globeTranslucencyFramebuffer = globeTranslucencyFramebuffer;\n\n  const originalGlobeDepthTexture = uniformState.globeDepthTexture;\n  const originalFramebuffer = passState.framebuffer;\n\n  // Render to internal framebuffer and get the first depth peel\n  passState.framebuffer =\n    globeTranslucencyFramebuffer.classificationFramebuffer;\n\n  executeCommandsMatchingType(\n    globeCommands,\n    globeCommandsLength,\n    executeCommandFunction,\n    scene,\n    passState,\n    depthOnlyTypes,\n  );\n\n  if (context.depthTexture) {\n    // Pack depth into separate texture for ground polylines and textured ground primitives\n    const packedDepthTexture = globeTranslucencyFramebuffer.packDepth(\n      context,\n      passState,\n    );\n    uniformState.globeDepthTexture = packedDepthTexture;\n  }\n\n  // Render classification on translucent faces\n  executeCommands(\n    classificationCommands,\n    classificationCommandsLength,\n    executeCommandFunction,\n    scene,\n    passState,\n  );\n\n  // Unset temporary state\n  uniformState.globeDepthTexture = originalGlobeDepthTexture;\n  passState.framebuffer = originalFramebuffer;\n};\n\nexport default GlobeTranslucencyState;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}