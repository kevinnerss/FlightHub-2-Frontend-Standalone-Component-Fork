{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport defined from \"../Core/defined.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\n\n/**\n * @private\n */\nfunction ShadowMapShader() {}\nShadowMapShader.getShadowCastShaderKeyword = function (isPointLight, isTerrain, usesDepthTexture, isOpaque) {\n  return `castShadow ${isPointLight} ${isTerrain} ${usesDepthTexture} ${isOpaque}`;\n};\nShadowMapShader.createShadowCastVertexShader = function (vs, isPointLight, isTerrain) {\n  const defines = vs.defines.slice(0);\n  const sources = vs.sources.slice(0);\n  defines.push(\"SHADOW_MAP\");\n  if (isTerrain) {\n    defines.push(\"GENERATE_POSITION\");\n  }\n  const positionVaryingName = ShaderSource.findPositionVarying(vs);\n  const hasPositionVarying = defined(positionVaryingName);\n  if (isPointLight && !hasPositionVarying) {\n    const length = sources.length;\n    for (let j = 0; j < length; ++j) {\n      sources[j] = ShaderSource.replaceMain(sources[j], \"czm_shadow_cast_main\");\n    }\n    const shadowVS = \"out vec3 v_positionEC; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    czm_shadow_cast_main(); \\n\" + \"    v_positionEC = (czm_inverseProjection * gl_Position).xyz; \\n\" + \"}\";\n    sources.push(shadowVS);\n  }\n  return new ShaderSource({\n    defines: defines,\n    sources: sources\n  });\n};\nShadowMapShader.createShadowCastFragmentShader = function (fs, isPointLight, usesDepthTexture, opaque) {\n  const defines = fs.defines.slice(0);\n  const sources = fs.sources.slice(0);\n  defines.push(\"SHADOW_MAP\");\n  let positionVaryingName = ShaderSource.findPositionVarying(fs);\n  const hasPositionVarying = defined(positionVaryingName);\n  if (!hasPositionVarying) {\n    positionVaryingName = \"v_positionEC\";\n  }\n  const length = sources.length;\n  for (let i = 0; i < length; ++i) {\n    sources[i] = ShaderSource.replaceMain(sources[i], \"czm_shadow_cast_main\");\n  }\n  let fsSource = \"\";\n  if (isPointLight) {\n    if (!hasPositionVarying) {\n      fsSource += \"in vec3 v_positionEC; \\n\";\n    }\n    fsSource += \"uniform vec4 shadowMap_lightPositionEC; \\n\";\n  }\n  if (opaque) {\n    fsSource += \"void main() \\n\" + \"{ \\n\";\n  } else {\n    fsSource += \"void main() \\n\" + \"{ \\n\" + \"    czm_shadow_cast_main(); \\n\" + \"    if (out_FragColor.a == 0.0) \\n\" + \"    { \\n\" + \"       discard; \\n\" + \"    } \\n\";\n  }\n  if (isPointLight) {\n    fsSource += `    float distance = length(${positionVaryingName}); \\n` + `    if (distance >= shadowMap_lightPositionEC.w) \\n` + `    { \\n` + `        discard; \\n` + `    } \\n` + `    distance /= shadowMap_lightPositionEC.w; // radius \\n` + `    out_FragColor = czm_packDepth(distance); \\n`;\n  } else if (usesDepthTexture) {\n    fsSource += \"    out_FragColor = vec4(1.0); \\n\";\n  } else {\n    fsSource += \"    out_FragColor = czm_packDepth(gl_FragCoord.z); \\n\";\n  }\n  fsSource += \"} \\n\";\n  sources.push(fsSource);\n  return new ShaderSource({\n    defines: defines,\n    sources: sources\n  });\n};\nShadowMapShader.getShadowReceiveShaderKeyword = function (shadowMap, castShadows, isTerrain, hasTerrainNormal) {\n  const usesDepthTexture = shadowMap._usesDepthTexture;\n  const polygonOffsetSupported = shadowMap._polygonOffsetSupported;\n  const isPointLight = shadowMap._isPointLight;\n  const isSpotLight = shadowMap._isSpotLight;\n  const hasCascades = shadowMap._numberOfCascades > 1;\n  const debugCascadeColors = shadowMap.debugCascadeColors;\n  const softShadows = shadowMap.softShadows;\n  return `receiveShadow ${usesDepthTexture}${polygonOffsetSupported}${isPointLight}${isSpotLight}${hasCascades}${debugCascadeColors}${softShadows}${castShadows}${isTerrain}${hasTerrainNormal}`;\n};\nShadowMapShader.createShadowReceiveVertexShader = function (vs, isTerrain, hasTerrainNormal) {\n  const defines = vs.defines.slice(0);\n  const sources = vs.sources.slice(0);\n  defines.push(\"SHADOW_MAP\");\n  if (isTerrain) {\n    if (hasTerrainNormal) {\n      defines.push(\"GENERATE_POSITION_AND_NORMAL\");\n    } else {\n      defines.push(\"GENERATE_POSITION\");\n    }\n  }\n  return new ShaderSource({\n    defines: defines,\n    sources: sources\n  });\n};\nShadowMapShader.createShadowReceiveFragmentShader = function (fs, shadowMap, castShadows, isTerrain, hasTerrainNormal) {\n  const normalVaryingName = ShaderSource.findNormalVarying(fs);\n  const hasNormalVarying = !isTerrain && defined(normalVaryingName) || isTerrain && hasTerrainNormal;\n  const positionVaryingName = ShaderSource.findPositionVarying(fs);\n  const hasPositionVarying = defined(positionVaryingName);\n  const usesDepthTexture = shadowMap._usesDepthTexture;\n  const polygonOffsetSupported = shadowMap._polygonOffsetSupported;\n  const isPointLight = shadowMap._isPointLight;\n  const isSpotLight = shadowMap._isSpotLight;\n  const hasCascades = shadowMap._numberOfCascades > 1;\n  const debugCascadeColors = shadowMap.debugCascadeColors;\n  const softShadows = shadowMap.softShadows;\n  const bias = isPointLight ? shadowMap._pointBias : isTerrain ? shadowMap._terrainBias : shadowMap._primitiveBias;\n  const defines = fs.defines.slice(0);\n  const sources = fs.sources.slice(0);\n  const length = sources.length;\n  for (let i = 0; i < length; ++i) {\n    sources[i] = ShaderSource.replaceMain(sources[i], \"czm_shadow_receive_main\");\n  }\n  if (isPointLight) {\n    defines.push(\"USE_CUBE_MAP_SHADOW\");\n  } else if (usesDepthTexture) {\n    defines.push(\"USE_SHADOW_DEPTH_TEXTURE\");\n  }\n  if (softShadows && !isPointLight) {\n    defines.push(\"USE_SOFT_SHADOWS\");\n  }\n\n  // Enable day-night shading so that the globe is dark when the light is below the horizon\n  if (hasCascades && castShadows && isTerrain) {\n    if (hasNormalVarying) {\n      defines.push(\"ENABLE_VERTEX_LIGHTING\");\n    } else {\n      defines.push(\"ENABLE_DAYNIGHT_SHADING\");\n    }\n  }\n  if (castShadows && bias.normalShading && hasNormalVarying) {\n    defines.push(\"USE_NORMAL_SHADING\");\n    if (bias.normalShadingSmooth > 0.0) {\n      defines.push(\"USE_NORMAL_SHADING_SMOOTH\");\n    }\n  }\n  let fsSource = \"\";\n  if (isPointLight) {\n    fsSource += \"uniform samplerCube shadowMap_textureCube; \\n\";\n  } else {\n    fsSource += \"uniform sampler2D shadowMap_texture; \\n\";\n  }\n  let returnPositionEC;\n  if (hasPositionVarying) {\n    returnPositionEC = `    return vec4(${positionVaryingName}, 1.0); \\n`;\n  } else {\n    returnPositionEC = \"#ifndef LOG_DEPTH \\n\" + \"    return czm_windowToEyeCoordinates(gl_FragCoord); \\n\" + \"#else \\n\" + \"    return vec4(v_logPositionEC, 1.0); \\n\" + \"#endif \\n\";\n  }\n  fsSource += `${\"uniform mat4 shadowMap_matrix; \\n\" + \"uniform vec3 shadowMap_lightDirectionEC; \\n\" + \"uniform vec4 shadowMap_lightPositionEC; \\n\" + \"uniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \\n\" + \"uniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \\n\" + \"#ifdef LOG_DEPTH \\n\" + \"in vec3 v_logPositionEC; \\n\" + \"#endif \\n\" + \"vec4 getPositionEC() \\n\" + \"{ \\n\"}${returnPositionEC}} \\n` + `vec3 getNormalEC() \\n` + `{ \\n${hasNormalVarying ? `    return normalize(${normalVaryingName}); \\n` : \"    return vec3(1.0); \\n\"}} \\n` +\n  // Offset the shadow position in the direction of the normal for perpendicular and back faces\n  `void applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \\n` + `{ \\n${bias.normalOffset && hasNormalVarying ? \"    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \\n\" + \"    float normalOffsetScale = 1.0 - nDotL; \\n\" + \"    vec3 offset = normalOffset * normalOffsetScale * normalEC; \\n\" + \"    positionEC.xyz += offset; \\n\" : \"\"}} \\n`;\n  fsSource += \"void main() \\n\" + \"{ \\n\" + \"    czm_shadow_receive_main(); \\n\" + \"    vec4 positionEC = getPositionEC(); \\n\" + \"    vec3 normalEC = getNormalEC(); \\n\" + \"    float depth = -positionEC.z; \\n\";\n  fsSource += \"    czm_shadowParameters shadowParameters; \\n\" + \"    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \\n\" + \"    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \\n\" + \"    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \\n\" + \"    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \\n\";\n  if (isTerrain) {\n    // Scale depth bias based on view distance to reduce z-fighting in distant terrain\n    fsSource += \"    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \\n\";\n  } else if (!polygonOffsetSupported) {\n    // If polygon offset isn't supported push the depth back based on view, however this\n    // causes light leaking at further away views\n    fsSource += \"    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \\n\";\n  }\n  if (isPointLight) {\n    fsSource += \"    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \\n\" + \"    float distance = length(directionEC); \\n\" + \"    directionEC = normalize(directionEC); \\n\" + \"    float radius = shadowMap_lightPositionEC.w; \\n\" + \"    // Stop early if the fragment is beyond the point light radius \\n\" + \"    if (distance > radius) \\n\" + \"    { \\n\" + \"        return; \\n\" + \"    } \\n\" + \"    vec3 directionWC  = czm_inverseViewRotation * directionEC; \\n\" + \"    shadowParameters.depth = distance / radius; \\n\" + \"    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \\n\" + \"    shadowParameters.texCoords = directionWC; \\n\" + \"    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \\n\";\n  } else if (isSpotLight) {\n    fsSource += \"    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \\n\" + \"    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \\n\" + \"    applyNormalOffset(positionEC, normalEC, nDotL); \\n\" + \"    vec4 shadowPosition = shadowMap_matrix * positionEC; \\n\" + \"    // Spot light uses a perspective projection, so perform the perspective divide \\n\" + \"    shadowPosition /= shadowPosition.w; \\n\" + \"    // Stop early if the fragment is not in the shadow bounds \\n\" + \"    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \\n\" + \"    { \\n\" + \"        return; \\n\" + \"    } \\n\" + \"    shadowParameters.texCoords = shadowPosition.xy; \\n\" + \"    shadowParameters.depth = shadowPosition.z; \\n\" + \"    shadowParameters.nDotL = nDotL; \\n\" + \"    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \\n\";\n  } else if (hasCascades) {\n    fsSource += `${\"    float maxDepth = shadowMap_cascadeSplits[1].w; \\n\" + \"    // Stop early if the eye depth exceeds the last cascade \\n\" + \"    if (depth > maxDepth) \\n\" + \"    { \\n\" + \"        return; \\n\" + \"    } \\n\" + \"    // Get the cascade based on the eye-space depth \\n\" + \"    vec4 weights = czm_cascadeWeights(depth); \\n\" + \"    // Apply normal offset \\n\" + \"    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \\n\" + \"    applyNormalOffset(positionEC, normalEC, nDotL); \\n\" + \"    // Transform position into the cascade \\n\" + \"    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \\n\" + \"    // Get visibility \\n\" + \"    shadowParameters.texCoords = shadowPosition.xy; \\n\" + \"    shadowParameters.depth = shadowPosition.z; \\n\" + \"    shadowParameters.nDotL = nDotL; \\n\" + \"    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \\n\" + \"    // Fade out shadows that are far away \\n\" + \"    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \\n\" + \"    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \\n\" + \"    visibility = mix(visibility, 1.0, fade); \\n\"}${debugCascadeColors ? \"    // Draw cascade colors for debugging \\n\" + \"    out_FragColor *= czm_cascadeColor(weights); \\n\" : \"\"}`;\n  } else {\n    fsSource += \"    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \\n\" + \"    applyNormalOffset(positionEC, normalEC, nDotL); \\n\" + \"    vec4 shadowPosition = shadowMap_matrix * positionEC; \\n\" + \"    // Stop early if the fragment is not in the shadow bounds \\n\" + \"    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \\n\" + \"    { \\n\" + \"        return; \\n\" + \"    } \\n\" + \"    shadowParameters.texCoords = shadowPosition.xy; \\n\" + \"    shadowParameters.depth = shadowPosition.z; \\n\" + \"    shadowParameters.nDotL = nDotL; \\n\" + \"    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \\n\";\n  }\n  fsSource += \"    out_FragColor.rgb *= visibility; \\n\" + \"} \\n\";\n  sources.push(fsSource);\n  return new ShaderSource({\n    defines: defines,\n    sources: sources\n  });\n};\nexport default ShadowMapShader;","map":{"version":3,"names":["defined","ShaderSource","ShadowMapShader","getShadowCastShaderKeyword","isPointLight","isTerrain","usesDepthTexture","isOpaque","createShadowCastVertexShader","vs","defines","slice","sources","push","positionVaryingName","findPositionVarying","hasPositionVarying","length","j","replaceMain","shadowVS","createShadowCastFragmentShader","fs","opaque","i","fsSource","getShadowReceiveShaderKeyword","shadowMap","castShadows","hasTerrainNormal","_usesDepthTexture","polygonOffsetSupported","_polygonOffsetSupported","_isPointLight","isSpotLight","_isSpotLight","hasCascades","_numberOfCascades","debugCascadeColors","softShadows","createShadowReceiveVertexShader","createShadowReceiveFragmentShader","normalVaryingName","findNormalVarying","hasNormalVarying","bias","_pointBias","_terrainBias","_primitiveBias","normalShading","normalShadingSmooth","returnPositionEC","normalOffset"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/ShadowMapShader.js"],"sourcesContent":["import defined from \"../Core/defined.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\n\n/**\n * @private\n */\nfunction ShadowMapShader() {}\n\nShadowMapShader.getShadowCastShaderKeyword = function (\n  isPointLight,\n  isTerrain,\n  usesDepthTexture,\n  isOpaque,\n) {\n  return `castShadow ${isPointLight} ${isTerrain} ${usesDepthTexture} ${isOpaque}`;\n};\n\nShadowMapShader.createShadowCastVertexShader = function (\n  vs,\n  isPointLight,\n  isTerrain,\n) {\n  const defines = vs.defines.slice(0);\n  const sources = vs.sources.slice(0);\n\n  defines.push(\"SHADOW_MAP\");\n\n  if (isTerrain) {\n    defines.push(\"GENERATE_POSITION\");\n  }\n\n  const positionVaryingName = ShaderSource.findPositionVarying(vs);\n  const hasPositionVarying = defined(positionVaryingName);\n\n  if (isPointLight && !hasPositionVarying) {\n    const length = sources.length;\n    for (let j = 0; j < length; ++j) {\n      sources[j] = ShaderSource.replaceMain(sources[j], \"czm_shadow_cast_main\");\n    }\n\n    const shadowVS =\n      \"out vec3 v_positionEC; \\n\" +\n      \"void main() \\n\" +\n      \"{ \\n\" +\n      \"    czm_shadow_cast_main(); \\n\" +\n      \"    v_positionEC = (czm_inverseProjection * gl_Position).xyz; \\n\" +\n      \"}\";\n    sources.push(shadowVS);\n  }\n\n  return new ShaderSource({\n    defines: defines,\n    sources: sources,\n  });\n};\n\nShadowMapShader.createShadowCastFragmentShader = function (\n  fs,\n  isPointLight,\n  usesDepthTexture,\n  opaque,\n) {\n  const defines = fs.defines.slice(0);\n  const sources = fs.sources.slice(0);\n\n  defines.push(\"SHADOW_MAP\");\n\n  let positionVaryingName = ShaderSource.findPositionVarying(fs);\n  const hasPositionVarying = defined(positionVaryingName);\n  if (!hasPositionVarying) {\n    positionVaryingName = \"v_positionEC\";\n  }\n\n  const length = sources.length;\n  for (let i = 0; i < length; ++i) {\n    sources[i] = ShaderSource.replaceMain(sources[i], \"czm_shadow_cast_main\");\n  }\n\n  let fsSource = \"\";\n\n  if (isPointLight) {\n    if (!hasPositionVarying) {\n      fsSource += \"in vec3 v_positionEC; \\n\";\n    }\n    fsSource += \"uniform vec4 shadowMap_lightPositionEC; \\n\";\n  }\n\n  if (opaque) {\n    fsSource += \"void main() \\n\" + \"{ \\n\";\n  } else {\n    fsSource +=\n      \"void main() \\n\" +\n      \"{ \\n\" +\n      \"    czm_shadow_cast_main(); \\n\" +\n      \"    if (out_FragColor.a == 0.0) \\n\" +\n      \"    { \\n\" +\n      \"       discard; \\n\" +\n      \"    } \\n\";\n  }\n\n  if (isPointLight) {\n    fsSource +=\n      `    float distance = length(${positionVaryingName}); \\n` +\n      `    if (distance >= shadowMap_lightPositionEC.w) \\n` +\n      `    { \\n` +\n      `        discard; \\n` +\n      `    } \\n` +\n      `    distance /= shadowMap_lightPositionEC.w; // radius \\n` +\n      `    out_FragColor = czm_packDepth(distance); \\n`;\n  } else if (usesDepthTexture) {\n    fsSource += \"    out_FragColor = vec4(1.0); \\n\";\n  } else {\n    fsSource += \"    out_FragColor = czm_packDepth(gl_FragCoord.z); \\n\";\n  }\n\n  fsSource += \"} \\n\";\n\n  sources.push(fsSource);\n\n  return new ShaderSource({\n    defines: defines,\n    sources: sources,\n  });\n};\n\nShadowMapShader.getShadowReceiveShaderKeyword = function (\n  shadowMap,\n  castShadows,\n  isTerrain,\n  hasTerrainNormal,\n) {\n  const usesDepthTexture = shadowMap._usesDepthTexture;\n  const polygonOffsetSupported = shadowMap._polygonOffsetSupported;\n  const isPointLight = shadowMap._isPointLight;\n  const isSpotLight = shadowMap._isSpotLight;\n  const hasCascades = shadowMap._numberOfCascades > 1;\n  const debugCascadeColors = shadowMap.debugCascadeColors;\n  const softShadows = shadowMap.softShadows;\n\n  return `receiveShadow ${usesDepthTexture}${polygonOffsetSupported}${isPointLight}${isSpotLight}${hasCascades}${debugCascadeColors}${softShadows}${castShadows}${isTerrain}${hasTerrainNormal}`;\n};\n\nShadowMapShader.createShadowReceiveVertexShader = function (\n  vs,\n  isTerrain,\n  hasTerrainNormal,\n) {\n  const defines = vs.defines.slice(0);\n  const sources = vs.sources.slice(0);\n\n  defines.push(\"SHADOW_MAP\");\n\n  if (isTerrain) {\n    if (hasTerrainNormal) {\n      defines.push(\"GENERATE_POSITION_AND_NORMAL\");\n    } else {\n      defines.push(\"GENERATE_POSITION\");\n    }\n  }\n\n  return new ShaderSource({\n    defines: defines,\n    sources: sources,\n  });\n};\n\nShadowMapShader.createShadowReceiveFragmentShader = function (\n  fs,\n  shadowMap,\n  castShadows,\n  isTerrain,\n  hasTerrainNormal,\n) {\n  const normalVaryingName = ShaderSource.findNormalVarying(fs);\n  const hasNormalVarying =\n    (!isTerrain && defined(normalVaryingName)) ||\n    (isTerrain && hasTerrainNormal);\n\n  const positionVaryingName = ShaderSource.findPositionVarying(fs);\n  const hasPositionVarying = defined(positionVaryingName);\n\n  const usesDepthTexture = shadowMap._usesDepthTexture;\n  const polygonOffsetSupported = shadowMap._polygonOffsetSupported;\n  const isPointLight = shadowMap._isPointLight;\n  const isSpotLight = shadowMap._isSpotLight;\n  const hasCascades = shadowMap._numberOfCascades > 1;\n  const debugCascadeColors = shadowMap.debugCascadeColors;\n  const softShadows = shadowMap.softShadows;\n  const bias = isPointLight\n    ? shadowMap._pointBias\n    : isTerrain\n      ? shadowMap._terrainBias\n      : shadowMap._primitiveBias;\n\n  const defines = fs.defines.slice(0);\n  const sources = fs.sources.slice(0);\n\n  const length = sources.length;\n  for (let i = 0; i < length; ++i) {\n    sources[i] = ShaderSource.replaceMain(\n      sources[i],\n      \"czm_shadow_receive_main\",\n    );\n  }\n\n  if (isPointLight) {\n    defines.push(\"USE_CUBE_MAP_SHADOW\");\n  } else if (usesDepthTexture) {\n    defines.push(\"USE_SHADOW_DEPTH_TEXTURE\");\n  }\n\n  if (softShadows && !isPointLight) {\n    defines.push(\"USE_SOFT_SHADOWS\");\n  }\n\n  // Enable day-night shading so that the globe is dark when the light is below the horizon\n  if (hasCascades && castShadows && isTerrain) {\n    if (hasNormalVarying) {\n      defines.push(\"ENABLE_VERTEX_LIGHTING\");\n    } else {\n      defines.push(\"ENABLE_DAYNIGHT_SHADING\");\n    }\n  }\n\n  if (castShadows && bias.normalShading && hasNormalVarying) {\n    defines.push(\"USE_NORMAL_SHADING\");\n    if (bias.normalShadingSmooth > 0.0) {\n      defines.push(\"USE_NORMAL_SHADING_SMOOTH\");\n    }\n  }\n\n  let fsSource = \"\";\n\n  if (isPointLight) {\n    fsSource += \"uniform samplerCube shadowMap_textureCube; \\n\";\n  } else {\n    fsSource += \"uniform sampler2D shadowMap_texture; \\n\";\n  }\n\n  let returnPositionEC;\n  if (hasPositionVarying) {\n    returnPositionEC = `    return vec4(${positionVaryingName}, 1.0); \\n`;\n  } else {\n    returnPositionEC =\n      \"#ifndef LOG_DEPTH \\n\" +\n      \"    return czm_windowToEyeCoordinates(gl_FragCoord); \\n\" +\n      \"#else \\n\" +\n      \"    return vec4(v_logPositionEC, 1.0); \\n\" +\n      \"#endif \\n\";\n  }\n\n  fsSource +=\n    `${\n      \"uniform mat4 shadowMap_matrix; \\n\" +\n      \"uniform vec3 shadowMap_lightDirectionEC; \\n\" +\n      \"uniform vec4 shadowMap_lightPositionEC; \\n\" +\n      \"uniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \\n\" +\n      \"uniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \\n\" +\n      \"#ifdef LOG_DEPTH \\n\" +\n      \"in vec3 v_logPositionEC; \\n\" +\n      \"#endif \\n\" +\n      \"vec4 getPositionEC() \\n\" +\n      \"{ \\n\"\n    }${returnPositionEC}} \\n` +\n    `vec3 getNormalEC() \\n` +\n    `{ \\n${\n      hasNormalVarying\n        ? `    return normalize(${normalVaryingName}); \\n`\n        : \"    return vec3(1.0); \\n\"\n    }} \\n` +\n    // Offset the shadow position in the direction of the normal for perpendicular and back faces\n    `void applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \\n` +\n    `{ \\n${\n      bias.normalOffset && hasNormalVarying\n        ? \"    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \\n\" +\n          \"    float normalOffsetScale = 1.0 - nDotL; \\n\" +\n          \"    vec3 offset = normalOffset * normalOffsetScale * normalEC; \\n\" +\n          \"    positionEC.xyz += offset; \\n\"\n        : \"\"\n    }} \\n`;\n\n  fsSource +=\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_shadow_receive_main(); \\n\" +\n    \"    vec4 positionEC = getPositionEC(); \\n\" +\n    \"    vec3 normalEC = getNormalEC(); \\n\" +\n    \"    float depth = -positionEC.z; \\n\";\n\n  fsSource +=\n    \"    czm_shadowParameters shadowParameters; \\n\" +\n    \"    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \\n\" +\n    \"    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \\n\" +\n    \"    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \\n\" +\n    \"    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \\n\";\n\n  if (isTerrain) {\n    // Scale depth bias based on view distance to reduce z-fighting in distant terrain\n    fsSource += \"    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \\n\";\n  } else if (!polygonOffsetSupported) {\n    // If polygon offset isn't supported push the depth back based on view, however this\n    // causes light leaking at further away views\n    fsSource +=\n      \"    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \\n\";\n  }\n\n  if (isPointLight) {\n    fsSource +=\n      \"    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \\n\" +\n      \"    float distance = length(directionEC); \\n\" +\n      \"    directionEC = normalize(directionEC); \\n\" +\n      \"    float radius = shadowMap_lightPositionEC.w; \\n\" +\n      \"    // Stop early if the fragment is beyond the point light radius \\n\" +\n      \"    if (distance > radius) \\n\" +\n      \"    { \\n\" +\n      \"        return; \\n\" +\n      \"    } \\n\" +\n      \"    vec3 directionWC  = czm_inverseViewRotation * directionEC; \\n\" +\n      \"    shadowParameters.depth = distance / radius; \\n\" +\n      \"    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \\n\" +\n      \"    shadowParameters.texCoords = directionWC; \\n\" +\n      \"    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \\n\";\n  } else if (isSpotLight) {\n    fsSource +=\n      \"    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \\n\" +\n      \"    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \\n\" +\n      \"    applyNormalOffset(positionEC, normalEC, nDotL); \\n\" +\n      \"    vec4 shadowPosition = shadowMap_matrix * positionEC; \\n\" +\n      \"    // Spot light uses a perspective projection, so perform the perspective divide \\n\" +\n      \"    shadowPosition /= shadowPosition.w; \\n\" +\n      \"    // Stop early if the fragment is not in the shadow bounds \\n\" +\n      \"    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \\n\" +\n      \"    { \\n\" +\n      \"        return; \\n\" +\n      \"    } \\n\" +\n      \"    shadowParameters.texCoords = shadowPosition.xy; \\n\" +\n      \"    shadowParameters.depth = shadowPosition.z; \\n\" +\n      \"    shadowParameters.nDotL = nDotL; \\n\" +\n      \"    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \\n\";\n  } else if (hasCascades) {\n    fsSource += `${\n      \"    float maxDepth = shadowMap_cascadeSplits[1].w; \\n\" +\n      \"    // Stop early if the eye depth exceeds the last cascade \\n\" +\n      \"    if (depth > maxDepth) \\n\" +\n      \"    { \\n\" +\n      \"        return; \\n\" +\n      \"    } \\n\" +\n      \"    // Get the cascade based on the eye-space depth \\n\" +\n      \"    vec4 weights = czm_cascadeWeights(depth); \\n\" +\n      \"    // Apply normal offset \\n\" +\n      \"    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \\n\" +\n      \"    applyNormalOffset(positionEC, normalEC, nDotL); \\n\" +\n      \"    // Transform position into the cascade \\n\" +\n      \"    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \\n\" +\n      \"    // Get visibility \\n\" +\n      \"    shadowParameters.texCoords = shadowPosition.xy; \\n\" +\n      \"    shadowParameters.depth = shadowPosition.z; \\n\" +\n      \"    shadowParameters.nDotL = nDotL; \\n\" +\n      \"    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \\n\" +\n      \"    // Fade out shadows that are far away \\n\" +\n      \"    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \\n\" +\n      \"    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \\n\" +\n      \"    visibility = mix(visibility, 1.0, fade); \\n\"\n    }${\n      debugCascadeColors\n        ? \"    // Draw cascade colors for debugging \\n\" +\n          \"    out_FragColor *= czm_cascadeColor(weights); \\n\"\n        : \"\"\n    }`;\n  } else {\n    fsSource +=\n      \"    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \\n\" +\n      \"    applyNormalOffset(positionEC, normalEC, nDotL); \\n\" +\n      \"    vec4 shadowPosition = shadowMap_matrix * positionEC; \\n\" +\n      \"    // Stop early if the fragment is not in the shadow bounds \\n\" +\n      \"    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \\n\" +\n      \"    { \\n\" +\n      \"        return; \\n\" +\n      \"    } \\n\" +\n      \"    shadowParameters.texCoords = shadowPosition.xy; \\n\" +\n      \"    shadowParameters.depth = shadowPosition.z; \\n\" +\n      \"    shadowParameters.nDotL = nDotL; \\n\" +\n      \"    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \\n\";\n  }\n\n  fsSource += \"    out_FragColor.rgb *= visibility; \\n\" + \"} \\n\";\n\n  sources.push(fsSource);\n\n  return new ShaderSource({\n    defines: defines,\n    sources: sources,\n  });\n};\nexport default ShadowMapShader;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}