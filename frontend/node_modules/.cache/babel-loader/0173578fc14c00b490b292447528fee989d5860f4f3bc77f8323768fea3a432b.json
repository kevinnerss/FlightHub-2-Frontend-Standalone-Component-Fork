{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport defined from \"../../Core/defined.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport Check from \"../../Core/Check.js\";\nimport Rectangle from \"../../Core/Rectangle.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport ImageryLayer from \"../ImageryLayer.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport ImageryFlags from \"./ImageryFlags.js\";\nimport ModelPrimitiveImagery from \"./ModelPrimitiveImagery.js\";\nimport ImageryInput from \"./ImageryInput.js\";\nimport ImageryState from \"../ImageryState.js\";\nimport oneTimeWarning from \"../../Core/oneTimeWarning.js\";\n\n/**\n * A compile-time debugging flag to draw the boundaries of imagery tiles\n * (Similar to \"SHOW_TILE_BOUNDARIES\" in GlobeFS.glsl)\n * @private\n */\nconst debugDrawImageryBoundaries = false;\n\n// Scratch variable for _computeTextureTranslationAndScale\nconst nativeBoundingRectangleScratch = new Rectangle();\n\n// Scratch variable for _computeTextureTranslationAndScale\nconst nativeImageryRectangleScratch = new Rectangle();\n\n/**\n * A pipeline stage that modifies the model shader to take into account\n * imagery textures that are draped over a primitive of the model, when it\n * is part a <code>Model3DTileContent</code> of a <code>Cesium3DTileset</code>\n * that has <code>imageryLayers</code> associated with it.\n *\n * Most of what is done here tries to emulate the parts from\n * https://github.com/CesiumGS/cesium/blob/6cc004aaff586bb59f07f199216ae511014cf5a9/packages/engine/Source/Shaders/GlobeFS.glsl#L166\n * that are relevant for imagery, using the more modern ShaderBuilder structures.\n *\n * @namespace ImageryPipelineStage\n *\n * @private\n */\nclass ImageryPipelineStage {\n  /**\n   * Process a primitive.\n   *\n   * This will update the render resources of the given primitive,\n   * depending on the imagery that is covered by the given primitive.\n   *\n   * This will obtain the <code>ModelPrimitiveImagery</code> from\n   * the given primitive, and use that to compute the actual\n   * <code>ImageryInput</code> objects that describe the information\n   * that has to be passed to the shader for draping the imagery over\n   * the primitive.\n   *\n   * After the <code>ImageryInput</code> has been computed, it will\n   * extend the render resources with the texture coordinate\n   * attribute that has to be used for the imagery, and augment\n   * the <code>primitiveRenderResources.shaderBuilder</code> with\n   * the information hat is required for the draping.\n   *\n   * @param {PrimitiveRenderResources} primitiveRenderResources The render resources for the primitive\n   * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n   * @param {FrameState} frameState The frame state.\n   */\n  static process(primitiveRenderResources, primitive, frameState) {\n    const model = primitiveRenderResources.model;\n    const modelPrimitiveImagery = primitive.modelPrimitiveImagery;\n\n    // When the creation of the model primitive imagery is happening\n    // asynchronously, then the primitive may not yet contain it.\n    // Return early in this case\n    if (!defined(modelPrimitiveImagery)) {\n      return;\n    }\n\n    // Similarly, when the model primitive imagery is not yet ready,\n    // then nothing can be done here\n    if (!modelPrimitiveImagery.ready) {\n      return;\n    }\n\n    // Compute the arrays containing ALL projections and the array\n    // containing the UNIQUE projections from the imagery layers,\n    // to establish the mapping between the imagery index and the\n    // imagery texture coordinate attribute set index.\n    // (This should be implemented and/or documented better...)\n    const imageryLayers = model.imageryLayers;\n    const allProjections = ModelPrimitiveImagery._extractProjections(imageryLayers);\n    const uniqueProjections = [...new Set(allProjections)];\n    const imageryTexCoordAttributeSetIndices = ImageryPipelineStage._computeIndexMapping(allProjections, uniqueProjections);\n\n    // Create the `ImageryInput` objects that describe\n    // - the texture\n    // - texture coordinate rectangle\n    // - translation and scale\n    // - index of the imagery texture coordinate attribute\n    // to be passed to the actual imagery pipeline stage execution\n    const imageryInputs = ImageryPipelineStage._createImageryInputs(imageryLayers, modelPrimitiveImagery, imageryTexCoordAttributeSetIndices);\n\n    // This can happen when none of the imagery textures could\n    // be obtained, because they had all been INVALID/FAILED,\n    // or when none of the imagery layers is actually visible\n    // according to `show==true`\n    // Bail out in this case\n    if (imageryInputs.length === 0) {\n      return;\n    }\n\n    // TODO_DRAPING This will have to be handled with upsampling.\n    // For now, just truncate the textures to not exceed the\n    // number of texture units\n    if (imageryInputs.length > 10) {\n      oneTimeWarning(\"imagery-texture-units\", `Warning: Draped imagery requires ${imageryInputs.length} texture units, truncating`);\n      imageryInputs.length = 10;\n    }\n\n    // Add the imagery texture coordinate attributes to the render\n    // resources\n    ImageryPipelineStage._addImageryTexCoordAttributesToRenderResources(modelPrimitiveImagery, primitiveRenderResources);\n    const imageryLayersArray = [];\n    for (let i = 0; i < imageryLayers.length; i++) {\n      imageryLayersArray.push(imageryLayers.get(i));\n    }\n    ImageryPipelineStage._processImageryInputs(imageryLayersArray, primitiveRenderResources, imageryInputs, uniqueProjections.length);\n  }\n\n  /**\n   * Add one attribute to the render resources, for each imagery texture\n   * coordinate that was computed in the given model primitive imagery\n   * (one for each projection)\n   *\n   * @param {ModelPrimitiveImagery} modelPrimitiveImagery The model primitive imagery\n   * @param {PrimitiveRenderResources} primitiveRenderResources The render resources\n   */\n  static _addImageryTexCoordAttributesToRenderResources(modelPrimitiveImagery, primitiveRenderResources) {\n    const imageryTexCoordAttributes = modelPrimitiveImagery.imageryTexCoordAttributesPerProjection();\n    for (const imageryTexCoordAttribute of imageryTexCoordAttributes) {\n      ImageryPipelineStage._addImageryTexCoordAttributeToRenderResources(imageryTexCoordAttribute, primitiveRenderResources);\n    }\n  }\n\n  /**\n   * Add the given attribute to the render resources\n   *\n   * @param {ModelComponents.Attribute} imageryTexCoordAttribute The attribute\n   * @param {PrimitiveRenderResources} primitiveRenderResources The render resources\n   */\n  static _addImageryTexCoordAttributeToRenderResources(imageryTexCoordAttribute, primitiveRenderResources) {\n    const componentsPerAttribute = AttributeType.getNumberOfComponents(imageryTexCoordAttribute.type);\n    // Convert the given object into another object that essentially\n    // contains the same information, but not exactly, and with most\n    // properties having slightly different names. Shrug.\n    const renderResourcesAttribute = {\n      index: primitiveRenderResources.attributeIndex++,\n      value: defined(imageryTexCoordAttribute.buffer) ? undefined : imageryTexCoordAttribute.constant,\n      vertexBuffer: imageryTexCoordAttribute.buffer,\n      count: imageryTexCoordAttribute.count,\n      componentsPerAttribute: componentsPerAttribute,\n      componentDatatype: imageryTexCoordAttribute.componentDatatype,\n      offsetInBytes: imageryTexCoordAttribute.byteOffset,\n      strideInBytes: imageryTexCoordAttribute.byteStride,\n      normalize: imageryTexCoordAttribute.normalized\n    };\n    primitiveRenderResources.attributes.push(renderResourcesAttribute);\n  }\n\n  /**\n   * Process the <code>ImageryInput</code> objects that have been\n   * created in <code>process</code>.\n   *\n   * This will build the shader, containing the attributes, uniforms,\n   * and \"sample and blend\" function that is required according to\n   * the given imagery inputs\n   *\n   * @param {ImageryLayer[]} imageryLayersArray The imagery layers\n   * @param {PrimitiveRenderResources} primitiveRenderResources The primitive render resources\n   * @param {ImageryInput[]} imageryInputs The imagery inputs\n   * @param {number} numImageryTexCoordAttributes The number of texture coordinate\n   * attributes that have been created for the imagery (one for each distinct\n   * projection that was found in the imagery layers)\n   */\n  static _processImageryInputs(imageryLayersArray, renderResources, imageryInputs, numImageryTexCoordAttributes) {\n    const shaderBuilder = renderResources.shaderBuilder;\n    const imageryFlags = ImageryPipelineStage._computeImageryFlags(imageryLayersArray);\n    const numTextures = imageryInputs.length;\n\n    // Set the global defines indicating the presence and number of\n    // imagery textures.\n    shaderBuilder.addDefine(`HAS_IMAGERY`);\n    shaderBuilder.addDefine(`IMAGERY_TEXTURE_UNITS ${numTextures}`);\n    ImageryPipelineStage._addAttributes(shaderBuilder, numImageryTexCoordAttributes);\n    ImageryPipelineStage._defineUniforms(shaderBuilder, imageryFlags);\n    ImageryPipelineStage._buildSampleAndBlendFunction(shaderBuilder, imageryFlags);\n    ImageryPipelineStage._createMainImageryShader(shaderBuilder, imageryInputs, imageryFlags);\n    const uniformMap = renderResources.uniformMap;\n    const uniforms = ImageryPipelineStage._createImageryUniforms(imageryInputs);\n    ImageryPipelineStage._setImageryUniforms(uniformMap, uniforms);\n  }\n\n  /**\n   * Add the attribute- and varying definitions for the imagery texture\n   * coordinates to the given shader.\n   *\n   * This includes the definition of the <code>initializeImageryAttributes</code>\n   * function that assigns the attribute values to varyings in the vertex shader.\n   *\n   * @param {ShaderBuilder} shaderBuilder The shader builder\n   * @param {number} numTexCoords The number of imagery texture coordinate sets\n   */\n  static _addAttributes(shaderBuilder, numTexCoords) {\n    for (let i = 0; i < numTexCoords; i++) {\n      shaderBuilder.addAttribute(\"vec2\", `a_imagery_texCoord_${i}`);\n      shaderBuilder.addVarying(\"vec2\", `v_imagery_texCoord_${i}`);\n    }\n    const functionId = \"initializeImageryAttributes\";\n    const signature = `void ${functionId}()`;\n    shaderBuilder.addFunction(functionId, signature, ShaderDestination.VERTEX);\n    for (let i = 0; i < numTexCoords; i++) {\n      shaderBuilder.addFunctionLines(functionId, [`v_imagery_texCoord_${i} = a_imagery_texCoord_${i};`]);\n    }\n  }\n\n  /**\n   * Returns the `ImageryFlags` that indicate the features that are\n   * required for the given imagery layers.\n   *\n   * The resulting flags will indicate whether any of the given\n   * imagery layer objects did *not* have the default value for\n   * the respective property, as defined by `ImageryLayer.DEFAULT_...`\n   *\n   * @param {ImageryLayer[]} imageryLayers The imagery layers\n   * @returns {ImageryFlags} The imagery flags\n   */\n  static _computeImageryFlags(imageryLayers) {\n    const imageryFlags = new ImageryFlags();\n    for (let i = 0; i < imageryLayers.length; i++) {\n      const imageryLayer = imageryLayers[i];\n\n      // These are short-circuiting to `number` instead\n      // of `boolean` here. With \"ecmaVersion: 2021\", we\n      // could use \"||=\" here. Otherwise, there is no\n      // nice shortcut for this.\n      imageryFlags.alpha |= imageryLayer.alpha !== 1.0;\n      imageryFlags.brightness |= imageryLayer.brightness !== ImageryLayer.DEFAULT_BRIGHTNESS;\n      imageryFlags.contrast |= imageryLayer.contrast !== ImageryLayer.DEFAULT_CONTRAST;\n      imageryFlags.hue |= imageryLayer.hue !== ImageryLayer.DEFAULT_HUE;\n      imageryFlags.saturation |= imageryLayer.saturation !== ImageryLayer.DEFAULT_SATURATION;\n      imageryFlags.gamma |= imageryLayer.gamma !== ImageryLayer.DEFAULT_GAMMA;\n      const hasColorToAlpha = defined(imageryLayer.colorToAlpha) && imageryLayer.colorToAlphaThreshold > 0.0;\n      imageryFlags.colorToAlpha |= hasColorToAlpha;\n    }\n    return imageryFlags;\n  }\n\n  /**\n   * Adds the uniforms that are required for the imagery to the shader.\n   *\n   * This will use the given shader builder to add the uniforms to the\n   * shader that are always required for the imagery (e.g. the\n   * `sampler2D u_imageryTextures[...]`).\n   *\n   * The array size of all arrays will be `IMAGERY_TEXTURE_UNITS`,\n   * so this has to be added as a `define` with a positive value.\n   *\n   * Depending on the given imagery flags being `true`, it will add\n   * the optional uniforms, like `u_imageryTextureAlpha`.\n   *\n   * The naming pattern will be `u_imageryTexture<name>`, except for\n   * `gamma`: To safe that one measly division, the thane will be\n   * `oneOverGamma` there.\n   *\n   * @param {ShaderBuilder} shaderBuilder The shader builder\n   * @param {ImageryFlags} imageryFlags The imagery flags\n   */\n  static _defineUniforms(shaderBuilder, imageryFlags) {\n    shaderBuilder.addUniform(\"sampler2D\", \"u_imageryTextures[IMAGERY_TEXTURE_UNITS]\", ShaderDestination.FRAGMENT);\n    shaderBuilder.addUniform(\"vec4\", \"u_imageryTextureCoordinateRectangle[IMAGERY_TEXTURE_UNITS]\", ShaderDestination.FRAGMENT);\n    shaderBuilder.addUniform(\"vec4\", \"u_imageryTextureTranslationAndScale[IMAGERY_TEXTURE_UNITS]\", ShaderDestination.FRAGMENT);\n    if (imageryFlags.alpha) {\n      shaderBuilder.addUniform(\"float\", \"u_imageryTextureAlpha[IMAGERY_TEXTURE_UNITS]\", ShaderDestination.FRAGMENT);\n    }\n    if (imageryFlags.brightness) {\n      shaderBuilder.addUniform(\"float\", \"u_imageryTextureBrightness[IMAGERY_TEXTURE_UNITS]\", ShaderDestination.FRAGMENT);\n    }\n    if (imageryFlags.contrast) {\n      shaderBuilder.addUniform(\"float\", \"u_imageryTextureContrast[IMAGERY_TEXTURE_UNITS]\", ShaderDestination.FRAGMENT);\n    }\n    if (imageryFlags.hue) {\n      shaderBuilder.addUniform(\"float\", \"u_imageryTextureHue[IMAGERY_TEXTURE_UNITS]\", ShaderDestination.FRAGMENT);\n    }\n    if (imageryFlags.saturation) {\n      shaderBuilder.addUniform(\"float\", \"u_imageryTextureSaturation[IMAGERY_TEXTURE_UNITS]\", ShaderDestination.FRAGMENT);\n    }\n    if (imageryFlags.gamma) {\n      shaderBuilder.addUniform(\"float\", \"u_imageryTextureOneOverGamma[IMAGERY_TEXTURE_UNITS]\", ShaderDestination.FRAGMENT);\n    }\n    if (imageryFlags.colorToAlpha) {\n      shaderBuilder.addUniform(\"vec4\", \"u_imageryTextureColorToAlpha[IMAGERY_TEXTURE_UNITS]\", ShaderDestination.FRAGMENT);\n    }\n  }\n\n  /**\n   * Create the function signature for the `sampleAndBlend` function,\n   * based on the features that are required for the imagery.\n   *\n   * For details, see `buildSampleAndBlendFunction`\n   *\n   * @param {ImageryFlags} imageryFlags The imagery flags\n   * @returns {string} The string\n   */\n  static _createSampleAndBlendFunctionSignature(imageryFlags) {\n    const functionId = \"sampleAndBlend\";\n    const parameters = [];\n    parameters.push(`vec4 previousColor`);\n    parameters.push(`sampler2D textureToSample`);\n    parameters.push(`vec2 textureCoordinates`);\n    parameters.push(`vec4 textureCoordinateRectangle`);\n    parameters.push(`vec4 textureCoordinateTranslationAndScale`);\n    if (imageryFlags.alpha) {\n      parameters.push(`float textureAlpha`);\n    }\n    if (imageryFlags.brightness) {\n      parameters.push(`float textureBrightness`);\n    }\n    if (imageryFlags.contrast) {\n      parameters.push(`float textureContrast`);\n    }\n    if (imageryFlags.hue) {\n      parameters.push(`float textureHue`);\n    }\n    if (imageryFlags.saturation) {\n      parameters.push(`float textureSaturation`);\n    }\n    if (imageryFlags.gamma) {\n      parameters.push(`float textureOneOverGamma`);\n    }\n    if (imageryFlags.colorToAlpha) {\n      parameters.push(`vec4 colorToAlpha`);\n    }\n    const parametersString = parameters.join(\", \");\n    const signature = `vec4 ${functionId}(${parametersString})`;\n    return signature;\n  }\n\n  /**\n   * Build the `sampleAndBlend` function that will be called for each imagery,\n   * to combine the previous pixel color with the respective imagery input.\n   *\n   * The function that is built here resembles the function that was originally defined at\n   * https://github.com/CesiumGS/cesium/blob/6cc004aaff586bb59f07f199216ae511014cf5a9/packages/engine/Source/Shaders/GlobeFS.glsl#L166\n   *\n   * However, for the function that is built here, the signature will\n   * reflect the actual features that are required for the imagery:\n   * For example, the `float textureAlpha` parameter will only be\n   * present when `imageryFlags.alpha` is `true`.\n   *\n   * @param {ShaderBuilder} shaderBuilder The shader builder\n   * @param {ImageryFlags} imageryFlags The imagery flags\n   */\n  static _buildSampleAndBlendFunction(shaderBuilder, imageryFlags) {\n    const functionId = \"sampleAndBlend\";\n    const signature = ImageryPipelineStage._createSampleAndBlendFunctionSignature(imageryFlags);\n    shaderBuilder.addFunction(functionId, signature, ShaderDestination.FRAGMENT);\n    shaderBuilder.addFunctionLines(functionId, [`float effectiveAlpha = 1.0;`]);\n    if (imageryFlags.alpha) {\n      shaderBuilder.addFunctionLines(functionId, [`effectiveAlpha = textureAlpha;`]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [\n    // This is the part that is documented as \"This crazy step stuff\"\n    // in GlobeFS.glsl. Using the if-approach here...\n    `if (textureCoordinates.x < textureCoordinateRectangle.x) effectiveAlpha = 0.0;`, `if (textureCoordinates.x > textureCoordinateRectangle.z) effectiveAlpha = 0.0;`, `if (textureCoordinates.y < textureCoordinateRectangle.y) effectiveAlpha = 0.0;`, `if (textureCoordinates.y > textureCoordinateRectangle.w) effectiveAlpha = 0.0;`, `vec2 translation = textureCoordinateTranslationAndScale.xy;`, `vec2 scale = textureCoordinateTranslationAndScale.zw;`, `vec2 effectiveTextureCoordinates = textureCoordinates * scale + translation;`, `vec4 value = texture(textureToSample, effectiveTextureCoordinates);`, `value = czm_srgbToLinear(value);`, `vec3 color = value.rgb;`, `float alpha = value.a;`]);\n    if (imageryFlags.colorToAlpha) {\n      shaderBuilder.addFunctionLines(functionId, [`vec3 colorDiff = abs(color.rgb - colorToAlpha.rgb);`, `colorDiff.r = czm_maximumComponent(colorDiff);`, `alpha = czm_branchFreeTernary(colorDiff.r < colorToAlpha.a, 0.0, alpha);`]);\n    }\n    if (imageryFlags.gamma) {\n      shaderBuilder.addFunctionLines(functionId, [`color = pow(color, vec3(textureOneOverGamma));`]);\n    } else {\n      shaderBuilder.addFunctionLines(functionId, [`vec4 tempColor = czm_gammaCorrect(vec4(color, alpha));`, `color = tempColor.rgb;`, `alpha = tempColor.a;`]);\n    }\n    if (imageryFlags.brightness) {\n      shaderBuilder.addFunctionLines(functionId, [`color = mix(vec3(0.0), color, textureBrightness);`]);\n    }\n    if (imageryFlags.contrast) {\n      shaderBuilder.addFunctionLines(functionId, [`color = mix(vec3(0.5), color, textureContrast);`]);\n    }\n    if (imageryFlags.hue) {\n      shaderBuilder.addFunctionLines(functionId, [`color = czm_hue(color, textureHue);`]);\n    }\n    if (imageryFlags.saturation) {\n      shaderBuilder.addFunctionLines(functionId, [`color = czm_saturation(color, textureSaturation);`]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [`float sourceAlpha = alpha * effectiveAlpha;`, `float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);`, `outAlpha += sign(outAlpha) - 1.0;`, `vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;`,\n    // See comments in https://github.com/CesiumGS/cesium/blob/6cc004aaff586bb59f07f199216ae511014cf5a9/packages/engine/Source/Shaders/GlobeFS.glsl#L166\n    `vec4 result = vec4(outColor, max(outAlpha, 0.0));`]);\n\n    // Debug mode: Draw boundaries of imagery in red\n    if (debugDrawImageryBoundaries) {\n      shaderBuilder.addFunctionLines(functionId, [`if (abs(textureCoordinates.x - textureCoordinateRectangle.x) < (1.0/256.0) || `, `    abs(textureCoordinates.x - textureCoordinateRectangle.z) < (1.0/256.0) || `, `    abs(textureCoordinates.y - textureCoordinateRectangle.y) < (1.0/256.0) || `, `    abs(textureCoordinates.y - textureCoordinateRectangle.w) < (1.0/256.0))`, `{`, `    result = vec4(1.0, 0.0, 0.0, effectiveAlpha);`, `}`]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [`return result;`]);\n  }\n\n  /**\n   * Creates the arguments for a call to `sampleAndBlend` for the\n   * specified imagery.\n   *\n   * For details, see `buildSampleAndBlendFunction`\n   *\n   * @param {ImageryFlags} imageryFlags The imagery flags\n   * @param {number} imageryTexCoordAttributeSetIndex The index for the texture coordinate attribute\n   * @param {number} i The imagery index\n   * @returns {string} The string\n   */\n  static _createSampleAndBlendCallArguments(imageryFlags, imageryTexCoordAttributeSetIndex, i) {\n    const textureCoordinates = `v_imagery_texCoord_${imageryTexCoordAttributeSetIndex}`;\n    const args = [];\n    args.push(`blendedBaseColor`);\n    args.push(`u_imageryTextures[${i}]`);\n    args.push(`${textureCoordinates}`);\n    args.push(`u_imageryTextureCoordinateRectangle[${i}]`);\n    args.push(`u_imageryTextureTranslationAndScale[${i}]`);\n    if (imageryFlags.alpha) {\n      args.push(`u_imageryTextureAlpha[${i}]`);\n    }\n    if (imageryFlags.brightness) {\n      args.push(`u_imageryTextureBrightness[${i}]`);\n    }\n    if (imageryFlags.contrast) {\n      args.push(`u_imageryTextureContrast[${i}]`);\n    }\n    if (imageryFlags.hue) {\n      args.push(`u_imageryTextureHue[${i}]`);\n    }\n    if (imageryFlags.saturation) {\n      args.push(`u_imageryTextureSaturation[${i}]`);\n    }\n    if (imageryFlags.gamma) {\n      args.push(`u_imageryTextureOneOverGamma[${i}]`);\n    }\n    if (imageryFlags.colorToAlpha) {\n      args.push(`u_imageryTextureColorToAlpha[${i}]`);\n    }\n    const argsString = args.join(\", \");\n    return argsString;\n  }\n\n  /**\n   * Creates the main part of the imagery shader.\n   *\n   * It adds the `blendBaseColorWithImagery` function, which is to be\n   * called in the `MaterialStageFS.glsl` when the `HAS_IMAGERY`\n   * flag was set in the shader.\n   *\n   * The `blendBaseColorWithImagery` function will go through all imagery\n   * layers in the input, and call the `sampleAndBlend` function, to\n   * incorporate the imagery input in the resulting pixel.\n   *\n   * @param {ShaderBuilder} shaderBuilder The shader builder\n   * @param {ImageryInput[]} imageryInputs The imagery inputs\n   * @param {ImageryFlags} imageryFlags The imagery flags\n   */\n  static _createMainImageryShader(shaderBuilder, imageryInputs, imageryFlags) {\n    const functionId = \"blendBaseColorWithImagery\";\n    shaderBuilder.addFunction(functionId, `vec4 blendBaseColorWithImagery(vec4 baseColorWithAlpha)`, ShaderDestination.FRAGMENT);\n    shaderBuilder.addFunctionLines(functionId, [`vec4 blendedBaseColor = baseColorWithAlpha;`]);\n\n    // Roughly what was done in https://github.com/CesiumGS/cesium/blob/6cc004aaff586bb59f07f199216ae511014cf5a9/packages/engine/Source/Scene/GlobeSurfaceShaderSet.js#L394\n    for (let i = 0; i < imageryInputs.length; i++) {\n      const imageryInput = imageryInputs[i];\n      const imageryTexCoordAttributeSetIndex = imageryInput.imageryTexCoordAttributeSetIndex;\n      const argsString = ImageryPipelineStage._createSampleAndBlendCallArguments(imageryFlags, imageryTexCoordAttributeSetIndex, i);\n      shaderBuilder.addFunctionLines(functionId, [`blendedBaseColor = sampleAndBlend(${argsString});`]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [`return blendedBaseColor;`]);\n  }\n\n  /**\n   * Creates an object that contains the uniform values the given imagery inputs.\n   *\n   * The result will be a structure that contains the uniform values\n   * that match the definitions that have been created by `defineUniforms`.\n   * (It will include the ones that still have their default values\n   * and may not be needed eventually)\n   *\n   * @param {ImageryInput[]} imageryInputs The imagery inputs\n   * @returns {object} The uniforms\n   */\n  static _createImageryUniforms(imageryInputs) {\n    const length = imageryInputs.length;\n    const uniforms = {};\n    uniforms.imageryTextures = Array(length);\n    uniforms.imageryTextureCoordinateRectangle = Array(length);\n    uniforms.imageryTextureTranslationAndScale = Array(length);\n    uniforms.imageryTextureAlpha = Array(length);\n    uniforms.imageryTextureBrightness = Array(length);\n    uniforms.imageryTextureContrast = Array(length);\n    uniforms.imageryTextureHue = Array(length);\n    uniforms.imageryTextureSaturation = Array(length);\n    uniforms.imageryTextureOneOverGamma = Array(length);\n    uniforms.imageryTextureColorToAlpha = Array(length);\n    for (let i = 0; i < length; i++) {\n      const imageryInput = imageryInputs[i];\n      const imageryLayer = imageryInput.imageryLayer;\n      const texture = imageryInput.texture;\n      const textureCoordinateRectangle = imageryInput.textureCoordinateRectangle;\n      const textureTranslationAndScale = imageryInput.textureTranslationAndScale;\n      uniforms.imageryTextures[i] = texture;\n      uniforms.imageryTextureTranslationAndScale[i] = textureTranslationAndScale;\n      uniforms.imageryTextureCoordinateRectangle[i] = textureCoordinateRectangle;\n      uniforms.imageryTextureAlpha[i] = imageryLayer.alpha;\n      uniforms.imageryTextureBrightness[i] = imageryLayer.brightness;\n      uniforms.imageryTextureContrast[i] = imageryLayer.contrast;\n      uniforms.imageryTextureHue[i] = imageryLayer.hue;\n      uniforms.imageryTextureSaturation[i] = imageryLayer.saturation;\n      uniforms.imageryTextureOneOverGamma[i] = 1.0 / imageryLayer.gamma;\n      let colorToAlpha = uniforms.imageryTextureColorToAlpha[i];\n      if (!defined(colorToAlpha)) {\n        colorToAlpha = new Cartesian4();\n        uniforms.imageryTextureColorToAlpha[i] = colorToAlpha;\n      }\n      const hasColorToAlpha = defined(imageryLayer.colorToAlpha) && imageryLayer.colorToAlphaThreshold > 0.0;\n      if (hasColorToAlpha) {\n        const color = imageryLayer.colorToAlpha;\n        colorToAlpha.x = color.red;\n        colorToAlpha.y = color.green;\n        colorToAlpha.z = color.blue;\n        colorToAlpha.w = imageryLayer.colorToAlphaThreshold;\n      } else {\n        colorToAlpha.w = -1.0;\n      }\n    }\n    return uniforms;\n  }\n\n  /**\n   * Fill the given uniform map with functions for all properties\n   * in the given uniforms object.\n   *\n   * The uniform names will be created as `u_<propertyName>`, and\n   * their value will just be a function that returns the respective\n   * property value.\n   *\n   * @param {UniformMap} uniformMap The uniform map\n   * @param {object} uniforms The uniforms\n   */\n  static _setImageryUniforms(uniformMap, uniforms) {\n    for (const key in uniforms) {\n      if (uniforms.hasOwnProperty(key)) {\n        const name = `u_${key}`;\n        uniformMap[name] = function () {\n          return uniforms[key];\n        };\n      }\n    }\n  }\n\n  /**\n   * Create the <code>ImageryInput</code> objects that have to be fed to the imagery\n   * pipeline stage for draping the given imagery layers over the primitive\n   * that is described by the given model primitive imagery.\n   *\n   * For each imagery layer that is currently visible (as of `show==true`), this\n   * will obtain the <code>ImageryCoverage</code> objects that are provided by\n   * the given model primitive imagery (and that describe the imagery tiles\n   * that are covered by the primitive), and create one <code>ImageryInput</code> for\n   * each of them.\n   *\n   * @param {ImageryLayerCollection} imageryLayers The imagery layers\n   * @param {ModelPrimitiveImagery} modelPrimitiveImagery The model primitive imagery\n   * @param {number[]} imageryTexCoordAttributeSetIndices The array that contains,\n   * for each imagery layer index, the set index of the texture coordinate\n   * attribute that should be used for this imagery. This is the value that\n   * will be used to access the texture coordinate attribute\n   * <code>a_imagery_texCoord_${imageryTexCoordAttributeSetIndex}</code>\n   * in the shader.\n   * @returns {ImageryInput[]} The imagery inputs\n   */\n  static _createImageryInputs(imageryLayers, modelPrimitiveImagery, imageryTexCoordAttributeSetIndices) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"imageryLayers\", imageryLayers);\n    Check.defined(\"modelPrimitiveImagery\", modelPrimitiveImagery);\n    Check.defined(\"imageryTexCoordAttributeSetIndices\", imageryTexCoordAttributeSetIndices);\n    //>>includeEnd('debug');\n\n    const imageryInputs = [];\n    for (let i = 0; i < imageryLayers.length; i++) {\n      const imageryLayer = imageryLayers.get(i);\n      if (!imageryLayer.show) {\n        continue;\n      }\n      const imageryTexCoordAttributeSetIndex = imageryTexCoordAttributeSetIndices[i];\n      const mappedPositions = modelPrimitiveImagery.mappedPositionsForImageryLayer(imageryLayer);\n      const cartographicBoundingRectangle = mappedPositions.cartographicBoundingRectangle;\n      const coverages = modelPrimitiveImagery.coveragesForImageryLayer(imageryLayer);\n      for (let j = 0; j < coverages.length; j++) {\n        const coverage = coverages[j];\n        const imageryInput = ImageryPipelineStage._createImageryInput(imageryLayer, coverage, cartographicBoundingRectangle, imageryTexCoordAttributeSetIndex);\n        if (defined(imageryInput)) {\n          imageryInputs.push(imageryInput);\n        }\n      }\n    }\n    return imageryInputs;\n  }\n\n  /**\n   * Create the `ImageryInput` that has to be passed to the imagery pipeline\n   * stage, for the given `ImageryCoverage`.\n   *\n   * The `ImageryCoverage` describes on imagery tile that is covered by the\n   * cartographic bounding rectangle of the primitive positions. This function\n   * obtains the actual `Imagery` object and its texture, computes the\n   * required texture coordinate and scale, and assembles this information\n   * into an `ImageryInput`.\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @param {ImageryCoverage} coverage The imagery coverage\n   * @param {Rectangle} cartographicBoundingRectangle The bounding rectangle\n   * of the cartographic primitive positions\n   * @param {number} imageryTexCoordAttributeSetIndex The set index of the\n   * texture coordinate attribute that should be used for this imagery.\n   * This is the value that will be used to access the texture coordinate\n   * attribute <code>a_imagery_texCoord_${imageryTexCoordAttributeSetIndex}</code>\n   * in the shader.\n   * @returns {ImageryInput|undefined} The imagery input, or undefined if\n   * the imagery for the given coverage turned out to be in the\n   * <code>ImageryState.INVALID/FAILED<code> state, or did not have\n   * a valid texture.\n   * @private\n   */\n  static _createImageryInput(imageryLayer, coverage, cartographicBoundingRectangle, imageryTexCoordAttributeSetIndex) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"imageryLayer\", imageryLayer);\n    Check.defined(\"coverage\", coverage);\n    Check.defined(\"cartographicBoundingRectangle\", cartographicBoundingRectangle);\n    Check.typeOf.number.greaterThanOrEquals(\"imageryTexCoordAttributeSetIndex\", imageryTexCoordAttributeSetIndex, 0);\n    //>>includeEnd('debug');\n\n    // Bail out early if something went wrong in the imagery\n    // loading state machine\n    const imagery = coverage.imagery;\n    if (imagery.state === ImageryState.FAILED || imagery.state === ImageryState.INVALID) {\n      return undefined;\n    }\n\n    // The texture coordinates are computed for the respective\n    // imagery, so pick either the textureWebMercator or the\n    // texture here\n    let texture = imagery.textureWebMercator;\n    if (!defined(texture)) {\n      texture = imagery.texture;\n      if (!defined(texture)) {\n        // Print an error message only when the imagery\n        // SHOULD actually have a texture\n        if (imagery.state === ImageryState.READY) {\n          console.log(`Imagery at ${coverage.x}, ${coverage.y} (level ${coverage.level}) does not have any texture - state ${imagery.state}`);\n        }\n        return undefined;\n      }\n    }\n    const textureTranslationAndScale = ImageryPipelineStage._computeTextureTranslationAndScale(imageryLayer, cartographicBoundingRectangle, imagery.rectangle);\n\n    // Convert the texture coordinate rectangle into a Cartesian4\n    // for the consumption as a uniform in the shader\n    const textureCoordinateCartesianRectangle = coverage.textureCoordinateRectangle;\n    const textureCoordinateRectangle = new Cartesian4(textureCoordinateCartesianRectangle.minX, textureCoordinateCartesianRectangle.minY, textureCoordinateCartesianRectangle.maxX, textureCoordinateCartesianRectangle.maxY);\n    const imageryInput = new ImageryInput(imageryLayer, texture, textureTranslationAndScale, textureCoordinateRectangle, imageryTexCoordAttributeSetIndex);\n    return imageryInput;\n  }\n\n  /**\n   * Compute the translation and scale that has to be applied to\n   * the texture coordinates for mapping the given imagery to\n   * the geometry.\n   *\n   * The given rectangles will be converted into their \"native\" representation,\n   * using the tiling scheme of the given imagery layer, and passed\n   * to `_computeTextureTranslationAndScaleFromNative` (see that for details).\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @param {Rectangle} nonNativeBoundingRectangle The bounding\n   * rectangle of the geometry\n   * @param {Rectangle} nonNativeImageryRectangle The bounding\n   * rectangle of the imagery\n   * @returns {Cartesian4} The translation and scale\n   * @private\n   */\n  static _computeTextureTranslationAndScale(imageryLayer, nonNativeBoundingRectangle, nonNativeImageryRectangle) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"imageryLayer\", imageryLayer);\n    Check.defined(\"nonNativeBoundingRectangle\", nonNativeBoundingRectangle);\n    Check.defined(\"nonNativeImageryRectangle\", nonNativeImageryRectangle);\n    //>>includeEnd('debug');\n\n    const tilingScheme = imageryLayer.imageryProvider.tilingScheme;\n    const nativeBoundingRectangle = tilingScheme.rectangleToNativeRectangle(nonNativeBoundingRectangle, nativeBoundingRectangleScratch);\n    const nativeImageryRectangle = tilingScheme.rectangleToNativeRectangle(nonNativeImageryRectangle, nativeImageryRectangleScratch);\n    const translationAndScale = ImageryPipelineStage._computeTextureTranslationAndScaleFromNative(nativeBoundingRectangle, nativeImageryRectangle);\n    return translationAndScale;\n  }\n\n  /**\n   * Compute the translation and scale that has to be applied to\n   * the texture coordinates for mapping the given imagery rectangle\n   * to the geometry rectangle.\n   *\n   * This will compute a Cartesian4 containing the\n   * (offsetX, offsetY, scaleX, scaleY) that have to be applied to\n   * the texture coordinates that that have been computed with\n   * `ModelImageryMapping.createTextureCoordinatesAttributeForMappedPositions`.\n   * In the shader, this offset and scale will map the given imagery rectangle\n   * to the geometry * rectangle.\n   *\n   * @param {Imagery} imagery The imagery\n   * @param {Rectangle} nonNativeBoundingRectangle The bounding\n   * rectangle of the geometry\n   * @param {Rectangle} nonNativeImageryRectangle The bounding\n   * rectangle of the imagery\n   * @returns {Cartesian4} The translation and scale\n   * @private\n   */\n  static _computeTextureTranslationAndScaleFromNative(nativeBoundingRectangle, nativeImageryRectangle) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"nativeBoundingRectangle\", nativeBoundingRectangle);\n    Check.defined(\"nativeImageryRectangle\", nativeImageryRectangle);\n    //>>includeEnd('debug');\n\n    const invImageryWidth = 1.0 / nativeImageryRectangle.width;\n    const invImageryHeight = 1.0 / nativeImageryRectangle.height;\n    const deltaWest = nativeBoundingRectangle.west - nativeImageryRectangle.west;\n    const deltaSouth = nativeBoundingRectangle.south - nativeImageryRectangle.south;\n    const offsetX = deltaWest * invImageryWidth;\n    const offsetY = deltaSouth * invImageryHeight;\n    const scaleX = nativeBoundingRectangle.width * invImageryWidth;\n    const scaleY = nativeBoundingRectangle.height * invImageryHeight;\n    return new Cartesian4(offsetX, offsetY, scaleX, scaleY);\n  }\n\n  /**\n   * Computes the index mapping from the given source to the given target.\n   *\n   * The result will be an array that has the same length as the source,\n   * and contains the indices that the source elements have in the\n   * target array.\n   *\n   * @param {object[]} source The source array\n   * @param {object[]} target The target array\n   * @returns {number[]} The result\n   */\n  static _computeIndexMapping(source, target) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"source\", source);\n    Check.defined(\"target\", target);\n    //>>includeEnd('debug');\n\n    const result = [];\n    const length = source.length;\n    for (let i = 0; i < length; i++) {\n      const element = source[i];\n      const index = target.indexOf(element);\n      result.push(index);\n    }\n    return result;\n  }\n}\n\n// Static properties (direct initialization disallowed by eslint)\n//ImageryPipelineStage.name = \"ImageryPipelineStage\"; // Helps with debugging, if you know where to look\n\nexport default ImageryPipelineStage;","map":{"version":3,"names":["defined","Cartesian4","Check","Rectangle","ShaderDestination","ImageryLayer","AttributeType","ImageryFlags","ModelPrimitiveImagery","ImageryInput","ImageryState","oneTimeWarning","debugDrawImageryBoundaries","nativeBoundingRectangleScratch","nativeImageryRectangleScratch","ImageryPipelineStage","process","primitiveRenderResources","primitive","frameState","model","modelPrimitiveImagery","ready","imageryLayers","allProjections","_extractProjections","uniqueProjections","Set","imageryTexCoordAttributeSetIndices","_computeIndexMapping","imageryInputs","_createImageryInputs","length","_addImageryTexCoordAttributesToRenderResources","imageryLayersArray","i","push","get","_processImageryInputs","imageryTexCoordAttributes","imageryTexCoordAttributesPerProjection","imageryTexCoordAttribute","_addImageryTexCoordAttributeToRenderResources","componentsPerAttribute","getNumberOfComponents","type","renderResourcesAttribute","index","attributeIndex","value","buffer","undefined","constant","vertexBuffer","count","componentDatatype","offsetInBytes","byteOffset","strideInBytes","byteStride","normalize","normalized","attributes","renderResources","numImageryTexCoordAttributes","shaderBuilder","imageryFlags","_computeImageryFlags","numTextures","addDefine","_addAttributes","_defineUniforms","_buildSampleAndBlendFunction","_createMainImageryShader","uniformMap","uniforms","_createImageryUniforms","_setImageryUniforms","numTexCoords","addAttribute","addVarying","functionId","signature","addFunction","VERTEX","addFunctionLines","imageryLayer","alpha","brightness","DEFAULT_BRIGHTNESS","contrast","DEFAULT_CONTRAST","hue","DEFAULT_HUE","saturation","DEFAULT_SATURATION","gamma","DEFAULT_GAMMA","hasColorToAlpha","colorToAlpha","colorToAlphaThreshold","addUniform","FRAGMENT","_createSampleAndBlendFunctionSignature","parameters","parametersString","join","_createSampleAndBlendCallArguments","imageryTexCoordAttributeSetIndex","textureCoordinates","args","argsString","imageryInput","imageryTextures","Array","imageryTextureCoordinateRectangle","imageryTextureTranslationAndScale","imageryTextureAlpha","imageryTextureBrightness","imageryTextureContrast","imageryTextureHue","imageryTextureSaturation","imageryTextureOneOverGamma","imageryTextureColorToAlpha","texture","textureCoordinateRectangle","textureTranslationAndScale","color","x","red","y","green","z","blue","w","key","hasOwnProperty","name","show","mappedPositions","mappedPositionsForImageryLayer","cartographicBoundingRectangle","coverages","coveragesForImageryLayer","j","coverage","_createImageryInput","typeOf","number","greaterThanOrEquals","imagery","state","FAILED","INVALID","textureWebMercator","READY","console","log","level","_computeTextureTranslationAndScale","rectangle","textureCoordinateCartesianRectangle","minX","minY","maxX","maxY","nonNativeBoundingRectangle","nonNativeImageryRectangle","tilingScheme","imageryProvider","nativeBoundingRectangle","rectangleToNativeRectangle","nativeImageryRectangle","translationAndScale","_computeTextureTranslationAndScaleFromNative","invImageryWidth","width","invImageryHeight","height","deltaWest","west","deltaSouth","south","offsetX","offsetY","scaleX","scaleY","source","target","result","element","indexOf"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Model/ImageryPipelineStage.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport Check from \"../../Core/Check.js\";\nimport Rectangle from \"../../Core/Rectangle.js\";\n\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\n\nimport ImageryLayer from \"../ImageryLayer.js\";\nimport AttributeType from \"../AttributeType.js\";\n\nimport ImageryFlags from \"./ImageryFlags.js\";\nimport ModelPrimitiveImagery from \"./ModelPrimitiveImagery.js\";\nimport ImageryInput from \"./ImageryInput.js\";\nimport ImageryState from \"../ImageryState.js\";\nimport oneTimeWarning from \"../../Core/oneTimeWarning.js\";\n\n/**\n * A compile-time debugging flag to draw the boundaries of imagery tiles\n * (Similar to \"SHOW_TILE_BOUNDARIES\" in GlobeFS.glsl)\n * @private\n */\nconst debugDrawImageryBoundaries = false;\n\n// Scratch variable for _computeTextureTranslationAndScale\nconst nativeBoundingRectangleScratch = new Rectangle();\n\n// Scratch variable for _computeTextureTranslationAndScale\nconst nativeImageryRectangleScratch = new Rectangle();\n\n/**\n * A pipeline stage that modifies the model shader to take into account\n * imagery textures that are draped over a primitive of the model, when it\n * is part a <code>Model3DTileContent</code> of a <code>Cesium3DTileset</code>\n * that has <code>imageryLayers</code> associated with it.\n *\n * Most of what is done here tries to emulate the parts from\n * https://github.com/CesiumGS/cesium/blob/6cc004aaff586bb59f07f199216ae511014cf5a9/packages/engine/Source/Shaders/GlobeFS.glsl#L166\n * that are relevant for imagery, using the more modern ShaderBuilder structures.\n *\n * @namespace ImageryPipelineStage\n *\n * @private\n */\nclass ImageryPipelineStage {\n  /**\n   * Process a primitive.\n   *\n   * This will update the render resources of the given primitive,\n   * depending on the imagery that is covered by the given primitive.\n   *\n   * This will obtain the <code>ModelPrimitiveImagery</code> from\n   * the given primitive, and use that to compute the actual\n   * <code>ImageryInput</code> objects that describe the information\n   * that has to be passed to the shader for draping the imagery over\n   * the primitive.\n   *\n   * After the <code>ImageryInput</code> has been computed, it will\n   * extend the render resources with the texture coordinate\n   * attribute that has to be used for the imagery, and augment\n   * the <code>primitiveRenderResources.shaderBuilder</code> with\n   * the information hat is required for the draping.\n   *\n   * @param {PrimitiveRenderResources} primitiveRenderResources The render resources for the primitive\n   * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n   * @param {FrameState} frameState The frame state.\n   */\n  static process(primitiveRenderResources, primitive, frameState) {\n    const model = primitiveRenderResources.model;\n    const modelPrimitiveImagery = primitive.modelPrimitiveImagery;\n\n    // When the creation of the model primitive imagery is happening\n    // asynchronously, then the primitive may not yet contain it.\n    // Return early in this case\n    if (!defined(modelPrimitiveImagery)) {\n      return;\n    }\n\n    // Similarly, when the model primitive imagery is not yet ready,\n    // then nothing can be done here\n    if (!modelPrimitiveImagery.ready) {\n      return;\n    }\n\n    // Compute the arrays containing ALL projections and the array\n    // containing the UNIQUE projections from the imagery layers,\n    // to establish the mapping between the imagery index and the\n    // imagery texture coordinate attribute set index.\n    // (This should be implemented and/or documented better...)\n    const imageryLayers = model.imageryLayers;\n    const allProjections =\n      ModelPrimitiveImagery._extractProjections(imageryLayers);\n    const uniqueProjections = [...new Set(allProjections)];\n    const imageryTexCoordAttributeSetIndices =\n      ImageryPipelineStage._computeIndexMapping(\n        allProjections,\n        uniqueProjections,\n      );\n\n    // Create the `ImageryInput` objects that describe\n    // - the texture\n    // - texture coordinate rectangle\n    // - translation and scale\n    // - index of the imagery texture coordinate attribute\n    // to be passed to the actual imagery pipeline stage execution\n    const imageryInputs = ImageryPipelineStage._createImageryInputs(\n      imageryLayers,\n      modelPrimitiveImagery,\n      imageryTexCoordAttributeSetIndices,\n    );\n\n    // This can happen when none of the imagery textures could\n    // be obtained, because they had all been INVALID/FAILED,\n    // or when none of the imagery layers is actually visible\n    // according to `show==true`\n    // Bail out in this case\n    if (imageryInputs.length === 0) {\n      return;\n    }\n\n    // TODO_DRAPING This will have to be handled with upsampling.\n    // For now, just truncate the textures to not exceed the\n    // number of texture units\n    if (imageryInputs.length > 10) {\n      oneTimeWarning(\n        \"imagery-texture-units\",\n        `Warning: Draped imagery requires ${imageryInputs.length} texture units, truncating`,\n      );\n      imageryInputs.length = 10;\n    }\n\n    // Add the imagery texture coordinate attributes to the render\n    // resources\n    ImageryPipelineStage._addImageryTexCoordAttributesToRenderResources(\n      modelPrimitiveImagery,\n      primitiveRenderResources,\n    );\n\n    const imageryLayersArray = [];\n    for (let i = 0; i < imageryLayers.length; i++) {\n      imageryLayersArray.push(imageryLayers.get(i));\n    }\n\n    ImageryPipelineStage._processImageryInputs(\n      imageryLayersArray,\n      primitiveRenderResources,\n      imageryInputs,\n      uniqueProjections.length,\n    );\n  }\n\n  /**\n   * Add one attribute to the render resources, for each imagery texture\n   * coordinate that was computed in the given model primitive imagery\n   * (one for each projection)\n   *\n   * @param {ModelPrimitiveImagery} modelPrimitiveImagery The model primitive imagery\n   * @param {PrimitiveRenderResources} primitiveRenderResources The render resources\n   */\n  static _addImageryTexCoordAttributesToRenderResources(\n    modelPrimitiveImagery,\n    primitiveRenderResources,\n  ) {\n    const imageryTexCoordAttributes =\n      modelPrimitiveImagery.imageryTexCoordAttributesPerProjection();\n    for (const imageryTexCoordAttribute of imageryTexCoordAttributes) {\n      ImageryPipelineStage._addImageryTexCoordAttributeToRenderResources(\n        imageryTexCoordAttribute,\n        primitiveRenderResources,\n      );\n    }\n  }\n\n  /**\n   * Add the given attribute to the render resources\n   *\n   * @param {ModelComponents.Attribute} imageryTexCoordAttribute The attribute\n   * @param {PrimitiveRenderResources} primitiveRenderResources The render resources\n   */\n  static _addImageryTexCoordAttributeToRenderResources(\n    imageryTexCoordAttribute,\n    primitiveRenderResources,\n  ) {\n    const componentsPerAttribute = AttributeType.getNumberOfComponents(\n      imageryTexCoordAttribute.type,\n    );\n    // Convert the given object into another object that essentially\n    // contains the same information, but not exactly, and with most\n    // properties having slightly different names. Shrug.\n    const renderResourcesAttribute = {\n      index: primitiveRenderResources.attributeIndex++,\n      value: defined(imageryTexCoordAttribute.buffer)\n        ? undefined\n        : imageryTexCoordAttribute.constant,\n      vertexBuffer: imageryTexCoordAttribute.buffer,\n      count: imageryTexCoordAttribute.count,\n      componentsPerAttribute: componentsPerAttribute,\n      componentDatatype: imageryTexCoordAttribute.componentDatatype,\n      offsetInBytes: imageryTexCoordAttribute.byteOffset,\n      strideInBytes: imageryTexCoordAttribute.byteStride,\n      normalize: imageryTexCoordAttribute.normalized,\n    };\n    primitiveRenderResources.attributes.push(renderResourcesAttribute);\n  }\n\n  /**\n   * Process the <code>ImageryInput</code> objects that have been\n   * created in <code>process</code>.\n   *\n   * This will build the shader, containing the attributes, uniforms,\n   * and \"sample and blend\" function that is required according to\n   * the given imagery inputs\n   *\n   * @param {ImageryLayer[]} imageryLayersArray The imagery layers\n   * @param {PrimitiveRenderResources} primitiveRenderResources The primitive render resources\n   * @param {ImageryInput[]} imageryInputs The imagery inputs\n   * @param {number} numImageryTexCoordAttributes The number of texture coordinate\n   * attributes that have been created for the imagery (one for each distinct\n   * projection that was found in the imagery layers)\n   */\n  static _processImageryInputs(\n    imageryLayersArray,\n    renderResources,\n    imageryInputs,\n    numImageryTexCoordAttributes,\n  ) {\n    const shaderBuilder = renderResources.shaderBuilder;\n\n    const imageryFlags =\n      ImageryPipelineStage._computeImageryFlags(imageryLayersArray);\n    const numTextures = imageryInputs.length;\n\n    // Set the global defines indicating the presence and number of\n    // imagery textures.\n    shaderBuilder.addDefine(`HAS_IMAGERY`);\n    shaderBuilder.addDefine(`IMAGERY_TEXTURE_UNITS ${numTextures}`);\n\n    ImageryPipelineStage._addAttributes(\n      shaderBuilder,\n      numImageryTexCoordAttributes,\n    );\n\n    ImageryPipelineStage._defineUniforms(shaderBuilder, imageryFlags);\n    ImageryPipelineStage._buildSampleAndBlendFunction(\n      shaderBuilder,\n      imageryFlags,\n    );\n\n    ImageryPipelineStage._createMainImageryShader(\n      shaderBuilder,\n      imageryInputs,\n      imageryFlags,\n    );\n\n    const uniformMap = renderResources.uniformMap;\n    const uniforms = ImageryPipelineStage._createImageryUniforms(imageryInputs);\n    ImageryPipelineStage._setImageryUniforms(uniformMap, uniforms);\n  }\n\n  /**\n   * Add the attribute- and varying definitions for the imagery texture\n   * coordinates to the given shader.\n   *\n   * This includes the definition of the <code>initializeImageryAttributes</code>\n   * function that assigns the attribute values to varyings in the vertex shader.\n   *\n   * @param {ShaderBuilder} shaderBuilder The shader builder\n   * @param {number} numTexCoords The number of imagery texture coordinate sets\n   */\n  static _addAttributes(shaderBuilder, numTexCoords) {\n    for (let i = 0; i < numTexCoords; i++) {\n      shaderBuilder.addAttribute(\"vec2\", `a_imagery_texCoord_${i}`);\n      shaderBuilder.addVarying(\"vec2\", `v_imagery_texCoord_${i}`);\n    }\n\n    const functionId = \"initializeImageryAttributes\";\n    const signature = `void ${functionId}()`;\n    shaderBuilder.addFunction(functionId, signature, ShaderDestination.VERTEX);\n\n    for (let i = 0; i < numTexCoords; i++) {\n      shaderBuilder.addFunctionLines(functionId, [\n        `v_imagery_texCoord_${i} = a_imagery_texCoord_${i};`,\n      ]);\n    }\n  }\n\n  /**\n   * Returns the `ImageryFlags` that indicate the features that are\n   * required for the given imagery layers.\n   *\n   * The resulting flags will indicate whether any of the given\n   * imagery layer objects did *not* have the default value for\n   * the respective property, as defined by `ImageryLayer.DEFAULT_...`\n   *\n   * @param {ImageryLayer[]} imageryLayers The imagery layers\n   * @returns {ImageryFlags} The imagery flags\n   */\n  static _computeImageryFlags(imageryLayers) {\n    const imageryFlags = new ImageryFlags();\n    for (let i = 0; i < imageryLayers.length; i++) {\n      const imageryLayer = imageryLayers[i];\n\n      // These are short-circuiting to `number` instead\n      // of `boolean` here. With \"ecmaVersion: 2021\", we\n      // could use \"||=\" here. Otherwise, there is no\n      // nice shortcut for this.\n      imageryFlags.alpha |= imageryLayer.alpha !== 1.0;\n      imageryFlags.brightness |=\n        imageryLayer.brightness !== ImageryLayer.DEFAULT_BRIGHTNESS;\n      imageryFlags.contrast |=\n        imageryLayer.contrast !== ImageryLayer.DEFAULT_CONTRAST;\n      imageryFlags.hue |= imageryLayer.hue !== ImageryLayer.DEFAULT_HUE;\n      imageryFlags.saturation |=\n        imageryLayer.saturation !== ImageryLayer.DEFAULT_SATURATION;\n      imageryFlags.gamma |= imageryLayer.gamma !== ImageryLayer.DEFAULT_GAMMA;\n      const hasColorToAlpha =\n        defined(imageryLayer.colorToAlpha) &&\n        imageryLayer.colorToAlphaThreshold > 0.0;\n      imageryFlags.colorToAlpha |= hasColorToAlpha;\n    }\n    return imageryFlags;\n  }\n\n  /**\n   * Adds the uniforms that are required for the imagery to the shader.\n   *\n   * This will use the given shader builder to add the uniforms to the\n   * shader that are always required for the imagery (e.g. the\n   * `sampler2D u_imageryTextures[...]`).\n   *\n   * The array size of all arrays will be `IMAGERY_TEXTURE_UNITS`,\n   * so this has to be added as a `define` with a positive value.\n   *\n   * Depending on the given imagery flags being `true`, it will add\n   * the optional uniforms, like `u_imageryTextureAlpha`.\n   *\n   * The naming pattern will be `u_imageryTexture<name>`, except for\n   * `gamma`: To safe that one measly division, the thane will be\n   * `oneOverGamma` there.\n   *\n   * @param {ShaderBuilder} shaderBuilder The shader builder\n   * @param {ImageryFlags} imageryFlags The imagery flags\n   */\n  static _defineUniforms(shaderBuilder, imageryFlags) {\n    shaderBuilder.addUniform(\n      \"sampler2D\",\n      \"u_imageryTextures[IMAGERY_TEXTURE_UNITS]\",\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addUniform(\n      \"vec4\",\n      \"u_imageryTextureCoordinateRectangle[IMAGERY_TEXTURE_UNITS]\",\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addUniform(\n      \"vec4\",\n      \"u_imageryTextureTranslationAndScale[IMAGERY_TEXTURE_UNITS]\",\n      ShaderDestination.FRAGMENT,\n    );\n\n    if (imageryFlags.alpha) {\n      shaderBuilder.addUniform(\n        \"float\",\n        \"u_imageryTextureAlpha[IMAGERY_TEXTURE_UNITS]\",\n        ShaderDestination.FRAGMENT,\n      );\n    }\n    if (imageryFlags.brightness) {\n      shaderBuilder.addUniform(\n        \"float\",\n        \"u_imageryTextureBrightness[IMAGERY_TEXTURE_UNITS]\",\n        ShaderDestination.FRAGMENT,\n      );\n    }\n    if (imageryFlags.contrast) {\n      shaderBuilder.addUniform(\n        \"float\",\n        \"u_imageryTextureContrast[IMAGERY_TEXTURE_UNITS]\",\n        ShaderDestination.FRAGMENT,\n      );\n    }\n    if (imageryFlags.hue) {\n      shaderBuilder.addUniform(\n        \"float\",\n        \"u_imageryTextureHue[IMAGERY_TEXTURE_UNITS]\",\n        ShaderDestination.FRAGMENT,\n      );\n    }\n    if (imageryFlags.saturation) {\n      shaderBuilder.addUniform(\n        \"float\",\n        \"u_imageryTextureSaturation[IMAGERY_TEXTURE_UNITS]\",\n        ShaderDestination.FRAGMENT,\n      );\n    }\n    if (imageryFlags.gamma) {\n      shaderBuilder.addUniform(\n        \"float\",\n        \"u_imageryTextureOneOverGamma[IMAGERY_TEXTURE_UNITS]\",\n        ShaderDestination.FRAGMENT,\n      );\n    }\n    if (imageryFlags.colorToAlpha) {\n      shaderBuilder.addUniform(\n        \"vec4\",\n        \"u_imageryTextureColorToAlpha[IMAGERY_TEXTURE_UNITS]\",\n        ShaderDestination.FRAGMENT,\n      );\n    }\n  }\n\n  /**\n   * Create the function signature for the `sampleAndBlend` function,\n   * based on the features that are required for the imagery.\n   *\n   * For details, see `buildSampleAndBlendFunction`\n   *\n   * @param {ImageryFlags} imageryFlags The imagery flags\n   * @returns {string} The string\n   */\n  static _createSampleAndBlendFunctionSignature(imageryFlags) {\n    const functionId = \"sampleAndBlend\";\n    const parameters = [];\n    parameters.push(`vec4 previousColor`);\n    parameters.push(`sampler2D textureToSample`);\n    parameters.push(`vec2 textureCoordinates`);\n    parameters.push(`vec4 textureCoordinateRectangle`);\n    parameters.push(`vec4 textureCoordinateTranslationAndScale`);\n    if (imageryFlags.alpha) {\n      parameters.push(`float textureAlpha`);\n    }\n    if (imageryFlags.brightness) {\n      parameters.push(`float textureBrightness`);\n    }\n    if (imageryFlags.contrast) {\n      parameters.push(`float textureContrast`);\n    }\n    if (imageryFlags.hue) {\n      parameters.push(`float textureHue`);\n    }\n    if (imageryFlags.saturation) {\n      parameters.push(`float textureSaturation`);\n    }\n    if (imageryFlags.gamma) {\n      parameters.push(`float textureOneOverGamma`);\n    }\n    if (imageryFlags.colorToAlpha) {\n      parameters.push(`vec4 colorToAlpha`);\n    }\n    const parametersString = parameters.join(\", \");\n\n    const signature = `vec4 ${functionId}(${parametersString})`;\n    return signature;\n  }\n\n  /**\n   * Build the `sampleAndBlend` function that will be called for each imagery,\n   * to combine the previous pixel color with the respective imagery input.\n   *\n   * The function that is built here resembles the function that was originally defined at\n   * https://github.com/CesiumGS/cesium/blob/6cc004aaff586bb59f07f199216ae511014cf5a9/packages/engine/Source/Shaders/GlobeFS.glsl#L166\n   *\n   * However, for the function that is built here, the signature will\n   * reflect the actual features that are required for the imagery:\n   * For example, the `float textureAlpha` parameter will only be\n   * present when `imageryFlags.alpha` is `true`.\n   *\n   * @param {ShaderBuilder} shaderBuilder The shader builder\n   * @param {ImageryFlags} imageryFlags The imagery flags\n   */\n  static _buildSampleAndBlendFunction(shaderBuilder, imageryFlags) {\n    const functionId = \"sampleAndBlend\";\n    const signature =\n      ImageryPipelineStage._createSampleAndBlendFunctionSignature(imageryFlags);\n    shaderBuilder.addFunction(\n      functionId,\n      signature,\n      ShaderDestination.FRAGMENT,\n    );\n\n    shaderBuilder.addFunctionLines(functionId, [`float effectiveAlpha = 1.0;`]);\n    if (imageryFlags.alpha) {\n      shaderBuilder.addFunctionLines(functionId, [\n        `effectiveAlpha = textureAlpha;`,\n      ]);\n    }\n    shaderBuilder.addFunctionLines(functionId, [\n      // This is the part that is documented as \"This crazy step stuff\"\n      // in GlobeFS.glsl. Using the if-approach here...\n      `if (textureCoordinates.x < textureCoordinateRectangle.x) effectiveAlpha = 0.0;`,\n      `if (textureCoordinates.x > textureCoordinateRectangle.z) effectiveAlpha = 0.0;`,\n      `if (textureCoordinates.y < textureCoordinateRectangle.y) effectiveAlpha = 0.0;`,\n      `if (textureCoordinates.y > textureCoordinateRectangle.w) effectiveAlpha = 0.0;`,\n\n      `vec2 translation = textureCoordinateTranslationAndScale.xy;`,\n      `vec2 scale = textureCoordinateTranslationAndScale.zw;`,\n      `vec2 effectiveTextureCoordinates = textureCoordinates * scale + translation;`,\n      `vec4 value = texture(textureToSample, effectiveTextureCoordinates);`,\n      `value = czm_srgbToLinear(value);`,\n\n      `vec3 color = value.rgb;`,\n      `float alpha = value.a;`,\n    ]);\n\n    if (imageryFlags.colorToAlpha) {\n      shaderBuilder.addFunctionLines(functionId, [\n        `vec3 colorDiff = abs(color.rgb - colorToAlpha.rgb);`,\n        `colorDiff.r = czm_maximumComponent(colorDiff);`,\n        `alpha = czm_branchFreeTernary(colorDiff.r < colorToAlpha.a, 0.0, alpha);`,\n      ]);\n    }\n\n    if (imageryFlags.gamma) {\n      shaderBuilder.addFunctionLines(functionId, [\n        `color = pow(color, vec3(textureOneOverGamma));`,\n      ]);\n    } else {\n      shaderBuilder.addFunctionLines(functionId, [\n        `vec4 tempColor = czm_gammaCorrect(vec4(color, alpha));`,\n        `color = tempColor.rgb;`,\n        `alpha = tempColor.a;`,\n      ]);\n    }\n\n    if (imageryFlags.brightness) {\n      shaderBuilder.addFunctionLines(functionId, [\n        `color = mix(vec3(0.0), color, textureBrightness);`,\n      ]);\n    }\n\n    if (imageryFlags.contrast) {\n      shaderBuilder.addFunctionLines(functionId, [\n        `color = mix(vec3(0.5), color, textureContrast);`,\n      ]);\n    }\n    if (imageryFlags.hue) {\n      shaderBuilder.addFunctionLines(functionId, [\n        `color = czm_hue(color, textureHue);`,\n      ]);\n    }\n\n    if (imageryFlags.saturation) {\n      shaderBuilder.addFunctionLines(functionId, [\n        `color = czm_saturation(color, textureSaturation);`,\n      ]);\n    }\n\n    shaderBuilder.addFunctionLines(functionId, [\n      `float sourceAlpha = alpha * effectiveAlpha;`,\n      `float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);`,\n      `outAlpha += sign(outAlpha) - 1.0;`,\n      `vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;`,\n      // See comments in https://github.com/CesiumGS/cesium/blob/6cc004aaff586bb59f07f199216ae511014cf5a9/packages/engine/Source/Shaders/GlobeFS.glsl#L166\n      `vec4 result = vec4(outColor, max(outAlpha, 0.0));`,\n    ]);\n\n    // Debug mode: Draw boundaries of imagery in red\n    if (debugDrawImageryBoundaries) {\n      shaderBuilder.addFunctionLines(functionId, [\n        `if (abs(textureCoordinates.x - textureCoordinateRectangle.x) < (1.0/256.0) || `,\n        `    abs(textureCoordinates.x - textureCoordinateRectangle.z) < (1.0/256.0) || `,\n        `    abs(textureCoordinates.y - textureCoordinateRectangle.y) < (1.0/256.0) || `,\n        `    abs(textureCoordinates.y - textureCoordinateRectangle.w) < (1.0/256.0))`,\n        `{`,\n        `    result = vec4(1.0, 0.0, 0.0, effectiveAlpha);`,\n        `}`,\n      ]);\n    }\n\n    shaderBuilder.addFunctionLines(functionId, [`return result;`]);\n  }\n\n  /**\n   * Creates the arguments for a call to `sampleAndBlend` for the\n   * specified imagery.\n   *\n   * For details, see `buildSampleAndBlendFunction`\n   *\n   * @param {ImageryFlags} imageryFlags The imagery flags\n   * @param {number} imageryTexCoordAttributeSetIndex The index for the texture coordinate attribute\n   * @param {number} i The imagery index\n   * @returns {string} The string\n   */\n  static _createSampleAndBlendCallArguments(\n    imageryFlags,\n    imageryTexCoordAttributeSetIndex,\n    i,\n  ) {\n    const textureCoordinates = `v_imagery_texCoord_${imageryTexCoordAttributeSetIndex}`;\n\n    const args = [];\n    args.push(`blendedBaseColor`);\n    args.push(`u_imageryTextures[${i}]`);\n    args.push(`${textureCoordinates}`);\n    args.push(`u_imageryTextureCoordinateRectangle[${i}]`);\n    args.push(`u_imageryTextureTranslationAndScale[${i}]`);\n    if (imageryFlags.alpha) {\n      args.push(`u_imageryTextureAlpha[${i}]`);\n    }\n    if (imageryFlags.brightness) {\n      args.push(`u_imageryTextureBrightness[${i}]`);\n    }\n    if (imageryFlags.contrast) {\n      args.push(`u_imageryTextureContrast[${i}]`);\n    }\n    if (imageryFlags.hue) {\n      args.push(`u_imageryTextureHue[${i}]`);\n    }\n    if (imageryFlags.saturation) {\n      args.push(`u_imageryTextureSaturation[${i}]`);\n    }\n    if (imageryFlags.gamma) {\n      args.push(`u_imageryTextureOneOverGamma[${i}]`);\n    }\n    if (imageryFlags.colorToAlpha) {\n      args.push(`u_imageryTextureColorToAlpha[${i}]`);\n    }\n\n    const argsString = args.join(\", \");\n    return argsString;\n  }\n\n  /**\n   * Creates the main part of the imagery shader.\n   *\n   * It adds the `blendBaseColorWithImagery` function, which is to be\n   * called in the `MaterialStageFS.glsl` when the `HAS_IMAGERY`\n   * flag was set in the shader.\n   *\n   * The `blendBaseColorWithImagery` function will go through all imagery\n   * layers in the input, and call the `sampleAndBlend` function, to\n   * incorporate the imagery input in the resulting pixel.\n   *\n   * @param {ShaderBuilder} shaderBuilder The shader builder\n   * @param {ImageryInput[]} imageryInputs The imagery inputs\n   * @param {ImageryFlags} imageryFlags The imagery flags\n   */\n  static _createMainImageryShader(shaderBuilder, imageryInputs, imageryFlags) {\n    const functionId = \"blendBaseColorWithImagery\";\n    shaderBuilder.addFunction(\n      functionId,\n      `vec4 blendBaseColorWithImagery(vec4 baseColorWithAlpha)`,\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addFunctionLines(functionId, [\n      `vec4 blendedBaseColor = baseColorWithAlpha;`,\n    ]);\n\n    // Roughly what was done in https://github.com/CesiumGS/cesium/blob/6cc004aaff586bb59f07f199216ae511014cf5a9/packages/engine/Source/Scene/GlobeSurfaceShaderSet.js#L394\n    for (let i = 0; i < imageryInputs.length; i++) {\n      const imageryInput = imageryInputs[i];\n      const imageryTexCoordAttributeSetIndex =\n        imageryInput.imageryTexCoordAttributeSetIndex;\n      const argsString =\n        ImageryPipelineStage._createSampleAndBlendCallArguments(\n          imageryFlags,\n          imageryTexCoordAttributeSetIndex,\n          i,\n        );\n      shaderBuilder.addFunctionLines(functionId, [\n        `blendedBaseColor = sampleAndBlend(${argsString});`,\n      ]);\n    }\n\n    shaderBuilder.addFunctionLines(functionId, [`return blendedBaseColor;`]);\n  }\n\n  /**\n   * Creates an object that contains the uniform values the given imagery inputs.\n   *\n   * The result will be a structure that contains the uniform values\n   * that match the definitions that have been created by `defineUniforms`.\n   * (It will include the ones that still have their default values\n   * and may not be needed eventually)\n   *\n   * @param {ImageryInput[]} imageryInputs The imagery inputs\n   * @returns {object} The uniforms\n   */\n  static _createImageryUniforms(imageryInputs) {\n    const length = imageryInputs.length;\n    const uniforms = {};\n    uniforms.imageryTextures = Array(length);\n    uniforms.imageryTextureCoordinateRectangle = Array(length);\n    uniforms.imageryTextureTranslationAndScale = Array(length);\n    uniforms.imageryTextureAlpha = Array(length);\n    uniforms.imageryTextureBrightness = Array(length);\n    uniforms.imageryTextureContrast = Array(length);\n    uniforms.imageryTextureHue = Array(length);\n    uniforms.imageryTextureSaturation = Array(length);\n    uniforms.imageryTextureOneOverGamma = Array(length);\n    uniforms.imageryTextureColorToAlpha = Array(length);\n\n    for (let i = 0; i < length; i++) {\n      const imageryInput = imageryInputs[i];\n\n      const imageryLayer = imageryInput.imageryLayer;\n      const texture = imageryInput.texture;\n      const textureCoordinateRectangle =\n        imageryInput.textureCoordinateRectangle;\n      const textureTranslationAndScale =\n        imageryInput.textureTranslationAndScale;\n\n      uniforms.imageryTextures[i] = texture;\n      uniforms.imageryTextureTranslationAndScale[i] =\n        textureTranslationAndScale;\n      uniforms.imageryTextureCoordinateRectangle[i] =\n        textureCoordinateRectangle;\n\n      uniforms.imageryTextureAlpha[i] = imageryLayer.alpha;\n      uniforms.imageryTextureBrightness[i] = imageryLayer.brightness;\n      uniforms.imageryTextureContrast[i] = imageryLayer.contrast;\n      uniforms.imageryTextureHue[i] = imageryLayer.hue;\n      uniforms.imageryTextureSaturation[i] = imageryLayer.saturation;\n      uniforms.imageryTextureOneOverGamma[i] = 1.0 / imageryLayer.gamma;\n\n      let colorToAlpha = uniforms.imageryTextureColorToAlpha[i];\n      if (!defined(colorToAlpha)) {\n        colorToAlpha = new Cartesian4();\n        uniforms.imageryTextureColorToAlpha[i] = colorToAlpha;\n      }\n      const hasColorToAlpha =\n        defined(imageryLayer.colorToAlpha) &&\n        imageryLayer.colorToAlphaThreshold > 0.0;\n      if (hasColorToAlpha) {\n        const color = imageryLayer.colorToAlpha;\n        colorToAlpha.x = color.red;\n        colorToAlpha.y = color.green;\n        colorToAlpha.z = color.blue;\n        colorToAlpha.w = imageryLayer.colorToAlphaThreshold;\n      } else {\n        colorToAlpha.w = -1.0;\n      }\n    }\n    return uniforms;\n  }\n\n  /**\n   * Fill the given uniform map with functions for all properties\n   * in the given uniforms object.\n   *\n   * The uniform names will be created as `u_<propertyName>`, and\n   * their value will just be a function that returns the respective\n   * property value.\n   *\n   * @param {UniformMap} uniformMap The uniform map\n   * @param {object} uniforms The uniforms\n   */\n  static _setImageryUniforms(uniformMap, uniforms) {\n    for (const key in uniforms) {\n      if (uniforms.hasOwnProperty(key)) {\n        const name = `u_${key}`;\n        uniformMap[name] = function () {\n          return uniforms[key];\n        };\n      }\n    }\n  }\n\n  /**\n   * Create the <code>ImageryInput</code> objects that have to be fed to the imagery\n   * pipeline stage for draping the given imagery layers over the primitive\n   * that is described by the given model primitive imagery.\n   *\n   * For each imagery layer that is currently visible (as of `show==true`), this\n   * will obtain the <code>ImageryCoverage</code> objects that are provided by\n   * the given model primitive imagery (and that describe the imagery tiles\n   * that are covered by the primitive), and create one <code>ImageryInput</code> for\n   * each of them.\n   *\n   * @param {ImageryLayerCollection} imageryLayers The imagery layers\n   * @param {ModelPrimitiveImagery} modelPrimitiveImagery The model primitive imagery\n   * @param {number[]} imageryTexCoordAttributeSetIndices The array that contains,\n   * for each imagery layer index, the set index of the texture coordinate\n   * attribute that should be used for this imagery. This is the value that\n   * will be used to access the texture coordinate attribute\n   * <code>a_imagery_texCoord_${imageryTexCoordAttributeSetIndex}</code>\n   * in the shader.\n   * @returns {ImageryInput[]} The imagery inputs\n   */\n  static _createImageryInputs(\n    imageryLayers,\n    modelPrimitiveImagery,\n    imageryTexCoordAttributeSetIndices,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"imageryLayers\", imageryLayers);\n    Check.defined(\"modelPrimitiveImagery\", modelPrimitiveImagery);\n    Check.defined(\n      \"imageryTexCoordAttributeSetIndices\",\n      imageryTexCoordAttributeSetIndices,\n    );\n    //>>includeEnd('debug');\n\n    const imageryInputs = [];\n\n    for (let i = 0; i < imageryLayers.length; i++) {\n      const imageryLayer = imageryLayers.get(i);\n      if (!imageryLayer.show) {\n        continue;\n      }\n      const imageryTexCoordAttributeSetIndex =\n        imageryTexCoordAttributeSetIndices[i];\n      const mappedPositions =\n        modelPrimitiveImagery.mappedPositionsForImageryLayer(imageryLayer);\n      const cartographicBoundingRectangle =\n        mappedPositions.cartographicBoundingRectangle;\n      const coverages =\n        modelPrimitiveImagery.coveragesForImageryLayer(imageryLayer);\n\n      for (let j = 0; j < coverages.length; j++) {\n        const coverage = coverages[j];\n        const imageryInput = ImageryPipelineStage._createImageryInput(\n          imageryLayer,\n          coverage,\n          cartographicBoundingRectangle,\n          imageryTexCoordAttributeSetIndex,\n        );\n        if (defined(imageryInput)) {\n          imageryInputs.push(imageryInput);\n        }\n      }\n    }\n    return imageryInputs;\n  }\n\n  /**\n   * Create the `ImageryInput` that has to be passed to the imagery pipeline\n   * stage, for the given `ImageryCoverage`.\n   *\n   * The `ImageryCoverage` describes on imagery tile that is covered by the\n   * cartographic bounding rectangle of the primitive positions. This function\n   * obtains the actual `Imagery` object and its texture, computes the\n   * required texture coordinate and scale, and assembles this information\n   * into an `ImageryInput`.\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @param {ImageryCoverage} coverage The imagery coverage\n   * @param {Rectangle} cartographicBoundingRectangle The bounding rectangle\n   * of the cartographic primitive positions\n   * @param {number} imageryTexCoordAttributeSetIndex The set index of the\n   * texture coordinate attribute that should be used for this imagery.\n   * This is the value that will be used to access the texture coordinate\n   * attribute <code>a_imagery_texCoord_${imageryTexCoordAttributeSetIndex}</code>\n   * in the shader.\n   * @returns {ImageryInput|undefined} The imagery input, or undefined if\n   * the imagery for the given coverage turned out to be in the\n   * <code>ImageryState.INVALID/FAILED<code> state, or did not have\n   * a valid texture.\n   * @private\n   */\n  static _createImageryInput(\n    imageryLayer,\n    coverage,\n    cartographicBoundingRectangle,\n    imageryTexCoordAttributeSetIndex,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"imageryLayer\", imageryLayer);\n    Check.defined(\"coverage\", coverage);\n    Check.defined(\n      \"cartographicBoundingRectangle\",\n      cartographicBoundingRectangle,\n    );\n    Check.typeOf.number.greaterThanOrEquals(\n      \"imageryTexCoordAttributeSetIndex\",\n      imageryTexCoordAttributeSetIndex,\n      0,\n    );\n    //>>includeEnd('debug');\n\n    // Bail out early if something went wrong in the imagery\n    // loading state machine\n    const imagery = coverage.imagery;\n    if (\n      imagery.state === ImageryState.FAILED ||\n      imagery.state === ImageryState.INVALID\n    ) {\n      return undefined;\n    }\n\n    // The texture coordinates are computed for the respective\n    // imagery, so pick either the textureWebMercator or the\n    // texture here\n    let texture = imagery.textureWebMercator;\n    if (!defined(texture)) {\n      texture = imagery.texture;\n      if (!defined(texture)) {\n        // Print an error message only when the imagery\n        // SHOULD actually have a texture\n        if (imagery.state === ImageryState.READY) {\n          console.log(\n            `Imagery at ${coverage.x}, ${coverage.y} (level ${coverage.level}) does not have any texture - state ${imagery.state}`,\n          );\n        }\n        return undefined;\n      }\n    }\n\n    const textureTranslationAndScale =\n      ImageryPipelineStage._computeTextureTranslationAndScale(\n        imageryLayer,\n        cartographicBoundingRectangle,\n        imagery.rectangle,\n      );\n\n    // Convert the texture coordinate rectangle into a Cartesian4\n    // for the consumption as a uniform in the shader\n    const textureCoordinateCartesianRectangle =\n      coverage.textureCoordinateRectangle;\n    const textureCoordinateRectangle = new Cartesian4(\n      textureCoordinateCartesianRectangle.minX,\n      textureCoordinateCartesianRectangle.minY,\n      textureCoordinateCartesianRectangle.maxX,\n      textureCoordinateCartesianRectangle.maxY,\n    );\n\n    const imageryInput = new ImageryInput(\n      imageryLayer,\n      texture,\n      textureTranslationAndScale,\n      textureCoordinateRectangle,\n      imageryTexCoordAttributeSetIndex,\n    );\n    return imageryInput;\n  }\n\n  /**\n   * Compute the translation and scale that has to be applied to\n   * the texture coordinates for mapping the given imagery to\n   * the geometry.\n   *\n   * The given rectangles will be converted into their \"native\" representation,\n   * using the tiling scheme of the given imagery layer, and passed\n   * to `_computeTextureTranslationAndScaleFromNative` (see that for details).\n   *\n   * @param {ImageryLayer} imageryLayer The imagery layer\n   * @param {Rectangle} nonNativeBoundingRectangle The bounding\n   * rectangle of the geometry\n   * @param {Rectangle} nonNativeImageryRectangle The bounding\n   * rectangle of the imagery\n   * @returns {Cartesian4} The translation and scale\n   * @private\n   */\n  static _computeTextureTranslationAndScale(\n    imageryLayer,\n    nonNativeBoundingRectangle,\n    nonNativeImageryRectangle,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"imageryLayer\", imageryLayer);\n    Check.defined(\"nonNativeBoundingRectangle\", nonNativeBoundingRectangle);\n    Check.defined(\"nonNativeImageryRectangle\", nonNativeImageryRectangle);\n    //>>includeEnd('debug');\n\n    const tilingScheme = imageryLayer.imageryProvider.tilingScheme;\n\n    const nativeBoundingRectangle = tilingScheme.rectangleToNativeRectangle(\n      nonNativeBoundingRectangle,\n      nativeBoundingRectangleScratch,\n    );\n    const nativeImageryRectangle = tilingScheme.rectangleToNativeRectangle(\n      nonNativeImageryRectangle,\n      nativeImageryRectangleScratch,\n    );\n\n    const translationAndScale =\n      ImageryPipelineStage._computeTextureTranslationAndScaleFromNative(\n        nativeBoundingRectangle,\n        nativeImageryRectangle,\n      );\n    return translationAndScale;\n  }\n\n  /**\n   * Compute the translation and scale that has to be applied to\n   * the texture coordinates for mapping the given imagery rectangle\n   * to the geometry rectangle.\n   *\n   * This will compute a Cartesian4 containing the\n   * (offsetX, offsetY, scaleX, scaleY) that have to be applied to\n   * the texture coordinates that that have been computed with\n   * `ModelImageryMapping.createTextureCoordinatesAttributeForMappedPositions`.\n   * In the shader, this offset and scale will map the given imagery rectangle\n   * to the geometry * rectangle.\n   *\n   * @param {Imagery} imagery The imagery\n   * @param {Rectangle} nonNativeBoundingRectangle The bounding\n   * rectangle of the geometry\n   * @param {Rectangle} nonNativeImageryRectangle The bounding\n   * rectangle of the imagery\n   * @returns {Cartesian4} The translation and scale\n   * @private\n   */\n  static _computeTextureTranslationAndScaleFromNative(\n    nativeBoundingRectangle,\n    nativeImageryRectangle,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"nativeBoundingRectangle\", nativeBoundingRectangle);\n    Check.defined(\"nativeImageryRectangle\", nativeImageryRectangle);\n    //>>includeEnd('debug');\n\n    const invImageryWidth = 1.0 / nativeImageryRectangle.width;\n    const invImageryHeight = 1.0 / nativeImageryRectangle.height;\n    const deltaWest =\n      nativeBoundingRectangle.west - nativeImageryRectangle.west;\n    const deltaSouth =\n      nativeBoundingRectangle.south - nativeImageryRectangle.south;\n    const offsetX = deltaWest * invImageryWidth;\n    const offsetY = deltaSouth * invImageryHeight;\n    const scaleX = nativeBoundingRectangle.width * invImageryWidth;\n    const scaleY = nativeBoundingRectangle.height * invImageryHeight;\n    return new Cartesian4(offsetX, offsetY, scaleX, scaleY);\n  }\n\n  /**\n   * Computes the index mapping from the given source to the given target.\n   *\n   * The result will be an array that has the same length as the source,\n   * and contains the indices that the source elements have in the\n   * target array.\n   *\n   * @param {object[]} source The source array\n   * @param {object[]} target The target array\n   * @returns {number[]} The result\n   */\n  static _computeIndexMapping(source, target) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"source\", source);\n    Check.defined(\"target\", target);\n    //>>includeEnd('debug');\n\n    const result = [];\n    const length = source.length;\n    for (let i = 0; i < length; i++) {\n      const element = source[i];\n      const index = target.indexOf(element);\n      result.push(index);\n    }\n    return result;\n  }\n}\n\n// Static properties (direct initialization disallowed by eslint)\n//ImageryPipelineStage.name = \"ImageryPipelineStage\"; // Helps with debugging, if you know where to look\n\nexport default ImageryPipelineStage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}