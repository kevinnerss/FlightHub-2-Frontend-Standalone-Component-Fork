{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport AttributeCompression from \"./AttributeCompression.js\";\nimport barycentricCoordinates from \"./barycentricCoordinates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EncodedCartesian3 from \"./EncodedCartesian3.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryType from \"./GeometryType.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport Intersect from \"./Intersect.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Tipsify from \"./Tipsify.js\";\n\n/**\n * Content pipeline functions for geometries.\n *\n * @namespace GeometryPipeline\n *\n * @see Geometry\n */\nconst GeometryPipeline = {};\nfunction addTriangle(lines, index, i0, i1, i2) {\n  lines[index++] = i0;\n  lines[index++] = i1;\n  lines[index++] = i1;\n  lines[index++] = i2;\n  lines[index++] = i2;\n  lines[index] = i0;\n}\nfunction trianglesToLines(triangles) {\n  const count = triangles.length;\n  const size = count / 3 * 6;\n  const lines = IndexDatatype.createTypedArray(count, size);\n  let index = 0;\n  for (let i = 0; i < count; i += 3, index += 6) {\n    addTriangle(lines, index, triangles[i], triangles[i + 1], triangles[i + 2]);\n  }\n  return lines;\n}\nfunction triangleStripToLines(triangles) {\n  const count = triangles.length;\n  if (count >= 3) {\n    const size = (count - 2) * 6;\n    const lines = IndexDatatype.createTypedArray(count, size);\n    addTriangle(lines, 0, triangles[0], triangles[1], triangles[2]);\n    let index = 6;\n    for (let i = 3; i < count; ++i, index += 6) {\n      addTriangle(lines, index, triangles[i - 1], triangles[i], triangles[i - 2]);\n    }\n    return lines;\n  }\n  return new Uint16Array();\n}\nfunction triangleFanToLines(triangles) {\n  if (triangles.length > 0) {\n    const count = triangles.length - 1;\n    const size = (count - 1) * 6;\n    const lines = IndexDatatype.createTypedArray(count, size);\n    const base = triangles[0];\n    let index = 0;\n    for (let i = 1; i < count; ++i, index += 6) {\n      addTriangle(lines, index, base, triangles[i], triangles[i + 1]);\n    }\n    return lines;\n  }\n  return new Uint16Array();\n}\n\n/**\n * Converts a geometry's triangle indices to line indices.  If the geometry has an <code>indices</code>\n * and its <code>primitiveType</code> is <code>TRIANGLES</code>, <code>TRIANGLE_STRIP</code>,\n * <code>TRIANGLE_FAN</code>, it is converted to <code>LINES</code>; otherwise, the geometry is not changed.\n * <p>\n * This is commonly used to create a wireframe geometry for visual debugging.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its triangle indices converted to lines.\n *\n * @exception {DeveloperError} geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.toWireframe(geometry);\n */\nGeometryPipeline.toWireframe = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = geometry.indices;\n  if (defined(indices)) {\n    switch (geometry.primitiveType) {\n      case PrimitiveType.TRIANGLES:\n        geometry.indices = trianglesToLines(indices);\n        break;\n      case PrimitiveType.TRIANGLE_STRIP:\n        geometry.indices = triangleStripToLines(indices);\n        break;\n      case PrimitiveType.TRIANGLE_FAN:\n        geometry.indices = triangleFanToLines(indices);\n        break;\n      //>>includeStart('debug', pragmas.debug);\n      default:\n        throw new DeveloperError(\"geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.\");\n      //>>includeEnd('debug');\n    }\n    geometry.primitiveType = PrimitiveType.LINES;\n  }\n  return geometry;\n};\n\n/**\n * Creates a new {@link Geometry} with <code>LINES</code> representing the provided\n * attribute (<code>attributeName</code>) for the provided geometry.  This is used to\n * visualize vector attributes like normals, tangents, and bitangents.\n *\n * @param {Geometry} geometry The <code>Geometry</code> instance with the attribute.\n * @param {string} [attributeName='normal'] The name of the attribute.\n * @param {number} [length=10000.0] The length of each line segment in meters.  This can be negative to point the vector in the opposite direction.\n * @returns {Geometry} A new <code>Geometry</code> instance with line segments for the vector.\n *\n * @exception {DeveloperError} geometry.attributes must have an attribute with the same name as the attributeName parameter.\n *\n * @example\n * const geometry = Cesium.GeometryPipeline.createLineSegmentsForVectors(instance.geometry, 'bitangent', 100000.0);\n */\nGeometryPipeline.createLineSegmentsForVectors = function (geometry, attributeName, length) {\n  attributeName = attributeName ?? \"normal\";\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (!defined(geometry.attributes.position)) {\n    throw new DeveloperError(\"geometry.attributes.position is required.\");\n  }\n  if (!defined(geometry.attributes[attributeName])) {\n    throw new DeveloperError(`geometry.attributes must have an attribute with the same name as the attributeName parameter, ${attributeName}.`);\n  }\n  //>>includeEnd('debug');\n\n  length = length ?? 10000.0;\n  const positions = geometry.attributes.position.values;\n  const vectors = geometry.attributes[attributeName].values;\n  const positionsLength = positions.length;\n  const newPositions = new Float64Array(2 * positionsLength);\n  let j = 0;\n  for (let i = 0; i < positionsLength; i += 3) {\n    newPositions[j++] = positions[i];\n    newPositions[j++] = positions[i + 1];\n    newPositions[j++] = positions[i + 2];\n    newPositions[j++] = positions[i] + vectors[i] * length;\n    newPositions[j++] = positions[i + 1] + vectors[i + 1] * length;\n    newPositions[j++] = positions[i + 2] + vectors[i + 2] * length;\n  }\n  let newBoundingSphere;\n  const bs = geometry.boundingSphere;\n  if (defined(bs)) {\n    newBoundingSphere = new BoundingSphere(bs.center, bs.radius + length);\n  }\n  return new Geometry({\n    attributes: {\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: newPositions\n      })\n    },\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: newBoundingSphere\n  });\n};\n\n/**\n * Creates an object that maps attribute names to unique locations (indices)\n * for matching vertex attributes and shader programs.\n *\n * @param {Geometry} geometry The geometry, which is not modified, to create the object for.\n * @returns {object} An object with attribute name / index pairs.\n *\n * @example\n * const attributeLocations = Cesium.GeometryPipeline.createAttributeLocations(geometry);\n * // Example output\n * // {\n * //   'position' : 0,\n * //   'normal' : 1\n * // }\n */\nGeometryPipeline.createAttributeLocations = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // There can be a WebGL performance hit when attribute 0 is disabled, so\n  // assign attribute locations to well-known attributes.\n  const semantics = [\"position\", \"positionHigh\", \"positionLow\",\n  // From VertexFormat.position - after 2D projection and high-precision encoding\n  \"position3DHigh\", \"position3DLow\", \"position2DHigh\", \"position2DLow\",\n  // From Primitive\n  \"pickColor\",\n  // From VertexFormat\n  \"normal\", \"st\", \"tangent\", \"bitangent\",\n  // For shadow volumes\n  \"extrudeDirection\",\n  // From compressing texture coordinates and normals\n  \"compressedAttributes\"];\n  const attributes = geometry.attributes;\n  const indices = {};\n  let j = 0;\n  let i;\n  const len = semantics.length;\n\n  // Attribute locations for well-known attributes\n  for (i = 0; i < len; ++i) {\n    const semantic = semantics[i];\n    if (defined(attributes[semantic])) {\n      indices[semantic] = j++;\n    }\n  }\n\n  // Locations for custom attributes\n  for (const name in attributes) {\n    if (attributes.hasOwnProperty(name) && !defined(indices[name])) {\n      indices[name] = j++;\n    }\n  }\n  return indices;\n};\n\n/**\n * Reorders a geometry's attributes and <code>indices</code> to achieve better performance from the GPU's pre-vertex-shader cache.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its attributes and indices reordered for the GPU's pre-vertex-shader cache.\n *\n * @exception {DeveloperError} Each attribute array in geometry.attributes must have the same number of attributes.\n *\n *\n * @example\n * geometry = Cesium.GeometryPipeline.reorderForPreVertexCache(geometry);\n *\n * @see GeometryPipeline.reorderForPostVertexCache\n */\nGeometryPipeline.reorderForPreVertexCache = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const numVertices = Geometry.computeNumberOfVertices(geometry);\n  const indices = geometry.indices;\n  if (defined(indices)) {\n    const indexCrossReferenceOldToNew = new Int32Array(numVertices);\n    for (let i = 0; i < numVertices; i++) {\n      indexCrossReferenceOldToNew[i] = -1;\n    }\n\n    // Construct cross reference and reorder indices\n    const indicesIn = indices;\n    const numIndices = indicesIn.length;\n    const indicesOut = IndexDatatype.createTypedArray(numVertices, numIndices);\n    let intoIndicesIn = 0;\n    let intoIndicesOut = 0;\n    let nextIndex = 0;\n    let tempIndex;\n    while (intoIndicesIn < numIndices) {\n      tempIndex = indexCrossReferenceOldToNew[indicesIn[intoIndicesIn]];\n      if (tempIndex !== -1) {\n        indicesOut[intoIndicesOut] = tempIndex;\n      } else {\n        tempIndex = indicesIn[intoIndicesIn];\n        indexCrossReferenceOldToNew[tempIndex] = nextIndex;\n        indicesOut[intoIndicesOut] = nextIndex;\n        ++nextIndex;\n      }\n      ++intoIndicesIn;\n      ++intoIndicesOut;\n    }\n    geometry.indices = indicesOut;\n\n    // Reorder attributes\n    const attributes = geometry.attributes;\n    for (const property in attributes) {\n      if (attributes.hasOwnProperty(property) && defined(attributes[property]) && defined(attributes[property].values)) {\n        const attribute = attributes[property];\n        const elementsIn = attribute.values;\n        let intoElementsIn = 0;\n        const numComponents = attribute.componentsPerAttribute;\n        const elementsOut = ComponentDatatype.createTypedArray(attribute.componentDatatype, nextIndex * numComponents);\n        while (intoElementsIn < numVertices) {\n          const temp = indexCrossReferenceOldToNew[intoElementsIn];\n          if (temp !== -1) {\n            for (let j = 0; j < numComponents; j++) {\n              elementsOut[numComponents * temp + j] = elementsIn[numComponents * intoElementsIn + j];\n            }\n          }\n          ++intoElementsIn;\n        }\n        attribute.values = elementsOut;\n      }\n    }\n  }\n  return geometry;\n};\n\n/**\n * Reorders a geometry's <code>indices</code> to achieve better performance from the GPU's\n * post vertex-shader cache by using the Tipsify algorithm.  If the geometry <code>primitiveType</code>\n * is not <code>TRIANGLES</code> or the geometry does not have an <code>indices</code>, this function has no effect.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @param {number} [cacheCapacity=24] The number of vertices that can be held in the GPU's vertex cache.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its indices reordered for the post-vertex-shader cache.\n *\n * @exception {DeveloperError} cacheCapacity must be greater than two.\n *\n *\n * @example\n * geometry = Cesium.GeometryPipeline.reorderForPostVertexCache(geometry);\n *\n * @see GeometryPipeline.reorderForPreVertexCache\n * @see {@link http://gfx.cs.princ0eton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf|Fast Triangle Reordering for Vertex Locality and Reduced Overdraw}\n * by Sander, Nehab, and Barczak\n */\nGeometryPipeline.reorderForPostVertexCache = function (geometry, cacheCapacity) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = geometry.indices;\n  if (geometry.primitiveType === PrimitiveType.TRIANGLES && defined(indices)) {\n    const numIndices = indices.length;\n    let maximumIndex = 0;\n    for (let j = 0; j < numIndices; j++) {\n      if (indices[j] > maximumIndex) {\n        maximumIndex = indices[j];\n      }\n    }\n    geometry.indices = Tipsify.tipsify({\n      indices: indices,\n      maximumIndex: maximumIndex,\n      cacheSize: cacheCapacity\n    });\n  }\n  return geometry;\n};\nfunction copyAttributesDescriptions(attributes) {\n  const newAttributes = {};\n  for (const attribute in attributes) {\n    if (attributes.hasOwnProperty(attribute) && defined(attributes[attribute]) && defined(attributes[attribute].values)) {\n      const attr = attributes[attribute];\n      newAttributes[attribute] = new GeometryAttribute({\n        componentDatatype: attr.componentDatatype,\n        componentsPerAttribute: attr.componentsPerAttribute,\n        normalize: attr.normalize,\n        values: []\n      });\n    }\n  }\n  return newAttributes;\n}\nfunction copyVertex(destinationAttributes, sourceAttributes, index) {\n  for (const attribute in sourceAttributes) {\n    if (sourceAttributes.hasOwnProperty(attribute) && defined(sourceAttributes[attribute]) && defined(sourceAttributes[attribute].values)) {\n      const attr = sourceAttributes[attribute];\n      for (let k = 0; k < attr.componentsPerAttribute; ++k) {\n        destinationAttributes[attribute].values.push(attr.values[index * attr.componentsPerAttribute + k]);\n      }\n    }\n  }\n}\n\n/**\n * Splits a geometry into multiple geometries, if necessary, to ensure that indices in the\n * <code>indices</code> fit into unsigned shorts.  This is used to meet the WebGL requirements\n * when unsigned int indices are not supported.\n * <p>\n * If the geometry does not have any <code>indices</code>, this function has no effect.\n * </p>\n *\n * @param {Geometry} geometry The geometry to be split into multiple geometries.\n * @returns {Geometry[]} An array of geometries, each with indices that fit into unsigned shorts.\n *\n * @exception {DeveloperError} geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS\n * @exception {DeveloperError} All geometry attribute lists must have the same number of attributes.\n *\n * @example\n * const geometries = Cesium.GeometryPipeline.fitToUnsignedShortIndices(geometry);\n */\nGeometryPipeline.fitToUnsignedShortIndices = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (defined(geometry.indices) && geometry.primitiveType !== PrimitiveType.TRIANGLES && geometry.primitiveType !== PrimitiveType.LINES && geometry.primitiveType !== PrimitiveType.POINTS) {\n    throw new DeveloperError(\"geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS.\");\n  }\n  //>>includeEnd('debug');\n\n  const geometries = [];\n\n  // If there's an index list and more than 64K attributes, it is possible that\n  // some indices are outside the range of unsigned short [0, 64K - 1]\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n  if (defined(geometry.indices) && numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\n    let oldToNewIndex = [];\n    let newIndices = [];\n    let currentIndex = 0;\n    let newAttributes = copyAttributesDescriptions(geometry.attributes);\n    const originalIndices = geometry.indices;\n    const numberOfIndices = originalIndices.length;\n    let indicesPerPrimitive;\n    if (geometry.primitiveType === PrimitiveType.TRIANGLES) {\n      indicesPerPrimitive = 3;\n    } else if (geometry.primitiveType === PrimitiveType.LINES) {\n      indicesPerPrimitive = 2;\n    } else if (geometry.primitiveType === PrimitiveType.POINTS) {\n      indicesPerPrimitive = 1;\n    }\n    for (let j = 0; j < numberOfIndices; j += indicesPerPrimitive) {\n      for (let k = 0; k < indicesPerPrimitive; ++k) {\n        const x = originalIndices[j + k];\n        let i = oldToNewIndex[x];\n        if (!defined(i)) {\n          i = currentIndex++;\n          oldToNewIndex[x] = i;\n          copyVertex(newAttributes, geometry.attributes, x);\n        }\n        newIndices.push(i);\n      }\n      if (currentIndex + indicesPerPrimitive >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\n        geometries.push(new Geometry({\n          attributes: newAttributes,\n          indices: newIndices,\n          primitiveType: geometry.primitiveType,\n          boundingSphere: geometry.boundingSphere,\n          boundingSphereCV: geometry.boundingSphereCV\n        }));\n\n        // Reset for next vertex-array\n        oldToNewIndex = [];\n        newIndices = [];\n        currentIndex = 0;\n        newAttributes = copyAttributesDescriptions(geometry.attributes);\n      }\n    }\n    if (newIndices.length !== 0) {\n      geometries.push(new Geometry({\n        attributes: newAttributes,\n        indices: newIndices,\n        primitiveType: geometry.primitiveType,\n        boundingSphere: geometry.boundingSphere,\n        boundingSphereCV: geometry.boundingSphereCV\n      }));\n    }\n  } else {\n    // No need to split into multiple geometries\n    geometries.push(geometry);\n  }\n  return geometries;\n};\nconst scratchProjectTo2DCartesian3 = new Cartesian3();\nconst scratchProjectTo2DCartographic = new Cartographic();\n\n/**\n * Projects a geometry's 3D <code>position</code> attribute to 2D, replacing the <code>position</code>\n * attribute with separate <code>position3D</code> and <code>position2D</code> attributes.\n * <p>\n * If the geometry does not have a <code>position</code>, this function has no effect.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @param {string} attributeName The name of the attribute.\n * @param {string} attributeName3D The name of the attribute in 3D.\n * @param {string} attributeName2D The name of the attribute in 2D.\n * @param {object} [projection=new GeographicProjection()] The projection to use.\n * @returns {Geometry} The modified <code>geometry</code> argument with <code>position3D</code> and <code>position2D</code> attributes.\n *\n * @exception {DeveloperError} geometry must have attribute matching the attributeName argument.\n * @exception {DeveloperError} The attribute componentDatatype must be ComponentDatatype.DOUBLE.\n * @exception {DeveloperError} Could not project a point to 2D.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.projectTo2D(geometry, 'position', 'position3D', 'position2D');\n */\nGeometryPipeline.projectTo2D = function (geometry, attributeName, attributeName3D, attributeName2D, projection) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (!defined(attributeName)) {\n    throw new DeveloperError(\"attributeName is required.\");\n  }\n  if (!defined(attributeName3D)) {\n    throw new DeveloperError(\"attributeName3D is required.\");\n  }\n  if (!defined(attributeName2D)) {\n    throw new DeveloperError(\"attributeName2D is required.\");\n  }\n  if (!defined(geometry.attributes[attributeName])) {\n    throw new DeveloperError(`geometry must have attribute matching the attributeName argument: ${attributeName}.`);\n  }\n  if (geometry.attributes[attributeName].componentDatatype !== ComponentDatatype.DOUBLE) {\n    throw new DeveloperError(\"The attribute componentDatatype must be ComponentDatatype.DOUBLE.\");\n  }\n  //>>includeEnd('debug');\n\n  const attribute = geometry.attributes[attributeName];\n  projection = defined(projection) ? projection : new GeographicProjection();\n  const ellipsoid = projection.ellipsoid;\n\n  // Project original values to 2D.\n  const values3D = attribute.values;\n  const projectedValues = new Float64Array(values3D.length);\n  let index = 0;\n  for (let i = 0; i < values3D.length; i += 3) {\n    const value = Cartesian3.fromArray(values3D, i, scratchProjectTo2DCartesian3);\n    const lonLat = ellipsoid.cartesianToCartographic(value, scratchProjectTo2DCartographic);\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(lonLat)) {\n      throw new DeveloperError(`Could not project point (${value.x}, ${value.y}, ${value.z}) to 2D.`);\n    }\n    //>>includeEnd('debug');\n\n    const projectedLonLat = projection.project(lonLat, scratchProjectTo2DCartesian3);\n    projectedValues[index++] = projectedLonLat.x;\n    projectedValues[index++] = projectedLonLat.y;\n    projectedValues[index++] = projectedLonLat.z;\n  }\n\n  // Rename original cartesians to ellipsoid cartesians.\n  geometry.attributes[attributeName3D] = attribute;\n\n  // Replace original cartesians with 2D projected cartesians\n  geometry.attributes[attributeName2D] = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: projectedValues\n  });\n  delete geometry.attributes[attributeName];\n  return geometry;\n};\nconst encodedResult = {\n  high: 0.0,\n  low: 0.0\n};\n\n/**\n * Encodes floating-point geometry attribute values as two separate attributes to improve\n * rendering precision.\n * <p>\n * This is commonly used to create high-precision position vertex attributes.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @param {string} attributeName The name of the attribute.\n * @param {string} attributeHighName The name of the attribute for the encoded high bits.\n * @param {string} attributeLowName The name of the attribute for the encoded low bits.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its encoded attribute.\n *\n * @exception {DeveloperError} geometry must have attribute matching the attributeName argument.\n * @exception {DeveloperError} The attribute componentDatatype must be ComponentDatatype.DOUBLE.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.encodeAttribute(geometry, 'position3D', 'position3DHigh', 'position3DLow');\n */\nGeometryPipeline.encodeAttribute = function (geometry, attributeName, attributeHighName, attributeLowName) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (!defined(attributeName)) {\n    throw new DeveloperError(\"attributeName is required.\");\n  }\n  if (!defined(attributeHighName)) {\n    throw new DeveloperError(\"attributeHighName is required.\");\n  }\n  if (!defined(attributeLowName)) {\n    throw new DeveloperError(\"attributeLowName is required.\");\n  }\n  if (!defined(geometry.attributes[attributeName])) {\n    throw new DeveloperError(`geometry must have attribute matching the attributeName argument: ${attributeName}.`);\n  }\n  if (geometry.attributes[attributeName].componentDatatype !== ComponentDatatype.DOUBLE) {\n    throw new DeveloperError(\"The attribute componentDatatype must be ComponentDatatype.DOUBLE.\");\n  }\n  //>>includeEnd('debug');\n\n  const attribute = geometry.attributes[attributeName];\n  const values = attribute.values;\n  const length = values.length;\n  const highValues = new Float32Array(length);\n  const lowValues = new Float32Array(length);\n  for (let i = 0; i < length; ++i) {\n    EncodedCartesian3.encode(values[i], encodedResult);\n    highValues[i] = encodedResult.high;\n    lowValues[i] = encodedResult.low;\n  }\n  const componentsPerAttribute = attribute.componentsPerAttribute;\n  geometry.attributes[attributeHighName] = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: componentsPerAttribute,\n    values: highValues\n  });\n  geometry.attributes[attributeLowName] = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: componentsPerAttribute,\n    values: lowValues\n  });\n  delete geometry.attributes[attributeName];\n  return geometry;\n};\nlet scratchCartesian3 = new Cartesian3();\nfunction transformPoint(matrix, attribute) {\n  if (defined(attribute)) {\n    const values = attribute.values;\n    const length = values.length;\n    for (let i = 0; i < length; i += 3) {\n      Cartesian3.unpack(values, i, scratchCartesian3);\n      Matrix4.multiplyByPoint(matrix, scratchCartesian3, scratchCartesian3);\n      Cartesian3.pack(scratchCartesian3, values, i);\n    }\n  }\n}\nfunction transformVector(matrix, attribute) {\n  if (defined(attribute)) {\n    const values = attribute.values;\n    const length = values.length;\n    for (let i = 0; i < length; i += 3) {\n      Cartesian3.unpack(values, i, scratchCartesian3);\n      Matrix3.multiplyByVector(matrix, scratchCartesian3, scratchCartesian3);\n      scratchCartesian3 = Cartesian3.normalize(scratchCartesian3, scratchCartesian3);\n      Cartesian3.pack(scratchCartesian3, values, i);\n    }\n  }\n}\nconst inverseTranspose = new Matrix4();\nconst normalMatrix = new Matrix3();\n\n/**\n * Transforms a geometry instance to world coordinates.  This changes\n * the instance's <code>modelMatrix</code> to {@link Matrix4.IDENTITY} and transforms the\n * following attributes if they are present: <code>position</code>, <code>normal</code>,\n * <code>tangent</code>, and <code>bitangent</code>.\n *\n * @param {GeometryInstance} instance The geometry instance to modify.\n * @returns {GeometryInstance} The modified <code>instance</code> argument, with its attributes transforms to world coordinates.\n *\n * @example\n * Cesium.GeometryPipeline.transformToWorldCoordinates(instance);\n */\nGeometryPipeline.transformToWorldCoordinates = function (instance) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(instance)) {\n    throw new DeveloperError(\"instance is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const modelMatrix = instance.modelMatrix;\n  if (Matrix4.equals(modelMatrix, Matrix4.IDENTITY)) {\n    // Already in world coordinates\n    return instance;\n  }\n  const attributes = instance.geometry.attributes;\n\n  // Transform attributes in known vertex formats\n  transformPoint(modelMatrix, attributes.position);\n  transformPoint(modelMatrix, attributes.prevPosition);\n  transformPoint(modelMatrix, attributes.nextPosition);\n  if (defined(attributes.normal) || defined(attributes.tangent) || defined(attributes.bitangent)) {\n    Matrix4.inverse(modelMatrix, inverseTranspose);\n    Matrix4.transpose(inverseTranspose, inverseTranspose);\n    Matrix4.getMatrix3(inverseTranspose, normalMatrix);\n    transformVector(normalMatrix, attributes.normal);\n    transformVector(normalMatrix, attributes.tangent);\n    transformVector(normalMatrix, attributes.bitangent);\n  }\n  const boundingSphere = instance.geometry.boundingSphere;\n  if (defined(boundingSphere)) {\n    instance.geometry.boundingSphere = BoundingSphere.transform(boundingSphere, modelMatrix, boundingSphere);\n  }\n  instance.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  return instance;\n};\nfunction findAttributesInAllGeometries(instances, propertyName) {\n  const length = instances.length;\n  const attributesInAllGeometries = {};\n  const attributes0 = instances[0][propertyName].attributes;\n  let name;\n  for (name in attributes0) {\n    if (attributes0.hasOwnProperty(name) && defined(attributes0[name]) && defined(attributes0[name].values)) {\n      const attribute = attributes0[name];\n      let numberOfComponents = attribute.values.length;\n      let inAllGeometries = true;\n\n      // Does this same attribute exist in all geometries?\n      for (let i = 1; i < length; ++i) {\n        const otherAttribute = instances[i][propertyName].attributes[name];\n        if (!defined(otherAttribute) || attribute.componentDatatype !== otherAttribute.componentDatatype || attribute.componentsPerAttribute !== otherAttribute.componentsPerAttribute || attribute.normalize !== otherAttribute.normalize) {\n          inAllGeometries = false;\n          break;\n        }\n        numberOfComponents += otherAttribute.values.length;\n      }\n      if (inAllGeometries) {\n        attributesInAllGeometries[name] = new GeometryAttribute({\n          componentDatatype: attribute.componentDatatype,\n          componentsPerAttribute: attribute.componentsPerAttribute,\n          normalize: attribute.normalize,\n          values: ComponentDatatype.createTypedArray(attribute.componentDatatype, numberOfComponents)\n        });\n      }\n    }\n  }\n  return attributesInAllGeometries;\n}\nconst tempScratch = new Cartesian3();\nfunction combineGeometries(instances, propertyName) {\n  const length = instances.length;\n  let name;\n  let i;\n  let j;\n  let k;\n  const m = instances[0].modelMatrix;\n  const haveIndices = defined(instances[0][propertyName].indices);\n  const primitiveType = instances[0][propertyName].primitiveType;\n\n  //>>includeStart('debug', pragmas.debug);\n  for (i = 1; i < length; ++i) {\n    if (!Matrix4.equals(instances[i].modelMatrix, m)) {\n      throw new DeveloperError(\"All instances must have the same modelMatrix.\");\n    }\n    if (defined(instances[i][propertyName].indices) !== haveIndices) {\n      throw new DeveloperError(\"All instance geometries must have an indices or not have one.\");\n    }\n    if (instances[i][propertyName].primitiveType !== primitiveType) {\n      throw new DeveloperError(\"All instance geometries must have the same primitiveType.\");\n    }\n  }\n  //>>includeEnd('debug');\n\n  // Find subset of attributes in all geometries\n  const attributes = findAttributesInAllGeometries(instances, propertyName);\n  let values;\n  let sourceValues;\n  let sourceValuesLength;\n\n  // Combine attributes from each geometry into a single typed array\n  for (name in attributes) {\n    if (attributes.hasOwnProperty(name)) {\n      values = attributes[name].values;\n      k = 0;\n      for (i = 0; i < length; ++i) {\n        sourceValues = instances[i][propertyName].attributes[name].values;\n        sourceValuesLength = sourceValues.length;\n        for (j = 0; j < sourceValuesLength; ++j) {\n          values[k++] = sourceValues[j];\n        }\n      }\n    }\n  }\n\n  // Combine index lists\n  let indices;\n  if (haveIndices) {\n    let numberOfIndices = 0;\n    for (i = 0; i < length; ++i) {\n      numberOfIndices += instances[i][propertyName].indices.length;\n    }\n    const numberOfVertices = Geometry.computeNumberOfVertices(new Geometry({\n      attributes: attributes,\n      primitiveType: PrimitiveType.POINTS\n    }));\n    const destIndices = IndexDatatype.createTypedArray(numberOfVertices, numberOfIndices);\n    let destOffset = 0;\n    let offset = 0;\n    for (i = 0; i < length; ++i) {\n      const sourceIndices = instances[i][propertyName].indices;\n      const sourceIndicesLen = sourceIndices.length;\n      for (k = 0; k < sourceIndicesLen; ++k) {\n        destIndices[destOffset++] = offset + sourceIndices[k];\n      }\n      offset += Geometry.computeNumberOfVertices(instances[i][propertyName]);\n    }\n    indices = destIndices;\n  }\n\n  // Create bounding sphere that includes all instances\n  let center = new Cartesian3();\n  let radius = 0.0;\n  let bs;\n  for (i = 0; i < length; ++i) {\n    bs = instances[i][propertyName].boundingSphere;\n    if (!defined(bs)) {\n      // If any geometries have an undefined bounding sphere, then so does the combined geometry\n      center = undefined;\n      break;\n    }\n    Cartesian3.add(bs.center, center, center);\n  }\n  if (defined(center)) {\n    Cartesian3.divideByScalar(center, length, center);\n    for (i = 0; i < length; ++i) {\n      bs = instances[i][propertyName].boundingSphere;\n      const tempRadius = Cartesian3.magnitude(Cartesian3.subtract(bs.center, center, tempScratch)) + bs.radius;\n      if (tempRadius > radius) {\n        radius = tempRadius;\n      }\n    }\n  }\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: primitiveType,\n    boundingSphere: defined(center) ? new BoundingSphere(center, radius) : undefined\n  });\n}\n\n/**\n * Combines geometry from several {@link GeometryInstance} objects into one geometry.\n * This concatenates the attributes, concatenates and adjusts the indices, and creates\n * a bounding sphere encompassing all instances.\n * <p>\n * If the instances do not have the same attributes, a subset of attributes common\n * to all instances is used, and the others are ignored.\n * </p>\n * <p>\n * This is used by {@link Primitive} to efficiently render a large amount of static data.\n * </p>\n *\n * @private\n *\n * @param {GeometryInstance[]} [instances] The array of {@link GeometryInstance} objects whose geometry will be combined.\n * @returns {Geometry} A single geometry created from the provided geometry instances.\n *\n * @exception {DeveloperError} All instances must have the same modelMatrix.\n * @exception {DeveloperError} All instance geometries must have an indices or not have one.\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n *\n *\n * @example\n * for (let i = 0; i < instances.length; ++i) {\n *   Cesium.GeometryPipeline.transformToWorldCoordinates(instances[i]);\n * }\n * const geometries = Cesium.GeometryPipeline.combineInstances(instances);\n *\n * @see GeometryPipeline.transformToWorldCoordinates\n */\nGeometryPipeline.combineInstances = function (instances) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(instances) || instances.length < 1) {\n    throw new DeveloperError(\"instances is required and must have length greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  const instanceGeometry = [];\n  const instanceSplitGeometry = [];\n  const length = instances.length;\n  for (let i = 0; i < length; ++i) {\n    const instance = instances[i];\n    if (defined(instance.geometry)) {\n      instanceGeometry.push(instance);\n    } else if (defined(instance.westHemisphereGeometry) && defined(instance.eastHemisphereGeometry)) {\n      instanceSplitGeometry.push(instance);\n    }\n  }\n  const geometries = [];\n  if (instanceGeometry.length > 0) {\n    geometries.push(combineGeometries(instanceGeometry, \"geometry\"));\n  }\n  if (instanceSplitGeometry.length > 0) {\n    geometries.push(combineGeometries(instanceSplitGeometry, \"westHemisphereGeometry\"));\n    geometries.push(combineGeometries(instanceSplitGeometry, \"eastHemisphereGeometry\"));\n  }\n  return geometries;\n};\nconst normal = new Cartesian3();\nconst v0 = new Cartesian3();\nconst v1 = new Cartesian3();\nconst v2 = new Cartesian3();\n\n/**\n * Computes per-vertex normals for a geometry containing <code>TRIANGLES</code> by averaging the normals of\n * all triangles incident to the vertex.  The result is a new <code>normal</code> attribute added to the geometry.\n * This assumes a counter-clockwise winding order.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument with the computed <code>normal</code> attribute.\n *\n * @exception {DeveloperError} geometry.indices length must be greater than 0 and be a multiple of 3.\n * @exception {DeveloperError} geometry.primitiveType must be {@link PrimitiveType.TRIANGLES}.\n *\n * @example\n * Cesium.GeometryPipeline.computeNormal(geometry);\n */\nGeometryPipeline.computeNormal = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (!defined(geometry.attributes.position) || !defined(geometry.attributes.position.values)) {\n    throw new DeveloperError(\"geometry.attributes.position.values is required.\");\n  }\n  if (!defined(geometry.indices)) {\n    throw new DeveloperError(\"geometry.indices is required.\");\n  }\n  if (geometry.indices.length < 2 || geometry.indices.length % 3 !== 0) {\n    throw new DeveloperError(\"geometry.indices length must be greater than 0 and be a multiple of 3.\");\n  }\n  if (geometry.primitiveType !== PrimitiveType.TRIANGLES) {\n    throw new DeveloperError(\"geometry.primitiveType must be PrimitiveType.TRIANGLES.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = geometry.indices;\n  const attributes = geometry.attributes;\n  const vertices = attributes.position.values;\n  const numVertices = attributes.position.values.length / 3;\n  const numIndices = indices.length;\n  const normalsPerVertex = new Array(numVertices);\n  const normalsPerTriangle = new Array(numIndices / 3);\n  const normalIndices = new Array(numIndices);\n  let i;\n  for (i = 0; i < numVertices; i++) {\n    normalsPerVertex[i] = {\n      indexOffset: 0,\n      count: 0,\n      currentCount: 0\n    };\n  }\n  let j = 0;\n  for (i = 0; i < numIndices; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n    const i03 = i0 * 3;\n    const i13 = i1 * 3;\n    const i23 = i2 * 3;\n    v0.x = vertices[i03];\n    v0.y = vertices[i03 + 1];\n    v0.z = vertices[i03 + 2];\n    v1.x = vertices[i13];\n    v1.y = vertices[i13 + 1];\n    v1.z = vertices[i13 + 2];\n    v2.x = vertices[i23];\n    v2.y = vertices[i23 + 1];\n    v2.z = vertices[i23 + 2];\n    normalsPerVertex[i0].count++;\n    normalsPerVertex[i1].count++;\n    normalsPerVertex[i2].count++;\n    Cartesian3.subtract(v1, v0, v1);\n    Cartesian3.subtract(v2, v0, v2);\n    normalsPerTriangle[j] = Cartesian3.cross(v1, v2, new Cartesian3());\n    j++;\n  }\n  let indexOffset = 0;\n  for (i = 0; i < numVertices; i++) {\n    normalsPerVertex[i].indexOffset += indexOffset;\n    indexOffset += normalsPerVertex[i].count;\n  }\n  j = 0;\n  let vertexNormalData;\n  for (i = 0; i < numIndices; i += 3) {\n    vertexNormalData = normalsPerVertex[indices[i]];\n    let index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n    normalIndices[index] = j;\n    vertexNormalData.currentCount++;\n    vertexNormalData = normalsPerVertex[indices[i + 1]];\n    index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n    normalIndices[index] = j;\n    vertexNormalData.currentCount++;\n    vertexNormalData = normalsPerVertex[indices[i + 2]];\n    index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n    normalIndices[index] = j;\n    vertexNormalData.currentCount++;\n    j++;\n  }\n  const normalValues = new Float32Array(numVertices * 3);\n  for (i = 0; i < numVertices; i++) {\n    const i3 = i * 3;\n    vertexNormalData = normalsPerVertex[i];\n    Cartesian3.clone(Cartesian3.ZERO, normal);\n    if (vertexNormalData.count > 0) {\n      for (j = 0; j < vertexNormalData.count; j++) {\n        Cartesian3.add(normal, normalsPerTriangle[normalIndices[vertexNormalData.indexOffset + j]], normal);\n      }\n\n      // We can run into an issue where a vertex is used with 2 primitives that have opposite winding order.\n      if (Cartesian3.equalsEpsilon(Cartesian3.ZERO, normal, CesiumMath.EPSILON10)) {\n        Cartesian3.clone(normalsPerTriangle[normalIndices[vertexNormalData.indexOffset]], normal);\n      }\n    }\n\n    // We end up with a zero vector probably because of a degenerate triangle\n    if (Cartesian3.equalsEpsilon(Cartesian3.ZERO, normal, CesiumMath.EPSILON10)) {\n      // Default to (0,0,1)\n      normal.z = 1.0;\n    }\n    Cartesian3.normalize(normal, normal);\n    normalValues[i3] = normal.x;\n    normalValues[i3 + 1] = normal.y;\n    normalValues[i3 + 2] = normal.z;\n  }\n  geometry.attributes.normal = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    values: normalValues\n  });\n  return geometry;\n};\nconst normalScratch = new Cartesian3();\nconst normalScale = new Cartesian3();\nconst tScratch = new Cartesian3();\n\n/**\n * Computes per-vertex tangents and bitangents for a geometry containing <code>TRIANGLES</code>.\n * The result is new <code>tangent</code> and <code>bitangent</code> attributes added to the geometry.\n * This assumes a counter-clockwise winding order.\n * <p>\n * Based on <a href=\"http://www.terathon.com/code/tangent.html\">Computing Tangent Space Basis Vectors\n * for an Arbitrary Mesh</a> by Eric Lengyel.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument with the computed <code>tangent</code> and <code>bitangent</code> attributes.\n *\n * @exception {DeveloperError} geometry.indices length must be greater than 0 and be a multiple of 3.\n * @exception {DeveloperError} geometry.primitiveType must be {@link PrimitiveType.TRIANGLES}.\n *\n * @example\n * Cesium.GeometryPipeline.computeTangentAndBiTangent(geometry);\n */\nGeometryPipeline.computeTangentAndBitangent = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const attributes = geometry.attributes;\n  const indices = geometry.indices;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(attributes.position) || !defined(attributes.position.values)) {\n    throw new DeveloperError(\"geometry.attributes.position.values is required.\");\n  }\n  if (!defined(attributes.normal) || !defined(attributes.normal.values)) {\n    throw new DeveloperError(\"geometry.attributes.normal.values is required.\");\n  }\n  if (!defined(attributes.st) || !defined(attributes.st.values)) {\n    throw new DeveloperError(\"geometry.attributes.st.values is required.\");\n  }\n  if (!defined(indices)) {\n    throw new DeveloperError(\"geometry.indices is required.\");\n  }\n  if (indices.length < 2 || indices.length % 3 !== 0) {\n    throw new DeveloperError(\"geometry.indices length must be greater than 0 and be a multiple of 3.\");\n  }\n  if (geometry.primitiveType !== PrimitiveType.TRIANGLES) {\n    throw new DeveloperError(\"geometry.primitiveType must be PrimitiveType.TRIANGLES.\");\n  }\n  //>>includeEnd('debug');\n\n  const vertices = geometry.attributes.position.values;\n  const normals = geometry.attributes.normal.values;\n  const st = geometry.attributes.st.values;\n  const numVertices = geometry.attributes.position.values.length / 3;\n  const numIndices = indices.length;\n  const tan1 = new Array(numVertices * 3);\n  let i;\n  for (i = 0; i < tan1.length; i++) {\n    tan1[i] = 0;\n  }\n  let i03;\n  let i13;\n  let i23;\n  for (i = 0; i < numIndices; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n    i03 = i0 * 3;\n    i13 = i1 * 3;\n    i23 = i2 * 3;\n    const i02 = i0 * 2;\n    const i12 = i1 * 2;\n    const i22 = i2 * 2;\n    const ux = vertices[i03];\n    const uy = vertices[i03 + 1];\n    const uz = vertices[i03 + 2];\n    const wx = st[i02];\n    const wy = st[i02 + 1];\n    const t1 = st[i12 + 1] - wy;\n    const t2 = st[i22 + 1] - wy;\n    const r = 1.0 / ((st[i12] - wx) * t2 - (st[i22] - wx) * t1);\n    const sdirx = (t2 * (vertices[i13] - ux) - t1 * (vertices[i23] - ux)) * r;\n    const sdiry = (t2 * (vertices[i13 + 1] - uy) - t1 * (vertices[i23 + 1] - uy)) * r;\n    const sdirz = (t2 * (vertices[i13 + 2] - uz) - t1 * (vertices[i23 + 2] - uz)) * r;\n    tan1[i03] += sdirx;\n    tan1[i03 + 1] += sdiry;\n    tan1[i03 + 2] += sdirz;\n    tan1[i13] += sdirx;\n    tan1[i13 + 1] += sdiry;\n    tan1[i13 + 2] += sdirz;\n    tan1[i23] += sdirx;\n    tan1[i23 + 1] += sdiry;\n    tan1[i23 + 2] += sdirz;\n  }\n  const tangentValues = new Float32Array(numVertices * 3);\n  const bitangentValues = new Float32Array(numVertices * 3);\n  for (i = 0; i < numVertices; i++) {\n    i03 = i * 3;\n    i13 = i03 + 1;\n    i23 = i03 + 2;\n    const n = Cartesian3.fromArray(normals, i03, normalScratch);\n    const t = Cartesian3.fromArray(tan1, i03, tScratch);\n    const scalar = Cartesian3.dot(n, t);\n    Cartesian3.multiplyByScalar(n, scalar, normalScale);\n    Cartesian3.normalize(Cartesian3.subtract(t, normalScale, t), t);\n    tangentValues[i03] = t.x;\n    tangentValues[i13] = t.y;\n    tangentValues[i23] = t.z;\n    Cartesian3.normalize(Cartesian3.cross(n, t, t), t);\n    bitangentValues[i03] = t.x;\n    bitangentValues[i13] = t.y;\n    bitangentValues[i23] = t.z;\n  }\n  geometry.attributes.tangent = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    values: tangentValues\n  });\n  geometry.attributes.bitangent = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    values: bitangentValues\n  });\n  return geometry;\n};\nconst scratchCartesian2 = new Cartesian2();\nconst toEncode1 = new Cartesian3();\nconst toEncode2 = new Cartesian3();\nconst toEncode3 = new Cartesian3();\nlet encodeResult2 = new Cartesian2();\n/**\n * Compresses and packs geometry normal attribute values to save memory.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its normals compressed and packed.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.compressVertices(geometry);\n */\nGeometryPipeline.compressVertices = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const extrudeAttribute = geometry.attributes.extrudeDirection;\n  let i;\n  let numVertices;\n  if (defined(extrudeAttribute)) {\n    //only shadow volumes use extrudeDirection, and shadow volumes use vertexFormat: POSITION_ONLY so we don't need to check other attributes\n    const extrudeDirections = extrudeAttribute.values;\n    numVertices = extrudeDirections.length / 3.0;\n    const compressedDirections = new Float32Array(numVertices * 2);\n    let i2 = 0;\n    for (i = 0; i < numVertices; ++i) {\n      Cartesian3.fromArray(extrudeDirections, i * 3.0, toEncode1);\n      if (Cartesian3.equals(toEncode1, Cartesian3.ZERO)) {\n        i2 += 2;\n        continue;\n      }\n      encodeResult2 = AttributeCompression.octEncodeInRange(toEncode1, 65535, encodeResult2);\n      compressedDirections[i2++] = encodeResult2.x;\n      compressedDirections[i2++] = encodeResult2.y;\n    }\n    geometry.attributes.compressedAttributes = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: compressedDirections\n    });\n    delete geometry.attributes.extrudeDirection;\n    return geometry;\n  }\n  const normalAttribute = geometry.attributes.normal;\n  const stAttribute = geometry.attributes.st;\n  const hasNormal = defined(normalAttribute);\n  const hasSt = defined(stAttribute);\n  if (!hasNormal && !hasSt) {\n    return geometry;\n  }\n  const tangentAttribute = geometry.attributes.tangent;\n  const bitangentAttribute = geometry.attributes.bitangent;\n  const hasTangent = defined(tangentAttribute);\n  const hasBitangent = defined(bitangentAttribute);\n  let normals;\n  let st;\n  let tangents;\n  let bitangents;\n  if (hasNormal) {\n    normals = normalAttribute.values;\n  }\n  if (hasSt) {\n    st = stAttribute.values;\n  }\n  if (hasTangent) {\n    tangents = tangentAttribute.values;\n  }\n  if (hasBitangent) {\n    bitangents = bitangentAttribute.values;\n  }\n  const length = hasNormal ? normals.length : st.length;\n  const numComponents = hasNormal ? 3.0 : 2.0;\n  numVertices = length / numComponents;\n  let compressedLength = numVertices;\n  let numCompressedComponents = hasSt && hasNormal ? 2.0 : 1.0;\n  numCompressedComponents += hasTangent || hasBitangent ? 1.0 : 0.0;\n  compressedLength *= numCompressedComponents;\n  const compressedAttributes = new Float32Array(compressedLength);\n  let normalIndex = 0;\n  for (i = 0; i < numVertices; ++i) {\n    if (hasSt) {\n      Cartesian2.fromArray(st, i * 2.0, scratchCartesian2);\n      compressedAttributes[normalIndex++] = AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n    }\n    const index = i * 3.0;\n    if (hasNormal && defined(tangents) && defined(bitangents)) {\n      Cartesian3.fromArray(normals, index, toEncode1);\n      Cartesian3.fromArray(tangents, index, toEncode2);\n      Cartesian3.fromArray(bitangents, index, toEncode3);\n      AttributeCompression.octPack(toEncode1, toEncode2, toEncode3, scratchCartesian2);\n      compressedAttributes[normalIndex++] = scratchCartesian2.x;\n      compressedAttributes[normalIndex++] = scratchCartesian2.y;\n    } else {\n      if (hasNormal) {\n        Cartesian3.fromArray(normals, index, toEncode1);\n        compressedAttributes[normalIndex++] = AttributeCompression.octEncodeFloat(toEncode1);\n      }\n      if (hasTangent) {\n        Cartesian3.fromArray(tangents, index, toEncode1);\n        compressedAttributes[normalIndex++] = AttributeCompression.octEncodeFloat(toEncode1);\n      }\n      if (hasBitangent) {\n        Cartesian3.fromArray(bitangents, index, toEncode1);\n        compressedAttributes[normalIndex++] = AttributeCompression.octEncodeFloat(toEncode1);\n      }\n    }\n  }\n  geometry.attributes.compressedAttributes = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: numCompressedComponents,\n    values: compressedAttributes\n  });\n  if (hasNormal) {\n    delete geometry.attributes.normal;\n  }\n  if (hasSt) {\n    delete geometry.attributes.st;\n  }\n  if (hasBitangent) {\n    delete geometry.attributes.bitangent;\n  }\n  if (hasTangent) {\n    delete geometry.attributes.tangent;\n  }\n  return geometry;\n};\nfunction indexTriangles(geometry) {\n  if (defined(geometry.indices)) {\n    return geometry;\n  }\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 3) {\n    throw new DeveloperError(\"The number of vertices must be at least three.\");\n  }\n  if (numberOfVertices % 3 !== 0) {\n    throw new DeveloperError(\"The number of vertices must be a multiple of three.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(numberOfVertices, numberOfVertices);\n  for (let i = 0; i < numberOfVertices; ++i) {\n    indices[i] = i;\n  }\n  geometry.indices = indices;\n  return geometry;\n}\nfunction indexTriangleFan(geometry) {\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 3) {\n    throw new DeveloperError(\"The number of vertices must be at least three.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(numberOfVertices, (numberOfVertices - 2) * 3);\n  indices[0] = 1;\n  indices[1] = 0;\n  indices[2] = 2;\n  let indicesIndex = 3;\n  for (let i = 3; i < numberOfVertices; ++i) {\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = 0;\n    indices[indicesIndex++] = i;\n  }\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.TRIANGLES;\n  return geometry;\n}\nfunction indexTriangleStrip(geometry) {\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 3) {\n    throw new DeveloperError(\"The number of vertices must be at least 3.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(numberOfVertices, (numberOfVertices - 2) * 3);\n  indices[0] = 0;\n  indices[1] = 1;\n  indices[2] = 2;\n  if (numberOfVertices > 3) {\n    indices[3] = 0;\n    indices[4] = 2;\n    indices[5] = 3;\n  }\n  let indicesIndex = 6;\n  for (let i = 3; i < numberOfVertices - 1; i += 2) {\n    indices[indicesIndex++] = i;\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = i + 1;\n    if (i + 2 < numberOfVertices) {\n      indices[indicesIndex++] = i;\n      indices[indicesIndex++] = i + 1;\n      indices[indicesIndex++] = i + 2;\n    }\n  }\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.TRIANGLES;\n  return geometry;\n}\nfunction indexLines(geometry) {\n  if (defined(geometry.indices)) {\n    return geometry;\n  }\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 2) {\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\n  }\n  if (numberOfVertices % 2 !== 0) {\n    throw new DeveloperError(\"The number of vertices must be a multiple of 2.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(numberOfVertices, numberOfVertices);\n  for (let i = 0; i < numberOfVertices; ++i) {\n    indices[i] = i;\n  }\n  geometry.indices = indices;\n  return geometry;\n}\nfunction indexLineStrip(geometry) {\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 2) {\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(numberOfVertices, (numberOfVertices - 1) * 2);\n  indices[0] = 0;\n  indices[1] = 1;\n  let indicesIndex = 2;\n  for (let i = 2; i < numberOfVertices; ++i) {\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = i;\n  }\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.LINES;\n  return geometry;\n}\nfunction indexLineLoop(geometry) {\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 2) {\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(numberOfVertices, numberOfVertices * 2);\n  indices[0] = 0;\n  indices[1] = 1;\n  let indicesIndex = 2;\n  for (let i = 2; i < numberOfVertices; ++i) {\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = i;\n  }\n  indices[indicesIndex++] = numberOfVertices - 1;\n  indices[indicesIndex] = 0;\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.LINES;\n  return geometry;\n}\nfunction indexPrimitive(geometry) {\n  switch (geometry.primitiveType) {\n    case PrimitiveType.TRIANGLE_FAN:\n      return indexTriangleFan(geometry);\n    case PrimitiveType.TRIANGLE_STRIP:\n      return indexTriangleStrip(geometry);\n    case PrimitiveType.TRIANGLES:\n      return indexTriangles(geometry);\n    case PrimitiveType.LINE_STRIP:\n      return indexLineStrip(geometry);\n    case PrimitiveType.LINE_LOOP:\n      return indexLineLoop(geometry);\n    case PrimitiveType.LINES:\n      return indexLines(geometry);\n  }\n  return geometry;\n}\nfunction offsetPointFromXZPlane(p, isBehind) {\n  if (Math.abs(p.y) < CesiumMath.EPSILON6) {\n    if (isBehind) {\n      p.y = -CesiumMath.EPSILON6;\n    } else {\n      p.y = CesiumMath.EPSILON6;\n    }\n  }\n}\nfunction offsetTriangleFromXZPlane(p0, p1, p2) {\n  if (p0.y !== 0.0 && p1.y !== 0.0 && p2.y !== 0.0) {\n    offsetPointFromXZPlane(p0, p0.y < 0.0);\n    offsetPointFromXZPlane(p1, p1.y < 0.0);\n    offsetPointFromXZPlane(p2, p2.y < 0.0);\n    return;\n  }\n  const p0y = Math.abs(p0.y);\n  const p1y = Math.abs(p1.y);\n  const p2y = Math.abs(p2.y);\n  let sign;\n  if (p0y > p1y) {\n    if (p0y > p2y) {\n      sign = CesiumMath.sign(p0.y);\n    } else {\n      sign = CesiumMath.sign(p2.y);\n    }\n  } else if (p1y > p2y) {\n    sign = CesiumMath.sign(p1.y);\n  } else {\n    sign = CesiumMath.sign(p2.y);\n  }\n  const isBehind = sign < 0.0;\n  offsetPointFromXZPlane(p0, isBehind);\n  offsetPointFromXZPlane(p1, isBehind);\n  offsetPointFromXZPlane(p2, isBehind);\n}\nconst c3 = new Cartesian3();\nfunction getXZIntersectionOffsetPoints(p, p1, u1, v1) {\n  Cartesian3.add(p, Cartesian3.multiplyByScalar(Cartesian3.subtract(p1, p, c3), p.y / (p.y - p1.y), c3), u1);\n  Cartesian3.clone(u1, v1);\n  offsetPointFromXZPlane(u1, true);\n  offsetPointFromXZPlane(v1, false);\n}\nconst u1 = new Cartesian3();\nconst u2 = new Cartesian3();\nconst q1 = new Cartesian3();\nconst q2 = new Cartesian3();\nconst splitTriangleResult = {\n  positions: new Array(7),\n  indices: new Array(3 * 3)\n};\nfunction splitTriangle(p0, p1, p2) {\n  // In ellipsoid coordinates, for a triangle approximately on the\n  // ellipsoid to cross the IDL, first it needs to be on the\n  // negative side of the plane x = 0.\n  if (p0.x >= 0.0 || p1.x >= 0.0 || p2.x >= 0.0) {\n    return undefined;\n  }\n  offsetTriangleFromXZPlane(p0, p1, p2);\n  const p0Behind = p0.y < 0.0;\n  const p1Behind = p1.y < 0.0;\n  const p2Behind = p2.y < 0.0;\n  let numBehind = 0;\n  numBehind += p0Behind ? 1 : 0;\n  numBehind += p1Behind ? 1 : 0;\n  numBehind += p2Behind ? 1 : 0;\n  const indices = splitTriangleResult.indices;\n  if (numBehind === 1) {\n    indices[1] = 3;\n    indices[2] = 4;\n    indices[5] = 6;\n    indices[7] = 6;\n    indices[8] = 5;\n    if (p0Behind) {\n      getXZIntersectionOffsetPoints(p0, p1, u1, q1);\n      getXZIntersectionOffsetPoints(p0, p2, u2, q2);\n      indices[0] = 0;\n      indices[3] = 1;\n      indices[4] = 2;\n      indices[6] = 1;\n    } else if (p1Behind) {\n      getXZIntersectionOffsetPoints(p1, p2, u1, q1);\n      getXZIntersectionOffsetPoints(p1, p0, u2, q2);\n      indices[0] = 1;\n      indices[3] = 2;\n      indices[4] = 0;\n      indices[6] = 2;\n    } else if (p2Behind) {\n      getXZIntersectionOffsetPoints(p2, p0, u1, q1);\n      getXZIntersectionOffsetPoints(p2, p1, u2, q2);\n      indices[0] = 2;\n      indices[3] = 0;\n      indices[4] = 1;\n      indices[6] = 0;\n    }\n  } else if (numBehind === 2) {\n    indices[2] = 4;\n    indices[4] = 4;\n    indices[5] = 3;\n    indices[7] = 5;\n    indices[8] = 6;\n    if (!p0Behind) {\n      getXZIntersectionOffsetPoints(p0, p1, u1, q1);\n      getXZIntersectionOffsetPoints(p0, p2, u2, q2);\n      indices[0] = 1;\n      indices[1] = 2;\n      indices[3] = 1;\n      indices[6] = 0;\n    } else if (!p1Behind) {\n      getXZIntersectionOffsetPoints(p1, p2, u1, q1);\n      getXZIntersectionOffsetPoints(p1, p0, u2, q2);\n      indices[0] = 2;\n      indices[1] = 0;\n      indices[3] = 2;\n      indices[6] = 1;\n    } else if (!p2Behind) {\n      getXZIntersectionOffsetPoints(p2, p0, u1, q1);\n      getXZIntersectionOffsetPoints(p2, p1, u2, q2);\n      indices[0] = 0;\n      indices[1] = 1;\n      indices[3] = 0;\n      indices[6] = 2;\n    }\n  }\n  const positions = splitTriangleResult.positions;\n  positions[0] = p0;\n  positions[1] = p1;\n  positions[2] = p2;\n  positions.length = 3;\n  if (numBehind === 1 || numBehind === 2) {\n    positions[3] = u1;\n    positions[4] = u2;\n    positions[5] = q1;\n    positions[6] = q2;\n    positions.length = 7;\n  }\n  return splitTriangleResult;\n}\nfunction updateGeometryAfterSplit(geometry, computeBoundingSphere) {\n  const attributes = geometry.attributes;\n  if (attributes.position.values.length === 0) {\n    return undefined;\n  }\n  for (const property in attributes) {\n    if (attributes.hasOwnProperty(property) && defined(attributes[property]) && defined(attributes[property].values)) {\n      const attribute = attributes[property];\n      attribute.values = ComponentDatatype.createTypedArray(attribute.componentDatatype, attribute.values);\n    }\n  }\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n  geometry.indices = IndexDatatype.createTypedArray(numberOfVertices, geometry.indices);\n  if (computeBoundingSphere) {\n    geometry.boundingSphere = BoundingSphere.fromVertices(attributes.position.values);\n  }\n  return geometry;\n}\nfunction copyGeometryForSplit(geometry) {\n  const attributes = geometry.attributes;\n  const copiedAttributes = {};\n  for (const property in attributes) {\n    if (attributes.hasOwnProperty(property) && defined(attributes[property]) && defined(attributes[property].values)) {\n      const attribute = attributes[property];\n      copiedAttributes[property] = new GeometryAttribute({\n        componentDatatype: attribute.componentDatatype,\n        componentsPerAttribute: attribute.componentsPerAttribute,\n        normalize: attribute.normalize,\n        values: []\n      });\n    }\n  }\n  return new Geometry({\n    attributes: copiedAttributes,\n    indices: [],\n    primitiveType: geometry.primitiveType\n  });\n}\nfunction updateInstanceAfterSplit(instance, westGeometry, eastGeometry) {\n  const computeBoundingSphere = defined(instance.geometry.boundingSphere);\n  westGeometry = updateGeometryAfterSplit(westGeometry, computeBoundingSphere);\n  eastGeometry = updateGeometryAfterSplit(eastGeometry, computeBoundingSphere);\n  if (defined(eastGeometry) && !defined(westGeometry)) {\n    instance.geometry = eastGeometry;\n  } else if (!defined(eastGeometry) && defined(westGeometry)) {\n    instance.geometry = westGeometry;\n  } else {\n    instance.westHemisphereGeometry = westGeometry;\n    instance.eastHemisphereGeometry = eastGeometry;\n    instance.geometry = undefined;\n  }\n}\nfunction generateBarycentricInterpolateFunction(CartesianType, numberOfComponents) {\n  const v0Scratch = new CartesianType();\n  const v1Scratch = new CartesianType();\n  const v2Scratch = new CartesianType();\n  return function (i0, i1, i2, coords, sourceValues, currentValues, insertedIndex, normalize) {\n    const v0 = CartesianType.fromArray(sourceValues, i0 * numberOfComponents, v0Scratch);\n    const v1 = CartesianType.fromArray(sourceValues, i1 * numberOfComponents, v1Scratch);\n    const v2 = CartesianType.fromArray(sourceValues, i2 * numberOfComponents, v2Scratch);\n    CartesianType.multiplyByScalar(v0, coords.x, v0);\n    CartesianType.multiplyByScalar(v1, coords.y, v1);\n    CartesianType.multiplyByScalar(v2, coords.z, v2);\n    const value = CartesianType.add(v0, v1, v0);\n    CartesianType.add(value, v2, value);\n    if (normalize) {\n      CartesianType.normalize(value, value);\n    }\n    CartesianType.pack(value, currentValues, insertedIndex * numberOfComponents);\n  };\n}\nconst interpolateAndPackCartesian4 = generateBarycentricInterpolateFunction(Cartesian4, 4);\nconst interpolateAndPackCartesian3 = generateBarycentricInterpolateFunction(Cartesian3, 3);\nconst interpolateAndPackCartesian2 = generateBarycentricInterpolateFunction(Cartesian2, 2);\nconst interpolateAndPackBoolean = function (i0, i1, i2, coords, sourceValues, currentValues, insertedIndex) {\n  const v1 = sourceValues[i0] * coords.x;\n  const v2 = sourceValues[i1] * coords.y;\n  const v3 = sourceValues[i2] * coords.z;\n  currentValues[insertedIndex] = v1 + v2 + v3 > CesiumMath.EPSILON6 ? 1 : 0;\n};\nconst p0Scratch = new Cartesian3();\nconst p1Scratch = new Cartesian3();\nconst p2Scratch = new Cartesian3();\nconst barycentricScratch = new Cartesian3();\nfunction computeTriangleAttributes(i0, i1, i2, point, positions, normals, tangents, bitangents, texCoords, extrudeDirections, applyOffset, currentAttributes, customAttributeNames, customAttributesLength, allAttributes, insertedIndex) {\n  if (!defined(normals) && !defined(tangents) && !defined(bitangents) && !defined(texCoords) && !defined(extrudeDirections) && customAttributesLength === 0) {\n    return;\n  }\n  const p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n  const p1 = Cartesian3.fromArray(positions, i1 * 3, p1Scratch);\n  const p2 = Cartesian3.fromArray(positions, i2 * 3, p2Scratch);\n  const coords = barycentricCoordinates(point, p0, p1, p2, barycentricScratch);\n  if (!defined(coords)) {\n    return;\n  }\n  if (defined(normals)) {\n    interpolateAndPackCartesian3(i0, i1, i2, coords, normals, currentAttributes.normal.values, insertedIndex, true);\n  }\n  if (defined(extrudeDirections)) {\n    const d0 = Cartesian3.fromArray(extrudeDirections, i0 * 3, p0Scratch);\n    const d1 = Cartesian3.fromArray(extrudeDirections, i1 * 3, p1Scratch);\n    const d2 = Cartesian3.fromArray(extrudeDirections, i2 * 3, p2Scratch);\n    Cartesian3.multiplyByScalar(d0, coords.x, d0);\n    Cartesian3.multiplyByScalar(d1, coords.y, d1);\n    Cartesian3.multiplyByScalar(d2, coords.z, d2);\n    let direction;\n    if (!Cartesian3.equals(d0, Cartesian3.ZERO) || !Cartesian3.equals(d1, Cartesian3.ZERO) || !Cartesian3.equals(d2, Cartesian3.ZERO)) {\n      direction = Cartesian3.add(d0, d1, d0);\n      Cartesian3.add(direction, d2, direction);\n      Cartesian3.normalize(direction, direction);\n    } else {\n      direction = p0Scratch;\n      direction.x = 0;\n      direction.y = 0;\n      direction.z = 0;\n    }\n    Cartesian3.pack(direction, currentAttributes.extrudeDirection.values, insertedIndex * 3);\n  }\n  if (defined(applyOffset)) {\n    interpolateAndPackBoolean(i0, i1, i2, coords, applyOffset, currentAttributes.applyOffset.values, insertedIndex);\n  }\n  if (defined(tangents)) {\n    interpolateAndPackCartesian3(i0, i1, i2, coords, tangents, currentAttributes.tangent.values, insertedIndex, true);\n  }\n  if (defined(bitangents)) {\n    interpolateAndPackCartesian3(i0, i1, i2, coords, bitangents, currentAttributes.bitangent.values, insertedIndex, true);\n  }\n  if (defined(texCoords)) {\n    interpolateAndPackCartesian2(i0, i1, i2, coords, texCoords, currentAttributes.st.values, insertedIndex);\n  }\n  if (customAttributesLength > 0) {\n    for (let i = 0; i < customAttributesLength; i++) {\n      const attributeName = customAttributeNames[i];\n      genericInterpolate(i0, i1, i2, coords, insertedIndex, allAttributes[attributeName], currentAttributes[attributeName]);\n    }\n  }\n}\nfunction genericInterpolate(i0, i1, i2, coords, insertedIndex, sourceAttribute, currentAttribute) {\n  const componentsPerAttribute = sourceAttribute.componentsPerAttribute;\n  const sourceValues = sourceAttribute.values;\n  const currentValues = currentAttribute.values;\n  switch (componentsPerAttribute) {\n    case 4:\n      interpolateAndPackCartesian4(i0, i1, i2, coords, sourceValues, currentValues, insertedIndex, false);\n      break;\n    case 3:\n      interpolateAndPackCartesian3(i0, i1, i2, coords, sourceValues, currentValues, insertedIndex, false);\n      break;\n    case 2:\n      interpolateAndPackCartesian2(i0, i1, i2, coords, sourceValues, currentValues, insertedIndex, false);\n      break;\n    default:\n      currentValues[insertedIndex] = sourceValues[i0] * coords.x + sourceValues[i1] * coords.y + sourceValues[i2] * coords.z;\n  }\n}\nfunction insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, currentIndex, point) {\n  const insertIndex = currentAttributes.position.values.length / 3;\n  if (currentIndex !== -1) {\n    const prevIndex = indices[currentIndex];\n    const newIndex = currentIndexMap[prevIndex];\n    if (newIndex === -1) {\n      currentIndexMap[prevIndex] = insertIndex;\n      currentAttributes.position.values.push(point.x, point.y, point.z);\n      currentIndices.push(insertIndex);\n      return insertIndex;\n    }\n    currentIndices.push(newIndex);\n    return newIndex;\n  }\n  currentAttributes.position.values.push(point.x, point.y, point.z);\n  currentIndices.push(insertIndex);\n  return insertIndex;\n}\nconst NAMED_ATTRIBUTES = {\n  position: true,\n  normal: true,\n  bitangent: true,\n  tangent: true,\n  st: true,\n  extrudeDirection: true,\n  applyOffset: true\n};\nfunction splitLongitudeTriangles(instance) {\n  const geometry = instance.geometry;\n  const attributes = geometry.attributes;\n  const positions = attributes.position.values;\n  const normals = defined(attributes.normal) ? attributes.normal.values : undefined;\n  const bitangents = defined(attributes.bitangent) ? attributes.bitangent.values : undefined;\n  const tangents = defined(attributes.tangent) ? attributes.tangent.values : undefined;\n  const texCoords = defined(attributes.st) ? attributes.st.values : undefined;\n  const extrudeDirections = defined(attributes.extrudeDirection) ? attributes.extrudeDirection.values : undefined;\n  const applyOffset = defined(attributes.applyOffset) ? attributes.applyOffset.values : undefined;\n  const indices = geometry.indices;\n  const customAttributeNames = [];\n  for (const attributeName in attributes) {\n    if (attributes.hasOwnProperty(attributeName) && !NAMED_ATTRIBUTES[attributeName] && defined(attributes[attributeName])) {\n      customAttributeNames.push(attributeName);\n    }\n  }\n  const customAttributesLength = customAttributeNames.length;\n  const eastGeometry = copyGeometryForSplit(geometry);\n  const westGeometry = copyGeometryForSplit(geometry);\n  let currentAttributes;\n  let currentIndices;\n  let currentIndexMap;\n  let insertedIndex;\n  let i;\n  const westGeometryIndexMap = [];\n  westGeometryIndexMap.length = positions.length / 3;\n  const eastGeometryIndexMap = [];\n  eastGeometryIndexMap.length = positions.length / 3;\n  for (i = 0; i < westGeometryIndexMap.length; ++i) {\n    westGeometryIndexMap[i] = -1;\n    eastGeometryIndexMap[i] = -1;\n  }\n  const len = indices.length;\n  for (i = 0; i < len; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n    let p0 = Cartesian3.fromArray(positions, i0 * 3);\n    let p1 = Cartesian3.fromArray(positions, i1 * 3);\n    let p2 = Cartesian3.fromArray(positions, i2 * 3);\n    const result = splitTriangle(p0, p1, p2);\n    if (defined(result) && result.positions.length > 3) {\n      const resultPositions = result.positions;\n      const resultIndices = result.indices;\n      const resultLength = resultIndices.length;\n      for (let j = 0; j < resultLength; ++j) {\n        const resultIndex = resultIndices[j];\n        const point = resultPositions[resultIndex];\n        if (point.y < 0.0) {\n          currentAttributes = westGeometry.attributes;\n          currentIndices = westGeometry.indices;\n          currentIndexMap = westGeometryIndexMap;\n        } else {\n          currentAttributes = eastGeometry.attributes;\n          currentIndices = eastGeometry.indices;\n          currentIndexMap = eastGeometryIndexMap;\n        }\n        insertedIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, resultIndex < 3 ? i + resultIndex : -1, point);\n        computeTriangleAttributes(i0, i1, i2, point, positions, normals, tangents, bitangents, texCoords, extrudeDirections, applyOffset, currentAttributes, customAttributeNames, customAttributesLength, attributes, insertedIndex);\n      }\n    } else {\n      if (defined(result)) {\n        p0 = result.positions[0];\n        p1 = result.positions[1];\n        p2 = result.positions[2];\n      }\n      if (p0.y < 0.0) {\n        currentAttributes = westGeometry.attributes;\n        currentIndices = westGeometry.indices;\n        currentIndexMap = westGeometryIndexMap;\n      } else {\n        currentAttributes = eastGeometry.attributes;\n        currentIndices = eastGeometry.indices;\n        currentIndexMap = eastGeometryIndexMap;\n      }\n      insertedIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i, p0);\n      computeTriangleAttributes(i0, i1, i2, p0, positions, normals, tangents, bitangents, texCoords, extrudeDirections, applyOffset, currentAttributes, customAttributeNames, customAttributesLength, attributes, insertedIndex);\n      insertedIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i + 1, p1);\n      computeTriangleAttributes(i0, i1, i2, p1, positions, normals, tangents, bitangents, texCoords, extrudeDirections, applyOffset, currentAttributes, customAttributeNames, customAttributesLength, attributes, insertedIndex);\n      insertedIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i + 2, p2);\n      computeTriangleAttributes(i0, i1, i2, p2, positions, normals, tangents, bitangents, texCoords, extrudeDirections, applyOffset, currentAttributes, customAttributeNames, customAttributesLength, attributes, insertedIndex);\n    }\n  }\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n}\nconst xzPlane = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\nconst offsetScratch = new Cartesian3();\nconst offsetPointScratch = new Cartesian3();\nfunction computeLineAttributes(i0, i1, point, positions, insertIndex, currentAttributes, applyOffset) {\n  if (!defined(applyOffset)) {\n    return;\n  }\n  const p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n  if (Cartesian3.equalsEpsilon(p0, point, CesiumMath.EPSILON10)) {\n    currentAttributes.applyOffset.values[insertIndex] = applyOffset[i0];\n  } else {\n    currentAttributes.applyOffset.values[insertIndex] = applyOffset[i1];\n  }\n}\nfunction splitLongitudeLines(instance) {\n  const geometry = instance.geometry;\n  const attributes = geometry.attributes;\n  const positions = attributes.position.values;\n  const applyOffset = defined(attributes.applyOffset) ? attributes.applyOffset.values : undefined;\n  const indices = geometry.indices;\n  const eastGeometry = copyGeometryForSplit(geometry);\n  const westGeometry = copyGeometryForSplit(geometry);\n  let i;\n  const length = indices.length;\n  const westGeometryIndexMap = [];\n  westGeometryIndexMap.length = positions.length / 3;\n  const eastGeometryIndexMap = [];\n  eastGeometryIndexMap.length = positions.length / 3;\n  for (i = 0; i < westGeometryIndexMap.length; ++i) {\n    westGeometryIndexMap[i] = -1;\n    eastGeometryIndexMap[i] = -1;\n  }\n  for (i = 0; i < length; i += 2) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n    const p1 = Cartesian3.fromArray(positions, i1 * 3, p1Scratch);\n    let insertIndex;\n    if (Math.abs(p0.y) < CesiumMath.EPSILON6) {\n      if (p0.y < 0.0) {\n        p0.y = -CesiumMath.EPSILON6;\n      } else {\n        p0.y = CesiumMath.EPSILON6;\n      }\n    }\n    if (Math.abs(p1.y) < CesiumMath.EPSILON6) {\n      if (p1.y < 0.0) {\n        p1.y = -CesiumMath.EPSILON6;\n      } else {\n        p1.y = CesiumMath.EPSILON6;\n      }\n    }\n    let p0Attributes = eastGeometry.attributes;\n    let p0Indices = eastGeometry.indices;\n    let p0IndexMap = eastGeometryIndexMap;\n    let p1Attributes = westGeometry.attributes;\n    let p1Indices = westGeometry.indices;\n    let p1IndexMap = westGeometryIndexMap;\n    const intersection = IntersectionTests.lineSegmentPlane(p0, p1, xzPlane, p2Scratch);\n    if (defined(intersection)) {\n      // move point on the xz-plane slightly away from the plane\n      const offset = Cartesian3.multiplyByScalar(Cartesian3.UNIT_Y, 5.0 * CesiumMath.EPSILON9, offsetScratch);\n      if (p0.y < 0.0) {\n        Cartesian3.negate(offset, offset);\n        p0Attributes = westGeometry.attributes;\n        p0Indices = westGeometry.indices;\n        p0IndexMap = westGeometryIndexMap;\n        p1Attributes = eastGeometry.attributes;\n        p1Indices = eastGeometry.indices;\n        p1IndexMap = eastGeometryIndexMap;\n      }\n      const offsetPoint = Cartesian3.add(intersection, offset, offsetPointScratch);\n      insertIndex = insertSplitPoint(p0Attributes, p0Indices, p0IndexMap, indices, i, p0);\n      computeLineAttributes(i0, i1, p0, positions, insertIndex, p0Attributes, applyOffset);\n      insertIndex = insertSplitPoint(p0Attributes, p0Indices, p0IndexMap, indices, -1, offsetPoint);\n      computeLineAttributes(i0, i1, offsetPoint, positions, insertIndex, p0Attributes, applyOffset);\n      Cartesian3.negate(offset, offset);\n      Cartesian3.add(intersection, offset, offsetPoint);\n      insertIndex = insertSplitPoint(p1Attributes, p1Indices, p1IndexMap, indices, -1, offsetPoint);\n      computeLineAttributes(i0, i1, offsetPoint, positions, insertIndex, p1Attributes, applyOffset);\n      insertIndex = insertSplitPoint(p1Attributes, p1Indices, p1IndexMap, indices, i + 1, p1);\n      computeLineAttributes(i0, i1, p1, positions, insertIndex, p1Attributes, applyOffset);\n    } else {\n      let currentAttributes;\n      let currentIndices;\n      let currentIndexMap;\n      if (p0.y < 0.0) {\n        currentAttributes = westGeometry.attributes;\n        currentIndices = westGeometry.indices;\n        currentIndexMap = westGeometryIndexMap;\n      } else {\n        currentAttributes = eastGeometry.attributes;\n        currentIndices = eastGeometry.indices;\n        currentIndexMap = eastGeometryIndexMap;\n      }\n      insertIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i, p0);\n      computeLineAttributes(i0, i1, p0, positions, insertIndex, currentAttributes, applyOffset);\n      insertIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i + 1, p1);\n      computeLineAttributes(i0, i1, p1, positions, insertIndex, currentAttributes, applyOffset);\n    }\n  }\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n}\nconst cartesian2Scratch0 = new Cartesian2();\nconst cartesian2Scratch1 = new Cartesian2();\nconst cartesian3Scratch0 = new Cartesian3();\nconst cartesian3Scratch2 = new Cartesian3();\nconst cartesian3Scratch3 = new Cartesian3();\nconst cartesian3Scratch4 = new Cartesian3();\nconst cartesian3Scratch5 = new Cartesian3();\nconst cartesian3Scratch6 = new Cartesian3();\nconst cartesian4Scratch0 = new Cartesian4();\nfunction updateAdjacencyAfterSplit(geometry) {\n  const attributes = geometry.attributes;\n  const positions = attributes.position.values;\n  const prevPositions = attributes.prevPosition.values;\n  const nextPositions = attributes.nextPosition.values;\n  const length = positions.length;\n  for (let j = 0; j < length; j += 3) {\n    const position = Cartesian3.unpack(positions, j, cartesian3Scratch0);\n    if (position.x > 0.0) {\n      continue;\n    }\n    const prevPosition = Cartesian3.unpack(prevPositions, j, cartesian3Scratch2);\n    if (position.y < 0.0 && prevPosition.y > 0.0 || position.y > 0.0 && prevPosition.y < 0.0) {\n      if (j - 3 > 0) {\n        prevPositions[j] = positions[j - 3];\n        prevPositions[j + 1] = positions[j - 2];\n        prevPositions[j + 2] = positions[j - 1];\n      } else {\n        Cartesian3.pack(position, prevPositions, j);\n      }\n    }\n    const nextPosition = Cartesian3.unpack(nextPositions, j, cartesian3Scratch3);\n    if (position.y < 0.0 && nextPosition.y > 0.0 || position.y > 0.0 && nextPosition.y < 0.0) {\n      if (j + 3 < length) {\n        nextPositions[j] = positions[j + 3];\n        nextPositions[j + 1] = positions[j + 4];\n        nextPositions[j + 2] = positions[j + 5];\n      } else {\n        Cartesian3.pack(position, nextPositions, j);\n      }\n    }\n  }\n}\nconst offsetScalar = 5.0 * CesiumMath.EPSILON9;\nconst coplanarOffset = CesiumMath.EPSILON6;\nfunction splitLongitudePolyline(instance) {\n  const geometry = instance.geometry;\n  const attributes = geometry.attributes;\n  const positions = attributes.position.values;\n  const prevPositions = attributes.prevPosition.values;\n  const nextPositions = attributes.nextPosition.values;\n  const expandAndWidths = attributes.expandAndWidth.values;\n  const texCoords = defined(attributes.st) ? attributes.st.values : undefined;\n  const colors = defined(attributes.color) ? attributes.color.values : undefined;\n  const eastGeometry = copyGeometryForSplit(geometry);\n  const westGeometry = copyGeometryForSplit(geometry);\n  let i;\n  let j;\n  let index;\n  let intersectionFound = false;\n  const length = positions.length / 3;\n  for (i = 0; i < length; i += 4) {\n    const i0 = i;\n    const i2 = i + 2;\n    const p0 = Cartesian3.fromArray(positions, i0 * 3, cartesian3Scratch0);\n    const p2 = Cartesian3.fromArray(positions, i2 * 3, cartesian3Scratch2);\n\n    // Offset points that are close to the 180 longitude and change the previous/next point\n    // to be the same offset point so it can be projected to 2D. There is special handling in the\n    // shader for when position == prevPosition || position == nextPosition.\n    if (Math.abs(p0.y) < coplanarOffset) {\n      p0.y = coplanarOffset * (p2.y < 0.0 ? -1.0 : 1.0);\n      positions[i * 3 + 1] = p0.y;\n      positions[(i + 1) * 3 + 1] = p0.y;\n      for (j = i0 * 3; j < i0 * 3 + 4 * 3; j += 3) {\n        prevPositions[j] = positions[i * 3];\n        prevPositions[j + 1] = positions[i * 3 + 1];\n        prevPositions[j + 2] = positions[i * 3 + 2];\n      }\n    }\n\n    // Do the same but for when the line crosses 180 longitude in the opposite direction.\n    if (Math.abs(p2.y) < coplanarOffset) {\n      p2.y = coplanarOffset * (p0.y < 0.0 ? -1.0 : 1.0);\n      positions[(i + 2) * 3 + 1] = p2.y;\n      positions[(i + 3) * 3 + 1] = p2.y;\n      for (j = i0 * 3; j < i0 * 3 + 4 * 3; j += 3) {\n        nextPositions[j] = positions[(i + 2) * 3];\n        nextPositions[j + 1] = positions[(i + 2) * 3 + 1];\n        nextPositions[j + 2] = positions[(i + 2) * 3 + 2];\n      }\n    }\n    let p0Attributes = eastGeometry.attributes;\n    let p0Indices = eastGeometry.indices;\n    let p2Attributes = westGeometry.attributes;\n    let p2Indices = westGeometry.indices;\n    const intersection = IntersectionTests.lineSegmentPlane(p0, p2, xzPlane, cartesian3Scratch4);\n    if (defined(intersection)) {\n      intersectionFound = true;\n\n      // move point on the xz-plane slightly away from the plane\n      const offset = Cartesian3.multiplyByScalar(Cartesian3.UNIT_Y, offsetScalar, cartesian3Scratch5);\n      if (p0.y < 0.0) {\n        Cartesian3.negate(offset, offset);\n        p0Attributes = westGeometry.attributes;\n        p0Indices = westGeometry.indices;\n        p2Attributes = eastGeometry.attributes;\n        p2Indices = eastGeometry.indices;\n      }\n      const offsetPoint = Cartesian3.add(intersection, offset, cartesian3Scratch6);\n      p0Attributes.position.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);\n      p0Attributes.position.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      p0Attributes.position.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      p0Attributes.prevPosition.values.push(prevPositions[i0 * 3], prevPositions[i0 * 3 + 1], prevPositions[i0 * 3 + 2]);\n      p0Attributes.prevPosition.values.push(prevPositions[i0 * 3 + 3], prevPositions[i0 * 3 + 4], prevPositions[i0 * 3 + 5]);\n      p0Attributes.prevPosition.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);\n      p0Attributes.nextPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      p0Attributes.nextPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      p0Attributes.nextPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      p0Attributes.nextPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      Cartesian3.negate(offset, offset);\n      Cartesian3.add(intersection, offset, offsetPoint);\n      p2Attributes.position.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      p2Attributes.position.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      p2Attributes.position.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);\n      p2Attributes.prevPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      p2Attributes.prevPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      p2Attributes.prevPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      p2Attributes.prevPosition.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n      p2Attributes.nextPosition.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);\n      p2Attributes.nextPosition.values.push(nextPositions[i2 * 3], nextPositions[i2 * 3 + 1], nextPositions[i2 * 3 + 2]);\n      p2Attributes.nextPosition.values.push(nextPositions[i2 * 3 + 3], nextPositions[i2 * 3 + 4], nextPositions[i2 * 3 + 5]);\n      const ew0 = Cartesian2.fromArray(expandAndWidths, i0 * 2, cartesian2Scratch0);\n      const width = Math.abs(ew0.y);\n      p0Attributes.expandAndWidth.values.push(-1, width, 1, width);\n      p0Attributes.expandAndWidth.values.push(-1, -width, 1, -width);\n      p2Attributes.expandAndWidth.values.push(-1, width, 1, width);\n      p2Attributes.expandAndWidth.values.push(-1, -width, 1, -width);\n      let t = Cartesian3.magnitudeSquared(Cartesian3.subtract(intersection, p0, cartesian3Scratch3));\n      t /= Cartesian3.magnitudeSquared(Cartesian3.subtract(p2, p0, cartesian3Scratch3));\n      if (defined(colors)) {\n        const c0 = Cartesian4.fromArray(colors, i0 * 4, cartesian4Scratch0);\n        const c2 = Cartesian4.fromArray(colors, i2 * 4, cartesian4Scratch0);\n        const r = CesiumMath.lerp(c0.x, c2.x, t);\n        const g = CesiumMath.lerp(c0.y, c2.y, t);\n        const b = CesiumMath.lerp(c0.z, c2.z, t);\n        const a = CesiumMath.lerp(c0.w, c2.w, t);\n        for (j = i0 * 4; j < i0 * 4 + 2 * 4; ++j) {\n          p0Attributes.color.values.push(colors[j]);\n        }\n        p0Attributes.color.values.push(r, g, b, a);\n        p0Attributes.color.values.push(r, g, b, a);\n        p2Attributes.color.values.push(r, g, b, a);\n        p2Attributes.color.values.push(r, g, b, a);\n        for (j = i2 * 4; j < i2 * 4 + 2 * 4; ++j) {\n          p2Attributes.color.values.push(colors[j]);\n        }\n      }\n      if (defined(texCoords)) {\n        const s0 = Cartesian2.fromArray(texCoords, i0 * 2, cartesian2Scratch0);\n        const s3 = Cartesian2.fromArray(texCoords, (i + 3) * 2, cartesian2Scratch1);\n        const sx = CesiumMath.lerp(s0.x, s3.x, t);\n        for (j = i0 * 2; j < i0 * 2 + 2 * 2; ++j) {\n          p0Attributes.st.values.push(texCoords[j]);\n        }\n        p0Attributes.st.values.push(sx, s0.y);\n        p0Attributes.st.values.push(sx, s3.y);\n        p2Attributes.st.values.push(sx, s0.y);\n        p2Attributes.st.values.push(sx, s3.y);\n        for (j = i2 * 2; j < i2 * 2 + 2 * 2; ++j) {\n          p2Attributes.st.values.push(texCoords[j]);\n        }\n      }\n      index = p0Attributes.position.values.length / 3 - 4;\n      p0Indices.push(index, index + 2, index + 1);\n      p0Indices.push(index + 1, index + 2, index + 3);\n      index = p2Attributes.position.values.length / 3 - 4;\n      p2Indices.push(index, index + 2, index + 1);\n      p2Indices.push(index + 1, index + 2, index + 3);\n    } else {\n      let currentAttributes;\n      let currentIndices;\n      if (p0.y < 0.0) {\n        currentAttributes = westGeometry.attributes;\n        currentIndices = westGeometry.indices;\n      } else {\n        currentAttributes = eastGeometry.attributes;\n        currentIndices = eastGeometry.indices;\n      }\n      currentAttributes.position.values.push(p0.x, p0.y, p0.z);\n      currentAttributes.position.values.push(p0.x, p0.y, p0.z);\n      currentAttributes.position.values.push(p2.x, p2.y, p2.z);\n      currentAttributes.position.values.push(p2.x, p2.y, p2.z);\n      for (j = i * 3; j < i * 3 + 4 * 3; ++j) {\n        currentAttributes.prevPosition.values.push(prevPositions[j]);\n        currentAttributes.nextPosition.values.push(nextPositions[j]);\n      }\n      for (j = i * 2; j < i * 2 + 4 * 2; ++j) {\n        currentAttributes.expandAndWidth.values.push(expandAndWidths[j]);\n        if (defined(texCoords)) {\n          currentAttributes.st.values.push(texCoords[j]);\n        }\n      }\n      if (defined(colors)) {\n        for (j = i * 4; j < i * 4 + 4 * 4; ++j) {\n          currentAttributes.color.values.push(colors[j]);\n        }\n      }\n      index = currentAttributes.position.values.length / 3 - 4;\n      currentIndices.push(index, index + 2, index + 1);\n      currentIndices.push(index + 1, index + 2, index + 3);\n    }\n  }\n  if (intersectionFound) {\n    updateAdjacencyAfterSplit(westGeometry);\n    updateAdjacencyAfterSplit(eastGeometry);\n  }\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n}\n\n/**\n * Splits the instances's geometry, by introducing new vertices and indices,that\n * intersect the International Date Line and Prime Meridian so that no primitives cross longitude\n * -180/180 degrees.  This is not required for 3D drawing, but is required for\n * correcting drawing in 2D and Columbus view.\n *\n * @private\n *\n * @param {GeometryInstance} instance The instance to modify.\n * @returns {GeometryInstance} The modified <code>instance</code> argument, with it's geometry split at the International Date Line.\n *\n * @example\n * instance = Cesium.GeometryPipeline.splitLongitude(instance);\n */\nGeometryPipeline.splitLongitude = function (instance) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(instance)) {\n    throw new DeveloperError(\"instance is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const geometry = instance.geometry;\n  const boundingSphere = geometry.boundingSphere;\n  if (defined(boundingSphere)) {\n    const minX = boundingSphere.center.x - boundingSphere.radius;\n    if (minX > 0 || BoundingSphere.intersectPlane(boundingSphere, Plane.ORIGIN_ZX_PLANE) !== Intersect.INTERSECTING) {\n      return instance;\n    }\n  }\n  if (geometry.geometryType !== GeometryType.NONE) {\n    switch (geometry.geometryType) {\n      case GeometryType.POLYLINES:\n        splitLongitudePolyline(instance);\n        break;\n      case GeometryType.TRIANGLES:\n        splitLongitudeTriangles(instance);\n        break;\n      case GeometryType.LINES:\n        splitLongitudeLines(instance);\n        break;\n    }\n  } else {\n    indexPrimitive(geometry);\n    if (geometry.primitiveType === PrimitiveType.TRIANGLES) {\n      splitLongitudeTriangles(instance);\n    } else if (geometry.primitiveType === PrimitiveType.LINES) {\n      splitLongitudeLines(instance);\n    }\n  }\n  return instance;\n};\nexport default GeometryPipeline;","map":{"version":3,"names":["AttributeCompression","barycentricCoordinates","BoundingSphere","Cartesian2","Cartesian3","Cartesian4","Cartographic","ComponentDatatype","defined","DeveloperError","EncodedCartesian3","GeographicProjection","Geometry","GeometryAttribute","GeometryType","IndexDatatype","Intersect","IntersectionTests","CesiumMath","Matrix3","Matrix4","Plane","PrimitiveType","Tipsify","GeometryPipeline","addTriangle","lines","index","i0","i1","i2","trianglesToLines","triangles","count","length","size","createTypedArray","i","triangleStripToLines","Uint16Array","triangleFanToLines","base","toWireframe","geometry","indices","primitiveType","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","LINES","createLineSegmentsForVectors","attributeName","attributes","position","positions","values","vectors","positionsLength","newPositions","Float64Array","j","newBoundingSphere","bs","boundingSphere","center","radius","componentDatatype","DOUBLE","componentsPerAttribute","createAttributeLocations","semantics","len","semantic","name","hasOwnProperty","reorderForPreVertexCache","numVertices","computeNumberOfVertices","indexCrossReferenceOldToNew","Int32Array","indicesIn","numIndices","indicesOut","intoIndicesIn","intoIndicesOut","nextIndex","tempIndex","property","attribute","elementsIn","intoElementsIn","numComponents","elementsOut","temp","reorderForPostVertexCache","cacheCapacity","maximumIndex","tipsify","cacheSize","copyAttributesDescriptions","newAttributes","attr","normalize","copyVertex","destinationAttributes","sourceAttributes","k","push","fitToUnsignedShortIndices","POINTS","geometries","numberOfVertices","SIXTY_FOUR_KILOBYTES","oldToNewIndex","newIndices","currentIndex","originalIndices","numberOfIndices","indicesPerPrimitive","x","boundingSphereCV","scratchProjectTo2DCartesian3","scratchProjectTo2DCartographic","projectTo2D","attributeName3D","attributeName2D","projection","ellipsoid","values3D","projectedValues","value","fromArray","lonLat","cartesianToCartographic","y","z","projectedLonLat","project","encodedResult","high","low","encodeAttribute","attributeHighName","attributeLowName","highValues","Float32Array","lowValues","encode","FLOAT","scratchCartesian3","transformPoint","matrix","unpack","multiplyByPoint","pack","transformVector","multiplyByVector","inverseTranspose","normalMatrix","transformToWorldCoordinates","instance","modelMatrix","equals","IDENTITY","prevPosition","nextPosition","normal","tangent","bitangent","inverse","transpose","getMatrix3","transform","clone","findAttributesInAllGeometries","instances","propertyName","attributesInAllGeometries","attributes0","numberOfComponents","inAllGeometries","otherAttribute","tempScratch","combineGeometries","m","haveIndices","sourceValues","sourceValuesLength","destIndices","destOffset","offset","sourceIndices","sourceIndicesLen","undefined","add","divideByScalar","tempRadius","magnitude","subtract","combineInstances","instanceGeometry","instanceSplitGeometry","westHemisphereGeometry","eastHemisphereGeometry","v0","v1","v2","computeNormal","vertices","normalsPerVertex","Array","normalsPerTriangle","normalIndices","indexOffset","currentCount","i03","i13","i23","cross","vertexNormalData","normalValues","i3","ZERO","equalsEpsilon","EPSILON10","normalScratch","normalScale","tScratch","computeTangentAndBitangent","st","normals","tan1","i02","i12","i22","ux","uy","uz","wx","wy","t1","t2","r","sdirx","sdiry","sdirz","tangentValues","bitangentValues","n","t","scalar","dot","multiplyByScalar","scratchCartesian2","toEncode1","toEncode2","toEncode3","encodeResult2","compressVertices","extrudeAttribute","extrudeDirection","extrudeDirections","compressedDirections","octEncodeInRange","compressedAttributes","normalAttribute","stAttribute","hasNormal","hasSt","tangentAttribute","bitangentAttribute","hasTangent","hasBitangent","tangents","bitangents","compressedLength","numCompressedComponents","normalIndex","compressTextureCoordinates","octPack","octEncodeFloat","indexTriangles","indexTriangleFan","indicesIndex","indexTriangleStrip","indexLines","indexLineStrip","indexLineLoop","indexPrimitive","LINE_STRIP","LINE_LOOP","offsetPointFromXZPlane","p","isBehind","Math","abs","EPSILON6","offsetTriangleFromXZPlane","p0","p1","p2","p0y","p1y","p2y","sign","c3","getXZIntersectionOffsetPoints","u1","u2","q1","q2","splitTriangleResult","splitTriangle","p0Behind","p1Behind","p2Behind","numBehind","updateGeometryAfterSplit","computeBoundingSphere","fromVertices","copyGeometryForSplit","copiedAttributes","updateInstanceAfterSplit","westGeometry","eastGeometry","generateBarycentricInterpolateFunction","CartesianType","v0Scratch","v1Scratch","v2Scratch","coords","currentValues","insertedIndex","interpolateAndPackCartesian4","interpolateAndPackCartesian3","interpolateAndPackCartesian2","interpolateAndPackBoolean","v3","p0Scratch","p1Scratch","p2Scratch","barycentricScratch","computeTriangleAttributes","point","texCoords","applyOffset","currentAttributes","customAttributeNames","customAttributesLength","allAttributes","d0","d1","d2","direction","genericInterpolate","sourceAttribute","currentAttribute","insertSplitPoint","currentIndices","currentIndexMap","insertIndex","prevIndex","newIndex","NAMED_ATTRIBUTES","splitLongitudeTriangles","westGeometryIndexMap","eastGeometryIndexMap","result","resultPositions","resultIndices","resultLength","resultIndex","xzPlane","fromPointNormal","UNIT_Y","offsetScratch","offsetPointScratch","computeLineAttributes","splitLongitudeLines","p0Attributes","p0Indices","p0IndexMap","p1Attributes","p1Indices","p1IndexMap","intersection","lineSegmentPlane","EPSILON9","negate","offsetPoint","cartesian2Scratch0","cartesian2Scratch1","cartesian3Scratch0","cartesian3Scratch2","cartesian3Scratch3","cartesian3Scratch4","cartesian3Scratch5","cartesian3Scratch6","cartesian4Scratch0","updateAdjacencyAfterSplit","prevPositions","nextPositions","offsetScalar","coplanarOffset","splitLongitudePolyline","expandAndWidths","expandAndWidth","colors","color","intersectionFound","p2Attributes","p2Indices","ew0","width","magnitudeSquared","c0","c2","lerp","g","b","a","w","s0","s3","sx","splitLongitude","minX","intersectPlane","ORIGIN_ZX_PLANE","INTERSECTING","geometryType","NONE","POLYLINES"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/GeometryPipeline.js"],"sourcesContent":["import AttributeCompression from \"./AttributeCompression.js\";\nimport barycentricCoordinates from \"./barycentricCoordinates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EncodedCartesian3 from \"./EncodedCartesian3.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryType from \"./GeometryType.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport Intersect from \"./Intersect.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Tipsify from \"./Tipsify.js\";\n\n/**\n * Content pipeline functions for geometries.\n *\n * @namespace GeometryPipeline\n *\n * @see Geometry\n */\nconst GeometryPipeline = {};\n\nfunction addTriangle(lines, index, i0, i1, i2) {\n  lines[index++] = i0;\n  lines[index++] = i1;\n\n  lines[index++] = i1;\n  lines[index++] = i2;\n\n  lines[index++] = i2;\n  lines[index] = i0;\n}\n\nfunction trianglesToLines(triangles) {\n  const count = triangles.length;\n  const size = (count / 3) * 6;\n  const lines = IndexDatatype.createTypedArray(count, size);\n\n  let index = 0;\n  for (let i = 0; i < count; i += 3, index += 6) {\n    addTriangle(lines, index, triangles[i], triangles[i + 1], triangles[i + 2]);\n  }\n\n  return lines;\n}\n\nfunction triangleStripToLines(triangles) {\n  const count = triangles.length;\n  if (count >= 3) {\n    const size = (count - 2) * 6;\n    const lines = IndexDatatype.createTypedArray(count, size);\n\n    addTriangle(lines, 0, triangles[0], triangles[1], triangles[2]);\n    let index = 6;\n\n    for (let i = 3; i < count; ++i, index += 6) {\n      addTriangle(\n        lines,\n        index,\n        triangles[i - 1],\n        triangles[i],\n        triangles[i - 2],\n      );\n    }\n\n    return lines;\n  }\n\n  return new Uint16Array();\n}\n\nfunction triangleFanToLines(triangles) {\n  if (triangles.length > 0) {\n    const count = triangles.length - 1;\n    const size = (count - 1) * 6;\n    const lines = IndexDatatype.createTypedArray(count, size);\n\n    const base = triangles[0];\n    let index = 0;\n    for (let i = 1; i < count; ++i, index += 6) {\n      addTriangle(lines, index, base, triangles[i], triangles[i + 1]);\n    }\n\n    return lines;\n  }\n\n  return new Uint16Array();\n}\n\n/**\n * Converts a geometry's triangle indices to line indices.  If the geometry has an <code>indices</code>\n * and its <code>primitiveType</code> is <code>TRIANGLES</code>, <code>TRIANGLE_STRIP</code>,\n * <code>TRIANGLE_FAN</code>, it is converted to <code>LINES</code>; otherwise, the geometry is not changed.\n * <p>\n * This is commonly used to create a wireframe geometry for visual debugging.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its triangle indices converted to lines.\n *\n * @exception {DeveloperError} geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.toWireframe(geometry);\n */\nGeometryPipeline.toWireframe = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = geometry.indices;\n  if (defined(indices)) {\n    switch (geometry.primitiveType) {\n      case PrimitiveType.TRIANGLES:\n        geometry.indices = trianglesToLines(indices);\n        break;\n      case PrimitiveType.TRIANGLE_STRIP:\n        geometry.indices = triangleStripToLines(indices);\n        break;\n      case PrimitiveType.TRIANGLE_FAN:\n        geometry.indices = triangleFanToLines(indices);\n        break;\n      //>>includeStart('debug', pragmas.debug);\n      default:\n        throw new DeveloperError(\n          \"geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.\",\n        );\n      //>>includeEnd('debug');\n    }\n\n    geometry.primitiveType = PrimitiveType.LINES;\n  }\n\n  return geometry;\n};\n\n/**\n * Creates a new {@link Geometry} with <code>LINES</code> representing the provided\n * attribute (<code>attributeName</code>) for the provided geometry.  This is used to\n * visualize vector attributes like normals, tangents, and bitangents.\n *\n * @param {Geometry} geometry The <code>Geometry</code> instance with the attribute.\n * @param {string} [attributeName='normal'] The name of the attribute.\n * @param {number} [length=10000.0] The length of each line segment in meters.  This can be negative to point the vector in the opposite direction.\n * @returns {Geometry} A new <code>Geometry</code> instance with line segments for the vector.\n *\n * @exception {DeveloperError} geometry.attributes must have an attribute with the same name as the attributeName parameter.\n *\n * @example\n * const geometry = Cesium.GeometryPipeline.createLineSegmentsForVectors(instance.geometry, 'bitangent', 100000.0);\n */\nGeometryPipeline.createLineSegmentsForVectors = function (\n  geometry,\n  attributeName,\n  length,\n) {\n  attributeName = attributeName ?? \"normal\";\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (!defined(geometry.attributes.position)) {\n    throw new DeveloperError(\"geometry.attributes.position is required.\");\n  }\n  if (!defined(geometry.attributes[attributeName])) {\n    throw new DeveloperError(\n      `geometry.attributes must have an attribute with the same name as the attributeName parameter, ${attributeName}.`,\n    );\n  }\n  //>>includeEnd('debug');\n\n  length = length ?? 10000.0;\n\n  const positions = geometry.attributes.position.values;\n  const vectors = geometry.attributes[attributeName].values;\n  const positionsLength = positions.length;\n\n  const newPositions = new Float64Array(2 * positionsLength);\n\n  let j = 0;\n  for (let i = 0; i < positionsLength; i += 3) {\n    newPositions[j++] = positions[i];\n    newPositions[j++] = positions[i + 1];\n    newPositions[j++] = positions[i + 2];\n\n    newPositions[j++] = positions[i] + vectors[i] * length;\n    newPositions[j++] = positions[i + 1] + vectors[i + 1] * length;\n    newPositions[j++] = positions[i + 2] + vectors[i + 2] * length;\n  }\n\n  let newBoundingSphere;\n  const bs = geometry.boundingSphere;\n  if (defined(bs)) {\n    newBoundingSphere = new BoundingSphere(bs.center, bs.radius + length);\n  }\n\n  return new Geometry({\n    attributes: {\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: newPositions,\n      }),\n    },\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: newBoundingSphere,\n  });\n};\n\n/**\n * Creates an object that maps attribute names to unique locations (indices)\n * for matching vertex attributes and shader programs.\n *\n * @param {Geometry} geometry The geometry, which is not modified, to create the object for.\n * @returns {object} An object with attribute name / index pairs.\n *\n * @example\n * const attributeLocations = Cesium.GeometryPipeline.createAttributeLocations(geometry);\n * // Example output\n * // {\n * //   'position' : 0,\n * //   'normal' : 1\n * // }\n */\nGeometryPipeline.createAttributeLocations = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // There can be a WebGL performance hit when attribute 0 is disabled, so\n  // assign attribute locations to well-known attributes.\n  const semantics = [\n    \"position\",\n    \"positionHigh\",\n    \"positionLow\",\n\n    // From VertexFormat.position - after 2D projection and high-precision encoding\n    \"position3DHigh\",\n    \"position3DLow\",\n    \"position2DHigh\",\n    \"position2DLow\",\n\n    // From Primitive\n    \"pickColor\",\n\n    // From VertexFormat\n    \"normal\",\n    \"st\",\n    \"tangent\",\n    \"bitangent\",\n\n    // For shadow volumes\n    \"extrudeDirection\",\n\n    // From compressing texture coordinates and normals\n    \"compressedAttributes\",\n  ];\n\n  const attributes = geometry.attributes;\n  const indices = {};\n  let j = 0;\n  let i;\n  const len = semantics.length;\n\n  // Attribute locations for well-known attributes\n  for (i = 0; i < len; ++i) {\n    const semantic = semantics[i];\n\n    if (defined(attributes[semantic])) {\n      indices[semantic] = j++;\n    }\n  }\n\n  // Locations for custom attributes\n  for (const name in attributes) {\n    if (attributes.hasOwnProperty(name) && !defined(indices[name])) {\n      indices[name] = j++;\n    }\n  }\n\n  return indices;\n};\n\n/**\n * Reorders a geometry's attributes and <code>indices</code> to achieve better performance from the GPU's pre-vertex-shader cache.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its attributes and indices reordered for the GPU's pre-vertex-shader cache.\n *\n * @exception {DeveloperError} Each attribute array in geometry.attributes must have the same number of attributes.\n *\n *\n * @example\n * geometry = Cesium.GeometryPipeline.reorderForPreVertexCache(geometry);\n *\n * @see GeometryPipeline.reorderForPostVertexCache\n */\nGeometryPipeline.reorderForPreVertexCache = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const numVertices = Geometry.computeNumberOfVertices(geometry);\n\n  const indices = geometry.indices;\n  if (defined(indices)) {\n    const indexCrossReferenceOldToNew = new Int32Array(numVertices);\n    for (let i = 0; i < numVertices; i++) {\n      indexCrossReferenceOldToNew[i] = -1;\n    }\n\n    // Construct cross reference and reorder indices\n    const indicesIn = indices;\n    const numIndices = indicesIn.length;\n    const indicesOut = IndexDatatype.createTypedArray(numVertices, numIndices);\n\n    let intoIndicesIn = 0;\n    let intoIndicesOut = 0;\n    let nextIndex = 0;\n    let tempIndex;\n    while (intoIndicesIn < numIndices) {\n      tempIndex = indexCrossReferenceOldToNew[indicesIn[intoIndicesIn]];\n      if (tempIndex !== -1) {\n        indicesOut[intoIndicesOut] = tempIndex;\n      } else {\n        tempIndex = indicesIn[intoIndicesIn];\n        indexCrossReferenceOldToNew[tempIndex] = nextIndex;\n\n        indicesOut[intoIndicesOut] = nextIndex;\n        ++nextIndex;\n      }\n      ++intoIndicesIn;\n      ++intoIndicesOut;\n    }\n    geometry.indices = indicesOut;\n\n    // Reorder attributes\n    const attributes = geometry.attributes;\n    for (const property in attributes) {\n      if (\n        attributes.hasOwnProperty(property) &&\n        defined(attributes[property]) &&\n        defined(attributes[property].values)\n      ) {\n        const attribute = attributes[property];\n        const elementsIn = attribute.values;\n        let intoElementsIn = 0;\n        const numComponents = attribute.componentsPerAttribute;\n        const elementsOut = ComponentDatatype.createTypedArray(\n          attribute.componentDatatype,\n          nextIndex * numComponents,\n        );\n        while (intoElementsIn < numVertices) {\n          const temp = indexCrossReferenceOldToNew[intoElementsIn];\n          if (temp !== -1) {\n            for (let j = 0; j < numComponents; j++) {\n              elementsOut[numComponents * temp + j] =\n                elementsIn[numComponents * intoElementsIn + j];\n            }\n          }\n          ++intoElementsIn;\n        }\n        attribute.values = elementsOut;\n      }\n    }\n  }\n\n  return geometry;\n};\n\n/**\n * Reorders a geometry's <code>indices</code> to achieve better performance from the GPU's\n * post vertex-shader cache by using the Tipsify algorithm.  If the geometry <code>primitiveType</code>\n * is not <code>TRIANGLES</code> or the geometry does not have an <code>indices</code>, this function has no effect.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @param {number} [cacheCapacity=24] The number of vertices that can be held in the GPU's vertex cache.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its indices reordered for the post-vertex-shader cache.\n *\n * @exception {DeveloperError} cacheCapacity must be greater than two.\n *\n *\n * @example\n * geometry = Cesium.GeometryPipeline.reorderForPostVertexCache(geometry);\n *\n * @see GeometryPipeline.reorderForPreVertexCache\n * @see {@link http://gfx.cs.princ0eton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf|Fast Triangle Reordering for Vertex Locality and Reduced Overdraw}\n * by Sander, Nehab, and Barczak\n */\nGeometryPipeline.reorderForPostVertexCache = function (\n  geometry,\n  cacheCapacity,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = geometry.indices;\n  if (geometry.primitiveType === PrimitiveType.TRIANGLES && defined(indices)) {\n    const numIndices = indices.length;\n    let maximumIndex = 0;\n    for (let j = 0; j < numIndices; j++) {\n      if (indices[j] > maximumIndex) {\n        maximumIndex = indices[j];\n      }\n    }\n    geometry.indices = Tipsify.tipsify({\n      indices: indices,\n      maximumIndex: maximumIndex,\n      cacheSize: cacheCapacity,\n    });\n  }\n\n  return geometry;\n};\n\nfunction copyAttributesDescriptions(attributes) {\n  const newAttributes = {};\n\n  for (const attribute in attributes) {\n    if (\n      attributes.hasOwnProperty(attribute) &&\n      defined(attributes[attribute]) &&\n      defined(attributes[attribute].values)\n    ) {\n      const attr = attributes[attribute];\n      newAttributes[attribute] = new GeometryAttribute({\n        componentDatatype: attr.componentDatatype,\n        componentsPerAttribute: attr.componentsPerAttribute,\n        normalize: attr.normalize,\n        values: [],\n      });\n    }\n  }\n\n  return newAttributes;\n}\n\nfunction copyVertex(destinationAttributes, sourceAttributes, index) {\n  for (const attribute in sourceAttributes) {\n    if (\n      sourceAttributes.hasOwnProperty(attribute) &&\n      defined(sourceAttributes[attribute]) &&\n      defined(sourceAttributes[attribute].values)\n    ) {\n      const attr = sourceAttributes[attribute];\n\n      for (let k = 0; k < attr.componentsPerAttribute; ++k) {\n        destinationAttributes[attribute].values.push(\n          attr.values[index * attr.componentsPerAttribute + k],\n        );\n      }\n    }\n  }\n}\n\n/**\n * Splits a geometry into multiple geometries, if necessary, to ensure that indices in the\n * <code>indices</code> fit into unsigned shorts.  This is used to meet the WebGL requirements\n * when unsigned int indices are not supported.\n * <p>\n * If the geometry does not have any <code>indices</code>, this function has no effect.\n * </p>\n *\n * @param {Geometry} geometry The geometry to be split into multiple geometries.\n * @returns {Geometry[]} An array of geometries, each with indices that fit into unsigned shorts.\n *\n * @exception {DeveloperError} geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS\n * @exception {DeveloperError} All geometry attribute lists must have the same number of attributes.\n *\n * @example\n * const geometries = Cesium.GeometryPipeline.fitToUnsignedShortIndices(geometry);\n */\nGeometryPipeline.fitToUnsignedShortIndices = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (\n    defined(geometry.indices) &&\n    geometry.primitiveType !== PrimitiveType.TRIANGLES &&\n    geometry.primitiveType !== PrimitiveType.LINES &&\n    geometry.primitiveType !== PrimitiveType.POINTS\n  ) {\n    throw new DeveloperError(\n      \"geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const geometries = [];\n\n  // If there's an index list and more than 64K attributes, it is possible that\n  // some indices are outside the range of unsigned short [0, 64K - 1]\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n  if (\n    defined(geometry.indices) &&\n    numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES\n  ) {\n    let oldToNewIndex = [];\n    let newIndices = [];\n    let currentIndex = 0;\n    let newAttributes = copyAttributesDescriptions(geometry.attributes);\n\n    const originalIndices = geometry.indices;\n    const numberOfIndices = originalIndices.length;\n\n    let indicesPerPrimitive;\n\n    if (geometry.primitiveType === PrimitiveType.TRIANGLES) {\n      indicesPerPrimitive = 3;\n    } else if (geometry.primitiveType === PrimitiveType.LINES) {\n      indicesPerPrimitive = 2;\n    } else if (geometry.primitiveType === PrimitiveType.POINTS) {\n      indicesPerPrimitive = 1;\n    }\n\n    for (let j = 0; j < numberOfIndices; j += indicesPerPrimitive) {\n      for (let k = 0; k < indicesPerPrimitive; ++k) {\n        const x = originalIndices[j + k];\n        let i = oldToNewIndex[x];\n        if (!defined(i)) {\n          i = currentIndex++;\n          oldToNewIndex[x] = i;\n          copyVertex(newAttributes, geometry.attributes, x);\n        }\n        newIndices.push(i);\n      }\n\n      if (\n        currentIndex + indicesPerPrimitive >=\n        CesiumMath.SIXTY_FOUR_KILOBYTES\n      ) {\n        geometries.push(\n          new Geometry({\n            attributes: newAttributes,\n            indices: newIndices,\n            primitiveType: geometry.primitiveType,\n            boundingSphere: geometry.boundingSphere,\n            boundingSphereCV: geometry.boundingSphereCV,\n          }),\n        );\n\n        // Reset for next vertex-array\n        oldToNewIndex = [];\n        newIndices = [];\n        currentIndex = 0;\n        newAttributes = copyAttributesDescriptions(geometry.attributes);\n      }\n    }\n\n    if (newIndices.length !== 0) {\n      geometries.push(\n        new Geometry({\n          attributes: newAttributes,\n          indices: newIndices,\n          primitiveType: geometry.primitiveType,\n          boundingSphere: geometry.boundingSphere,\n          boundingSphereCV: geometry.boundingSphereCV,\n        }),\n      );\n    }\n  } else {\n    // No need to split into multiple geometries\n    geometries.push(geometry);\n  }\n\n  return geometries;\n};\n\nconst scratchProjectTo2DCartesian3 = new Cartesian3();\nconst scratchProjectTo2DCartographic = new Cartographic();\n\n/**\n * Projects a geometry's 3D <code>position</code> attribute to 2D, replacing the <code>position</code>\n * attribute with separate <code>position3D</code> and <code>position2D</code> attributes.\n * <p>\n * If the geometry does not have a <code>position</code>, this function has no effect.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @param {string} attributeName The name of the attribute.\n * @param {string} attributeName3D The name of the attribute in 3D.\n * @param {string} attributeName2D The name of the attribute in 2D.\n * @param {object} [projection=new GeographicProjection()] The projection to use.\n * @returns {Geometry} The modified <code>geometry</code> argument with <code>position3D</code> and <code>position2D</code> attributes.\n *\n * @exception {DeveloperError} geometry must have attribute matching the attributeName argument.\n * @exception {DeveloperError} The attribute componentDatatype must be ComponentDatatype.DOUBLE.\n * @exception {DeveloperError} Could not project a point to 2D.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.projectTo2D(geometry, 'position', 'position3D', 'position2D');\n */\nGeometryPipeline.projectTo2D = function (\n  geometry,\n  attributeName,\n  attributeName3D,\n  attributeName2D,\n  projection,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (!defined(attributeName)) {\n    throw new DeveloperError(\"attributeName is required.\");\n  }\n  if (!defined(attributeName3D)) {\n    throw new DeveloperError(\"attributeName3D is required.\");\n  }\n  if (!defined(attributeName2D)) {\n    throw new DeveloperError(\"attributeName2D is required.\");\n  }\n  if (!defined(geometry.attributes[attributeName])) {\n    throw new DeveloperError(\n      `geometry must have attribute matching the attributeName argument: ${attributeName}.`,\n    );\n  }\n  if (\n    geometry.attributes[attributeName].componentDatatype !==\n    ComponentDatatype.DOUBLE\n  ) {\n    throw new DeveloperError(\n      \"The attribute componentDatatype must be ComponentDatatype.DOUBLE.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const attribute = geometry.attributes[attributeName];\n  projection = defined(projection) ? projection : new GeographicProjection();\n  const ellipsoid = projection.ellipsoid;\n\n  // Project original values to 2D.\n  const values3D = attribute.values;\n  const projectedValues = new Float64Array(values3D.length);\n  let index = 0;\n\n  for (let i = 0; i < values3D.length; i += 3) {\n    const value = Cartesian3.fromArray(\n      values3D,\n      i,\n      scratchProjectTo2DCartesian3,\n    );\n\n    const lonLat = ellipsoid.cartesianToCartographic(\n      value,\n      scratchProjectTo2DCartographic,\n    );\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(lonLat)) {\n      throw new DeveloperError(\n        `Could not project point (${value.x}, ${value.y}, ${value.z}) to 2D.`,\n      );\n    }\n    //>>includeEnd('debug');\n\n    const projectedLonLat = projection.project(\n      lonLat,\n      scratchProjectTo2DCartesian3,\n    );\n\n    projectedValues[index++] = projectedLonLat.x;\n    projectedValues[index++] = projectedLonLat.y;\n    projectedValues[index++] = projectedLonLat.z;\n  }\n\n  // Rename original cartesians to ellipsoid cartesians.\n  geometry.attributes[attributeName3D] = attribute;\n\n  // Replace original cartesians with 2D projected cartesians\n  geometry.attributes[attributeName2D] = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: projectedValues,\n  });\n  delete geometry.attributes[attributeName];\n\n  return geometry;\n};\n\nconst encodedResult = {\n  high: 0.0,\n  low: 0.0,\n};\n\n/**\n * Encodes floating-point geometry attribute values as two separate attributes to improve\n * rendering precision.\n * <p>\n * This is commonly used to create high-precision position vertex attributes.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @param {string} attributeName The name of the attribute.\n * @param {string} attributeHighName The name of the attribute for the encoded high bits.\n * @param {string} attributeLowName The name of the attribute for the encoded low bits.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its encoded attribute.\n *\n * @exception {DeveloperError} geometry must have attribute matching the attributeName argument.\n * @exception {DeveloperError} The attribute componentDatatype must be ComponentDatatype.DOUBLE.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.encodeAttribute(geometry, 'position3D', 'position3DHigh', 'position3DLow');\n */\nGeometryPipeline.encodeAttribute = function (\n  geometry,\n  attributeName,\n  attributeHighName,\n  attributeLowName,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (!defined(attributeName)) {\n    throw new DeveloperError(\"attributeName is required.\");\n  }\n  if (!defined(attributeHighName)) {\n    throw new DeveloperError(\"attributeHighName is required.\");\n  }\n  if (!defined(attributeLowName)) {\n    throw new DeveloperError(\"attributeLowName is required.\");\n  }\n  if (!defined(geometry.attributes[attributeName])) {\n    throw new DeveloperError(\n      `geometry must have attribute matching the attributeName argument: ${attributeName}.`,\n    );\n  }\n  if (\n    geometry.attributes[attributeName].componentDatatype !==\n    ComponentDatatype.DOUBLE\n  ) {\n    throw new DeveloperError(\n      \"The attribute componentDatatype must be ComponentDatatype.DOUBLE.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const attribute = geometry.attributes[attributeName];\n  const values = attribute.values;\n  const length = values.length;\n  const highValues = new Float32Array(length);\n  const lowValues = new Float32Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    EncodedCartesian3.encode(values[i], encodedResult);\n    highValues[i] = encodedResult.high;\n    lowValues[i] = encodedResult.low;\n  }\n\n  const componentsPerAttribute = attribute.componentsPerAttribute;\n\n  geometry.attributes[attributeHighName] = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: componentsPerAttribute,\n    values: highValues,\n  });\n  geometry.attributes[attributeLowName] = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: componentsPerAttribute,\n    values: lowValues,\n  });\n  delete geometry.attributes[attributeName];\n\n  return geometry;\n};\n\nlet scratchCartesian3 = new Cartesian3();\n\nfunction transformPoint(matrix, attribute) {\n  if (defined(attribute)) {\n    const values = attribute.values;\n    const length = values.length;\n    for (let i = 0; i < length; i += 3) {\n      Cartesian3.unpack(values, i, scratchCartesian3);\n      Matrix4.multiplyByPoint(matrix, scratchCartesian3, scratchCartesian3);\n      Cartesian3.pack(scratchCartesian3, values, i);\n    }\n  }\n}\n\nfunction transformVector(matrix, attribute) {\n  if (defined(attribute)) {\n    const values = attribute.values;\n    const length = values.length;\n    for (let i = 0; i < length; i += 3) {\n      Cartesian3.unpack(values, i, scratchCartesian3);\n      Matrix3.multiplyByVector(matrix, scratchCartesian3, scratchCartesian3);\n      scratchCartesian3 = Cartesian3.normalize(\n        scratchCartesian3,\n        scratchCartesian3,\n      );\n      Cartesian3.pack(scratchCartesian3, values, i);\n    }\n  }\n}\n\nconst inverseTranspose = new Matrix4();\nconst normalMatrix = new Matrix3();\n\n/**\n * Transforms a geometry instance to world coordinates.  This changes\n * the instance's <code>modelMatrix</code> to {@link Matrix4.IDENTITY} and transforms the\n * following attributes if they are present: <code>position</code>, <code>normal</code>,\n * <code>tangent</code>, and <code>bitangent</code>.\n *\n * @param {GeometryInstance} instance The geometry instance to modify.\n * @returns {GeometryInstance} The modified <code>instance</code> argument, with its attributes transforms to world coordinates.\n *\n * @example\n * Cesium.GeometryPipeline.transformToWorldCoordinates(instance);\n */\nGeometryPipeline.transformToWorldCoordinates = function (instance) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(instance)) {\n    throw new DeveloperError(\"instance is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const modelMatrix = instance.modelMatrix;\n\n  if (Matrix4.equals(modelMatrix, Matrix4.IDENTITY)) {\n    // Already in world coordinates\n    return instance;\n  }\n\n  const attributes = instance.geometry.attributes;\n\n  // Transform attributes in known vertex formats\n  transformPoint(modelMatrix, attributes.position);\n  transformPoint(modelMatrix, attributes.prevPosition);\n  transformPoint(modelMatrix, attributes.nextPosition);\n\n  if (\n    defined(attributes.normal) ||\n    defined(attributes.tangent) ||\n    defined(attributes.bitangent)\n  ) {\n    Matrix4.inverse(modelMatrix, inverseTranspose);\n    Matrix4.transpose(inverseTranspose, inverseTranspose);\n    Matrix4.getMatrix3(inverseTranspose, normalMatrix);\n\n    transformVector(normalMatrix, attributes.normal);\n    transformVector(normalMatrix, attributes.tangent);\n    transformVector(normalMatrix, attributes.bitangent);\n  }\n\n  const boundingSphere = instance.geometry.boundingSphere;\n  if (defined(boundingSphere)) {\n    instance.geometry.boundingSphere = BoundingSphere.transform(\n      boundingSphere,\n      modelMatrix,\n      boundingSphere,\n    );\n  }\n\n  instance.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n  return instance;\n};\n\nfunction findAttributesInAllGeometries(instances, propertyName) {\n  const length = instances.length;\n\n  const attributesInAllGeometries = {};\n\n  const attributes0 = instances[0][propertyName].attributes;\n  let name;\n\n  for (name in attributes0) {\n    if (\n      attributes0.hasOwnProperty(name) &&\n      defined(attributes0[name]) &&\n      defined(attributes0[name].values)\n    ) {\n      const attribute = attributes0[name];\n      let numberOfComponents = attribute.values.length;\n      let inAllGeometries = true;\n\n      // Does this same attribute exist in all geometries?\n      for (let i = 1; i < length; ++i) {\n        const otherAttribute = instances[i][propertyName].attributes[name];\n\n        if (\n          !defined(otherAttribute) ||\n          attribute.componentDatatype !== otherAttribute.componentDatatype ||\n          attribute.componentsPerAttribute !==\n            otherAttribute.componentsPerAttribute ||\n          attribute.normalize !== otherAttribute.normalize\n        ) {\n          inAllGeometries = false;\n          break;\n        }\n\n        numberOfComponents += otherAttribute.values.length;\n      }\n\n      if (inAllGeometries) {\n        attributesInAllGeometries[name] = new GeometryAttribute({\n          componentDatatype: attribute.componentDatatype,\n          componentsPerAttribute: attribute.componentsPerAttribute,\n          normalize: attribute.normalize,\n          values: ComponentDatatype.createTypedArray(\n            attribute.componentDatatype,\n            numberOfComponents,\n          ),\n        });\n      }\n    }\n  }\n\n  return attributesInAllGeometries;\n}\n\nconst tempScratch = new Cartesian3();\n\nfunction combineGeometries(instances, propertyName) {\n  const length = instances.length;\n\n  let name;\n  let i;\n  let j;\n  let k;\n\n  const m = instances[0].modelMatrix;\n  const haveIndices = defined(instances[0][propertyName].indices);\n  const primitiveType = instances[0][propertyName].primitiveType;\n\n  //>>includeStart('debug', pragmas.debug);\n  for (i = 1; i < length; ++i) {\n    if (!Matrix4.equals(instances[i].modelMatrix, m)) {\n      throw new DeveloperError(\"All instances must have the same modelMatrix.\");\n    }\n    if (defined(instances[i][propertyName].indices) !== haveIndices) {\n      throw new DeveloperError(\n        \"All instance geometries must have an indices or not have one.\",\n      );\n    }\n    if (instances[i][propertyName].primitiveType !== primitiveType) {\n      throw new DeveloperError(\n        \"All instance geometries must have the same primitiveType.\",\n      );\n    }\n  }\n  //>>includeEnd('debug');\n\n  // Find subset of attributes in all geometries\n  const attributes = findAttributesInAllGeometries(instances, propertyName);\n  let values;\n  let sourceValues;\n  let sourceValuesLength;\n\n  // Combine attributes from each geometry into a single typed array\n  for (name in attributes) {\n    if (attributes.hasOwnProperty(name)) {\n      values = attributes[name].values;\n\n      k = 0;\n      for (i = 0; i < length; ++i) {\n        sourceValues = instances[i][propertyName].attributes[name].values;\n        sourceValuesLength = sourceValues.length;\n\n        for (j = 0; j < sourceValuesLength; ++j) {\n          values[k++] = sourceValues[j];\n        }\n      }\n    }\n  }\n\n  // Combine index lists\n  let indices;\n\n  if (haveIndices) {\n    let numberOfIndices = 0;\n    for (i = 0; i < length; ++i) {\n      numberOfIndices += instances[i][propertyName].indices.length;\n    }\n\n    const numberOfVertices = Geometry.computeNumberOfVertices(\n      new Geometry({\n        attributes: attributes,\n        primitiveType: PrimitiveType.POINTS,\n      }),\n    );\n    const destIndices = IndexDatatype.createTypedArray(\n      numberOfVertices,\n      numberOfIndices,\n    );\n\n    let destOffset = 0;\n    let offset = 0;\n\n    for (i = 0; i < length; ++i) {\n      const sourceIndices = instances[i][propertyName].indices;\n      const sourceIndicesLen = sourceIndices.length;\n\n      for (k = 0; k < sourceIndicesLen; ++k) {\n        destIndices[destOffset++] = offset + sourceIndices[k];\n      }\n\n      offset += Geometry.computeNumberOfVertices(instances[i][propertyName]);\n    }\n\n    indices = destIndices;\n  }\n\n  // Create bounding sphere that includes all instances\n  let center = new Cartesian3();\n  let radius = 0.0;\n  let bs;\n\n  for (i = 0; i < length; ++i) {\n    bs = instances[i][propertyName].boundingSphere;\n    if (!defined(bs)) {\n      // If any geometries have an undefined bounding sphere, then so does the combined geometry\n      center = undefined;\n      break;\n    }\n\n    Cartesian3.add(bs.center, center, center);\n  }\n\n  if (defined(center)) {\n    Cartesian3.divideByScalar(center, length, center);\n\n    for (i = 0; i < length; ++i) {\n      bs = instances[i][propertyName].boundingSphere;\n      const tempRadius =\n        Cartesian3.magnitude(\n          Cartesian3.subtract(bs.center, center, tempScratch),\n        ) + bs.radius;\n\n      if (tempRadius > radius) {\n        radius = tempRadius;\n      }\n    }\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: primitiveType,\n    boundingSphere: defined(center)\n      ? new BoundingSphere(center, radius)\n      : undefined,\n  });\n}\n\n/**\n * Combines geometry from several {@link GeometryInstance} objects into one geometry.\n * This concatenates the attributes, concatenates and adjusts the indices, and creates\n * a bounding sphere encompassing all instances.\n * <p>\n * If the instances do not have the same attributes, a subset of attributes common\n * to all instances is used, and the others are ignored.\n * </p>\n * <p>\n * This is used by {@link Primitive} to efficiently render a large amount of static data.\n * </p>\n *\n * @private\n *\n * @param {GeometryInstance[]} [instances] The array of {@link GeometryInstance} objects whose geometry will be combined.\n * @returns {Geometry} A single geometry created from the provided geometry instances.\n *\n * @exception {DeveloperError} All instances must have the same modelMatrix.\n * @exception {DeveloperError} All instance geometries must have an indices or not have one.\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n *\n *\n * @example\n * for (let i = 0; i < instances.length; ++i) {\n *   Cesium.GeometryPipeline.transformToWorldCoordinates(instances[i]);\n * }\n * const geometries = Cesium.GeometryPipeline.combineInstances(instances);\n *\n * @see GeometryPipeline.transformToWorldCoordinates\n */\nGeometryPipeline.combineInstances = function (instances) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(instances) || instances.length < 1) {\n    throw new DeveloperError(\n      \"instances is required and must have length greater than zero.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const instanceGeometry = [];\n  const instanceSplitGeometry = [];\n  const length = instances.length;\n  for (let i = 0; i < length; ++i) {\n    const instance = instances[i];\n\n    if (defined(instance.geometry)) {\n      instanceGeometry.push(instance);\n    } else if (\n      defined(instance.westHemisphereGeometry) &&\n      defined(instance.eastHemisphereGeometry)\n    ) {\n      instanceSplitGeometry.push(instance);\n    }\n  }\n\n  const geometries = [];\n  if (instanceGeometry.length > 0) {\n    geometries.push(combineGeometries(instanceGeometry, \"geometry\"));\n  }\n\n  if (instanceSplitGeometry.length > 0) {\n    geometries.push(\n      combineGeometries(instanceSplitGeometry, \"westHemisphereGeometry\"),\n    );\n    geometries.push(\n      combineGeometries(instanceSplitGeometry, \"eastHemisphereGeometry\"),\n    );\n  }\n\n  return geometries;\n};\n\nconst normal = new Cartesian3();\nconst v0 = new Cartesian3();\nconst v1 = new Cartesian3();\nconst v2 = new Cartesian3();\n\n/**\n * Computes per-vertex normals for a geometry containing <code>TRIANGLES</code> by averaging the normals of\n * all triangles incident to the vertex.  The result is a new <code>normal</code> attribute added to the geometry.\n * This assumes a counter-clockwise winding order.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument with the computed <code>normal</code> attribute.\n *\n * @exception {DeveloperError} geometry.indices length must be greater than 0 and be a multiple of 3.\n * @exception {DeveloperError} geometry.primitiveType must be {@link PrimitiveType.TRIANGLES}.\n *\n * @example\n * Cesium.GeometryPipeline.computeNormal(geometry);\n */\nGeometryPipeline.computeNormal = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (\n    !defined(geometry.attributes.position) ||\n    !defined(geometry.attributes.position.values)\n  ) {\n    throw new DeveloperError(\n      \"geometry.attributes.position.values is required.\",\n    );\n  }\n  if (!defined(geometry.indices)) {\n    throw new DeveloperError(\"geometry.indices is required.\");\n  }\n  if (geometry.indices.length < 2 || geometry.indices.length % 3 !== 0) {\n    throw new DeveloperError(\n      \"geometry.indices length must be greater than 0 and be a multiple of 3.\",\n    );\n  }\n  if (geometry.primitiveType !== PrimitiveType.TRIANGLES) {\n    throw new DeveloperError(\n      \"geometry.primitiveType must be PrimitiveType.TRIANGLES.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const indices = geometry.indices;\n  const attributes = geometry.attributes;\n  const vertices = attributes.position.values;\n  const numVertices = attributes.position.values.length / 3;\n  const numIndices = indices.length;\n  const normalsPerVertex = new Array(numVertices);\n  const normalsPerTriangle = new Array(numIndices / 3);\n  const normalIndices = new Array(numIndices);\n  let i;\n  for (i = 0; i < numVertices; i++) {\n    normalsPerVertex[i] = {\n      indexOffset: 0,\n      count: 0,\n      currentCount: 0,\n    };\n  }\n\n  let j = 0;\n  for (i = 0; i < numIndices; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n    const i03 = i0 * 3;\n    const i13 = i1 * 3;\n    const i23 = i2 * 3;\n\n    v0.x = vertices[i03];\n    v0.y = vertices[i03 + 1];\n    v0.z = vertices[i03 + 2];\n    v1.x = vertices[i13];\n    v1.y = vertices[i13 + 1];\n    v1.z = vertices[i13 + 2];\n    v2.x = vertices[i23];\n    v2.y = vertices[i23 + 1];\n    v2.z = vertices[i23 + 2];\n\n    normalsPerVertex[i0].count++;\n    normalsPerVertex[i1].count++;\n    normalsPerVertex[i2].count++;\n\n    Cartesian3.subtract(v1, v0, v1);\n    Cartesian3.subtract(v2, v0, v2);\n    normalsPerTriangle[j] = Cartesian3.cross(v1, v2, new Cartesian3());\n    j++;\n  }\n\n  let indexOffset = 0;\n  for (i = 0; i < numVertices; i++) {\n    normalsPerVertex[i].indexOffset += indexOffset;\n    indexOffset += normalsPerVertex[i].count;\n  }\n\n  j = 0;\n  let vertexNormalData;\n  for (i = 0; i < numIndices; i += 3) {\n    vertexNormalData = normalsPerVertex[indices[i]];\n    let index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n    normalIndices[index] = j;\n    vertexNormalData.currentCount++;\n\n    vertexNormalData = normalsPerVertex[indices[i + 1]];\n    index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n    normalIndices[index] = j;\n    vertexNormalData.currentCount++;\n\n    vertexNormalData = normalsPerVertex[indices[i + 2]];\n    index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n    normalIndices[index] = j;\n    vertexNormalData.currentCount++;\n\n    j++;\n  }\n\n  const normalValues = new Float32Array(numVertices * 3);\n  for (i = 0; i < numVertices; i++) {\n    const i3 = i * 3;\n    vertexNormalData = normalsPerVertex[i];\n    Cartesian3.clone(Cartesian3.ZERO, normal);\n    if (vertexNormalData.count > 0) {\n      for (j = 0; j < vertexNormalData.count; j++) {\n        Cartesian3.add(\n          normal,\n          normalsPerTriangle[normalIndices[vertexNormalData.indexOffset + j]],\n          normal,\n        );\n      }\n\n      // We can run into an issue where a vertex is used with 2 primitives that have opposite winding order.\n      if (\n        Cartesian3.equalsEpsilon(Cartesian3.ZERO, normal, CesiumMath.EPSILON10)\n      ) {\n        Cartesian3.clone(\n          normalsPerTriangle[normalIndices[vertexNormalData.indexOffset]],\n          normal,\n        );\n      }\n    }\n\n    // We end up with a zero vector probably because of a degenerate triangle\n    if (\n      Cartesian3.equalsEpsilon(Cartesian3.ZERO, normal, CesiumMath.EPSILON10)\n    ) {\n      // Default to (0,0,1)\n      normal.z = 1.0;\n    }\n\n    Cartesian3.normalize(normal, normal);\n    normalValues[i3] = normal.x;\n    normalValues[i3 + 1] = normal.y;\n    normalValues[i3 + 2] = normal.z;\n  }\n\n  geometry.attributes.normal = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    values: normalValues,\n  });\n\n  return geometry;\n};\n\nconst normalScratch = new Cartesian3();\nconst normalScale = new Cartesian3();\nconst tScratch = new Cartesian3();\n\n/**\n * Computes per-vertex tangents and bitangents for a geometry containing <code>TRIANGLES</code>.\n * The result is new <code>tangent</code> and <code>bitangent</code> attributes added to the geometry.\n * This assumes a counter-clockwise winding order.\n * <p>\n * Based on <a href=\"http://www.terathon.com/code/tangent.html\">Computing Tangent Space Basis Vectors\n * for an Arbitrary Mesh</a> by Eric Lengyel.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument with the computed <code>tangent</code> and <code>bitangent</code> attributes.\n *\n * @exception {DeveloperError} geometry.indices length must be greater than 0 and be a multiple of 3.\n * @exception {DeveloperError} geometry.primitiveType must be {@link PrimitiveType.TRIANGLES}.\n *\n * @example\n * Cesium.GeometryPipeline.computeTangentAndBiTangent(geometry);\n */\nGeometryPipeline.computeTangentAndBitangent = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const attributes = geometry.attributes;\n  const indices = geometry.indices;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(attributes.position) || !defined(attributes.position.values)) {\n    throw new DeveloperError(\n      \"geometry.attributes.position.values is required.\",\n    );\n  }\n  if (!defined(attributes.normal) || !defined(attributes.normal.values)) {\n    throw new DeveloperError(\"geometry.attributes.normal.values is required.\");\n  }\n  if (!defined(attributes.st) || !defined(attributes.st.values)) {\n    throw new DeveloperError(\"geometry.attributes.st.values is required.\");\n  }\n  if (!defined(indices)) {\n    throw new DeveloperError(\"geometry.indices is required.\");\n  }\n  if (indices.length < 2 || indices.length % 3 !== 0) {\n    throw new DeveloperError(\n      \"geometry.indices length must be greater than 0 and be a multiple of 3.\",\n    );\n  }\n  if (geometry.primitiveType !== PrimitiveType.TRIANGLES) {\n    throw new DeveloperError(\n      \"geometry.primitiveType must be PrimitiveType.TRIANGLES.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const vertices = geometry.attributes.position.values;\n  const normals = geometry.attributes.normal.values;\n  const st = geometry.attributes.st.values;\n\n  const numVertices = geometry.attributes.position.values.length / 3;\n  const numIndices = indices.length;\n  const tan1 = new Array(numVertices * 3);\n\n  let i;\n  for (i = 0; i < tan1.length; i++) {\n    tan1[i] = 0;\n  }\n\n  let i03;\n  let i13;\n  let i23;\n  for (i = 0; i < numIndices; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n    i03 = i0 * 3;\n    i13 = i1 * 3;\n    i23 = i2 * 3;\n    const i02 = i0 * 2;\n    const i12 = i1 * 2;\n    const i22 = i2 * 2;\n\n    const ux = vertices[i03];\n    const uy = vertices[i03 + 1];\n    const uz = vertices[i03 + 2];\n\n    const wx = st[i02];\n    const wy = st[i02 + 1];\n    const t1 = st[i12 + 1] - wy;\n    const t2 = st[i22 + 1] - wy;\n\n    const r = 1.0 / ((st[i12] - wx) * t2 - (st[i22] - wx) * t1);\n    const sdirx = (t2 * (vertices[i13] - ux) - t1 * (vertices[i23] - ux)) * r;\n    const sdiry =\n      (t2 * (vertices[i13 + 1] - uy) - t1 * (vertices[i23 + 1] - uy)) * r;\n    const sdirz =\n      (t2 * (vertices[i13 + 2] - uz) - t1 * (vertices[i23 + 2] - uz)) * r;\n\n    tan1[i03] += sdirx;\n    tan1[i03 + 1] += sdiry;\n    tan1[i03 + 2] += sdirz;\n\n    tan1[i13] += sdirx;\n    tan1[i13 + 1] += sdiry;\n    tan1[i13 + 2] += sdirz;\n\n    tan1[i23] += sdirx;\n    tan1[i23 + 1] += sdiry;\n    tan1[i23 + 2] += sdirz;\n  }\n\n  const tangentValues = new Float32Array(numVertices * 3);\n  const bitangentValues = new Float32Array(numVertices * 3);\n\n  for (i = 0; i < numVertices; i++) {\n    i03 = i * 3;\n    i13 = i03 + 1;\n    i23 = i03 + 2;\n\n    const n = Cartesian3.fromArray(normals, i03, normalScratch);\n    const t = Cartesian3.fromArray(tan1, i03, tScratch);\n    const scalar = Cartesian3.dot(n, t);\n    Cartesian3.multiplyByScalar(n, scalar, normalScale);\n    Cartesian3.normalize(Cartesian3.subtract(t, normalScale, t), t);\n\n    tangentValues[i03] = t.x;\n    tangentValues[i13] = t.y;\n    tangentValues[i23] = t.z;\n\n    Cartesian3.normalize(Cartesian3.cross(n, t, t), t);\n\n    bitangentValues[i03] = t.x;\n    bitangentValues[i13] = t.y;\n    bitangentValues[i23] = t.z;\n  }\n\n  geometry.attributes.tangent = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    values: tangentValues,\n  });\n\n  geometry.attributes.bitangent = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    values: bitangentValues,\n  });\n\n  return geometry;\n};\n\nconst scratchCartesian2 = new Cartesian2();\nconst toEncode1 = new Cartesian3();\nconst toEncode2 = new Cartesian3();\nconst toEncode3 = new Cartesian3();\nlet encodeResult2 = new Cartesian2();\n/**\n * Compresses and packs geometry normal attribute values to save memory.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its normals compressed and packed.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.compressVertices(geometry);\n */\nGeometryPipeline.compressVertices = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const extrudeAttribute = geometry.attributes.extrudeDirection;\n  let i;\n  let numVertices;\n  if (defined(extrudeAttribute)) {\n    //only shadow volumes use extrudeDirection, and shadow volumes use vertexFormat: POSITION_ONLY so we don't need to check other attributes\n    const extrudeDirections = extrudeAttribute.values;\n    numVertices = extrudeDirections.length / 3.0;\n    const compressedDirections = new Float32Array(numVertices * 2);\n\n    let i2 = 0;\n    for (i = 0; i < numVertices; ++i) {\n      Cartesian3.fromArray(extrudeDirections, i * 3.0, toEncode1);\n      if (Cartesian3.equals(toEncode1, Cartesian3.ZERO)) {\n        i2 += 2;\n        continue;\n      }\n      encodeResult2 = AttributeCompression.octEncodeInRange(\n        toEncode1,\n        65535,\n        encodeResult2,\n      );\n      compressedDirections[i2++] = encodeResult2.x;\n      compressedDirections[i2++] = encodeResult2.y;\n    }\n\n    geometry.attributes.compressedAttributes = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: compressedDirections,\n    });\n    delete geometry.attributes.extrudeDirection;\n    return geometry;\n  }\n\n  const normalAttribute = geometry.attributes.normal;\n  const stAttribute = geometry.attributes.st;\n\n  const hasNormal = defined(normalAttribute);\n  const hasSt = defined(stAttribute);\n  if (!hasNormal && !hasSt) {\n    return geometry;\n  }\n\n  const tangentAttribute = geometry.attributes.tangent;\n  const bitangentAttribute = geometry.attributes.bitangent;\n\n  const hasTangent = defined(tangentAttribute);\n  const hasBitangent = defined(bitangentAttribute);\n\n  let normals;\n  let st;\n  let tangents;\n  let bitangents;\n\n  if (hasNormal) {\n    normals = normalAttribute.values;\n  }\n  if (hasSt) {\n    st = stAttribute.values;\n  }\n  if (hasTangent) {\n    tangents = tangentAttribute.values;\n  }\n  if (hasBitangent) {\n    bitangents = bitangentAttribute.values;\n  }\n\n  const length = hasNormal ? normals.length : st.length;\n  const numComponents = hasNormal ? 3.0 : 2.0;\n  numVertices = length / numComponents;\n\n  let compressedLength = numVertices;\n  let numCompressedComponents = hasSt && hasNormal ? 2.0 : 1.0;\n  numCompressedComponents += hasTangent || hasBitangent ? 1.0 : 0.0;\n  compressedLength *= numCompressedComponents;\n\n  const compressedAttributes = new Float32Array(compressedLength);\n\n  let normalIndex = 0;\n  for (i = 0; i < numVertices; ++i) {\n    if (hasSt) {\n      Cartesian2.fromArray(st, i * 2.0, scratchCartesian2);\n      compressedAttributes[normalIndex++] =\n        AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n    }\n\n    const index = i * 3.0;\n    if (hasNormal && defined(tangents) && defined(bitangents)) {\n      Cartesian3.fromArray(normals, index, toEncode1);\n      Cartesian3.fromArray(tangents, index, toEncode2);\n      Cartesian3.fromArray(bitangents, index, toEncode3);\n\n      AttributeCompression.octPack(\n        toEncode1,\n        toEncode2,\n        toEncode3,\n        scratchCartesian2,\n      );\n      compressedAttributes[normalIndex++] = scratchCartesian2.x;\n      compressedAttributes[normalIndex++] = scratchCartesian2.y;\n    } else {\n      if (hasNormal) {\n        Cartesian3.fromArray(normals, index, toEncode1);\n        compressedAttributes[normalIndex++] =\n          AttributeCompression.octEncodeFloat(toEncode1);\n      }\n\n      if (hasTangent) {\n        Cartesian3.fromArray(tangents, index, toEncode1);\n        compressedAttributes[normalIndex++] =\n          AttributeCompression.octEncodeFloat(toEncode1);\n      }\n\n      if (hasBitangent) {\n        Cartesian3.fromArray(bitangents, index, toEncode1);\n        compressedAttributes[normalIndex++] =\n          AttributeCompression.octEncodeFloat(toEncode1);\n      }\n    }\n  }\n\n  geometry.attributes.compressedAttributes = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: numCompressedComponents,\n    values: compressedAttributes,\n  });\n\n  if (hasNormal) {\n    delete geometry.attributes.normal;\n  }\n  if (hasSt) {\n    delete geometry.attributes.st;\n  }\n  if (hasBitangent) {\n    delete geometry.attributes.bitangent;\n  }\n  if (hasTangent) {\n    delete geometry.attributes.tangent;\n  }\n\n  return geometry;\n};\n\nfunction indexTriangles(geometry) {\n  if (defined(geometry.indices)) {\n    return geometry;\n  }\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 3) {\n    throw new DeveloperError(\"The number of vertices must be at least three.\");\n  }\n  if (numberOfVertices % 3 !== 0) {\n    throw new DeveloperError(\n      \"The number of vertices must be a multiple of three.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    numberOfVertices,\n  );\n  for (let i = 0; i < numberOfVertices; ++i) {\n    indices[i] = i;\n  }\n\n  geometry.indices = indices;\n  return geometry;\n}\n\nfunction indexTriangleFan(geometry) {\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 3) {\n    throw new DeveloperError(\"The number of vertices must be at least three.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    (numberOfVertices - 2) * 3,\n  );\n  indices[0] = 1;\n  indices[1] = 0;\n  indices[2] = 2;\n\n  let indicesIndex = 3;\n  for (let i = 3; i < numberOfVertices; ++i) {\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = 0;\n    indices[indicesIndex++] = i;\n  }\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.TRIANGLES;\n  return geometry;\n}\n\nfunction indexTriangleStrip(geometry) {\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 3) {\n    throw new DeveloperError(\"The number of vertices must be at least 3.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    (numberOfVertices - 2) * 3,\n  );\n  indices[0] = 0;\n  indices[1] = 1;\n  indices[2] = 2;\n\n  if (numberOfVertices > 3) {\n    indices[3] = 0;\n    indices[4] = 2;\n    indices[5] = 3;\n  }\n\n  let indicesIndex = 6;\n  for (let i = 3; i < numberOfVertices - 1; i += 2) {\n    indices[indicesIndex++] = i;\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = i + 1;\n\n    if (i + 2 < numberOfVertices) {\n      indices[indicesIndex++] = i;\n      indices[indicesIndex++] = i + 1;\n      indices[indicesIndex++] = i + 2;\n    }\n  }\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.TRIANGLES;\n  return geometry;\n}\n\nfunction indexLines(geometry) {\n  if (defined(geometry.indices)) {\n    return geometry;\n  }\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 2) {\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\n  }\n  if (numberOfVertices % 2 !== 0) {\n    throw new DeveloperError(\"The number of vertices must be a multiple of 2.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    numberOfVertices,\n  );\n  for (let i = 0; i < numberOfVertices; ++i) {\n    indices[i] = i;\n  }\n\n  geometry.indices = indices;\n  return geometry;\n}\n\nfunction indexLineStrip(geometry) {\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 2) {\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    (numberOfVertices - 1) * 2,\n  );\n  indices[0] = 0;\n  indices[1] = 1;\n  let indicesIndex = 2;\n  for (let i = 2; i < numberOfVertices; ++i) {\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = i;\n  }\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.LINES;\n  return geometry;\n}\n\nfunction indexLineLoop(geometry) {\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 2) {\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    numberOfVertices * 2,\n  );\n\n  indices[0] = 0;\n  indices[1] = 1;\n\n  let indicesIndex = 2;\n  for (let i = 2; i < numberOfVertices; ++i) {\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = i;\n  }\n\n  indices[indicesIndex++] = numberOfVertices - 1;\n  indices[indicesIndex] = 0;\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.LINES;\n  return geometry;\n}\n\nfunction indexPrimitive(geometry) {\n  switch (geometry.primitiveType) {\n    case PrimitiveType.TRIANGLE_FAN:\n      return indexTriangleFan(geometry);\n    case PrimitiveType.TRIANGLE_STRIP:\n      return indexTriangleStrip(geometry);\n    case PrimitiveType.TRIANGLES:\n      return indexTriangles(geometry);\n    case PrimitiveType.LINE_STRIP:\n      return indexLineStrip(geometry);\n    case PrimitiveType.LINE_LOOP:\n      return indexLineLoop(geometry);\n    case PrimitiveType.LINES:\n      return indexLines(geometry);\n  }\n\n  return geometry;\n}\n\nfunction offsetPointFromXZPlane(p, isBehind) {\n  if (Math.abs(p.y) < CesiumMath.EPSILON6) {\n    if (isBehind) {\n      p.y = -CesiumMath.EPSILON6;\n    } else {\n      p.y = CesiumMath.EPSILON6;\n    }\n  }\n}\n\nfunction offsetTriangleFromXZPlane(p0, p1, p2) {\n  if (p0.y !== 0.0 && p1.y !== 0.0 && p2.y !== 0.0) {\n    offsetPointFromXZPlane(p0, p0.y < 0.0);\n    offsetPointFromXZPlane(p1, p1.y < 0.0);\n    offsetPointFromXZPlane(p2, p2.y < 0.0);\n    return;\n  }\n\n  const p0y = Math.abs(p0.y);\n  const p1y = Math.abs(p1.y);\n  const p2y = Math.abs(p2.y);\n\n  let sign;\n  if (p0y > p1y) {\n    if (p0y > p2y) {\n      sign = CesiumMath.sign(p0.y);\n    } else {\n      sign = CesiumMath.sign(p2.y);\n    }\n  } else if (p1y > p2y) {\n    sign = CesiumMath.sign(p1.y);\n  } else {\n    sign = CesiumMath.sign(p2.y);\n  }\n\n  const isBehind = sign < 0.0;\n  offsetPointFromXZPlane(p0, isBehind);\n  offsetPointFromXZPlane(p1, isBehind);\n  offsetPointFromXZPlane(p2, isBehind);\n}\n\nconst c3 = new Cartesian3();\nfunction getXZIntersectionOffsetPoints(p, p1, u1, v1) {\n  Cartesian3.add(\n    p,\n    Cartesian3.multiplyByScalar(\n      Cartesian3.subtract(p1, p, c3),\n      p.y / (p.y - p1.y),\n      c3,\n    ),\n    u1,\n  );\n  Cartesian3.clone(u1, v1);\n  offsetPointFromXZPlane(u1, true);\n  offsetPointFromXZPlane(v1, false);\n}\n\nconst u1 = new Cartesian3();\nconst u2 = new Cartesian3();\nconst q1 = new Cartesian3();\nconst q2 = new Cartesian3();\n\nconst splitTriangleResult = {\n  positions: new Array(7),\n  indices: new Array(3 * 3),\n};\n\nfunction splitTriangle(p0, p1, p2) {\n  // In ellipsoid coordinates, for a triangle approximately on the\n  // ellipsoid to cross the IDL, first it needs to be on the\n  // negative side of the plane x = 0.\n  if (p0.x >= 0.0 || p1.x >= 0.0 || p2.x >= 0.0) {\n    return undefined;\n  }\n\n  offsetTriangleFromXZPlane(p0, p1, p2);\n\n  const p0Behind = p0.y < 0.0;\n  const p1Behind = p1.y < 0.0;\n  const p2Behind = p2.y < 0.0;\n\n  let numBehind = 0;\n  numBehind += p0Behind ? 1 : 0;\n  numBehind += p1Behind ? 1 : 0;\n  numBehind += p2Behind ? 1 : 0;\n\n  const indices = splitTriangleResult.indices;\n\n  if (numBehind === 1) {\n    indices[1] = 3;\n    indices[2] = 4;\n    indices[5] = 6;\n    indices[7] = 6;\n    indices[8] = 5;\n\n    if (p0Behind) {\n      getXZIntersectionOffsetPoints(p0, p1, u1, q1);\n      getXZIntersectionOffsetPoints(p0, p2, u2, q2);\n\n      indices[0] = 0;\n      indices[3] = 1;\n      indices[4] = 2;\n      indices[6] = 1;\n    } else if (p1Behind) {\n      getXZIntersectionOffsetPoints(p1, p2, u1, q1);\n      getXZIntersectionOffsetPoints(p1, p0, u2, q2);\n\n      indices[0] = 1;\n      indices[3] = 2;\n      indices[4] = 0;\n      indices[6] = 2;\n    } else if (p2Behind) {\n      getXZIntersectionOffsetPoints(p2, p0, u1, q1);\n      getXZIntersectionOffsetPoints(p2, p1, u2, q2);\n\n      indices[0] = 2;\n      indices[3] = 0;\n      indices[4] = 1;\n      indices[6] = 0;\n    }\n  } else if (numBehind === 2) {\n    indices[2] = 4;\n    indices[4] = 4;\n    indices[5] = 3;\n    indices[7] = 5;\n    indices[8] = 6;\n\n    if (!p0Behind) {\n      getXZIntersectionOffsetPoints(p0, p1, u1, q1);\n      getXZIntersectionOffsetPoints(p0, p2, u2, q2);\n\n      indices[0] = 1;\n      indices[1] = 2;\n      indices[3] = 1;\n      indices[6] = 0;\n    } else if (!p1Behind) {\n      getXZIntersectionOffsetPoints(p1, p2, u1, q1);\n      getXZIntersectionOffsetPoints(p1, p0, u2, q2);\n\n      indices[0] = 2;\n      indices[1] = 0;\n      indices[3] = 2;\n      indices[6] = 1;\n    } else if (!p2Behind) {\n      getXZIntersectionOffsetPoints(p2, p0, u1, q1);\n      getXZIntersectionOffsetPoints(p2, p1, u2, q2);\n\n      indices[0] = 0;\n      indices[1] = 1;\n      indices[3] = 0;\n      indices[6] = 2;\n    }\n  }\n\n  const positions = splitTriangleResult.positions;\n  positions[0] = p0;\n  positions[1] = p1;\n  positions[2] = p2;\n  positions.length = 3;\n\n  if (numBehind === 1 || numBehind === 2) {\n    positions[3] = u1;\n    positions[4] = u2;\n    positions[5] = q1;\n    positions[6] = q2;\n    positions.length = 7;\n  }\n\n  return splitTriangleResult;\n}\n\nfunction updateGeometryAfterSplit(geometry, computeBoundingSphere) {\n  const attributes = geometry.attributes;\n\n  if (attributes.position.values.length === 0) {\n    return undefined;\n  }\n\n  for (const property in attributes) {\n    if (\n      attributes.hasOwnProperty(property) &&\n      defined(attributes[property]) &&\n      defined(attributes[property].values)\n    ) {\n      const attribute = attributes[property];\n      attribute.values = ComponentDatatype.createTypedArray(\n        attribute.componentDatatype,\n        attribute.values,\n      );\n    }\n  }\n\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n  geometry.indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    geometry.indices,\n  );\n\n  if (computeBoundingSphere) {\n    geometry.boundingSphere = BoundingSphere.fromVertices(\n      attributes.position.values,\n    );\n  }\n\n  return geometry;\n}\n\nfunction copyGeometryForSplit(geometry) {\n  const attributes = geometry.attributes;\n  const copiedAttributes = {};\n\n  for (const property in attributes) {\n    if (\n      attributes.hasOwnProperty(property) &&\n      defined(attributes[property]) &&\n      defined(attributes[property].values)\n    ) {\n      const attribute = attributes[property];\n      copiedAttributes[property] = new GeometryAttribute({\n        componentDatatype: attribute.componentDatatype,\n        componentsPerAttribute: attribute.componentsPerAttribute,\n        normalize: attribute.normalize,\n        values: [],\n      });\n    }\n  }\n\n  return new Geometry({\n    attributes: copiedAttributes,\n    indices: [],\n    primitiveType: geometry.primitiveType,\n  });\n}\n\nfunction updateInstanceAfterSplit(instance, westGeometry, eastGeometry) {\n  const computeBoundingSphere = defined(instance.geometry.boundingSphere);\n\n  westGeometry = updateGeometryAfterSplit(westGeometry, computeBoundingSphere);\n  eastGeometry = updateGeometryAfterSplit(eastGeometry, computeBoundingSphere);\n\n  if (defined(eastGeometry) && !defined(westGeometry)) {\n    instance.geometry = eastGeometry;\n  } else if (!defined(eastGeometry) && defined(westGeometry)) {\n    instance.geometry = westGeometry;\n  } else {\n    instance.westHemisphereGeometry = westGeometry;\n    instance.eastHemisphereGeometry = eastGeometry;\n    instance.geometry = undefined;\n  }\n}\n\nfunction generateBarycentricInterpolateFunction(\n  CartesianType,\n  numberOfComponents,\n) {\n  const v0Scratch = new CartesianType();\n  const v1Scratch = new CartesianType();\n  const v2Scratch = new CartesianType();\n\n  return function (\n    i0,\n    i1,\n    i2,\n    coords,\n    sourceValues,\n    currentValues,\n    insertedIndex,\n    normalize,\n  ) {\n    const v0 = CartesianType.fromArray(\n      sourceValues,\n      i0 * numberOfComponents,\n      v0Scratch,\n    );\n    const v1 = CartesianType.fromArray(\n      sourceValues,\n      i1 * numberOfComponents,\n      v1Scratch,\n    );\n    const v2 = CartesianType.fromArray(\n      sourceValues,\n      i2 * numberOfComponents,\n      v2Scratch,\n    );\n\n    CartesianType.multiplyByScalar(v0, coords.x, v0);\n    CartesianType.multiplyByScalar(v1, coords.y, v1);\n    CartesianType.multiplyByScalar(v2, coords.z, v2);\n\n    const value = CartesianType.add(v0, v1, v0);\n    CartesianType.add(value, v2, value);\n\n    if (normalize) {\n      CartesianType.normalize(value, value);\n    }\n\n    CartesianType.pack(\n      value,\n      currentValues,\n      insertedIndex * numberOfComponents,\n    );\n  };\n}\n\nconst interpolateAndPackCartesian4 = generateBarycentricInterpolateFunction(\n  Cartesian4,\n  4,\n);\nconst interpolateAndPackCartesian3 = generateBarycentricInterpolateFunction(\n  Cartesian3,\n  3,\n);\nconst interpolateAndPackCartesian2 = generateBarycentricInterpolateFunction(\n  Cartesian2,\n  2,\n);\nconst interpolateAndPackBoolean = function (\n  i0,\n  i1,\n  i2,\n  coords,\n  sourceValues,\n  currentValues,\n  insertedIndex,\n) {\n  const v1 = sourceValues[i0] * coords.x;\n  const v2 = sourceValues[i1] * coords.y;\n  const v3 = sourceValues[i2] * coords.z;\n  currentValues[insertedIndex] = v1 + v2 + v3 > CesiumMath.EPSILON6 ? 1 : 0;\n};\n\nconst p0Scratch = new Cartesian3();\nconst p1Scratch = new Cartesian3();\nconst p2Scratch = new Cartesian3();\nconst barycentricScratch = new Cartesian3();\n\nfunction computeTriangleAttributes(\n  i0,\n  i1,\n  i2,\n  point,\n  positions,\n  normals,\n  tangents,\n  bitangents,\n  texCoords,\n  extrudeDirections,\n  applyOffset,\n  currentAttributes,\n  customAttributeNames,\n  customAttributesLength,\n  allAttributes,\n  insertedIndex,\n) {\n  if (\n    !defined(normals) &&\n    !defined(tangents) &&\n    !defined(bitangents) &&\n    !defined(texCoords) &&\n    !defined(extrudeDirections) &&\n    customAttributesLength === 0\n  ) {\n    return;\n  }\n\n  const p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n  const p1 = Cartesian3.fromArray(positions, i1 * 3, p1Scratch);\n  const p2 = Cartesian3.fromArray(positions, i2 * 3, p2Scratch);\n  const coords = barycentricCoordinates(point, p0, p1, p2, barycentricScratch);\n  if (!defined(coords)) {\n    return;\n  }\n\n  if (defined(normals)) {\n    interpolateAndPackCartesian3(\n      i0,\n      i1,\n      i2,\n      coords,\n      normals,\n      currentAttributes.normal.values,\n      insertedIndex,\n      true,\n    );\n  }\n\n  if (defined(extrudeDirections)) {\n    const d0 = Cartesian3.fromArray(extrudeDirections, i0 * 3, p0Scratch);\n    const d1 = Cartesian3.fromArray(extrudeDirections, i1 * 3, p1Scratch);\n    const d2 = Cartesian3.fromArray(extrudeDirections, i2 * 3, p2Scratch);\n\n    Cartesian3.multiplyByScalar(d0, coords.x, d0);\n    Cartesian3.multiplyByScalar(d1, coords.y, d1);\n    Cartesian3.multiplyByScalar(d2, coords.z, d2);\n\n    let direction;\n    if (\n      !Cartesian3.equals(d0, Cartesian3.ZERO) ||\n      !Cartesian3.equals(d1, Cartesian3.ZERO) ||\n      !Cartesian3.equals(d2, Cartesian3.ZERO)\n    ) {\n      direction = Cartesian3.add(d0, d1, d0);\n      Cartesian3.add(direction, d2, direction);\n      Cartesian3.normalize(direction, direction);\n    } else {\n      direction = p0Scratch;\n      direction.x = 0;\n      direction.y = 0;\n      direction.z = 0;\n    }\n    Cartesian3.pack(\n      direction,\n      currentAttributes.extrudeDirection.values,\n      insertedIndex * 3,\n    );\n  }\n\n  if (defined(applyOffset)) {\n    interpolateAndPackBoolean(\n      i0,\n      i1,\n      i2,\n      coords,\n      applyOffset,\n      currentAttributes.applyOffset.values,\n      insertedIndex,\n    );\n  }\n\n  if (defined(tangents)) {\n    interpolateAndPackCartesian3(\n      i0,\n      i1,\n      i2,\n      coords,\n      tangents,\n      currentAttributes.tangent.values,\n      insertedIndex,\n      true,\n    );\n  }\n\n  if (defined(bitangents)) {\n    interpolateAndPackCartesian3(\n      i0,\n      i1,\n      i2,\n      coords,\n      bitangents,\n      currentAttributes.bitangent.values,\n      insertedIndex,\n      true,\n    );\n  }\n\n  if (defined(texCoords)) {\n    interpolateAndPackCartesian2(\n      i0,\n      i1,\n      i2,\n      coords,\n      texCoords,\n      currentAttributes.st.values,\n      insertedIndex,\n    );\n  }\n\n  if (customAttributesLength > 0) {\n    for (let i = 0; i < customAttributesLength; i++) {\n      const attributeName = customAttributeNames[i];\n      genericInterpolate(\n        i0,\n        i1,\n        i2,\n        coords,\n        insertedIndex,\n        allAttributes[attributeName],\n        currentAttributes[attributeName],\n      );\n    }\n  }\n}\n\nfunction genericInterpolate(\n  i0,\n  i1,\n  i2,\n  coords,\n  insertedIndex,\n  sourceAttribute,\n  currentAttribute,\n) {\n  const componentsPerAttribute = sourceAttribute.componentsPerAttribute;\n  const sourceValues = sourceAttribute.values;\n  const currentValues = currentAttribute.values;\n  switch (componentsPerAttribute) {\n    case 4:\n      interpolateAndPackCartesian4(\n        i0,\n        i1,\n        i2,\n        coords,\n        sourceValues,\n        currentValues,\n        insertedIndex,\n        false,\n      );\n      break;\n    case 3:\n      interpolateAndPackCartesian3(\n        i0,\n        i1,\n        i2,\n        coords,\n        sourceValues,\n        currentValues,\n        insertedIndex,\n        false,\n      );\n      break;\n    case 2:\n      interpolateAndPackCartesian2(\n        i0,\n        i1,\n        i2,\n        coords,\n        sourceValues,\n        currentValues,\n        insertedIndex,\n        false,\n      );\n      break;\n    default:\n      currentValues[insertedIndex] =\n        sourceValues[i0] * coords.x +\n        sourceValues[i1] * coords.y +\n        sourceValues[i2] * coords.z;\n  }\n}\n\nfunction insertSplitPoint(\n  currentAttributes,\n  currentIndices,\n  currentIndexMap,\n  indices,\n  currentIndex,\n  point,\n) {\n  const insertIndex = currentAttributes.position.values.length / 3;\n\n  if (currentIndex !== -1) {\n    const prevIndex = indices[currentIndex];\n    const newIndex = currentIndexMap[prevIndex];\n\n    if (newIndex === -1) {\n      currentIndexMap[prevIndex] = insertIndex;\n      currentAttributes.position.values.push(point.x, point.y, point.z);\n      currentIndices.push(insertIndex);\n      return insertIndex;\n    }\n\n    currentIndices.push(newIndex);\n    return newIndex;\n  }\n\n  currentAttributes.position.values.push(point.x, point.y, point.z);\n  currentIndices.push(insertIndex);\n  return insertIndex;\n}\n\nconst NAMED_ATTRIBUTES = {\n  position: true,\n  normal: true,\n  bitangent: true,\n  tangent: true,\n  st: true,\n  extrudeDirection: true,\n  applyOffset: true,\n};\nfunction splitLongitudeTriangles(instance) {\n  const geometry = instance.geometry;\n  const attributes = geometry.attributes;\n  const positions = attributes.position.values;\n  const normals = defined(attributes.normal)\n    ? attributes.normal.values\n    : undefined;\n  const bitangents = defined(attributes.bitangent)\n    ? attributes.bitangent.values\n    : undefined;\n  const tangents = defined(attributes.tangent)\n    ? attributes.tangent.values\n    : undefined;\n  const texCoords = defined(attributes.st) ? attributes.st.values : undefined;\n  const extrudeDirections = defined(attributes.extrudeDirection)\n    ? attributes.extrudeDirection.values\n    : undefined;\n  const applyOffset = defined(attributes.applyOffset)\n    ? attributes.applyOffset.values\n    : undefined;\n  const indices = geometry.indices;\n\n  const customAttributeNames = [];\n  for (const attributeName in attributes) {\n    if (\n      attributes.hasOwnProperty(attributeName) &&\n      !NAMED_ATTRIBUTES[attributeName] &&\n      defined(attributes[attributeName])\n    ) {\n      customAttributeNames.push(attributeName);\n    }\n  }\n  const customAttributesLength = customAttributeNames.length;\n\n  const eastGeometry = copyGeometryForSplit(geometry);\n  const westGeometry = copyGeometryForSplit(geometry);\n\n  let currentAttributes;\n  let currentIndices;\n  let currentIndexMap;\n  let insertedIndex;\n  let i;\n\n  const westGeometryIndexMap = [];\n  westGeometryIndexMap.length = positions.length / 3;\n\n  const eastGeometryIndexMap = [];\n  eastGeometryIndexMap.length = positions.length / 3;\n\n  for (i = 0; i < westGeometryIndexMap.length; ++i) {\n    westGeometryIndexMap[i] = -1;\n    eastGeometryIndexMap[i] = -1;\n  }\n\n  const len = indices.length;\n  for (i = 0; i < len; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n\n    let p0 = Cartesian3.fromArray(positions, i0 * 3);\n    let p1 = Cartesian3.fromArray(positions, i1 * 3);\n    let p2 = Cartesian3.fromArray(positions, i2 * 3);\n\n    const result = splitTriangle(p0, p1, p2);\n    if (defined(result) && result.positions.length > 3) {\n      const resultPositions = result.positions;\n      const resultIndices = result.indices;\n      const resultLength = resultIndices.length;\n\n      for (let j = 0; j < resultLength; ++j) {\n        const resultIndex = resultIndices[j];\n        const point = resultPositions[resultIndex];\n\n        if (point.y < 0.0) {\n          currentAttributes = westGeometry.attributes;\n          currentIndices = westGeometry.indices;\n          currentIndexMap = westGeometryIndexMap;\n        } else {\n          currentAttributes = eastGeometry.attributes;\n          currentIndices = eastGeometry.indices;\n          currentIndexMap = eastGeometryIndexMap;\n        }\n\n        insertedIndex = insertSplitPoint(\n          currentAttributes,\n          currentIndices,\n          currentIndexMap,\n          indices,\n          resultIndex < 3 ? i + resultIndex : -1,\n          point,\n        );\n        computeTriangleAttributes(\n          i0,\n          i1,\n          i2,\n          point,\n          positions,\n          normals,\n          tangents,\n          bitangents,\n          texCoords,\n          extrudeDirections,\n          applyOffset,\n          currentAttributes,\n          customAttributeNames,\n          customAttributesLength,\n          attributes,\n          insertedIndex,\n        );\n      }\n    } else {\n      if (defined(result)) {\n        p0 = result.positions[0];\n        p1 = result.positions[1];\n        p2 = result.positions[2];\n      }\n\n      if (p0.y < 0.0) {\n        currentAttributes = westGeometry.attributes;\n        currentIndices = westGeometry.indices;\n        currentIndexMap = westGeometryIndexMap;\n      } else {\n        currentAttributes = eastGeometry.attributes;\n        currentIndices = eastGeometry.indices;\n        currentIndexMap = eastGeometryIndexMap;\n      }\n\n      insertedIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i,\n        p0,\n      );\n      computeTriangleAttributes(\n        i0,\n        i1,\n        i2,\n        p0,\n        positions,\n        normals,\n        tangents,\n        bitangents,\n        texCoords,\n        extrudeDirections,\n        applyOffset,\n        currentAttributes,\n        customAttributeNames,\n        customAttributesLength,\n        attributes,\n        insertedIndex,\n      );\n\n      insertedIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i + 1,\n        p1,\n      );\n      computeTriangleAttributes(\n        i0,\n        i1,\n        i2,\n        p1,\n        positions,\n        normals,\n        tangents,\n        bitangents,\n        texCoords,\n        extrudeDirections,\n        applyOffset,\n        currentAttributes,\n        customAttributeNames,\n        customAttributesLength,\n        attributes,\n        insertedIndex,\n      );\n\n      insertedIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i + 2,\n        p2,\n      );\n      computeTriangleAttributes(\n        i0,\n        i1,\n        i2,\n        p2,\n        positions,\n        normals,\n        tangents,\n        bitangents,\n        texCoords,\n        extrudeDirections,\n        applyOffset,\n        currentAttributes,\n        customAttributeNames,\n        customAttributesLength,\n        attributes,\n        insertedIndex,\n      );\n    }\n  }\n\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n}\n\nconst xzPlane = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\n\nconst offsetScratch = new Cartesian3();\nconst offsetPointScratch = new Cartesian3();\n\nfunction computeLineAttributes(\n  i0,\n  i1,\n  point,\n  positions,\n  insertIndex,\n  currentAttributes,\n  applyOffset,\n) {\n  if (!defined(applyOffset)) {\n    return;\n  }\n\n  const p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n  if (Cartesian3.equalsEpsilon(p0, point, CesiumMath.EPSILON10)) {\n    currentAttributes.applyOffset.values[insertIndex] = applyOffset[i0];\n  } else {\n    currentAttributes.applyOffset.values[insertIndex] = applyOffset[i1];\n  }\n}\n\nfunction splitLongitudeLines(instance) {\n  const geometry = instance.geometry;\n  const attributes = geometry.attributes;\n  const positions = attributes.position.values;\n  const applyOffset = defined(attributes.applyOffset)\n    ? attributes.applyOffset.values\n    : undefined;\n  const indices = geometry.indices;\n\n  const eastGeometry = copyGeometryForSplit(geometry);\n  const westGeometry = copyGeometryForSplit(geometry);\n\n  let i;\n  const length = indices.length;\n\n  const westGeometryIndexMap = [];\n  westGeometryIndexMap.length = positions.length / 3;\n\n  const eastGeometryIndexMap = [];\n  eastGeometryIndexMap.length = positions.length / 3;\n\n  for (i = 0; i < westGeometryIndexMap.length; ++i) {\n    westGeometryIndexMap[i] = -1;\n    eastGeometryIndexMap[i] = -1;\n  }\n\n  for (i = 0; i < length; i += 2) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n\n    const p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n    const p1 = Cartesian3.fromArray(positions, i1 * 3, p1Scratch);\n    let insertIndex;\n\n    if (Math.abs(p0.y) < CesiumMath.EPSILON6) {\n      if (p0.y < 0.0) {\n        p0.y = -CesiumMath.EPSILON6;\n      } else {\n        p0.y = CesiumMath.EPSILON6;\n      }\n    }\n\n    if (Math.abs(p1.y) < CesiumMath.EPSILON6) {\n      if (p1.y < 0.0) {\n        p1.y = -CesiumMath.EPSILON6;\n      } else {\n        p1.y = CesiumMath.EPSILON6;\n      }\n    }\n\n    let p0Attributes = eastGeometry.attributes;\n    let p0Indices = eastGeometry.indices;\n    let p0IndexMap = eastGeometryIndexMap;\n    let p1Attributes = westGeometry.attributes;\n    let p1Indices = westGeometry.indices;\n    let p1IndexMap = westGeometryIndexMap;\n\n    const intersection = IntersectionTests.lineSegmentPlane(\n      p0,\n      p1,\n      xzPlane,\n      p2Scratch,\n    );\n    if (defined(intersection)) {\n      // move point on the xz-plane slightly away from the plane\n      const offset = Cartesian3.multiplyByScalar(\n        Cartesian3.UNIT_Y,\n        5.0 * CesiumMath.EPSILON9,\n        offsetScratch,\n      );\n      if (p0.y < 0.0) {\n        Cartesian3.negate(offset, offset);\n\n        p0Attributes = westGeometry.attributes;\n        p0Indices = westGeometry.indices;\n        p0IndexMap = westGeometryIndexMap;\n        p1Attributes = eastGeometry.attributes;\n        p1Indices = eastGeometry.indices;\n        p1IndexMap = eastGeometryIndexMap;\n      }\n\n      const offsetPoint = Cartesian3.add(\n        intersection,\n        offset,\n        offsetPointScratch,\n      );\n\n      insertIndex = insertSplitPoint(\n        p0Attributes,\n        p0Indices,\n        p0IndexMap,\n        indices,\n        i,\n        p0,\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        p0,\n        positions,\n        insertIndex,\n        p0Attributes,\n        applyOffset,\n      );\n\n      insertIndex = insertSplitPoint(\n        p0Attributes,\n        p0Indices,\n        p0IndexMap,\n        indices,\n        -1,\n        offsetPoint,\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        offsetPoint,\n        positions,\n        insertIndex,\n        p0Attributes,\n        applyOffset,\n      );\n\n      Cartesian3.negate(offset, offset);\n      Cartesian3.add(intersection, offset, offsetPoint);\n      insertIndex = insertSplitPoint(\n        p1Attributes,\n        p1Indices,\n        p1IndexMap,\n        indices,\n        -1,\n        offsetPoint,\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        offsetPoint,\n        positions,\n        insertIndex,\n        p1Attributes,\n        applyOffset,\n      );\n\n      insertIndex = insertSplitPoint(\n        p1Attributes,\n        p1Indices,\n        p1IndexMap,\n        indices,\n        i + 1,\n        p1,\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        p1,\n        positions,\n        insertIndex,\n        p1Attributes,\n        applyOffset,\n      );\n    } else {\n      let currentAttributes;\n      let currentIndices;\n      let currentIndexMap;\n\n      if (p0.y < 0.0) {\n        currentAttributes = westGeometry.attributes;\n        currentIndices = westGeometry.indices;\n        currentIndexMap = westGeometryIndexMap;\n      } else {\n        currentAttributes = eastGeometry.attributes;\n        currentIndices = eastGeometry.indices;\n        currentIndexMap = eastGeometryIndexMap;\n      }\n\n      insertIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i,\n        p0,\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        p0,\n        positions,\n        insertIndex,\n        currentAttributes,\n        applyOffset,\n      );\n\n      insertIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i + 1,\n        p1,\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        p1,\n        positions,\n        insertIndex,\n        currentAttributes,\n        applyOffset,\n      );\n    }\n  }\n\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n}\n\nconst cartesian2Scratch0 = new Cartesian2();\nconst cartesian2Scratch1 = new Cartesian2();\n\nconst cartesian3Scratch0 = new Cartesian3();\nconst cartesian3Scratch2 = new Cartesian3();\nconst cartesian3Scratch3 = new Cartesian3();\nconst cartesian3Scratch4 = new Cartesian3();\nconst cartesian3Scratch5 = new Cartesian3();\nconst cartesian3Scratch6 = new Cartesian3();\n\nconst cartesian4Scratch0 = new Cartesian4();\n\nfunction updateAdjacencyAfterSplit(geometry) {\n  const attributes = geometry.attributes;\n  const positions = attributes.position.values;\n  const prevPositions = attributes.prevPosition.values;\n  const nextPositions = attributes.nextPosition.values;\n\n  const length = positions.length;\n  for (let j = 0; j < length; j += 3) {\n    const position = Cartesian3.unpack(positions, j, cartesian3Scratch0);\n    if (position.x > 0.0) {\n      continue;\n    }\n\n    const prevPosition = Cartesian3.unpack(\n      prevPositions,\n      j,\n      cartesian3Scratch2,\n    );\n    if (\n      (position.y < 0.0 && prevPosition.y > 0.0) ||\n      (position.y > 0.0 && prevPosition.y < 0.0)\n    ) {\n      if (j - 3 > 0) {\n        prevPositions[j] = positions[j - 3];\n        prevPositions[j + 1] = positions[j - 2];\n        prevPositions[j + 2] = positions[j - 1];\n      } else {\n        Cartesian3.pack(position, prevPositions, j);\n      }\n    }\n\n    const nextPosition = Cartesian3.unpack(\n      nextPositions,\n      j,\n      cartesian3Scratch3,\n    );\n    if (\n      (position.y < 0.0 && nextPosition.y > 0.0) ||\n      (position.y > 0.0 && nextPosition.y < 0.0)\n    ) {\n      if (j + 3 < length) {\n        nextPositions[j] = positions[j + 3];\n        nextPositions[j + 1] = positions[j + 4];\n        nextPositions[j + 2] = positions[j + 5];\n      } else {\n        Cartesian3.pack(position, nextPositions, j);\n      }\n    }\n  }\n}\n\nconst offsetScalar = 5.0 * CesiumMath.EPSILON9;\nconst coplanarOffset = CesiumMath.EPSILON6;\n\nfunction splitLongitudePolyline(instance) {\n  const geometry = instance.geometry;\n  const attributes = geometry.attributes;\n  const positions = attributes.position.values;\n  const prevPositions = attributes.prevPosition.values;\n  const nextPositions = attributes.nextPosition.values;\n  const expandAndWidths = attributes.expandAndWidth.values;\n\n  const texCoords = defined(attributes.st) ? attributes.st.values : undefined;\n  const colors = defined(attributes.color)\n    ? attributes.color.values\n    : undefined;\n\n  const eastGeometry = copyGeometryForSplit(geometry);\n  const westGeometry = copyGeometryForSplit(geometry);\n\n  let i;\n  let j;\n  let index;\n\n  let intersectionFound = false;\n\n  const length = positions.length / 3;\n  for (i = 0; i < length; i += 4) {\n    const i0 = i;\n    const i2 = i + 2;\n\n    const p0 = Cartesian3.fromArray(positions, i0 * 3, cartesian3Scratch0);\n    const p2 = Cartesian3.fromArray(positions, i2 * 3, cartesian3Scratch2);\n\n    // Offset points that are close to the 180 longitude and change the previous/next point\n    // to be the same offset point so it can be projected to 2D. There is special handling in the\n    // shader for when position == prevPosition || position == nextPosition.\n    if (Math.abs(p0.y) < coplanarOffset) {\n      p0.y = coplanarOffset * (p2.y < 0.0 ? -1.0 : 1.0);\n      positions[i * 3 + 1] = p0.y;\n      positions[(i + 1) * 3 + 1] = p0.y;\n\n      for (j = i0 * 3; j < i0 * 3 + 4 * 3; j += 3) {\n        prevPositions[j] = positions[i * 3];\n        prevPositions[j + 1] = positions[i * 3 + 1];\n        prevPositions[j + 2] = positions[i * 3 + 2];\n      }\n    }\n\n    // Do the same but for when the line crosses 180 longitude in the opposite direction.\n    if (Math.abs(p2.y) < coplanarOffset) {\n      p2.y = coplanarOffset * (p0.y < 0.0 ? -1.0 : 1.0);\n      positions[(i + 2) * 3 + 1] = p2.y;\n      positions[(i + 3) * 3 + 1] = p2.y;\n\n      for (j = i0 * 3; j < i0 * 3 + 4 * 3; j += 3) {\n        nextPositions[j] = positions[(i + 2) * 3];\n        nextPositions[j + 1] = positions[(i + 2) * 3 + 1];\n        nextPositions[j + 2] = positions[(i + 2) * 3 + 2];\n      }\n    }\n\n    let p0Attributes = eastGeometry.attributes;\n    let p0Indices = eastGeometry.indices;\n    let p2Attributes = westGeometry.attributes;\n    let p2Indices = westGeometry.indices;\n\n    const intersection = IntersectionTests.lineSegmentPlane(\n      p0,\n      p2,\n      xzPlane,\n      cartesian3Scratch4,\n    );\n    if (defined(intersection)) {\n      intersectionFound = true;\n\n      // move point on the xz-plane slightly away from the plane\n      const offset = Cartesian3.multiplyByScalar(\n        Cartesian3.UNIT_Y,\n        offsetScalar,\n        cartesian3Scratch5,\n      );\n      if (p0.y < 0.0) {\n        Cartesian3.negate(offset, offset);\n        p0Attributes = westGeometry.attributes;\n        p0Indices = westGeometry.indices;\n        p2Attributes = eastGeometry.attributes;\n        p2Indices = eastGeometry.indices;\n      }\n\n      const offsetPoint = Cartesian3.add(\n        intersection,\n        offset,\n        cartesian3Scratch6,\n      );\n      p0Attributes.position.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);\n      p0Attributes.position.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n      p0Attributes.position.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n\n      p0Attributes.prevPosition.values.push(\n        prevPositions[i0 * 3],\n        prevPositions[i0 * 3 + 1],\n        prevPositions[i0 * 3 + 2],\n      );\n      p0Attributes.prevPosition.values.push(\n        prevPositions[i0 * 3 + 3],\n        prevPositions[i0 * 3 + 4],\n        prevPositions[i0 * 3 + 5],\n      );\n      p0Attributes.prevPosition.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);\n\n      p0Attributes.nextPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n      p0Attributes.nextPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n      p0Attributes.nextPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n      p0Attributes.nextPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n\n      Cartesian3.negate(offset, offset);\n      Cartesian3.add(intersection, offset, offsetPoint);\n      p2Attributes.position.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n      p2Attributes.position.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n      p2Attributes.position.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);\n\n      p2Attributes.prevPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n      p2Attributes.prevPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n      p2Attributes.prevPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n      p2Attributes.prevPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z,\n      );\n\n      p2Attributes.nextPosition.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);\n      p2Attributes.nextPosition.values.push(\n        nextPositions[i2 * 3],\n        nextPositions[i2 * 3 + 1],\n        nextPositions[i2 * 3 + 2],\n      );\n      p2Attributes.nextPosition.values.push(\n        nextPositions[i2 * 3 + 3],\n        nextPositions[i2 * 3 + 4],\n        nextPositions[i2 * 3 + 5],\n      );\n\n      const ew0 = Cartesian2.fromArray(\n        expandAndWidths,\n        i0 * 2,\n        cartesian2Scratch0,\n      );\n      const width = Math.abs(ew0.y);\n\n      p0Attributes.expandAndWidth.values.push(-1, width, 1, width);\n      p0Attributes.expandAndWidth.values.push(-1, -width, 1, -width);\n      p2Attributes.expandAndWidth.values.push(-1, width, 1, width);\n      p2Attributes.expandAndWidth.values.push(-1, -width, 1, -width);\n\n      let t = Cartesian3.magnitudeSquared(\n        Cartesian3.subtract(intersection, p0, cartesian3Scratch3),\n      );\n      t /= Cartesian3.magnitudeSquared(\n        Cartesian3.subtract(p2, p0, cartesian3Scratch3),\n      );\n\n      if (defined(colors)) {\n        const c0 = Cartesian4.fromArray(colors, i0 * 4, cartesian4Scratch0);\n        const c2 = Cartesian4.fromArray(colors, i2 * 4, cartesian4Scratch0);\n\n        const r = CesiumMath.lerp(c0.x, c2.x, t);\n        const g = CesiumMath.lerp(c0.y, c2.y, t);\n        const b = CesiumMath.lerp(c0.z, c2.z, t);\n        const a = CesiumMath.lerp(c0.w, c2.w, t);\n\n        for (j = i0 * 4; j < i0 * 4 + 2 * 4; ++j) {\n          p0Attributes.color.values.push(colors[j]);\n        }\n        p0Attributes.color.values.push(r, g, b, a);\n        p0Attributes.color.values.push(r, g, b, a);\n        p2Attributes.color.values.push(r, g, b, a);\n        p2Attributes.color.values.push(r, g, b, a);\n        for (j = i2 * 4; j < i2 * 4 + 2 * 4; ++j) {\n          p2Attributes.color.values.push(colors[j]);\n        }\n      }\n\n      if (defined(texCoords)) {\n        const s0 = Cartesian2.fromArray(texCoords, i0 * 2, cartesian2Scratch0);\n        const s3 = Cartesian2.fromArray(\n          texCoords,\n          (i + 3) * 2,\n          cartesian2Scratch1,\n        );\n\n        const sx = CesiumMath.lerp(s0.x, s3.x, t);\n\n        for (j = i0 * 2; j < i0 * 2 + 2 * 2; ++j) {\n          p0Attributes.st.values.push(texCoords[j]);\n        }\n        p0Attributes.st.values.push(sx, s0.y);\n        p0Attributes.st.values.push(sx, s3.y);\n        p2Attributes.st.values.push(sx, s0.y);\n        p2Attributes.st.values.push(sx, s3.y);\n        for (j = i2 * 2; j < i2 * 2 + 2 * 2; ++j) {\n          p2Attributes.st.values.push(texCoords[j]);\n        }\n      }\n\n      index = p0Attributes.position.values.length / 3 - 4;\n      p0Indices.push(index, index + 2, index + 1);\n      p0Indices.push(index + 1, index + 2, index + 3);\n\n      index = p2Attributes.position.values.length / 3 - 4;\n      p2Indices.push(index, index + 2, index + 1);\n      p2Indices.push(index + 1, index + 2, index + 3);\n    } else {\n      let currentAttributes;\n      let currentIndices;\n\n      if (p0.y < 0.0) {\n        currentAttributes = westGeometry.attributes;\n        currentIndices = westGeometry.indices;\n      } else {\n        currentAttributes = eastGeometry.attributes;\n        currentIndices = eastGeometry.indices;\n      }\n\n      currentAttributes.position.values.push(p0.x, p0.y, p0.z);\n      currentAttributes.position.values.push(p0.x, p0.y, p0.z);\n      currentAttributes.position.values.push(p2.x, p2.y, p2.z);\n      currentAttributes.position.values.push(p2.x, p2.y, p2.z);\n\n      for (j = i * 3; j < i * 3 + 4 * 3; ++j) {\n        currentAttributes.prevPosition.values.push(prevPositions[j]);\n        currentAttributes.nextPosition.values.push(nextPositions[j]);\n      }\n\n      for (j = i * 2; j < i * 2 + 4 * 2; ++j) {\n        currentAttributes.expandAndWidth.values.push(expandAndWidths[j]);\n        if (defined(texCoords)) {\n          currentAttributes.st.values.push(texCoords[j]);\n        }\n      }\n\n      if (defined(colors)) {\n        for (j = i * 4; j < i * 4 + 4 * 4; ++j) {\n          currentAttributes.color.values.push(colors[j]);\n        }\n      }\n\n      index = currentAttributes.position.values.length / 3 - 4;\n      currentIndices.push(index, index + 2, index + 1);\n      currentIndices.push(index + 1, index + 2, index + 3);\n    }\n  }\n\n  if (intersectionFound) {\n    updateAdjacencyAfterSplit(westGeometry);\n    updateAdjacencyAfterSplit(eastGeometry);\n  }\n\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n}\n\n/**\n * Splits the instances's geometry, by introducing new vertices and indices,that\n * intersect the International Date Line and Prime Meridian so that no primitives cross longitude\n * -180/180 degrees.  This is not required for 3D drawing, but is required for\n * correcting drawing in 2D and Columbus view.\n *\n * @private\n *\n * @param {GeometryInstance} instance The instance to modify.\n * @returns {GeometryInstance} The modified <code>instance</code> argument, with it's geometry split at the International Date Line.\n *\n * @example\n * instance = Cesium.GeometryPipeline.splitLongitude(instance);\n */\nGeometryPipeline.splitLongitude = function (instance) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(instance)) {\n    throw new DeveloperError(\"instance is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const geometry = instance.geometry;\n  const boundingSphere = geometry.boundingSphere;\n  if (defined(boundingSphere)) {\n    const minX = boundingSphere.center.x - boundingSphere.radius;\n    if (\n      minX > 0 ||\n      BoundingSphere.intersectPlane(boundingSphere, Plane.ORIGIN_ZX_PLANE) !==\n        Intersect.INTERSECTING\n    ) {\n      return instance;\n    }\n  }\n\n  if (geometry.geometryType !== GeometryType.NONE) {\n    switch (geometry.geometryType) {\n      case GeometryType.POLYLINES:\n        splitLongitudePolyline(instance);\n        break;\n      case GeometryType.TRIANGLES:\n        splitLongitudeTriangles(instance);\n        break;\n      case GeometryType.LINES:\n        splitLongitudeLines(instance);\n        break;\n    }\n  } else {\n    indexPrimitive(geometry);\n    if (geometry.primitiveType === PrimitiveType.TRIANGLES) {\n      splitLongitudeTriangles(instance);\n    } else if (geometry.primitiveType === PrimitiveType.LINES) {\n      splitLongitudeLines(instance);\n    }\n  }\n\n  return instance;\n};\nexport default GeometryPipeline;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}