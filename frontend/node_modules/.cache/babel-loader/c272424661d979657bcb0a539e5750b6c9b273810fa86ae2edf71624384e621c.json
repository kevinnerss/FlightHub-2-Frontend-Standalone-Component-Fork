{"ast":null,"code":"import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport createBillboardPointCallback from \"../Scene/createBillboardPointCallback.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport Property from \"./Property.js\";\nimport SplitDirection from \"../Scene/SplitDirection.js\";\nconst defaultColor = Color.WHITE;\nconst defaultOutlineColor = Color.BLACK;\nconst defaultOutlineWidth = 0.0;\nconst defaultPixelSize = 1.0;\nconst defaultDisableDepthTestDistance = 0.0;\nconst defaultSplitDirection = SplitDirection.NONE;\nconst colorScratch = new Color();\nconst positionScratch = new Cartesian3();\nconst outlineColorScratch = new Color();\nconst scaleByDistanceScratch = new NearFarScalar();\nconst translucencyByDistanceScratch = new NearFarScalar();\nconst distanceDisplayConditionScratch = new DistanceDisplayCondition();\nfunction EntityData(entity) {\n  this.entity = entity;\n  this.pointPrimitive = undefined;\n  this.billboard = undefined;\n  this.color = undefined;\n  this.outlineColor = undefined;\n  this.pixelSize = undefined;\n  this.outlineWidth = undefined;\n}\n\n/**\n * A {@link Visualizer} which maps {@link Entity#point} to a {@link PointPrimitive}.\n * @alias PointVisualizer\n * @constructor\n *\n * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.\n * @param {EntityCollection} entityCollection The entityCollection to visualize.\n */\nfunction PointVisualizer(entityCluster, entityCollection) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entityCluster)) {\n    throw new DeveloperError(\"entityCluster is required.\");\n  }\n  if (!defined(entityCollection)) {\n    throw new DeveloperError(\"entityCollection is required.\");\n  }\n  //>>includeEnd('debug');\n\n  entityCollection.collectionChanged.addEventListener(PointVisualizer.prototype._onCollectionChanged, this);\n  this._cluster = entityCluster;\n  this._entityCollection = entityCollection;\n  this._items = new AssociativeArray();\n  this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n}\n\n/**\n * Updates the primitives created by this visualizer to match their\n * Entity counterpart at the given time.\n *\n * @param {JulianDate} time The time to update to.\n * @returns {boolean} This function always returns true.\n */\nPointVisualizer.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(time)) {\n    throw new DeveloperError(\"time is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const items = this._items.values;\n  const cluster = this._cluster;\n  for (let i = 0, len = items.length; i < len; i++) {\n    const item = items[i];\n    const entity = item.entity;\n    const pointGraphics = entity._point;\n    let pointPrimitive = item.pointPrimitive;\n    let billboard = item.billboard;\n    const heightReference = Property.getValueOrDefault(pointGraphics._heightReference, time, HeightReference.NONE);\n    let show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(pointGraphics._show, time, true);\n    let position;\n    if (show) {\n      position = Property.getValueOrUndefined(entity._position, time, positionScratch);\n      show = defined(position);\n    }\n    if (!show) {\n      returnPrimitive(item, entity, cluster);\n      continue;\n    }\n    if (!Property.isConstant(entity._position)) {\n      cluster._clusterDirty = true;\n    }\n    let needsRedraw = false;\n    let updateClamping = false;\n    if (heightReference !== HeightReference.NONE && !defined(billboard)) {\n      if (defined(pointPrimitive)) {\n        returnPrimitive(item, entity, cluster);\n        pointPrimitive = undefined;\n      }\n      billboard = cluster.getBillboard(entity);\n      billboard.id = entity;\n      billboard.image = undefined;\n      item.billboard = billboard;\n      needsRedraw = true;\n\n      // If this new billboard happens to have a position and height reference that match our new values,\n      // billboard._updateClamping will not be called automatically. That's a problem because the clamped\n      // height may be based on different terrain than is now loaded. So we'll manually call\n      // _updateClamping below.\n      updateClamping = Cartesian3.equals(billboard.position, position) && billboard.heightReference === heightReference;\n    } else if (heightReference === HeightReference.NONE && !defined(pointPrimitive)) {\n      if (defined(billboard)) {\n        returnPrimitive(item, entity, cluster);\n        billboard = undefined;\n      }\n      pointPrimitive = cluster.getPoint(entity);\n      pointPrimitive.id = entity;\n      item.pointPrimitive = pointPrimitive;\n    }\n    if (defined(pointPrimitive)) {\n      pointPrimitive.show = true;\n      pointPrimitive.position = position;\n      pointPrimitive.scaleByDistance = Property.getValueOrUndefined(pointGraphics._scaleByDistance, time, scaleByDistanceScratch);\n      pointPrimitive.translucencyByDistance = Property.getValueOrUndefined(pointGraphics._translucencyByDistance, time, translucencyByDistanceScratch);\n      pointPrimitive.color = Property.getValueOrDefault(pointGraphics._color, time, defaultColor, colorScratch);\n      pointPrimitive.outlineColor = Property.getValueOrDefault(pointGraphics._outlineColor, time, defaultOutlineColor, outlineColorScratch);\n      pointPrimitive.outlineWidth = Property.getValueOrDefault(pointGraphics._outlineWidth, time, defaultOutlineWidth);\n      pointPrimitive.pixelSize = Property.getValueOrDefault(pointGraphics._pixelSize, time, defaultPixelSize);\n      pointPrimitive.distanceDisplayCondition = Property.getValueOrUndefined(pointGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);\n      pointPrimitive.disableDepthTestDistance = Property.getValueOrDefault(pointGraphics._disableDepthTestDistance, time, defaultDisableDepthTestDistance);\n      pointPrimitive.splitDirection = Property.getValueOrDefault(pointGraphics._splitDirection, time, defaultSplitDirection);\n    } else if (defined(billboard)) {\n      billboard.show = true;\n      billboard.position = position;\n      billboard.scaleByDistance = Property.getValueOrUndefined(pointGraphics._scaleByDistance, time, scaleByDistanceScratch);\n      billboard.translucencyByDistance = Property.getValueOrUndefined(pointGraphics._translucencyByDistance, time, translucencyByDistanceScratch);\n      billboard.distanceDisplayCondition = Property.getValueOrUndefined(pointGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);\n      billboard.disableDepthTestDistance = Property.getValueOrDefault(pointGraphics._disableDepthTestDistance, time, defaultDisableDepthTestDistance);\n      billboard.splitDirection = Property.getValueOrDefault(pointGraphics._splitDirection, time, defaultSplitDirection);\n      billboard.heightReference = heightReference;\n      const newColor = Property.getValueOrDefault(pointGraphics._color, time, defaultColor, colorScratch);\n      const newOutlineColor = Property.getValueOrDefault(pointGraphics._outlineColor, time, defaultOutlineColor, outlineColorScratch);\n      const newOutlineWidth = Math.round(Property.getValueOrDefault(pointGraphics._outlineWidth, time, defaultOutlineWidth));\n      let newPixelSize = Math.max(1, Math.round(Property.getValueOrDefault(pointGraphics._pixelSize, time, defaultPixelSize)));\n      if (newOutlineWidth > 0) {\n        billboard.scale = 1.0;\n        needsRedraw = needsRedraw ||\n        //\n        newOutlineWidth !== item.outlineWidth ||\n        //\n        newPixelSize !== item.pixelSize ||\n        //\n        !Color.equals(newColor, item.color) ||\n        //\n        !Color.equals(newOutlineColor, item.outlineColor);\n      } else {\n        billboard.scale = newPixelSize / 50.0;\n        newPixelSize = 50.0;\n        needsRedraw = needsRedraw ||\n        //\n        newOutlineWidth !== item.outlineWidth ||\n        //\n        !Color.equals(newColor, item.color) ||\n        //\n        !Color.equals(newOutlineColor, item.outlineColor);\n      }\n      if (needsRedraw) {\n        item.color = Color.clone(newColor, item.color);\n        item.outlineColor = Color.clone(newOutlineColor, item.outlineColor);\n        item.pixelSize = newPixelSize;\n        item.outlineWidth = newOutlineWidth;\n        const centerAlpha = newColor.alpha;\n        const cssColor = newColor.toCssColorString();\n        const cssOutlineColor = newOutlineColor.toCssColorString();\n        const textureId = JSON.stringify([cssColor, newPixelSize, cssOutlineColor, newOutlineWidth]);\n        billboard.setImage(textureId, createBillboardPointCallback(centerAlpha, cssColor, cssOutlineColor, newOutlineWidth, newPixelSize));\n      }\n      if (updateClamping) {\n        billboard._updateClamping();\n      }\n    }\n  }\n  return true;\n};\n\n/**\n * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n * The bounding sphere is in the fixed frame of the scene's globe.\n *\n * @param {Entity} entity The entity whose bounding sphere to compute.\n * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n *                       BoundingSphereState.PENDING if the result is still being computed, or\n *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n * @private\n */\nPointVisualizer.prototype.getBoundingSphere = function (entity, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entity)) {\n    throw new DeveloperError(\"entity is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const item = this._items.get(entity.id);\n  if (!defined(item) || !(defined(item.pointPrimitive) || defined(item.billboard))) {\n    return BoundingSphereState.FAILED;\n  }\n  if (defined(item.pointPrimitive)) {\n    result.center = Cartesian3.clone(item.pointPrimitive.position, result.center);\n  } else {\n    const billboard = item.billboard;\n    if (!defined(billboard._clampedPosition)) {\n      return BoundingSphereState.PENDING;\n    }\n    result.center = Cartesian3.clone(billboard._clampedPosition, result.center);\n  }\n  result.radius = 0;\n  return BoundingSphereState.DONE;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n */\nPointVisualizer.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes and destroys all primitives created by this instance.\n */\nPointVisualizer.prototype.destroy = function () {\n  this._entityCollection.collectionChanged.removeEventListener(PointVisualizer.prototype._onCollectionChanged, this);\n  const entities = this._entityCollection.values;\n  for (let i = 0; i < entities.length; i++) {\n    this._cluster.removePoint(entities[i]);\n  }\n  return destroyObject(this);\n};\nPointVisualizer.prototype._onCollectionChanged = function (entityCollection, added, removed, changed) {\n  let i;\n  let entity;\n  const items = this._items;\n  const cluster = this._cluster;\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    if (defined(entity._point) && defined(entity._position)) {\n      items.set(entity.id, new EntityData(entity));\n    }\n  }\n  for (i = changed.length - 1; i > -1; i--) {\n    entity = changed[i];\n    if (defined(entity._point) && defined(entity._position)) {\n      if (!items.contains(entity.id)) {\n        items.set(entity.id, new EntityData(entity));\n      }\n    } else {\n      returnPrimitive(items.get(entity.id), entity, cluster);\n      items.remove(entity.id);\n    }\n  }\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    returnPrimitive(items.get(entity.id), entity, cluster);\n    items.remove(entity.id);\n  }\n};\nfunction returnPrimitive(item, entity, cluster) {\n  if (defined(item)) {\n    const pointPrimitive = item.pointPrimitive;\n    if (defined(pointPrimitive)) {\n      item.pointPrimitive = undefined;\n      cluster.removePoint(entity);\n      return;\n    }\n    const billboard = item.billboard;\n    if (defined(billboard)) {\n      item.billboard = undefined;\n      cluster.removeBillboard(entity);\n    }\n  }\n}\nexport default PointVisualizer;","map":{"version":3,"names":["AssociativeArray","Cartesian3","Color","defined","destroyObject","DeveloperError","DistanceDisplayCondition","NearFarScalar","createBillboardPointCallback","HeightReference","BoundingSphereState","Property","SplitDirection","defaultColor","WHITE","defaultOutlineColor","BLACK","defaultOutlineWidth","defaultPixelSize","defaultDisableDepthTestDistance","defaultSplitDirection","NONE","colorScratch","positionScratch","outlineColorScratch","scaleByDistanceScratch","translucencyByDistanceScratch","distanceDisplayConditionScratch","EntityData","entity","pointPrimitive","undefined","billboard","color","outlineColor","pixelSize","outlineWidth","PointVisualizer","entityCluster","entityCollection","collectionChanged","addEventListener","prototype","_onCollectionChanged","_cluster","_entityCollection","_items","values","update","time","items","cluster","i","len","length","item","pointGraphics","_point","heightReference","getValueOrDefault","_heightReference","show","isShowing","isAvailable","_show","position","getValueOrUndefined","_position","returnPrimitive","isConstant","_clusterDirty","needsRedraw","updateClamping","getBillboard","id","image","equals","getPoint","scaleByDistance","_scaleByDistance","translucencyByDistance","_translucencyByDistance","_color","_outlineColor","_outlineWidth","_pixelSize","distanceDisplayCondition","_distanceDisplayCondition","disableDepthTestDistance","_disableDepthTestDistance","splitDirection","_splitDirection","newColor","newOutlineColor","newOutlineWidth","Math","round","newPixelSize","max","scale","clone","centerAlpha","alpha","cssColor","toCssColorString","cssOutlineColor","textureId","JSON","stringify","setImage","_updateClamping","getBoundingSphere","result","get","FAILED","center","_clampedPosition","PENDING","radius","DONE","isDestroyed","destroy","removeEventListener","entities","removePoint","added","removed","changed","set","contains","remove","removeBillboard"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/DataSources/PointVisualizer.js"],"sourcesContent":["import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport createBillboardPointCallback from \"../Scene/createBillboardPointCallback.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport Property from \"./Property.js\";\nimport SplitDirection from \"../Scene/SplitDirection.js\";\n\nconst defaultColor = Color.WHITE;\nconst defaultOutlineColor = Color.BLACK;\nconst defaultOutlineWidth = 0.0;\nconst defaultPixelSize = 1.0;\nconst defaultDisableDepthTestDistance = 0.0;\nconst defaultSplitDirection = SplitDirection.NONE;\n\nconst colorScratch = new Color();\nconst positionScratch = new Cartesian3();\nconst outlineColorScratch = new Color();\nconst scaleByDistanceScratch = new NearFarScalar();\nconst translucencyByDistanceScratch = new NearFarScalar();\nconst distanceDisplayConditionScratch = new DistanceDisplayCondition();\n\nfunction EntityData(entity) {\n  this.entity = entity;\n  this.pointPrimitive = undefined;\n  this.billboard = undefined;\n  this.color = undefined;\n  this.outlineColor = undefined;\n  this.pixelSize = undefined;\n  this.outlineWidth = undefined;\n}\n\n/**\n * A {@link Visualizer} which maps {@link Entity#point} to a {@link PointPrimitive}.\n * @alias PointVisualizer\n * @constructor\n *\n * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.\n * @param {EntityCollection} entityCollection The entityCollection to visualize.\n */\nfunction PointVisualizer(entityCluster, entityCollection) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entityCluster)) {\n    throw new DeveloperError(\"entityCluster is required.\");\n  }\n  if (!defined(entityCollection)) {\n    throw new DeveloperError(\"entityCollection is required.\");\n  }\n  //>>includeEnd('debug');\n\n  entityCollection.collectionChanged.addEventListener(\n    PointVisualizer.prototype._onCollectionChanged,\n    this,\n  );\n\n  this._cluster = entityCluster;\n  this._entityCollection = entityCollection;\n  this._items = new AssociativeArray();\n  this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n}\n\n/**\n * Updates the primitives created by this visualizer to match their\n * Entity counterpart at the given time.\n *\n * @param {JulianDate} time The time to update to.\n * @returns {boolean} This function always returns true.\n */\nPointVisualizer.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(time)) {\n    throw new DeveloperError(\"time is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const items = this._items.values;\n  const cluster = this._cluster;\n  for (let i = 0, len = items.length; i < len; i++) {\n    const item = items[i];\n    const entity = item.entity;\n    const pointGraphics = entity._point;\n    let pointPrimitive = item.pointPrimitive;\n    let billboard = item.billboard;\n    const heightReference = Property.getValueOrDefault(\n      pointGraphics._heightReference,\n      time,\n      HeightReference.NONE,\n    );\n    let show =\n      entity.isShowing &&\n      entity.isAvailable(time) &&\n      Property.getValueOrDefault(pointGraphics._show, time, true);\n    let position;\n    if (show) {\n      position = Property.getValueOrUndefined(\n        entity._position,\n        time,\n        positionScratch,\n      );\n      show = defined(position);\n    }\n    if (!show) {\n      returnPrimitive(item, entity, cluster);\n      continue;\n    }\n\n    if (!Property.isConstant(entity._position)) {\n      cluster._clusterDirty = true;\n    }\n\n    let needsRedraw = false;\n    let updateClamping = false;\n    if (heightReference !== HeightReference.NONE && !defined(billboard)) {\n      if (defined(pointPrimitive)) {\n        returnPrimitive(item, entity, cluster);\n        pointPrimitive = undefined;\n      }\n\n      billboard = cluster.getBillboard(entity);\n      billboard.id = entity;\n      billboard.image = undefined;\n      item.billboard = billboard;\n      needsRedraw = true;\n\n      // If this new billboard happens to have a position and height reference that match our new values,\n      // billboard._updateClamping will not be called automatically. That's a problem because the clamped\n      // height may be based on different terrain than is now loaded. So we'll manually call\n      // _updateClamping below.\n      updateClamping =\n        Cartesian3.equals(billboard.position, position) &&\n        billboard.heightReference === heightReference;\n    } else if (\n      heightReference === HeightReference.NONE &&\n      !defined(pointPrimitive)\n    ) {\n      if (defined(billboard)) {\n        returnPrimitive(item, entity, cluster);\n        billboard = undefined;\n      }\n\n      pointPrimitive = cluster.getPoint(entity);\n      pointPrimitive.id = entity;\n      item.pointPrimitive = pointPrimitive;\n    }\n\n    if (defined(pointPrimitive)) {\n      pointPrimitive.show = true;\n      pointPrimitive.position = position;\n      pointPrimitive.scaleByDistance = Property.getValueOrUndefined(\n        pointGraphics._scaleByDistance,\n        time,\n        scaleByDistanceScratch,\n      );\n      pointPrimitive.translucencyByDistance = Property.getValueOrUndefined(\n        pointGraphics._translucencyByDistance,\n        time,\n        translucencyByDistanceScratch,\n      );\n      pointPrimitive.color = Property.getValueOrDefault(\n        pointGraphics._color,\n        time,\n        defaultColor,\n        colorScratch,\n      );\n      pointPrimitive.outlineColor = Property.getValueOrDefault(\n        pointGraphics._outlineColor,\n        time,\n        defaultOutlineColor,\n        outlineColorScratch,\n      );\n      pointPrimitive.outlineWidth = Property.getValueOrDefault(\n        pointGraphics._outlineWidth,\n        time,\n        defaultOutlineWidth,\n      );\n      pointPrimitive.pixelSize = Property.getValueOrDefault(\n        pointGraphics._pixelSize,\n        time,\n        defaultPixelSize,\n      );\n      pointPrimitive.distanceDisplayCondition = Property.getValueOrUndefined(\n        pointGraphics._distanceDisplayCondition,\n        time,\n        distanceDisplayConditionScratch,\n      );\n      pointPrimitive.disableDepthTestDistance = Property.getValueOrDefault(\n        pointGraphics._disableDepthTestDistance,\n        time,\n        defaultDisableDepthTestDistance,\n      );\n      pointPrimitive.splitDirection = Property.getValueOrDefault(\n        pointGraphics._splitDirection,\n        time,\n        defaultSplitDirection,\n      );\n    } else if (defined(billboard)) {\n      billboard.show = true;\n      billboard.position = position;\n      billboard.scaleByDistance = Property.getValueOrUndefined(\n        pointGraphics._scaleByDistance,\n        time,\n        scaleByDistanceScratch,\n      );\n      billboard.translucencyByDistance = Property.getValueOrUndefined(\n        pointGraphics._translucencyByDistance,\n        time,\n        translucencyByDistanceScratch,\n      );\n      billboard.distanceDisplayCondition = Property.getValueOrUndefined(\n        pointGraphics._distanceDisplayCondition,\n        time,\n        distanceDisplayConditionScratch,\n      );\n      billboard.disableDepthTestDistance = Property.getValueOrDefault(\n        pointGraphics._disableDepthTestDistance,\n        time,\n        defaultDisableDepthTestDistance,\n      );\n      billboard.splitDirection = Property.getValueOrDefault(\n        pointGraphics._splitDirection,\n        time,\n        defaultSplitDirection,\n      );\n      billboard.heightReference = heightReference;\n\n      const newColor = Property.getValueOrDefault(\n        pointGraphics._color,\n        time,\n        defaultColor,\n        colorScratch,\n      );\n      const newOutlineColor = Property.getValueOrDefault(\n        pointGraphics._outlineColor,\n        time,\n        defaultOutlineColor,\n        outlineColorScratch,\n      );\n      const newOutlineWidth = Math.round(\n        Property.getValueOrDefault(\n          pointGraphics._outlineWidth,\n          time,\n          defaultOutlineWidth,\n        ),\n      );\n      let newPixelSize = Math.max(\n        1,\n        Math.round(\n          Property.getValueOrDefault(\n            pointGraphics._pixelSize,\n            time,\n            defaultPixelSize,\n          ),\n        ),\n      );\n\n      if (newOutlineWidth > 0) {\n        billboard.scale = 1.0;\n        needsRedraw =\n          needsRedraw || //\n          newOutlineWidth !== item.outlineWidth || //\n          newPixelSize !== item.pixelSize || //\n          !Color.equals(newColor, item.color) || //\n          !Color.equals(newOutlineColor, item.outlineColor);\n      } else {\n        billboard.scale = newPixelSize / 50.0;\n        newPixelSize = 50.0;\n        needsRedraw =\n          needsRedraw || //\n          newOutlineWidth !== item.outlineWidth || //\n          !Color.equals(newColor, item.color) || //\n          !Color.equals(newOutlineColor, item.outlineColor);\n      }\n\n      if (needsRedraw) {\n        item.color = Color.clone(newColor, item.color);\n        item.outlineColor = Color.clone(newOutlineColor, item.outlineColor);\n        item.pixelSize = newPixelSize;\n        item.outlineWidth = newOutlineWidth;\n\n        const centerAlpha = newColor.alpha;\n        const cssColor = newColor.toCssColorString();\n        const cssOutlineColor = newOutlineColor.toCssColorString();\n        const textureId = JSON.stringify([\n          cssColor,\n          newPixelSize,\n          cssOutlineColor,\n          newOutlineWidth,\n        ]);\n\n        billboard.setImage(\n          textureId,\n          createBillboardPointCallback(\n            centerAlpha,\n            cssColor,\n            cssOutlineColor,\n            newOutlineWidth,\n            newPixelSize,\n          ),\n        );\n      }\n\n      if (updateClamping) {\n        billboard._updateClamping();\n      }\n    }\n  }\n  return true;\n};\n\n/**\n * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n * The bounding sphere is in the fixed frame of the scene's globe.\n *\n * @param {Entity} entity The entity whose bounding sphere to compute.\n * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n *                       BoundingSphereState.PENDING if the result is still being computed, or\n *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n * @private\n */\nPointVisualizer.prototype.getBoundingSphere = function (entity, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(entity)) {\n    throw new DeveloperError(\"entity is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const item = this._items.get(entity.id);\n  if (\n    !defined(item) ||\n    !(defined(item.pointPrimitive) || defined(item.billboard))\n  ) {\n    return BoundingSphereState.FAILED;\n  }\n\n  if (defined(item.pointPrimitive)) {\n    result.center = Cartesian3.clone(\n      item.pointPrimitive.position,\n      result.center,\n    );\n  } else {\n    const billboard = item.billboard;\n    if (!defined(billboard._clampedPosition)) {\n      return BoundingSphereState.PENDING;\n    }\n    result.center = Cartesian3.clone(billboard._clampedPosition, result.center);\n  }\n\n  result.radius = 0;\n  return BoundingSphereState.DONE;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n */\nPointVisualizer.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes and destroys all primitives created by this instance.\n */\nPointVisualizer.prototype.destroy = function () {\n  this._entityCollection.collectionChanged.removeEventListener(\n    PointVisualizer.prototype._onCollectionChanged,\n    this,\n  );\n  const entities = this._entityCollection.values;\n  for (let i = 0; i < entities.length; i++) {\n    this._cluster.removePoint(entities[i]);\n  }\n  return destroyObject(this);\n};\n\nPointVisualizer.prototype._onCollectionChanged = function (\n  entityCollection,\n  added,\n  removed,\n  changed,\n) {\n  let i;\n  let entity;\n  const items = this._items;\n  const cluster = this._cluster;\n\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    if (defined(entity._point) && defined(entity._position)) {\n      items.set(entity.id, new EntityData(entity));\n    }\n  }\n\n  for (i = changed.length - 1; i > -1; i--) {\n    entity = changed[i];\n    if (defined(entity._point) && defined(entity._position)) {\n      if (!items.contains(entity.id)) {\n        items.set(entity.id, new EntityData(entity));\n      }\n    } else {\n      returnPrimitive(items.get(entity.id), entity, cluster);\n      items.remove(entity.id);\n    }\n  }\n\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    returnPrimitive(items.get(entity.id), entity, cluster);\n    items.remove(entity.id);\n  }\n};\n\nfunction returnPrimitive(item, entity, cluster) {\n  if (defined(item)) {\n    const pointPrimitive = item.pointPrimitive;\n    if (defined(pointPrimitive)) {\n      item.pointPrimitive = undefined;\n      cluster.removePoint(entity);\n      return;\n    }\n    const billboard = item.billboard;\n    if (defined(billboard)) {\n      item.billboard = undefined;\n      cluster.removeBillboard(entity);\n    }\n  }\n}\nexport default PointVisualizer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}