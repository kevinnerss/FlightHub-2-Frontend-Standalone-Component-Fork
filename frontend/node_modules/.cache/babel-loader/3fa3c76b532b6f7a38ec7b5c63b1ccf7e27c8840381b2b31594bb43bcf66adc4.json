{"ast":null,"code":"import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport EllipseGeometry from \"../Core/EllipseGeometry.js\";\nimport EllipseOutlineGeometry from \"../Core/EllipseOutlineGeometry.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryUpdater from \"./DynamicGeometryUpdater.js\";\nimport GeometryUpdater from \"./GeometryUpdater.js\";\nimport GroundGeometryUpdater from \"./GroundGeometryUpdater.js\";\nimport Property from \"./Property.js\";\nconst scratchColor = new Color();\nconst defaultOffset = Cartesian3.ZERO;\nconst offsetScratch = new Cartesian3();\nconst scratchRectangle = new Rectangle();\nfunction EllipseGeometryOptions(entity) {\n  this.id = entity;\n  this.vertexFormat = undefined;\n  this.center = undefined;\n  this.semiMajorAxis = undefined;\n  this.semiMinorAxis = undefined;\n  this.rotation = undefined;\n  this.height = undefined;\n  this.extrudedHeight = undefined;\n  this.granularity = undefined;\n  this.stRotation = undefined;\n  this.numberOfVerticalLines = undefined;\n  this.offsetAttribute = undefined;\n}\n\n/**\n * A {@link GeometryUpdater} for ellipses.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias EllipseGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\nfunction EllipseGeometryUpdater(entity, scene) {\n  GroundGeometryUpdater.call(this, {\n    entity: entity,\n    scene: scene,\n    geometryOptions: new EllipseGeometryOptions(entity),\n    geometryPropertyName: \"ellipse\",\n    observedPropertyNames: [\"availability\", \"position\", \"ellipse\"]\n  });\n  this._onEntityPropertyChanged(entity, \"ellipse\", entity.ellipse, undefined);\n}\nif (defined(Object.create)) {\n  EllipseGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);\n  EllipseGeometryUpdater.prototype.constructor = EllipseGeometryUpdater;\n}\n\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\nEllipseGeometryUpdater.prototype.createFillGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  if (!this._fillEnabled) {\n    throw new DeveloperError(\"This instance does not represent a filled geometry.\");\n  }\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n  const attributes = {\n    show: new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),\n    distanceDisplayCondition: DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n    offset: undefined,\n    color: undefined\n  };\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    let currentColor;\n    if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n    attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n  }\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n  }\n  return new GeometryInstance({\n    id: entity,\n    geometry: new EllipseGeometry(this._options),\n    attributes: attributes\n  });\n};\n\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\nEllipseGeometryUpdater.prototype.createOutlineGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  if (!this._outlineEnabled) {\n    throw new DeveloperError(\"This instance does not represent an outlined geometry.\");\n  }\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n  const outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n  const distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n  const attributes = {\n    show: new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n    color: ColorGeometryInstanceAttribute.fromColor(outlineColor),\n    distanceDisplayCondition: DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n    offset: undefined\n  };\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n  }\n  return new GeometryInstance({\n    id: entity,\n    geometry: new EllipseOutlineGeometry(this._options),\n    attributes: attributes\n  });\n};\nEllipseGeometryUpdater.prototype._computeCenter = function (time, result) {\n  return Property.getValueOrUndefined(this._entity.position, time, result);\n};\nEllipseGeometryUpdater.prototype._isHidden = function (entity, ellipse) {\n  const position = entity.position;\n  return !defined(position) || !defined(ellipse.semiMajorAxis) || !defined(ellipse.semiMinorAxis) || GeometryUpdater.prototype._isHidden.call(this, entity, ellipse);\n};\nEllipseGeometryUpdater.prototype._isDynamic = function (entity, ellipse) {\n  return !entity.position.isConstant ||\n  //\n  !ellipse.semiMajorAxis.isConstant ||\n  //\n  !ellipse.semiMinorAxis.isConstant ||\n  //\n  !Property.isConstant(ellipse.rotation) ||\n  //\n  !Property.isConstant(ellipse.height) ||\n  //\n  !Property.isConstant(ellipse.extrudedHeight) ||\n  //\n  !Property.isConstant(ellipse.granularity) ||\n  //\n  !Property.isConstant(ellipse.stRotation) ||\n  //\n  !Property.isConstant(ellipse.outlineWidth) ||\n  //\n  !Property.isConstant(ellipse.numberOfVerticalLines) ||\n  //\n  !Property.isConstant(ellipse.zIndex) ||\n  //\n  this._onTerrain && !Property.isConstant(this._materialProperty) && !(this._materialProperty instanceof ColorMaterialProperty);\n};\nEllipseGeometryUpdater.prototype._setStaticOptions = function (entity, ellipse) {\n  let heightValue = Property.getValueOrUndefined(ellipse.height, Iso8601.MINIMUM_VALUE);\n  const heightReferenceValue = Property.getValueOrDefault(ellipse.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n  let extrudedHeightValue = Property.getValueOrUndefined(ellipse.extrudedHeight, Iso8601.MINIMUM_VALUE);\n  const extrudedHeightReferenceValue = Property.getValueOrDefault(ellipse.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n  if (defined(extrudedHeightValue) && !defined(heightValue)) {\n    heightValue = 0;\n  }\n  const options = this._options;\n  options.vertexFormat = this._materialProperty instanceof ColorMaterialProperty ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n  options.center = entity.position.getValue(Iso8601.MINIMUM_VALUE, options.center);\n  options.semiMajorAxis = ellipse.semiMajorAxis.getValue(Iso8601.MINIMUM_VALUE, options.semiMajorAxis);\n  options.semiMinorAxis = ellipse.semiMinorAxis.getValue(Iso8601.MINIMUM_VALUE, options.semiMinorAxis);\n  options.rotation = Property.getValueOrUndefined(ellipse.rotation, Iso8601.MINIMUM_VALUE);\n  options.granularity = Property.getValueOrUndefined(ellipse.granularity, Iso8601.MINIMUM_VALUE);\n  options.stRotation = Property.getValueOrUndefined(ellipse.stRotation, Iso8601.MINIMUM_VALUE);\n  options.numberOfVerticalLines = Property.getValueOrUndefined(ellipse.numberOfVerticalLines, Iso8601.MINIMUM_VALUE);\n  options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n  options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n  extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n  if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n    extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(EllipseGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n  }\n  options.extrudedHeight = extrudedHeightValue;\n};\nEllipseGeometryUpdater.DynamicGeometryUpdater = DynamicEllipseGeometryUpdater;\n\n/**\n * @private\n */\nfunction DynamicEllipseGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n  DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n}\nif (defined(Object.create)) {\n  DynamicEllipseGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n  DynamicEllipseGeometryUpdater.prototype.constructor = DynamicEllipseGeometryUpdater;\n}\nDynamicEllipseGeometryUpdater.prototype._isHidden = function (entity, ellipse, time) {\n  const options = this._options;\n  return !defined(options.center) || !defined(options.semiMajorAxis) || !defined(options.semiMinorAxis) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, ellipse, time);\n};\nDynamicEllipseGeometryUpdater.prototype._setOptions = function (entity, ellipse, time) {\n  const options = this._options;\n  let heightValue = Property.getValueOrUndefined(ellipse.height, time);\n  const heightReferenceValue = Property.getValueOrDefault(ellipse.heightReference, time, HeightReference.NONE);\n  let extrudedHeightValue = Property.getValueOrUndefined(ellipse.extrudedHeight, time);\n  const extrudedHeightReferenceValue = Property.getValueOrDefault(ellipse.extrudedHeightReference, time, HeightReference.NONE);\n  if (defined(extrudedHeightValue) && !defined(heightValue)) {\n    heightValue = 0;\n  }\n  options.center = Property.getValueOrUndefined(entity.position, time, options.center);\n  options.semiMajorAxis = Property.getValueOrUndefined(ellipse.semiMajorAxis, time);\n  options.semiMinorAxis = Property.getValueOrUndefined(ellipse.semiMinorAxis, time);\n  options.rotation = Property.getValueOrUndefined(ellipse.rotation, time);\n  options.granularity = Property.getValueOrUndefined(ellipse.granularity, time);\n  options.stRotation = Property.getValueOrUndefined(ellipse.stRotation, time);\n  options.numberOfVerticalLines = Property.getValueOrUndefined(ellipse.numberOfVerticalLines, time);\n  options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n  options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n  extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n  if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n    extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(EllipseGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n  }\n  options.extrudedHeight = extrudedHeightValue;\n};\nexport default EllipseGeometryUpdater;","map":{"version":3,"names":["ApproximateTerrainHeights","Cartesian3","Check","Color","ColorGeometryInstanceAttribute","defined","DeveloperError","DistanceDisplayConditionGeometryInstanceAttribute","EllipseGeometry","EllipseOutlineGeometry","GeometryInstance","Iso8601","OffsetGeometryInstanceAttribute","Rectangle","ShowGeometryInstanceAttribute","HeightReference","MaterialAppearance","PerInstanceColorAppearance","ColorMaterialProperty","DynamicGeometryUpdater","GeometryUpdater","GroundGeometryUpdater","Property","scratchColor","defaultOffset","ZERO","offsetScratch","scratchRectangle","EllipseGeometryOptions","entity","id","vertexFormat","undefined","center","semiMajorAxis","semiMinorAxis","rotation","height","extrudedHeight","granularity","stRotation","numberOfVerticalLines","offsetAttribute","EllipseGeometryUpdater","scene","call","geometryOptions","geometryPropertyName","observedPropertyNames","_onEntityPropertyChanged","ellipse","Object","create","prototype","constructor","createFillGeometryInstance","time","_fillEnabled","_entity","isAvailable","attributes","show","isShowing","_showProperty","getValue","_fillProperty","distanceDisplayCondition","fromDistanceDisplayCondition","_distanceDisplayConditionProperty","offset","color","_materialProperty","currentColor","isConstant","WHITE","fromColor","_options","fromCartesian3","getValueOrDefault","_terrainOffsetProperty","geometry","createOutlineGeometryInstance","_outlineEnabled","outlineColor","_outlineColorProperty","BLACK","_showOutlineProperty","_computeCenter","result","getValueOrUndefined","position","_isHidden","_isDynamic","outlineWidth","zIndex","_onTerrain","_setStaticOptions","heightValue","MINIMUM_VALUE","heightReferenceValue","heightReference","NONE","extrudedHeightValue","extrudedHeightReferenceValue","extrudedHeightReference","options","VERTEX_FORMAT","MaterialSupport","TEXTURED","computeGeometryOffsetAttribute","getGeometryHeight","getGeometryExtrudedHeight","CLAMP_TO_GROUND","getMinimumMaximumHeights","computeRectangle","minimumTerrainHeight","DynamicEllipseGeometryUpdater","geometryUpdater","primitives","groundPrimitives","_setOptions"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/DataSources/EllipseGeometryUpdater.js"],"sourcesContent":["import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayConditionGeometryInstanceAttribute from \"../Core/DistanceDisplayConditionGeometryInstanceAttribute.js\";\nimport EllipseGeometry from \"../Core/EllipseGeometry.js\";\nimport EllipseOutlineGeometry from \"../Core/EllipseOutlineGeometry.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Iso8601 from \"../Core/Iso8601.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport DynamicGeometryUpdater from \"./DynamicGeometryUpdater.js\";\nimport GeometryUpdater from \"./GeometryUpdater.js\";\nimport GroundGeometryUpdater from \"./GroundGeometryUpdater.js\";\nimport Property from \"./Property.js\";\n\nconst scratchColor = new Color();\nconst defaultOffset = Cartesian3.ZERO;\nconst offsetScratch = new Cartesian3();\nconst scratchRectangle = new Rectangle();\n\nfunction EllipseGeometryOptions(entity) {\n  this.id = entity;\n  this.vertexFormat = undefined;\n  this.center = undefined;\n  this.semiMajorAxis = undefined;\n  this.semiMinorAxis = undefined;\n  this.rotation = undefined;\n  this.height = undefined;\n  this.extrudedHeight = undefined;\n  this.granularity = undefined;\n  this.stRotation = undefined;\n  this.numberOfVerticalLines = undefined;\n  this.offsetAttribute = undefined;\n}\n\n/**\n * A {@link GeometryUpdater} for ellipses.\n * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n * @alias EllipseGeometryUpdater\n * @constructor\n *\n * @param {Entity} entity The entity containing the geometry to be visualized.\n * @param {Scene} scene The scene where visualization is taking place.\n */\nfunction EllipseGeometryUpdater(entity, scene) {\n  GroundGeometryUpdater.call(this, {\n    entity: entity,\n    scene: scene,\n    geometryOptions: new EllipseGeometryOptions(entity),\n    geometryPropertyName: \"ellipse\",\n    observedPropertyNames: [\"availability\", \"position\", \"ellipse\"],\n  });\n\n  this._onEntityPropertyChanged(entity, \"ellipse\", entity.ellipse, undefined);\n}\n\nif (defined(Object.create)) {\n  EllipseGeometryUpdater.prototype = Object.create(\n    GroundGeometryUpdater.prototype,\n  );\n  EllipseGeometryUpdater.prototype.constructor = EllipseGeometryUpdater;\n}\n\n/**\n * Creates the geometry instance which represents the fill of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent a filled geometry.\n */\nEllipseGeometryUpdater.prototype.createFillGeometryInstance = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n\n  if (!this._fillEnabled) {\n    throw new DeveloperError(\n      \"This instance does not represent a filled geometry.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n\n  const attributes = {\n    show: new ShowGeometryInstanceAttribute(\n      isAvailable &&\n        entity.isShowing &&\n        this._showProperty.getValue(time) &&\n        this._fillProperty.getValue(time),\n    ),\n    distanceDisplayCondition:\n      DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(\n        this._distanceDisplayConditionProperty.getValue(time),\n      ),\n    offset: undefined,\n    color: undefined,\n  };\n\n  if (this._materialProperty instanceof ColorMaterialProperty) {\n    let currentColor;\n    if (\n      defined(this._materialProperty.color) &&\n      (this._materialProperty.color.isConstant || isAvailable)\n    ) {\n      currentColor = this._materialProperty.color.getValue(time, scratchColor);\n    }\n    if (!defined(currentColor)) {\n      currentColor = Color.WHITE;\n    }\n    attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n  }\n\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(\n      Property.getValueOrDefault(\n        this._terrainOffsetProperty,\n        time,\n        defaultOffset,\n        offsetScratch,\n      ),\n    );\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new EllipseGeometry(this._options),\n    attributes: attributes,\n  });\n};\n\n/**\n * Creates the geometry instance which represents the outline of the geometry.\n *\n * @param {JulianDate} time The time to use when retrieving initial attribute values.\n * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n *\n * @exception {DeveloperError} This instance does not represent an outlined geometry.\n */\nEllipseGeometryUpdater.prototype.createOutlineGeometryInstance = function (\n  time,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n\n  if (!this._outlineEnabled) {\n    throw new DeveloperError(\n      \"This instance does not represent an outlined geometry.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const entity = this._entity;\n  const isAvailable = entity.isAvailable(time);\n  const outlineColor = Property.getValueOrDefault(\n    this._outlineColorProperty,\n    time,\n    Color.BLACK,\n    scratchColor,\n  );\n  const distanceDisplayCondition =\n    this._distanceDisplayConditionProperty.getValue(time);\n\n  const attributes = {\n    show: new ShowGeometryInstanceAttribute(\n      isAvailable &&\n        entity.isShowing &&\n        this._showProperty.getValue(time) &&\n        this._showOutlineProperty.getValue(time),\n    ),\n    color: ColorGeometryInstanceAttribute.fromColor(outlineColor),\n    distanceDisplayCondition:\n      DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(\n        distanceDisplayCondition,\n      ),\n    offset: undefined,\n  };\n\n  if (defined(this._options.offsetAttribute)) {\n    attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(\n      Property.getValueOrDefault(\n        this._terrainOffsetProperty,\n        time,\n        defaultOffset,\n        offsetScratch,\n      ),\n    );\n  }\n\n  return new GeometryInstance({\n    id: entity,\n    geometry: new EllipseOutlineGeometry(this._options),\n    attributes: attributes,\n  });\n};\n\nEllipseGeometryUpdater.prototype._computeCenter = function (time, result) {\n  return Property.getValueOrUndefined(this._entity.position, time, result);\n};\n\nEllipseGeometryUpdater.prototype._isHidden = function (entity, ellipse) {\n  const position = entity.position;\n\n  return (\n    !defined(position) ||\n    !defined(ellipse.semiMajorAxis) ||\n    !defined(ellipse.semiMinorAxis) ||\n    GeometryUpdater.prototype._isHidden.call(this, entity, ellipse)\n  );\n};\n\nEllipseGeometryUpdater.prototype._isDynamic = function (entity, ellipse) {\n  return (\n    !entity.position.isConstant || //\n    !ellipse.semiMajorAxis.isConstant || //\n    !ellipse.semiMinorAxis.isConstant || //\n    !Property.isConstant(ellipse.rotation) || //\n    !Property.isConstant(ellipse.height) || //\n    !Property.isConstant(ellipse.extrudedHeight) || //\n    !Property.isConstant(ellipse.granularity) || //\n    !Property.isConstant(ellipse.stRotation) || //\n    !Property.isConstant(ellipse.outlineWidth) || //\n    !Property.isConstant(ellipse.numberOfVerticalLines) || //\n    !Property.isConstant(ellipse.zIndex) || //\n    (this._onTerrain &&\n      !Property.isConstant(this._materialProperty) &&\n      !(this._materialProperty instanceof ColorMaterialProperty))\n  );\n};\n\nEllipseGeometryUpdater.prototype._setStaticOptions = function (\n  entity,\n  ellipse,\n) {\n  let heightValue = Property.getValueOrUndefined(\n    ellipse.height,\n    Iso8601.MINIMUM_VALUE,\n  );\n  const heightReferenceValue = Property.getValueOrDefault(\n    ellipse.heightReference,\n    Iso8601.MINIMUM_VALUE,\n    HeightReference.NONE,\n  );\n  let extrudedHeightValue = Property.getValueOrUndefined(\n    ellipse.extrudedHeight,\n    Iso8601.MINIMUM_VALUE,\n  );\n  const extrudedHeightReferenceValue = Property.getValueOrDefault(\n    ellipse.extrudedHeightReference,\n    Iso8601.MINIMUM_VALUE,\n    HeightReference.NONE,\n  );\n  if (defined(extrudedHeightValue) && !defined(heightValue)) {\n    heightValue = 0;\n  }\n\n  const options = this._options;\n  options.vertexFormat =\n    this._materialProperty instanceof ColorMaterialProperty\n      ? PerInstanceColorAppearance.VERTEX_FORMAT\n      : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n  options.center = entity.position.getValue(\n    Iso8601.MINIMUM_VALUE,\n    options.center,\n  );\n  options.semiMajorAxis = ellipse.semiMajorAxis.getValue(\n    Iso8601.MINIMUM_VALUE,\n    options.semiMajorAxis,\n  );\n  options.semiMinorAxis = ellipse.semiMinorAxis.getValue(\n    Iso8601.MINIMUM_VALUE,\n    options.semiMinorAxis,\n  );\n  options.rotation = Property.getValueOrUndefined(\n    ellipse.rotation,\n    Iso8601.MINIMUM_VALUE,\n  );\n  options.granularity = Property.getValueOrUndefined(\n    ellipse.granularity,\n    Iso8601.MINIMUM_VALUE,\n  );\n  options.stRotation = Property.getValueOrUndefined(\n    ellipse.stRotation,\n    Iso8601.MINIMUM_VALUE,\n  );\n  options.numberOfVerticalLines = Property.getValueOrUndefined(\n    ellipse.numberOfVerticalLines,\n    Iso8601.MINIMUM_VALUE,\n  );\n  options.offsetAttribute =\n    GroundGeometryUpdater.computeGeometryOffsetAttribute(\n      heightValue,\n      heightReferenceValue,\n      extrudedHeightValue,\n      extrudedHeightReferenceValue,\n    );\n  options.height = GroundGeometryUpdater.getGeometryHeight(\n    heightValue,\n    heightReferenceValue,\n  );\n\n  extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(\n    extrudedHeightValue,\n    extrudedHeightReferenceValue,\n  );\n  if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n    extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(\n      EllipseGeometry.computeRectangle(options, scratchRectangle),\n    ).minimumTerrainHeight;\n  }\n\n  options.extrudedHeight = extrudedHeightValue;\n};\n\nEllipseGeometryUpdater.DynamicGeometryUpdater = DynamicEllipseGeometryUpdater;\n\n/**\n * @private\n */\nfunction DynamicEllipseGeometryUpdater(\n  geometryUpdater,\n  primitives,\n  groundPrimitives,\n) {\n  DynamicGeometryUpdater.call(\n    this,\n    geometryUpdater,\n    primitives,\n    groundPrimitives,\n  );\n}\n\nif (defined(Object.create)) {\n  DynamicEllipseGeometryUpdater.prototype = Object.create(\n    DynamicGeometryUpdater.prototype,\n  );\n  DynamicEllipseGeometryUpdater.prototype.constructor =\n    DynamicEllipseGeometryUpdater;\n}\n\nDynamicEllipseGeometryUpdater.prototype._isHidden = function (\n  entity,\n  ellipse,\n  time,\n) {\n  const options = this._options;\n  return (\n    !defined(options.center) ||\n    !defined(options.semiMajorAxis) ||\n    !defined(options.semiMinorAxis) ||\n    DynamicGeometryUpdater.prototype._isHidden.call(this, entity, ellipse, time)\n  );\n};\n\nDynamicEllipseGeometryUpdater.prototype._setOptions = function (\n  entity,\n  ellipse,\n  time,\n) {\n  const options = this._options;\n  let heightValue = Property.getValueOrUndefined(ellipse.height, time);\n  const heightReferenceValue = Property.getValueOrDefault(\n    ellipse.heightReference,\n    time,\n    HeightReference.NONE,\n  );\n  let extrudedHeightValue = Property.getValueOrUndefined(\n    ellipse.extrudedHeight,\n    time,\n  );\n  const extrudedHeightReferenceValue = Property.getValueOrDefault(\n    ellipse.extrudedHeightReference,\n    time,\n    HeightReference.NONE,\n  );\n  if (defined(extrudedHeightValue) && !defined(heightValue)) {\n    heightValue = 0;\n  }\n\n  options.center = Property.getValueOrUndefined(\n    entity.position,\n    time,\n    options.center,\n  );\n  options.semiMajorAxis = Property.getValueOrUndefined(\n    ellipse.semiMajorAxis,\n    time,\n  );\n  options.semiMinorAxis = Property.getValueOrUndefined(\n    ellipse.semiMinorAxis,\n    time,\n  );\n  options.rotation = Property.getValueOrUndefined(ellipse.rotation, time);\n  options.granularity = Property.getValueOrUndefined(ellipse.granularity, time);\n  options.stRotation = Property.getValueOrUndefined(ellipse.stRotation, time);\n  options.numberOfVerticalLines = Property.getValueOrUndefined(\n    ellipse.numberOfVerticalLines,\n    time,\n  );\n  options.offsetAttribute =\n    GroundGeometryUpdater.computeGeometryOffsetAttribute(\n      heightValue,\n      heightReferenceValue,\n      extrudedHeightValue,\n      extrudedHeightReferenceValue,\n    );\n  options.height = GroundGeometryUpdater.getGeometryHeight(\n    heightValue,\n    heightReferenceValue,\n  );\n\n  extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(\n    extrudedHeightValue,\n    extrudedHeightReferenceValue,\n  );\n  if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n    extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(\n      EllipseGeometry.computeRectangle(options, scratchRectangle),\n    ).minimumTerrainHeight;\n  }\n\n  options.extrudedHeight = extrudedHeightValue;\n};\nexport default EllipseGeometryUpdater;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}