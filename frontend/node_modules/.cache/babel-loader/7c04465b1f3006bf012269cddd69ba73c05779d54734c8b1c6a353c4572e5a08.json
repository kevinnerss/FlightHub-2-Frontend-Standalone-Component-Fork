{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport combine from \"../Core/combine.js\";\nimport defined from \"../Core/defined.js\";\nimport ShaderBuilder from \"../Renderer/ShaderBuilder.js\";\nimport ShaderDestination from \"../Renderer/ShaderDestination.js\";\nimport VoxelUtils from \"../Shaders/Voxels/VoxelUtils.js\";\nimport VoxelFS from \"../Shaders/Voxels/VoxelFS.js\";\nimport VoxelVS from \"../Shaders/Voxels/VoxelVS.js\";\nimport IntersectionUtils from \"../Shaders/Voxels/IntersectionUtils.js\";\nimport IntersectDepth from \"../Shaders/Voxels/IntersectDepth.js\";\nimport IntersectPlane from \"../Shaders/Voxels/IntersectPlane.js\";\nimport IntersectLongitude from \"../Shaders/Voxels/IntersectLongitude.js\";\nimport IntersectBox from \"../Shaders/Voxels/IntersectBox.js\";\nimport IntersectCylinder from \"../Shaders/Voxels/IntersectCylinder.js\";\nimport IntersectEllipsoid from \"../Shaders/Voxels/IntersectEllipsoid.js\";\nimport Intersection from \"../Shaders/Voxels/Intersection.js\";\nimport convertLocalToBoxUv from \"../Shaders/Voxels/convertLocalToBoxUv.js\";\nimport convertLocalToCylinderUv from \"../Shaders/Voxels/convertLocalToCylinderUv.js\";\nimport convertLocalToEllipsoidUv from \"../Shaders/Voxels/convertLocalToEllipsoidUv.js\";\nimport Octree from \"../Shaders/Voxels/Octree.js\";\nimport Megatexture from \"../Shaders/Voxels/Megatexture.js\";\nimport VoxelMetadataOrder from \"./VoxelMetadataOrder.js\";\n\n/**\n * Set up render resources, including basic shader code, for rendering\n * a Voxel primitive.\n * The shader code generated by this function may be modified in later stages.\n * @constructor\n * @param {VoxelPrimitive} primitive\n *\n * @private\n */\nfunction VoxelRenderResources(primitive) {\n  const shaderBuilder = new ShaderBuilder();\n  /**\n   * An object used to build a shader incrementally. Each pipeline stage\n   * may add lines of shader code to this object.\n   *\n   * @type {ShaderBuilder}\n   * @readonly\n   *\n   * @private\n   */\n  this.shaderBuilder = shaderBuilder;\n\n  // Custom shader uniforms\n  const customShader = primitive._customShader;\n  const uniformMap = combine(primitive._uniformMap, customShader.uniformMap);\n  primitive._uniformMap = uniformMap;\n  const customShaderUniforms = customShader.uniforms;\n  for (const uniformName in customShaderUniforms) {\n    if (customShaderUniforms.hasOwnProperty(uniformName)) {\n      const uniform = customShaderUniforms[uniformName];\n      shaderBuilder.addUniform(uniform.type, uniformName, ShaderDestination.FRAGMENT);\n    }\n  }\n  // The reason this uniform is added by shader builder is because some of the\n  // dynamically generated shader code reads from it.\n  shaderBuilder.addUniform(\"sampler2D\", \"u_megatextureTextures[METADATA_COUNT]\", ShaderDestination.FRAGMENT);\n\n  /**\n   * A dictionary mapping uniform name to functions that return the uniform\n   * values.\n   * @private\n   * @type {Object<string, Function>}\n   */\n  this.uniformMap = uniformMap;\n  const clippingPlanes = primitive._clippingPlanes;\n  const clippingPlanesLength = defined(clippingPlanes) && clippingPlanes.enabled ? clippingPlanes.length : 0;\n  this.clippingPlanes = clippingPlanes;\n  this.clippingPlanesLength = clippingPlanesLength;\n  const renderBoundPlanes = primitive._shape.renderBoundPlanes;\n  const renderBoundPlanesLength = renderBoundPlanes?.length ?? 0;\n  this.renderBoundPlanes = renderBoundPlanes;\n  this.renderBoundPlanesLength = renderBoundPlanesLength;\n\n  // Build shader\n  shaderBuilder.addVertexLines([VoxelVS]);\n  if (primitive.provider.metadataOrder === VoxelMetadataOrder.Y_UP) {\n    shaderBuilder.addDefine(\"Y_UP_METADATA_ORDER\", undefined, ShaderDestination.FRAGMENT);\n  }\n  const shapeType = primitive._provider.shape;\n  if (shapeType === \"BOX\") {\n    shaderBuilder.addDefine(\"SHAPE_BOX\", undefined, ShaderDestination.FRAGMENT);\n  } else if (shapeType === \"CYLINDER\") {\n    shaderBuilder.addDefine(\"SHAPE_CYLINDER\", undefined, ShaderDestination.FRAGMENT);\n  } else if (shapeType === \"ELLIPSOID\") {\n    shaderBuilder.addDefine(\"SHAPE_ELLIPSOID\", undefined, ShaderDestination.FRAGMENT);\n  }\n  shaderBuilder.addFragmentLines([customShader.fragmentShaderText, \"#line 0\", Octree, VoxelUtils, Megatexture, IntersectionUtils, IntersectPlane, IntersectDepth]);\n  if (clippingPlanesLength > 0) {\n    shaderBuilder.addDefine(\"CLIPPING_PLANES\", undefined, ShaderDestination.FRAGMENT);\n    shaderBuilder.addDefine(\"CLIPPING_PLANES_COUNT\", clippingPlanesLength, ShaderDestination.FRAGMENT);\n    if (clippingPlanes.unionClippingRegions) {\n      shaderBuilder.addDefine(\"CLIPPING_PLANES_UNION\", undefined, ShaderDestination.FRAGMENT);\n    }\n  }\n  if (primitive._depthTest) {\n    shaderBuilder.addDefine(\"DEPTH_TEST\", undefined, ShaderDestination.FRAGMENT);\n  }\n  if (shapeType === \"BOX\") {\n    shaderBuilder.addFragmentLines([convertLocalToBoxUv, IntersectBox, Intersection]);\n  } else if (shapeType === \"CYLINDER\") {\n    shaderBuilder.addFragmentLines([convertLocalToCylinderUv, IntersectLongitude, IntersectCylinder, Intersection]);\n  } else if (shapeType === \"ELLIPSOID\") {\n    shaderBuilder.addFragmentLines([convertLocalToEllipsoidUv, IntersectLongitude, IntersectEllipsoid, Intersection]);\n  }\n  shaderBuilder.addFragmentLines([VoxelFS]);\n  const shape = primitive._shape;\n  const shapeDefines = shape.shaderDefines;\n  for (const key in shapeDefines) {\n    if (shapeDefines.hasOwnProperty(key)) {\n      let value = shapeDefines[key];\n      // if value is undefined, don't define it\n      // if value is true, define it to nothing\n      if (defined(value)) {\n        value = value === true ? undefined : value;\n        shaderBuilder.addDefine(key, value, ShaderDestination.FRAGMENT);\n      }\n    }\n  }\n\n  // Count how many intersections the shader will do.\n  let intersectionCount = shape.shaderMaximumIntersectionsLength;\n  if (clippingPlanesLength > 0) {\n    shaderBuilder.addDefine(\"CLIPPING_PLANES_INTERSECTION_INDEX\", intersectionCount, ShaderDestination.FRAGMENT);\n    if (clippingPlanesLength === 1) {\n      intersectionCount += 1;\n    } else if (clippingPlanes.unionClippingRegions) {\n      intersectionCount += 2;\n    } else {\n      intersectionCount += 1;\n    }\n  }\n  if (primitive._depthTest) {\n    shaderBuilder.addDefine(\"DEPTH_INTERSECTION_INDEX\", intersectionCount, ShaderDestination.FRAGMENT);\n    intersectionCount += 1;\n  }\n  shaderBuilder.addDefine(\"INTERSECTION_COUNT\", intersectionCount, ShaderDestination.FRAGMENT);\n\n  // Additional fragment shader defines\n  if (!Cartesian3.equals(primitive.paddingBefore, Cartesian3.ZERO) || !Cartesian3.equals(primitive.paddingAfter, Cartesian3.ZERO)) {\n    shaderBuilder.addDefine(\"PADDING\", undefined, ShaderDestination.FRAGMENT);\n  }\n  // Allow reading from log depth texture, but don't write log depth anywhere.\n  // Note: This needs to be set even if depthTest is off because it affects the\n  // derived command system.\n  if (primitive._useLogDepth) {\n    shaderBuilder.addDefine(\"LOG_DEPTH_READ_ONLY\", undefined, ShaderDestination.FRAGMENT);\n  }\n  if (primitive._nearestSampling) {\n    shaderBuilder.addDefine(\"NEAREST_SAMPLING\", undefined, ShaderDestination.FRAGMENT);\n  }\n  const traversal = primitive._traversal;\n  shaderBuilder.addDefine(\"SAMPLE_COUNT\", `${traversal._sampleCount}`, ShaderDestination.FRAGMENT);\n}\nexport default VoxelRenderResources;","map":{"version":3,"names":["Cartesian3","combine","defined","ShaderBuilder","ShaderDestination","VoxelUtils","VoxelFS","VoxelVS","IntersectionUtils","IntersectDepth","IntersectPlane","IntersectLongitude","IntersectBox","IntersectCylinder","IntersectEllipsoid","Intersection","convertLocalToBoxUv","convertLocalToCylinderUv","convertLocalToEllipsoidUv","Octree","Megatexture","VoxelMetadataOrder","VoxelRenderResources","primitive","shaderBuilder","customShader","_customShader","uniformMap","_uniformMap","customShaderUniforms","uniforms","uniformName","hasOwnProperty","uniform","addUniform","type","FRAGMENT","clippingPlanes","_clippingPlanes","clippingPlanesLength","enabled","length","renderBoundPlanes","_shape","renderBoundPlanesLength","addVertexLines","provider","metadataOrder","Y_UP","addDefine","undefined","shapeType","_provider","shape","addFragmentLines","fragmentShaderText","unionClippingRegions","_depthTest","shapeDefines","shaderDefines","key","value","intersectionCount","shaderMaximumIntersectionsLength","equals","paddingBefore","ZERO","paddingAfter","_useLogDepth","_nearestSampling","traversal","_traversal","_sampleCount"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/VoxelRenderResources.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport combine from \"../Core/combine.js\";\nimport defined from \"../Core/defined.js\";\nimport ShaderBuilder from \"../Renderer/ShaderBuilder.js\";\nimport ShaderDestination from \"../Renderer/ShaderDestination.js\";\nimport VoxelUtils from \"../Shaders/Voxels/VoxelUtils.js\";\nimport VoxelFS from \"../Shaders/Voxels/VoxelFS.js\";\nimport VoxelVS from \"../Shaders/Voxels/VoxelVS.js\";\nimport IntersectionUtils from \"../Shaders/Voxels/IntersectionUtils.js\";\nimport IntersectDepth from \"../Shaders/Voxels/IntersectDepth.js\";\nimport IntersectPlane from \"../Shaders/Voxels/IntersectPlane.js\";\nimport IntersectLongitude from \"../Shaders/Voxels/IntersectLongitude.js\";\nimport IntersectBox from \"../Shaders/Voxels/IntersectBox.js\";\nimport IntersectCylinder from \"../Shaders/Voxels/IntersectCylinder.js\";\nimport IntersectEllipsoid from \"../Shaders/Voxels/IntersectEllipsoid.js\";\nimport Intersection from \"../Shaders/Voxels/Intersection.js\";\nimport convertLocalToBoxUv from \"../Shaders/Voxels/convertLocalToBoxUv.js\";\nimport convertLocalToCylinderUv from \"../Shaders/Voxels/convertLocalToCylinderUv.js\";\nimport convertLocalToEllipsoidUv from \"../Shaders/Voxels/convertLocalToEllipsoidUv.js\";\nimport Octree from \"../Shaders/Voxels/Octree.js\";\nimport Megatexture from \"../Shaders/Voxels/Megatexture.js\";\nimport VoxelMetadataOrder from \"./VoxelMetadataOrder.js\";\n\n/**\n * Set up render resources, including basic shader code, for rendering\n * a Voxel primitive.\n * The shader code generated by this function may be modified in later stages.\n * @constructor\n * @param {VoxelPrimitive} primitive\n *\n * @private\n */\nfunction VoxelRenderResources(primitive) {\n  const shaderBuilder = new ShaderBuilder();\n  /**\n   * An object used to build a shader incrementally. Each pipeline stage\n   * may add lines of shader code to this object.\n   *\n   * @type {ShaderBuilder}\n   * @readonly\n   *\n   * @private\n   */\n  this.shaderBuilder = shaderBuilder;\n\n  // Custom shader uniforms\n  const customShader = primitive._customShader;\n  const uniformMap = combine(primitive._uniformMap, customShader.uniformMap);\n  primitive._uniformMap = uniformMap;\n\n  const customShaderUniforms = customShader.uniforms;\n  for (const uniformName in customShaderUniforms) {\n    if (customShaderUniforms.hasOwnProperty(uniformName)) {\n      const uniform = customShaderUniforms[uniformName];\n      shaderBuilder.addUniform(\n        uniform.type,\n        uniformName,\n        ShaderDestination.FRAGMENT,\n      );\n    }\n  }\n  // The reason this uniform is added by shader builder is because some of the\n  // dynamically generated shader code reads from it.\n  shaderBuilder.addUniform(\n    \"sampler2D\",\n    \"u_megatextureTextures[METADATA_COUNT]\",\n    ShaderDestination.FRAGMENT,\n  );\n\n  /**\n   * A dictionary mapping uniform name to functions that return the uniform\n   * values.\n   * @private\n   * @type {Object<string, Function>}\n   */\n  this.uniformMap = uniformMap;\n\n  const clippingPlanes = primitive._clippingPlanes;\n  const clippingPlanesLength =\n    defined(clippingPlanes) && clippingPlanes.enabled\n      ? clippingPlanes.length\n      : 0;\n\n  this.clippingPlanes = clippingPlanes;\n  this.clippingPlanesLength = clippingPlanesLength;\n\n  const renderBoundPlanes = primitive._shape.renderBoundPlanes;\n  const renderBoundPlanesLength = renderBoundPlanes?.length ?? 0;\n\n  this.renderBoundPlanes = renderBoundPlanes;\n  this.renderBoundPlanesLength = renderBoundPlanesLength;\n\n  // Build shader\n  shaderBuilder.addVertexLines([VoxelVS]);\n\n  if (primitive.provider.metadataOrder === VoxelMetadataOrder.Y_UP) {\n    shaderBuilder.addDefine(\n      \"Y_UP_METADATA_ORDER\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n  const shapeType = primitive._provider.shape;\n  if (shapeType === \"BOX\") {\n    shaderBuilder.addDefine(\"SHAPE_BOX\", undefined, ShaderDestination.FRAGMENT);\n  } else if (shapeType === \"CYLINDER\") {\n    shaderBuilder.addDefine(\n      \"SHAPE_CYLINDER\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  } else if (shapeType === \"ELLIPSOID\") {\n    shaderBuilder.addDefine(\n      \"SHAPE_ELLIPSOID\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  shaderBuilder.addFragmentLines([\n    customShader.fragmentShaderText,\n    \"#line 0\",\n    Octree,\n    VoxelUtils,\n    Megatexture,\n    IntersectionUtils,\n    IntersectPlane,\n    IntersectDepth,\n  ]);\n\n  if (clippingPlanesLength > 0) {\n    shaderBuilder.addDefine(\n      \"CLIPPING_PLANES\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n    shaderBuilder.addDefine(\n      \"CLIPPING_PLANES_COUNT\",\n      clippingPlanesLength,\n      ShaderDestination.FRAGMENT,\n    );\n    if (clippingPlanes.unionClippingRegions) {\n      shaderBuilder.addDefine(\n        \"CLIPPING_PLANES_UNION\",\n        undefined,\n        ShaderDestination.FRAGMENT,\n      );\n    }\n  }\n\n  if (primitive._depthTest) {\n    shaderBuilder.addDefine(\n      \"DEPTH_TEST\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n\n  if (shapeType === \"BOX\") {\n    shaderBuilder.addFragmentLines([\n      convertLocalToBoxUv,\n      IntersectBox,\n      Intersection,\n    ]);\n  } else if (shapeType === \"CYLINDER\") {\n    shaderBuilder.addFragmentLines([\n      convertLocalToCylinderUv,\n      IntersectLongitude,\n      IntersectCylinder,\n      Intersection,\n    ]);\n  } else if (shapeType === \"ELLIPSOID\") {\n    shaderBuilder.addFragmentLines([\n      convertLocalToEllipsoidUv,\n      IntersectLongitude,\n      IntersectEllipsoid,\n      Intersection,\n    ]);\n  }\n\n  shaderBuilder.addFragmentLines([VoxelFS]);\n\n  const shape = primitive._shape;\n  const shapeDefines = shape.shaderDefines;\n  for (const key in shapeDefines) {\n    if (shapeDefines.hasOwnProperty(key)) {\n      let value = shapeDefines[key];\n      // if value is undefined, don't define it\n      // if value is true, define it to nothing\n      if (defined(value)) {\n        value = value === true ? undefined : value;\n        shaderBuilder.addDefine(key, value, ShaderDestination.FRAGMENT);\n      }\n    }\n  }\n\n  // Count how many intersections the shader will do.\n  let intersectionCount = shape.shaderMaximumIntersectionsLength;\n  if (clippingPlanesLength > 0) {\n    shaderBuilder.addDefine(\n      \"CLIPPING_PLANES_INTERSECTION_INDEX\",\n      intersectionCount,\n      ShaderDestination.FRAGMENT,\n    );\n    if (clippingPlanesLength === 1) {\n      intersectionCount += 1;\n    } else if (clippingPlanes.unionClippingRegions) {\n      intersectionCount += 2;\n    } else {\n      intersectionCount += 1;\n    }\n  }\n  if (primitive._depthTest) {\n    shaderBuilder.addDefine(\n      \"DEPTH_INTERSECTION_INDEX\",\n      intersectionCount,\n      ShaderDestination.FRAGMENT,\n    );\n    intersectionCount += 1;\n  }\n  shaderBuilder.addDefine(\n    \"INTERSECTION_COUNT\",\n    intersectionCount,\n    ShaderDestination.FRAGMENT,\n  );\n\n  // Additional fragment shader defines\n  if (\n    !Cartesian3.equals(primitive.paddingBefore, Cartesian3.ZERO) ||\n    !Cartesian3.equals(primitive.paddingAfter, Cartesian3.ZERO)\n  ) {\n    shaderBuilder.addDefine(\"PADDING\", undefined, ShaderDestination.FRAGMENT);\n  }\n  // Allow reading from log depth texture, but don't write log depth anywhere.\n  // Note: This needs to be set even if depthTest is off because it affects the\n  // derived command system.\n  if (primitive._useLogDepth) {\n    shaderBuilder.addDefine(\n      \"LOG_DEPTH_READ_ONLY\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n  if (primitive._nearestSampling) {\n    shaderBuilder.addDefine(\n      \"NEAREST_SAMPLING\",\n      undefined,\n      ShaderDestination.FRAGMENT,\n    );\n  }\n  const traversal = primitive._traversal;\n  shaderBuilder.addDefine(\n    \"SAMPLE_COUNT\",\n    `${traversal._sampleCount}`,\n    ShaderDestination.FRAGMENT,\n  );\n}\n\nexport default VoxelRenderResources;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}