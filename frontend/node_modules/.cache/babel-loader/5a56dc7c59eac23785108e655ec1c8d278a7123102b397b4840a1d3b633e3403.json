{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CzmBuiltins from \"../Shaders/Builtin/CzmBuiltins.js\";\nimport AutomaticUniforms from \"./AutomaticUniforms.js\";\nimport demodernizeShader from \"./demodernizeShader.js\";\nfunction removeComments(source) {\n  // remove inline comments\n  source = source.replace(/\\/\\/.*/g, \"\");\n  // remove multiline comment block\n  return source.replace(/\\/\\*\\*[\\s\\S]*?\\*\\//gm, function (match) {\n    // preserve the number of lines in the comment block so the line numbers will be correct when debugging shaders\n    const numberOfLines = match.match(/\\n/gm).length;\n    let replacement = \"\";\n    for (let lineNumber = 0; lineNumber < numberOfLines; ++lineNumber) {\n      replacement += \"\\n\";\n    }\n    return replacement;\n  });\n}\nfunction getDependencyNode(name, glslSource, nodes) {\n  let dependencyNode;\n\n  // check if already loaded\n  for (let i = 0; i < nodes.length; ++i) {\n    if (nodes[i].name === name) {\n      dependencyNode = nodes[i];\n    }\n  }\n  if (!defined(dependencyNode)) {\n    // strip doc comments so we don't accidentally try to determine a dependency for something found\n    // in a comment\n    glslSource = removeComments(glslSource);\n\n    // create new node\n    dependencyNode = {\n      name: name,\n      glslSource: glslSource,\n      dependsOn: [],\n      requiredBy: [],\n      evaluated: false\n    };\n    nodes.push(dependencyNode);\n  }\n  return dependencyNode;\n}\nfunction generateDependencies(currentNode, dependencyNodes) {\n  if (currentNode.evaluated) {\n    return;\n  }\n  currentNode.evaluated = true;\n\n  // identify all dependencies that are referenced from this glsl source code\n  let czmMatches = currentNode.glslSource.match(/\\bczm_[a-zA-Z0-9_]*/g);\n  if (defined(czmMatches) && czmMatches !== null) {\n    // remove duplicates\n    czmMatches = czmMatches.filter(function (elem, pos) {\n      return czmMatches.indexOf(elem) === pos;\n    });\n    czmMatches.forEach(function (element) {\n      if (element !== currentNode.name && ShaderSource._czmBuiltinsAndUniforms.hasOwnProperty(element)) {\n        const referencedNode = getDependencyNode(element, ShaderSource._czmBuiltinsAndUniforms[element], dependencyNodes);\n        currentNode.dependsOn.push(referencedNode);\n        referencedNode.requiredBy.push(currentNode);\n\n        // recursive call to find any dependencies of the new node\n        generateDependencies(referencedNode, dependencyNodes);\n      }\n    });\n  }\n}\nfunction sortDependencies(dependencyNodes) {\n  const nodesWithoutIncomingEdges = [];\n  const allNodes = [];\n  while (dependencyNodes.length > 0) {\n    const node = dependencyNodes.pop();\n    allNodes.push(node);\n    if (node.requiredBy.length === 0) {\n      nodesWithoutIncomingEdges.push(node);\n    }\n  }\n  while (nodesWithoutIncomingEdges.length > 0) {\n    const currentNode = nodesWithoutIncomingEdges.shift();\n    dependencyNodes.push(currentNode);\n    for (let i = 0; i < currentNode.dependsOn.length; ++i) {\n      // remove the edge from the graph\n      const referencedNode = currentNode.dependsOn[i];\n      const index = referencedNode.requiredBy.indexOf(currentNode);\n      referencedNode.requiredBy.splice(index, 1);\n\n      // if referenced node has no more incoming edges, add to list\n      if (referencedNode.requiredBy.length === 0) {\n        nodesWithoutIncomingEdges.push(referencedNode);\n      }\n    }\n  }\n\n  // if there are any nodes left with incoming edges, then there was a circular dependency somewhere in the graph\n  const badNodes = [];\n  for (let j = 0; j < allNodes.length; ++j) {\n    if (allNodes[j].requiredBy.length !== 0) {\n      badNodes.push(allNodes[j]);\n    }\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (badNodes.length !== 0) {\n    let message = \"A circular dependency was found in the following built-in functions/structs/constants: \\n\";\n    for (let k = 0; k < badNodes.length; ++k) {\n      message = `${message + badNodes[k].name}\\n`;\n    }\n    throw new DeveloperError(message);\n  }\n  //>>includeEnd('debug');\n}\nfunction getBuiltinsAndAutomaticUniforms(shaderSource) {\n  // generate a dependency graph for builtin functions\n  const dependencyNodes = [];\n  const root = getDependencyNode(\"main\", shaderSource, dependencyNodes);\n  generateDependencies(root, dependencyNodes);\n  sortDependencies(dependencyNodes);\n\n  // Concatenate the source code for the function dependencies.\n  // Iterate in reverse so that dependent items are declared before they are used.\n  let builtinsSource = \"\";\n  for (let i = dependencyNodes.length - 1; i >= 0; --i) {\n    builtinsSource = `${builtinsSource + dependencyNodes[i].glslSource}\\n`;\n  }\n  return builtinsSource.replace(root.glslSource, \"\");\n}\nfunction combineShader(shaderSource, isFragmentShader, context) {\n  let i;\n  let length;\n\n  // Combine shader sources, generally for pseudo-polymorphism, e.g., czm_getMaterial.\n  let combinedSources = \"\";\n  const sources = shaderSource.sources;\n  if (defined(sources)) {\n    for (i = 0, length = sources.length; i < length; ++i) {\n      // #line needs to be on its own line.\n      combinedSources += `\\n#line 0\\n${sources[i]}`;\n    }\n  }\n  combinedSources = removeComments(combinedSources);\n\n  // Extract existing shader version from sources\n  let version;\n  combinedSources = combinedSources.replace(/#version\\s+(.*?)\\n/gm, function (match, group1) {\n    //>>includeStart('debug', pragmas.debug);\n    if (defined(version) && version !== group1) {\n      throw new DeveloperError(`inconsistent versions found: ${version} and ${group1}`);\n    }\n    //>>includeEnd('debug');\n\n    // Extract #version to put at the top\n    version = group1;\n\n    // Replace original #version directive with a new line so the line numbers\n    // are not off by one.  There can be only one #version directive\n    // and it must appear at the top of the source, only preceded by\n    // whitespace and comments.\n    return \"\\n\";\n  });\n\n  // Extract shader extensions from sources\n  const extensions = [];\n  combinedSources = combinedSources.replace(/#extension.*\\n/gm, function (match) {\n    // Extract extension to put at the top\n    extensions.push(match);\n\n    // Replace original #extension directive with a new line so the line numbers\n    // are not off by one.\n    return \"\\n\";\n  });\n\n  // Remove precision qualifier\n  combinedSources = combinedSources.replace(/precision\\s(lowp|mediump|highp)\\s(float|int);/, \"\");\n\n  // Replace main() for picked if desired.\n  const pickColorQualifier = shaderSource.pickColorQualifier;\n  if (defined(pickColorQualifier)) {\n    combinedSources = ShaderSource.createPickFragmentShaderSource(combinedSources, pickColorQualifier);\n  }\n\n  // combine into single string\n  let result = \"\";\n  const extensionsLength = extensions.length;\n  for (i = 0; i < extensionsLength; i++) {\n    result += extensions[i];\n  }\n  if (isFragmentShader) {\n    // If high precision isn't support replace occurrences of highp with mediump\n    // The highp keyword is not always available on older mobile devices\n    // See https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#In_WebGL_1_highp_float_support_is_optional_in_fragment_shaders\n    result += \"\\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\n\\\n    precision highp float;\\n\\\n    precision highp int;\\n\\\n#else\\n\\\n    precision mediump float;\\n\\\n    precision mediump int;\\n\\\n    #define highp mediump\\n\\\n#endif\\n\\n\";\n  }\n\n  // Prepend #defines for uber-shaders\n  const defines = shaderSource.defines;\n  if (defined(defines)) {\n    for (i = 0, length = defines.length; i < length; ++i) {\n      const define = defines[i];\n      if (define.length !== 0) {\n        result += `#define ${define}\\n`;\n      }\n    }\n  }\n\n  // Define a constant for the OES_texture_float_linear extension since WebGL does not.\n  if (context.textureFloatLinear) {\n    result += \"#define OES_texture_float_linear\\n\\n\";\n  }\n\n  // Define a constant for the OES_texture_float extension since WebGL does not.\n  if (context.floatingPointTexture) {\n    result += \"#define OES_texture_float\\n\\n\";\n  }\n\n  // append built-ins\n  let builtinSources = \"\";\n  if (shaderSource.includeBuiltIns) {\n    builtinSources = getBuiltinsAndAutomaticUniforms(combinedSources);\n  }\n\n  // reset line number\n  result += \"\\n#line 0\\n\";\n\n  // append actual source\n  const combinedShader = builtinSources + combinedSources;\n  if (context.webgl2 && isFragmentShader && !/layout\\s*\\(location\\s*=\\s*0\\)\\s*out\\s+vec4\\s+out_FragColor;/g.test(combinedShader) && !/czm_out_FragColor/g.test(combinedShader) && /out_FragColor/g.test(combinedShader)) {\n    result += \"layout(location = 0) out vec4 out_FragColor;\\n\\n\";\n  }\n  result += builtinSources;\n  result += combinedSources;\n\n  // modernize the source\n  if (!context.webgl2) {\n    result = demodernizeShader(result, isFragmentShader);\n  } else {\n    result = `#version 300 es\\n${result}`;\n  }\n  return result;\n}\n\n/**\n * An object containing various inputs that will be combined to form a final GLSL shader string.\n *\n * @param {object} [options] Object with the following properties:\n * @param {string[]} [options.sources] An array of strings to combine containing GLSL code for the shader.\n * @param {string[]} [options.defines] An array of strings containing GLSL identifiers to <code>#define</code>.\n * @param {string} [options.pickColorQualifier] The GLSL qualifier, <code>uniform</code> or <code>in</code>, for the input <code>czm_pickColor</code>.  When defined, a pick fragment shader is generated.\n * @param {boolean} [options.includeBuiltIns=true] If true, referenced built-in functions will be included with the combined shader.  Set to false if this shader will become a source in another shader, to avoid duplicating functions.\n *\n * @exception {DeveloperError} options.pickColorQualifier must be 'uniform' or 'in'.\n *\n * @example\n * // 1. Prepend #defines to a shader\n * const source = new Cesium.ShaderSource({\n *   defines : ['WHITE'],\n *   sources : ['void main() { \\n#ifdef WHITE\\n out_FragColor = vec4(1.0); \\n#else\\n out_FragColor = vec4(0.0); \\n#endif\\n }']\n * });\n *\n * // 2. Modify a fragment shader for picking\n * const source2 = new Cesium.ShaderSource({\n *   sources : ['void main() { out_FragColor = vec4(1.0); }'],\n *   pickColorQualifier : 'uniform'\n * });\n *\n * @private\n */\nfunction ShaderSource(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const pickColorQualifier = options.pickColorQualifier;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(pickColorQualifier) && pickColorQualifier !== \"uniform\" && pickColorQualifier !== \"in\") {\n    throw new DeveloperError(\"options.pickColorQualifier must be 'uniform' or 'in'.\");\n  }\n  //>>includeEnd('debug');\n\n  this.defines = defined(options.defines) ? options.defines.slice(0) : [];\n  this.sources = defined(options.sources) ? options.sources.slice(0) : [];\n  this.pickColorQualifier = pickColorQualifier;\n  this.includeBuiltIns = options.includeBuiltIns ?? true;\n}\nShaderSource.prototype.clone = function () {\n  return new ShaderSource({\n    sources: this.sources,\n    defines: this.defines,\n    pickColorQualifier: this.pickColorQualifier,\n    includeBuiltIns: this.includeBuiltIns\n  });\n};\nShaderSource.replaceMain = function (source, renamedMain) {\n  renamedMain = `void ${renamedMain}()`;\n  return source.replace(/void\\s+main\\s*\\(\\s*(?:void)?\\s*\\)/g, renamedMain);\n};\n\n/**\n * Since {@link ShaderSource#createCombinedVertexShader} and\n * {@link ShaderSource#createCombinedFragmentShader} are both expensive to\n * compute, create a simpler string key for lookups in the {@link ShaderCache}.\n *\n * @returns {string} A key for identifying this shader\n *\n * @private\n */\nShaderSource.prototype.getCacheKey = function () {\n  // Sort defines to make the key comparison deterministic\n  const sortedDefines = this.defines.slice().sort();\n  const definesKey = sortedDefines.join(\",\");\n  const pickKey = this.pickColorQualifier;\n  const builtinsKey = this.includeBuiltIns;\n  const sourcesKey = this.sources.join(\"\\n\");\n  return `${definesKey}:${pickKey}:${builtinsKey}:${sourcesKey}`;\n};\n\n/**\n * Create a single string containing the full, combined vertex shader with all dependencies and defines.\n *\n * @param {Context} context The current rendering context\n *\n * @returns {string} The combined shader string.\n */\nShaderSource.prototype.createCombinedVertexShader = function (context) {\n  return combineShader(this, false, context);\n};\n\n/**\n * Create a single string containing the full, combined fragment shader with all dependencies and defines.\n *\n * @param {Context} context The current rendering context\n *\n * @returns {string} The combined shader string.\n */\nShaderSource.prototype.createCombinedFragmentShader = function (context) {\n  return combineShader(this, true, context);\n};\n\n/**\n * For ShaderProgram testing\n * @private\n */\nShaderSource._czmBuiltinsAndUniforms = {};\n\n// combine automatic uniforms and Cesium built-ins\nfor (const builtinName in CzmBuiltins) {\n  if (CzmBuiltins.hasOwnProperty(builtinName)) {\n    ShaderSource._czmBuiltinsAndUniforms[builtinName] = CzmBuiltins[builtinName];\n  }\n}\nfor (const uniformName in AutomaticUniforms) {\n  if (AutomaticUniforms.hasOwnProperty(uniformName)) {\n    const uniform = AutomaticUniforms[uniformName];\n    if (typeof uniform.getDeclaration === \"function\") {\n      ShaderSource._czmBuiltinsAndUniforms[uniformName] = uniform.getDeclaration(uniformName);\n    }\n  }\n}\nShaderSource.createPickVertexShaderSource = function (vertexShaderSource) {\n  const renamedVS = ShaderSource.replaceMain(vertexShaderSource, \"czm_old_main\");\n  const pickMain = \"in vec4 pickColor; \\n\" + \"out vec4 czm_pickColor; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    czm_old_main(); \\n\" + \"    czm_pickColor = pickColor; \\n\" + \"}\";\n  return `${renamedVS}\\n${pickMain}`;\n};\nShaderSource.createPickFragmentShaderSource = function (fragmentShaderSource, pickColorQualifier) {\n  const renamedFS = ShaderSource.replaceMain(fragmentShaderSource, \"czm_old_main\");\n  const pickMain = `${pickColorQualifier} vec4 czm_pickColor; \\n` + `void main() \\n` + `{ \\n` + `    czm_old_main(); \\n` + `    if (out_FragColor.a == 0.0) { \\n` + `       discard; \\n` + `    } \\n` + `    out_FragColor = czm_pickColor; \\n` + `}`;\n  return `${renamedFS}\\n${pickMain}`;\n};\nfunction containsDefine(shaderSource, define) {\n  const defines = shaderSource.defines;\n  const definesLength = defines.length;\n  for (let i = 0; i < definesLength; ++i) {\n    if (defines[i] === define) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction containsString(shaderSource, string) {\n  const sources = shaderSource.sources;\n  const sourcesLength = sources.length;\n  for (let i = 0; i < sourcesLength; ++i) {\n    if (sources[i].indexOf(string) !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction findFirstString(shaderSource, strings) {\n  const stringsLength = strings.length;\n  for (let i = 0; i < stringsLength; ++i) {\n    const string = strings[i];\n    if (containsString(shaderSource, string)) {\n      return string;\n    }\n  }\n  return undefined;\n}\nconst normalVaryingNames = [\"v_normalEC\", \"v_normal\"];\nShaderSource.findNormalVarying = function (shaderSource) {\n  // Fix for Model: the shader text always has the word v_normalEC\n  // wrapped in an #ifdef so instead of looking for v_normalEC look for the define\n  if (containsString(shaderSource, \"#ifdef HAS_NORMALS\")) {\n    if (containsDefine(shaderSource, \"HAS_NORMALS\")) {\n      return \"v_normalEC\";\n    }\n    return undefined;\n  }\n  return findFirstString(shaderSource, normalVaryingNames);\n};\nconst positionVaryingNames = [\"v_positionEC\"];\nShaderSource.findPositionVarying = function (shaderSource) {\n  return findFirstString(shaderSource, positionVaryingNames);\n};\nexport default ShaderSource;","map":{"version":3,"names":["Frozen","defined","DeveloperError","CzmBuiltins","AutomaticUniforms","demodernizeShader","removeComments","source","replace","match","numberOfLines","length","replacement","lineNumber","getDependencyNode","name","glslSource","nodes","dependencyNode","i","dependsOn","requiredBy","evaluated","push","generateDependencies","currentNode","dependencyNodes","czmMatches","filter","elem","pos","indexOf","forEach","element","ShaderSource","_czmBuiltinsAndUniforms","hasOwnProperty","referencedNode","sortDependencies","nodesWithoutIncomingEdges","allNodes","node","pop","shift","index","splice","badNodes","j","message","k","getBuiltinsAndAutomaticUniforms","shaderSource","root","builtinsSource","combineShader","isFragmentShader","context","combinedSources","sources","version","group1","extensions","pickColorQualifier","createPickFragmentShaderSource","result","extensionsLength","defines","define","textureFloatLinear","floatingPointTexture","builtinSources","includeBuiltIns","combinedShader","webgl2","test","options","EMPTY_OBJECT","slice","prototype","clone","replaceMain","renamedMain","getCacheKey","sortedDefines","sort","definesKey","join","pickKey","builtinsKey","sourcesKey","createCombinedVertexShader","createCombinedFragmentShader","builtinName","uniformName","uniform","getDeclaration","createPickVertexShaderSource","vertexShaderSource","renamedVS","pickMain","fragmentShaderSource","renamedFS","containsDefine","definesLength","containsString","string","sourcesLength","findFirstString","strings","stringsLength","undefined","normalVaryingNames","findNormalVarying","positionVaryingNames","findPositionVarying"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Renderer/ShaderSource.js"],"sourcesContent":["import Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CzmBuiltins from \"../Shaders/Builtin/CzmBuiltins.js\";\nimport AutomaticUniforms from \"./AutomaticUniforms.js\";\nimport demodernizeShader from \"./demodernizeShader.js\";\n\nfunction removeComments(source) {\n  // remove inline comments\n  source = source.replace(/\\/\\/.*/g, \"\");\n  // remove multiline comment block\n  return source.replace(/\\/\\*\\*[\\s\\S]*?\\*\\//gm, function (match) {\n    // preserve the number of lines in the comment block so the line numbers will be correct when debugging shaders\n    const numberOfLines = match.match(/\\n/gm).length;\n    let replacement = \"\";\n    for (let lineNumber = 0; lineNumber < numberOfLines; ++lineNumber) {\n      replacement += \"\\n\";\n    }\n    return replacement;\n  });\n}\n\nfunction getDependencyNode(name, glslSource, nodes) {\n  let dependencyNode;\n\n  // check if already loaded\n  for (let i = 0; i < nodes.length; ++i) {\n    if (nodes[i].name === name) {\n      dependencyNode = nodes[i];\n    }\n  }\n\n  if (!defined(dependencyNode)) {\n    // strip doc comments so we don't accidentally try to determine a dependency for something found\n    // in a comment\n    glslSource = removeComments(glslSource);\n\n    // create new node\n    dependencyNode = {\n      name: name,\n      glslSource: glslSource,\n      dependsOn: [],\n      requiredBy: [],\n      evaluated: false,\n    };\n    nodes.push(dependencyNode);\n  }\n\n  return dependencyNode;\n}\n\nfunction generateDependencies(currentNode, dependencyNodes) {\n  if (currentNode.evaluated) {\n    return;\n  }\n\n  currentNode.evaluated = true;\n\n  // identify all dependencies that are referenced from this glsl source code\n  let czmMatches = currentNode.glslSource.match(/\\bczm_[a-zA-Z0-9_]*/g);\n  if (defined(czmMatches) && czmMatches !== null) {\n    // remove duplicates\n    czmMatches = czmMatches.filter(function (elem, pos) {\n      return czmMatches.indexOf(elem) === pos;\n    });\n\n    czmMatches.forEach(function (element) {\n      if (\n        element !== currentNode.name &&\n        ShaderSource._czmBuiltinsAndUniforms.hasOwnProperty(element)\n      ) {\n        const referencedNode = getDependencyNode(\n          element,\n          ShaderSource._czmBuiltinsAndUniforms[element],\n          dependencyNodes,\n        );\n        currentNode.dependsOn.push(referencedNode);\n        referencedNode.requiredBy.push(currentNode);\n\n        // recursive call to find any dependencies of the new node\n        generateDependencies(referencedNode, dependencyNodes);\n      }\n    });\n  }\n}\n\nfunction sortDependencies(dependencyNodes) {\n  const nodesWithoutIncomingEdges = [];\n  const allNodes = [];\n\n  while (dependencyNodes.length > 0) {\n    const node = dependencyNodes.pop();\n    allNodes.push(node);\n\n    if (node.requiredBy.length === 0) {\n      nodesWithoutIncomingEdges.push(node);\n    }\n  }\n\n  while (nodesWithoutIncomingEdges.length > 0) {\n    const currentNode = nodesWithoutIncomingEdges.shift();\n\n    dependencyNodes.push(currentNode);\n\n    for (let i = 0; i < currentNode.dependsOn.length; ++i) {\n      // remove the edge from the graph\n      const referencedNode = currentNode.dependsOn[i];\n      const index = referencedNode.requiredBy.indexOf(currentNode);\n      referencedNode.requiredBy.splice(index, 1);\n\n      // if referenced node has no more incoming edges, add to list\n      if (referencedNode.requiredBy.length === 0) {\n        nodesWithoutIncomingEdges.push(referencedNode);\n      }\n    }\n  }\n\n  // if there are any nodes left with incoming edges, then there was a circular dependency somewhere in the graph\n  const badNodes = [];\n  for (let j = 0; j < allNodes.length; ++j) {\n    if (allNodes[j].requiredBy.length !== 0) {\n      badNodes.push(allNodes[j]);\n    }\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (badNodes.length !== 0) {\n    let message =\n      \"A circular dependency was found in the following built-in functions/structs/constants: \\n\";\n    for (let k = 0; k < badNodes.length; ++k) {\n      message = `${message + badNodes[k].name}\\n`;\n    }\n    throw new DeveloperError(message);\n  }\n  //>>includeEnd('debug');\n}\n\nfunction getBuiltinsAndAutomaticUniforms(shaderSource) {\n  // generate a dependency graph for builtin functions\n  const dependencyNodes = [];\n  const root = getDependencyNode(\"main\", shaderSource, dependencyNodes);\n  generateDependencies(root, dependencyNodes);\n  sortDependencies(dependencyNodes);\n\n  // Concatenate the source code for the function dependencies.\n  // Iterate in reverse so that dependent items are declared before they are used.\n  let builtinsSource = \"\";\n  for (let i = dependencyNodes.length - 1; i >= 0; --i) {\n    builtinsSource = `${builtinsSource + dependencyNodes[i].glslSource}\\n`;\n  }\n\n  return builtinsSource.replace(root.glslSource, \"\");\n}\n\nfunction combineShader(shaderSource, isFragmentShader, context) {\n  let i;\n  let length;\n\n  // Combine shader sources, generally for pseudo-polymorphism, e.g., czm_getMaterial.\n  let combinedSources = \"\";\n  const sources = shaderSource.sources;\n  if (defined(sources)) {\n    for (i = 0, length = sources.length; i < length; ++i) {\n      // #line needs to be on its own line.\n      combinedSources += `\\n#line 0\\n${sources[i]}`;\n    }\n  }\n\n  combinedSources = removeComments(combinedSources);\n\n  // Extract existing shader version from sources\n  let version;\n  combinedSources = combinedSources.replace(\n    /#version\\s+(.*?)\\n/gm,\n    function (match, group1) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(version) && version !== group1) {\n        throw new DeveloperError(\n          `inconsistent versions found: ${version} and ${group1}`,\n        );\n      }\n      //>>includeEnd('debug');\n\n      // Extract #version to put at the top\n      version = group1;\n\n      // Replace original #version directive with a new line so the line numbers\n      // are not off by one.  There can be only one #version directive\n      // and it must appear at the top of the source, only preceded by\n      // whitespace and comments.\n      return \"\\n\";\n    },\n  );\n\n  // Extract shader extensions from sources\n  const extensions = [];\n  combinedSources = combinedSources.replace(\n    /#extension.*\\n/gm,\n    function (match) {\n      // Extract extension to put at the top\n      extensions.push(match);\n\n      // Replace original #extension directive with a new line so the line numbers\n      // are not off by one.\n      return \"\\n\";\n    },\n  );\n\n  // Remove precision qualifier\n  combinedSources = combinedSources.replace(\n    /precision\\s(lowp|mediump|highp)\\s(float|int);/,\n    \"\",\n  );\n\n  // Replace main() for picked if desired.\n  const pickColorQualifier = shaderSource.pickColorQualifier;\n  if (defined(pickColorQualifier)) {\n    combinedSources = ShaderSource.createPickFragmentShaderSource(\n      combinedSources,\n      pickColorQualifier,\n    );\n  }\n\n  // combine into single string\n  let result = \"\";\n\n  const extensionsLength = extensions.length;\n  for (i = 0; i < extensionsLength; i++) {\n    result += extensions[i];\n  }\n\n  if (isFragmentShader) {\n    // If high precision isn't support replace occurrences of highp with mediump\n    // The highp keyword is not always available on older mobile devices\n    // See https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#In_WebGL_1_highp_float_support_is_optional_in_fragment_shaders\n    result +=\n      \"\\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\n\\\n    precision highp float;\\n\\\n    precision highp int;\\n\\\n#else\\n\\\n    precision mediump float;\\n\\\n    precision mediump int;\\n\\\n    #define highp mediump\\n\\\n#endif\\n\\n\";\n  }\n\n  // Prepend #defines for uber-shaders\n  const defines = shaderSource.defines;\n  if (defined(defines)) {\n    for (i = 0, length = defines.length; i < length; ++i) {\n      const define = defines[i];\n      if (define.length !== 0) {\n        result += `#define ${define}\\n`;\n      }\n    }\n  }\n\n  // Define a constant for the OES_texture_float_linear extension since WebGL does not.\n  if (context.textureFloatLinear) {\n    result += \"#define OES_texture_float_linear\\n\\n\";\n  }\n\n  // Define a constant for the OES_texture_float extension since WebGL does not.\n  if (context.floatingPointTexture) {\n    result += \"#define OES_texture_float\\n\\n\";\n  }\n\n  // append built-ins\n  let builtinSources = \"\";\n  if (shaderSource.includeBuiltIns) {\n    builtinSources = getBuiltinsAndAutomaticUniforms(combinedSources);\n  }\n\n  // reset line number\n  result += \"\\n#line 0\\n\";\n\n  // append actual source\n  const combinedShader = builtinSources + combinedSources;\n  if (\n    context.webgl2 &&\n    isFragmentShader &&\n    !/layout\\s*\\(location\\s*=\\s*0\\)\\s*out\\s+vec4\\s+out_FragColor;/g.test(\n      combinedShader,\n    ) &&\n    !/czm_out_FragColor/g.test(combinedShader) &&\n    /out_FragColor/g.test(combinedShader)\n  ) {\n    result += \"layout(location = 0) out vec4 out_FragColor;\\n\\n\";\n  }\n\n  result += builtinSources;\n  result += combinedSources;\n\n  // modernize the source\n  if (!context.webgl2) {\n    result = demodernizeShader(result, isFragmentShader);\n  } else {\n    result = `#version 300 es\\n${result}`;\n  }\n\n  return result;\n}\n\n/**\n * An object containing various inputs that will be combined to form a final GLSL shader string.\n *\n * @param {object} [options] Object with the following properties:\n * @param {string[]} [options.sources] An array of strings to combine containing GLSL code for the shader.\n * @param {string[]} [options.defines] An array of strings containing GLSL identifiers to <code>#define</code>.\n * @param {string} [options.pickColorQualifier] The GLSL qualifier, <code>uniform</code> or <code>in</code>, for the input <code>czm_pickColor</code>.  When defined, a pick fragment shader is generated.\n * @param {boolean} [options.includeBuiltIns=true] If true, referenced built-in functions will be included with the combined shader.  Set to false if this shader will become a source in another shader, to avoid duplicating functions.\n *\n * @exception {DeveloperError} options.pickColorQualifier must be 'uniform' or 'in'.\n *\n * @example\n * // 1. Prepend #defines to a shader\n * const source = new Cesium.ShaderSource({\n *   defines : ['WHITE'],\n *   sources : ['void main() { \\n#ifdef WHITE\\n out_FragColor = vec4(1.0); \\n#else\\n out_FragColor = vec4(0.0); \\n#endif\\n }']\n * });\n *\n * // 2. Modify a fragment shader for picking\n * const source2 = new Cesium.ShaderSource({\n *   sources : ['void main() { out_FragColor = vec4(1.0); }'],\n *   pickColorQualifier : 'uniform'\n * });\n *\n * @private\n */\nfunction ShaderSource(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const pickColorQualifier = options.pickColorQualifier;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    defined(pickColorQualifier) &&\n    pickColorQualifier !== \"uniform\" &&\n    pickColorQualifier !== \"in\"\n  ) {\n    throw new DeveloperError(\n      \"options.pickColorQualifier must be 'uniform' or 'in'.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  this.defines = defined(options.defines) ? options.defines.slice(0) : [];\n  this.sources = defined(options.sources) ? options.sources.slice(0) : [];\n  this.pickColorQualifier = pickColorQualifier;\n  this.includeBuiltIns = options.includeBuiltIns ?? true;\n}\n\nShaderSource.prototype.clone = function () {\n  return new ShaderSource({\n    sources: this.sources,\n    defines: this.defines,\n    pickColorQualifier: this.pickColorQualifier,\n    includeBuiltIns: this.includeBuiltIns,\n  });\n};\n\nShaderSource.replaceMain = function (source, renamedMain) {\n  renamedMain = `void ${renamedMain}()`;\n  return source.replace(/void\\s+main\\s*\\(\\s*(?:void)?\\s*\\)/g, renamedMain);\n};\n\n/**\n * Since {@link ShaderSource#createCombinedVertexShader} and\n * {@link ShaderSource#createCombinedFragmentShader} are both expensive to\n * compute, create a simpler string key for lookups in the {@link ShaderCache}.\n *\n * @returns {string} A key for identifying this shader\n *\n * @private\n */\nShaderSource.prototype.getCacheKey = function () {\n  // Sort defines to make the key comparison deterministic\n  const sortedDefines = this.defines.slice().sort();\n  const definesKey = sortedDefines.join(\",\");\n  const pickKey = this.pickColorQualifier;\n  const builtinsKey = this.includeBuiltIns;\n  const sourcesKey = this.sources.join(\"\\n\");\n\n  return `${definesKey}:${pickKey}:${builtinsKey}:${sourcesKey}`;\n};\n\n/**\n * Create a single string containing the full, combined vertex shader with all dependencies and defines.\n *\n * @param {Context} context The current rendering context\n *\n * @returns {string} The combined shader string.\n */\nShaderSource.prototype.createCombinedVertexShader = function (context) {\n  return combineShader(this, false, context);\n};\n\n/**\n * Create a single string containing the full, combined fragment shader with all dependencies and defines.\n *\n * @param {Context} context The current rendering context\n *\n * @returns {string} The combined shader string.\n */\nShaderSource.prototype.createCombinedFragmentShader = function (context) {\n  return combineShader(this, true, context);\n};\n\n/**\n * For ShaderProgram testing\n * @private\n */\nShaderSource._czmBuiltinsAndUniforms = {};\n\n// combine automatic uniforms and Cesium built-ins\nfor (const builtinName in CzmBuiltins) {\n  if (CzmBuiltins.hasOwnProperty(builtinName)) {\n    ShaderSource._czmBuiltinsAndUniforms[builtinName] =\n      CzmBuiltins[builtinName];\n  }\n}\nfor (const uniformName in AutomaticUniforms) {\n  if (AutomaticUniforms.hasOwnProperty(uniformName)) {\n    const uniform = AutomaticUniforms[uniformName];\n    if (typeof uniform.getDeclaration === \"function\") {\n      ShaderSource._czmBuiltinsAndUniforms[uniformName] =\n        uniform.getDeclaration(uniformName);\n    }\n  }\n}\n\nShaderSource.createPickVertexShaderSource = function (vertexShaderSource) {\n  const renamedVS = ShaderSource.replaceMain(\n    vertexShaderSource,\n    \"czm_old_main\",\n  );\n  const pickMain =\n    \"in vec4 pickColor; \\n\" +\n    \"out vec4 czm_pickColor; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_old_main(); \\n\" +\n    \"    czm_pickColor = pickColor; \\n\" +\n    \"}\";\n\n  return `${renamedVS}\\n${pickMain}`;\n};\n\nShaderSource.createPickFragmentShaderSource = function (\n  fragmentShaderSource,\n  pickColorQualifier,\n) {\n  const renamedFS = ShaderSource.replaceMain(\n    fragmentShaderSource,\n    \"czm_old_main\",\n  );\n  const pickMain =\n    `${pickColorQualifier} vec4 czm_pickColor; \\n` +\n    `void main() \\n` +\n    `{ \\n` +\n    `    czm_old_main(); \\n` +\n    `    if (out_FragColor.a == 0.0) { \\n` +\n    `       discard; \\n` +\n    `    } \\n` +\n    `    out_FragColor = czm_pickColor; \\n` +\n    `}`;\n\n  return `${renamedFS}\\n${pickMain}`;\n};\n\nfunction containsDefine(shaderSource, define) {\n  const defines = shaderSource.defines;\n  const definesLength = defines.length;\n  for (let i = 0; i < definesLength; ++i) {\n    if (defines[i] === define) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction containsString(shaderSource, string) {\n  const sources = shaderSource.sources;\n  const sourcesLength = sources.length;\n  for (let i = 0; i < sourcesLength; ++i) {\n    if (sources[i].indexOf(string) !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction findFirstString(shaderSource, strings) {\n  const stringsLength = strings.length;\n  for (let i = 0; i < stringsLength; ++i) {\n    const string = strings[i];\n    if (containsString(shaderSource, string)) {\n      return string;\n    }\n  }\n  return undefined;\n}\n\nconst normalVaryingNames = [\"v_normalEC\", \"v_normal\"];\n\nShaderSource.findNormalVarying = function (shaderSource) {\n  // Fix for Model: the shader text always has the word v_normalEC\n  // wrapped in an #ifdef so instead of looking for v_normalEC look for the define\n  if (containsString(shaderSource, \"#ifdef HAS_NORMALS\")) {\n    if (containsDefine(shaderSource, \"HAS_NORMALS\")) {\n      return \"v_normalEC\";\n    }\n    return undefined;\n  }\n\n  return findFirstString(shaderSource, normalVaryingNames);\n};\n\nconst positionVaryingNames = [\"v_positionEC\"];\n\nShaderSource.findPositionVarying = function (shaderSource) {\n  return findFirstString(shaderSource, positionVaryingNames);\n};\nexport default ShaderSource;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}