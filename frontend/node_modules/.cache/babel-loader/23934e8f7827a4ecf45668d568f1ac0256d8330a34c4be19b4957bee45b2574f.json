{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Check from \"../Core/Check.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport AutomaticUniforms from \"./AutomaticUniforms.js\";\nimport ContextLimits from \"./ContextLimits.js\";\nimport createUniform from \"./createUniform.js\";\nimport createUniformArray from \"./createUniformArray.js\";\nlet nextShaderProgramId = 0;\n\n/**\n * @private\n */\nfunction ShaderProgram(options) {\n  let vertexShaderText = options.vertexShaderText;\n  let fragmentShaderText = options.fragmentShaderText;\n  if (typeof spector !== \"undefined\") {\n    // The #line statements common in Cesium shaders interfere with the ability of the\n    // SpectorJS to show errors on the correct line. So remove them when SpectorJS\n    // is active.\n    vertexShaderText = vertexShaderText.replace(/^#line/gm, \"//#line\");\n    fragmentShaderText = fragmentShaderText.replace(/^#line/gm, \"//#line\");\n  }\n  const modifiedFS = handleUniformPrecisionMismatches(vertexShaderText, fragmentShaderText);\n  this._gl = options.gl;\n  this._logShaderCompilation = options.logShaderCompilation;\n  this._debugShaders = options.debugShaders;\n  this._attributeLocations = options.attributeLocations;\n  this._program = undefined;\n  this._numberOfVertexAttributes = undefined;\n  this._vertexAttributes = undefined;\n  this._uniformsByName = undefined;\n  this._uniforms = undefined;\n  this._automaticUniforms = undefined;\n  this._manualUniforms = undefined;\n  this._duplicateUniformNames = modifiedFS.duplicateUniformNames;\n  this._cachedShader = undefined; // Used by ShaderCache\n\n  /**\n   * @private\n   */\n  this.maximumTextureUnitIndex = undefined;\n  this._vertexShaderSource = options.vertexShaderSource;\n  this._vertexShaderText = options.vertexShaderText;\n  this._fragmentShaderSource = options.fragmentShaderSource;\n  this._fragmentShaderText = modifiedFS.fragmentShaderText;\n\n  /**\n   * @private\n   */\n  this.id = nextShaderProgramId++;\n}\nShaderProgram.fromCache = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  //>>includeEnd('debug');\n\n  return options.context.shaderCache.getShaderProgram(options);\n};\nShaderProgram.replaceCache = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  //>>includeEnd('debug');\n\n  return options.context.shaderCache.replaceShaderProgram(options);\n};\nObject.defineProperties(ShaderProgram.prototype, {\n  /**\n   * GLSL source for the shader program's vertex shader.\n   * @memberof ShaderProgram.prototype\n   *\n   * @type {ShaderSource}\n   * @readonly\n   */\n  vertexShaderSource: {\n    get: function () {\n      return this._vertexShaderSource;\n    }\n  },\n  /**\n   * GLSL source for the shader program's fragment shader.\n   * @memberof ShaderProgram.prototype\n   *\n   * @type {ShaderSource}\n   * @readonly\n   */\n  fragmentShaderSource: {\n    get: function () {\n      return this._fragmentShaderSource;\n    }\n  },\n  vertexAttributes: {\n    get: function () {\n      initialize(this);\n      return this._vertexAttributes;\n    }\n  },\n  numberOfVertexAttributes: {\n    get: function () {\n      initialize(this);\n      return this._numberOfVertexAttributes;\n    }\n  },\n  allUniforms: {\n    get: function () {\n      initialize(this);\n      return this._uniformsByName;\n    }\n  }\n});\nfunction extractUniforms(shaderText) {\n  const uniformNames = [];\n  const uniformLines = shaderText.match(/uniform.*?(?![^{]*})(?=[=\\[;])/g);\n  if (defined(uniformLines)) {\n    const len = uniformLines.length;\n    for (let i = 0; i < len; i++) {\n      const line = uniformLines[i].trim();\n      const name = line.slice(line.lastIndexOf(\" \") + 1);\n      uniformNames.push(name);\n    }\n  }\n  return uniformNames;\n}\nfunction handleUniformPrecisionMismatches(vertexShaderText, fragmentShaderText) {\n  // If a uniform exists in both the vertex and fragment shader but with different precision qualifiers,\n  // give the fragment shader uniform a different name. This fixes shader compilation errors on devices\n  // that only support mediump in the fragment shader.\n  const duplicateUniformNames = {};\n  if (!ContextLimits.highpFloatSupported || !ContextLimits.highpIntSupported) {\n    let i, j;\n    let uniformName;\n    let duplicateName;\n    const vertexShaderUniforms = extractUniforms(vertexShaderText);\n    const fragmentShaderUniforms = extractUniforms(fragmentShaderText);\n    const vertexUniformsCount = vertexShaderUniforms.length;\n    const fragmentUniformsCount = fragmentShaderUniforms.length;\n    for (i = 0; i < vertexUniformsCount; i++) {\n      for (j = 0; j < fragmentUniformsCount; j++) {\n        if (vertexShaderUniforms[i] === fragmentShaderUniforms[j]) {\n          uniformName = vertexShaderUniforms[i];\n          duplicateName = `czm_mediump_${uniformName}`;\n          // Update fragmentShaderText with renamed uniforms\n          const re = new RegExp(`${uniformName}\\\\b`, \"g\");\n          fragmentShaderText = fragmentShaderText.replace(re, duplicateName);\n          duplicateUniformNames[duplicateName] = uniformName;\n        }\n      }\n    }\n  }\n  return {\n    fragmentShaderText: fragmentShaderText,\n    duplicateUniformNames: duplicateUniformNames\n  };\n}\nconst consolePrefix = \"[Cesium WebGL] \";\nfunction createAndLinkProgram(gl, shader) {\n  const vsSource = shader._vertexShaderText;\n  const fsSource = shader._fragmentShaderText;\n  const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n  gl.shaderSource(vertexShader, vsSource);\n  gl.compileShader(vertexShader);\n  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n  gl.shaderSource(fragmentShader, fsSource);\n  gl.compileShader(fragmentShader);\n  const program = gl.createProgram();\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  const attributeLocations = shader._attributeLocations;\n  if (defined(attributeLocations)) {\n    for (const attribute in attributeLocations) {\n      if (attributeLocations.hasOwnProperty(attribute)) {\n        gl.bindAttribLocation(program, attributeLocations[attribute], attribute);\n      }\n    }\n  }\n  gl.linkProgram(program);\n  let log;\n\n  // For performance: if linker succeeds, return without checking compile status\n  if (gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    if (shader._logShaderCompilation) {\n      log = gl.getShaderInfoLog(vertexShader);\n      if (defined(log) && log.length > 0) {\n        console.log(`${consolePrefix}Vertex shader compile log: ${log}`);\n      }\n      log = gl.getShaderInfoLog(fragmentShader);\n      if (defined(log) && log.length > 0) {\n        console.log(`${consolePrefix}Fragment shader compile log: ${log}`);\n      }\n      log = gl.getProgramInfoLog(program);\n      if (defined(log) && log.length > 0) {\n        console.log(`${consolePrefix}Shader program link log: ${log}`);\n      }\n    }\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader);\n    return program;\n  }\n\n  // Program failed to link. Try to find and report the reason\n  let errorMessage;\n  const debugShaders = shader._debugShaders;\n  if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n    log = gl.getShaderInfoLog(fragmentShader);\n    console.error(`${consolePrefix}Fragment shader compile log: ${log}`);\n    console.error(`${consolePrefix} Fragment shader source:\\n${fsSource}`);\n    errorMessage = `Fragment shader failed to compile.  Compile log: ${log}`;\n  } else if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n    log = gl.getShaderInfoLog(vertexShader);\n    console.error(`${consolePrefix}Vertex shader compile log: ${log}`);\n    console.error(`${consolePrefix} Vertex shader source:\\n${vsSource}`);\n    errorMessage = `Vertex shader failed to compile.  Compile log: ${log}`;\n  } else {\n    log = gl.getProgramInfoLog(program);\n    console.error(`${consolePrefix}Shader program link log: ${log}`);\n    logTranslatedSource(vertexShader, \"vertex\");\n    logTranslatedSource(fragmentShader, \"fragment\");\n    errorMessage = `Program failed to link.  Link log: ${log}`;\n  }\n  gl.deleteShader(vertexShader);\n  gl.deleteShader(fragmentShader);\n  gl.deleteProgram(program);\n  throw new RuntimeError(errorMessage);\n  function logTranslatedSource(compiledShader, name) {\n    if (!defined(debugShaders)) {\n      return;\n    }\n    const translation = debugShaders.getTranslatedShaderSource(compiledShader);\n    if (translation === \"\") {\n      console.error(`${consolePrefix}${name} shader translation failed.`);\n      return;\n    }\n    console.error(`${consolePrefix}Translated ${name} shaderSource:\\n${translation}`);\n  }\n}\nfunction findVertexAttributes(gl, program, numberOfAttributes) {\n  const attributes = {};\n  for (let i = 0; i < numberOfAttributes; ++i) {\n    const attr = gl.getActiveAttrib(program, i);\n    const location = gl.getAttribLocation(program, attr.name);\n    attributes[attr.name] = {\n      name: attr.name,\n      type: attr.type,\n      index: location\n    };\n  }\n  return attributes;\n}\nfunction findUniforms(gl, program) {\n  const uniformsByName = {};\n  const uniforms = [];\n  const samplerUniforms = [];\n  const numberOfUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n  for (let i = 0; i < numberOfUniforms; ++i) {\n    const activeUniform = gl.getActiveUniform(program, i);\n    const suffix = \"[0]\";\n    const uniformName = activeUniform.name.indexOf(suffix, activeUniform.name.length - suffix.length) !== -1 ? activeUniform.name.slice(0, activeUniform.name.length - 3) : activeUniform.name;\n\n    // Ignore GLSL built-in uniforms returned in Firefox.\n    if (uniformName.indexOf(\"gl_\") !== 0) {\n      if (activeUniform.name.indexOf(\"[\") < 0) {\n        // Single uniform\n        const location = gl.getUniformLocation(program, uniformName);\n\n        // IE 11.0.9 needs this check since getUniformLocation can return null\n        // if the uniform is not active (e.g., it is optimized out).  Looks like\n        // getActiveUniform() above returns uniforms that are not actually active.\n        if (location !== null) {\n          const uniform = createUniform(gl, activeUniform, uniformName, location);\n          uniformsByName[uniformName] = uniform;\n          uniforms.push(uniform);\n          if (uniform._setSampler) {\n            samplerUniforms.push(uniform);\n          }\n        }\n      } else {\n        // Uniform array\n\n        let uniformArray;\n        let locations;\n        let value;\n        let loc;\n\n        // On some platforms - Nexus 4 in Firefox for one - an array of sampler2D ends up being represented\n        // as separate uniforms, one for each array element.  Check for and handle that case.\n        const indexOfBracket = uniformName.indexOf(\"[\");\n        if (indexOfBracket >= 0) {\n          // We're assuming the array elements show up in numerical order - it seems to be true.\n          uniformArray = uniformsByName[uniformName.slice(0, indexOfBracket)];\n\n          // Nexus 4 with Android 4.3 needs this check, because it reports a uniform\n          // with the strange name webgl_3467e0265d05c3c1[1] in our globe surface shader.\n          if (!defined(uniformArray)) {\n            continue;\n          }\n          locations = uniformArray._locations;\n\n          // On the Nexus 4 in Chrome, we get one uniform per sampler, just like in Firefox,\n          // but the size is not 1 like it is in Firefox.  So if we push locations here,\n          // we'll end up adding too many locations.\n          if (locations.length <= 1) {\n            value = uniformArray.value;\n            loc = gl.getUniformLocation(program, uniformName);\n\n            // Workaround for IE 11.0.9.  See above.\n            if (loc !== null) {\n              locations.push(loc);\n              value.push(gl.getUniform(program, loc));\n            }\n          }\n        } else {\n          locations = [];\n          for (let j = 0; j < activeUniform.size; ++j) {\n            loc = gl.getUniformLocation(program, `${uniformName}[${j}]`);\n\n            // Workaround for IE 11.0.9.  See above.\n            if (loc !== null) {\n              locations.push(loc);\n            }\n          }\n          uniformArray = createUniformArray(gl, activeUniform, uniformName, locations);\n          uniformsByName[uniformName] = uniformArray;\n          uniforms.push(uniformArray);\n          if (uniformArray._setSampler) {\n            samplerUniforms.push(uniformArray);\n          }\n        }\n      }\n    }\n  }\n  return {\n    uniformsByName: uniformsByName,\n    uniforms: uniforms,\n    samplerUniforms: samplerUniforms\n  };\n}\nfunction partitionUniforms(shader, uniforms) {\n  const automaticUniforms = [];\n  const manualUniforms = [];\n  for (const uniform in uniforms) {\n    if (uniforms.hasOwnProperty(uniform)) {\n      const uniformObject = uniforms[uniform];\n      let uniformName = uniform;\n      // if it's a duplicate uniform, use its original name so it is updated correctly\n      const duplicateUniform = shader._duplicateUniformNames[uniformName];\n      if (defined(duplicateUniform)) {\n        uniformObject.name = duplicateUniform;\n        uniformName = duplicateUniform;\n      }\n      const automaticUniform = AutomaticUniforms[uniformName];\n      if (defined(automaticUniform)) {\n        automaticUniforms.push({\n          uniform: uniformObject,\n          automaticUniform: automaticUniform\n        });\n      } else {\n        manualUniforms.push(uniformObject);\n      }\n    }\n  }\n  return {\n    automaticUniforms: automaticUniforms,\n    manualUniforms: manualUniforms\n  };\n}\nfunction setSamplerUniforms(gl, program, samplerUniforms) {\n  gl.useProgram(program);\n  let textureUnitIndex = 0;\n  const length = samplerUniforms.length;\n  for (let i = 0; i < length; ++i) {\n    textureUnitIndex = samplerUniforms[i]._setSampler(textureUnitIndex);\n  }\n  gl.useProgram(null);\n  return textureUnitIndex;\n}\nfunction initialize(shader) {\n  if (defined(shader._program)) {\n    return;\n  }\n  reinitialize(shader);\n}\nfunction reinitialize(shader) {\n  const oldProgram = shader._program;\n  const gl = shader._gl;\n  const program = createAndLinkProgram(gl, shader, shader._debugShaders);\n  const numberOfVertexAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n  const uniforms = findUniforms(gl, program);\n  const partitionedUniforms = partitionUniforms(shader, uniforms.uniformsByName);\n  shader._program = program;\n  shader._numberOfVertexAttributes = numberOfVertexAttributes;\n  shader._vertexAttributes = findVertexAttributes(gl, program, numberOfVertexAttributes);\n  shader._uniformsByName = uniforms.uniformsByName;\n  shader._uniforms = uniforms.uniforms;\n  shader._automaticUniforms = partitionedUniforms.automaticUniforms;\n  shader._manualUniforms = partitionedUniforms.manualUniforms;\n  shader.maximumTextureUnitIndex = setSamplerUniforms(gl, program, uniforms.samplerUniforms);\n  if (oldProgram) {\n    shader._gl.deleteProgram(oldProgram);\n  }\n\n  // If SpectorJS is active, add the hook to make the shader editor work.\n  // https://github.com/BabylonJS/Spector.js/blob/master/documentation/extension.md#shader-editor\n  if (typeof spector !== \"undefined\") {\n    shader._program.__SPECTOR_rebuildProgram = function (vertexSourceCode,\n    // The new vertex shader source\n    fragmentSourceCode,\n    // The new fragment shader source\n    onCompiled,\n    // Callback triggered by your engine when the compilation is successful. It needs to send back the new linked program.\n    onError // Callback triggered by your engine in case of error. It needs to send the WebGL error to allow the editor to display the error in the gutter.\n    ) {\n      const originalVS = shader._vertexShaderText;\n      const originalFS = shader._fragmentShaderText;\n\n      // SpectorJS likes to replace `!=` with `! =` for unknown reasons,\n      // and that causes glsl compile failures. So fix that up.\n      const regex = / ! = /g;\n      shader._vertexShaderText = vertexSourceCode.replace(regex, \" != \");\n      shader._fragmentShaderText = fragmentSourceCode.replace(regex, \" != \");\n      try {\n        reinitialize(shader);\n        onCompiled(shader._program);\n      } catch (e) {\n        shader._vertexShaderText = originalVS;\n        shader._fragmentShaderText = originalFS;\n\n        // Only pass on the WebGL error:\n        const errorMatcher = /(?:Compile|Link) error: ([^]*)/;\n        const match = errorMatcher.exec(e.message);\n        if (match) {\n          onError(match[1]);\n        } else {\n          onError(e.message);\n        }\n      }\n    };\n  }\n}\nShaderProgram.prototype._bind = function () {\n  initialize(this);\n  this._gl.useProgram(this._program);\n};\nShaderProgram.prototype._setUniforms = function (uniformMap, uniformState, validate) {\n  let len;\n  let i;\n  if (defined(uniformMap)) {\n    const manualUniforms = this._manualUniforms;\n    len = manualUniforms.length;\n    for (i = 0; i < len; ++i) {\n      const mu = manualUniforms[i];\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(uniformMap[mu.name])) {\n        throw new DeveloperError(`Unknown uniform: ${mu.name}`);\n      }\n      //>>includeEnd('debug');\n\n      mu.value = uniformMap[mu.name]();\n    }\n  }\n  const automaticUniforms = this._automaticUniforms;\n  len = automaticUniforms.length;\n  for (i = 0; i < len; ++i) {\n    const au = automaticUniforms[i];\n    au.uniform.value = au.automaticUniform.getValue(uniformState);\n  }\n\n  ///////////////////////////////////////////////////////////////////\n\n  // It appears that assigning the uniform values above and then setting them here\n  // (which makes the GL calls) is faster than removing this loop and making\n  // the GL calls above.  I suspect this is because each GL call pollutes the\n  // L2 cache making our JavaScript and the browser/driver ping-pong cache lines.\n  const uniforms = this._uniforms;\n  len = uniforms.length;\n  for (i = 0; i < len; ++i) {\n    uniforms[i].set();\n  }\n  if (validate) {\n    const gl = this._gl;\n    const program = this._program;\n    gl.validateProgram(program);\n    //>>includeStart('debug', pragmas.debug);\n    if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {\n      throw new DeveloperError(`Program validation failed.  Program info log: ${gl.getProgramInfoLog(program)}`);\n    }\n    //>>includeEnd('debug');\n  }\n};\nShaderProgram.prototype.isDestroyed = function () {\n  return false;\n};\nShaderProgram.prototype.destroy = function () {\n  this._cachedShader.cache.releaseShaderProgram(this);\n  return undefined;\n};\nShaderProgram.prototype.finalDestroy = function () {\n  this._gl.deleteProgram(this._program);\n  return destroyObject(this);\n};\nexport default ShaderProgram;","map":{"version":3,"names":["Check","Frozen","defined","destroyObject","DeveloperError","RuntimeError","AutomaticUniforms","ContextLimits","createUniform","createUniformArray","nextShaderProgramId","ShaderProgram","options","vertexShaderText","fragmentShaderText","spector","replace","modifiedFS","handleUniformPrecisionMismatches","_gl","gl","_logShaderCompilation","logShaderCompilation","_debugShaders","debugShaders","_attributeLocations","attributeLocations","_program","undefined","_numberOfVertexAttributes","_vertexAttributes","_uniformsByName","_uniforms","_automaticUniforms","_manualUniforms","_duplicateUniformNames","duplicateUniformNames","_cachedShader","maximumTextureUnitIndex","_vertexShaderSource","vertexShaderSource","_vertexShaderText","_fragmentShaderSource","fragmentShaderSource","_fragmentShaderText","id","fromCache","EMPTY_OBJECT","context","shaderCache","getShaderProgram","replaceCache","replaceShaderProgram","Object","defineProperties","prototype","get","vertexAttributes","initialize","numberOfVertexAttributes","allUniforms","extractUniforms","shaderText","uniformNames","uniformLines","match","len","length","i","line","trim","name","slice","lastIndexOf","push","highpFloatSupported","highpIntSupported","j","uniformName","duplicateName","vertexShaderUniforms","fragmentShaderUniforms","vertexUniformsCount","fragmentUniformsCount","re","RegExp","consolePrefix","createAndLinkProgram","shader","vsSource","fsSource","vertexShader","createShader","VERTEX_SHADER","shaderSource","compileShader","fragmentShader","FRAGMENT_SHADER","program","createProgram","attachShader","attribute","hasOwnProperty","bindAttribLocation","linkProgram","log","getProgramParameter","LINK_STATUS","getShaderInfoLog","console","getProgramInfoLog","deleteShader","errorMessage","getShaderParameter","COMPILE_STATUS","error","logTranslatedSource","deleteProgram","compiledShader","translation","getTranslatedShaderSource","findVertexAttributes","numberOfAttributes","attributes","attr","getActiveAttrib","location","getAttribLocation","type","index","findUniforms","uniformsByName","uniforms","samplerUniforms","numberOfUniforms","ACTIVE_UNIFORMS","activeUniform","getActiveUniform","suffix","indexOf","getUniformLocation","uniform","_setSampler","uniformArray","locations","value","loc","indexOfBracket","_locations","getUniform","size","partitionUniforms","automaticUniforms","manualUniforms","uniformObject","duplicateUniform","automaticUniform","setSamplerUniforms","useProgram","textureUnitIndex","reinitialize","oldProgram","ACTIVE_ATTRIBUTES","partitionedUniforms","__SPECTOR_rebuildProgram","vertexSourceCode","fragmentSourceCode","onCompiled","onError","originalVS","originalFS","regex","e","errorMatcher","exec","message","_bind","_setUniforms","uniformMap","uniformState","validate","mu","au","getValue","set","validateProgram","VALIDATE_STATUS","isDestroyed","destroy","cache","releaseShaderProgram","finalDestroy"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Renderer/ShaderProgram.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport AutomaticUniforms from \"./AutomaticUniforms.js\";\nimport ContextLimits from \"./ContextLimits.js\";\nimport createUniform from \"./createUniform.js\";\nimport createUniformArray from \"./createUniformArray.js\";\n\nlet nextShaderProgramId = 0;\n\n/**\n * @private\n */\nfunction ShaderProgram(options) {\n  let vertexShaderText = options.vertexShaderText;\n  let fragmentShaderText = options.fragmentShaderText;\n\n  if (typeof spector !== \"undefined\") {\n    // The #line statements common in Cesium shaders interfere with the ability of the\n    // SpectorJS to show errors on the correct line. So remove them when SpectorJS\n    // is active.\n    vertexShaderText = vertexShaderText.replace(/^#line/gm, \"//#line\");\n    fragmentShaderText = fragmentShaderText.replace(/^#line/gm, \"//#line\");\n  }\n\n  const modifiedFS = handleUniformPrecisionMismatches(\n    vertexShaderText,\n    fragmentShaderText,\n  );\n\n  this._gl = options.gl;\n  this._logShaderCompilation = options.logShaderCompilation;\n  this._debugShaders = options.debugShaders;\n  this._attributeLocations = options.attributeLocations;\n\n  this._program = undefined;\n  this._numberOfVertexAttributes = undefined;\n  this._vertexAttributes = undefined;\n  this._uniformsByName = undefined;\n  this._uniforms = undefined;\n  this._automaticUniforms = undefined;\n  this._manualUniforms = undefined;\n  this._duplicateUniformNames = modifiedFS.duplicateUniformNames;\n  this._cachedShader = undefined; // Used by ShaderCache\n\n  /**\n   * @private\n   */\n  this.maximumTextureUnitIndex = undefined;\n\n  this._vertexShaderSource = options.vertexShaderSource;\n  this._vertexShaderText = options.vertexShaderText;\n  this._fragmentShaderSource = options.fragmentShaderSource;\n  this._fragmentShaderText = modifiedFS.fragmentShaderText;\n\n  /**\n   * @private\n   */\n  this.id = nextShaderProgramId++;\n}\n\nShaderProgram.fromCache = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  //>>includeEnd('debug');\n\n  return options.context.shaderCache.getShaderProgram(options);\n};\n\nShaderProgram.replaceCache = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.context\", options.context);\n  //>>includeEnd('debug');\n\n  return options.context.shaderCache.replaceShaderProgram(options);\n};\n\nObject.defineProperties(ShaderProgram.prototype, {\n  /**\n   * GLSL source for the shader program's vertex shader.\n   * @memberof ShaderProgram.prototype\n   *\n   * @type {ShaderSource}\n   * @readonly\n   */\n  vertexShaderSource: {\n    get: function () {\n      return this._vertexShaderSource;\n    },\n  },\n  /**\n   * GLSL source for the shader program's fragment shader.\n   * @memberof ShaderProgram.prototype\n   *\n   * @type {ShaderSource}\n   * @readonly\n   */\n  fragmentShaderSource: {\n    get: function () {\n      return this._fragmentShaderSource;\n    },\n  },\n  vertexAttributes: {\n    get: function () {\n      initialize(this);\n      return this._vertexAttributes;\n    },\n  },\n  numberOfVertexAttributes: {\n    get: function () {\n      initialize(this);\n      return this._numberOfVertexAttributes;\n    },\n  },\n  allUniforms: {\n    get: function () {\n      initialize(this);\n      return this._uniformsByName;\n    },\n  },\n});\n\nfunction extractUniforms(shaderText) {\n  const uniformNames = [];\n  const uniformLines = shaderText.match(/uniform.*?(?![^{]*})(?=[=\\[;])/g);\n  if (defined(uniformLines)) {\n    const len = uniformLines.length;\n    for (let i = 0; i < len; i++) {\n      const line = uniformLines[i].trim();\n      const name = line.slice(line.lastIndexOf(\" \") + 1);\n      uniformNames.push(name);\n    }\n  }\n  return uniformNames;\n}\n\nfunction handleUniformPrecisionMismatches(\n  vertexShaderText,\n  fragmentShaderText,\n) {\n  // If a uniform exists in both the vertex and fragment shader but with different precision qualifiers,\n  // give the fragment shader uniform a different name. This fixes shader compilation errors on devices\n  // that only support mediump in the fragment shader.\n  const duplicateUniformNames = {};\n\n  if (!ContextLimits.highpFloatSupported || !ContextLimits.highpIntSupported) {\n    let i, j;\n    let uniformName;\n    let duplicateName;\n    const vertexShaderUniforms = extractUniforms(vertexShaderText);\n    const fragmentShaderUniforms = extractUniforms(fragmentShaderText);\n    const vertexUniformsCount = vertexShaderUniforms.length;\n    const fragmentUniformsCount = fragmentShaderUniforms.length;\n\n    for (i = 0; i < vertexUniformsCount; i++) {\n      for (j = 0; j < fragmentUniformsCount; j++) {\n        if (vertexShaderUniforms[i] === fragmentShaderUniforms[j]) {\n          uniformName = vertexShaderUniforms[i];\n          duplicateName = `czm_mediump_${uniformName}`;\n          // Update fragmentShaderText with renamed uniforms\n          const re = new RegExp(`${uniformName}\\\\b`, \"g\");\n          fragmentShaderText = fragmentShaderText.replace(re, duplicateName);\n          duplicateUniformNames[duplicateName] = uniformName;\n        }\n      }\n    }\n  }\n\n  return {\n    fragmentShaderText: fragmentShaderText,\n    duplicateUniformNames: duplicateUniformNames,\n  };\n}\n\nconst consolePrefix = \"[Cesium WebGL] \";\n\nfunction createAndLinkProgram(gl, shader) {\n  const vsSource = shader._vertexShaderText;\n  const fsSource = shader._fragmentShaderText;\n\n  const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n  gl.shaderSource(vertexShader, vsSource);\n  gl.compileShader(vertexShader);\n\n  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n  gl.shaderSource(fragmentShader, fsSource);\n  gl.compileShader(fragmentShader);\n\n  const program = gl.createProgram();\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n\n  const attributeLocations = shader._attributeLocations;\n  if (defined(attributeLocations)) {\n    for (const attribute in attributeLocations) {\n      if (attributeLocations.hasOwnProperty(attribute)) {\n        gl.bindAttribLocation(\n          program,\n          attributeLocations[attribute],\n          attribute,\n        );\n      }\n    }\n  }\n\n  gl.linkProgram(program);\n  let log;\n\n  // For performance: if linker succeeds, return without checking compile status\n  if (gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    if (shader._logShaderCompilation) {\n      log = gl.getShaderInfoLog(vertexShader);\n      if (defined(log) && log.length > 0) {\n        console.log(`${consolePrefix}Vertex shader compile log: ${log}`);\n      }\n\n      log = gl.getShaderInfoLog(fragmentShader);\n      if (defined(log) && log.length > 0) {\n        console.log(`${consolePrefix}Fragment shader compile log: ${log}`);\n      }\n\n      log = gl.getProgramInfoLog(program);\n      if (defined(log) && log.length > 0) {\n        console.log(`${consolePrefix}Shader program link log: ${log}`);\n      }\n    }\n\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader);\n\n    return program;\n  }\n\n  // Program failed to link. Try to find and report the reason\n  let errorMessage;\n  const debugShaders = shader._debugShaders;\n\n  if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n    log = gl.getShaderInfoLog(fragmentShader);\n    console.error(`${consolePrefix}Fragment shader compile log: ${log}`);\n    console.error(`${consolePrefix} Fragment shader source:\\n${fsSource}`);\n    errorMessage = `Fragment shader failed to compile.  Compile log: ${log}`;\n  } else if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n    log = gl.getShaderInfoLog(vertexShader);\n    console.error(`${consolePrefix}Vertex shader compile log: ${log}`);\n    console.error(`${consolePrefix} Vertex shader source:\\n${vsSource}`);\n    errorMessage = `Vertex shader failed to compile.  Compile log: ${log}`;\n  } else {\n    log = gl.getProgramInfoLog(program);\n    console.error(`${consolePrefix}Shader program link log: ${log}`);\n    logTranslatedSource(vertexShader, \"vertex\");\n    logTranslatedSource(fragmentShader, \"fragment\");\n    errorMessage = `Program failed to link.  Link log: ${log}`;\n  }\n\n  gl.deleteShader(vertexShader);\n  gl.deleteShader(fragmentShader);\n  gl.deleteProgram(program);\n  throw new RuntimeError(errorMessage);\n\n  function logTranslatedSource(compiledShader, name) {\n    if (!defined(debugShaders)) {\n      return;\n    }\n    const translation = debugShaders.getTranslatedShaderSource(compiledShader);\n    if (translation === \"\") {\n      console.error(`${consolePrefix}${name} shader translation failed.`);\n      return;\n    }\n    console.error(\n      `${consolePrefix}Translated ${name} shaderSource:\\n${translation}`,\n    );\n  }\n}\n\nfunction findVertexAttributes(gl, program, numberOfAttributes) {\n  const attributes = {};\n  for (let i = 0; i < numberOfAttributes; ++i) {\n    const attr = gl.getActiveAttrib(program, i);\n    const location = gl.getAttribLocation(program, attr.name);\n\n    attributes[attr.name] = {\n      name: attr.name,\n      type: attr.type,\n      index: location,\n    };\n  }\n\n  return attributes;\n}\n\nfunction findUniforms(gl, program) {\n  const uniformsByName = {};\n  const uniforms = [];\n  const samplerUniforms = [];\n\n  const numberOfUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n  for (let i = 0; i < numberOfUniforms; ++i) {\n    const activeUniform = gl.getActiveUniform(program, i);\n    const suffix = \"[0]\";\n    const uniformName =\n      activeUniform.name.indexOf(\n        suffix,\n        activeUniform.name.length - suffix.length,\n      ) !== -1\n        ? activeUniform.name.slice(0, activeUniform.name.length - 3)\n        : activeUniform.name;\n\n    // Ignore GLSL built-in uniforms returned in Firefox.\n    if (uniformName.indexOf(\"gl_\") !== 0) {\n      if (activeUniform.name.indexOf(\"[\") < 0) {\n        // Single uniform\n        const location = gl.getUniformLocation(program, uniformName);\n\n        // IE 11.0.9 needs this check since getUniformLocation can return null\n        // if the uniform is not active (e.g., it is optimized out).  Looks like\n        // getActiveUniform() above returns uniforms that are not actually active.\n        if (location !== null) {\n          const uniform = createUniform(\n            gl,\n            activeUniform,\n            uniformName,\n            location,\n          );\n\n          uniformsByName[uniformName] = uniform;\n          uniforms.push(uniform);\n\n          if (uniform._setSampler) {\n            samplerUniforms.push(uniform);\n          }\n        }\n      } else {\n        // Uniform array\n\n        let uniformArray;\n        let locations;\n        let value;\n        let loc;\n\n        // On some platforms - Nexus 4 in Firefox for one - an array of sampler2D ends up being represented\n        // as separate uniforms, one for each array element.  Check for and handle that case.\n        const indexOfBracket = uniformName.indexOf(\"[\");\n        if (indexOfBracket >= 0) {\n          // We're assuming the array elements show up in numerical order - it seems to be true.\n          uniformArray = uniformsByName[uniformName.slice(0, indexOfBracket)];\n\n          // Nexus 4 with Android 4.3 needs this check, because it reports a uniform\n          // with the strange name webgl_3467e0265d05c3c1[1] in our globe surface shader.\n          if (!defined(uniformArray)) {\n            continue;\n          }\n\n          locations = uniformArray._locations;\n\n          // On the Nexus 4 in Chrome, we get one uniform per sampler, just like in Firefox,\n          // but the size is not 1 like it is in Firefox.  So if we push locations here,\n          // we'll end up adding too many locations.\n          if (locations.length <= 1) {\n            value = uniformArray.value;\n            loc = gl.getUniformLocation(program, uniformName);\n\n            // Workaround for IE 11.0.9.  See above.\n            if (loc !== null) {\n              locations.push(loc);\n              value.push(gl.getUniform(program, loc));\n            }\n          }\n        } else {\n          locations = [];\n          for (let j = 0; j < activeUniform.size; ++j) {\n            loc = gl.getUniformLocation(program, `${uniformName}[${j}]`);\n\n            // Workaround for IE 11.0.9.  See above.\n            if (loc !== null) {\n              locations.push(loc);\n            }\n          }\n          uniformArray = createUniformArray(\n            gl,\n            activeUniform,\n            uniformName,\n            locations,\n          );\n\n          uniformsByName[uniformName] = uniformArray;\n          uniforms.push(uniformArray);\n\n          if (uniformArray._setSampler) {\n            samplerUniforms.push(uniformArray);\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    uniformsByName: uniformsByName,\n    uniforms: uniforms,\n    samplerUniforms: samplerUniforms,\n  };\n}\n\nfunction partitionUniforms(shader, uniforms) {\n  const automaticUniforms = [];\n  const manualUniforms = [];\n\n  for (const uniform in uniforms) {\n    if (uniforms.hasOwnProperty(uniform)) {\n      const uniformObject = uniforms[uniform];\n      let uniformName = uniform;\n      // if it's a duplicate uniform, use its original name so it is updated correctly\n      const duplicateUniform = shader._duplicateUniformNames[uniformName];\n      if (defined(duplicateUniform)) {\n        uniformObject.name = duplicateUniform;\n        uniformName = duplicateUniform;\n      }\n      const automaticUniform = AutomaticUniforms[uniformName];\n      if (defined(automaticUniform)) {\n        automaticUniforms.push({\n          uniform: uniformObject,\n          automaticUniform: automaticUniform,\n        });\n      } else {\n        manualUniforms.push(uniformObject);\n      }\n    }\n  }\n\n  return {\n    automaticUniforms: automaticUniforms,\n    manualUniforms: manualUniforms,\n  };\n}\n\nfunction setSamplerUniforms(gl, program, samplerUniforms) {\n  gl.useProgram(program);\n\n  let textureUnitIndex = 0;\n  const length = samplerUniforms.length;\n  for (let i = 0; i < length; ++i) {\n    textureUnitIndex = samplerUniforms[i]._setSampler(textureUnitIndex);\n  }\n\n  gl.useProgram(null);\n\n  return textureUnitIndex;\n}\n\nfunction initialize(shader) {\n  if (defined(shader._program)) {\n    return;\n  }\n\n  reinitialize(shader);\n}\n\nfunction reinitialize(shader) {\n  const oldProgram = shader._program;\n\n  const gl = shader._gl;\n  const program = createAndLinkProgram(gl, shader, shader._debugShaders);\n  const numberOfVertexAttributes = gl.getProgramParameter(\n    program,\n    gl.ACTIVE_ATTRIBUTES,\n  );\n  const uniforms = findUniforms(gl, program);\n  const partitionedUniforms = partitionUniforms(\n    shader,\n    uniforms.uniformsByName,\n  );\n\n  shader._program = program;\n  shader._numberOfVertexAttributes = numberOfVertexAttributes;\n  shader._vertexAttributes = findVertexAttributes(\n    gl,\n    program,\n    numberOfVertexAttributes,\n  );\n  shader._uniformsByName = uniforms.uniformsByName;\n  shader._uniforms = uniforms.uniforms;\n  shader._automaticUniforms = partitionedUniforms.automaticUniforms;\n  shader._manualUniforms = partitionedUniforms.manualUniforms;\n\n  shader.maximumTextureUnitIndex = setSamplerUniforms(\n    gl,\n    program,\n    uniforms.samplerUniforms,\n  );\n\n  if (oldProgram) {\n    shader._gl.deleteProgram(oldProgram);\n  }\n\n  // If SpectorJS is active, add the hook to make the shader editor work.\n  // https://github.com/BabylonJS/Spector.js/blob/master/documentation/extension.md#shader-editor\n  if (typeof spector !== \"undefined\") {\n    shader._program.__SPECTOR_rebuildProgram = function (\n      vertexSourceCode, // The new vertex shader source\n      fragmentSourceCode, // The new fragment shader source\n      onCompiled, // Callback triggered by your engine when the compilation is successful. It needs to send back the new linked program.\n      onError, // Callback triggered by your engine in case of error. It needs to send the WebGL error to allow the editor to display the error in the gutter.\n    ) {\n      const originalVS = shader._vertexShaderText;\n      const originalFS = shader._fragmentShaderText;\n\n      // SpectorJS likes to replace `!=` with `! =` for unknown reasons,\n      // and that causes glsl compile failures. So fix that up.\n      const regex = / ! = /g;\n      shader._vertexShaderText = vertexSourceCode.replace(regex, \" != \");\n      shader._fragmentShaderText = fragmentSourceCode.replace(regex, \" != \");\n\n      try {\n        reinitialize(shader);\n        onCompiled(shader._program);\n      } catch (e) {\n        shader._vertexShaderText = originalVS;\n        shader._fragmentShaderText = originalFS;\n\n        // Only pass on the WebGL error:\n        const errorMatcher = /(?:Compile|Link) error: ([^]*)/;\n        const match = errorMatcher.exec(e.message);\n        if (match) {\n          onError(match[1]);\n        } else {\n          onError(e.message);\n        }\n      }\n    };\n  }\n}\n\nShaderProgram.prototype._bind = function () {\n  initialize(this);\n  this._gl.useProgram(this._program);\n};\n\nShaderProgram.prototype._setUniforms = function (\n  uniformMap,\n  uniformState,\n  validate,\n) {\n  let len;\n  let i;\n\n  if (defined(uniformMap)) {\n    const manualUniforms = this._manualUniforms;\n    len = manualUniforms.length;\n    for (i = 0; i < len; ++i) {\n      const mu = manualUniforms[i];\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(uniformMap[mu.name])) {\n        throw new DeveloperError(`Unknown uniform: ${mu.name}`);\n      }\n      //>>includeEnd('debug');\n\n      mu.value = uniformMap[mu.name]();\n    }\n  }\n\n  const automaticUniforms = this._automaticUniforms;\n  len = automaticUniforms.length;\n  for (i = 0; i < len; ++i) {\n    const au = automaticUniforms[i];\n    au.uniform.value = au.automaticUniform.getValue(uniformState);\n  }\n\n  ///////////////////////////////////////////////////////////////////\n\n  // It appears that assigning the uniform values above and then setting them here\n  // (which makes the GL calls) is faster than removing this loop and making\n  // the GL calls above.  I suspect this is because each GL call pollutes the\n  // L2 cache making our JavaScript and the browser/driver ping-pong cache lines.\n  const uniforms = this._uniforms;\n  len = uniforms.length;\n  for (i = 0; i < len; ++i) {\n    uniforms[i].set();\n  }\n\n  if (validate) {\n    const gl = this._gl;\n    const program = this._program;\n\n    gl.validateProgram(program);\n    //>>includeStart('debug', pragmas.debug);\n    if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {\n      throw new DeveloperError(\n        `Program validation failed.  Program info log: ${gl.getProgramInfoLog(\n          program,\n        )}`,\n      );\n    }\n    //>>includeEnd('debug');\n  }\n};\n\nShaderProgram.prototype.isDestroyed = function () {\n  return false;\n};\n\nShaderProgram.prototype.destroy = function () {\n  this._cachedShader.cache.releaseShaderProgram(this);\n  return undefined;\n};\n\nShaderProgram.prototype.finalDestroy = function () {\n  this._gl.deleteProgram(this._program);\n  return destroyObject(this);\n};\nexport default ShaderProgram;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}