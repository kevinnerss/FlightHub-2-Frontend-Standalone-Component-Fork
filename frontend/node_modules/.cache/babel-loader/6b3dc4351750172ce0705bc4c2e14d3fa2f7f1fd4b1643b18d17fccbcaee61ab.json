{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Credit from \"../Core/Credit.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Resource from \"../Core/Resource.js\";\nimport IonResource from \"../Core/IonResource.js\";\nimport Check from \"../Core/Check.js\";\nimport UrlTemplateImageryProvider from \"./UrlTemplateImageryProvider.js\";\nimport GoogleMaps from \"../Core/GoogleMaps.js\";\nconst trailingSlashRegex = /\\/$/;\n\n/**\n * @typedef {Object} Google2DImageryProvider.ConstructorOptions\n *\n * Initialization options for the Google2DImageryProvider constructor\n *\n * @property {object} options Object with the following properties:\n * @property {string} options.key The Google api key to send with tile requests.\n * @property {string} options.session The Google session token that tracks the current state of your map and viewport.\n * @property {string|Resource|IonResource} options.url The Google 2D maps endpoint.\n * @property {string} options.tileWidth The width of each tile in pixels.\n * @property {string} options.tileHeight The height of each tile in pixels.\n * @property {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid.  If not specified, the default ellipsoid is used.\n * @property {number} [options.minimumLevel=0] The minimum level-of-detail supported by the imagery provider.  Take care when specifying\n *                 this that the number of tiles at the minimum level is small, such as four or less.  A larger number is likely\n *                 to result in rendering problems.\n * @property {number} [options.maximumLevel=22] The maximum level-of-detail supported by the imagery provider.\n * @property {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the image.\n */\n\n/**\n * <div class=\"notice\">\n * This object is normally not instantiated directly, use {@link Google2DImageryProvider.fromIonAssetId} or {@link Google2DImageryProvider.fromUrl}.\n * </div>\n *\n *\n * Provides 2D image tiles from {@link https://developers.google.com/maps/documentation/tile/2d-tiles-overview|Google 2D Tiles}.\n * \n * Google 2D Tiles can only be used with the Google geocoder.\n *\n * @alias Google2DImageryProvider\n * @constructor\n *\n * @param {Google2DImageryProvider.ConstructorOptions} options Object describing initialization options\n *\n * @example\n * // Google 2D imagery provider\n * const googleTilesProvider = Cesium.Google2DImageryProvider.fromIonAssetId({\n *     assetId: 3830184\n * });\n  * @example\n * // Use your own Google api key\n * Cesium.GoogleMaps.defaultApiKey = \"your-api-key\";\n * \n * const googleTilesProvider = Cesium.Google2DImageryProvider.fromUrl({\n *     mapType: \"SATELLITE\"\n * });\n *\n\n *\n * @see {@link https://developers.google.com/maps/documentation/tile/2d-tiles-overview}\n * @see {@link https://developers.google.com/maps/documentation/tile/session_tokens}\n * @see {@link https://en.wikipedia.org/wiki/IETF_language_tag|IETF Language Tags}\n * @see {@link https://cldr.unicode.org/|Common Locale Data Repository region identifiers}\n */\n\nfunction Google2DImageryProvider(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  this._maximumLevel = options.maximumLevel ?? 22;\n  this._minimumLevel = options.minimumLevel ?? 0;\n\n  //>>includeStart(\"debug\", pragmas.debug);\n  Check.defined(\"options.session\", options.session);\n  Check.defined(\"options.tileWidth\", options.tileWidth);\n  Check.defined(\"options.tileHeight\", options.tileHeight);\n  Check.defined(\"options.key\", options.key);\n  //>>includeEnd(\"debug\");\n\n  this._session = options.session;\n  this._key = options.key;\n  this._tileWidth = options.tileWidth;\n  this._tileHeight = options.tileHeight;\n  const resource = options.url instanceof IonResource ? options.url : Resource.createIfNeeded(options.url ?? GoogleMaps.mapTilesApiEndpoint);\n  let templateUrl = resource.getUrlComponent();\n  if (!trailingSlashRegex.test(templateUrl)) {\n    templateUrl += \"/\";\n  }\n  const tilesUrl = `${templateUrl}v1/2dtiles/{z}/{x}/{y}`;\n  this._viewportUrl = `${templateUrl}tile/v1/viewport`;\n  resource.url = tilesUrl;\n  resource.setQueryParameters({\n    session: encodeURIComponent(options.session),\n    key: encodeURIComponent(options.key)\n  });\n  let credit;\n  if (defined(options.credit)) {\n    credit = options.credit;\n    if (typeof credit === \"string\") {\n      credit = new Credit(credit);\n    }\n  }\n  const provider = new UrlTemplateImageryProvider({\n    url: resource,\n    credit: credit,\n    tileWidth: options.tileWidth,\n    tileHeight: options.tileHeight,\n    ellipsoid: options.ellipsoid,\n    rectangle: options.rectangle,\n    maximumLevel: this._maximumLevel,\n    minimumLevel: this._minimumLevel\n  });\n  provider._resource = resource;\n  this._imageryProvider = provider;\n\n  // This will be defined for ion resources\n  this._tileCredits = resource.credits;\n  this._attributionsByLevel = undefined;\n  // Asynchronously request and populate _attributionsByLevel\n  this.getViewportCredits();\n}\nObject.defineProperties(Google2DImageryProvider.prototype, {\n  /**\n   * Gets the URL of the Google 2D Imagery server.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {string}\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._imageryProvider.url;\n    }\n  },\n  /**\n   * Gets the rectangle, in radians, of the imagery provided by the instance.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function () {\n      return this._imageryProvider.rectangle;\n    }\n  },\n  /**\n   * Gets the width of each tile, in pixels.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {number}\n   * @readonly\n   */\n  tileWidth: {\n    get: function () {\n      return this._imageryProvider.tileWidth;\n    }\n  },\n  /**\n   * Gets the height of each tile, in pixels.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {number}\n   * @readonly\n   */\n  tileHeight: {\n    get: function () {\n      return this._imageryProvider.tileHeight;\n    }\n  },\n  /**\n   * Gets the maximum level-of-detail that can be requested.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {number|undefined}\n   * @readonly\n   */\n  maximumLevel: {\n    get: function () {\n      return this._imageryProvider.maximumLevel;\n    }\n  },\n  /**\n   * Gets the minimum level-of-detail that can be requested. Generally,\n   * a minimum level should only be used when the rectangle of the imagery is small\n   * enough that the number of tiles at the minimum level is small.  An imagery\n   * provider with more than a few tiles at the minimum level will lead to\n   * rendering problems.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {number}\n   * @readonly\n   */\n  minimumLevel: {\n    get: function () {\n      return this._imageryProvider.minimumLevel;\n    }\n  },\n  /**\n   * Gets the tiling scheme used by the provider.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      return this._imageryProvider.tilingScheme;\n    }\n  },\n  /**\n   * Gets the tile discard policy.  If not undefined, the discard policy is responsible\n   * for filtering out \"missing\" tiles via its shouldDiscardImage function.  If this function\n   * returns undefined, no tiles are filtered.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {TileDiscardPolicy}\n   * @readonly\n   */\n  tileDiscardPolicy: {\n    get: function () {\n      return this._imageryProvider.tileDiscardPolicy;\n    }\n  },\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._imageryProvider.errorEvent;\n    }\n  },\n  /**\n   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit\n   * the source of the imagery.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._imageryProvider.credit;\n    }\n  },\n  /**\n   * Gets the proxy used by this provider.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {Proxy}\n   * @readonly\n   */\n  proxy: {\n    get: function () {\n      return this._imageryProvider.proxy;\n    }\n  },\n  /**\n   * Gets a value indicating whether or not the images provided by this imagery provider\n   * include an alpha channel.  If this property is false, an alpha channel, if present, will\n   * be ignored.  If this property is true, any images without an alpha channel will be treated\n   * as if their alpha is 1.0 everywhere.  When this property is false, memory usage\n   * and texture upload time are reduced.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasAlphaChannel: {\n    get: function () {\n      return this._imageryProvider.hasAlphaChannel;\n    }\n  }\n});\n\n/**\n * Creates an {@link ImageryProvider} which provides 2D global tiled imagery from {@link https://developers.google.com/maps/documentation/tile/2d-tiles-overview|Google 2D Tiles}, streamed using the Cesium ion REST API.\n * @param {object} options Object with the following properties:\n * @param {string} options.assetId The Cesium ion asset id.\n * @param {\"satellite\" | \"terrain\" | \"roadmap\"} [options.mapType=\"satellite\"] The map type of the Google map imagery. Valid options are satellite, terrain, and roadmap. If overlayLayerType is set, mapType is ignored and a transparent overlay is returned. If overlayMapType is undefined, then a basemap of mapType is returned. layerRoadmap overlayLayerType is included in terrain and roadmap mapTypes.\n * @param {string} [options.language=\"en_US\"] an IETF language tag that specifies the language used to display information on the tiles\n * @param {string} [options.region=\"US\"] A Common Locale Data Repository region identifier (two uppercase letters) that represents the physical location of the user.\n * @param {\"layerRoadmap\" | \"layerStreetview\" | \"layerTraffic\"} [options.overlayLayerType] Returns a transparent overlay map with the specified layerType. If no value is provided, a basemap of mapType is returned. Use multiple instances of Google2DImageryProvider to add multiple Google Maps overlays to a scene. layerRoadmap is included in terrain and roadmap mapTypes, so adding as overlay to terrain or roadmap has no effect.\n * @param {Object} [options.styles] An array of JSON style objects that specify the appearance and detail level of map features such as roads, parks, and built-up areas. Styling is used to customize the standard Google base map. The styles parameter is valid only if the mapType is roadmap. For the complete style syntax, see the ({@link https://developers.google.com/maps/documentation/tile/style-reference|Google Style Reference}).\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid.  If not specified, the default ellipsoid is used.\n * @param {number} [options.minimumLevel=0] The minimum level-of-detail supported by the imagery provider.  Take care when specifying\n *                 this that the number of tiles at the minimum level is small, such as four or less.  A larger number is likely\n *                 to result in rendering problems.\n * @param {number} [options.maximumLevel=22] The maximum level-of-detail supported by the imagery provider.\n * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the image.\n * @param {Credit|string} [options.credit] A credit for the data source, which is displayed on the canvas.\n *\n * @returns {Promise<Google2DImageryProvider>} A promise that resolves to the created Google2DImageryProvider.\n *\n * @example\n * // Google 2D imagery provider\n * const googleTilesProvider = Cesium.Google2DImageryProvider.fromIonAssetId({\n *     assetId: 3830184\n * });\n * @example\n * // Google 2D roadmap overlay with custom styles\n * const googleTileProvider = Cesium.Google2DImageryProvider.fromIonAssetId({\n *     assetId: 3830184,\n *     overlayLayerType: \"layerRoadmap\",\n *     styles: [\n *         {\n *             stylers: [{ hue: \"#00ffe6\" }, { saturation: -20 }],\n *         },\n *         {\n *             featureType: \"road\",\n *             elementType: \"geometry\",\n *             stylers: [{ lightness: 100 }, { visibility: \"simplified\" }],\n *         },\n *     ],\n * });\n */\nGoogle2DImageryProvider.fromIonAssetId = async function (options) {\n  options = options ?? {};\n  options.mapType = options.mapType ?? \"satellite\";\n  options.language = options.language ?? \"en_US\";\n  options.region = options.region ?? \"US\";\n  const overlayLayerType = options.overlayLayerType;\n  //>>includeStart(\"debug\", pragmas.debug);\n  if (defined(overlayLayerType)) {\n    Check.typeOf.string(\"options.overlayLayerType\", overlayLayerType);\n  }\n  Check.defined(\"options.assetId\", options.assetId);\n  //>>includeEnd(\"debug\");\n\n  const queryOptions = buildQueryOptions(options);\n  const endpointResource = IonResource._createEndpointResource(options.assetId, {\n    queryParameters: {\n      options: JSON.stringify(queryOptions)\n    }\n  });\n  const endpoint = await endpointResource.fetchJson();\n  const endpointOptions = {\n    ...endpoint.options\n  };\n  delete endpointOptions.url;\n  const providerOptions = {\n    language: options.language,\n    region: options.region,\n    ellipsoid: options.ellipsoid,\n    minimumLevel: options.minimumLevel,\n    maximumLevel: options.maximumLevel,\n    rectangle: options.rectangle,\n    credit: options.credit\n  };\n  return new Google2DImageryProvider({\n    ...endpointOptions,\n    ...providerOptions,\n    url: new IonResource(endpoint, endpointResource)\n  });\n};\n\n/**\n * Creates an {@link ImageryProvider} which provides 2D global tiled imagery from {@link https://developers.google.com/maps/documentation/tile/2d-tiles-overview|Google 2D Tiles}.\n * @param {object} options Object with the following properties:\n * @param {string} [options.key=GoogleMaps.defaultApiKey] Your API key to access Google 2D Tiles. See {@link https://developers.google.com/maps/documentation/javascript/get-api-key} for instructions on how to create your own key.\n * @param {\"satellite\" | \"terrain\" | \"roadmap\"} [options.mapType=\"satellite\"] The map type of the Google map imagery. Valid options are satellite, terrain, and roadmap. If overlayLayerType is set, mapType is ignored and a transparent overlay is returned. If overlayMapType is undefined, then a basemap of mapType is returned. layerRoadmap overlayLayerType is included in terrain and roadmap mapTypes.\n * @param {string} [options.language=\"en_US\"] an IETF language tag that specifies the language used to display information on the tiles\n * @param {string} [options.region=\"US\"] A Common Locale Data Repository region identifier (two uppercase letters) that represents the physical location of the user.\n * @param {\"layerRoadmap\" | \"layerStreetview\" | \"layerTraffic\"} [options.overlayLayerType] Returns a transparent overlay map with the specified layerType. If no value is provided, a basemap of mapType is returned. Use multiple instances of Google2DImageryProvider to add multiple Google Maps overlays to a scene. layerRoadmap is included in terrain and roadmap mapTypes, so adding as overlay to terrain or roadmap has no effect.\n * @param {Object} [options.styles] An array of JSON style objects that specify the appearance and detail level of map features such as roads, parks, and built-up areas. Styling is used to customize the standard Google base map. The styles parameter is valid only if the mapType is roadmap. For the complete style syntax, see the ({@link https://developers.google.com/maps/documentation/tile/style-reference|Google Style Reference}).\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid.  If not specified, the default ellipsoid is used.\n * @param {number} [options.minimumLevel=0] The minimum level-of-detail supported by the imagery provider.  Take care when specifying\n *                 this that the number of tiles at the minimum level is small, such as four or less.  A larger number is likely\n *                 to result in rendering problems.\n * @param {number} [options.maximumLevel=22] The maximum level-of-detail supported by the imagery provider.\n * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the image.\n * @param {Credit|string} [options.credit] A credit for the data source, which is displayed on the canvas.\n *\n * @returns {Promise<Google2DImageryProvider>} A promise that resolves to the created Google2DImageryProvider.\n *\n * @example\n * // Use your own Google api key\n * Cesium.GoogleMaps.defaultApiKey = \"your-api-key\";\n *\n * const googleTilesProvider = Cesium.Google2DImageryProvider.fromUrl({\n *     mapType: \"satellite\"\n * });\n * @example\n * // Google 2D roadmap overlay with custom styles\n * Cesium.GoogleMaps.defaultApiKey = \"your-api-key\";\n *\n * const googleTileProvider = Cesium.Google2DImageryProvider.fromUrl({\n *     overlayLayerType: \"layerRoadmap\",\n *     styles: [\n *         {\n *             stylers: [{ hue: \"#00ffe6\" }, { saturation: -20 }],\n *         },\n *         {\n *             featureType: \"road\",\n *             elementType: \"geometry\",\n *             stylers: [{ lightness: 100 }, { visibility: \"simplified\" }],\n *         },\n *     ],\n * });\n */\nGoogle2DImageryProvider.fromUrl = async function (options) {\n  options = options ?? {};\n  options.mapType = options.mapType ?? \"satellite\";\n  options.language = options.language ?? \"en_US\";\n  options.region = options.region ?? \"US\";\n  options.url = options.url ?? GoogleMaps.mapTilesApiEndpoint;\n  options.key = options.key ?? GoogleMaps.defaultApiKey;\n  const overlayLayerType = options.overlayLayerType;\n  //>>includeStart(\"debug\", pragmas.debug);\n  if (defined(overlayLayerType)) {\n    Check.typeOf.string(\"overlayLayerType\", overlayLayerType);\n  }\n  if (!defined(options.key) && !defined(GoogleMaps.defaultApiKey)) {\n    throw new DeveloperError(\"options.key or GoogleMaps.defaultApiKey is required.\");\n  }\n  //>>includeEnd(\"debug\");\n\n  const sessionJson = await createGoogleImagerySession(options);\n  return new Google2DImageryProvider({\n    ...sessionJson,\n    ...options,\n    credit: options.credit ?? GoogleMaps.getDefaultCredit()\n  });\n};\n\n/**\n * Gets the credits to be displayed when a given tile is displayed.\n *\n * @param {number} x The tile X coordinate.\n * @param {number} y The tile Y coordinate.\n * @param {number} level The tile level;\n * @returns {Credit[]|undefined} The credits to be displayed when the tile is displayed.\n */\nGoogle2DImageryProvider.prototype.getTileCredits = function (x, y, level) {\n  const hasAttributions = defined(this._attributionsByLevel);\n  if (!hasAttributions || !defined(this._tileCredits)) {\n    return undefined;\n  }\n  const innerCredits = this._attributionsByLevel.get(level);\n  if (!defined(this._tileCredits)) {\n    return innerCredits;\n  }\n  return this._tileCredits.concat(innerCredits);\n};\n\n/**\n * Requests the image for a given tile.\n *\n * @param {number} x The tile X coordinate.\n * @param {number} y The tile Y coordinate.\n * @param {number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise<ImageryTypes>|undefined} A promise for the image that will resolve when the image is available, or\n *          undefined if there are too many active requests to the server, and the request should be retried later.\n */\nGoogle2DImageryProvider.prototype.requestImage = function (x, y, level, request) {\n  return this._imageryProvider.requestImage(x, y, level, request);\n};\n\n/**\n * Picking features is not currently supported by this imagery provider, so this function simply returns\n * undefined.\n *\n * @param {number} x The tile X coordinate.\n * @param {number} y The tile Y coordinate.\n * @param {number} level The tile level.\n * @param {number} longitude The longitude at which to pick features.\n * @param {number} latitude  The latitude at which to pick features.\n * @return {undefined} Undefined since picking is not supported.\n */\nGoogle2DImageryProvider.prototype.pickFeatures = function (x, y, level, longitude, latitude) {\n  return undefined;\n};\n\n/**\n * Get attribution for imagery from Google Maps to display in the credits\n * @private\n * @return {Promise<Map<Credit[]>>} The list of attribution sources to display in the credits.\n */\nGoogle2DImageryProvider.prototype.getViewportCredits = async function () {\n  const maximumLevel = this._maximumLevel;\n  const promises = [];\n  for (let level = 0; level < maximumLevel + 1; level++) {\n    promises.push(fetchViewportAttribution(this._viewportUrl, this._key, this._session, level));\n  }\n  const results = await Promise.all(promises);\n  const attributionsByLevel = new Map();\n  for (let level = 0; level < maximumLevel + 1; level++) {\n    const credits = [];\n    const attributions = results[level];\n    if (attributions) {\n      const levelCredits = new Credit(attributions);\n      credits.push(levelCredits);\n    }\n    attributionsByLevel.set(level, credits);\n  }\n  this._attributionsByLevel = attributionsByLevel;\n  return attributionsByLevel;\n};\nasync function fetchViewportAttribution(url, key, session, level) {\n  const viewport = await Resource.fetch({\n    url: url,\n    queryParameters: {\n      key,\n      session,\n      zoom: level,\n      north: 90,\n      south: -90,\n      east: 180,\n      west: -180\n    },\n    data: JSON.stringify(Frozen.EMPTY_OBJECT)\n  });\n  const viewportJson = JSON.parse(viewport);\n  return viewportJson.copyright;\n}\nfunction buildQueryOptions(options) {\n  const {\n    mapType,\n    overlayLayerType,\n    styles\n  } = options;\n  const queryOptions = {\n    mapType,\n    overlay: false\n  };\n  if (mapType === \"terrain\" && !defined(overlayLayerType)) {\n    queryOptions.layerTypes = [\"layerRoadmap\"];\n  }\n  if (defined(overlayLayerType)) {\n    queryOptions.mapType = \"satellite\";\n    queryOptions.overlay = true;\n    queryOptions.layerTypes = [overlayLayerType];\n  }\n  if (defined(styles)) {\n    queryOptions.styles = styles;\n  }\n  return queryOptions;\n}\nasync function createGoogleImagerySession(options) {\n  const {\n    language,\n    region,\n    key,\n    url\n  } = options;\n  const queryOptions = buildQueryOptions(options);\n  let baseUrl = url.url ?? url;\n  if (!trailingSlashRegex.test(baseUrl)) {\n    baseUrl += \"/\";\n  }\n  const response = await Resource.post({\n    url: `${baseUrl}v1/createSession`,\n    queryParameters: {\n      key: key\n    },\n    data: JSON.stringify({\n      ...queryOptions,\n      language,\n      region\n    })\n  });\n  const responseJson = JSON.parse(response);\n  return responseJson;\n}\nexport default Google2DImageryProvider;","map":{"version":3,"names":["Credit","Frozen","defined","DeveloperError","Resource","IonResource","Check","UrlTemplateImageryProvider","GoogleMaps","trailingSlashRegex","Google2DImageryProvider","options","EMPTY_OBJECT","_maximumLevel","maximumLevel","_minimumLevel","minimumLevel","session","tileWidth","tileHeight","key","_session","_key","_tileWidth","_tileHeight","resource","url","createIfNeeded","mapTilesApiEndpoint","templateUrl","getUrlComponent","test","tilesUrl","_viewportUrl","setQueryParameters","encodeURIComponent","credit","provider","ellipsoid","rectangle","_resource","_imageryProvider","_tileCredits","credits","_attributionsByLevel","undefined","getViewportCredits","Object","defineProperties","prototype","get","tilingScheme","tileDiscardPolicy","errorEvent","proxy","hasAlphaChannel","fromIonAssetId","mapType","language","region","overlayLayerType","typeOf","string","assetId","queryOptions","buildQueryOptions","endpointResource","_createEndpointResource","queryParameters","JSON","stringify","endpoint","fetchJson","endpointOptions","providerOptions","fromUrl","defaultApiKey","sessionJson","createGoogleImagerySession","getDefaultCredit","getTileCredits","x","y","level","hasAttributions","innerCredits","concat","requestImage","request","pickFeatures","longitude","latitude","promises","push","fetchViewportAttribution","results","Promise","all","attributionsByLevel","Map","attributions","levelCredits","set","viewport","fetch","zoom","north","south","east","west","data","viewportJson","parse","copyright","styles","overlay","layerTypes","baseUrl","response","post","responseJson"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Google2DImageryProvider.js"],"sourcesContent":["import Credit from \"../Core/Credit.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Resource from \"../Core/Resource.js\";\nimport IonResource from \"../Core/IonResource.js\";\nimport Check from \"../Core/Check.js\";\nimport UrlTemplateImageryProvider from \"./UrlTemplateImageryProvider.js\";\nimport GoogleMaps from \"../Core/GoogleMaps.js\";\n\nconst trailingSlashRegex = /\\/$/;\n\n/**\n * @typedef {Object} Google2DImageryProvider.ConstructorOptions\n *\n * Initialization options for the Google2DImageryProvider constructor\n *\n * @property {object} options Object with the following properties:\n * @property {string} options.key The Google api key to send with tile requests.\n * @property {string} options.session The Google session token that tracks the current state of your map and viewport.\n * @property {string|Resource|IonResource} options.url The Google 2D maps endpoint.\n * @property {string} options.tileWidth The width of each tile in pixels.\n * @property {string} options.tileHeight The height of each tile in pixels.\n * @property {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid.  If not specified, the default ellipsoid is used.\n * @property {number} [options.minimumLevel=0] The minimum level-of-detail supported by the imagery provider.  Take care when specifying\n *                 this that the number of tiles at the minimum level is small, such as four or less.  A larger number is likely\n *                 to result in rendering problems.\n * @property {number} [options.maximumLevel=22] The maximum level-of-detail supported by the imagery provider.\n * @property {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the image.\n */\n\n/**\n * <div class=\"notice\">\n * This object is normally not instantiated directly, use {@link Google2DImageryProvider.fromIonAssetId} or {@link Google2DImageryProvider.fromUrl}.\n * </div>\n *\n *\n * Provides 2D image tiles from {@link https://developers.google.com/maps/documentation/tile/2d-tiles-overview|Google 2D Tiles}.\n * \n * Google 2D Tiles can only be used with the Google geocoder.\n *\n * @alias Google2DImageryProvider\n * @constructor\n *\n * @param {Google2DImageryProvider.ConstructorOptions} options Object describing initialization options\n *\n * @example\n * // Google 2D imagery provider\n * const googleTilesProvider = Cesium.Google2DImageryProvider.fromIonAssetId({\n *     assetId: 3830184\n * });\n  * @example\n * // Use your own Google api key\n * Cesium.GoogleMaps.defaultApiKey = \"your-api-key\";\n * \n * const googleTilesProvider = Cesium.Google2DImageryProvider.fromUrl({\n *     mapType: \"SATELLITE\"\n * });\n *\n\n *\n * @see {@link https://developers.google.com/maps/documentation/tile/2d-tiles-overview}\n * @see {@link https://developers.google.com/maps/documentation/tile/session_tokens}\n * @see {@link https://en.wikipedia.org/wiki/IETF_language_tag|IETF Language Tags}\n * @see {@link https://cldr.unicode.org/|Common Locale Data Repository region identifiers}\n */\n\nfunction Google2DImageryProvider(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  this._maximumLevel = options.maximumLevel ?? 22;\n  this._minimumLevel = options.minimumLevel ?? 0;\n\n  //>>includeStart(\"debug\", pragmas.debug);\n  Check.defined(\"options.session\", options.session);\n  Check.defined(\"options.tileWidth\", options.tileWidth);\n  Check.defined(\"options.tileHeight\", options.tileHeight);\n  Check.defined(\"options.key\", options.key);\n  //>>includeEnd(\"debug\");\n\n  this._session = options.session;\n  this._key = options.key;\n  this._tileWidth = options.tileWidth;\n  this._tileHeight = options.tileHeight;\n\n  const resource =\n    options.url instanceof IonResource\n      ? options.url\n      : Resource.createIfNeeded(options.url ?? GoogleMaps.mapTilesApiEndpoint);\n\n  let templateUrl = resource.getUrlComponent();\n  if (!trailingSlashRegex.test(templateUrl)) {\n    templateUrl += \"/\";\n  }\n  const tilesUrl = `${templateUrl}v1/2dtiles/{z}/{x}/{y}`;\n  this._viewportUrl = `${templateUrl}tile/v1/viewport`;\n\n  resource.url = tilesUrl;\n\n  resource.setQueryParameters({\n    session: encodeURIComponent(options.session),\n    key: encodeURIComponent(options.key),\n  });\n\n  let credit;\n  if (defined(options.credit)) {\n    credit = options.credit;\n    if (typeof credit === \"string\") {\n      credit = new Credit(credit);\n    }\n  }\n\n  const provider = new UrlTemplateImageryProvider({\n    url: resource,\n    credit: credit,\n    tileWidth: options.tileWidth,\n    tileHeight: options.tileHeight,\n    ellipsoid: options.ellipsoid,\n    rectangle: options.rectangle,\n    maximumLevel: this._maximumLevel,\n    minimumLevel: this._minimumLevel,\n  });\n  provider._resource = resource;\n  this._imageryProvider = provider;\n\n  // This will be defined for ion resources\n  this._tileCredits = resource.credits;\n  this._attributionsByLevel = undefined;\n  // Asynchronously request and populate _attributionsByLevel\n  this.getViewportCredits();\n}\n\nObject.defineProperties(Google2DImageryProvider.prototype, {\n  /**\n   * Gets the URL of the Google 2D Imagery server.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {string}\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._imageryProvider.url;\n    },\n  },\n\n  /**\n   * Gets the rectangle, in radians, of the imagery provided by the instance.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function () {\n      return this._imageryProvider.rectangle;\n    },\n  },\n\n  /**\n   * Gets the width of each tile, in pixels.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {number}\n   * @readonly\n   */\n  tileWidth: {\n    get: function () {\n      return this._imageryProvider.tileWidth;\n    },\n  },\n\n  /**\n   * Gets the height of each tile, in pixels.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {number}\n   * @readonly\n   */\n  tileHeight: {\n    get: function () {\n      return this._imageryProvider.tileHeight;\n    },\n  },\n\n  /**\n   * Gets the maximum level-of-detail that can be requested.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {number|undefined}\n   * @readonly\n   */\n  maximumLevel: {\n    get: function () {\n      return this._imageryProvider.maximumLevel;\n    },\n  },\n\n  /**\n   * Gets the minimum level-of-detail that can be requested. Generally,\n   * a minimum level should only be used when the rectangle of the imagery is small\n   * enough that the number of tiles at the minimum level is small.  An imagery\n   * provider with more than a few tiles at the minimum level will lead to\n   * rendering problems.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {number}\n   * @readonly\n   */\n  minimumLevel: {\n    get: function () {\n      return this._imageryProvider.minimumLevel;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by the provider.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      return this._imageryProvider.tilingScheme;\n    },\n  },\n\n  /**\n   * Gets the tile discard policy.  If not undefined, the discard policy is responsible\n   * for filtering out \"missing\" tiles via its shouldDiscardImage function.  If this function\n   * returns undefined, no tiles are filtered.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {TileDiscardPolicy}\n   * @readonly\n   */\n  tileDiscardPolicy: {\n    get: function () {\n      return this._imageryProvider.tileDiscardPolicy;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._imageryProvider.errorEvent;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit\n   * the source of the imagery.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._imageryProvider.credit;\n    },\n  },\n\n  /**\n   * Gets the proxy used by this provider.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {Proxy}\n   * @readonly\n   */\n  proxy: {\n    get: function () {\n      return this._imageryProvider.proxy;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the images provided by this imagery provider\n   * include an alpha channel.  If this property is false, an alpha channel, if present, will\n   * be ignored.  If this property is true, any images without an alpha channel will be treated\n   * as if their alpha is 1.0 everywhere.  When this property is false, memory usage\n   * and texture upload time are reduced.\n   * @memberof Google2DImageryProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasAlphaChannel: {\n    get: function () {\n      return this._imageryProvider.hasAlphaChannel;\n    },\n  },\n});\n\n/**\n * Creates an {@link ImageryProvider} which provides 2D global tiled imagery from {@link https://developers.google.com/maps/documentation/tile/2d-tiles-overview|Google 2D Tiles}, streamed using the Cesium ion REST API.\n * @param {object} options Object with the following properties:\n * @param {string} options.assetId The Cesium ion asset id.\n * @param {\"satellite\" | \"terrain\" | \"roadmap\"} [options.mapType=\"satellite\"] The map type of the Google map imagery. Valid options are satellite, terrain, and roadmap. If overlayLayerType is set, mapType is ignored and a transparent overlay is returned. If overlayMapType is undefined, then a basemap of mapType is returned. layerRoadmap overlayLayerType is included in terrain and roadmap mapTypes.\n * @param {string} [options.language=\"en_US\"] an IETF language tag that specifies the language used to display information on the tiles\n * @param {string} [options.region=\"US\"] A Common Locale Data Repository region identifier (two uppercase letters) that represents the physical location of the user.\n * @param {\"layerRoadmap\" | \"layerStreetview\" | \"layerTraffic\"} [options.overlayLayerType] Returns a transparent overlay map with the specified layerType. If no value is provided, a basemap of mapType is returned. Use multiple instances of Google2DImageryProvider to add multiple Google Maps overlays to a scene. layerRoadmap is included in terrain and roadmap mapTypes, so adding as overlay to terrain or roadmap has no effect.\n * @param {Object} [options.styles] An array of JSON style objects that specify the appearance and detail level of map features such as roads, parks, and built-up areas. Styling is used to customize the standard Google base map. The styles parameter is valid only if the mapType is roadmap. For the complete style syntax, see the ({@link https://developers.google.com/maps/documentation/tile/style-reference|Google Style Reference}).\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid.  If not specified, the default ellipsoid is used.\n * @param {number} [options.minimumLevel=0] The minimum level-of-detail supported by the imagery provider.  Take care when specifying\n *                 this that the number of tiles at the minimum level is small, such as four or less.  A larger number is likely\n *                 to result in rendering problems.\n * @param {number} [options.maximumLevel=22] The maximum level-of-detail supported by the imagery provider.\n * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the image.\n * @param {Credit|string} [options.credit] A credit for the data source, which is displayed on the canvas.\n *\n * @returns {Promise<Google2DImageryProvider>} A promise that resolves to the created Google2DImageryProvider.\n *\n * @example\n * // Google 2D imagery provider\n * const googleTilesProvider = Cesium.Google2DImageryProvider.fromIonAssetId({\n *     assetId: 3830184\n * });\n * @example\n * // Google 2D roadmap overlay with custom styles\n * const googleTileProvider = Cesium.Google2DImageryProvider.fromIonAssetId({\n *     assetId: 3830184,\n *     overlayLayerType: \"layerRoadmap\",\n *     styles: [\n *         {\n *             stylers: [{ hue: \"#00ffe6\" }, { saturation: -20 }],\n *         },\n *         {\n *             featureType: \"road\",\n *             elementType: \"geometry\",\n *             stylers: [{ lightness: 100 }, { visibility: \"simplified\" }],\n *         },\n *     ],\n * });\n */\nGoogle2DImageryProvider.fromIonAssetId = async function (options) {\n  options = options ?? {};\n  options.mapType = options.mapType ?? \"satellite\";\n  options.language = options.language ?? \"en_US\";\n  options.region = options.region ?? \"US\";\n\n  const overlayLayerType = options.overlayLayerType;\n  //>>includeStart(\"debug\", pragmas.debug);\n  if (defined(overlayLayerType)) {\n    Check.typeOf.string(\"options.overlayLayerType\", overlayLayerType);\n  }\n  Check.defined(\"options.assetId\", options.assetId);\n  //>>includeEnd(\"debug\");\n\n  const queryOptions = buildQueryOptions(options);\n\n  const endpointResource = IonResource._createEndpointResource(\n    options.assetId,\n    {\n      queryParameters: {\n        options: JSON.stringify(queryOptions),\n      },\n    },\n  );\n\n  const endpoint = await endpointResource.fetchJson();\n  const endpointOptions = { ...endpoint.options };\n  delete endpointOptions.url;\n\n  const providerOptions = {\n    language: options.language,\n    region: options.region,\n    ellipsoid: options.ellipsoid,\n    minimumLevel: options.minimumLevel,\n    maximumLevel: options.maximumLevel,\n    rectangle: options.rectangle,\n    credit: options.credit,\n  };\n\n  return new Google2DImageryProvider({\n    ...endpointOptions,\n    ...providerOptions,\n    url: new IonResource(endpoint, endpointResource),\n  });\n};\n\n/**\n * Creates an {@link ImageryProvider} which provides 2D global tiled imagery from {@link https://developers.google.com/maps/documentation/tile/2d-tiles-overview|Google 2D Tiles}.\n * @param {object} options Object with the following properties:\n * @param {string} [options.key=GoogleMaps.defaultApiKey] Your API key to access Google 2D Tiles. See {@link https://developers.google.com/maps/documentation/javascript/get-api-key} for instructions on how to create your own key.\n * @param {\"satellite\" | \"terrain\" | \"roadmap\"} [options.mapType=\"satellite\"] The map type of the Google map imagery. Valid options are satellite, terrain, and roadmap. If overlayLayerType is set, mapType is ignored and a transparent overlay is returned. If overlayMapType is undefined, then a basemap of mapType is returned. layerRoadmap overlayLayerType is included in terrain and roadmap mapTypes.\n * @param {string} [options.language=\"en_US\"] an IETF language tag that specifies the language used to display information on the tiles\n * @param {string} [options.region=\"US\"] A Common Locale Data Repository region identifier (two uppercase letters) that represents the physical location of the user.\n * @param {\"layerRoadmap\" | \"layerStreetview\" | \"layerTraffic\"} [options.overlayLayerType] Returns a transparent overlay map with the specified layerType. If no value is provided, a basemap of mapType is returned. Use multiple instances of Google2DImageryProvider to add multiple Google Maps overlays to a scene. layerRoadmap is included in terrain and roadmap mapTypes, so adding as overlay to terrain or roadmap has no effect.\n * @param {Object} [options.styles] An array of JSON style objects that specify the appearance and detail level of map features such as roads, parks, and built-up areas. Styling is used to customize the standard Google base map. The styles parameter is valid only if the mapType is roadmap. For the complete style syntax, see the ({@link https://developers.google.com/maps/documentation/tile/style-reference|Google Style Reference}).\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid.  If not specified, the default ellipsoid is used.\n * @param {number} [options.minimumLevel=0] The minimum level-of-detail supported by the imagery provider.  Take care when specifying\n *                 this that the number of tiles at the minimum level is small, such as four or less.  A larger number is likely\n *                 to result in rendering problems.\n * @param {number} [options.maximumLevel=22] The maximum level-of-detail supported by the imagery provider.\n * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the image.\n * @param {Credit|string} [options.credit] A credit for the data source, which is displayed on the canvas.\n *\n * @returns {Promise<Google2DImageryProvider>} A promise that resolves to the created Google2DImageryProvider.\n *\n * @example\n * // Use your own Google api key\n * Cesium.GoogleMaps.defaultApiKey = \"your-api-key\";\n *\n * const googleTilesProvider = Cesium.Google2DImageryProvider.fromUrl({\n *     mapType: \"satellite\"\n * });\n * @example\n * // Google 2D roadmap overlay with custom styles\n * Cesium.GoogleMaps.defaultApiKey = \"your-api-key\";\n *\n * const googleTileProvider = Cesium.Google2DImageryProvider.fromUrl({\n *     overlayLayerType: \"layerRoadmap\",\n *     styles: [\n *         {\n *             stylers: [{ hue: \"#00ffe6\" }, { saturation: -20 }],\n *         },\n *         {\n *             featureType: \"road\",\n *             elementType: \"geometry\",\n *             stylers: [{ lightness: 100 }, { visibility: \"simplified\" }],\n *         },\n *     ],\n * });\n */\nGoogle2DImageryProvider.fromUrl = async function (options) {\n  options = options ?? {};\n  options.mapType = options.mapType ?? \"satellite\";\n  options.language = options.language ?? \"en_US\";\n  options.region = options.region ?? \"US\";\n  options.url = options.url ?? GoogleMaps.mapTilesApiEndpoint;\n  options.key = options.key ?? GoogleMaps.defaultApiKey;\n\n  const overlayLayerType = options.overlayLayerType;\n  //>>includeStart(\"debug\", pragmas.debug);\n  if (defined(overlayLayerType)) {\n    Check.typeOf.string(\"overlayLayerType\", overlayLayerType);\n  }\n  if (!defined(options.key) && !defined(GoogleMaps.defaultApiKey)) {\n    throw new DeveloperError(\n      \"options.key or GoogleMaps.defaultApiKey is required.\",\n    );\n  }\n  //>>includeEnd(\"debug\");\n\n  const sessionJson = await createGoogleImagerySession(options);\n  return new Google2DImageryProvider({\n    ...sessionJson,\n    ...options,\n    credit: options.credit ?? GoogleMaps.getDefaultCredit(),\n  });\n};\n\n/**\n * Gets the credits to be displayed when a given tile is displayed.\n *\n * @param {number} x The tile X coordinate.\n * @param {number} y The tile Y coordinate.\n * @param {number} level The tile level;\n * @returns {Credit[]|undefined} The credits to be displayed when the tile is displayed.\n */\nGoogle2DImageryProvider.prototype.getTileCredits = function (x, y, level) {\n  const hasAttributions = defined(this._attributionsByLevel);\n\n  if (!hasAttributions || !defined(this._tileCredits)) {\n    return undefined;\n  }\n\n  const innerCredits = this._attributionsByLevel.get(level);\n  if (!defined(this._tileCredits)) {\n    return innerCredits;\n  }\n\n  return this._tileCredits.concat(innerCredits);\n};\n\n/**\n * Requests the image for a given tile.\n *\n * @param {number} x The tile X coordinate.\n * @param {number} y The tile Y coordinate.\n * @param {number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise<ImageryTypes>|undefined} A promise for the image that will resolve when the image is available, or\n *          undefined if there are too many active requests to the server, and the request should be retried later.\n */\nGoogle2DImageryProvider.prototype.requestImage = function (\n  x,\n  y,\n  level,\n  request,\n) {\n  return this._imageryProvider.requestImage(x, y, level, request);\n};\n\n/**\n * Picking features is not currently supported by this imagery provider, so this function simply returns\n * undefined.\n *\n * @param {number} x The tile X coordinate.\n * @param {number} y The tile Y coordinate.\n * @param {number} level The tile level.\n * @param {number} longitude The longitude at which to pick features.\n * @param {number} latitude  The latitude at which to pick features.\n * @return {undefined} Undefined since picking is not supported.\n */\nGoogle2DImageryProvider.prototype.pickFeatures = function (\n  x,\n  y,\n  level,\n  longitude,\n  latitude,\n) {\n  return undefined;\n};\n\n/**\n * Get attribution for imagery from Google Maps to display in the credits\n * @private\n * @return {Promise<Map<Credit[]>>} The list of attribution sources to display in the credits.\n */\nGoogle2DImageryProvider.prototype.getViewportCredits = async function () {\n  const maximumLevel = this._maximumLevel;\n\n  const promises = [];\n  for (let level = 0; level < maximumLevel + 1; level++) {\n    promises.push(\n      fetchViewportAttribution(\n        this._viewportUrl,\n        this._key,\n        this._session,\n        level,\n      ),\n    );\n  }\n  const results = await Promise.all(promises);\n\n  const attributionsByLevel = new Map();\n  for (let level = 0; level < maximumLevel + 1; level++) {\n    const credits = [];\n    const attributions = results[level];\n    if (attributions) {\n      const levelCredits = new Credit(attributions);\n      credits.push(levelCredits);\n    }\n    attributionsByLevel.set(level, credits);\n  }\n\n  this._attributionsByLevel = attributionsByLevel;\n\n  return attributionsByLevel;\n};\n\nasync function fetchViewportAttribution(url, key, session, level) {\n  const viewport = await Resource.fetch({\n    url: url,\n    queryParameters: {\n      key,\n      session,\n      zoom: level,\n      north: 90,\n      south: -90,\n      east: 180,\n      west: -180,\n    },\n    data: JSON.stringify(Frozen.EMPTY_OBJECT),\n  });\n  const viewportJson = JSON.parse(viewport);\n  return viewportJson.copyright;\n}\n\nfunction buildQueryOptions(options) {\n  const { mapType, overlayLayerType, styles } = options;\n\n  const queryOptions = {\n    mapType,\n    overlay: false,\n  };\n\n  if (mapType === \"terrain\" && !defined(overlayLayerType)) {\n    queryOptions.layerTypes = [\"layerRoadmap\"];\n  }\n\n  if (defined(overlayLayerType)) {\n    queryOptions.mapType = \"satellite\";\n    queryOptions.overlay = true;\n    queryOptions.layerTypes = [overlayLayerType];\n  }\n  if (defined(styles)) {\n    queryOptions.styles = styles;\n  }\n  return queryOptions;\n}\n\nasync function createGoogleImagerySession(options) {\n  const { language, region, key, url } = options;\n\n  const queryOptions = buildQueryOptions(options);\n\n  let baseUrl = url.url ?? url;\n  if (!trailingSlashRegex.test(baseUrl)) {\n    baseUrl += \"/\";\n  }\n\n  const response = await Resource.post({\n    url: `${baseUrl}v1/createSession`,\n    queryParameters: { key: key },\n    data: JSON.stringify({\n      ...queryOptions,\n      language,\n      region,\n    }),\n  });\n  const responseJson = JSON.parse(response);\n  return responseJson;\n}\n\nexport default Google2DImageryProvider;\n"],"mappings":"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C;EACA,IAAI,CAACC,kBAAkB,CAAC,CAAC;AAC3B;AAEAC,MAAM,CAACC,gBAAgB,CAACtC,uBAAuB,CAACuC,SAAS,EAAE;EACzD;AACF;AACA;AACA;AACA;AACA;EACEvB,GAAG,EAAE;IACHwB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACT,gBAAgB,CAACf,GAAG;IAClC;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACEa,SAAS,EAAE;IACTW,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACT,gBAAgB,CAACF,SAAS;IACxC;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACErB,SAAS,EAAE;IACTgC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACT,gBAAgB,CAACvB,SAAS;IACxC;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACEC,UAAU,EAAE;IACV+B,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACT,gBAAgB,CAACtB,UAAU;IACzC;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACEL,YAAY,EAAE;IACZoC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACT,gBAAgB,CAAC3B,YAAY;IAC3C;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEE,YAAY,EAAE;IACZkC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACT,gBAAgB,CAACzB,YAAY;IAC3C;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACEmC,YAAY,EAAE;IACZD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACT,gBAAgB,CAACU,YAAY;IAC3C;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,iBAAiB,EAAE;IACjBF,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACT,gBAAgB,CAACW,iBAAiB;IAChD;EA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}