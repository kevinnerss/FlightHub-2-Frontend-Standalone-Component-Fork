{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"/* Ellipsoid defines (set in Scene/VoxelEllipsoidShape.js)\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY\\n\\\n#define ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE\\n\\\n#define ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED\\n\\\n#define ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE\\n\\\n*/\\n\\\n\\n\\\nuniform vec3 u_cameraPositionCartographic; // (longitude, latitude, height) in radians and meters\\n\\\nuniform vec2 u_ellipsoidCurvatureAtLatitude;\\n\\\nuniform mat3 u_ellipsoidEcToEastNorthUp;\\n\\\nuniform vec3 u_ellipsoidRadii;\\n\\\nuniform vec2 u_evoluteScale; // (radii.x ^ 2 - radii.z ^ 2) * vec2(1.0, -1.0) / radii;\\n\\\nuniform vec3 u_ellipsoidInverseRadiiSquared;\\n\\\n#if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY) || defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY) || defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED)\\n\\\n    uniform vec3 u_ellipsoidShapeUvLongitudeMinMaxMid;\\n\\\n#endif\\n\\\n#if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE)\\n\\\n    uniform vec2 u_ellipsoidLocalToShapeUvLongitude; // x = scale, y = offset\\n\\\n    uniform float u_ellipsoidShapeUvLongitudeRangeOrigin;\\n\\\n#endif\\n\\\n#if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE)\\n\\\n    uniform vec2 u_ellipsoidLocalToShapeUvLatitude; // x = scale, y = offset\\n\\\n#endif\\n\\\nuniform float u_ellipsoidInverseHeightDifference;\\n\\\n\\n\\\nuniform ivec4 u_cameraTileCoordinates;\\n\\\nuniform vec3 u_cameraTileUv;\\n\\\n\\n\\\n// robust iterative solution without trig functions\\n\\\n// https://github.com/0xfaded/ellipse_demo/issues/1\\n\\\n// https://stackoverflow.com/questions/22959698/distance-from-given-point-to-given-ellipse\\n\\\n// Extended to return radius of curvature along with the point\\n\\\nvec3 nearestPointAndRadiusOnEllipse(vec2 pos, vec2 radii) {\\n\\\n    vec2 p = abs(pos);\\n\\\n    vec2 inverseRadii = 1.0 / radii;\\n\\\n\\n\\\n    // We describe the ellipse parametrically: v = radii * vec2(cos(t), sin(t))\\n\\\n    // but store the cos and sin of t in a vec2 for efficiency.\\n\\\n    // Initial guess: t = pi/4\\n\\\n    vec2 tTrigs = vec2(0.7071067811865476);\\n\\\n    // Initial guess of point on ellipsoid\\n\\\n    vec2 v = radii * tTrigs;\\n\\\n    // Center of curvature of the ellipse at v\\n\\\n    vec2 evolute = u_evoluteScale * tTrigs * tTrigs * tTrigs;\\n\\\n\\n\\\n    const int iterations = 3;\\n\\\n    for (int i = 0; i < iterations; ++i) {\\n\\\n        // Find the (approximate) intersection of p - evolute with the ellipsoid.\\n\\\n        vec2 q = normalize(p - evolute) * length(v - evolute);\\n\\\n        // Update the estimate of t.\\n\\\n        tTrigs = (q + evolute) * inverseRadii;\\n\\\n        tTrigs = normalize(clamp(tTrigs, 0.0, 1.0));\\n\\\n        v = radii * tTrigs;\\n\\\n        evolute = u_evoluteScale * tTrigs * tTrigs * tTrigs;\\n\\\n    }\\n\\\n\\n\\\n    return vec3(v * sign(pos), length(v - evolute));\\n\\\n}\\n\\\n\\n\\\nmat3 convertLocalToShapeSpaceDerivative(in vec3 position) {\\n\\\n    vec3 east = normalize(vec3(-position.y, position.x, 0.0));\\n\\\n\\n\\\n    // Convert the 3D position to a 2D position relative to the ellipse (radii.x, radii.z)\\n\\\n    // (assume radii.y == radii.x) and find the nearest point on the ellipse and its normal\\n\\\n    float distanceFromZAxis = length(position.xy);\\n\\\n    vec2 posEllipse = vec2(distanceFromZAxis, position.z);\\n\\\n    vec3 surfacePointAndRadius = nearestPointAndRadiusOnEllipse(posEllipse, u_ellipsoidRadii.xz);\\n\\\n    vec2 surfacePoint = surfacePointAndRadius.xy;\\n\\\n\\n\\\n    vec2 normal2d = normalize(surfacePoint * u_ellipsoidInverseRadiiSquared.xz);\\n\\\n    vec3 north = vec3(-normal2d.y * normalize(position.xy), abs(normal2d.x));\\n\\\n\\n\\\n    float heightSign = length(posEllipse) < length(surfacePoint) ? -1.0 : 1.0;\\n\\\n    float height = heightSign * length(posEllipse - surfacePoint);\\n\\\n    vec3 up = normalize(cross(east, north));\\n\\\n\\n\\\n    return mat3(east / distanceFromZAxis, north / (surfacePointAndRadius.z + height), up);\\n\\\n}\\n\\\n\\n\\\nvec3 scaleShapeUvToShapeSpace(in vec3 shapeUv) {\\n\\\n    // Convert from [0, 1] to radians [-pi, pi]\\n\\\n    float longitude = shapeUv.x * czm_twoPi;\\n\\\n    #if defined (ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE)\\n\\\n        longitude /= u_ellipsoidLocalToShapeUvLongitude.x;\\n\\\n    #endif\\n\\\n\\n\\\n    // Convert from [0, 1] to radians [-pi/2, pi/2]\\n\\\n    float latitude = shapeUv.y * czm_pi;\\n\\\n    #if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE)\\n\\\n        latitude /= u_ellipsoidLocalToShapeUvLatitude.x;\\n\\\n    #endif\\n\\\n\\n\\\n    float height = shapeUv.z / u_ellipsoidInverseHeightDifference;\\n\\\n\\n\\\n    return vec3(longitude, latitude, height);\\n\\\n}\\n\\\n\\n\\\nvec3 convertEcToDeltaShape(in vec3 positionEC) {\\n\\\n    vec3 enu = u_ellipsoidEcToEastNorthUp * positionEC;\\n\\\n\\n\\\n    // 1. Compute the change in longitude from the camera to the ENU point\\n\\\n    // First project the camera and ENU positions to the equatorial XY plane,\\n\\\n    // positioning the camera on the +x axis, so that enu.x projects along the +y axis\\n\\\n    float cosLatitude = cos(u_cameraPositionCartographic.y);\\n\\\n    float sinLatitude = sin(u_cameraPositionCartographic.y);\\n\\\n    float primeVerticalRadius = 1.0 / u_ellipsoidCurvatureAtLatitude.x;\\n\\\n    vec2 cameraXY = vec2((primeVerticalRadius + u_cameraPositionCartographic.z) * cosLatitude, 0.0);\\n\\\n    // Note precision loss in positionXY.x if length(enu) << length(cameraXY)\\n\\\n    vec2 positionXY = cameraXY + vec2(-enu.y * sinLatitude + enu.z * cosLatitude, enu.x);\\n\\\n    float dLongitude = atan(positionXY.y, positionXY.x);\\n\\\n\\n\\\n    // 2. Find the longitude component of positionXY, by rotating about Z until the y component is zero.\\n\\\n    // Use the versine  to compute the change in x directly from the change in angle:\\n\\\n    //   versine(angle) = 2 * sin^2(angle/2)\\n\\\n    float sinHalfLongitude = sin(dLongitude / 2.0);\\n\\\n    float dx = length(positionXY) * 2.0 * sinHalfLongitude * sinHalfLongitude;\\n\\\n    // Rotate longitude component back to ENU North and Up, and remove from enu\\n\\\n    enu += vec3(-enu.x, -dx * sinLatitude, dx * cosLatitude);\\n\\\n\\n\\\n    // 3. Compute the change in latitude from the camera to the ENU point.\\n\\\n    // First project the camera and ENU positions to the meridional ZX plane,\\n\\\n    // positioning the camera on the +Z axis, so that enu.y maps to the +X axis.\\n\\\n    float meridionalRadius = 1.0 / u_ellipsoidCurvatureAtLatitude.y;\\n\\\n    vec2 cameraZX = vec2(meridionalRadius + u_cameraPositionCartographic.z, 0.0);\\n\\\n    vec2 positionZX = cameraZX + vec2(enu.z, enu.y);\\n\\\n    float dLatitude = atan(positionZX.y, positionZX.x);\\n\\\n\\n\\\n    // 4. Compute the change in height above the ellipsoid\\n\\\n    // Find the change in enu.z associated with rotating the point to the latitude of the camera\\n\\\n    float sinHalfLatitude = sin(dLatitude / 2.0);\\n\\\n    float dz = length(positionZX) * 2.0 * sinHalfLatitude * sinHalfLatitude;\\n\\\n    // The remaining change in enu.z is the change in height above the ellipsoid\\n\\\n    float dHeight = enu.z + dz;\\n\\\n\\n\\\n    return vec3(dLongitude, dLatitude, dHeight);\\n\\\n}\\n\\\n\\n\\\nvec3 convertEcToDeltaTile(in vec3 positionEC) {\\n\\\n    vec3 deltaShape = convertEcToDeltaShape(positionEC);\\n\\\n    // Convert to tileset coordinates in [0, 1]\\n\\\n    float dx = deltaShape.x / czm_twoPi;\\n\\\n\\n\\\n#if (defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE))\\n\\\n    // Wrap to ensure dx is not crossing through the unoccupied angle range, where\\n\\\n    // angle to tile coordinate conversions would be more complicated\\n\\\n    float cameraUvLongitude = (u_cameraPositionCartographic.x + czm_pi) / czm_twoPi;\\n\\\n    float cameraUvLongitudeShift = fract(cameraUvLongitude - u_ellipsoidShapeUvLongitudeRangeOrigin);\\n\\\n    float rawOutputUvLongitude = cameraUvLongitudeShift + dx;\\n\\\n    float rotation = floor(rawOutputUvLongitude);\\n\\\n    dx -= rotation;\\n\\\n    dx *= u_ellipsoidLocalToShapeUvLongitude.x;\\n\\\n#endif\\n\\\n\\n\\\n    float dy = deltaShape.y / czm_pi;\\n\\\n#if (defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE))\\n\\\n    dy *= u_ellipsoidLocalToShapeUvLatitude.x;\\n\\\n#endif\\n\\\n\\n\\\n    float dz = u_ellipsoidInverseHeightDifference * deltaShape.z;\\n\\\n    // Convert to tile coordinate changes\\n\\\n    return vec3(dx, dy, dz) * float(1 << u_cameraTileCoordinates.w);\\n\\\n}\\n\\\n\\n\\\nTileAndUvCoordinate getTileAndUvCoordinate(in vec3 positionEC) {\\n\\\n    vec3 deltaTileCoordinate = convertEcToDeltaTile(positionEC);\\n\\\n    vec3 tileUvSum = u_cameraTileUv + deltaTileCoordinate;\\n\\\n    ivec3 tileCoordinate = u_cameraTileCoordinates.xyz + ivec3(floor(tileUvSum));\\n\\\n    int maxTileCoordinate = (1 << u_cameraTileCoordinates.w) - 1;\\n\\\n    tileCoordinate.y = min(max(0, tileCoordinate.y), maxTileCoordinate);\\n\\\n    tileCoordinate.z = min(max(0, tileCoordinate.z), maxTileCoordinate);\\n\\\n#if (!defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE))\\n\\\n    ivec3 tileCoordinateChange = tileCoordinate - u_cameraTileCoordinates.xyz;\\n\\\n    if (tileCoordinate.x < 0) {\\n\\\n        tileCoordinate.x += (maxTileCoordinate + 1);\\n\\\n    } else if (tileCoordinate.x > maxTileCoordinate) {\\n\\\n        tileCoordinate.x -= (maxTileCoordinate + 1);\\n\\\n    }\\n\\\n#else\\n\\\n    tileCoordinate.x = min(max(0, tileCoordinate.x), maxTileCoordinate);\\n\\\n    ivec3 tileCoordinateChange = tileCoordinate - u_cameraTileCoordinates.xyz;\\n\\\n#endif\\n\\\n    vec3 tileUv = tileUvSum - vec3(tileCoordinateChange);\\n\\\n#if (!defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE))\\n\\\n    // If there is only one tile spanning 2*PI angle, the coordinate wraps around\\n\\\n    tileUv.x = (u_cameraTileCoordinates.w == 0) ? fract(tileUv.x) : clamp(tileUv.x, 0.0, 1.0);\\n\\\n#else\\n\\\n    tileUv.x = clamp(tileUv.x, 0.0, 1.0);\\n\\\n#endif\\n\\\n    tileUv.y = clamp(tileUv.y, 0.0, 1.0);\\n\\\n    tileUv.z = clamp(tileUv.z, 0.0, 1.0);\\n\\\n    return TileAndUvCoordinate(ivec4(tileCoordinate, u_cameraTileCoordinates.w), tileUv);\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Shaders/Voxels/convertLocalToEllipsoidUv.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"/* Ellipsoid defines (set in Scene/VoxelEllipsoidShape.js)\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY\\n\\\n#define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY\\n\\\n#define ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE\\n\\\n#define ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED\\n\\\n#define ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE\\n\\\n*/\\n\\\n\\n\\\nuniform vec3 u_cameraPositionCartographic; // (longitude, latitude, height) in radians and meters\\n\\\nuniform vec2 u_ellipsoidCurvatureAtLatitude;\\n\\\nuniform mat3 u_ellipsoidEcToEastNorthUp;\\n\\\nuniform vec3 u_ellipsoidRadii;\\n\\\nuniform vec2 u_evoluteScale; // (radii.x ^ 2 - radii.z ^ 2) * vec2(1.0, -1.0) / radii;\\n\\\nuniform vec3 u_ellipsoidInverseRadiiSquared;\\n\\\n#if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY) || defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY) || defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED)\\n\\\n    uniform vec3 u_ellipsoidShapeUvLongitudeMinMaxMid;\\n\\\n#endif\\n\\\n#if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE)\\n\\\n    uniform vec2 u_ellipsoidLocalToShapeUvLongitude; // x = scale, y = offset\\n\\\n    uniform float u_ellipsoidShapeUvLongitudeRangeOrigin;\\n\\\n#endif\\n\\\n#if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE)\\n\\\n    uniform vec2 u_ellipsoidLocalToShapeUvLatitude; // x = scale, y = offset\\n\\\n#endif\\n\\\nuniform float u_ellipsoidInverseHeightDifference;\\n\\\n\\n\\\nuniform ivec4 u_cameraTileCoordinates;\\n\\\nuniform vec3 u_cameraTileUv;\\n\\\n\\n\\\n// robust iterative solution without trig functions\\n\\\n// https://github.com/0xfaded/ellipse_demo/issues/1\\n\\\n// https://stackoverflow.com/questions/22959698/distance-from-given-point-to-given-ellipse\\n\\\n// Extended to return radius of curvature along with the point\\n\\\nvec3 nearestPointAndRadiusOnEllipse(vec2 pos, vec2 radii) {\\n\\\n    vec2 p = abs(pos);\\n\\\n    vec2 inverseRadii = 1.0 / radii;\\n\\\n\\n\\\n    // We describe the ellipse parametrically: v = radii * vec2(cos(t), sin(t))\\n\\\n    // but store the cos and sin of t in a vec2 for efficiency.\\n\\\n    // Initial guess: t = pi/4\\n\\\n    vec2 tTrigs = vec2(0.7071067811865476);\\n\\\n    // Initial guess of point on ellipsoid\\n\\\n    vec2 v = radii * tTrigs;\\n\\\n    // Center of curvature of the ellipse at v\\n\\\n    vec2 evolute = u_evoluteScale * tTrigs * tTrigs * tTrigs;\\n\\\n\\n\\\n    const int iterations = 3;\\n\\\n    for (int i = 0; i < iterations; ++i) {\\n\\\n        // Find the (approximate) intersection of p - evolute with the ellipsoid.\\n\\\n        vec2 q = normalize(p - evolute) * length(v - evolute);\\n\\\n        // Update the estimate of t.\\n\\\n        tTrigs = (q + evolute) * inverseRadii;\\n\\\n        tTrigs = normalize(clamp(tTrigs, 0.0, 1.0));\\n\\\n        v = radii * tTrigs;\\n\\\n        evolute = u_evoluteScale * tTrigs * tTrigs * tTrigs;\\n\\\n    }\\n\\\n\\n\\\n    return vec3(v * sign(pos), length(v - evolute));\\n\\\n}\\n\\\n\\n\\\nmat3 convertLocalToShapeSpaceDerivative(in vec3 position) {\\n\\\n    vec3 east = normalize(vec3(-position.y, position.x, 0.0));\\n\\\n\\n\\\n    // Convert the 3D position to a 2D position relative to the ellipse (radii.x, radii.z)\\n\\\n    // (assume radii.y == radii.x) and find the nearest point on the ellipse and its normal\\n\\\n    float distanceFromZAxis = length(position.xy);\\n\\\n    vec2 posEllipse = vec2(distanceFromZAxis, position.z);\\n\\\n    vec3 surfacePointAndRadius = nearestPointAndRadiusOnEllipse(posEllipse, u_ellipsoidRadii.xz);\\n\\\n    vec2 surfacePoint = surfacePointAndRadius.xy;\\n\\\n\\n\\\n    vec2 normal2d = normalize(surfacePoint * u_ellipsoidInverseRadiiSquared.xz);\\n\\\n    vec3 north = vec3(-normal2d.y * normalize(position.xy), abs(normal2d.x));\\n\\\n\\n\\\n    float heightSign = length(posEllipse) < length(surfacePoint) ? -1.0 : 1.0;\\n\\\n    float height = heightSign * length(posEllipse - surfacePoint);\\n\\\n    vec3 up = normalize(cross(east, north));\\n\\\n\\n\\\n    return mat3(east / distanceFromZAxis, north / (surfacePointAndRadius.z + height), up);\\n\\\n}\\n\\\n\\n\\\nvec3 scaleShapeUvToShapeSpace(in vec3 shapeUv) {\\n\\\n    // Convert from [0, 1] to radians [-pi, pi]\\n\\\n    float longitude = shapeUv.x * czm_twoPi;\\n\\\n    #if defined (ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE)\\n\\\n        longitude /= u_ellipsoidLocalToShapeUvLongitude.x;\\n\\\n    #endif\\n\\\n\\n\\\n    // Convert from [0, 1] to radians [-pi/2, pi/2]\\n\\\n    float latitude = shapeUv.y * czm_pi;\\n\\\n    #if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE)\\n\\\n        latitude /= u_ellipsoidLocalToShapeUvLatitude.x;\\n\\\n    #endif\\n\\\n\\n\\\n    float height = shapeUv.z / u_ellipsoidInverseHeightDifference;\\n\\\n\\n\\\n    return vec3(longitude, latitude, height);\\n\\\n}\\n\\\n\\n\\\nvec3 convertEcToDeltaShape(in vec3 positionEC) {\\n\\\n    vec3 enu = u_ellipsoidEcToEastNorthUp * positionEC;\\n\\\n\\n\\\n    // 1. Compute the change in longitude from the camera to the ENU point\\n\\\n    // First project the camera and ENU positions to the equatorial XY plane,\\n\\\n    // positioning the camera on the +x axis, so that enu.x projects along the +y axis\\n\\\n    float cosLatitude = cos(u_cameraPositionCartographic.y);\\n\\\n    float sinLatitude = sin(u_cameraPositionCartographic.y);\\n\\\n    float primeVerticalRadius = 1.0 / u_ellipsoidCurvatureAtLatitude.x;\\n\\\n    vec2 cameraXY = vec2((primeVerticalRadius + u_cameraPositionCartographic.z) * cosLatitude, 0.0);\\n\\\n    // Note precision loss in positionXY.x if length(enu) << length(cameraXY)\\n\\\n    vec2 positionXY = cameraXY + vec2(-enu.y * sinLatitude + enu.z * cosLatitude, enu.x);\\n\\\n    float dLongitude = atan(positionXY.y, positionXY.x);\\n\\\n\\n\\\n    // 2. Find the longitude component of positionXY, by rotating about Z until the y component is zero.\\n\\\n    // Use the versine  to compute the change in x directly from the change in angle:\\n\\\n    //   versine(angle) = 2 * sin^2(angle/2)\\n\\\n    float sinHalfLongitude = sin(dLongitude / 2.0);\\n\\\n    float dx = length(positionXY) * 2.0 * sinHalfLongitude * sinHalfLongitude;\\n\\\n    // Rotate longitude component back to ENU North and Up, and remove from enu\\n\\\n    enu += vec3(-enu.x, -dx * sinLatitude, dx * cosLatitude);\\n\\\n\\n\\\n    // 3. Compute the change in latitude from the camera to the ENU point.\\n\\\n    // First project the camera and ENU positions to the meridional ZX plane,\\n\\\n    // positioning the camera on the +Z axis, so that enu.y maps to the +X axis.\\n\\\n    float meridionalRadius = 1.0 / u_ellipsoidCurvatureAtLatitude.y;\\n\\\n    vec2 cameraZX = vec2(meridionalRadius + u_cameraPositionCartographic.z, 0.0);\\n\\\n    vec2 positionZX = cameraZX + vec2(enu.z, enu.y);\\n\\\n    float dLatitude = atan(positionZX.y, positionZX.x);\\n\\\n\\n\\\n    // 4. Compute the change in height above the ellipsoid\\n\\\n    // Find the change in enu.z associated with rotating the point to the latitude of the camera\\n\\\n    float sinHalfLatitude = sin(dLatitude / 2.0);\\n\\\n    float dz = length(positionZX) * 2.0 * sinHalfLatitude * sinHalfLatitude;\\n\\\n    // The remaining change in enu.z is the change in height above the ellipsoid\\n\\\n    float dHeight = enu.z + dz;\\n\\\n\\n\\\n    return vec3(dLongitude, dLatitude, dHeight);\\n\\\n}\\n\\\n\\n\\\nvec3 convertEcToDeltaTile(in vec3 positionEC) {\\n\\\n    vec3 deltaShape = convertEcToDeltaShape(positionEC);\\n\\\n    // Convert to tileset coordinates in [0, 1]\\n\\\n    float dx = deltaShape.x / czm_twoPi;\\n\\\n\\n\\\n#if (defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE))\\n\\\n    // Wrap to ensure dx is not crossing through the unoccupied angle range, where\\n\\\n    // angle to tile coordinate conversions would be more complicated\\n\\\n    float cameraUvLongitude = (u_cameraPositionCartographic.x + czm_pi) / czm_twoPi;\\n\\\n    float cameraUvLongitudeShift = fract(cameraUvLongitude - u_ellipsoidShapeUvLongitudeRangeOrigin);\\n\\\n    float rawOutputUvLongitude = cameraUvLongitudeShift + dx;\\n\\\n    float rotation = floor(rawOutputUvLongitude);\\n\\\n    dx -= rotation;\\n\\\n    dx *= u_ellipsoidLocalToShapeUvLongitude.x;\\n\\\n#endif\\n\\\n\\n\\\n    float dy = deltaShape.y / czm_pi;\\n\\\n#if (defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE))\\n\\\n    dy *= u_ellipsoidLocalToShapeUvLatitude.x;\\n\\\n#endif\\n\\\n\\n\\\n    float dz = u_ellipsoidInverseHeightDifference * deltaShape.z;\\n\\\n    // Convert to tile coordinate changes\\n\\\n    return vec3(dx, dy, dz) * float(1 << u_cameraTileCoordinates.w);\\n\\\n}\\n\\\n\\n\\\nTileAndUvCoordinate getTileAndUvCoordinate(in vec3 positionEC) {\\n\\\n    vec3 deltaTileCoordinate = convertEcToDeltaTile(positionEC);\\n\\\n    vec3 tileUvSum = u_cameraTileUv + deltaTileCoordinate;\\n\\\n    ivec3 tileCoordinate = u_cameraTileCoordinates.xyz + ivec3(floor(tileUvSum));\\n\\\n    int maxTileCoordinate = (1 << u_cameraTileCoordinates.w) - 1;\\n\\\n    tileCoordinate.y = min(max(0, tileCoordinate.y), maxTileCoordinate);\\n\\\n    tileCoordinate.z = min(max(0, tileCoordinate.z), maxTileCoordinate);\\n\\\n#if (!defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE))\\n\\\n    ivec3 tileCoordinateChange = tileCoordinate - u_cameraTileCoordinates.xyz;\\n\\\n    if (tileCoordinate.x < 0) {\\n\\\n        tileCoordinate.x += (maxTileCoordinate + 1);\\n\\\n    } else if (tileCoordinate.x > maxTileCoordinate) {\\n\\\n        tileCoordinate.x -= (maxTileCoordinate + 1);\\n\\\n    }\\n\\\n#else\\n\\\n    tileCoordinate.x = min(max(0, tileCoordinate.x), maxTileCoordinate);\\n\\\n    ivec3 tileCoordinateChange = tileCoordinate - u_cameraTileCoordinates.xyz;\\n\\\n#endif\\n\\\n    vec3 tileUv = tileUvSum - vec3(tileCoordinateChange);\\n\\\n#if (!defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE))\\n\\\n    // If there is only one tile spanning 2*PI angle, the coordinate wraps around\\n\\\n    tileUv.x = (u_cameraTileCoordinates.w == 0) ? fract(tileUv.x) : clamp(tileUv.x, 0.0, 1.0);\\n\\\n#else\\n\\\n    tileUv.x = clamp(tileUv.x, 0.0, 1.0);\\n\\\n#endif\\n\\\n    tileUv.y = clamp(tileUv.y, 0.0, 1.0);\\n\\\n    tileUv.z = clamp(tileUv.z, 0.0, 1.0);\\n\\\n    return TileAndUvCoordinate(ivec4(tileCoordinate, u_cameraTileCoordinates.w), tileUv);\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}