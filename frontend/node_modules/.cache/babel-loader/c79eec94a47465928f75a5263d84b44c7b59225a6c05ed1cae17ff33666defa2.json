{"ast":null,"code":"import Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\n\n/**\n * A heatmap colorizer in a {@link Cesium3DTileset}. A tileset can colorize its visible tiles in a heatmap style.\n *\n * @alias Cesium3DTilesetHeatmap\n * @constructor\n * @private\n */\nfunction Cesium3DTilesetHeatmap(tilePropertyName) {\n  /**\n   * The tile variable to track for heatmap colorization.\n   * Tile's will be colorized relative to the other visible tile's values for this variable.\n   *\n   * @type {string}\n   */\n  this.tilePropertyName = tilePropertyName;\n\n  // Members that are updated every time a tile is colorized\n  this._minimum = Number.MAX_VALUE;\n  this._maximum = -Number.MAX_VALUE;\n\n  // Members that are updated once every frame\n  this._previousMinimum = Number.MAX_VALUE;\n  this._previousMaximum = -Number.MAX_VALUE;\n\n  // If defined uses a reference minimum maximum to colorize by instead of using last frames minimum maximum of rendered tiles.\n  // For example, the _loadTimestamp can get a better colorization using setReferenceMinimumMaximum in order to take accurate colored timing diffs of various scenes.\n  this._referenceMinimum = {};\n  this._referenceMaximum = {};\n}\n\n/**\n * Convert to a usable heatmap value (i.e. a number). Ensures that tile values that aren't stored as numbers can be used for colorization.\n * @private\n */\nfunction getHeatmapValue(tileValue, tilePropertyName) {\n  let value;\n  if (tilePropertyName === \"_loadTimestamp\") {\n    value = JulianDate.toDate(tileValue).getTime();\n  } else {\n    value = tileValue;\n  }\n  return value;\n}\n\n/**\n * Sets the reference minimum and maximum for the variable name. Converted to numbers before they are stored.\n *\n * @param {object} minimum The minimum reference value.\n * @param {object} maximum The maximum reference value.\n * @param {string} tilePropertyName The tile variable that will use these reference values when it is colorized.\n */\nCesium3DTilesetHeatmap.prototype.setReferenceMinimumMaximum = function (minimum, maximum, tilePropertyName) {\n  this._referenceMinimum[tilePropertyName] = getHeatmapValue(minimum, tilePropertyName);\n  this._referenceMaximum[tilePropertyName] = getHeatmapValue(maximum, tilePropertyName);\n};\nfunction getHeatmapValueAndUpdateMinimumMaximum(heatmap, tile) {\n  const tilePropertyName = heatmap.tilePropertyName;\n  if (defined(tilePropertyName)) {\n    const heatmapValue = getHeatmapValue(tile[tilePropertyName], tilePropertyName);\n    if (!defined(heatmapValue)) {\n      heatmap.tilePropertyName = undefined;\n      return heatmapValue;\n    }\n    heatmap._maximum = Math.max(heatmapValue, heatmap._maximum);\n    heatmap._minimum = Math.min(heatmapValue, heatmap._minimum);\n    return heatmapValue;\n  }\n}\nconst heatmapColors = [new Color(0.1, 0.1, 0.1, 1),\n// Dark Gray\nnew Color(0.153, 0.278, 0.878, 1),\n// Blue\nnew Color(0.827, 0.231, 0.49, 1),\n// Pink\nnew Color(0.827, 0.188, 0.22, 1),\n// Red\nnew Color(1.0, 0.592, 0.259, 1),\n// Orange\nnew Color(1.0, 0.843, 0.0, 1)]; // Yellow\n/**\n * Colorize the tile in heat map style based on where it lies within the minimum maximum window.\n * Heatmap colors are black, blue, pink, red, orange, yellow. 'Cold' or low numbers will be black and blue, 'Hot' or high numbers will be orange and yellow,\n * @param {Cesium3DTile} tile The tile to colorize relative to last frame's minimum and maximum values of all visible tiles.\n * @param {FrameState} frameState The frame state.\n */\nCesium3DTilesetHeatmap.prototype.colorize = function (tile, frameState) {\n  const tilePropertyName = this.tilePropertyName;\n  if (!defined(tilePropertyName) || !tile.contentAvailable || tile._selectedFrame !== frameState.frameNumber) {\n    return;\n  }\n  const heatmapValue = getHeatmapValueAndUpdateMinimumMaximum(this, tile);\n  const minimum = this._previousMinimum;\n  const maximum = this._previousMaximum;\n  if (minimum === Number.MAX_VALUE || maximum === -Number.MAX_VALUE) {\n    return;\n  }\n\n  // Shift the minimum maximum window down to 0\n  const shiftedMax = maximum - minimum + CesiumMath.EPSILON7; // Prevent divide by 0\n  const shiftedValue = CesiumMath.clamp(heatmapValue - minimum, 0.0, shiftedMax);\n\n  // Get position between minimum and maximum and convert that to a position in the color array\n  const zeroToOne = shiftedValue / shiftedMax;\n  const lastIndex = heatmapColors.length - 1.0;\n  const colorPosition = zeroToOne * lastIndex;\n\n  // Take floor and ceil of the value to get the two colors to lerp between, lerp using the fractional portion\n  const colorPositionFloor = Math.floor(colorPosition);\n  const colorPositionCeil = Math.ceil(colorPosition);\n  const t = colorPosition - colorPositionFloor;\n  const colorZero = heatmapColors[colorPositionFloor];\n  const colorOne = heatmapColors[colorPositionCeil];\n\n  // Perform the lerp\n  const finalColor = Color.clone(Color.WHITE);\n  finalColor.red = CesiumMath.lerp(colorZero.red, colorOne.red, t);\n  finalColor.green = CesiumMath.lerp(colorZero.green, colorOne.green, t);\n  finalColor.blue = CesiumMath.lerp(colorZero.blue, colorOne.blue, t);\n  tile._debugColor = finalColor;\n};\n\n/**\n * Resets the tracked minimum maximum values for heatmap colorization. Happens right before tileset traversal.\n */\nCesium3DTilesetHeatmap.prototype.resetMinimumMaximum = function () {\n  // For heat map colorization\n  const tilePropertyName = this.tilePropertyName;\n  if (defined(tilePropertyName)) {\n    const referenceMinimum = this._referenceMinimum[tilePropertyName];\n    const referenceMaximum = this._referenceMaximum[tilePropertyName];\n    const useReference = defined(referenceMinimum) && defined(referenceMaximum);\n    this._previousMinimum = useReference ? referenceMinimum : this._minimum;\n    this._previousMaximum = useReference ? referenceMaximum : this._maximum;\n    this._minimum = Number.MAX_VALUE;\n    this._maximum = -Number.MAX_VALUE;\n  }\n};\nexport default Cesium3DTilesetHeatmap;","map":{"version":3,"names":["Color","defined","JulianDate","CesiumMath","Cesium3DTilesetHeatmap","tilePropertyName","_minimum","Number","MAX_VALUE","_maximum","_previousMinimum","_previousMaximum","_referenceMinimum","_referenceMaximum","getHeatmapValue","tileValue","value","toDate","getTime","prototype","setReferenceMinimumMaximum","minimum","maximum","getHeatmapValueAndUpdateMinimumMaximum","heatmap","tile","heatmapValue","undefined","Math","max","min","heatmapColors","colorize","frameState","contentAvailable","_selectedFrame","frameNumber","shiftedMax","EPSILON7","shiftedValue","clamp","zeroToOne","lastIndex","length","colorPosition","colorPositionFloor","floor","colorPositionCeil","ceil","t","colorZero","colorOne","finalColor","clone","WHITE","red","lerp","green","blue","_debugColor","resetMinimumMaximum","referenceMinimum","referenceMaximum","useReference"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Cesium3DTilesetHeatmap.js"],"sourcesContent":["import Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\n\n/**\n * A heatmap colorizer in a {@link Cesium3DTileset}. A tileset can colorize its visible tiles in a heatmap style.\n *\n * @alias Cesium3DTilesetHeatmap\n * @constructor\n * @private\n */\nfunction Cesium3DTilesetHeatmap(tilePropertyName) {\n  /**\n   * The tile variable to track for heatmap colorization.\n   * Tile's will be colorized relative to the other visible tile's values for this variable.\n   *\n   * @type {string}\n   */\n  this.tilePropertyName = tilePropertyName;\n\n  // Members that are updated every time a tile is colorized\n  this._minimum = Number.MAX_VALUE;\n  this._maximum = -Number.MAX_VALUE;\n\n  // Members that are updated once every frame\n  this._previousMinimum = Number.MAX_VALUE;\n  this._previousMaximum = -Number.MAX_VALUE;\n\n  // If defined uses a reference minimum maximum to colorize by instead of using last frames minimum maximum of rendered tiles.\n  // For example, the _loadTimestamp can get a better colorization using setReferenceMinimumMaximum in order to take accurate colored timing diffs of various scenes.\n  this._referenceMinimum = {};\n  this._referenceMaximum = {};\n}\n\n/**\n * Convert to a usable heatmap value (i.e. a number). Ensures that tile values that aren't stored as numbers can be used for colorization.\n * @private\n */\nfunction getHeatmapValue(tileValue, tilePropertyName) {\n  let value;\n  if (tilePropertyName === \"_loadTimestamp\") {\n    value = JulianDate.toDate(tileValue).getTime();\n  } else {\n    value = tileValue;\n  }\n  return value;\n}\n\n/**\n * Sets the reference minimum and maximum for the variable name. Converted to numbers before they are stored.\n *\n * @param {object} minimum The minimum reference value.\n * @param {object} maximum The maximum reference value.\n * @param {string} tilePropertyName The tile variable that will use these reference values when it is colorized.\n */\nCesium3DTilesetHeatmap.prototype.setReferenceMinimumMaximum = function (\n  minimum,\n  maximum,\n  tilePropertyName,\n) {\n  this._referenceMinimum[tilePropertyName] = getHeatmapValue(\n    minimum,\n    tilePropertyName,\n  );\n  this._referenceMaximum[tilePropertyName] = getHeatmapValue(\n    maximum,\n    tilePropertyName,\n  );\n};\n\nfunction getHeatmapValueAndUpdateMinimumMaximum(heatmap, tile) {\n  const tilePropertyName = heatmap.tilePropertyName;\n  if (defined(tilePropertyName)) {\n    const heatmapValue = getHeatmapValue(\n      tile[tilePropertyName],\n      tilePropertyName,\n    );\n    if (!defined(heatmapValue)) {\n      heatmap.tilePropertyName = undefined;\n      return heatmapValue;\n    }\n    heatmap._maximum = Math.max(heatmapValue, heatmap._maximum);\n    heatmap._minimum = Math.min(heatmapValue, heatmap._minimum);\n    return heatmapValue;\n  }\n}\n\nconst heatmapColors = [\n  new Color(0.1, 0.1, 0.1, 1), // Dark Gray\n  new Color(0.153, 0.278, 0.878, 1), // Blue\n  new Color(0.827, 0.231, 0.49, 1), // Pink\n  new Color(0.827, 0.188, 0.22, 1), // Red\n  new Color(1.0, 0.592, 0.259, 1), // Orange\n  new Color(1.0, 0.843, 0.0, 1),\n]; // Yellow\n/**\n * Colorize the tile in heat map style based on where it lies within the minimum maximum window.\n * Heatmap colors are black, blue, pink, red, orange, yellow. 'Cold' or low numbers will be black and blue, 'Hot' or high numbers will be orange and yellow,\n * @param {Cesium3DTile} tile The tile to colorize relative to last frame's minimum and maximum values of all visible tiles.\n * @param {FrameState} frameState The frame state.\n */\nCesium3DTilesetHeatmap.prototype.colorize = function (tile, frameState) {\n  const tilePropertyName = this.tilePropertyName;\n  if (\n    !defined(tilePropertyName) ||\n    !tile.contentAvailable ||\n    tile._selectedFrame !== frameState.frameNumber\n  ) {\n    return;\n  }\n\n  const heatmapValue = getHeatmapValueAndUpdateMinimumMaximum(this, tile);\n  const minimum = this._previousMinimum;\n  const maximum = this._previousMaximum;\n\n  if (minimum === Number.MAX_VALUE || maximum === -Number.MAX_VALUE) {\n    return;\n  }\n\n  // Shift the minimum maximum window down to 0\n  const shiftedMax = maximum - minimum + CesiumMath.EPSILON7; // Prevent divide by 0\n  const shiftedValue = CesiumMath.clamp(\n    heatmapValue - minimum,\n    0.0,\n    shiftedMax,\n  );\n\n  // Get position between minimum and maximum and convert that to a position in the color array\n  const zeroToOne = shiftedValue / shiftedMax;\n  const lastIndex = heatmapColors.length - 1.0;\n  const colorPosition = zeroToOne * lastIndex;\n\n  // Take floor and ceil of the value to get the two colors to lerp between, lerp using the fractional portion\n  const colorPositionFloor = Math.floor(colorPosition);\n  const colorPositionCeil = Math.ceil(colorPosition);\n  const t = colorPosition - colorPositionFloor;\n  const colorZero = heatmapColors[colorPositionFloor];\n  const colorOne = heatmapColors[colorPositionCeil];\n\n  // Perform the lerp\n  const finalColor = Color.clone(Color.WHITE);\n  finalColor.red = CesiumMath.lerp(colorZero.red, colorOne.red, t);\n  finalColor.green = CesiumMath.lerp(colorZero.green, colorOne.green, t);\n  finalColor.blue = CesiumMath.lerp(colorZero.blue, colorOne.blue, t);\n  tile._debugColor = finalColor;\n};\n\n/**\n * Resets the tracked minimum maximum values for heatmap colorization. Happens right before tileset traversal.\n */\nCesium3DTilesetHeatmap.prototype.resetMinimumMaximum = function () {\n  // For heat map colorization\n  const tilePropertyName = this.tilePropertyName;\n  if (defined(tilePropertyName)) {\n    const referenceMinimum = this._referenceMinimum[tilePropertyName];\n    const referenceMaximum = this._referenceMaximum[tilePropertyName];\n    const useReference = defined(referenceMinimum) && defined(referenceMaximum);\n    this._previousMinimum = useReference ? referenceMinimum : this._minimum;\n    this._previousMaximum = useReference ? referenceMaximum : this._maximum;\n    this._minimum = Number.MAX_VALUE;\n    this._maximum = -Number.MAX_VALUE;\n  }\n};\nexport default Cesium3DTilesetHeatmap;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}