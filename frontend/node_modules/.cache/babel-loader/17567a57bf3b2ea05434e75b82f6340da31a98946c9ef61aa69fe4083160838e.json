{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport EasingFunction from \"../Core/EasingFunction.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport Ray from \"../Core/Ray.js\";\nimport ScreenSpaceEventHandler from \"../Core/ScreenSpaceEventHandler.js\";\nimport ScreenSpaceEventType from \"../Core/ScreenSpaceEventType.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport Camera from \"./Camera.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * @private\n */\nfunction SceneTransitioner(scene) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scene\", scene);\n  //>>includeEnd('debug');\n\n  this._scene = scene;\n  this._currentTweens = [];\n  this._morphHandler = undefined;\n  this._morphCancelled = false;\n  this._completeMorph = undefined;\n  this._morphToOrthographic = false;\n}\nSceneTransitioner.prototype.completeMorph = function () {\n  if (defined(this._completeMorph)) {\n    this._completeMorph();\n  }\n};\nSceneTransitioner.prototype.morphTo2D = function (duration, ellipsoid) {\n  if (defined(this._completeMorph)) {\n    this._completeMorph();\n  }\n  const scene = this._scene;\n  this._previousMode = scene.mode;\n  this._morphToOrthographic = scene.camera.frustum instanceof OrthographicFrustum;\n  if (this._previousMode === SceneMode.SCENE2D || this._previousMode === SceneMode.MORPHING) {\n    return;\n  }\n  this._scene.morphStart.raiseEvent(this, this._previousMode, SceneMode.SCENE2D, true);\n  scene._mode = SceneMode.MORPHING;\n  scene.camera._setTransform(Matrix4.IDENTITY);\n  if (this._previousMode === SceneMode.COLUMBUS_VIEW) {\n    morphFromColumbusViewTo2D(this, duration);\n  } else {\n    morphFrom3DTo2D(this, duration, ellipsoid);\n  }\n  if (duration === 0.0 && defined(this._completeMorph)) {\n    this._completeMorph();\n  }\n};\nconst scratchToCVPosition = new Cartesian3();\nconst scratchToCVDirection = new Cartesian3();\nconst scratchToCVUp = new Cartesian3();\nconst scratchToCVPosition2D = new Cartesian3();\nconst scratchToCVDirection2D = new Cartesian3();\nconst scratchToCVUp2D = new Cartesian3();\nconst scratchToCVSurfacePosition = new Cartesian3();\nconst scratchToCVCartographic = new Cartographic();\nconst scratchToCVToENU = new Matrix4();\nconst scratchToCVFrustumPerspective = new PerspectiveFrustum();\nconst scratchToCVFrustumOrthographic = new OrthographicFrustum();\nconst scratchToCVCamera = {\n  position: undefined,\n  direction: undefined,\n  up: undefined,\n  position2D: undefined,\n  direction2D: undefined,\n  up2D: undefined,\n  frustum: undefined\n};\nSceneTransitioner.prototype.morphToColumbusView = function (duration, ellipsoid) {\n  if (defined(this._completeMorph)) {\n    this._completeMorph();\n  }\n  const scene = this._scene;\n  this._previousMode = scene.mode;\n  if (this._previousMode === SceneMode.COLUMBUS_VIEW || this._previousMode === SceneMode.MORPHING) {\n    return;\n  }\n  this._scene.morphStart.raiseEvent(this, this._previousMode, SceneMode.COLUMBUS_VIEW, true);\n  scene.camera._setTransform(Matrix4.IDENTITY);\n  let position = scratchToCVPosition;\n  const direction = scratchToCVDirection;\n  const up = scratchToCVUp;\n  if (duration > 0.0) {\n    position.x = 0.0;\n    position.y = -1.0;\n    position.z = 1.0;\n    position = Cartesian3.multiplyByScalar(Cartesian3.normalize(position, position), 5.0 * ellipsoid.maximumRadius, position);\n    Cartesian3.negate(Cartesian3.normalize(position, direction), direction);\n    Cartesian3.cross(Cartesian3.UNIT_X, direction, up);\n  } else {\n    const camera = scene.camera;\n    if (this._previousMode === SceneMode.SCENE2D) {\n      Cartesian3.clone(camera.position, position);\n      position.z = camera.frustum.right - camera.frustum.left;\n      Cartesian3.negate(Cartesian3.UNIT_Z, direction);\n      Cartesian3.clone(Cartesian3.UNIT_Y, up);\n    } else {\n      Cartesian3.clone(camera.positionWC, position);\n      Cartesian3.clone(camera.directionWC, direction);\n      Cartesian3.clone(camera.upWC, up);\n      const surfacePoint = ellipsoid.scaleToGeodeticSurface(position, scratchToCVSurfacePosition);\n      const toENU = Transforms.eastNorthUpToFixedFrame(surfacePoint, ellipsoid, scratchToCVToENU);\n      Matrix4.inverseTransformation(toENU, toENU);\n      scene.mapProjection.project(ellipsoid.cartesianToCartographic(position, scratchToCVCartographic), position);\n      Matrix4.multiplyByPointAsVector(toENU, direction, direction);\n      Matrix4.multiplyByPointAsVector(toENU, up, up);\n    }\n  }\n  let frustum;\n  if (this._morphToOrthographic) {\n    frustum = scratchToCVFrustumOrthographic;\n    frustum.width = scene.camera.frustum.right - scene.camera.frustum.left;\n    frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;\n  } else {\n    frustum = scratchToCVFrustumPerspective;\n    frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;\n    frustum.fov = CesiumMath.toRadians(60.0);\n  }\n  const cameraCV = scratchToCVCamera;\n  cameraCV.position = position;\n  cameraCV.direction = direction;\n  cameraCV.up = up;\n  cameraCV.frustum = frustum;\n  const complete = completeColumbusViewCallback(cameraCV);\n  createMorphHandler(this, complete);\n  if (this._previousMode === SceneMode.SCENE2D) {\n    morphFrom2DToColumbusView(this, duration, cameraCV, complete);\n  } else {\n    cameraCV.position2D = Matrix4.multiplyByPoint(Camera.TRANSFORM_2D, position, scratchToCVPosition2D);\n    cameraCV.direction2D = Matrix4.multiplyByPointAsVector(Camera.TRANSFORM_2D, direction, scratchToCVDirection2D);\n    cameraCV.up2D = Matrix4.multiplyByPointAsVector(Camera.TRANSFORM_2D, up, scratchToCVUp2D);\n    scene._mode = SceneMode.MORPHING;\n    morphFrom3DToColumbusView(this, duration, cameraCV, complete);\n  }\n  if (duration === 0.0 && defined(this._completeMorph)) {\n    this._completeMorph();\n  }\n};\nconst scratchCVTo3DCamera = {\n  position: new Cartesian3(),\n  direction: new Cartesian3(),\n  up: new Cartesian3(),\n  frustum: undefined\n};\nconst scratch2DTo3DFrustumPersp = new PerspectiveFrustum();\nSceneTransitioner.prototype.morphTo3D = function (duration, ellipsoid) {\n  if (defined(this._completeMorph)) {\n    this._completeMorph();\n  }\n  const scene = this._scene;\n  this._previousMode = scene.mode;\n  if (this._previousMode === SceneMode.SCENE3D || this._previousMode === SceneMode.MORPHING) {\n    return;\n  }\n  this._scene.morphStart.raiseEvent(this, this._previousMode, SceneMode.SCENE3D, true);\n  scene._mode = SceneMode.MORPHING;\n  scene.camera._setTransform(Matrix4.IDENTITY);\n  if (this._previousMode === SceneMode.SCENE2D) {\n    morphFrom2DTo3D(this, duration, ellipsoid);\n  } else {\n    let camera3D;\n    if (duration > 0.0) {\n      camera3D = scratchCVTo3DCamera;\n      Cartesian3.fromDegrees(0.0, 0.0, 5.0 * ellipsoid.maximumRadius, ellipsoid, camera3D.position);\n      Cartesian3.negate(camera3D.position, camera3D.direction);\n      Cartesian3.normalize(camera3D.direction, camera3D.direction);\n      Cartesian3.clone(Cartesian3.UNIT_Z, camera3D.up);\n    } else {\n      camera3D = getColumbusViewTo3DCamera(this, ellipsoid);\n    }\n    let frustum;\n    const camera = scene.camera;\n    if (camera.frustum instanceof OrthographicFrustum) {\n      frustum = camera.frustum.clone();\n    } else {\n      frustum = scratch2DTo3DFrustumPersp;\n      frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;\n      frustum.fov = CesiumMath.toRadians(60.0);\n    }\n    camera3D.frustum = frustum;\n    const complete = complete3DCallback(camera3D);\n    createMorphHandler(this, complete);\n    morphFromColumbusViewTo3D(this, duration, camera3D, complete);\n  }\n  if (duration === 0.0 && defined(this._completeMorph)) {\n    this._completeMorph();\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nSceneTransitioner.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * transitioner = transitioner && transitioner.destroy();\n */\nSceneTransitioner.prototype.destroy = function () {\n  destroyMorphHandler(this);\n  return destroyObject(this);\n};\nfunction createMorphHandler(transitioner, completeMorphFunction) {\n  if (transitioner._scene.completeMorphOnUserInput) {\n    transitioner._morphHandler = new ScreenSpaceEventHandler(transitioner._scene.canvas);\n    const completeMorph = function () {\n      transitioner._morphCancelled = true;\n      transitioner._scene.camera.cancelFlight();\n      completeMorphFunction(transitioner);\n    };\n    transitioner._completeMorph = completeMorph;\n    transitioner._morphHandler.setInputAction(completeMorph, ScreenSpaceEventType.LEFT_DOWN);\n    transitioner._morphHandler.setInputAction(completeMorph, ScreenSpaceEventType.MIDDLE_DOWN);\n    transitioner._morphHandler.setInputAction(completeMorph, ScreenSpaceEventType.RIGHT_DOWN);\n    transitioner._morphHandler.setInputAction(completeMorph, ScreenSpaceEventType.WHEEL);\n  }\n}\nfunction destroyMorphHandler(transitioner) {\n  const tweens = transitioner._currentTweens;\n  for (let i = 0; i < tweens.length; ++i) {\n    tweens[i].cancelTween();\n  }\n  transitioner._currentTweens.length = 0;\n  transitioner._morphHandler = transitioner._morphHandler && transitioner._morphHandler.destroy();\n}\nconst scratchCVTo3DCartographic = new Cartographic();\nconst scratchCVTo3DSurfacePoint = new Cartesian3();\nconst scratchCVTo3DFromENU = new Matrix4();\nfunction getColumbusViewTo3DCamera(transitioner, ellipsoid) {\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n  const camera3D = scratchCVTo3DCamera;\n  const position = camera3D.position;\n  const direction = camera3D.direction;\n  const up = camera3D.up;\n  const positionCarto = scene.mapProjection.unproject(camera.position, scratchCVTo3DCartographic);\n  ellipsoid.cartographicToCartesian(positionCarto, position);\n  const surfacePoint = ellipsoid.scaleToGeodeticSurface(position, scratchCVTo3DSurfacePoint);\n  const fromENU = Transforms.eastNorthUpToFixedFrame(surfacePoint, ellipsoid, scratchCVTo3DFromENU);\n  Matrix4.multiplyByPointAsVector(fromENU, camera.direction, direction);\n  Matrix4.multiplyByPointAsVector(fromENU, camera.up, up);\n  return camera3D;\n}\nconst scratchCVTo3DStartPos = new Cartesian3();\nconst scratchCVTo3DStartDir = new Cartesian3();\nconst scratchCVTo3DStartUp = new Cartesian3();\nconst scratchCVTo3DEndPos = new Cartesian3();\nconst scratchCVTo3DEndDir = new Cartesian3();\nconst scratchCVTo3DEndUp = new Cartesian3();\nfunction morphFromColumbusViewTo3D(transitioner, duration, endCamera, complete) {\n  duration *= 0.5;\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n  const startPos = Cartesian3.clone(camera.position, scratchCVTo3DStartPos);\n  const startDir = Cartesian3.clone(camera.direction, scratchCVTo3DStartDir);\n  const startUp = Cartesian3.clone(camera.up, scratchCVTo3DStartUp);\n  const endPos = Matrix4.multiplyByPoint(Camera.TRANSFORM_2D_INVERSE, endCamera.position, scratchCVTo3DEndPos);\n  const endDir = Matrix4.multiplyByPointAsVector(Camera.TRANSFORM_2D_INVERSE, endCamera.direction, scratchCVTo3DEndDir);\n  const endUp = Matrix4.multiplyByPointAsVector(Camera.TRANSFORM_2D_INVERSE, endCamera.up, scratchCVTo3DEndUp);\n  function update(value) {\n    columbusViewMorph(startPos, endPos, value.time, camera.position);\n    columbusViewMorph(startDir, endDir, value.time, camera.direction);\n    columbusViewMorph(startUp, endUp, value.time, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.normalize(camera.right, camera.right);\n  }\n  const tween = scene.tweens.add({\n    duration: duration,\n    easingFunction: EasingFunction.QUARTIC_OUT,\n    startObject: {\n      time: 0.0\n    },\n    stopObject: {\n      time: 1.0\n    },\n    update: update,\n    complete: function () {\n      addMorphTimeAnimations(transitioner, scene, 0.0, 1.0, duration, complete);\n    }\n  });\n  transitioner._currentTweens.push(tween);\n}\nconst scratch2DTo3DFrustumOrtho = new OrthographicFrustum();\nconst scratch3DToCVStartPos = new Cartesian3();\nconst scratch3DToCVStartDir = new Cartesian3();\nconst scratch3DToCVStartUp = new Cartesian3();\nconst scratch3DToCVEndPos = new Cartesian3();\nconst scratch3DToCVEndDir = new Cartesian3();\nconst scratch3DToCVEndUp = new Cartesian3();\nfunction morphFrom2DTo3D(transitioner, duration, ellipsoid) {\n  duration /= 3.0;\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n  let camera3D;\n  if (duration > 0.0) {\n    camera3D = scratchCVTo3DCamera;\n    Cartesian3.fromDegrees(0.0, 0.0, 5.0 * ellipsoid.maximumRadius, ellipsoid, camera3D.position);\n    Cartesian3.negate(camera3D.position, camera3D.direction);\n    Cartesian3.normalize(camera3D.direction, camera3D.direction);\n    Cartesian3.clone(Cartesian3.UNIT_Z, camera3D.up);\n  } else {\n    camera.position.z = camera.frustum.right - camera.frustum.left;\n    camera3D = getColumbusViewTo3DCamera(transitioner, ellipsoid);\n  }\n  let frustum;\n  if (transitioner._morphToOrthographic) {\n    frustum = scratch2DTo3DFrustumOrtho;\n    frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;\n    frustum.width = camera.frustum.right - camera.frustum.left;\n  } else {\n    frustum = scratch2DTo3DFrustumPersp;\n    frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;\n    frustum.fov = CesiumMath.toRadians(60.0);\n  }\n  camera3D.frustum = frustum;\n  const complete = complete3DCallback(camera3D);\n  createMorphHandler(transitioner, complete);\n  let morph;\n  if (transitioner._morphToOrthographic) {\n    morph = function () {\n      morphFromColumbusViewTo3D(transitioner, duration, camera3D, complete);\n    };\n  } else {\n    morph = function () {\n      morphOrthographicToPerspective(transitioner, duration, camera3D, function () {\n        morphFromColumbusViewTo3D(transitioner, duration, camera3D, complete);\n      });\n    };\n  }\n  if (duration > 0.0) {\n    scene._mode = SceneMode.SCENE2D;\n    camera.flyTo({\n      duration: duration,\n      destination: Cartesian3.fromDegrees(0.0, 0.0, 5.0 * ellipsoid.maximumRadius, ellipsoid, scratch3DToCVEndPos),\n      complete: function () {\n        scene._mode = SceneMode.MORPHING;\n        morph();\n      }\n    });\n  } else {\n    morph();\n  }\n}\nfunction columbusViewMorph(startPosition, endPosition, time, result) {\n  // Just linear for now.\n  return Cartesian3.lerp(startPosition, endPosition, time, result);\n}\nfunction morphPerspectiveToOrthographic(transitioner, duration, endCamera, updateHeight, complete) {\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n  if (camera.frustum instanceof OrthographicFrustum) {\n    return;\n  }\n  const startFOV = camera.frustum.fov;\n  const endFOV = CesiumMath.RADIANS_PER_DEGREE * 0.5;\n  const d = endCamera.position.z * Math.tan(startFOV * 0.5);\n  camera.frustum.far = d / Math.tan(endFOV * 0.5) + 10000000.0;\n  function update(value) {\n    camera.frustum.fov = CesiumMath.lerp(startFOV, endFOV, value.time);\n    const height = d / Math.tan(camera.frustum.fov * 0.5);\n    updateHeight(camera, height);\n  }\n  const tween = scene.tweens.add({\n    duration: duration,\n    easingFunction: EasingFunction.QUARTIC_OUT,\n    startObject: {\n      time: 0.0\n    },\n    stopObject: {\n      time: 1.0\n    },\n    update: update,\n    complete: function () {\n      camera.frustum = endCamera.frustum.clone();\n      complete(transitioner);\n    }\n  });\n  transitioner._currentTweens.push(tween);\n}\nconst scratchCVTo2DStartPos = new Cartesian3();\nconst scratchCVTo2DStartDir = new Cartesian3();\nconst scratchCVTo2DStartUp = new Cartesian3();\nconst scratchCVTo2DEndPos = new Cartesian3();\nconst scratchCVTo2DEndDir = new Cartesian3();\nconst scratchCVTo2DEndUp = new Cartesian3();\nconst scratchCVTo2DFrustum = new OrthographicOffCenterFrustum();\nconst scratchCVTo2DRay = new Ray();\nconst scratchCVTo2DPickPos = new Cartesian3();\nconst scratchCVTo2DCamera = {\n  position: undefined,\n  direction: undefined,\n  up: undefined,\n  frustum: undefined\n};\nfunction morphFromColumbusViewTo2D(transitioner, duration) {\n  duration *= 0.5;\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n  const startPos = Cartesian3.clone(camera.position, scratchCVTo2DStartPos);\n  const startDir = Cartesian3.clone(camera.direction, scratchCVTo2DStartDir);\n  const startUp = Cartesian3.clone(camera.up, scratchCVTo2DStartUp);\n  const endDir = Cartesian3.negate(Cartesian3.UNIT_Z, scratchCVTo2DEndDir);\n  const endUp = Cartesian3.clone(Cartesian3.UNIT_Y, scratchCVTo2DEndUp);\n  const endPos = scratchCVTo2DEndPos;\n  if (duration > 0.0) {\n    Cartesian3.clone(Cartesian3.ZERO, scratchCVTo2DEndPos);\n    endPos.z = 5.0 * scene.ellipsoid.maximumRadius;\n  } else {\n    Cartesian3.clone(startPos, scratchCVTo2DEndPos);\n    const ray = scratchCVTo2DRay;\n    Matrix4.multiplyByPoint(Camera.TRANSFORM_2D, startPos, ray.origin);\n    Matrix4.multiplyByPointAsVector(Camera.TRANSFORM_2D, startDir, ray.direction);\n    const globe = scene.globe;\n    if (defined(globe)) {\n      const pickPos = globe.pickWorldCoordinates(ray, scene, true, scratchCVTo2DPickPos);\n      if (defined(pickPos)) {\n        Matrix4.multiplyByPoint(Camera.TRANSFORM_2D_INVERSE, pickPos, endPos);\n        endPos.z += Cartesian3.distance(startPos, endPos);\n      }\n    }\n  }\n  const frustum = scratchCVTo2DFrustum;\n  frustum.right = endPos.z * 0.5;\n  frustum.left = -frustum.right;\n  frustum.top = frustum.right * (scene.drawingBufferHeight / scene.drawingBufferWidth);\n  frustum.bottom = -frustum.top;\n  const camera2D = scratchCVTo2DCamera;\n  camera2D.position = endPos;\n  camera2D.direction = endDir;\n  camera2D.up = endUp;\n  camera2D.frustum = frustum;\n  const complete = complete2DCallback(camera2D);\n  createMorphHandler(transitioner, complete);\n  function updateCV(value) {\n    columbusViewMorph(startPos, endPos, value.time, camera.position);\n    columbusViewMorph(startDir, endDir, value.time, camera.direction);\n    columbusViewMorph(startUp, endUp, value.time, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.normalize(camera.right, camera.right);\n    camera._adjustOrthographicFrustum(true);\n  }\n  function updateHeight(camera, height) {\n    camera.position.z = height;\n  }\n  const tween = scene.tweens.add({\n    duration: duration,\n    easingFunction: EasingFunction.QUARTIC_OUT,\n    startObject: {\n      time: 0.0\n    },\n    stopObject: {\n      time: 1.0\n    },\n    update: updateCV,\n    complete: function () {\n      morphPerspectiveToOrthographic(transitioner, duration, camera2D, updateHeight, complete);\n    }\n  });\n  transitioner._currentTweens.push(tween);\n}\nconst scratch3DTo2DCartographic = new Cartographic();\nconst scratch3DTo2DCamera = {\n  position: new Cartesian3(),\n  direction: new Cartesian3(),\n  up: new Cartesian3(),\n  position2D: new Cartesian3(),\n  direction2D: new Cartesian3(),\n  up2D: new Cartesian3(),\n  frustum: new OrthographicOffCenterFrustum()\n};\nconst scratch3DTo2DEndCamera = {\n  position: new Cartesian3(),\n  direction: new Cartesian3(),\n  up: new Cartesian3(),\n  frustum: undefined\n};\nconst scratch3DTo2DPickPosition = new Cartesian3();\nconst scratch3DTo2DRay = new Ray();\nconst scratch3DTo2DToENU = new Matrix4();\nconst scratch3DTo2DSurfacePoint = new Cartesian3();\nfunction morphFrom3DTo2D(transitioner, duration, ellipsoid) {\n  duration *= 0.5;\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n  const camera2D = scratch3DTo2DCamera;\n  if (duration > 0.0) {\n    Cartesian3.clone(Cartesian3.ZERO, camera2D.position);\n    camera2D.position.z = 5.0 * ellipsoid.maximumRadius;\n    Cartesian3.negate(Cartesian3.UNIT_Z, camera2D.direction);\n    Cartesian3.clone(Cartesian3.UNIT_Y, camera2D.up);\n  } else {\n    ellipsoid.cartesianToCartographic(camera.positionWC, scratch3DTo2DCartographic);\n    scene.mapProjection.project(scratch3DTo2DCartographic, camera2D.position);\n    Cartesian3.negate(Cartesian3.UNIT_Z, camera2D.direction);\n    Cartesian3.clone(Cartesian3.UNIT_Y, camera2D.up);\n    const ray = scratch3DTo2DRay;\n    Cartesian3.clone(camera2D.position2D, ray.origin);\n    const rayDirection = Cartesian3.clone(camera.directionWC, ray.direction);\n    const surfacePoint = ellipsoid.scaleToGeodeticSurface(camera.positionWC, scratch3DTo2DSurfacePoint);\n    const toENU = Transforms.eastNorthUpToFixedFrame(surfacePoint, ellipsoid, scratch3DTo2DToENU);\n    Matrix4.inverseTransformation(toENU, toENU);\n    Matrix4.multiplyByPointAsVector(toENU, rayDirection, rayDirection);\n    Matrix4.multiplyByPointAsVector(Camera.TRANSFORM_2D, rayDirection, rayDirection);\n    const globe = scene.globe;\n    if (defined(globe)) {\n      const pickedPos = globe.pickWorldCoordinates(ray, scene, true, scratch3DTo2DPickPosition);\n      if (defined(pickedPos)) {\n        const height = Cartesian3.distance(camera2D.position2D, pickedPos);\n        pickedPos.x += height;\n        Cartesian3.clone(pickedPos, camera2D.position2D);\n      }\n    }\n  }\n  function updateHeight(camera, height) {\n    camera.position.x = height;\n  }\n  Matrix4.multiplyByPoint(Camera.TRANSFORM_2D, camera2D.position, camera2D.position2D);\n  Matrix4.multiplyByPointAsVector(Camera.TRANSFORM_2D, camera2D.direction, camera2D.direction2D);\n  Matrix4.multiplyByPointAsVector(Camera.TRANSFORM_2D, camera2D.up, camera2D.up2D);\n  const frustum = camera2D.frustum;\n  frustum.right = camera2D.position.z * 0.5;\n  frustum.left = -frustum.right;\n  frustum.top = frustum.right * (scene.drawingBufferHeight / scene.drawingBufferWidth);\n  frustum.bottom = -frustum.top;\n  const endCamera = scratch3DTo2DEndCamera;\n  Matrix4.multiplyByPoint(Camera.TRANSFORM_2D_INVERSE, camera2D.position2D, endCamera.position);\n  Cartesian3.clone(camera2D.direction, endCamera.direction);\n  Cartesian3.clone(camera2D.up, endCamera.up);\n  endCamera.frustum = frustum;\n  const complete = complete2DCallback(endCamera);\n  createMorphHandler(transitioner, complete);\n  function completeCallback() {\n    morphPerspectiveToOrthographic(transitioner, duration, camera2D, updateHeight, complete);\n  }\n  morphFrom3DToColumbusView(transitioner, duration, camera2D, completeCallback);\n}\nfunction morphOrthographicToPerspective(transitioner, duration, cameraCV, complete) {\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n  const height = camera.frustum.right - camera.frustum.left;\n  camera.frustum = cameraCV.frustum.clone();\n  const endFOV = camera.frustum.fov;\n  const startFOV = CesiumMath.RADIANS_PER_DEGREE * 0.5;\n  const d = height * Math.tan(endFOV * 0.5);\n  camera.frustum.far = d / Math.tan(startFOV * 0.5) + 10000000.0;\n  camera.frustum.fov = startFOV;\n  function update(value) {\n    camera.frustum.fov = CesiumMath.lerp(startFOV, endFOV, value.time);\n    camera.position.z = d / Math.tan(camera.frustum.fov * 0.5);\n  }\n  const tween = scene.tweens.add({\n    duration: duration,\n    easingFunction: EasingFunction.QUARTIC_OUT,\n    startObject: {\n      time: 0.0\n    },\n    stopObject: {\n      time: 1.0\n    },\n    update: update,\n    complete: function () {\n      complete(transitioner);\n    }\n  });\n  transitioner._currentTweens.push(tween);\n}\nfunction morphFrom2DToColumbusView(transitioner, duration, cameraCV, complete) {\n  duration *= 0.5;\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n  const endPos = Cartesian3.clone(cameraCV.position, scratch3DToCVEndPos);\n  const endDir = Cartesian3.clone(cameraCV.direction, scratch3DToCVEndDir);\n  const endUp = Cartesian3.clone(cameraCV.up, scratch3DToCVEndUp);\n  scene._mode = SceneMode.MORPHING;\n  function morph() {\n    camera.frustum = cameraCV.frustum.clone();\n    const startPos = Cartesian3.clone(camera.position, scratch3DToCVStartPos);\n    const startDir = Cartesian3.clone(camera.direction, scratch3DToCVStartDir);\n    const startUp = Cartesian3.clone(camera.up, scratch3DToCVStartUp);\n    startPos.z = endPos.z;\n    function update(value) {\n      columbusViewMorph(startPos, endPos, value.time, camera.position);\n      columbusViewMorph(startDir, endDir, value.time, camera.direction);\n      columbusViewMorph(startUp, endUp, value.time, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n    const tween = scene.tweens.add({\n      duration: duration,\n      easingFunction: EasingFunction.QUARTIC_OUT,\n      startObject: {\n        time: 0.0\n      },\n      stopObject: {\n        time: 1.0\n      },\n      update: update,\n      complete: function () {\n        complete(transitioner);\n      }\n    });\n    transitioner._currentTweens.push(tween);\n  }\n  if (transitioner._morphToOrthographic) {\n    morph();\n  } else {\n    morphOrthographicToPerspective(transitioner, 0.0, cameraCV, morph);\n  }\n}\nfunction morphFrom3DToColumbusView(transitioner, duration, endCamera, complete) {\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n  const startPos = Cartesian3.clone(camera.position, scratch3DToCVStartPos);\n  const startDir = Cartesian3.clone(camera.direction, scratch3DToCVStartDir);\n  const startUp = Cartesian3.clone(camera.up, scratch3DToCVStartUp);\n  const endPos = Cartesian3.clone(endCamera.position2D, scratch3DToCVEndPos);\n  const endDir = Cartesian3.clone(endCamera.direction2D, scratch3DToCVEndDir);\n  const endUp = Cartesian3.clone(endCamera.up2D, scratch3DToCVEndUp);\n  function update(value) {\n    columbusViewMorph(startPos, endPos, value.time, camera.position);\n    columbusViewMorph(startDir, endDir, value.time, camera.direction);\n    columbusViewMorph(startUp, endUp, value.time, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.normalize(camera.right, camera.right);\n    camera._adjustOrthographicFrustum(true);\n  }\n  const tween = scene.tweens.add({\n    duration: duration,\n    easingFunction: EasingFunction.QUARTIC_OUT,\n    startObject: {\n      time: 0.0\n    },\n    stopObject: {\n      time: 1.0\n    },\n    update: update,\n    complete: function () {\n      addMorphTimeAnimations(transitioner, scene, 1.0, 0.0, duration, complete);\n    }\n  });\n  transitioner._currentTweens.push(tween);\n}\nfunction addMorphTimeAnimations(transitioner, scene, start, stop, duration, complete) {\n  // Later, this will be linear and each object will adjust, if desired, in its vertex shader.\n  const options = {\n    object: scene,\n    property: \"morphTime\",\n    startValue: start,\n    stopValue: stop,\n    duration: duration,\n    easingFunction: EasingFunction.QUARTIC_OUT\n  };\n  if (defined(complete)) {\n    options.complete = function () {\n      complete(transitioner);\n    };\n  }\n  const tween = scene.tweens.addProperty(options);\n  transitioner._currentTweens.push(tween);\n}\nfunction complete3DCallback(camera3D) {\n  return function (transitioner) {\n    const scene = transitioner._scene;\n    scene._mode = SceneMode.SCENE3D;\n    scene.morphTime = SceneMode.getMorphTime(SceneMode.SCENE3D);\n    destroyMorphHandler(transitioner);\n    const camera = scene.camera;\n    if (transitioner._previousMode !== SceneMode.MORPHING || transitioner._morphCancelled) {\n      transitioner._morphCancelled = false;\n      Cartesian3.clone(camera3D.position, camera.position);\n      Cartesian3.clone(camera3D.direction, camera.direction);\n      Cartesian3.clone(camera3D.up, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.normalize(camera.right, camera.right);\n      camera.frustum = camera3D.frustum.clone();\n    }\n    const frustum = camera.frustum;\n    if (scene.frameState.useLogDepth) {\n      frustum.near = 0.1;\n      frustum.far = 10000000000.0;\n    }\n    const wasMorphing = defined(transitioner._completeMorph);\n    transitioner._completeMorph = undefined;\n    scene.camera.update(scene.mode);\n    transitioner._scene.morphComplete.raiseEvent(transitioner, transitioner._previousMode, SceneMode.SCENE3D, wasMorphing);\n  };\n}\nfunction complete2DCallback(camera2D) {\n  return function (transitioner) {\n    const scene = transitioner._scene;\n    scene._mode = SceneMode.SCENE2D;\n    scene.morphTime = SceneMode.getMorphTime(SceneMode.SCENE2D);\n    destroyMorphHandler(transitioner);\n    const camera = scene.camera;\n    Cartesian3.clone(camera2D.position, camera.position);\n    camera.position.z = scene.ellipsoid.maximumRadius * 2.0;\n    Cartesian3.clone(camera2D.direction, camera.direction);\n    Cartesian3.clone(camera2D.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.normalize(camera.right, camera.right);\n    camera.frustum = camera2D.frustum.clone();\n    const wasMorphing = defined(transitioner._completeMorph);\n    transitioner._completeMorph = undefined;\n    scene.camera.update(scene.mode);\n    transitioner._scene.morphComplete.raiseEvent(transitioner, transitioner._previousMode, SceneMode.SCENE2D, wasMorphing);\n  };\n}\nfunction completeColumbusViewCallback(cameraCV) {\n  return function (transitioner) {\n    const scene = transitioner._scene;\n    scene._mode = SceneMode.COLUMBUS_VIEW;\n    scene.morphTime = SceneMode.getMorphTime(SceneMode.COLUMBUS_VIEW);\n    destroyMorphHandler(transitioner);\n    const camera = scene.camera;\n    if (transitioner._previousModeMode !== SceneMode.MORPHING || transitioner._morphCancelled) {\n      transitioner._morphCancelled = false;\n      Cartesian3.clone(cameraCV.position, camera.position);\n      Cartesian3.clone(cameraCV.direction, camera.direction);\n      Cartesian3.clone(cameraCV.up, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n    const frustum = camera.frustum;\n    if (scene.frameState.useLogDepth) {\n      frustum.near = 0.1;\n      frustum.far = 10000000000.0;\n    }\n    const wasMorphing = defined(transitioner._completeMorph);\n    transitioner._completeMorph = undefined;\n    scene.camera.update(scene.mode);\n    transitioner._scene.morphComplete.raiseEvent(transitioner, transitioner._previousMode, SceneMode.COLUMBUS_VIEW, wasMorphing);\n  };\n}\nexport default SceneTransitioner;","map":{"version":3,"names":["Cartesian3","Cartographic","Check","defined","destroyObject","EasingFunction","CesiumMath","Matrix4","OrthographicFrustum","OrthographicOffCenterFrustum","PerspectiveFrustum","Ray","ScreenSpaceEventHandler","ScreenSpaceEventType","Transforms","Camera","SceneMode","SceneTransitioner","scene","typeOf","object","_scene","_currentTweens","_morphHandler","undefined","_morphCancelled","_completeMorph","_morphToOrthographic","prototype","completeMorph","morphTo2D","duration","ellipsoid","_previousMode","mode","camera","frustum","SCENE2D","MORPHING","morphStart","raiseEvent","_mode","_setTransform","IDENTITY","COLUMBUS_VIEW","morphFromColumbusViewTo2D","morphFrom3DTo2D","scratchToCVPosition","scratchToCVDirection","scratchToCVUp","scratchToCVPosition2D","scratchToCVDirection2D","scratchToCVUp2D","scratchToCVSurfacePosition","scratchToCVCartographic","scratchToCVToENU","scratchToCVFrustumPerspective","scratchToCVFrustumOrthographic","scratchToCVCamera","position","direction","up","position2D","direction2D","up2D","morphToColumbusView","x","y","z","multiplyByScalar","normalize","maximumRadius","negate","cross","UNIT_X","clone","right","left","UNIT_Z","UNIT_Y","positionWC","directionWC","upWC","surfacePoint","scaleToGeodeticSurface","toENU","eastNorthUpToFixedFrame","inverseTransformation","mapProjection","project","cartesianToCartographic","multiplyByPointAsVector","width","aspectRatio","drawingBufferWidth","drawingBufferHeight","fov","toRadians","cameraCV","complete","completeColumbusViewCallback","createMorphHandler","morphFrom2DToColumbusView","multiplyByPoint","TRANSFORM_2D","morphFrom3DToColumbusView","scratchCVTo3DCamera","scratch2DTo3DFrustumPersp","morphTo3D","SCENE3D","morphFrom2DTo3D","camera3D","fromDegrees","getColumbusViewTo3DCamera","complete3DCallback","morphFromColumbusViewTo3D","isDestroyed","destroy","destroyMorphHandler","transitioner","completeMorphFunction","completeMorphOnUserInput","canvas","cancelFlight","setInputAction","LEFT_DOWN","MIDDLE_DOWN","RIGHT_DOWN","WHEEL","tweens","i","length","cancelTween","scratchCVTo3DCartographic","scratchCVTo3DSurfacePoint","scratchCVTo3DFromENU","positionCarto","unproject","cartographicToCartesian","fromENU","scratchCVTo3DStartPos","scratchCVTo3DStartDir","scratchCVTo3DStartUp","scratchCVTo3DEndPos","scratchCVTo3DEndDir","scratchCVTo3DEndUp","endCamera","startPos","startDir","startUp","endPos","TRANSFORM_2D_INVERSE","endDir","endUp","update","value","columbusViewMorph","time","tween","add","easingFunction","QUARTIC_OUT","startObject","stopObject","addMorphTimeAnimations","push","scratch2DTo3DFrustumOrtho","scratch3DToCVStartPos","scratch3DToCVStartDir","scratch3DToCVStartUp","scratch3DToCVEndPos","scratch3DToCVEndDir","scratch3DToCVEndUp","morph","morphOrthographicToPerspective","flyTo","destination","startPosition","endPosition","result","lerp","morphPerspectiveToOrthographic","updateHeight","startFOV","endFOV","RADIANS_PER_DEGREE","d","Math","tan","far","height","scratchCVTo2DStartPos","scratchCVTo2DStartDir","scratchCVTo2DStartUp","scratchCVTo2DEndPos","scratchCVTo2DEndDir","scratchCVTo2DEndUp","scratchCVTo2DFrustum","scratchCVTo2DRay","scratchCVTo2DPickPos","scratchCVTo2DCamera","ZERO","ray","origin","globe","pickPos","pickWorldCoordinates","distance","top","bottom","camera2D","complete2DCallback","updateCV","_adjustOrthographicFrustum","scratch3DTo2DCartographic","scratch3DTo2DCamera","scratch3DTo2DEndCamera","scratch3DTo2DPickPosition","scratch3DTo2DRay","scratch3DTo2DToENU","scratch3DTo2DSurfacePoint","rayDirection","pickedPos","completeCallback","start","stop","options","property","startValue","stopValue","addProperty","morphTime","getMorphTime","frameState","useLogDepth","near","wasMorphing","morphComplete","_previousModeMode"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/SceneTransitioner.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport EasingFunction from \"../Core/EasingFunction.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport Ray from \"../Core/Ray.js\";\nimport ScreenSpaceEventHandler from \"../Core/ScreenSpaceEventHandler.js\";\nimport ScreenSpaceEventType from \"../Core/ScreenSpaceEventType.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport Camera from \"./Camera.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * @private\n */\nfunction SceneTransitioner(scene) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scene\", scene);\n  //>>includeEnd('debug');\n\n  this._scene = scene;\n  this._currentTweens = [];\n  this._morphHandler = undefined;\n  this._morphCancelled = false;\n  this._completeMorph = undefined;\n  this._morphToOrthographic = false;\n}\n\nSceneTransitioner.prototype.completeMorph = function () {\n  if (defined(this._completeMorph)) {\n    this._completeMorph();\n  }\n};\n\nSceneTransitioner.prototype.morphTo2D = function (duration, ellipsoid) {\n  if (defined(this._completeMorph)) {\n    this._completeMorph();\n  }\n\n  const scene = this._scene;\n  this._previousMode = scene.mode;\n  this._morphToOrthographic =\n    scene.camera.frustum instanceof OrthographicFrustum;\n\n  if (\n    this._previousMode === SceneMode.SCENE2D ||\n    this._previousMode === SceneMode.MORPHING\n  ) {\n    return;\n  }\n  this._scene.morphStart.raiseEvent(\n    this,\n    this._previousMode,\n    SceneMode.SCENE2D,\n    true,\n  );\n\n  scene._mode = SceneMode.MORPHING;\n  scene.camera._setTransform(Matrix4.IDENTITY);\n\n  if (this._previousMode === SceneMode.COLUMBUS_VIEW) {\n    morphFromColumbusViewTo2D(this, duration);\n  } else {\n    morphFrom3DTo2D(this, duration, ellipsoid);\n  }\n\n  if (duration === 0.0 && defined(this._completeMorph)) {\n    this._completeMorph();\n  }\n};\n\nconst scratchToCVPosition = new Cartesian3();\nconst scratchToCVDirection = new Cartesian3();\nconst scratchToCVUp = new Cartesian3();\nconst scratchToCVPosition2D = new Cartesian3();\nconst scratchToCVDirection2D = new Cartesian3();\nconst scratchToCVUp2D = new Cartesian3();\nconst scratchToCVSurfacePosition = new Cartesian3();\nconst scratchToCVCartographic = new Cartographic();\nconst scratchToCVToENU = new Matrix4();\nconst scratchToCVFrustumPerspective = new PerspectiveFrustum();\nconst scratchToCVFrustumOrthographic = new OrthographicFrustum();\nconst scratchToCVCamera = {\n  position: undefined,\n  direction: undefined,\n  up: undefined,\n  position2D: undefined,\n  direction2D: undefined,\n  up2D: undefined,\n  frustum: undefined,\n};\n\nSceneTransitioner.prototype.morphToColumbusView = function (\n  duration,\n  ellipsoid,\n) {\n  if (defined(this._completeMorph)) {\n    this._completeMorph();\n  }\n\n  const scene = this._scene;\n  this._previousMode = scene.mode;\n\n  if (\n    this._previousMode === SceneMode.COLUMBUS_VIEW ||\n    this._previousMode === SceneMode.MORPHING\n  ) {\n    return;\n  }\n  this._scene.morphStart.raiseEvent(\n    this,\n    this._previousMode,\n    SceneMode.COLUMBUS_VIEW,\n    true,\n  );\n\n  scene.camera._setTransform(Matrix4.IDENTITY);\n\n  let position = scratchToCVPosition;\n  const direction = scratchToCVDirection;\n  const up = scratchToCVUp;\n\n  if (duration > 0.0) {\n    position.x = 0.0;\n    position.y = -1.0;\n    position.z = 1.0;\n    position = Cartesian3.multiplyByScalar(\n      Cartesian3.normalize(position, position),\n      5.0 * ellipsoid.maximumRadius,\n      position,\n    );\n\n    Cartesian3.negate(Cartesian3.normalize(position, direction), direction);\n    Cartesian3.cross(Cartesian3.UNIT_X, direction, up);\n  } else {\n    const camera = scene.camera;\n    if (this._previousMode === SceneMode.SCENE2D) {\n      Cartesian3.clone(camera.position, position);\n      position.z = camera.frustum.right - camera.frustum.left;\n      Cartesian3.negate(Cartesian3.UNIT_Z, direction);\n      Cartesian3.clone(Cartesian3.UNIT_Y, up);\n    } else {\n      Cartesian3.clone(camera.positionWC, position);\n      Cartesian3.clone(camera.directionWC, direction);\n      Cartesian3.clone(camera.upWC, up);\n\n      const surfacePoint = ellipsoid.scaleToGeodeticSurface(\n        position,\n        scratchToCVSurfacePosition,\n      );\n      const toENU = Transforms.eastNorthUpToFixedFrame(\n        surfacePoint,\n        ellipsoid,\n        scratchToCVToENU,\n      );\n      Matrix4.inverseTransformation(toENU, toENU);\n\n      scene.mapProjection.project(\n        ellipsoid.cartesianToCartographic(position, scratchToCVCartographic),\n        position,\n      );\n      Matrix4.multiplyByPointAsVector(toENU, direction, direction);\n      Matrix4.multiplyByPointAsVector(toENU, up, up);\n    }\n  }\n\n  let frustum;\n  if (this._morphToOrthographic) {\n    frustum = scratchToCVFrustumOrthographic;\n    frustum.width = scene.camera.frustum.right - scene.camera.frustum.left;\n    frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;\n  } else {\n    frustum = scratchToCVFrustumPerspective;\n    frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;\n    frustum.fov = CesiumMath.toRadians(60.0);\n  }\n\n  const cameraCV = scratchToCVCamera;\n  cameraCV.position = position;\n  cameraCV.direction = direction;\n  cameraCV.up = up;\n  cameraCV.frustum = frustum;\n\n  const complete = completeColumbusViewCallback(cameraCV);\n  createMorphHandler(this, complete);\n\n  if (this._previousMode === SceneMode.SCENE2D) {\n    morphFrom2DToColumbusView(this, duration, cameraCV, complete);\n  } else {\n    cameraCV.position2D = Matrix4.multiplyByPoint(\n      Camera.TRANSFORM_2D,\n      position,\n      scratchToCVPosition2D,\n    );\n    cameraCV.direction2D = Matrix4.multiplyByPointAsVector(\n      Camera.TRANSFORM_2D,\n      direction,\n      scratchToCVDirection2D,\n    );\n    cameraCV.up2D = Matrix4.multiplyByPointAsVector(\n      Camera.TRANSFORM_2D,\n      up,\n      scratchToCVUp2D,\n    );\n\n    scene._mode = SceneMode.MORPHING;\n    morphFrom3DToColumbusView(this, duration, cameraCV, complete);\n  }\n\n  if (duration === 0.0 && defined(this._completeMorph)) {\n    this._completeMorph();\n  }\n};\n\nconst scratchCVTo3DCamera = {\n  position: new Cartesian3(),\n  direction: new Cartesian3(),\n  up: new Cartesian3(),\n  frustum: undefined,\n};\nconst scratch2DTo3DFrustumPersp = new PerspectiveFrustum();\n\nSceneTransitioner.prototype.morphTo3D = function (duration, ellipsoid) {\n  if (defined(this._completeMorph)) {\n    this._completeMorph();\n  }\n\n  const scene = this._scene;\n  this._previousMode = scene.mode;\n\n  if (\n    this._previousMode === SceneMode.SCENE3D ||\n    this._previousMode === SceneMode.MORPHING\n  ) {\n    return;\n  }\n  this._scene.morphStart.raiseEvent(\n    this,\n    this._previousMode,\n    SceneMode.SCENE3D,\n    true,\n  );\n\n  scene._mode = SceneMode.MORPHING;\n  scene.camera._setTransform(Matrix4.IDENTITY);\n\n  if (this._previousMode === SceneMode.SCENE2D) {\n    morphFrom2DTo3D(this, duration, ellipsoid);\n  } else {\n    let camera3D;\n    if (duration > 0.0) {\n      camera3D = scratchCVTo3DCamera;\n      Cartesian3.fromDegrees(\n        0.0,\n        0.0,\n        5.0 * ellipsoid.maximumRadius,\n        ellipsoid,\n        camera3D.position,\n      );\n      Cartesian3.negate(camera3D.position, camera3D.direction);\n      Cartesian3.normalize(camera3D.direction, camera3D.direction);\n      Cartesian3.clone(Cartesian3.UNIT_Z, camera3D.up);\n    } else {\n      camera3D = getColumbusViewTo3DCamera(this, ellipsoid);\n    }\n\n    let frustum;\n    const camera = scene.camera;\n    if (camera.frustum instanceof OrthographicFrustum) {\n      frustum = camera.frustum.clone();\n    } else {\n      frustum = scratch2DTo3DFrustumPersp;\n      frustum.aspectRatio =\n        scene.drawingBufferWidth / scene.drawingBufferHeight;\n      frustum.fov = CesiumMath.toRadians(60.0);\n    }\n    camera3D.frustum = frustum;\n\n    const complete = complete3DCallback(camera3D);\n    createMorphHandler(this, complete);\n\n    morphFromColumbusViewTo3D(this, duration, camera3D, complete);\n  }\n\n  if (duration === 0.0 && defined(this._completeMorph)) {\n    this._completeMorph();\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nSceneTransitioner.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * transitioner = transitioner && transitioner.destroy();\n */\nSceneTransitioner.prototype.destroy = function () {\n  destroyMorphHandler(this);\n  return destroyObject(this);\n};\n\nfunction createMorphHandler(transitioner, completeMorphFunction) {\n  if (transitioner._scene.completeMorphOnUserInput) {\n    transitioner._morphHandler = new ScreenSpaceEventHandler(\n      transitioner._scene.canvas,\n    );\n\n    const completeMorph = function () {\n      transitioner._morphCancelled = true;\n      transitioner._scene.camera.cancelFlight();\n      completeMorphFunction(transitioner);\n    };\n    transitioner._completeMorph = completeMorph;\n    transitioner._morphHandler.setInputAction(\n      completeMorph,\n      ScreenSpaceEventType.LEFT_DOWN,\n    );\n    transitioner._morphHandler.setInputAction(\n      completeMorph,\n      ScreenSpaceEventType.MIDDLE_DOWN,\n    );\n    transitioner._morphHandler.setInputAction(\n      completeMorph,\n      ScreenSpaceEventType.RIGHT_DOWN,\n    );\n    transitioner._morphHandler.setInputAction(\n      completeMorph,\n      ScreenSpaceEventType.WHEEL,\n    );\n  }\n}\n\nfunction destroyMorphHandler(transitioner) {\n  const tweens = transitioner._currentTweens;\n  for (let i = 0; i < tweens.length; ++i) {\n    tweens[i].cancelTween();\n  }\n  transitioner._currentTweens.length = 0;\n  transitioner._morphHandler =\n    transitioner._morphHandler && transitioner._morphHandler.destroy();\n}\n\nconst scratchCVTo3DCartographic = new Cartographic();\nconst scratchCVTo3DSurfacePoint = new Cartesian3();\nconst scratchCVTo3DFromENU = new Matrix4();\n\nfunction getColumbusViewTo3DCamera(transitioner, ellipsoid) {\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n\n  const camera3D = scratchCVTo3DCamera;\n  const position = camera3D.position;\n  const direction = camera3D.direction;\n  const up = camera3D.up;\n\n  const positionCarto = scene.mapProjection.unproject(\n    camera.position,\n    scratchCVTo3DCartographic,\n  );\n  ellipsoid.cartographicToCartesian(positionCarto, position);\n  const surfacePoint = ellipsoid.scaleToGeodeticSurface(\n    position,\n    scratchCVTo3DSurfacePoint,\n  );\n\n  const fromENU = Transforms.eastNorthUpToFixedFrame(\n    surfacePoint,\n    ellipsoid,\n    scratchCVTo3DFromENU,\n  );\n\n  Matrix4.multiplyByPointAsVector(fromENU, camera.direction, direction);\n  Matrix4.multiplyByPointAsVector(fromENU, camera.up, up);\n\n  return camera3D;\n}\n\nconst scratchCVTo3DStartPos = new Cartesian3();\nconst scratchCVTo3DStartDir = new Cartesian3();\nconst scratchCVTo3DStartUp = new Cartesian3();\nconst scratchCVTo3DEndPos = new Cartesian3();\nconst scratchCVTo3DEndDir = new Cartesian3();\nconst scratchCVTo3DEndUp = new Cartesian3();\n\nfunction morphFromColumbusViewTo3D(\n  transitioner,\n  duration,\n  endCamera,\n  complete,\n) {\n  duration *= 0.5;\n\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n\n  const startPos = Cartesian3.clone(camera.position, scratchCVTo3DStartPos);\n  const startDir = Cartesian3.clone(camera.direction, scratchCVTo3DStartDir);\n  const startUp = Cartesian3.clone(camera.up, scratchCVTo3DStartUp);\n\n  const endPos = Matrix4.multiplyByPoint(\n    Camera.TRANSFORM_2D_INVERSE,\n    endCamera.position,\n    scratchCVTo3DEndPos,\n  );\n  const endDir = Matrix4.multiplyByPointAsVector(\n    Camera.TRANSFORM_2D_INVERSE,\n    endCamera.direction,\n    scratchCVTo3DEndDir,\n  );\n  const endUp = Matrix4.multiplyByPointAsVector(\n    Camera.TRANSFORM_2D_INVERSE,\n    endCamera.up,\n    scratchCVTo3DEndUp,\n  );\n\n  function update(value) {\n    columbusViewMorph(startPos, endPos, value.time, camera.position);\n    columbusViewMorph(startDir, endDir, value.time, camera.direction);\n    columbusViewMorph(startUp, endUp, value.time, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.normalize(camera.right, camera.right);\n  }\n\n  const tween = scene.tweens.add({\n    duration: duration,\n    easingFunction: EasingFunction.QUARTIC_OUT,\n    startObject: {\n      time: 0.0,\n    },\n    stopObject: {\n      time: 1.0,\n    },\n    update: update,\n    complete: function () {\n      addMorphTimeAnimations(transitioner, scene, 0.0, 1.0, duration, complete);\n    },\n  });\n  transitioner._currentTweens.push(tween);\n}\n\nconst scratch2DTo3DFrustumOrtho = new OrthographicFrustum();\nconst scratch3DToCVStartPos = new Cartesian3();\nconst scratch3DToCVStartDir = new Cartesian3();\nconst scratch3DToCVStartUp = new Cartesian3();\nconst scratch3DToCVEndPos = new Cartesian3();\nconst scratch3DToCVEndDir = new Cartesian3();\nconst scratch3DToCVEndUp = new Cartesian3();\n\nfunction morphFrom2DTo3D(transitioner, duration, ellipsoid) {\n  duration /= 3.0;\n\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n\n  let camera3D;\n  if (duration > 0.0) {\n    camera3D = scratchCVTo3DCamera;\n    Cartesian3.fromDegrees(\n      0.0,\n      0.0,\n      5.0 * ellipsoid.maximumRadius,\n      ellipsoid,\n      camera3D.position,\n    );\n    Cartesian3.negate(camera3D.position, camera3D.direction);\n    Cartesian3.normalize(camera3D.direction, camera3D.direction);\n    Cartesian3.clone(Cartesian3.UNIT_Z, camera3D.up);\n  } else {\n    camera.position.z = camera.frustum.right - camera.frustum.left;\n\n    camera3D = getColumbusViewTo3DCamera(transitioner, ellipsoid);\n  }\n\n  let frustum;\n  if (transitioner._morphToOrthographic) {\n    frustum = scratch2DTo3DFrustumOrtho;\n    frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;\n    frustum.width = camera.frustum.right - camera.frustum.left;\n  } else {\n    frustum = scratch2DTo3DFrustumPersp;\n    frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;\n    frustum.fov = CesiumMath.toRadians(60.0);\n  }\n\n  camera3D.frustum = frustum;\n\n  const complete = complete3DCallback(camera3D);\n  createMorphHandler(transitioner, complete);\n\n  let morph;\n  if (transitioner._morphToOrthographic) {\n    morph = function () {\n      morphFromColumbusViewTo3D(transitioner, duration, camera3D, complete);\n    };\n  } else {\n    morph = function () {\n      morphOrthographicToPerspective(\n        transitioner,\n        duration,\n        camera3D,\n        function () {\n          morphFromColumbusViewTo3D(transitioner, duration, camera3D, complete);\n        },\n      );\n    };\n  }\n\n  if (duration > 0.0) {\n    scene._mode = SceneMode.SCENE2D;\n    camera.flyTo({\n      duration: duration,\n      destination: Cartesian3.fromDegrees(\n        0.0,\n        0.0,\n        5.0 * ellipsoid.maximumRadius,\n        ellipsoid,\n        scratch3DToCVEndPos,\n      ),\n      complete: function () {\n        scene._mode = SceneMode.MORPHING;\n        morph();\n      },\n    });\n  } else {\n    morph();\n  }\n}\n\nfunction columbusViewMorph(startPosition, endPosition, time, result) {\n  // Just linear for now.\n  return Cartesian3.lerp(startPosition, endPosition, time, result);\n}\n\nfunction morphPerspectiveToOrthographic(\n  transitioner,\n  duration,\n  endCamera,\n  updateHeight,\n  complete,\n) {\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    return;\n  }\n\n  const startFOV = camera.frustum.fov;\n  const endFOV = CesiumMath.RADIANS_PER_DEGREE * 0.5;\n  const d = endCamera.position.z * Math.tan(startFOV * 0.5);\n  camera.frustum.far = d / Math.tan(endFOV * 0.5) + 10000000.0;\n\n  function update(value) {\n    camera.frustum.fov = CesiumMath.lerp(startFOV, endFOV, value.time);\n    const height = d / Math.tan(camera.frustum.fov * 0.5);\n    updateHeight(camera, height);\n  }\n  const tween = scene.tweens.add({\n    duration: duration,\n    easingFunction: EasingFunction.QUARTIC_OUT,\n    startObject: {\n      time: 0.0,\n    },\n    stopObject: {\n      time: 1.0,\n    },\n    update: update,\n    complete: function () {\n      camera.frustum = endCamera.frustum.clone();\n      complete(transitioner);\n    },\n  });\n  transitioner._currentTweens.push(tween);\n}\n\nconst scratchCVTo2DStartPos = new Cartesian3();\nconst scratchCVTo2DStartDir = new Cartesian3();\nconst scratchCVTo2DStartUp = new Cartesian3();\nconst scratchCVTo2DEndPos = new Cartesian3();\nconst scratchCVTo2DEndDir = new Cartesian3();\nconst scratchCVTo2DEndUp = new Cartesian3();\nconst scratchCVTo2DFrustum = new OrthographicOffCenterFrustum();\nconst scratchCVTo2DRay = new Ray();\nconst scratchCVTo2DPickPos = new Cartesian3();\nconst scratchCVTo2DCamera = {\n  position: undefined,\n  direction: undefined,\n  up: undefined,\n  frustum: undefined,\n};\n\nfunction morphFromColumbusViewTo2D(transitioner, duration) {\n  duration *= 0.5;\n\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n\n  const startPos = Cartesian3.clone(camera.position, scratchCVTo2DStartPos);\n  const startDir = Cartesian3.clone(camera.direction, scratchCVTo2DStartDir);\n  const startUp = Cartesian3.clone(camera.up, scratchCVTo2DStartUp);\n\n  const endDir = Cartesian3.negate(Cartesian3.UNIT_Z, scratchCVTo2DEndDir);\n  const endUp = Cartesian3.clone(Cartesian3.UNIT_Y, scratchCVTo2DEndUp);\n\n  const endPos = scratchCVTo2DEndPos;\n\n  if (duration > 0.0) {\n    Cartesian3.clone(Cartesian3.ZERO, scratchCVTo2DEndPos);\n    endPos.z = 5.0 * scene.ellipsoid.maximumRadius;\n  } else {\n    Cartesian3.clone(startPos, scratchCVTo2DEndPos);\n\n    const ray = scratchCVTo2DRay;\n    Matrix4.multiplyByPoint(Camera.TRANSFORM_2D, startPos, ray.origin);\n    Matrix4.multiplyByPointAsVector(\n      Camera.TRANSFORM_2D,\n      startDir,\n      ray.direction,\n    );\n\n    const globe = scene.globe;\n    if (defined(globe)) {\n      const pickPos = globe.pickWorldCoordinates(\n        ray,\n        scene,\n        true,\n        scratchCVTo2DPickPos,\n      );\n      if (defined(pickPos)) {\n        Matrix4.multiplyByPoint(Camera.TRANSFORM_2D_INVERSE, pickPos, endPos);\n        endPos.z += Cartesian3.distance(startPos, endPos);\n      }\n    }\n  }\n\n  const frustum = scratchCVTo2DFrustum;\n  frustum.right = endPos.z * 0.5;\n  frustum.left = -frustum.right;\n  frustum.top =\n    frustum.right * (scene.drawingBufferHeight / scene.drawingBufferWidth);\n  frustum.bottom = -frustum.top;\n\n  const camera2D = scratchCVTo2DCamera;\n  camera2D.position = endPos;\n  camera2D.direction = endDir;\n  camera2D.up = endUp;\n  camera2D.frustum = frustum;\n\n  const complete = complete2DCallback(camera2D);\n  createMorphHandler(transitioner, complete);\n\n  function updateCV(value) {\n    columbusViewMorph(startPos, endPos, value.time, camera.position);\n    columbusViewMorph(startDir, endDir, value.time, camera.direction);\n    columbusViewMorph(startUp, endUp, value.time, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.normalize(camera.right, camera.right);\n    camera._adjustOrthographicFrustum(true);\n  }\n\n  function updateHeight(camera, height) {\n    camera.position.z = height;\n  }\n\n  const tween = scene.tweens.add({\n    duration: duration,\n    easingFunction: EasingFunction.QUARTIC_OUT,\n    startObject: {\n      time: 0.0,\n    },\n    stopObject: {\n      time: 1.0,\n    },\n    update: updateCV,\n    complete: function () {\n      morphPerspectiveToOrthographic(\n        transitioner,\n        duration,\n        camera2D,\n        updateHeight,\n        complete,\n      );\n    },\n  });\n  transitioner._currentTweens.push(tween);\n}\n\nconst scratch3DTo2DCartographic = new Cartographic();\nconst scratch3DTo2DCamera = {\n  position: new Cartesian3(),\n  direction: new Cartesian3(),\n  up: new Cartesian3(),\n  position2D: new Cartesian3(),\n  direction2D: new Cartesian3(),\n  up2D: new Cartesian3(),\n  frustum: new OrthographicOffCenterFrustum(),\n};\nconst scratch3DTo2DEndCamera = {\n  position: new Cartesian3(),\n  direction: new Cartesian3(),\n  up: new Cartesian3(),\n  frustum: undefined,\n};\nconst scratch3DTo2DPickPosition = new Cartesian3();\nconst scratch3DTo2DRay = new Ray();\nconst scratch3DTo2DToENU = new Matrix4();\nconst scratch3DTo2DSurfacePoint = new Cartesian3();\n\nfunction morphFrom3DTo2D(transitioner, duration, ellipsoid) {\n  duration *= 0.5;\n\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n  const camera2D = scratch3DTo2DCamera;\n\n  if (duration > 0.0) {\n    Cartesian3.clone(Cartesian3.ZERO, camera2D.position);\n    camera2D.position.z = 5.0 * ellipsoid.maximumRadius;\n    Cartesian3.negate(Cartesian3.UNIT_Z, camera2D.direction);\n    Cartesian3.clone(Cartesian3.UNIT_Y, camera2D.up);\n  } else {\n    ellipsoid.cartesianToCartographic(\n      camera.positionWC,\n      scratch3DTo2DCartographic,\n    );\n    scene.mapProjection.project(scratch3DTo2DCartographic, camera2D.position);\n\n    Cartesian3.negate(Cartesian3.UNIT_Z, camera2D.direction);\n    Cartesian3.clone(Cartesian3.UNIT_Y, camera2D.up);\n\n    const ray = scratch3DTo2DRay;\n    Cartesian3.clone(camera2D.position2D, ray.origin);\n    const rayDirection = Cartesian3.clone(camera.directionWC, ray.direction);\n    const surfacePoint = ellipsoid.scaleToGeodeticSurface(\n      camera.positionWC,\n      scratch3DTo2DSurfacePoint,\n    );\n    const toENU = Transforms.eastNorthUpToFixedFrame(\n      surfacePoint,\n      ellipsoid,\n      scratch3DTo2DToENU,\n    );\n    Matrix4.inverseTransformation(toENU, toENU);\n    Matrix4.multiplyByPointAsVector(toENU, rayDirection, rayDirection);\n    Matrix4.multiplyByPointAsVector(\n      Camera.TRANSFORM_2D,\n      rayDirection,\n      rayDirection,\n    );\n\n    const globe = scene.globe;\n    if (defined(globe)) {\n      const pickedPos = globe.pickWorldCoordinates(\n        ray,\n        scene,\n        true,\n        scratch3DTo2DPickPosition,\n      );\n      if (defined(pickedPos)) {\n        const height = Cartesian3.distance(camera2D.position2D, pickedPos);\n        pickedPos.x += height;\n        Cartesian3.clone(pickedPos, camera2D.position2D);\n      }\n    }\n  }\n\n  function updateHeight(camera, height) {\n    camera.position.x = height;\n  }\n\n  Matrix4.multiplyByPoint(\n    Camera.TRANSFORM_2D,\n    camera2D.position,\n    camera2D.position2D,\n  );\n  Matrix4.multiplyByPointAsVector(\n    Camera.TRANSFORM_2D,\n    camera2D.direction,\n    camera2D.direction2D,\n  );\n  Matrix4.multiplyByPointAsVector(\n    Camera.TRANSFORM_2D,\n    camera2D.up,\n    camera2D.up2D,\n  );\n\n  const frustum = camera2D.frustum;\n  frustum.right = camera2D.position.z * 0.5;\n  frustum.left = -frustum.right;\n  frustum.top =\n    frustum.right * (scene.drawingBufferHeight / scene.drawingBufferWidth);\n  frustum.bottom = -frustum.top;\n\n  const endCamera = scratch3DTo2DEndCamera;\n  Matrix4.multiplyByPoint(\n    Camera.TRANSFORM_2D_INVERSE,\n    camera2D.position2D,\n    endCamera.position,\n  );\n  Cartesian3.clone(camera2D.direction, endCamera.direction);\n  Cartesian3.clone(camera2D.up, endCamera.up);\n  endCamera.frustum = frustum;\n\n  const complete = complete2DCallback(endCamera);\n  createMorphHandler(transitioner, complete);\n\n  function completeCallback() {\n    morphPerspectiveToOrthographic(\n      transitioner,\n      duration,\n      camera2D,\n      updateHeight,\n      complete,\n    );\n  }\n  morphFrom3DToColumbusView(transitioner, duration, camera2D, completeCallback);\n}\n\nfunction morphOrthographicToPerspective(\n  transitioner,\n  duration,\n  cameraCV,\n  complete,\n) {\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n\n  const height = camera.frustum.right - camera.frustum.left;\n  camera.frustum = cameraCV.frustum.clone();\n\n  const endFOV = camera.frustum.fov;\n  const startFOV = CesiumMath.RADIANS_PER_DEGREE * 0.5;\n  const d = height * Math.tan(endFOV * 0.5);\n  camera.frustum.far = d / Math.tan(startFOV * 0.5) + 10000000.0;\n  camera.frustum.fov = startFOV;\n\n  function update(value) {\n    camera.frustum.fov = CesiumMath.lerp(startFOV, endFOV, value.time);\n    camera.position.z = d / Math.tan(camera.frustum.fov * 0.5);\n  }\n  const tween = scene.tweens.add({\n    duration: duration,\n    easingFunction: EasingFunction.QUARTIC_OUT,\n    startObject: {\n      time: 0.0,\n    },\n    stopObject: {\n      time: 1.0,\n    },\n    update: update,\n    complete: function () {\n      complete(transitioner);\n    },\n  });\n  transitioner._currentTweens.push(tween);\n}\n\nfunction morphFrom2DToColumbusView(transitioner, duration, cameraCV, complete) {\n  duration *= 0.5;\n\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n\n  const endPos = Cartesian3.clone(cameraCV.position, scratch3DToCVEndPos);\n  const endDir = Cartesian3.clone(cameraCV.direction, scratch3DToCVEndDir);\n  const endUp = Cartesian3.clone(cameraCV.up, scratch3DToCVEndUp);\n\n  scene._mode = SceneMode.MORPHING;\n\n  function morph() {\n    camera.frustum = cameraCV.frustum.clone();\n\n    const startPos = Cartesian3.clone(camera.position, scratch3DToCVStartPos);\n    const startDir = Cartesian3.clone(camera.direction, scratch3DToCVStartDir);\n    const startUp = Cartesian3.clone(camera.up, scratch3DToCVStartUp);\n    startPos.z = endPos.z;\n\n    function update(value) {\n      columbusViewMorph(startPos, endPos, value.time, camera.position);\n      columbusViewMorph(startDir, endDir, value.time, camera.direction);\n      columbusViewMorph(startUp, endUp, value.time, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n    const tween = scene.tweens.add({\n      duration: duration,\n      easingFunction: EasingFunction.QUARTIC_OUT,\n      startObject: {\n        time: 0.0,\n      },\n      stopObject: {\n        time: 1.0,\n      },\n      update: update,\n      complete: function () {\n        complete(transitioner);\n      },\n    });\n    transitioner._currentTweens.push(tween);\n  }\n\n  if (transitioner._morphToOrthographic) {\n    morph();\n  } else {\n    morphOrthographicToPerspective(transitioner, 0.0, cameraCV, morph);\n  }\n}\n\nfunction morphFrom3DToColumbusView(\n  transitioner,\n  duration,\n  endCamera,\n  complete,\n) {\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n\n  const startPos = Cartesian3.clone(camera.position, scratch3DToCVStartPos);\n  const startDir = Cartesian3.clone(camera.direction, scratch3DToCVStartDir);\n  const startUp = Cartesian3.clone(camera.up, scratch3DToCVStartUp);\n\n  const endPos = Cartesian3.clone(endCamera.position2D, scratch3DToCVEndPos);\n  const endDir = Cartesian3.clone(endCamera.direction2D, scratch3DToCVEndDir);\n  const endUp = Cartesian3.clone(endCamera.up2D, scratch3DToCVEndUp);\n\n  function update(value) {\n    columbusViewMorph(startPos, endPos, value.time, camera.position);\n    columbusViewMorph(startDir, endDir, value.time, camera.direction);\n    columbusViewMorph(startUp, endUp, value.time, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.normalize(camera.right, camera.right);\n    camera._adjustOrthographicFrustum(true);\n  }\n  const tween = scene.tweens.add({\n    duration: duration,\n    easingFunction: EasingFunction.QUARTIC_OUT,\n    startObject: {\n      time: 0.0,\n    },\n    stopObject: {\n      time: 1.0,\n    },\n    update: update,\n    complete: function () {\n      addMorphTimeAnimations(transitioner, scene, 1.0, 0.0, duration, complete);\n    },\n  });\n  transitioner._currentTweens.push(tween);\n}\n\nfunction addMorphTimeAnimations(\n  transitioner,\n  scene,\n  start,\n  stop,\n  duration,\n  complete,\n) {\n  // Later, this will be linear and each object will adjust, if desired, in its vertex shader.\n  const options = {\n    object: scene,\n    property: \"morphTime\",\n    startValue: start,\n    stopValue: stop,\n    duration: duration,\n    easingFunction: EasingFunction.QUARTIC_OUT,\n  };\n\n  if (defined(complete)) {\n    options.complete = function () {\n      complete(transitioner);\n    };\n  }\n\n  const tween = scene.tweens.addProperty(options);\n  transitioner._currentTweens.push(tween);\n}\n\nfunction complete3DCallback(camera3D) {\n  return function (transitioner) {\n    const scene = transitioner._scene;\n    scene._mode = SceneMode.SCENE3D;\n    scene.morphTime = SceneMode.getMorphTime(SceneMode.SCENE3D);\n\n    destroyMorphHandler(transitioner);\n\n    const camera = scene.camera;\n    if (\n      transitioner._previousMode !== SceneMode.MORPHING ||\n      transitioner._morphCancelled\n    ) {\n      transitioner._morphCancelled = false;\n\n      Cartesian3.clone(camera3D.position, camera.position);\n      Cartesian3.clone(camera3D.direction, camera.direction);\n      Cartesian3.clone(camera3D.up, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.normalize(camera.right, camera.right);\n\n      camera.frustum = camera3D.frustum.clone();\n    }\n\n    const frustum = camera.frustum;\n    if (scene.frameState.useLogDepth) {\n      frustum.near = 0.1;\n      frustum.far = 10000000000.0;\n    }\n\n    const wasMorphing = defined(transitioner._completeMorph);\n    transitioner._completeMorph = undefined;\n    scene.camera.update(scene.mode);\n    transitioner._scene.morphComplete.raiseEvent(\n      transitioner,\n      transitioner._previousMode,\n      SceneMode.SCENE3D,\n      wasMorphing,\n    );\n  };\n}\n\nfunction complete2DCallback(camera2D) {\n  return function (transitioner) {\n    const scene = transitioner._scene;\n\n    scene._mode = SceneMode.SCENE2D;\n    scene.morphTime = SceneMode.getMorphTime(SceneMode.SCENE2D);\n\n    destroyMorphHandler(transitioner);\n\n    const camera = scene.camera;\n    Cartesian3.clone(camera2D.position, camera.position);\n    camera.position.z = scene.ellipsoid.maximumRadius * 2.0;\n    Cartesian3.clone(camera2D.direction, camera.direction);\n    Cartesian3.clone(camera2D.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.normalize(camera.right, camera.right);\n    camera.frustum = camera2D.frustum.clone();\n\n    const wasMorphing = defined(transitioner._completeMorph);\n    transitioner._completeMorph = undefined;\n    scene.camera.update(scene.mode);\n    transitioner._scene.morphComplete.raiseEvent(\n      transitioner,\n      transitioner._previousMode,\n      SceneMode.SCENE2D,\n      wasMorphing,\n    );\n  };\n}\n\nfunction completeColumbusViewCallback(cameraCV) {\n  return function (transitioner) {\n    const scene = transitioner._scene;\n    scene._mode = SceneMode.COLUMBUS_VIEW;\n    scene.morphTime = SceneMode.getMorphTime(SceneMode.COLUMBUS_VIEW);\n\n    destroyMorphHandler(transitioner);\n\n    const camera = scene.camera;\n    if (\n      transitioner._previousModeMode !== SceneMode.MORPHING ||\n      transitioner._morphCancelled\n    ) {\n      transitioner._morphCancelled = false;\n\n      Cartesian3.clone(cameraCV.position, camera.position);\n      Cartesian3.clone(cameraCV.direction, camera.direction);\n      Cartesian3.clone(cameraCV.up, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n\n    const frustum = camera.frustum;\n    if (scene.frameState.useLogDepth) {\n      frustum.near = 0.1;\n      frustum.far = 10000000000.0;\n    }\n\n    const wasMorphing = defined(transitioner._completeMorph);\n    transitioner._completeMorph = undefined;\n    scene.camera.update(scene.mode);\n    transitioner._scene.morphComplete.raiseEvent(\n      transitioner,\n      transitioner._previousMode,\n      SceneMode.COLUMBUS_VIEW,\n      wasMorphing,\n    );\n  };\n}\nexport default SceneTransitioner;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}