{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport Frozen from \"../../Core/Frozen.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Transforms from \"../../Core/Transforms.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport SplitDirection from \"../SplitDirection.js\";\nimport TilesetPipelineStage from \"./TilesetPipelineStage.js\";\nimport AtmospherePipelineStage from \"./AtmospherePipelineStage.js\";\nimport ImageBasedLightingPipelineStage from \"./ImageBasedLightingPipelineStage.js\";\nimport ModelArticulation from \"./ModelArticulation.js\";\nimport ModelColorPipelineStage from \"./ModelColorPipelineStage.js\";\nimport ModelClippingPlanesPipelineStage from \"./ModelClippingPlanesPipelineStage.js\";\nimport ModelClippingPolygonsPipelineStage from \"./ModelClippingPolygonsPipelineStage.js\";\nimport ModelNode from \"./ModelNode.js\";\nimport ModelRuntimeNode from \"./ModelRuntimeNode.js\";\nimport ModelRuntimePrimitive from \"./ModelRuntimePrimitive.js\";\nimport ModelSkin from \"./ModelSkin.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport ModelRenderResources from \"./ModelRenderResources.js\";\nimport ModelSilhouettePipelineStage from \"./ModelSilhouettePipelineStage.js\";\nimport ModelSplitterPipelineStage from \"./ModelSplitterPipelineStage.js\";\nimport ModelType from \"./ModelType.js\";\nimport NodeRenderResources from \"./NodeRenderResources.js\";\nimport PrimitiveRenderResources from \"./PrimitiveRenderResources.js\";\nimport ModelDrawCommands from \"./ModelDrawCommands.js\";\nimport addAllToArray from \"../../Core/addAllToArray.js\";\n\n/**\n * An in memory representation of the scene graph for a {@link Model}\n *\n * @param {object} options An object containing the following options\n * @param {Model} options.model The model this scene graph belongs to\n * @param {ModelComponents} options.modelComponents The model components describing the model\n *\n * @alias ModelSceneGraph\n * @constructor\n *\n * @private\n */\nfunction ModelSceneGraph(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const components = options.modelComponents;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.model\", options.model);\n  Check.typeOf.object(\"options.modelComponents\", components);\n  //>>includeEnd('debug');\n\n  /**\n   * A reference to the {@link Model} that owns this scene graph.\n   *\n   * @type {Model}\n   * @readonly\n   *\n   * @private\n   */\n  this._model = options.model;\n\n  /**\n   * The model components that represent the contents of the 3D model file.\n   *\n   * @type {ModelComponents}\n   * @readonly\n   *\n   * @private\n   */\n  this._components = components;\n\n  /**\n   * Pipeline stages to apply across the model.\n   *\n   * @type {Object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._pipelineStages = [];\n\n  /**\n   * Update stages to apply across the model.\n   *\n   * @type {Object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._updateStages = [];\n\n  /**\n   * The runtime nodes that make up the scene graph\n   *\n   * @type {ModelRuntimeNode[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._runtimeNodes = [];\n\n  /**\n   * The indices of the root nodes in the runtime nodes array.\n   *\n   * @type {number[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._rootNodes = [];\n\n  /**\n   * The indices of the skinned nodes in the runtime nodes array. These refer\n   * to the nodes that will be manipulated by their skin, as opposed to the nodes\n   * acting as joints for the skin.\n   *\n   * @type {number[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._skinnedNodes = [];\n\n  /**\n   * The runtime skins that affect nodes in the scene graph.\n   *\n   * @type {ModelSkin[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._runtimeSkins = [];\n\n  /**\n   * Pipeline stages to apply to this model. This\n   * is an array of classes, each with a static method called\n   * <code>process()</code>\n   *\n   * @type {Object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.modelPipelineStages = [];\n\n  // The scene graph's bounding sphere is model space, so that\n  // the model's bounding sphere can be recomputed when given a\n  // new model matrix.\n  this._boundingSphere = undefined;\n\n  // The 2D bounding sphere is in world space. This is checked\n  // by the draw commands to see if the model is over the IDL,\n  // and if so, renders the primitives using extra commands.\n  this._boundingSphere2D = undefined;\n  this._computedModelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._computedModelMatrix2D = Matrix4.clone(Matrix4.IDENTITY);\n  this._axisCorrectionMatrix = ModelUtility.getAxisCorrectionMatrix(components.upAxis, components.forwardAxis, new Matrix4());\n\n  // Store articulations from the AGI_articulations extension\n  // by name in a dictionary for easy retrieval.\n  this._runtimeArticulations = {};\n  initialize(this);\n}\nObject.defineProperties(ModelSceneGraph.prototype, {\n  /**\n   * The model components this scene graph represents.\n   *\n   * @type {ModelComponents}\n   * @readonly\n   *\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    }\n  },\n  /**\n   * The axis-corrected model matrix.\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @private\n   */\n  computedModelMatrix: {\n    get: function () {\n      return this._computedModelMatrix;\n    }\n  },\n  /**\n   * A matrix to correct from y-up in some model formats (e.g. glTF) to the\n   * z-up coordinate system Cesium uses.\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @private\n   */\n  axisCorrectionMatrix: {\n    get: function () {\n      return this._axisCorrectionMatrix;\n    }\n  },\n  /**\n   * The bounding sphere containing all the primitives in the scene graph\n   * in model space.\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   *\n   * @private\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    }\n  }\n});\nfunction initialize(sceneGraph) {\n  const components = sceneGraph._components;\n  const scene = components.scene;\n  const model = sceneGraph._model;\n\n  // If the model has a height reference that modifies the model matrix,\n  // it will be accounted for in updateModelMatrix.\n  const modelMatrix = model.modelMatrix;\n  computeModelMatrix(sceneGraph, modelMatrix);\n  const articulations = components.articulations;\n  const articulationsLength = articulations.length;\n  const runtimeArticulations = sceneGraph._runtimeArticulations;\n  for (let i = 0; i < articulationsLength; i++) {\n    const articulation = articulations[i];\n    const runtimeArticulation = new ModelArticulation({\n      articulation: articulation,\n      sceneGraph: sceneGraph\n    });\n    const name = runtimeArticulation.name;\n    runtimeArticulations[name] = runtimeArticulation;\n  }\n  const nodes = components.nodes;\n  const nodesLength = nodes.length;\n\n  // Initialize this array to be the same size as the nodes array in\n  // the model file. This is so the node indices remain the same. However,\n  // only nodes reachable from the scene's root node will be populated, the\n  // rest will be undefined\n  sceneGraph._runtimeNodes = new Array(nodesLength);\n  const rootNodes = scene.nodes;\n  const rootNodesLength = rootNodes.length;\n  const transformToRoot = Matrix4.IDENTITY;\n  for (let i = 0; i < rootNodesLength; i++) {\n    const rootNode = scene.nodes[i];\n    const rootNodeIndex = traverseAndCreateSceneGraph(sceneGraph, rootNode, transformToRoot);\n    sceneGraph._rootNodes.push(rootNodeIndex);\n  }\n\n  // Handle skins after all runtime nodes are created\n  const skins = components.skins;\n  const runtimeSkins = sceneGraph._runtimeSkins;\n  const skinsLength = skins.length;\n  for (let i = 0; i < skinsLength; i++) {\n    const skin = skins[i];\n    runtimeSkins.push(new ModelSkin({\n      skin: skin,\n      sceneGraph: sceneGraph\n    }));\n  }\n  const skinnedNodes = sceneGraph._skinnedNodes;\n  const skinnedNodesLength = skinnedNodes.length;\n  for (let i = 0; i < skinnedNodesLength; i++) {\n    const skinnedNodeIndex = skinnedNodes[i];\n    const skinnedNode = sceneGraph._runtimeNodes[skinnedNodeIndex];\n\n    // Use the index of the skin in the model components to find\n    // the corresponding runtime skin.\n    const skin = nodes[skinnedNodeIndex].skin;\n    const skinIndex = skin.index;\n    skinnedNode._runtimeSkin = runtimeSkins[skinIndex];\n    skinnedNode.updateJointMatrices();\n  }\n\n  // Ensure articulations are applied with their initial values to their target nodes.\n  sceneGraph.applyArticulations();\n}\nfunction computeModelMatrix(sceneGraph, modelMatrix) {\n  const components = sceneGraph._components;\n  const model = sceneGraph._model;\n  sceneGraph._computedModelMatrix = Matrix4.multiplyTransformation(modelMatrix, components.transform, sceneGraph._computedModelMatrix);\n  sceneGraph._computedModelMatrix = Matrix4.multiplyTransformation(sceneGraph._computedModelMatrix, sceneGraph._axisCorrectionMatrix, sceneGraph._computedModelMatrix);\n  sceneGraph._computedModelMatrix = Matrix4.multiplyByUniformScale(sceneGraph._computedModelMatrix, model.computedScale, sceneGraph._computedModelMatrix);\n}\nconst scratchComputedTranslation = new Cartesian3();\nfunction computeModelMatrix2D(sceneGraph, frameState) {\n  const computedModelMatrix = sceneGraph._computedModelMatrix;\n  const translation = Matrix4.getTranslation(computedModelMatrix, scratchComputedTranslation);\n  if (!Cartesian3.equals(translation, Cartesian3.ZERO)) {\n    sceneGraph._computedModelMatrix2D = Transforms.basisTo2D(frameState.mapProjection, computedModelMatrix, sceneGraph._computedModelMatrix2D);\n  } else {\n    const center = sceneGraph.boundingSphere.center;\n    const to2D = Transforms.ellipsoidTo2DModelMatrix(frameState.mapProjection, center, sceneGraph._computedModelMatrix2D);\n    sceneGraph._computedModelMatrix2D = Matrix4.multiply(to2D, computedModelMatrix, sceneGraph._computedModelMatrix2D);\n  }\n  sceneGraph._boundingSphere2D = BoundingSphere.transform(sceneGraph._boundingSphere, sceneGraph._computedModelMatrix2D, sceneGraph._boundingSphere2D);\n}\n\n/**\n * Recursively traverse through the nodes in the scene graph to create\n * their runtime versions, using a post-order depth-first traversal.\n *\n * @param {ModelSceneGraph} sceneGraph The scene graph\n * @param {ModelComponents.Node} node The current node\n * @param {Matrix4} transformToRoot The transforms of this node's ancestors.\n * @returns {number} The index of this node in the runtimeNodes array.\n *\n * @private\n */\nfunction traverseAndCreateSceneGraph(sceneGraph, node, transformToRoot) {\n  // The indices of the children of this node in the runtimeNodes array.\n  const childrenIndices = [];\n  const transform = ModelUtility.getNodeTransform(node);\n\n  // Traverse through scene graph.\n  const childrenLength = node.children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    const childNode = node.children[i];\n    const childNodeTransformToRoot = Matrix4.multiplyTransformation(transformToRoot, transform, new Matrix4());\n    const childIndex = traverseAndCreateSceneGraph(sceneGraph, childNode, childNodeTransformToRoot);\n    childrenIndices.push(childIndex);\n  }\n\n  // Process node and mesh primitives.\n  const runtimeNode = new ModelRuntimeNode({\n    node: node,\n    transform: transform,\n    transformToRoot: transformToRoot,\n    children: childrenIndices,\n    sceneGraph: sceneGraph\n  });\n  const primitivesLength = node.primitives.length;\n  for (let i = 0; i < primitivesLength; i++) {\n    runtimeNode.runtimePrimitives.push(new ModelRuntimePrimitive({\n      primitive: node.primitives[i],\n      node: node,\n      model: sceneGraph._model\n    }));\n  }\n  const index = node.index;\n  sceneGraph._runtimeNodes[index] = runtimeNode;\n  if (defined(node.skin)) {\n    sceneGraph._skinnedNodes.push(index);\n  }\n\n  // Create and store the public version of the runtime node.\n  const name = node.name;\n  if (defined(name)) {\n    const model = sceneGraph._model;\n    const publicNode = new ModelNode(model, runtimeNode);\n    model._nodesByName[name] = publicNode;\n  }\n  return index;\n}\nconst scratchModelPositionMin = new Cartesian3();\nconst scratchModelPositionMax = new Cartesian3();\nconst scratchPrimitivePositionMin = new Cartesian3();\nconst scratchPrimitivePositionMax = new Cartesian3();\n\n/**\n * Generates the {@link ModelDrawCommand} for each primitive in the model.\n * If the model is used for classification, a {@link ClassificationModelDrawCommand}\n * is generated for each primitive instead.\n *\n * @param {FrameState} frameState The current frame state. This is needed to\n * allocate GPU resources as needed.\n *\n * @private\n */\nModelSceneGraph.prototype.buildDrawCommands = function (frameState) {\n  const modelRenderResources = this.buildRenderResources(frameState);\n  this.computeBoundingVolumes(modelRenderResources);\n  this.createDrawCommands(modelRenderResources, frameState);\n};\n\n/**\n * Generates the {@link ModelRenderResources} for the model.\n *\n * This will traverse the model, nodes and primitives of the scene graph,\n * and perform the following tasks:\n *\n * - configure the pipeline stages by calling `configurePipeline`,\n *   `runtimeNode.configurePipeline`, and `runtimePrimitive.configurePipeline`\n * - create the `ModelRenderResources`, `NodeRenderResources`, and\n *   `PrimitiveRenderResources`\n * - Process the render resources with the respective pipelines\n *\n * @param {FrameState} frameState The current frame state. This is needed to\n * allocate GPU resources as needed.\n * @returns {ModelRenderResources} The model render resources\n *\n * @private\n */\nModelSceneGraph.prototype.buildRenderResources = function (frameState) {\n  const model = this._model;\n  const modelRenderResources = new ModelRenderResources(model);\n\n  // Reset the memory counts before running the pipeline\n  model.statistics.clear();\n  this.configurePipeline(frameState);\n  const modelPipelineStages = this.modelPipelineStages;\n  for (let i = 0; i < modelPipelineStages.length; i++) {\n    const modelPipelineStage = modelPipelineStages[i];\n    modelPipelineStage.process(modelRenderResources, model, frameState);\n  }\n  for (let i = 0; i < this._runtimeNodes.length; i++) {\n    const runtimeNode = this._runtimeNodes[i];\n\n    // If a node in the model was unreachable from the scene graph, there will\n    // be no corresponding runtime node and therefore should be skipped.\n    if (!defined(runtimeNode)) {\n      continue;\n    }\n    runtimeNode.configurePipeline();\n    const nodePipelineStages = runtimeNode.pipelineStages;\n    const nodeRenderResources = new NodeRenderResources(modelRenderResources, runtimeNode);\n    modelRenderResources.nodeRenderResources[i] = nodeRenderResources;\n    for (let j = 0; j < nodePipelineStages.length; j++) {\n      const nodePipelineStage = nodePipelineStages[j];\n      nodePipelineStage.process(nodeRenderResources, runtimeNode.node, frameState);\n    }\n    for (let j = 0; j < runtimeNode.runtimePrimitives.length; j++) {\n      const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n      runtimePrimitive.configurePipeline(frameState);\n      const primitivePipelineStages = runtimePrimitive.pipelineStages;\n      const primitiveRenderResources = new PrimitiveRenderResources(nodeRenderResources, runtimePrimitive);\n      nodeRenderResources.primitiveRenderResources[j] = primitiveRenderResources;\n      for (let k = 0; k < primitivePipelineStages.length; k++) {\n        const primitivePipelineStage = primitivePipelineStages[k];\n        primitivePipelineStage.process(primitiveRenderResources, runtimePrimitive.primitive, frameState);\n      }\n    }\n  }\n  return modelRenderResources;\n};\n\n/**\n * Computes the bounding volumes for the scene graph and the model.\n *\n * This will traverse the model, nodes and primitives of the scene graph,\n * and compute the bounding volumes. Specifically, it will compute\n *\n * - this._boundingSphere\n * - model._boundingSphere\n *\n * With the latter being modified as of\n *\n * - model._initialRadius = model._boundingSphere.radius;\n * - model._boundingSphere.radius *= model._clampedScale;\n *\n * NOTE: This contains some bugs. See https://github.com/CesiumGS/cesium/issues/12108\n *\n * @param {ModelRenderResources} modelRenderResources The model render resources\n *\n * @private\n */\nModelSceneGraph.prototype.computeBoundingVolumes = function (modelRenderResources) {\n  const model = this._model;\n  const modelPositionMin = Cartesian3.fromElements(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, scratchModelPositionMin);\n  const modelPositionMax = Cartesian3.fromElements(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, scratchModelPositionMax);\n  for (let i = 0; i < this._runtimeNodes.length; i++) {\n    const runtimeNode = this._runtimeNodes[i];\n\n    // If a node in the model was unreachable from the scene graph, there will\n    // be no corresponding runtime node and therefore should be skipped.\n    if (!defined(runtimeNode)) {\n      continue;\n    }\n    const nodeRenderResources = modelRenderResources.nodeRenderResources[i];\n    const nodeTransform = runtimeNode.computedTransform;\n    for (let j = 0; j < runtimeNode.runtimePrimitives.length; j++) {\n      const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n      const primitiveRenderResources = nodeRenderResources.primitiveRenderResources[j];\n      runtimePrimitive.boundingSphere = BoundingSphere.clone(primitiveRenderResources.boundingSphere, new BoundingSphere());\n      const primitivePositionMin = Matrix4.multiplyByPoint(nodeTransform, primitiveRenderResources.positionMin, scratchPrimitivePositionMin);\n      const primitivePositionMax = Matrix4.multiplyByPoint(nodeTransform, primitiveRenderResources.positionMax, scratchPrimitivePositionMax);\n      Cartesian3.minimumByComponent(modelPositionMin, primitivePositionMin, modelPositionMin);\n      Cartesian3.maximumByComponent(modelPositionMax, primitivePositionMax, modelPositionMax);\n    }\n  }\n  this._boundingSphere = BoundingSphere.fromCornerPoints(modelPositionMin, modelPositionMax, new BoundingSphere());\n  this._boundingSphere = BoundingSphere.transformWithoutScale(this._boundingSphere, this._axisCorrectionMatrix, this._boundingSphere);\n  this._boundingSphere = BoundingSphere.transform(this._boundingSphere, this._components.transform, this._boundingSphere);\n  model._boundingSphere = BoundingSphere.transform(this._boundingSphere, model.modelMatrix, model._boundingSphere);\n  model._initialRadius = model._boundingSphere.radius;\n  model._boundingSphere.radius *= model._clampedScale;\n};\n\n/**\n * Creates the draw commands for the primitives in the scene graph.\n *\n * This will traverse the model, nodes and primitives of the scene graph,\n * and create the respective draw commands for the primitives, storing\n * them as the `runtimePrimitive.drawCommand`, respectively.\n *\n * @param {ModelRenderResources} modelRenderResources The model render resources\n *\n * @private\n */\nModelSceneGraph.prototype.createDrawCommands = function (modelRenderResources, frameState) {\n  for (let i = 0; i < this._runtimeNodes.length; i++) {\n    const runtimeNode = this._runtimeNodes[i];\n\n    // If a node in the model was unreachable from the scene graph, there will\n    // be no corresponding runtime node and therefore should be skipped.\n    if (!defined(runtimeNode)) {\n      continue;\n    }\n    const nodeRenderResources = modelRenderResources.nodeRenderResources[i];\n    for (let j = 0; j < runtimeNode.runtimePrimitives.length; j++) {\n      const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n      const primitiveRenderResources = nodeRenderResources.primitiveRenderResources[j];\n      const drawCommand = ModelDrawCommands.buildModelDrawCommand(primitiveRenderResources, frameState);\n      runtimePrimitive.drawCommand = drawCommand;\n    }\n  }\n};\n\n/**\n * Configure the model pipeline stages. If the pipeline needs to be re-run, call\n * this method again to ensure the correct sequence of pipeline stages are\n * used.\n *\n * @param {FrameState} frameState\n * @private\n */\nModelSceneGraph.prototype.configurePipeline = function (frameState) {\n  const modelPipelineStages = this.modelPipelineStages;\n  modelPipelineStages.length = 0;\n  const model = this._model;\n  const fogRenderable = frameState.fog.enabled && frameState.fog.renderable;\n  if (defined(model.color)) {\n    modelPipelineStages.push(ModelColorPipelineStage);\n  }\n\n  // Skip these pipeline stages for classification models.\n  if (defined(model.classificationType)) {\n    return;\n  }\n  if (model.imageBasedLighting.enabled) {\n    modelPipelineStages.push(ImageBasedLightingPipelineStage);\n  }\n  if (model.isClippingEnabled()) {\n    modelPipelineStages.push(ModelClippingPlanesPipelineStage);\n  }\n  if (model.isClippingPolygonsEnabled()) {\n    modelPipelineStages.push(ModelClippingPolygonsPipelineStage);\n  }\n  if (model.hasSilhouette(frameState)) {\n    modelPipelineStages.push(ModelSilhouettePipelineStage);\n  }\n  if (defined(model.splitDirection) && model.splitDirection !== SplitDirection.NONE) {\n    modelPipelineStages.push(ModelSplitterPipelineStage);\n  }\n  if (ModelType.is3DTiles(model.type)) {\n    modelPipelineStages.push(TilesetPipelineStage);\n  }\n  if (fogRenderable) {\n    modelPipelineStages.push(AtmospherePipelineStage);\n  }\n};\nModelSceneGraph.prototype.update = function (frameState, updateForAnimations) {\n  let i, j, k;\n  for (i = 0; i < this._runtimeNodes.length; i++) {\n    const runtimeNode = this._runtimeNodes[i];\n\n    // If a node in the model was unreachable from the scene graph, there will\n    // be no corresponding runtime node and therefore should be skipped.\n    if (!defined(runtimeNode)) {\n      continue;\n    }\n    for (j = 0; j < runtimeNode.updateStages.length; j++) {\n      const nodeUpdateStage = runtimeNode.updateStages[j];\n      nodeUpdateStage.update(runtimeNode, this, frameState);\n    }\n    const disableAnimations = frameState.mode !== SceneMode.SCENE3D && this._model._projectTo2D;\n    if (updateForAnimations && !disableAnimations) {\n      this.updateJointMatrices();\n    }\n    for (j = 0; j < runtimeNode.runtimePrimitives.length; j++) {\n      const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n      for (k = 0; k < runtimePrimitive.updateStages.length; k++) {\n        const stage = runtimePrimitive.updateStages[k];\n        stage.update(runtimePrimitive, this);\n      }\n    }\n  }\n};\nModelSceneGraph.prototype.updateModelMatrix = function (modelMatrix, frameState) {\n  computeModelMatrix(this, modelMatrix);\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    computeModelMatrix2D(this, frameState);\n  }\n\n  // Mark all root nodes as dirty. Any and all children will be\n  // affected recursively in the update stage.\n  const rootNodes = this._rootNodes;\n  for (let i = 0; i < rootNodes.length; i++) {\n    const node = this._runtimeNodes[rootNodes[i]];\n    node._transformDirty = true;\n  }\n};\n\n/**\n * Updates the joint matrices for the skins and nodes of the model.\n *\n * @private\n */\nModelSceneGraph.prototype.updateJointMatrices = function () {\n  const skinnedNodes = this._skinnedNodes;\n  const length = skinnedNodes.length;\n  for (let i = 0; i < length; i++) {\n    const nodeIndex = skinnedNodes[i];\n    const runtimeNode = this._runtimeNodes[nodeIndex];\n    runtimeNode.updateJointMatrices();\n  }\n};\n\n/**\n * A callback to be applied once at each runtime primitive in the\n * scene graph\n * @callback traverseSceneGraphCallback\n *\n * @param {ModelRuntimePrimitive} runtimePrimitive The runtime primitive for the current step of the traversal\n * @param {object} [options] A dictionary of additional options to be passed to the callback, or undefined if the callback does not need any additional information.\n *\n * @private\n */\n\n/**\n * Recursively traverse through the runtime nodes in the scene graph\n * using a post-order depth-first traversal to perform a callback on\n * their runtime primitives.\n *\n * @param {ModelSceneGraph} sceneGraph The scene graph.\n * @param {ModelRuntimeNode} runtimeNode The current runtime node.\n * @param {boolean} visibleNodesOnly Whether to only traverse nodes that are visible.\n * @param {traverseSceneGraphCallback} callback The callback to perform on the runtime primitives of the node.\n * @param {object} [callbackOptions] A dictionary of additional options to be passed to the callback, if needed.\n *\n * @private\n */\nfunction traverseSceneGraph(sceneGraph, runtimeNode, visibleNodesOnly, callback, callbackOptions) {\n  if (visibleNodesOnly && !runtimeNode.show) {\n    return;\n  }\n  const childrenLength = runtimeNode.children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    const childRuntimeNode = runtimeNode.getChild(i);\n    traverseSceneGraph(sceneGraph, childRuntimeNode, visibleNodesOnly, callback, callbackOptions);\n  }\n  const runtimePrimitives = runtimeNode.runtimePrimitives;\n  const runtimePrimitivesLength = runtimePrimitives.length;\n  for (let j = 0; j < runtimePrimitivesLength; j++) {\n    const runtimePrimitive = runtimePrimitives[j];\n    callback(runtimePrimitive, callbackOptions);\n  }\n}\nfunction forEachRuntimePrimitive(sceneGraph, visibleNodesOnly, callback, callbackOptions) {\n  const rootNodes = sceneGraph._rootNodes;\n  const rootNodesLength = rootNodes.length;\n  for (let i = 0; i < rootNodesLength; i++) {\n    const rootNodeIndex = rootNodes[i];\n    const runtimeNode = sceneGraph._runtimeNodes[rootNodeIndex];\n    traverseSceneGraph(sceneGraph, runtimeNode, visibleNodesOnly, callback, callbackOptions);\n  }\n}\nconst scratchBackFaceCullingOptions = {\n  backFaceCulling: undefined\n};\n\n/**\n * Traverses through all draw commands and changes the back-face culling setting.\n *\n * @param {boolean} backFaceCulling The new value for the back-face culling setting.\n *\n * @private\n */\nModelSceneGraph.prototype.updateBackFaceCulling = function (backFaceCulling) {\n  const backFaceCullingOptions = scratchBackFaceCullingOptions;\n  backFaceCullingOptions.backFaceCulling = backFaceCulling;\n  forEachRuntimePrimitive(this, false, updatePrimitiveBackFaceCulling, backFaceCullingOptions);\n};\n\n// Callback is defined here to avoid allocating a closure in the render loop\nfunction updatePrimitiveBackFaceCulling(runtimePrimitive, options) {\n  const drawCommand = runtimePrimitive.drawCommand;\n  drawCommand.backFaceCulling = options.backFaceCulling;\n}\nconst scratchShadowOptions = {\n  shadowMode: undefined\n};\n\n/**\n * Traverses through all draw commands and changes the shadow settings.\n *\n * @param {ShadowMode} shadowMode The new shadow settings.\n *\n * @private\n */\nModelSceneGraph.prototype.updateShadows = function (shadowMode) {\n  const shadowOptions = scratchShadowOptions;\n  shadowOptions.shadowMode = shadowMode;\n  forEachRuntimePrimitive(this, false, updatePrimitiveShadows, shadowOptions);\n};\n\n// Callback is defined here to avoid allocating a closure in the render loop\nfunction updatePrimitiveShadows(runtimePrimitive, options) {\n  const drawCommand = runtimePrimitive.drawCommand;\n  drawCommand.shadows = options.shadowMode;\n}\nconst scratchShowBoundingVolumeOptions = {\n  debugShowBoundingVolume: undefined\n};\n\n/**\n * Traverses through all draw commands and changes whether to show the debug bounding volume.\n *\n * @param {boolean} debugShowBoundingVolume The new value for showing the debug bounding volume.\n *\n * @private\n */\nModelSceneGraph.prototype.updateShowBoundingVolume = function (debugShowBoundingVolume) {\n  const showBoundingVolumeOptions = scratchShowBoundingVolumeOptions;\n  showBoundingVolumeOptions.debugShowBoundingVolume = debugShowBoundingVolume;\n  forEachRuntimePrimitive(this, false, updatePrimitiveShowBoundingVolume, showBoundingVolumeOptions);\n};\n\n// Callback is defined here to avoid allocating a closure in the render loop\nfunction updatePrimitiveShowBoundingVolume(runtimePrimitive, options) {\n  const drawCommand = runtimePrimitive.drawCommand;\n  drawCommand.debugShowBoundingVolume = options.debugShowBoundingVolume;\n}\nconst scratchSilhouetteCommands = [];\nconst scratchPushDrawCommandOptions = {\n  frameState: undefined,\n  hasSilhouette: undefined\n};\n\n/**\n * Traverses through the scene graph and pushes the draw commands associated\n * with each primitive to the frame state's command list.\n *\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nModelSceneGraph.prototype.pushDrawCommands = function (frameState) {\n  // If a model has silhouettes, the commands that draw the silhouettes for\n  // each primitive can only be invoked after the entire model has drawn.\n  // Otherwise, the silhouette may draw on top of the model. This requires\n  // gathering the original commands and the silhouette commands separately.\n  const silhouetteCommands = scratchSilhouetteCommands;\n  silhouetteCommands.length = 0;\n\n  // Since this function is called each frame, the options object is\n  // preallocated in a scratch variable\n  const pushDrawCommandOptions = scratchPushDrawCommandOptions;\n  pushDrawCommandOptions.hasSilhouette = this._model.hasSilhouette(frameState);\n  pushDrawCommandOptions.frameState = frameState;\n  forEachRuntimePrimitive(this, true, pushPrimitiveDrawCommands, pushDrawCommandOptions);\n  addAllToArray(frameState.commandList, silhouetteCommands);\n};\n\n// Callback is defined here to avoid allocating a closure in the render loop\nfunction pushPrimitiveDrawCommands(runtimePrimitive, options) {\n  const frameState = options.frameState;\n  const hasSilhouette = options.hasSilhouette;\n  const passes = frameState.passes;\n  const silhouetteCommands = scratchSilhouetteCommands;\n  const primitiveDrawCommand = runtimePrimitive.drawCommand;\n  primitiveDrawCommand.pushCommands(frameState, frameState.commandList);\n\n  // If a model has silhouettes, the commands that draw the silhouettes for\n  // each primitive can only be invoked after the entire model has drawn.\n  // Otherwise, the silhouette may draw on top of the model. This requires\n  // gathering the original commands and the silhouette commands separately.\n  if (hasSilhouette && !passes.pick) {\n    primitiveDrawCommand.pushSilhouetteCommands(frameState, silhouetteCommands);\n  }\n}\n\n/**\n * Sets the current value of an articulation stage.\n *\n * @param {string} articulationStageKey The name of the articulation, a space, and the name of the stage.\n * @param {number} value The numeric value of this stage of the articulation.\n *\n * @private\n */\nModelSceneGraph.prototype.setArticulationStage = function (articulationStageKey, value) {\n  const names = articulationStageKey.split(\" \");\n  if (names.length !== 2) {\n    return;\n  }\n  const articulationName = names[0];\n  const stageName = names[1];\n  const runtimeArticulation = this._runtimeArticulations[articulationName];\n  if (defined(runtimeArticulation)) {\n    runtimeArticulation.setArticulationStage(stageName, value);\n  }\n};\n\n/**\n * Applies any modified articulation stages to the matrix of each node that participates\n * in any articulation.  Note that this will overwrite any nodeTransformations on participating nodes.\n *\n * @private\n */\nModelSceneGraph.prototype.applyArticulations = function () {\n  const runtimeArticulations = this._runtimeArticulations;\n  for (const articulationName in runtimeArticulations) {\n    if (runtimeArticulations.hasOwnProperty(articulationName)) {\n      const articulation = runtimeArticulations[articulationName];\n      articulation.apply();\n    }\n  }\n};\nexport default ModelSceneGraph;","map":{"version":3,"names":["BoundingSphere","Cartesian3","Check","Frozen","defined","Matrix4","Transforms","SceneMode","SplitDirection","TilesetPipelineStage","AtmospherePipelineStage","ImageBasedLightingPipelineStage","ModelArticulation","ModelColorPipelineStage","ModelClippingPlanesPipelineStage","ModelClippingPolygonsPipelineStage","ModelNode","ModelRuntimeNode","ModelRuntimePrimitive","ModelSkin","ModelUtility","ModelRenderResources","ModelSilhouettePipelineStage","ModelSplitterPipelineStage","ModelType","NodeRenderResources","PrimitiveRenderResources","ModelDrawCommands","addAllToArray","ModelSceneGraph","options","EMPTY_OBJECT","components","modelComponents","typeOf","object","model","_model","_components","_pipelineStages","_updateStages","_runtimeNodes","_rootNodes","_skinnedNodes","_runtimeSkins","modelPipelineStages","_boundingSphere","undefined","_boundingSphere2D","_computedModelMatrix","clone","IDENTITY","_computedModelMatrix2D","_axisCorrectionMatrix","getAxisCorrectionMatrix","upAxis","forwardAxis","_runtimeArticulations","initialize","Object","defineProperties","prototype","get","computedModelMatrix","axisCorrectionMatrix","boundingSphere","sceneGraph","scene","modelMatrix","computeModelMatrix","articulations","articulationsLength","length","runtimeArticulations","i","articulation","runtimeArticulation","name","nodes","nodesLength","Array","rootNodes","rootNodesLength","transformToRoot","rootNode","rootNodeIndex","traverseAndCreateSceneGraph","push","skins","runtimeSkins","skinsLength","skin","skinnedNodes","skinnedNodesLength","skinnedNodeIndex","skinnedNode","skinIndex","index","_runtimeSkin","updateJointMatrices","applyArticulations","multiplyTransformation","transform","multiplyByUniformScale","computedScale","scratchComputedTranslation","computeModelMatrix2D","frameState","translation","getTranslation","equals","ZERO","basisTo2D","mapProjection","center","to2D","ellipsoidTo2DModelMatrix","multiply","node","childrenIndices","getNodeTransform","childrenLength","children","childNode","childNodeTransformToRoot","childIndex","runtimeNode","primitivesLength","primitives","runtimePrimitives","primitive","publicNode","_nodesByName","scratchModelPositionMin","scratchModelPositionMax","scratchPrimitivePositionMin","scratchPrimitivePositionMax","buildDrawCommands","modelRenderResources","buildRenderResources","computeBoundingVolumes","createDrawCommands","statistics","clear","configurePipeline","modelPipelineStage","process","nodePipelineStages","pipelineStages","nodeRenderResources","j","nodePipelineStage","runtimePrimitive","primitivePipelineStages","primitiveRenderResources","k","primitivePipelineStage","modelPositionMin","fromElements","Number","MAX_VALUE","modelPositionMax","nodeTransform","computedTransform","primitivePositionMin","multiplyByPoint","positionMin","primitivePositionMax","positionMax","minimumByComponent","maximumByComponent","fromCornerPoints","transformWithoutScale","_initialRadius","radius","_clampedScale","drawCommand","buildModelDrawCommand","fogRenderable","fog","enabled","renderable","color","classificationType","imageBasedLighting","isClippingEnabled","isClippingPolygonsEnabled","hasSilhouette","splitDirection","NONE","is3DTiles","type","update","updateForAnimations","updateStages","nodeUpdateStage","disableAnimations","mode","SCENE3D","_projectTo2D","stage","updateModelMatrix","_transformDirty","nodeIndex","traverseSceneGraph","visibleNodesOnly","callback","callbackOptions","show","childRuntimeNode","getChild","runtimePrimitivesLength","forEachRuntimePrimitive","scratchBackFaceCullingOptions","backFaceCulling","updateBackFaceCulling","backFaceCullingOptions","updatePrimitiveBackFaceCulling","scratchShadowOptions","shadowMode","updateShadows","shadowOptions","updatePrimitiveShadows","shadows","scratchShowBoundingVolumeOptions","debugShowBoundingVolume","updateShowBoundingVolume","showBoundingVolumeOptions","updatePrimitiveShowBoundingVolume","scratchSilhouetteCommands","scratchPushDrawCommandOptions","pushDrawCommands","silhouetteCommands","pushDrawCommandOptions","pushPrimitiveDrawCommands","commandList","passes","primitiveDrawCommand","pushCommands","pick","pushSilhouetteCommands","setArticulationStage","articulationStageKey","value","names","split","articulationName","stageName","hasOwnProperty","apply"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Model/ModelSceneGraph.js"],"sourcesContent":["import BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport Frozen from \"../../Core/Frozen.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Transforms from \"../../Core/Transforms.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport SplitDirection from \"../SplitDirection.js\";\nimport TilesetPipelineStage from \"./TilesetPipelineStage.js\";\nimport AtmospherePipelineStage from \"./AtmospherePipelineStage.js\";\nimport ImageBasedLightingPipelineStage from \"./ImageBasedLightingPipelineStage.js\";\nimport ModelArticulation from \"./ModelArticulation.js\";\nimport ModelColorPipelineStage from \"./ModelColorPipelineStage.js\";\nimport ModelClippingPlanesPipelineStage from \"./ModelClippingPlanesPipelineStage.js\";\nimport ModelClippingPolygonsPipelineStage from \"./ModelClippingPolygonsPipelineStage.js\";\nimport ModelNode from \"./ModelNode.js\";\nimport ModelRuntimeNode from \"./ModelRuntimeNode.js\";\nimport ModelRuntimePrimitive from \"./ModelRuntimePrimitive.js\";\nimport ModelSkin from \"./ModelSkin.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport ModelRenderResources from \"./ModelRenderResources.js\";\nimport ModelSilhouettePipelineStage from \"./ModelSilhouettePipelineStage.js\";\nimport ModelSplitterPipelineStage from \"./ModelSplitterPipelineStage.js\";\nimport ModelType from \"./ModelType.js\";\nimport NodeRenderResources from \"./NodeRenderResources.js\";\nimport PrimitiveRenderResources from \"./PrimitiveRenderResources.js\";\nimport ModelDrawCommands from \"./ModelDrawCommands.js\";\nimport addAllToArray from \"../../Core/addAllToArray.js\";\n\n/**\n * An in memory representation of the scene graph for a {@link Model}\n *\n * @param {object} options An object containing the following options\n * @param {Model} options.model The model this scene graph belongs to\n * @param {ModelComponents} options.modelComponents The model components describing the model\n *\n * @alias ModelSceneGraph\n * @constructor\n *\n * @private\n */\nfunction ModelSceneGraph(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const components = options.modelComponents;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.model\", options.model);\n  Check.typeOf.object(\"options.modelComponents\", components);\n  //>>includeEnd('debug');\n\n  /**\n   * A reference to the {@link Model} that owns this scene graph.\n   *\n   * @type {Model}\n   * @readonly\n   *\n   * @private\n   */\n  this._model = options.model;\n\n  /**\n   * The model components that represent the contents of the 3D model file.\n   *\n   * @type {ModelComponents}\n   * @readonly\n   *\n   * @private\n   */\n  this._components = components;\n\n  /**\n   * Pipeline stages to apply across the model.\n   *\n   * @type {Object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._pipelineStages = [];\n\n  /**\n   * Update stages to apply across the model.\n   *\n   * @type {Object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._updateStages = [];\n\n  /**\n   * The runtime nodes that make up the scene graph\n   *\n   * @type {ModelRuntimeNode[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._runtimeNodes = [];\n\n  /**\n   * The indices of the root nodes in the runtime nodes array.\n   *\n   * @type {number[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._rootNodes = [];\n\n  /**\n   * The indices of the skinned nodes in the runtime nodes array. These refer\n   * to the nodes that will be manipulated by their skin, as opposed to the nodes\n   * acting as joints for the skin.\n   *\n   * @type {number[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._skinnedNodes = [];\n\n  /**\n   * The runtime skins that affect nodes in the scene graph.\n   *\n   * @type {ModelSkin[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._runtimeSkins = [];\n\n  /**\n   * Pipeline stages to apply to this model. This\n   * is an array of classes, each with a static method called\n   * <code>process()</code>\n   *\n   * @type {Object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.modelPipelineStages = [];\n\n  // The scene graph's bounding sphere is model space, so that\n  // the model's bounding sphere can be recomputed when given a\n  // new model matrix.\n  this._boundingSphere = undefined;\n\n  // The 2D bounding sphere is in world space. This is checked\n  // by the draw commands to see if the model is over the IDL,\n  // and if so, renders the primitives using extra commands.\n  this._boundingSphere2D = undefined;\n\n  this._computedModelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._computedModelMatrix2D = Matrix4.clone(Matrix4.IDENTITY);\n\n  this._axisCorrectionMatrix = ModelUtility.getAxisCorrectionMatrix(\n    components.upAxis,\n    components.forwardAxis,\n    new Matrix4(),\n  );\n\n  // Store articulations from the AGI_articulations extension\n  // by name in a dictionary for easy retrieval.\n  this._runtimeArticulations = {};\n\n  initialize(this);\n}\n\nObject.defineProperties(ModelSceneGraph.prototype, {\n  /**\n   * The model components this scene graph represents.\n   *\n   * @type {ModelComponents}\n   * @readonly\n   *\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    },\n  },\n\n  /**\n   * The axis-corrected model matrix.\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @private\n   */\n  computedModelMatrix: {\n    get: function () {\n      return this._computedModelMatrix;\n    },\n  },\n\n  /**\n   * A matrix to correct from y-up in some model formats (e.g. glTF) to the\n   * z-up coordinate system Cesium uses.\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @private\n   */\n  axisCorrectionMatrix: {\n    get: function () {\n      return this._axisCorrectionMatrix;\n    },\n  },\n\n  /**\n   * The bounding sphere containing all the primitives in the scene graph\n   * in model space.\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   *\n   * @private\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    },\n  },\n});\n\nfunction initialize(sceneGraph) {\n  const components = sceneGraph._components;\n  const scene = components.scene;\n  const model = sceneGraph._model;\n\n  // If the model has a height reference that modifies the model matrix,\n  // it will be accounted for in updateModelMatrix.\n  const modelMatrix = model.modelMatrix;\n  computeModelMatrix(sceneGraph, modelMatrix);\n\n  const articulations = components.articulations;\n  const articulationsLength = articulations.length;\n\n  const runtimeArticulations = sceneGraph._runtimeArticulations;\n  for (let i = 0; i < articulationsLength; i++) {\n    const articulation = articulations[i];\n    const runtimeArticulation = new ModelArticulation({\n      articulation: articulation,\n      sceneGraph: sceneGraph,\n    });\n\n    const name = runtimeArticulation.name;\n    runtimeArticulations[name] = runtimeArticulation;\n  }\n\n  const nodes = components.nodes;\n  const nodesLength = nodes.length;\n\n  // Initialize this array to be the same size as the nodes array in\n  // the model file. This is so the node indices remain the same. However,\n  // only nodes reachable from the scene's root node will be populated, the\n  // rest will be undefined\n  sceneGraph._runtimeNodes = new Array(nodesLength);\n\n  const rootNodes = scene.nodes;\n  const rootNodesLength = rootNodes.length;\n  const transformToRoot = Matrix4.IDENTITY;\n  for (let i = 0; i < rootNodesLength; i++) {\n    const rootNode = scene.nodes[i];\n\n    const rootNodeIndex = traverseAndCreateSceneGraph(\n      sceneGraph,\n      rootNode,\n      transformToRoot,\n    );\n\n    sceneGraph._rootNodes.push(rootNodeIndex);\n  }\n\n  // Handle skins after all runtime nodes are created\n  const skins = components.skins;\n  const runtimeSkins = sceneGraph._runtimeSkins;\n\n  const skinsLength = skins.length;\n  for (let i = 0; i < skinsLength; i++) {\n    const skin = skins[i];\n    runtimeSkins.push(\n      new ModelSkin({\n        skin: skin,\n        sceneGraph: sceneGraph,\n      }),\n    );\n  }\n\n  const skinnedNodes = sceneGraph._skinnedNodes;\n  const skinnedNodesLength = skinnedNodes.length;\n  for (let i = 0; i < skinnedNodesLength; i++) {\n    const skinnedNodeIndex = skinnedNodes[i];\n    const skinnedNode = sceneGraph._runtimeNodes[skinnedNodeIndex];\n\n    // Use the index of the skin in the model components to find\n    // the corresponding runtime skin.\n    const skin = nodes[skinnedNodeIndex].skin;\n    const skinIndex = skin.index;\n\n    skinnedNode._runtimeSkin = runtimeSkins[skinIndex];\n    skinnedNode.updateJointMatrices();\n  }\n\n  // Ensure articulations are applied with their initial values to their target nodes.\n  sceneGraph.applyArticulations();\n}\n\nfunction computeModelMatrix(sceneGraph, modelMatrix) {\n  const components = sceneGraph._components;\n  const model = sceneGraph._model;\n\n  sceneGraph._computedModelMatrix = Matrix4.multiplyTransformation(\n    modelMatrix,\n    components.transform,\n    sceneGraph._computedModelMatrix,\n  );\n\n  sceneGraph._computedModelMatrix = Matrix4.multiplyTransformation(\n    sceneGraph._computedModelMatrix,\n    sceneGraph._axisCorrectionMatrix,\n    sceneGraph._computedModelMatrix,\n  );\n\n  sceneGraph._computedModelMatrix = Matrix4.multiplyByUniformScale(\n    sceneGraph._computedModelMatrix,\n    model.computedScale,\n    sceneGraph._computedModelMatrix,\n  );\n}\n\nconst scratchComputedTranslation = new Cartesian3();\n\nfunction computeModelMatrix2D(sceneGraph, frameState) {\n  const computedModelMatrix = sceneGraph._computedModelMatrix;\n  const translation = Matrix4.getTranslation(\n    computedModelMatrix,\n    scratchComputedTranslation,\n  );\n\n  if (!Cartesian3.equals(translation, Cartesian3.ZERO)) {\n    sceneGraph._computedModelMatrix2D = Transforms.basisTo2D(\n      frameState.mapProjection,\n      computedModelMatrix,\n      sceneGraph._computedModelMatrix2D,\n    );\n  } else {\n    const center = sceneGraph.boundingSphere.center;\n    const to2D = Transforms.ellipsoidTo2DModelMatrix(\n      frameState.mapProjection,\n      center,\n      sceneGraph._computedModelMatrix2D,\n    );\n    sceneGraph._computedModelMatrix2D = Matrix4.multiply(\n      to2D,\n      computedModelMatrix,\n      sceneGraph._computedModelMatrix2D,\n    );\n  }\n\n  sceneGraph._boundingSphere2D = BoundingSphere.transform(\n    sceneGraph._boundingSphere,\n    sceneGraph._computedModelMatrix2D,\n    sceneGraph._boundingSphere2D,\n  );\n}\n\n/**\n * Recursively traverse through the nodes in the scene graph to create\n * their runtime versions, using a post-order depth-first traversal.\n *\n * @param {ModelSceneGraph} sceneGraph The scene graph\n * @param {ModelComponents.Node} node The current node\n * @param {Matrix4} transformToRoot The transforms of this node's ancestors.\n * @returns {number} The index of this node in the runtimeNodes array.\n *\n * @private\n */\nfunction traverseAndCreateSceneGraph(sceneGraph, node, transformToRoot) {\n  // The indices of the children of this node in the runtimeNodes array.\n  const childrenIndices = [];\n  const transform = ModelUtility.getNodeTransform(node);\n\n  // Traverse through scene graph.\n  const childrenLength = node.children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    const childNode = node.children[i];\n    const childNodeTransformToRoot = Matrix4.multiplyTransformation(\n      transformToRoot,\n      transform,\n      new Matrix4(),\n    );\n\n    const childIndex = traverseAndCreateSceneGraph(\n      sceneGraph,\n      childNode,\n      childNodeTransformToRoot,\n    );\n    childrenIndices.push(childIndex);\n  }\n\n  // Process node and mesh primitives.\n  const runtimeNode = new ModelRuntimeNode({\n    node: node,\n    transform: transform,\n    transformToRoot: transformToRoot,\n    children: childrenIndices,\n    sceneGraph: sceneGraph,\n  });\n\n  const primitivesLength = node.primitives.length;\n  for (let i = 0; i < primitivesLength; i++) {\n    runtimeNode.runtimePrimitives.push(\n      new ModelRuntimePrimitive({\n        primitive: node.primitives[i],\n        node: node,\n        model: sceneGraph._model,\n      }),\n    );\n  }\n\n  const index = node.index;\n  sceneGraph._runtimeNodes[index] = runtimeNode;\n  if (defined(node.skin)) {\n    sceneGraph._skinnedNodes.push(index);\n  }\n\n  // Create and store the public version of the runtime node.\n  const name = node.name;\n  if (defined(name)) {\n    const model = sceneGraph._model;\n    const publicNode = new ModelNode(model, runtimeNode);\n    model._nodesByName[name] = publicNode;\n  }\n\n  return index;\n}\n\nconst scratchModelPositionMin = new Cartesian3();\nconst scratchModelPositionMax = new Cartesian3();\nconst scratchPrimitivePositionMin = new Cartesian3();\nconst scratchPrimitivePositionMax = new Cartesian3();\n\n/**\n * Generates the {@link ModelDrawCommand} for each primitive in the model.\n * If the model is used for classification, a {@link ClassificationModelDrawCommand}\n * is generated for each primitive instead.\n *\n * @param {FrameState} frameState The current frame state. This is needed to\n * allocate GPU resources as needed.\n *\n * @private\n */\nModelSceneGraph.prototype.buildDrawCommands = function (frameState) {\n  const modelRenderResources = this.buildRenderResources(frameState);\n  this.computeBoundingVolumes(modelRenderResources);\n  this.createDrawCommands(modelRenderResources, frameState);\n};\n\n/**\n * Generates the {@link ModelRenderResources} for the model.\n *\n * This will traverse the model, nodes and primitives of the scene graph,\n * and perform the following tasks:\n *\n * - configure the pipeline stages by calling `configurePipeline`,\n *   `runtimeNode.configurePipeline`, and `runtimePrimitive.configurePipeline`\n * - create the `ModelRenderResources`, `NodeRenderResources`, and\n *   `PrimitiveRenderResources`\n * - Process the render resources with the respective pipelines\n *\n * @param {FrameState} frameState The current frame state. This is needed to\n * allocate GPU resources as needed.\n * @returns {ModelRenderResources} The model render resources\n *\n * @private\n */\nModelSceneGraph.prototype.buildRenderResources = function (frameState) {\n  const model = this._model;\n  const modelRenderResources = new ModelRenderResources(model);\n\n  // Reset the memory counts before running the pipeline\n  model.statistics.clear();\n\n  this.configurePipeline(frameState);\n  const modelPipelineStages = this.modelPipelineStages;\n\n  for (let i = 0; i < modelPipelineStages.length; i++) {\n    const modelPipelineStage = modelPipelineStages[i];\n    modelPipelineStage.process(modelRenderResources, model, frameState);\n  }\n\n  for (let i = 0; i < this._runtimeNodes.length; i++) {\n    const runtimeNode = this._runtimeNodes[i];\n\n    // If a node in the model was unreachable from the scene graph, there will\n    // be no corresponding runtime node and therefore should be skipped.\n    if (!defined(runtimeNode)) {\n      continue;\n    }\n\n    runtimeNode.configurePipeline();\n    const nodePipelineStages = runtimeNode.pipelineStages;\n\n    const nodeRenderResources = new NodeRenderResources(\n      modelRenderResources,\n      runtimeNode,\n    );\n    modelRenderResources.nodeRenderResources[i] = nodeRenderResources;\n\n    for (let j = 0; j < nodePipelineStages.length; j++) {\n      const nodePipelineStage = nodePipelineStages[j];\n\n      nodePipelineStage.process(\n        nodeRenderResources,\n        runtimeNode.node,\n        frameState,\n      );\n    }\n\n    for (let j = 0; j < runtimeNode.runtimePrimitives.length; j++) {\n      const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n\n      runtimePrimitive.configurePipeline(frameState);\n      const primitivePipelineStages = runtimePrimitive.pipelineStages;\n\n      const primitiveRenderResources = new PrimitiveRenderResources(\n        nodeRenderResources,\n        runtimePrimitive,\n      );\n      nodeRenderResources.primitiveRenderResources[j] =\n        primitiveRenderResources;\n\n      for (let k = 0; k < primitivePipelineStages.length; k++) {\n        const primitivePipelineStage = primitivePipelineStages[k];\n        primitivePipelineStage.process(\n          primitiveRenderResources,\n          runtimePrimitive.primitive,\n          frameState,\n        );\n      }\n    }\n  }\n  return modelRenderResources;\n};\n\n/**\n * Computes the bounding volumes for the scene graph and the model.\n *\n * This will traverse the model, nodes and primitives of the scene graph,\n * and compute the bounding volumes. Specifically, it will compute\n *\n * - this._boundingSphere\n * - model._boundingSphere\n *\n * With the latter being modified as of\n *\n * - model._initialRadius = model._boundingSphere.radius;\n * - model._boundingSphere.radius *= model._clampedScale;\n *\n * NOTE: This contains some bugs. See https://github.com/CesiumGS/cesium/issues/12108\n *\n * @param {ModelRenderResources} modelRenderResources The model render resources\n *\n * @private\n */\nModelSceneGraph.prototype.computeBoundingVolumes = function (\n  modelRenderResources,\n) {\n  const model = this._model;\n\n  const modelPositionMin = Cartesian3.fromElements(\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n    scratchModelPositionMin,\n  );\n  const modelPositionMax = Cartesian3.fromElements(\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n    scratchModelPositionMax,\n  );\n\n  for (let i = 0; i < this._runtimeNodes.length; i++) {\n    const runtimeNode = this._runtimeNodes[i];\n\n    // If a node in the model was unreachable from the scene graph, there will\n    // be no corresponding runtime node and therefore should be skipped.\n    if (!defined(runtimeNode)) {\n      continue;\n    }\n\n    const nodeRenderResources = modelRenderResources.nodeRenderResources[i];\n    const nodeTransform = runtimeNode.computedTransform;\n    for (let j = 0; j < runtimeNode.runtimePrimitives.length; j++) {\n      const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n\n      const primitiveRenderResources =\n        nodeRenderResources.primitiveRenderResources[j];\n\n      runtimePrimitive.boundingSphere = BoundingSphere.clone(\n        primitiveRenderResources.boundingSphere,\n        new BoundingSphere(),\n      );\n\n      const primitivePositionMin = Matrix4.multiplyByPoint(\n        nodeTransform,\n        primitiveRenderResources.positionMin,\n        scratchPrimitivePositionMin,\n      );\n      const primitivePositionMax = Matrix4.multiplyByPoint(\n        nodeTransform,\n        primitiveRenderResources.positionMax,\n        scratchPrimitivePositionMax,\n      );\n\n      Cartesian3.minimumByComponent(\n        modelPositionMin,\n        primitivePositionMin,\n        modelPositionMin,\n      );\n      Cartesian3.maximumByComponent(\n        modelPositionMax,\n        primitivePositionMax,\n        modelPositionMax,\n      );\n    }\n  }\n\n  this._boundingSphere = BoundingSphere.fromCornerPoints(\n    modelPositionMin,\n    modelPositionMax,\n    new BoundingSphere(),\n  );\n\n  this._boundingSphere = BoundingSphere.transformWithoutScale(\n    this._boundingSphere,\n    this._axisCorrectionMatrix,\n    this._boundingSphere,\n  );\n\n  this._boundingSphere = BoundingSphere.transform(\n    this._boundingSphere,\n    this._components.transform,\n    this._boundingSphere,\n  );\n\n  model._boundingSphere = BoundingSphere.transform(\n    this._boundingSphere,\n    model.modelMatrix,\n    model._boundingSphere,\n  );\n\n  model._initialRadius = model._boundingSphere.radius;\n  model._boundingSphere.radius *= model._clampedScale;\n};\n\n/**\n * Creates the draw commands for the primitives in the scene graph.\n *\n * This will traverse the model, nodes and primitives of the scene graph,\n * and create the respective draw commands for the primitives, storing\n * them as the `runtimePrimitive.drawCommand`, respectively.\n *\n * @param {ModelRenderResources} modelRenderResources The model render resources\n *\n * @private\n */\nModelSceneGraph.prototype.createDrawCommands = function (\n  modelRenderResources,\n  frameState,\n) {\n  for (let i = 0; i < this._runtimeNodes.length; i++) {\n    const runtimeNode = this._runtimeNodes[i];\n\n    // If a node in the model was unreachable from the scene graph, there will\n    // be no corresponding runtime node and therefore should be skipped.\n    if (!defined(runtimeNode)) {\n      continue;\n    }\n\n    const nodeRenderResources = modelRenderResources.nodeRenderResources[i];\n\n    for (let j = 0; j < runtimeNode.runtimePrimitives.length; j++) {\n      const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n\n      const primitiveRenderResources =\n        nodeRenderResources.primitiveRenderResources[j];\n\n      const drawCommand = ModelDrawCommands.buildModelDrawCommand(\n        primitiveRenderResources,\n        frameState,\n      );\n      runtimePrimitive.drawCommand = drawCommand;\n    }\n  }\n};\n\n/**\n * Configure the model pipeline stages. If the pipeline needs to be re-run, call\n * this method again to ensure the correct sequence of pipeline stages are\n * used.\n *\n * @param {FrameState} frameState\n * @private\n */\nModelSceneGraph.prototype.configurePipeline = function (frameState) {\n  const modelPipelineStages = this.modelPipelineStages;\n  modelPipelineStages.length = 0;\n\n  const model = this._model;\n  const fogRenderable = frameState.fog.enabled && frameState.fog.renderable;\n\n  if (defined(model.color)) {\n    modelPipelineStages.push(ModelColorPipelineStage);\n  }\n\n  // Skip these pipeline stages for classification models.\n  if (defined(model.classificationType)) {\n    return;\n  }\n\n  if (model.imageBasedLighting.enabled) {\n    modelPipelineStages.push(ImageBasedLightingPipelineStage);\n  }\n\n  if (model.isClippingEnabled()) {\n    modelPipelineStages.push(ModelClippingPlanesPipelineStage);\n  }\n\n  if (model.isClippingPolygonsEnabled()) {\n    modelPipelineStages.push(ModelClippingPolygonsPipelineStage);\n  }\n\n  if (model.hasSilhouette(frameState)) {\n    modelPipelineStages.push(ModelSilhouettePipelineStage);\n  }\n\n  if (\n    defined(model.splitDirection) &&\n    model.splitDirection !== SplitDirection.NONE\n  ) {\n    modelPipelineStages.push(ModelSplitterPipelineStage);\n  }\n\n  if (ModelType.is3DTiles(model.type)) {\n    modelPipelineStages.push(TilesetPipelineStage);\n  }\n\n  if (fogRenderable) {\n    modelPipelineStages.push(AtmospherePipelineStage);\n  }\n};\n\nModelSceneGraph.prototype.update = function (frameState, updateForAnimations) {\n  let i, j, k;\n\n  for (i = 0; i < this._runtimeNodes.length; i++) {\n    const runtimeNode = this._runtimeNodes[i];\n\n    // If a node in the model was unreachable from the scene graph, there will\n    // be no corresponding runtime node and therefore should be skipped.\n    if (!defined(runtimeNode)) {\n      continue;\n    }\n\n    for (j = 0; j < runtimeNode.updateStages.length; j++) {\n      const nodeUpdateStage = runtimeNode.updateStages[j];\n      nodeUpdateStage.update(runtimeNode, this, frameState);\n    }\n\n    const disableAnimations =\n      frameState.mode !== SceneMode.SCENE3D && this._model._projectTo2D;\n    if (updateForAnimations && !disableAnimations) {\n      this.updateJointMatrices();\n    }\n\n    for (j = 0; j < runtimeNode.runtimePrimitives.length; j++) {\n      const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n      for (k = 0; k < runtimePrimitive.updateStages.length; k++) {\n        const stage = runtimePrimitive.updateStages[k];\n        stage.update(runtimePrimitive, this);\n      }\n    }\n  }\n};\n\nModelSceneGraph.prototype.updateModelMatrix = function (\n  modelMatrix,\n  frameState,\n) {\n  computeModelMatrix(this, modelMatrix);\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    computeModelMatrix2D(this, frameState);\n  }\n\n  // Mark all root nodes as dirty. Any and all children will be\n  // affected recursively in the update stage.\n  const rootNodes = this._rootNodes;\n  for (let i = 0; i < rootNodes.length; i++) {\n    const node = this._runtimeNodes[rootNodes[i]];\n    node._transformDirty = true;\n  }\n};\n\n/**\n * Updates the joint matrices for the skins and nodes of the model.\n *\n * @private\n */\nModelSceneGraph.prototype.updateJointMatrices = function () {\n  const skinnedNodes = this._skinnedNodes;\n  const length = skinnedNodes.length;\n\n  for (let i = 0; i < length; i++) {\n    const nodeIndex = skinnedNodes[i];\n    const runtimeNode = this._runtimeNodes[nodeIndex];\n    runtimeNode.updateJointMatrices();\n  }\n};\n\n/**\n * A callback to be applied once at each runtime primitive in the\n * scene graph\n * @callback traverseSceneGraphCallback\n *\n * @param {ModelRuntimePrimitive} runtimePrimitive The runtime primitive for the current step of the traversal\n * @param {object} [options] A dictionary of additional options to be passed to the callback, or undefined if the callback does not need any additional information.\n *\n * @private\n */\n\n/**\n * Recursively traverse through the runtime nodes in the scene graph\n * using a post-order depth-first traversal to perform a callback on\n * their runtime primitives.\n *\n * @param {ModelSceneGraph} sceneGraph The scene graph.\n * @param {ModelRuntimeNode} runtimeNode The current runtime node.\n * @param {boolean} visibleNodesOnly Whether to only traverse nodes that are visible.\n * @param {traverseSceneGraphCallback} callback The callback to perform on the runtime primitives of the node.\n * @param {object} [callbackOptions] A dictionary of additional options to be passed to the callback, if needed.\n *\n * @private\n */\nfunction traverseSceneGraph(\n  sceneGraph,\n  runtimeNode,\n  visibleNodesOnly,\n  callback,\n  callbackOptions,\n) {\n  if (visibleNodesOnly && !runtimeNode.show) {\n    return;\n  }\n\n  const childrenLength = runtimeNode.children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    const childRuntimeNode = runtimeNode.getChild(i);\n    traverseSceneGraph(\n      sceneGraph,\n      childRuntimeNode,\n      visibleNodesOnly,\n      callback,\n      callbackOptions,\n    );\n  }\n\n  const runtimePrimitives = runtimeNode.runtimePrimitives;\n  const runtimePrimitivesLength = runtimePrimitives.length;\n  for (let j = 0; j < runtimePrimitivesLength; j++) {\n    const runtimePrimitive = runtimePrimitives[j];\n    callback(runtimePrimitive, callbackOptions);\n  }\n}\n\nfunction forEachRuntimePrimitive(\n  sceneGraph,\n  visibleNodesOnly,\n  callback,\n  callbackOptions,\n) {\n  const rootNodes = sceneGraph._rootNodes;\n  const rootNodesLength = rootNodes.length;\n  for (let i = 0; i < rootNodesLength; i++) {\n    const rootNodeIndex = rootNodes[i];\n    const runtimeNode = sceneGraph._runtimeNodes[rootNodeIndex];\n    traverseSceneGraph(\n      sceneGraph,\n      runtimeNode,\n      visibleNodesOnly,\n      callback,\n      callbackOptions,\n    );\n  }\n}\n\nconst scratchBackFaceCullingOptions = {\n  backFaceCulling: undefined,\n};\n\n/**\n * Traverses through all draw commands and changes the back-face culling setting.\n *\n * @param {boolean} backFaceCulling The new value for the back-face culling setting.\n *\n * @private\n */\nModelSceneGraph.prototype.updateBackFaceCulling = function (backFaceCulling) {\n  const backFaceCullingOptions = scratchBackFaceCullingOptions;\n  backFaceCullingOptions.backFaceCulling = backFaceCulling;\n  forEachRuntimePrimitive(\n    this,\n    false,\n    updatePrimitiveBackFaceCulling,\n    backFaceCullingOptions,\n  );\n};\n\n// Callback is defined here to avoid allocating a closure in the render loop\nfunction updatePrimitiveBackFaceCulling(runtimePrimitive, options) {\n  const drawCommand = runtimePrimitive.drawCommand;\n  drawCommand.backFaceCulling = options.backFaceCulling;\n}\n\nconst scratchShadowOptions = {\n  shadowMode: undefined,\n};\n\n/**\n * Traverses through all draw commands and changes the shadow settings.\n *\n * @param {ShadowMode} shadowMode The new shadow settings.\n *\n * @private\n */\nModelSceneGraph.prototype.updateShadows = function (shadowMode) {\n  const shadowOptions = scratchShadowOptions;\n  shadowOptions.shadowMode = shadowMode;\n  forEachRuntimePrimitive(this, false, updatePrimitiveShadows, shadowOptions);\n};\n\n// Callback is defined here to avoid allocating a closure in the render loop\nfunction updatePrimitiveShadows(runtimePrimitive, options) {\n  const drawCommand = runtimePrimitive.drawCommand;\n  drawCommand.shadows = options.shadowMode;\n}\n\nconst scratchShowBoundingVolumeOptions = {\n  debugShowBoundingVolume: undefined,\n};\n\n/**\n * Traverses through all draw commands and changes whether to show the debug bounding volume.\n *\n * @param {boolean} debugShowBoundingVolume The new value for showing the debug bounding volume.\n *\n * @private\n */\nModelSceneGraph.prototype.updateShowBoundingVolume = function (\n  debugShowBoundingVolume,\n) {\n  const showBoundingVolumeOptions = scratchShowBoundingVolumeOptions;\n  showBoundingVolumeOptions.debugShowBoundingVolume = debugShowBoundingVolume;\n\n  forEachRuntimePrimitive(\n    this,\n    false,\n    updatePrimitiveShowBoundingVolume,\n    showBoundingVolumeOptions,\n  );\n};\n\n// Callback is defined here to avoid allocating a closure in the render loop\nfunction updatePrimitiveShowBoundingVolume(runtimePrimitive, options) {\n  const drawCommand = runtimePrimitive.drawCommand;\n  drawCommand.debugShowBoundingVolume = options.debugShowBoundingVolume;\n}\n\nconst scratchSilhouetteCommands = [];\nconst scratchPushDrawCommandOptions = {\n  frameState: undefined,\n  hasSilhouette: undefined,\n};\n\n/**\n * Traverses through the scene graph and pushes the draw commands associated\n * with each primitive to the frame state's command list.\n *\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nModelSceneGraph.prototype.pushDrawCommands = function (frameState) {\n  // If a model has silhouettes, the commands that draw the silhouettes for\n  // each primitive can only be invoked after the entire model has drawn.\n  // Otherwise, the silhouette may draw on top of the model. This requires\n  // gathering the original commands and the silhouette commands separately.\n  const silhouetteCommands = scratchSilhouetteCommands;\n  silhouetteCommands.length = 0;\n\n  // Since this function is called each frame, the options object is\n  // preallocated in a scratch variable\n  const pushDrawCommandOptions = scratchPushDrawCommandOptions;\n  pushDrawCommandOptions.hasSilhouette = this._model.hasSilhouette(frameState);\n  pushDrawCommandOptions.frameState = frameState;\n\n  forEachRuntimePrimitive(\n    this,\n    true,\n    pushPrimitiveDrawCommands,\n    pushDrawCommandOptions,\n  );\n\n  addAllToArray(frameState.commandList, silhouetteCommands);\n};\n\n// Callback is defined here to avoid allocating a closure in the render loop\nfunction pushPrimitiveDrawCommands(runtimePrimitive, options) {\n  const frameState = options.frameState;\n  const hasSilhouette = options.hasSilhouette;\n\n  const passes = frameState.passes;\n  const silhouetteCommands = scratchSilhouetteCommands;\n  const primitiveDrawCommand = runtimePrimitive.drawCommand;\n  primitiveDrawCommand.pushCommands(frameState, frameState.commandList);\n\n  // If a model has silhouettes, the commands that draw the silhouettes for\n  // each primitive can only be invoked after the entire model has drawn.\n  // Otherwise, the silhouette may draw on top of the model. This requires\n  // gathering the original commands and the silhouette commands separately.\n  if (hasSilhouette && !passes.pick) {\n    primitiveDrawCommand.pushSilhouetteCommands(frameState, silhouetteCommands);\n  }\n}\n\n/**\n * Sets the current value of an articulation stage.\n *\n * @param {string} articulationStageKey The name of the articulation, a space, and the name of the stage.\n * @param {number} value The numeric value of this stage of the articulation.\n *\n * @private\n */\nModelSceneGraph.prototype.setArticulationStage = function (\n  articulationStageKey,\n  value,\n) {\n  const names = articulationStageKey.split(\" \");\n  if (names.length !== 2) {\n    return;\n  }\n\n  const articulationName = names[0];\n  const stageName = names[1];\n\n  const runtimeArticulation = this._runtimeArticulations[articulationName];\n  if (defined(runtimeArticulation)) {\n    runtimeArticulation.setArticulationStage(stageName, value);\n  }\n};\n\n/**\n * Applies any modified articulation stages to the matrix of each node that participates\n * in any articulation.  Note that this will overwrite any nodeTransformations on participating nodes.\n *\n * @private\n */\nModelSceneGraph.prototype.applyArticulations = function () {\n  const runtimeArticulations = this._runtimeArticulations;\n  for (const articulationName in runtimeArticulations) {\n    if (runtimeArticulations.hasOwnProperty(articulationName)) {\n      const articulation = runtimeArticulations[articulationName];\n      articulation.apply();\n    }\n  }\n};\n\nexport default ModelSceneGraph;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}