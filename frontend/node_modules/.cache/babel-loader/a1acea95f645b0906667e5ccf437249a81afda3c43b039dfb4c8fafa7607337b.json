{"ast":null,"code":"import PointCloudEyeDomeLighting from \"./PointCloudEyeDomeLighting.js\";\n\n/**\n * Options for performing point attenuation based on geometric error when rendering\n * point clouds using 3D Tiles.\n *\n * @param {object} [options] Object with the following properties:\n * @param {boolean} [options.attenuation=false] Perform point attenuation based on geometric error.\n * @param {number} [options.geometricErrorScale=1.0] Scale to be applied to each tile's geometric error.\n * @param {number} [options.maximumAttenuation] Maximum attenuation in pixels. Defaults to the Cesium3DTileset's maximumScreenSpaceError.\n * @param {number} [options.baseResolution] Average base resolution for the dataset in meters. Substitute for Geometric Error when not available.\n * @param {boolean} [options.eyeDomeLighting=true] When true, use eye dome lighting when drawing with point attenuation.\n * @param {number} [options.eyeDomeLightingStrength=1.0] Increasing this value increases contrast on slopes and edges.\n * @param {number} [options.eyeDomeLightingRadius=1.0] Increase the thickness of contours from eye dome lighting.\n * @param {boolean} [options.backFaceCulling=false] Determines whether back-facing points are hidden. This option works only if data has normals included.\n * @param {boolean} [options.normalShading=true] Determines whether a point cloud that contains normals is shaded by the scene's light source.\n *\n * @alias PointCloudShading\n * @constructor\n */\nfunction PointCloudShading(options) {\n  const pointCloudShading = options ?? {};\n\n  /**\n   * Perform point attenuation based on geometric error.\n   * @type {boolean}\n   * @default false\n   */\n  this.attenuation = pointCloudShading.attenuation ?? false;\n\n  /**\n   * Scale to be applied to the geometric error before computing attenuation.\n   * @type {number}\n   * @default 1.0\n   */\n  this.geometricErrorScale = pointCloudShading.geometricErrorScale ?? 1.0;\n\n  /**\n   * Maximum point attenuation in pixels. If undefined, the Cesium3DTileset's maximumScreenSpaceError will be used.\n   * @type {number}\n   */\n  this.maximumAttenuation = pointCloudShading.maximumAttenuation;\n\n  /**\n   * Average base resolution for the dataset in meters.\n   * Used in place of geometric error when geometric error is 0.\n   * If undefined, an approximation will be computed for each tile that has geometric error of 0.\n   * @type {number}\n   */\n  this.baseResolution = pointCloudShading.baseResolution;\n\n  /**\n   * Use eye dome lighting when drawing with point attenuation\n   * Requires support for EXT_frag_depth, OES_texture_float, and WEBGL_draw_buffers extensions in WebGL 1.0,\n   * otherwise eye dome lighting is ignored.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.eyeDomeLighting = pointCloudShading.eyeDomeLighting ?? true;\n\n  /**\n   * Eye dome lighting strength (apparent contrast)\n   * @type {number}\n   * @default 1.0\n   */\n  this.eyeDomeLightingStrength = pointCloudShading.eyeDomeLightingStrength ?? 1.0;\n\n  /**\n   * Thickness of contours from eye dome lighting\n   * @type {number}\n   * @default 1.0\n   */\n  this.eyeDomeLightingRadius = pointCloudShading.eyeDomeLightingRadius ?? 1.0;\n\n  /**\n   * Determines whether back-facing points are hidden.\n   * This option works only if data has normals included.\n   *\n   * @type {boolean}\n   * @default false\n   */\n  this.backFaceCulling = pointCloudShading.backFaceCulling ?? false;\n\n  /**\n   * Determines whether a point cloud that contains normals is shaded by the scene's light source.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.normalShading = pointCloudShading.normalShading ?? true;\n}\n\n/**\n * Determines if point cloud shading is supported.\n *\n * @param {Scene} scene The scene.\n * @returns {boolean} <code>true</code> if point cloud shading is supported; otherwise, returns <code>false</code>\n */\nPointCloudShading.isSupported = function (scene) {\n  return PointCloudEyeDomeLighting.isSupported(scene.context);\n};\nexport default PointCloudShading;","map":{"version":3,"names":["PointCloudEyeDomeLighting","PointCloudShading","options","pointCloudShading","attenuation","geometricErrorScale","maximumAttenuation","baseResolution","eyeDomeLighting","eyeDomeLightingStrength","eyeDomeLightingRadius","backFaceCulling","normalShading","isSupported","scene","context"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/PointCloudShading.js"],"sourcesContent":["import PointCloudEyeDomeLighting from \"./PointCloudEyeDomeLighting.js\";\n\n/**\n * Options for performing point attenuation based on geometric error when rendering\n * point clouds using 3D Tiles.\n *\n * @param {object} [options] Object with the following properties:\n * @param {boolean} [options.attenuation=false] Perform point attenuation based on geometric error.\n * @param {number} [options.geometricErrorScale=1.0] Scale to be applied to each tile's geometric error.\n * @param {number} [options.maximumAttenuation] Maximum attenuation in pixels. Defaults to the Cesium3DTileset's maximumScreenSpaceError.\n * @param {number} [options.baseResolution] Average base resolution for the dataset in meters. Substitute for Geometric Error when not available.\n * @param {boolean} [options.eyeDomeLighting=true] When true, use eye dome lighting when drawing with point attenuation.\n * @param {number} [options.eyeDomeLightingStrength=1.0] Increasing this value increases contrast on slopes and edges.\n * @param {number} [options.eyeDomeLightingRadius=1.0] Increase the thickness of contours from eye dome lighting.\n * @param {boolean} [options.backFaceCulling=false] Determines whether back-facing points are hidden. This option works only if data has normals included.\n * @param {boolean} [options.normalShading=true] Determines whether a point cloud that contains normals is shaded by the scene's light source.\n *\n * @alias PointCloudShading\n * @constructor\n */\nfunction PointCloudShading(options) {\n  const pointCloudShading = options ?? {};\n\n  /**\n   * Perform point attenuation based on geometric error.\n   * @type {boolean}\n   * @default false\n   */\n  this.attenuation = pointCloudShading.attenuation ?? false;\n\n  /**\n   * Scale to be applied to the geometric error before computing attenuation.\n   * @type {number}\n   * @default 1.0\n   */\n  this.geometricErrorScale = pointCloudShading.geometricErrorScale ?? 1.0;\n\n  /**\n   * Maximum point attenuation in pixels. If undefined, the Cesium3DTileset's maximumScreenSpaceError will be used.\n   * @type {number}\n   */\n  this.maximumAttenuation = pointCloudShading.maximumAttenuation;\n\n  /**\n   * Average base resolution for the dataset in meters.\n   * Used in place of geometric error when geometric error is 0.\n   * If undefined, an approximation will be computed for each tile that has geometric error of 0.\n   * @type {number}\n   */\n  this.baseResolution = pointCloudShading.baseResolution;\n\n  /**\n   * Use eye dome lighting when drawing with point attenuation\n   * Requires support for EXT_frag_depth, OES_texture_float, and WEBGL_draw_buffers extensions in WebGL 1.0,\n   * otherwise eye dome lighting is ignored.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.eyeDomeLighting = pointCloudShading.eyeDomeLighting ?? true;\n\n  /**\n   * Eye dome lighting strength (apparent contrast)\n   * @type {number}\n   * @default 1.0\n   */\n  this.eyeDomeLightingStrength =\n    pointCloudShading.eyeDomeLightingStrength ?? 1.0;\n\n  /**\n   * Thickness of contours from eye dome lighting\n   * @type {number}\n   * @default 1.0\n   */\n  this.eyeDomeLightingRadius = pointCloudShading.eyeDomeLightingRadius ?? 1.0;\n\n  /**\n   * Determines whether back-facing points are hidden.\n   * This option works only if data has normals included.\n   *\n   * @type {boolean}\n   * @default false\n   */\n  this.backFaceCulling = pointCloudShading.backFaceCulling ?? false;\n\n  /**\n   * Determines whether a point cloud that contains normals is shaded by the scene's light source.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.normalShading = pointCloudShading.normalShading ?? true;\n}\n\n/**\n * Determines if point cloud shading is supported.\n *\n * @param {Scene} scene The scene.\n * @returns {boolean} <code>true</code> if point cloud shading is supported; otherwise, returns <code>false</code>\n */\nPointCloudShading.isSupported = function (scene) {\n  return PointCloudEyeDomeLighting.isSupported(scene.context);\n};\nexport default PointCloudShading;\n"],"mappings":"AAAA,OAAOA,yBAAyB,MAAM,gCAAgC;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,iBAAiBA,CAACC,OAAO,EAAE;EAClC,MAAMC,iBAAiB,GAAGD,OAAO,IAAI,CAAC,CAAC;;EAEvC;AACF;AACA;AACA;AACA;EACE,IAAI,CAACE,WAAW,GAAGD,iBAAiB,CAACC,WAAW,IAAI,KAAK;;EAEzD;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,mBAAmB,GAAGF,iBAAiB,CAACE,mBAAmB,IAAI,GAAG;;EAEvE;AACF;AACA;AACA;EACE,IAAI,CAACC,kBAAkB,GAAGH,iBAAiB,CAACG,kBAAkB;;EAE9D;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,cAAc,GAAGJ,iBAAiB,CAACI,cAAc;;EAEtD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,eAAe,GAAGL,iBAAiB,CAACK,eAAe,IAAI,IAAI;;EAEhE;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,uBAAuB,GAC1BN,iBAAiB,CAACM,uBAAuB,IAAI,GAAG;;EAElD;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,qBAAqB,GAAGP,iBAAiB,CAACO,qBAAqB,IAAI,GAAG;;EAE3E;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,eAAe,GAAGR,iBAAiB,CAACQ,eAAe,IAAI,KAAK;;EAEjE;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,aAAa,GAAGT,iBAAiB,CAACS,aAAa,IAAI,IAAI;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACAX,iBAAiB,CAACY,WAAW,GAAG,UAAUC,KAAK,EAAE;EAC/C,OAAOd,yBAAyB,CAACa,WAAW,CAACC,KAAK,CAACC,OAAO,CAAC;AAC7D,CAAC;AACD,eAAed,iBAAiB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}