{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport BillboardLoadState from \"./BillboardLoadState.js\";\n\n/**\n * Tracks a reference to an image and it's loading state, as used in a BillboardCollection and stored in a texture atlas.\n * @constructor\n * @private\n * @see BillboardCollection\n * @see Billboard#image\n * @alias BillboardTexture\n * @param {BillboardCollection} billboardCollection The associated billboard collecion.\n */\nfunction BillboardTexture(billboardCollection) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"billboardCollection\", billboardCollection);\n  //>>includeEnd('debug');\n\n  this._billboardCollection = billboardCollection;\n  this._id = undefined;\n  this._loadState = BillboardLoadState.NONE;\n  this._loadError = undefined;\n  this._index = -1;\n  this._width = undefined;\n  this._height = undefined;\n  this._hasSubregion = false;\n\n  /**\n   * Used by billboardCollection to track whcih billboards to update.\n   * @type {boolean}\n   * @private\n   */\n  this.dirty = false;\n}\nObject.defineProperties(BillboardTexture.prototype, {\n  /**\n   * If defined, this error was encountered during the loading process.\n   * @memberof BillboardTexture.prototype\n   * @type {Error|undefined}\n   * @readonly\n   * @private\n   */\n  loadError: {\n    get: function () {\n      return this._loadError;\n    }\n  },\n  /**\n   * The current status of the image load. When <code>BillboardLoadState.LOADED</code>, this billboard is ready to render, i.e., the image\n   * has been downloaded and the WebGL resources are created.\n   * @memberof BillboardTexture.prototype\n   * @type {BillboardLoadState}\n   * @readonly\n   * @default BillboardLoadState.NONE\n   * @private\n   */\n  loadState: {\n    get: function () {\n      return this._loadState;\n    }\n  },\n  /**\n   * When <code>true</code>, this texture is ready to render, i.e., the image\n   * has been downloaded and the WebGL resources are created.\n   * @memberof BillboardTexture.prototype\n   * @type {boolean}\n   * @readonly\n   * @default false\n   * @private\n   */\n  ready: {\n    get: function () {\n      return this._loadState === BillboardLoadState.LOADED;\n    }\n  },\n  /**\n   * Returns <code>true</code> if there is image data associated with this instance.\n   * @memberof BillboardTexture.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  hasImage: {\n    get: function () {\n      return this._loadState !== BillboardLoadState.NONE;\n    }\n  },\n  /**\n   * A unique identifier for the image, or undefined if no image data has been associated with this instance.\n   * @memberof BillboardTexture.prototype\n   * @type {string|undefined}\n   * @readonly\n   * @private\n   */\n  id: {\n    get: function () {\n      return this._id;\n    }\n  },\n  /**\n   * The width of the associated image. Before the instance is <code>ready</code>, this will be <code>undefined</code>.\n   * @memberof BillboardTexture.prototype\n   * @type {number|undefined}\n   * @readonly\n   * @private\n   */\n  width: {\n    get: function () {\n      return this._width;\n    }\n  },\n  /**\n   * The height of the associated image. Before the instance is <code>ready</code>, this will be <code>undefined</code>.\n   * @memberof BillboardTexture.prototype\n   * @type {number|undefined}\n   * @readonly\n   * @private\n   */\n  height: {\n    get: function () {\n      return this._height;\n    }\n  }\n});\n\n/**\n * Releases reference to any associated image data.\n * @private\n */\nBillboardTexture.prototype.unload = async function () {\n  if (this._loadState === BillboardLoadState.NONE) {\n    return;\n  }\n  this._id = undefined;\n  this._loadError = undefined;\n  this._loadState = BillboardLoadState.NONE;\n  this._index = -1;\n  this._width = undefined;\n  this._height = undefined;\n  this.dirty = true;\n};\n\n/**\n * Starts loading an image into the texture atlas.\n * @see {TextureAtlas#addImage}\n * @private\n * @param {string} id An identifier to detect whether the image already exists in the atlas.\n * @param {HTMLImageElement|HTMLCanvasElement|string|Resource|Promise|TextureAtlas.CreateImageCallback} image An image or canvas to add to the texture atlas,\n *        or a URL to an Image, or a Promise for an image, or a function that creates an image.\n */\nBillboardTexture.prototype.loadImage = async function (id, image) {\n  if (this._id === id) {\n    // This image has already been loaded\n    return;\n  }\n  const collection = this._billboardCollection;\n  const cache = collection.billboardTextureCache;\n  let billboardTexture = cache.get(id);\n  if (defined(billboardTexture) && image.loadState === BillboardLoadState.LOADING || image.loadState === BillboardLoadState.LOADED) {\n    // Use the cached texture if it is in progress or successful.\n    BillboardTexture.clone(billboardTexture, this);\n    return;\n  }\n  // Otherwise, load if not yet assigned an image, and try the load again if anything failed during the last billboard creation\n  if (!defined(billboardTexture)) {\n    billboardTexture = new BillboardTexture(collection);\n    cache.set(id, billboardTexture);\n  }\n  billboardTexture._id = this._id = id;\n  billboardTexture._loadState = this._loadState = BillboardLoadState.LOADING;\n  billboardTexture._loadError = this._loadError = undefined;\n  let index;\n  const atlas = this._billboardCollection.textureAtlas;\n  try {\n    index = await atlas.addImage(id, image);\n  } catch (error) {\n    // There was an error loading the image\n    billboardTexture._loadState = BillboardLoadState.ERROR;\n    billboardTexture._loadError = error;\n    if (this._id !== id) {\n      // Another load was initiated and resolved resolved before this one. This operation is cancelled.\n      return;\n    }\n    this._loadState = BillboardLoadState.ERROR;\n    this._loadError = error;\n    return;\n  }\n  if (!defined(index) || index === -1) {\n    // Resources destroyed or otherwise\n    billboardTexture._loadState = BillboardLoadState.FAILED;\n    billboardTexture._index = -1;\n    if (this._id !== id) {\n      // Another load was initiated and resolved resolved before this one. This operation is cancelled.\n      return;\n    }\n    this._loadState = BillboardLoadState.FAILED;\n    this._index = -1;\n    return;\n  }\n  billboardTexture._index = index;\n  billboardTexture._loadState = BillboardLoadState.LOADED;\n  const rectangle = atlas.rectangles[index];\n  billboardTexture._width = rectangle.width;\n  billboardTexture._height = rectangle.height;\n  if (this._id !== id) {\n    // Another load was initiated and resolved resolved before this one. This operation is cancelled.\n    return;\n  }\n  this._index = index;\n  this._loadState = BillboardLoadState.LOADED;\n  this._width = rectangle.width;\n  this._height = rectangle.height;\n  this.dirty = true;\n};\n\n/**\n * Track a reference to a sub-region of an existing image.\n * @see {TextureAtlas#addImageSubRegion}\n * @private\n * @param {string} id An identifier to detect whether the image already exists in the atlas.\n * @param {BoundingRectangle} subRegion An {@link BoundingRectangle} defining a region of an existing image, measured in pixels from the bottom-left of the image.\n */\nBillboardTexture.prototype.addImageSubRegion = async function (id, subRegion) {\n  this._id = id;\n  this._loadState = BillboardLoadState.LOADING;\n  this._loadError = undefined;\n  this._hasSubregion = true;\n  let index;\n  const atlas = this._billboardCollection.textureAtlas;\n  try {\n    index = await atlas.addImageSubRegion(id, subRegion);\n  } catch (error) {\n    // There was an error loading the referenced image\n    this._loadState = BillboardLoadState.ERROR;\n    this._loadError = error;\n    return;\n  }\n  if (!defined(index) || index === -1) {\n    this._loadState = BillboardLoadState.FAILED;\n    this._index = -1;\n    this._width = undefined;\n    this._height = undefined;\n    return;\n  }\n  this._width = subRegion.width;\n  this._height = subRegion.height;\n  this._index = index;\n  this._loadState = BillboardLoadState.LOADED;\n  this.dirty = true;\n};\n\n/**\n * Get the texture coordinates for reading the loaded texture in shaders.\n * @private\n * @param {BoundingRectangle} [result] The modified result parameter or a new BoundingRectangle instance if one was not provided.\n * @return {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBillboardTexture.prototype.computeTextureCoordinates = function (result) {\n  const atlas = this._billboardCollection.textureAtlas;\n  return atlas.computeTextureCoordinates(this._index, result);\n};\n\n/**\n * Clones an existing billboard texture, inlcuding any in-flight tracking, into the target billboard texture.\n * @param {BillboardTexture} billboardTexture\n * @param {BillboardTexture} target\n * @returns {BillboardTexture} target\n */\nBillboardTexture.clone = function (billboardTexture, target) {\n  target._id = billboardTexture._id;\n  target._loadState = billboardTexture._loadState;\n  target._loadError = undefined;\n  target._index = billboardTexture._index;\n  target._width = billboardTexture._width;\n  target._height = billboardTexture._height;\n  target._hasSubregion = billboardTexture._hasSubregion;\n  if (billboardTexture.ready) {\n    target.dirty = true;\n    return;\n  }\n  const completeLoad = async () => {\n    const id = billboardTexture._id;\n    const atlas = billboardTexture._billboardCollection.textureAtlas;\n    await atlas._indexPromiseById.get(id);\n\n    // Any errors should have already been handled\n    if (target._id !== id) {\n      // Another load was initiated and resolved resolved before this one. This operation is cancelled.\n      return;\n    }\n    if (billboardTexture._hasSubregion) {\n      // Subregions must wait an additional frame to be ready\n      await Promise.resolve();\n    }\n    target._id = id;\n    target._loadState = billboardTexture._loadState;\n    target._loadError = billboardTexture._loadError;\n    target._index = billboardTexture._index;\n    target._width = billboardTexture._width;\n    target._height = billboardTexture._height;\n    target.dirty = true;\n  };\n  completeLoad();\n  return target;\n};\nexport default BillboardTexture;","map":{"version":3,"names":["Check","defined","BillboardLoadState","BillboardTexture","billboardCollection","_billboardCollection","_id","undefined","_loadState","NONE","_loadError","_index","_width","_height","_hasSubregion","dirty","Object","defineProperties","prototype","loadError","get","loadState","ready","LOADED","hasImage","id","width","height","unload","loadImage","image","collection","cache","billboardTextureCache","billboardTexture","LOADING","clone","set","index","atlas","textureAtlas","addImage","error","ERROR","FAILED","rectangle","rectangles","addImageSubRegion","subRegion","computeTextureCoordinates","result","target","completeLoad","_indexPromiseById","Promise","resolve"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/BillboardTexture.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport BillboardLoadState from \"./BillboardLoadState.js\";\n\n/**\n * Tracks a reference to an image and it's loading state, as used in a BillboardCollection and stored in a texture atlas.\n * @constructor\n * @private\n * @see BillboardCollection\n * @see Billboard#image\n * @alias BillboardTexture\n * @param {BillboardCollection} billboardCollection The associated billboard collecion.\n */\nfunction BillboardTexture(billboardCollection) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"billboardCollection\", billboardCollection);\n  //>>includeEnd('debug');\n\n  this._billboardCollection = billboardCollection;\n\n  this._id = undefined;\n  this._loadState = BillboardLoadState.NONE;\n  this._loadError = undefined;\n\n  this._index = -1;\n  this._width = undefined;\n  this._height = undefined;\n\n  this._hasSubregion = false;\n\n  /**\n   * Used by billboardCollection to track whcih billboards to update.\n   * @type {boolean}\n   * @private\n   */\n  this.dirty = false;\n}\n\nObject.defineProperties(BillboardTexture.prototype, {\n  /**\n   * If defined, this error was encountered during the loading process.\n   * @memberof BillboardTexture.prototype\n   * @type {Error|undefined}\n   * @readonly\n   * @private\n   */\n  loadError: {\n    get: function () {\n      return this._loadError;\n    },\n  },\n\n  /**\n   * The current status of the image load. When <code>BillboardLoadState.LOADED</code>, this billboard is ready to render, i.e., the image\n   * has been downloaded and the WebGL resources are created.\n   * @memberof BillboardTexture.prototype\n   * @type {BillboardLoadState}\n   * @readonly\n   * @default BillboardLoadState.NONE\n   * @private\n   */\n  loadState: {\n    get: function () {\n      return this._loadState;\n    },\n  },\n\n  /**\n   * When <code>true</code>, this texture is ready to render, i.e., the image\n   * has been downloaded and the WebGL resources are created.\n   * @memberof BillboardTexture.prototype\n   * @type {boolean}\n   * @readonly\n   * @default false\n   * @private\n   */\n  ready: {\n    get: function () {\n      return this._loadState === BillboardLoadState.LOADED;\n    },\n  },\n\n  /**\n   * Returns <code>true</code> if there is image data associated with this instance.\n   * @memberof BillboardTexture.prototype\n   * @type {boolean}\n   * @readonly\n   * @private\n   */\n  hasImage: {\n    get: function () {\n      return this._loadState !== BillboardLoadState.NONE;\n    },\n  },\n\n  /**\n   * A unique identifier for the image, or undefined if no image data has been associated with this instance.\n   * @memberof BillboardTexture.prototype\n   * @type {string|undefined}\n   * @readonly\n   * @private\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n\n  /**\n   * The width of the associated image. Before the instance is <code>ready</code>, this will be <code>undefined</code>.\n   * @memberof BillboardTexture.prototype\n   * @type {number|undefined}\n   * @readonly\n   * @private\n   */\n  width: {\n    get: function () {\n      return this._width;\n    },\n  },\n\n  /**\n   * The height of the associated image. Before the instance is <code>ready</code>, this will be <code>undefined</code>.\n   * @memberof BillboardTexture.prototype\n   * @type {number|undefined}\n   * @readonly\n   * @private\n   */\n  height: {\n    get: function () {\n      return this._height;\n    },\n  },\n});\n\n/**\n * Releases reference to any associated image data.\n * @private\n */\nBillboardTexture.prototype.unload = async function () {\n  if (this._loadState === BillboardLoadState.NONE) {\n    return;\n  }\n\n  this._id = undefined;\n  this._loadError = undefined;\n  this._loadState = BillboardLoadState.NONE;\n\n  this._index = -1;\n  this._width = undefined;\n  this._height = undefined;\n\n  this.dirty = true;\n};\n\n/**\n * Starts loading an image into the texture atlas.\n * @see {TextureAtlas#addImage}\n * @private\n * @param {string} id An identifier to detect whether the image already exists in the atlas.\n * @param {HTMLImageElement|HTMLCanvasElement|string|Resource|Promise|TextureAtlas.CreateImageCallback} image An image or canvas to add to the texture atlas,\n *        or a URL to an Image, or a Promise for an image, or a function that creates an image.\n */\nBillboardTexture.prototype.loadImage = async function (id, image) {\n  if (this._id === id) {\n    // This image has already been loaded\n    return;\n  }\n\n  const collection = this._billboardCollection;\n  const cache = collection.billboardTextureCache;\n  let billboardTexture = cache.get(id);\n  if (\n    (defined(billboardTexture) &&\n      image.loadState === BillboardLoadState.LOADING) ||\n    image.loadState === BillboardLoadState.LOADED\n  ) {\n    // Use the cached texture if it is in progress or successful.\n    BillboardTexture.clone(billboardTexture, this);\n    return;\n  }\n  // Otherwise, load if not yet assigned an image, and try the load again if anything failed during the last billboard creation\n  if (!defined(billboardTexture)) {\n    billboardTexture = new BillboardTexture(collection);\n    cache.set(id, billboardTexture);\n  }\n\n  billboardTexture._id = this._id = id;\n  billboardTexture._loadState = this._loadState = BillboardLoadState.LOADING;\n  billboardTexture._loadError = this._loadError = undefined;\n\n  let index;\n  const atlas = this._billboardCollection.textureAtlas;\n  try {\n    index = await atlas.addImage(id, image);\n  } catch (error) {\n    // There was an error loading the image\n    billboardTexture._loadState = BillboardLoadState.ERROR;\n    billboardTexture._loadError = error;\n\n    if (this._id !== id) {\n      // Another load was initiated and resolved resolved before this one. This operation is cancelled.\n      return;\n    }\n\n    this._loadState = BillboardLoadState.ERROR;\n    this._loadError = error;\n    return;\n  }\n\n  if (!defined(index) || index === -1) {\n    // Resources destroyed or otherwise\n    billboardTexture._loadState = BillboardLoadState.FAILED;\n    billboardTexture._index = -1;\n\n    if (this._id !== id) {\n      // Another load was initiated and resolved resolved before this one. This operation is cancelled.\n      return;\n    }\n\n    this._loadState = BillboardLoadState.FAILED;\n    this._index = -1;\n\n    return;\n  }\n\n  billboardTexture._index = index;\n  billboardTexture._loadState = BillboardLoadState.LOADED;\n\n  const rectangle = atlas.rectangles[index];\n  billboardTexture._width = rectangle.width;\n  billboardTexture._height = rectangle.height;\n\n  if (this._id !== id) {\n    // Another load was initiated and resolved resolved before this one. This operation is cancelled.\n    return;\n  }\n\n  this._index = index;\n  this._loadState = BillboardLoadState.LOADED;\n  this._width = rectangle.width;\n  this._height = rectangle.height;\n\n  this.dirty = true;\n};\n\n/**\n * Track a reference to a sub-region of an existing image.\n * @see {TextureAtlas#addImageSubRegion}\n * @private\n * @param {string} id An identifier to detect whether the image already exists in the atlas.\n * @param {BoundingRectangle} subRegion An {@link BoundingRectangle} defining a region of an existing image, measured in pixels from the bottom-left of the image.\n */\nBillboardTexture.prototype.addImageSubRegion = async function (id, subRegion) {\n  this._id = id;\n  this._loadState = BillboardLoadState.LOADING;\n  this._loadError = undefined;\n  this._hasSubregion = true;\n\n  let index;\n  const atlas = this._billboardCollection.textureAtlas;\n  try {\n    index = await atlas.addImageSubRegion(id, subRegion);\n  } catch (error) {\n    // There was an error loading the referenced image\n    this._loadState = BillboardLoadState.ERROR;\n    this._loadError = error;\n    return;\n  }\n\n  if (!defined(index) || index === -1) {\n    this._loadState = BillboardLoadState.FAILED;\n    this._index = -1;\n    this._width = undefined;\n    this._height = undefined;\n    return;\n  }\n\n  this._width = subRegion.width;\n  this._height = subRegion.height;\n\n  this._index = index;\n  this._loadState = BillboardLoadState.LOADED;\n\n  this.dirty = true;\n};\n\n/**\n * Get the texture coordinates for reading the loaded texture in shaders.\n * @private\n * @param {BoundingRectangle} [result] The modified result parameter or a new BoundingRectangle instance if one was not provided.\n * @return {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n */\nBillboardTexture.prototype.computeTextureCoordinates = function (result) {\n  const atlas = this._billboardCollection.textureAtlas;\n  return atlas.computeTextureCoordinates(this._index, result);\n};\n\n/**\n * Clones an existing billboard texture, inlcuding any in-flight tracking, into the target billboard texture.\n * @param {BillboardTexture} billboardTexture\n * @param {BillboardTexture} target\n * @returns {BillboardTexture} target\n */\nBillboardTexture.clone = function (billboardTexture, target) {\n  target._id = billboardTexture._id;\n  target._loadState = billboardTexture._loadState;\n  target._loadError = undefined;\n  target._index = billboardTexture._index;\n  target._width = billboardTexture._width;\n  target._height = billboardTexture._height;\n  target._hasSubregion = billboardTexture._hasSubregion;\n\n  if (billboardTexture.ready) {\n    target.dirty = true;\n    return;\n  }\n\n  const completeLoad = async () => {\n    const id = billboardTexture._id;\n    const atlas = billboardTexture._billboardCollection.textureAtlas;\n    await atlas._indexPromiseById.get(id);\n\n    // Any errors should have already been handled\n    if (target._id !== id) {\n      // Another load was initiated and resolved resolved before this one. This operation is cancelled.\n      return;\n    }\n\n    if (billboardTexture._hasSubregion) {\n      // Subregions must wait an additional frame to be ready\n      await Promise.resolve();\n    }\n\n    target._id = id;\n    target._loadState = billboardTexture._loadState;\n    target._loadError = billboardTexture._loadError;\n    target._index = billboardTexture._index;\n    target._width = billboardTexture._width;\n    target._height = billboardTexture._height;\n    target.dirty = true;\n  };\n\n  completeLoad();\n  return target;\n};\n\nexport default BillboardTexture;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}