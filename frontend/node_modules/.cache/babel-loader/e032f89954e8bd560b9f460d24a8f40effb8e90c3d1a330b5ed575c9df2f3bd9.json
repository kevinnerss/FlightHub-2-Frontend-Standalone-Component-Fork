{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"uniform vec2 u_cylinderLocalToShapeUvRadius; // x = scale, y = offset\\n\\\nuniform vec2 u_cylinderLocalToShapeUvHeight; // x = scale, y = offset\\n\\\nuniform vec2 u_cylinderLocalToShapeUvAngle; // x = scale, y = offset\\n\\\nuniform float u_cylinderShapeUvAngleRangeOrigin;\\n\\\nuniform mat3 u_cylinderEcToRadialTangentUp;\\n\\\nuniform ivec4 u_cameraTileCoordinates;\\n\\\nuniform vec3 u_cameraTileUv;\\n\\\nuniform vec3 u_cameraShapePosition; // (radial distance, angle, height) of camera in shape space\\n\\\n\\n\\\nmat3 convertLocalToShapeSpaceDerivative(in vec3 position) {\\n\\\n    vec3 radial = normalize(vec3(position.xy, 0.0));\\n\\\n    vec3 z = vec3(0.0, 0.0, 1.0);\\n\\\n    vec3 east = normalize(vec3(-position.y, position.x, 0.0));\\n\\\n    return mat3(radial, east / length(position.xy), z);\\n\\\n}\\n\\\n\\n\\\nvec3 scaleShapeUvToShapeSpace(in vec3 shapeUv) {\\n\\\n    float radius = shapeUv.x / u_cylinderLocalToShapeUvRadius.x;\\n\\\n    float angle = shapeUv.y * czm_twoPi / u_cylinderLocalToShapeUvAngle.x;\\n\\\n    float height = shapeUv.z / u_cylinderLocalToShapeUvHeight.x;\\n\\\n\\n\\\n    return vec3(radius, angle, height);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Computes the change in polar coordinates given a change in position.\\n\\\n * @param {vec2} dPosition The change in position in Cartesian coordinates.\\n\\\n * @param {float} cameraRadialDistance The radial distance of the camera from the origin.\\n\\\n * @return {vec2} The change in polar coordinates (radial distance, angle).\\n\\\n */\\n\\\nvec2 computePolarChange(in vec2 dPosition, in float cameraRadialDistance) {\\n\\\n    float dAngle = atan(dPosition.y, cameraRadialDistance + dPosition.x);\\n\\\n    // Find the direction of the radial axis at the output angle, in Cartesian coordinates\\n\\\n    vec2 outputRadialAxis = vec2(cos(dAngle), sin(dAngle));\\n\\\n    float sinHalfAngle = sin(dAngle / 2.0);\\n\\\n    float versine = 2.0 * sinHalfAngle * sinHalfAngle;\\n\\\n    float dRadial = dot(dPosition, outputRadialAxis) - cameraRadialDistance * versine;\\n\\\n    return vec2(dRadial, dAngle);\\n\\\n}\\n\\\n\\n\\\nvec3 convertEcToDeltaShape(in vec3 positionEC) {\\n\\\n    // 1. Rotate to radial, tangent, and up coordinates\\n\\\n    vec3 rtu = u_cylinderEcToRadialTangentUp * positionEC;\\n\\\n    // 2. Compute change in angular and radial coordinates.\\n\\\n    vec2 dPolar = computePolarChange(rtu.xy, u_cameraShapePosition.x);\\n\\\n    return vec3(dPolar.xy, rtu.z);\\n\\\n}\\n\\\n\\n\\\nvec3 convertEcToDeltaTile(in vec3 positionEC) {\\n\\\n    vec3 deltaShape = convertEcToDeltaShape(positionEC);\\n\\\n    // Convert to tileset coordinates in [0, 1]\\n\\\n    float dx = u_cylinderLocalToShapeUvRadius.x * deltaShape.x;\\n\\\n    float dy = deltaShape.y / czm_twoPi;\\n\\\n#if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE)\\n\\\n    // Wrap to ensure dy is not crossing through the unoccupied angle range, where\\n\\\n    // angle to tile coordinate conversions would be more complicated\\n\\\n    float cameraUvAngle = (u_cameraShapePosition.y + czm_pi) / czm_twoPi;\\n\\\n    float cameraUvAngleShift = fract(cameraUvAngle - u_cylinderShapeUvAngleRangeOrigin);\\n\\\n    float rawOutputUvAngle = cameraUvAngleShift + dy;\\n\\\n    float rotation = floor(rawOutputUvAngle);\\n\\\n    dy -= rotation;\\n\\\n#endif\\n\\\n    dy *= u_cylinderLocalToShapeUvAngle.x;\\n\\\n    float dz = u_cylinderLocalToShapeUvHeight.x * deltaShape.z;\\n\\\n    // Convert to tile coordinate changes\\n\\\n    return vec3(dx, dy, dz) * float(1 << u_cameraTileCoordinates.w);\\n\\\n}\\n\\\n\\n\\\nTileAndUvCoordinate getTileAndUvCoordinate(in vec3 positionEC) {\\n\\\n    vec3 deltaTileCoordinate = convertEcToDeltaTile(positionEC);\\n\\\n    vec3 tileUvSum = u_cameraTileUv + deltaTileCoordinate;\\n\\\n    ivec3 tileCoordinate = u_cameraTileCoordinates.xyz + ivec3(floor(tileUvSum));\\n\\\n    int maxTileCoordinate = (1 << u_cameraTileCoordinates.w) - 1;\\n\\\n    tileCoordinate.x = min(max(0, tileCoordinate.x), maxTileCoordinate);\\n\\\n    tileCoordinate.z = min(max(0, tileCoordinate.z), maxTileCoordinate);\\n\\\n#if (!defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE))\\n\\\n    ivec3 tileCoordinateChange = tileCoordinate - u_cameraTileCoordinates.xyz;\\n\\\n    if (tileCoordinate.y < 0) {\\n\\\n        tileCoordinate.y += (maxTileCoordinate + 1);\\n\\\n    } else if (tileCoordinate.y > maxTileCoordinate) {\\n\\\n        tileCoordinate.y -= (maxTileCoordinate + 1);\\n\\\n    }\\n\\\n#else\\n\\\n    tileCoordinate.y = min(max(0, tileCoordinate.y), maxTileCoordinate);\\n\\\n    ivec3 tileCoordinateChange = tileCoordinate - u_cameraTileCoordinates.xyz;\\n\\\n#endif\\n\\\n    vec3 tileUv = tileUvSum - vec3(tileCoordinateChange);\\n\\\n    tileUv.x = clamp(tileUv.x, 0.0, 1.0);\\n\\\n#if (!defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE))\\n\\\n    // If there is only one tile spanning 2*PI angle, the coordinate wraps around\\n\\\n    tileUv.y = (u_cameraTileCoordinates.w == 0) ? fract(tileUv.y) : clamp(tileUv.y, 0.0, 1.0);\\n\\\n#else\\n\\\n    tileUv.y = clamp(tileUv.y, 0.0, 1.0);\\n\\\n#endif\\n\\\n    tileUv.z = clamp(tileUv.z, 0.0, 1.0);\\n\\\n    return TileAndUvCoordinate(ivec4(tileCoordinate, u_cameraTileCoordinates.w), tileUv);\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Shaders/Voxels/convertLocalToCylinderUv.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"uniform vec2 u_cylinderLocalToShapeUvRadius; // x = scale, y = offset\\n\\\nuniform vec2 u_cylinderLocalToShapeUvHeight; // x = scale, y = offset\\n\\\nuniform vec2 u_cylinderLocalToShapeUvAngle; // x = scale, y = offset\\n\\\nuniform float u_cylinderShapeUvAngleRangeOrigin;\\n\\\nuniform mat3 u_cylinderEcToRadialTangentUp;\\n\\\nuniform ivec4 u_cameraTileCoordinates;\\n\\\nuniform vec3 u_cameraTileUv;\\n\\\nuniform vec3 u_cameraShapePosition; // (radial distance, angle, height) of camera in shape space\\n\\\n\\n\\\nmat3 convertLocalToShapeSpaceDerivative(in vec3 position) {\\n\\\n    vec3 radial = normalize(vec3(position.xy, 0.0));\\n\\\n    vec3 z = vec3(0.0, 0.0, 1.0);\\n\\\n    vec3 east = normalize(vec3(-position.y, position.x, 0.0));\\n\\\n    return mat3(radial, east / length(position.xy), z);\\n\\\n}\\n\\\n\\n\\\nvec3 scaleShapeUvToShapeSpace(in vec3 shapeUv) {\\n\\\n    float radius = shapeUv.x / u_cylinderLocalToShapeUvRadius.x;\\n\\\n    float angle = shapeUv.y * czm_twoPi / u_cylinderLocalToShapeUvAngle.x;\\n\\\n    float height = shapeUv.z / u_cylinderLocalToShapeUvHeight.x;\\n\\\n\\n\\\n    return vec3(radius, angle, height);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Computes the change in polar coordinates given a change in position.\\n\\\n * @param {vec2} dPosition The change in position in Cartesian coordinates.\\n\\\n * @param {float} cameraRadialDistance The radial distance of the camera from the origin.\\n\\\n * @return {vec2} The change in polar coordinates (radial distance, angle).\\n\\\n */\\n\\\nvec2 computePolarChange(in vec2 dPosition, in float cameraRadialDistance) {\\n\\\n    float dAngle = atan(dPosition.y, cameraRadialDistance + dPosition.x);\\n\\\n    // Find the direction of the radial axis at the output angle, in Cartesian coordinates\\n\\\n    vec2 outputRadialAxis = vec2(cos(dAngle), sin(dAngle));\\n\\\n    float sinHalfAngle = sin(dAngle / 2.0);\\n\\\n    float versine = 2.0 * sinHalfAngle * sinHalfAngle;\\n\\\n    float dRadial = dot(dPosition, outputRadialAxis) - cameraRadialDistance * versine;\\n\\\n    return vec2(dRadial, dAngle);\\n\\\n}\\n\\\n\\n\\\nvec3 convertEcToDeltaShape(in vec3 positionEC) {\\n\\\n    // 1. Rotate to radial, tangent, and up coordinates\\n\\\n    vec3 rtu = u_cylinderEcToRadialTangentUp * positionEC;\\n\\\n    // 2. Compute change in angular and radial coordinates.\\n\\\n    vec2 dPolar = computePolarChange(rtu.xy, u_cameraShapePosition.x);\\n\\\n    return vec3(dPolar.xy, rtu.z);\\n\\\n}\\n\\\n\\n\\\nvec3 convertEcToDeltaTile(in vec3 positionEC) {\\n\\\n    vec3 deltaShape = convertEcToDeltaShape(positionEC);\\n\\\n    // Convert to tileset coordinates in [0, 1]\\n\\\n    float dx = u_cylinderLocalToShapeUvRadius.x * deltaShape.x;\\n\\\n    float dy = deltaShape.y / czm_twoPi;\\n\\\n#if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE)\\n\\\n    // Wrap to ensure dy is not crossing through the unoccupied angle range, where\\n\\\n    // angle to tile coordinate conversions would be more complicated\\n\\\n    float cameraUvAngle = (u_cameraShapePosition.y + czm_pi) / czm_twoPi;\\n\\\n    float cameraUvAngleShift = fract(cameraUvAngle - u_cylinderShapeUvAngleRangeOrigin);\\n\\\n    float rawOutputUvAngle = cameraUvAngleShift + dy;\\n\\\n    float rotation = floor(rawOutputUvAngle);\\n\\\n    dy -= rotation;\\n\\\n#endif\\n\\\n    dy *= u_cylinderLocalToShapeUvAngle.x;\\n\\\n    float dz = u_cylinderLocalToShapeUvHeight.x * deltaShape.z;\\n\\\n    // Convert to tile coordinate changes\\n\\\n    return vec3(dx, dy, dz) * float(1 << u_cameraTileCoordinates.w);\\n\\\n}\\n\\\n\\n\\\nTileAndUvCoordinate getTileAndUvCoordinate(in vec3 positionEC) {\\n\\\n    vec3 deltaTileCoordinate = convertEcToDeltaTile(positionEC);\\n\\\n    vec3 tileUvSum = u_cameraTileUv + deltaTileCoordinate;\\n\\\n    ivec3 tileCoordinate = u_cameraTileCoordinates.xyz + ivec3(floor(tileUvSum));\\n\\\n    int maxTileCoordinate = (1 << u_cameraTileCoordinates.w) - 1;\\n\\\n    tileCoordinate.x = min(max(0, tileCoordinate.x), maxTileCoordinate);\\n\\\n    tileCoordinate.z = min(max(0, tileCoordinate.z), maxTileCoordinate);\\n\\\n#if (!defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE))\\n\\\n    ivec3 tileCoordinateChange = tileCoordinate - u_cameraTileCoordinates.xyz;\\n\\\n    if (tileCoordinate.y < 0) {\\n\\\n        tileCoordinate.y += (maxTileCoordinate + 1);\\n\\\n    } else if (tileCoordinate.y > maxTileCoordinate) {\\n\\\n        tileCoordinate.y -= (maxTileCoordinate + 1);\\n\\\n    }\\n\\\n#else\\n\\\n    tileCoordinate.y = min(max(0, tileCoordinate.y), maxTileCoordinate);\\n\\\n    ivec3 tileCoordinateChange = tileCoordinate - u_cameraTileCoordinates.xyz;\\n\\\n#endif\\n\\\n    vec3 tileUv = tileUvSum - vec3(tileCoordinateChange);\\n\\\n    tileUv.x = clamp(tileUv.x, 0.0, 1.0);\\n\\\n#if (!defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE))\\n\\\n    // If there is only one tile spanning 2*PI angle, the coordinate wraps around\\n\\\n    tileUv.y = (u_cameraTileCoordinates.w == 0) ? fract(tileUv.y) : clamp(tileUv.y, 0.0, 1.0);\\n\\\n#else\\n\\\n    tileUv.y = clamp(tileUv.y, 0.0, 1.0);\\n\\\n#endif\\n\\\n    tileUv.z = clamp(tileUv.z, 0.0, 1.0);\\n\\\n    return TileAndUvCoordinate(ivec4(tileCoordinate, u_cameraTileCoordinates.w), tileUv);\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}