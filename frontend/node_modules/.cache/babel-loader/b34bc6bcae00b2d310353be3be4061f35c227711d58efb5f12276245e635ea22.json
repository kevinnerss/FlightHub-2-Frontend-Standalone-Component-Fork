{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"uniform samplerCube u_radianceMap;\\n\\\n\\n\\\nin vec2 v_textureCoordinates;\\n\\\n\\n\\\n\\n\\\nconst float twoSqrtPi = 2.0 * sqrt(czm_pi);\\n\\\n\\n\\\n// Coutesy of https://www.ppsloan.org/publications/StupidSH36.pdf\\n\\\nfloat computeShBasis(int index, vec3 s) {\\n\\\n    if (index == 0) { // l = 0, m = 0\\n\\\n        return 1.0 / twoSqrtPi;\\n\\\n    }\\n\\\n    \\n\\\n    if (index == 1) { // l = 1, m = -1\\n\\\n        return -sqrt(3.0) * s.y / twoSqrtPi;\\n\\\n    }\\n\\\n\\n\\\n    if (index == 2) { // l = 1, m = 0\\n\\\n        return sqrt(3.0) * s.z / twoSqrtPi;\\n\\\n    }\\n\\\n\\n\\\n    if (index == 3) { // l = 1, m = 1\\n\\\n        return -sqrt(3.0) * s.x / twoSqrtPi;\\n\\\n    }\\n\\\n\\n\\\n    if (index == 4) { // l = 2, m = -2\\n\\\n        return sqrt(15.0) * s.y * s.x / twoSqrtPi;\\n\\\n    }\\n\\\n\\n\\\n    if (index == 5) { // l = 2, m = -1\\n\\\n        return -sqrt(15.0) * s.y * s.z / twoSqrtPi;\\n\\\n    }\\n\\\n\\n\\\n    if (index == 6) { // l = 2, m = 0\\n\\\n        return sqrt(5.0) * (3.0 * s.z * s.z - 1.0) / 2.0 / twoSqrtPi;\\n\\\n    }\\n\\\n\\n\\\n    if (index == 7) { // l = 2, m = 1\\n\\\n        return -sqrt(15.0) * s.x * s.z / twoSqrtPi;\\n\\\n    }\\n\\\n\\n\\\n    if (index == 8) { // l = 2, m = 2\\n\\\n        return sqrt(15.0) * (s.x * s.x - s.y * s.y) / 2.0 / twoSqrtPi;\\n\\\n    }\\n\\\n\\n\\\n    return 0.0;\\n\\\n}\\n\\\n\\n\\\nfloat vdcRadicalInverse(int i)\\n\\\n{\\n\\\n    float r;\\n\\\n    float base = 2.0;\\n\\\n    float value = 0.0;\\n\\\n    float invBase = 1.0 / base;\\n\\\n    float invBi = invBase;\\n\\\n    for (int x = 0; x < 100; x++)\\n\\\n    {\\n\\\n        if (i <= 0)\\n\\\n        {\\n\\\n            break;\\n\\\n        }\\n\\\n        r = mod(float(i), base);\\n\\\n        value += r * invBi;\\n\\\n        invBi *= invBase;\\n\\\n        i = int(float(i) * invBase);\\n\\\n    }\\n\\\n    return value;\\n\\\n}\\n\\\n\\n\\\nvec2 hammersley2D(int i, int N)\\n\\\n{\\n\\\n    return vec2(float(i) / float(N), vdcRadicalInverse(i));\\n\\\n}\\n\\\n\\n\\\n// Sample count is relatively low for the sake of performance, but should still be enough to capture directionality needed for third-order harmonics\\n\\\nconst int samples = 256; \\n\\\nconst float solidAngle = 1.0 / float(samples);\\n\\\n\\n\\\nvoid main() {\\n\\\n    // Get the current coefficient based on the uv\\n\\\n   vec2 uv = v_textureCoordinates.xy * 3.0;\\n\\\n   int coefficientIndex = int(floor(uv.y) * 3.0 + floor(uv.x));\\n\\\n\\n\\\n    for (int i = 0; i < samples; ++i) {\\n\\\n        vec2 xi = hammersley2D(i, samples);\\n\\\n        float phi = czm_twoPi * xi.x;\\n\\\n        float cosTheta = 1.0 - 2.0 * sqrt(1.0 - xi.y * xi.y);\\n\\\n        float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\\n\\\n        vec3 direction = normalize(vec3(sinTheta * cos(phi), cosTheta, sinTheta * sin(phi)));\\n\\\n\\n\\\n        // Generate the spherical harmonics basis from the direction\\n\\\n        float Ylm = computeShBasis(coefficientIndex, direction);\\n\\\n\\n\\\n        vec3 lookupDirection = -direction.xyz;\\n\\\n        lookupDirection.z = -lookupDirection.z;\\n\\\n\\n\\\n        vec4 color = czm_textureCube(u_radianceMap, lookupDirection, 0.0);\\n\\\n\\n\\\n        // Use the relevant function for this coefficient\\n\\\n        out_FragColor += Ylm * color * solidAngle * sinTheta;\\n\\\n    }\\n\\\n    \\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Shaders/ComputeIrradianceFS.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"uniform samplerCube u_radianceMap;\\n\\\n\\n\\\nin vec2 v_textureCoordinates;\\n\\\n\\n\\\n\\n\\\nconst float twoSqrtPi = 2.0 * sqrt(czm_pi);\\n\\\n\\n\\\n// Coutesy of https://www.ppsloan.org/publications/StupidSH36.pdf\\n\\\nfloat computeShBasis(int index, vec3 s) {\\n\\\n    if (index == 0) { // l = 0, m = 0\\n\\\n        return 1.0 / twoSqrtPi;\\n\\\n    }\\n\\\n    \\n\\\n    if (index == 1) { // l = 1, m = -1\\n\\\n        return -sqrt(3.0) * s.y / twoSqrtPi;\\n\\\n    }\\n\\\n\\n\\\n    if (index == 2) { // l = 1, m = 0\\n\\\n        return sqrt(3.0) * s.z / twoSqrtPi;\\n\\\n    }\\n\\\n\\n\\\n    if (index == 3) { // l = 1, m = 1\\n\\\n        return -sqrt(3.0) * s.x / twoSqrtPi;\\n\\\n    }\\n\\\n\\n\\\n    if (index == 4) { // l = 2, m = -2\\n\\\n        return sqrt(15.0) * s.y * s.x / twoSqrtPi;\\n\\\n    }\\n\\\n\\n\\\n    if (index == 5) { // l = 2, m = -1\\n\\\n        return -sqrt(15.0) * s.y * s.z / twoSqrtPi;\\n\\\n    }\\n\\\n\\n\\\n    if (index == 6) { // l = 2, m = 0\\n\\\n        return sqrt(5.0) * (3.0 * s.z * s.z - 1.0) / 2.0 / twoSqrtPi;\\n\\\n    }\\n\\\n\\n\\\n    if (index == 7) { // l = 2, m = 1\\n\\\n        return -sqrt(15.0) * s.x * s.z / twoSqrtPi;\\n\\\n    }\\n\\\n\\n\\\n    if (index == 8) { // l = 2, m = 2\\n\\\n        return sqrt(15.0) * (s.x * s.x - s.y * s.y) / 2.0 / twoSqrtPi;\\n\\\n    }\\n\\\n\\n\\\n    return 0.0;\\n\\\n}\\n\\\n\\n\\\nfloat vdcRadicalInverse(int i)\\n\\\n{\\n\\\n    float r;\\n\\\n    float base = 2.0;\\n\\\n    float value = 0.0;\\n\\\n    float invBase = 1.0 / base;\\n\\\n    float invBi = invBase;\\n\\\n    for (int x = 0; x < 100; x++)\\n\\\n    {\\n\\\n        if (i <= 0)\\n\\\n        {\\n\\\n            break;\\n\\\n        }\\n\\\n        r = mod(float(i), base);\\n\\\n        value += r * invBi;\\n\\\n        invBi *= invBase;\\n\\\n        i = int(float(i) * invBase);\\n\\\n    }\\n\\\n    return value;\\n\\\n}\\n\\\n\\n\\\nvec2 hammersley2D(int i, int N)\\n\\\n{\\n\\\n    return vec2(float(i) / float(N), vdcRadicalInverse(i));\\n\\\n}\\n\\\n\\n\\\n// Sample count is relatively low for the sake of performance, but should still be enough to capture directionality needed for third-order harmonics\\n\\\nconst int samples = 256; \\n\\\nconst float solidAngle = 1.0 / float(samples);\\n\\\n\\n\\\nvoid main() {\\n\\\n    // Get the current coefficient based on the uv\\n\\\n   vec2 uv = v_textureCoordinates.xy * 3.0;\\n\\\n   int coefficientIndex = int(floor(uv.y) * 3.0 + floor(uv.x));\\n\\\n\\n\\\n    for (int i = 0; i < samples; ++i) {\\n\\\n        vec2 xi = hammersley2D(i, samples);\\n\\\n        float phi = czm_twoPi * xi.x;\\n\\\n        float cosTheta = 1.0 - 2.0 * sqrt(1.0 - xi.y * xi.y);\\n\\\n        float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\\n\\\n        vec3 direction = normalize(vec3(sinTheta * cos(phi), cosTheta, sinTheta * sin(phi)));\\n\\\n\\n\\\n        // Generate the spherical harmonics basis from the direction\\n\\\n        float Ylm = computeShBasis(coefficientIndex, direction);\\n\\\n\\n\\\n        vec3 lookupDirection = -direction.xyz;\\n\\\n        lookupDirection.z = -lookupDirection.z;\\n\\\n\\n\\\n        vec4 color = czm_textureCube(u_radianceMap, lookupDirection, 0.0);\\n\\\n\\n\\\n        // Use the relevant function for this coefficient\\n\\\n        out_FragColor += Ylm * color * solidAngle * sinTheta;\\n\\\n    }\\n\\\n    \\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}