{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport defined from \"../../Core/defined.js\";\nimport Cartesian2 from \"../../Core/Cartesian2.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Rectangle from \"../../Core/Rectangle.js\";\nimport Cartographic from \"../../Core/Cartographic.js\";\nimport BoundingRectangle from \"../../Core/BoundingRectangle.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport Check from \"../../Core/Check.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport ModelReader from \"./ModelReader.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\n/**\n * A class for computing the texture coordinates of imagery that is\n * supposed to be mapped on a <code>ModelComponents.Primitive</code>.\n *\n * @private\n */\nclass ModelImageryMapping {\n  /**\n   * Creates a typed array that contains texture coordinates for\n   * the given <code>MappedPositions</code>, using the given\n   * projection.\n   *\n   * This will be a typed array that contains the texture coordinates\n   * that result from projecting the given positions with the given\n   * projection, and normalizing them to their bounding rectangle.\n   *\n   * @param {MappedPositions} mappedPositions The positions\n   * @param {MapProjection} projection The projection that should be used\n   * @returns {TypedArray} The result\n   */\n  static createTextureCoordinatesForMappedPositions(mappedPositions, projection) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"mappedPositions\", mappedPositions);\n    Check.defined(\"projection\", projection);\n    //>>includeEnd('debug');\n\n    const cartographicPositions = mappedPositions.cartographicPositions;\n    const cartographicBoundingRectangle = mappedPositions.cartographicBoundingRectangle;\n    const numPositions = mappedPositions.numPositions;\n    return ModelImageryMapping._createTextureCoordinates(cartographicPositions, numPositions, cartographicBoundingRectangle, projection);\n  }\n\n  /**\n   * Creates a typed array that contains texture coordinates for\n   * a primitive with the given positions, using the given\n   * projection.\n   *\n   * This will be a typed array of size <code>numPositions*2</code>\n   * that contains the texture coordinates that result from\n   * projecting the given positions with the given projection,\n   * and normalizing them to the given bounding rectangle.\n   *\n   * @param {Iterable<Cartographic>} cartographicPositions The\n   * cartographic positions\n   * @param {number} numPositions The number of positions (vertices)\n   * @param {Rectangle} cartographicBoundingRectangle The bounding\n   * rectangle of the cartographic positions\n   * @param {MapProjection} projection The projection that should be used\n   * @returns {TypedArray} The result\n   * @private\n   */\n  static _createTextureCoordinates(cartographicPositions, numPositions, cartographicBoundingRectangle, projection) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"cartographicPositions\", cartographicPositions);\n    Check.typeOf.number.greaterThanOrEquals(\"numPositions\", numPositions, 0);\n    Check.defined(\"cartographicBoundingRectangle\", cartographicBoundingRectangle);\n    Check.defined(\"projection\", projection);\n    //>>includeEnd('debug');\n\n    // Convert the bounding `Rectangle`(!) of the cartographic positions\n    // into a `BoundingRectangle`(!) using the given projection\n    const boundingRectangle = new BoundingRectangle();\n    BoundingRectangle.fromRectangle(cartographicBoundingRectangle, projection, boundingRectangle);\n\n    // Compute the projected positions, using the given projection\n    const projectedPositions = ModelImageryMapping.createProjectedPositions(cartographicPositions, projection);\n\n    // Relativize the projected positions into the bounding rectangle\n    // to obtain texture coordinates\n    const texCoords = ModelImageryMapping.computeTexCoords(projectedPositions, boundingRectangle);\n\n    // Convert the texture coordinates into a typed array\n    const texCoordsTypedArray = ModelImageryMapping.createTypedArrayFromCartesians2(numPositions, texCoords);\n    return texCoordsTypedArray;\n  }\n\n  /**\n   * Creates the `ModelComponents.Attribute` for the texture coordinates\n   * for a primitive\n   *\n   * This will create an attribute with\n   * - semantic: VertexAttributeSemantic.TEXCOORD\n   * - type: AttributeType.VEC2\n   * - count: mappedPositions.numPositions\n   * that contains the texture coordinates for the given vertex positions,\n   * after they are projected using the given projection, normalized to\n   * their bounding rectangle.\n   *\n   * @param {Iterable<Cartographic>} cartographicPositions The\n   * cartographic positions\n   * @param {number} numPositions The number of positions (vertices)\n   * @param {Rectangle} cartographicBoundingRectangle The bounding\n   * rectangle of the cartographic positions\n   * @param {MapProjection} projection The projection that should be used\n   * @returns {ModelComponents.Attribute} The new attribute\n   */\n  static createTextureCoordinatesAttributeForMappedPositions(mappedPositions, projection) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"mappedPositions\", mappedPositions);\n    Check.defined(\"projection\", projection);\n    //>>includeEnd('debug');\n\n    // Create the typed array that contains the texture coordinates\n    const texCoordsTypedArray = ModelImageryMapping.createTextureCoordinatesForMappedPositions(mappedPositions, projection);\n\n    // Create an attribute from the texture coordinates typed array\n    const texCoordAttribute = ModelImageryMapping.createTexCoordAttribute(texCoordsTypedArray);\n    return texCoordAttribute;\n  }\n\n  /**\n   * Create an iterable that provides the cartographic positions\n   * of the given POSITION attribute, based on the given ellipsoid\n   *\n   * @param {ModelComponents.Attribute} primitivePositionAttribute\n   * The \"POSITION\" attribute of the primitive.\n   * @param {Matrix4} primitivePositionTransform The full transform of the primitive\n   * @param {Elliposid} ellipsoid The ellipsoid that should be used\n   * @returns {Iterable<Cartographic>} The iterable over `Cartographic` objects\n   */\n  static createCartographicPositions(primitivePositionAttribute, primitivePositionTransform, ellipsoid) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"primitivePositionAttribute\", primitivePositionAttribute);\n    Check.defined(\"primitivePositionTransform\", primitivePositionTransform);\n    Check.defined(\"ellipsoid\", ellipsoid);\n    //>>includeEnd('debug');\n\n    // Extract the positions as a typed array\n    const typedArray = ModelReader.readAttributeAsTypedArray(primitivePositionAttribute);\n\n    // Create an iterable over the positions\n    const type = primitivePositionAttribute.type;\n    const numComponents = AttributeType.getNumberOfComponents(type);\n    const positions = ModelImageryMapping.createIterableCartesian3FromTypedArray(typedArray, numComponents);\n\n    // Compute the positions after they are transformed with the given matrix\n    const transformedPositions = ModelImageryMapping.transformCartesians3(positions, primitivePositionTransform);\n\n    // Compute the cartographic positions for the given ellipsoid\n    const cartographicPositions = ModelImageryMapping.transformToCartographic(transformedPositions, ellipsoid);\n    return cartographicPositions;\n  }\n\n  /**\n   * Creates an iterable over `Cartesian3` objects from the given\n   * typed array.\n   *\n   * The resulting iterable will always return the same `Cartesian3`\n   * object. Clients should not store and modify this object.\n   *\n   * @param {TypedArray} typedArray The typed array\n   * @param {number} stride The stride between to consecutive\n   * `Cartesian3` elements in the given array. Must be at least 3.\n   * @returns {Iterable<Cartesian3>} The iterable\n   */\n  static createIterableCartesian3FromTypedArray(typedArray, stride) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"typedArray\", typedArray);\n    Check.typeOf.number.greaterThanOrEquals(\"stride\", stride, 3);\n    //>>includeEnd('debug');\n\n    const cartesian = new Cartesian3();\n    const numElements = typedArray.length / stride;\n    const result = {\n      [Symbol.iterator]: function* () {\n        for (let i = 0; i < numElements; i++) {\n          cartesian.x = typedArray[i * stride + 0];\n          cartesian.y = typedArray[i * stride + 1];\n          cartesian.z = typedArray[i * stride + 2];\n          yield cartesian;\n        }\n      }\n    };\n    return result;\n  }\n\n  /**\n   * Creates a new iterable that applies the given mapper to the given iterable.\n   *\n   * @param {Iterable} iterable The input iterable\n   * @param {Function} mapper The mapper\n   * @returns {Iterable} The mapped iterable\n   */\n  static map(iterable, mapper) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"iterable\", iterable);\n    Check.defined(\"mapper\", mapper);\n    //>>includeEnd('debug');\n\n    const result = {\n      [Symbol.iterator]: function* () {\n        for (const element of iterable) {\n          yield mapper(element);\n        }\n      }\n    };\n    return result;\n  }\n\n  /**\n   * Computes the bounding rectangle of the given cartographic positions,\n   * stores it in the given result, and returns it.\n   *\n   * If the given result is `undefined`, a new rectangle will be created\n   * and returned.\n   *\n   * @param {Iterable<Cartographic>} cartographicPositions The cartographics\n   * @param {Rectangle} [result] The result\n   * @returns {Rectangle} The result\n   */\n  static computeCartographicBoundingRectangle(cartographicPositions, result) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"cartographicPositions\", cartographicPositions);\n    //>>includeEnd('debug');\n\n    if (!defined(result)) {\n      result = new Rectangle();\n    }\n    // One could store these directly in the result, but that would\n    // violate the constraint of the PI-related ranges..\n    let north = Number.NEGATIVE_INFINITY;\n    let south = Number.POSITIVE_INFINITY;\n    let east = Number.NEGATIVE_INFINITY;\n    let west = Number.POSITIVE_INFINITY;\n    for (const cartographicPosition of cartographicPositions) {\n      north = Math.max(north, cartographicPosition.latitude);\n      south = Math.min(south, cartographicPosition.latitude);\n      east = Math.max(east, cartographicPosition.longitude);\n      west = Math.min(west, cartographicPosition.longitude);\n    }\n    result.north = north;\n    result.south = south;\n    result.east = east;\n    result.west = west;\n    return result;\n  }\n\n  /**\n   * Creates a new iterable that provides `Cartesian3` objects that\n   * are created by transforming the `Cartesian3` objects of the\n   * given iterable with the given matrix.\n   *\n   * The resulting iterable will always return the same `Cartesian3`\n   * object. Clients should not store and modify this object.\n   *\n   * @param {Iterable<Cartesian3>} positions The positions\n   * @param {Matrix4} matrix The matrix\n   * @returns {Iterable<Cartesian3>} The transformed cartesians\n   */\n  static transformCartesians3(positions, matrix) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"positions\", positions);\n    Check.defined(\"matrix\", matrix);\n    //>>includeEnd('debug');\n\n    const transformedPosition = new Cartesian3();\n    const transformedPositions = ModelImageryMapping.map(positions, p => {\n      Matrix4.multiplyByPoint(matrix, p, transformedPosition);\n      return transformedPosition;\n    });\n    return transformedPositions;\n  }\n\n  /**\n   * Creates a new iterable that provides `Cartographic` objects that\n   * are created by converting the given `Cartesian3` objects to\n   * cartographics, based on the given ellipsoid.\n   *\n   * The resulting iterable will always return the same `Cartographic`\n   * object. Clients should not store and modify this object.\n   *\n   * @param {Iterable<Cartesian3>} positions The positions\n   * @param {Ellipsoid} ellipsoid The ellipsoid\n   * @returns {Iterable<Cartographic>} The cartographic positions\n   */\n  static transformToCartographic(positions, ellipsoid) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"positions\", positions);\n    Check.defined(\"ellipsoid\", ellipsoid);\n    //>>includeEnd('debug');\n\n    const cartographicPosition = new Cartographic();\n    const cartographicPositions = ModelImageryMapping.map(positions, p => {\n      // Note: This will not yield valid results for p=(0,0,0).\n      // But there is no sensible cartographic position for\n      // that, so simply accept the unspecified output here.\n      ellipsoid.cartesianToCartographic(p, cartographicPosition);\n      return cartographicPosition;\n    });\n    return cartographicPositions;\n  }\n\n  /**\n   * Creates an iterable over the results of applying the given projection\n   * to the given cartographic positions.\n   *\n   * The resulting iterable will always return the same `Cartesian3`\n   * object. Clients should not store and modify this object.\n   *\n   * @param {Iterable<Cartographic>} cartographicPositions The cartographic\n   * positions\n   * @param {MapProjection} projection The projection to use\n   * @returns {Iterable<Cartesian3>} The projected positions\n   */\n  static createProjectedPositions(cartographicPositions, projection) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"cartographicPositions\", cartographicPositions);\n    Check.defined(\"projection\", projection);\n    //>>includeEnd('debug');\n\n    const projectedPosition = new Cartesian3();\n    const projectedPositions = ModelImageryMapping.map(cartographicPositions, c => {\n      projection.project(c, projectedPosition);\n      return projectedPosition;\n    });\n    return projectedPositions;\n  }\n\n  /**\n   * Computes the texture coordinates for the given positions, relative\n   * to the given bounding rectangle.\n   *\n   * This will make the x/y coordinates of the given cartesians relative\n   * to the given bounding rectangle and clamp them to [0,0]-[1,1].\n   *\n   * NOTE: This could be broken down into\n   * 1. mapping to 2D\n   * 2. relativizing for the bounding recangle\n   * 3. clamping to [0,0]-[1,1]\n   *\n   * @param {Iterable<Cartesian3>} positions The positions\n   * @param {BoundingRectangle} boundingRectangle The rectangle\n   * @returns {Iterable<Cartesian2>} The texture coordinates\n   */\n  static computeTexCoords(positions, boundingRectangle) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"positions\", positions);\n    Check.defined(\"boundingRectangle\", boundingRectangle);\n    //>>includeEnd('debug');\n\n    const texCoord = new Cartesian2();\n    const invSizeX = 1.0 / boundingRectangle.width;\n    const invSizeY = 1.0 / boundingRectangle.height;\n    const texCoords = ModelImageryMapping.map(positions, p => {\n      const uRaw = (p.x - boundingRectangle.x) * invSizeX;\n      const vRaw = (p.y - boundingRectangle.y) * invSizeY;\n      const u = Math.min(Math.max(uRaw, 0.0), 1.0);\n      const v = Math.min(Math.max(vRaw, 0.0), 1.0);\n      texCoord.x = u;\n      texCoord.y = v;\n      return texCoord;\n    });\n    return texCoords;\n  }\n\n  /**\n   * Creates a new typed array from the given `Cartesian2` objects.\n   *\n   * @param {number} numElements The number of elements\n   * @param {Iterable<Cartesian2>} elements The elements\n   * @returns {TypedArray} The typed array\n   */\n  static createTypedArrayFromCartesians2(numElements, elements) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.typeOf.number.greaterThanOrEquals(\"numElements\", numElements, 0);\n    Check.defined(\"elements\", elements);\n    //>>includeEnd('debug');\n\n    const typedArray = new Float32Array(numElements * 2);\n    let index = 0;\n    for (const element of elements) {\n      typedArray[index * 2 + 0] = element.x;\n      typedArray[index * 2 + 1] = element.y;\n      index++;\n    }\n    return typedArray;\n  }\n\n  /**\n   * Create a new texture coordinates attribute from the given data.\n   *\n   * This will create an attribute with\n   * - semantic: VertexAttributeSemantic.TEXCOORD\n   * - type: AttributeType.VEC2\n   * - count: texCoordsTypedArray.length / 2\n   * that contains the data from the given typed array.\n   *\n   * @param {TypedArray} texCoordsTypedArray The typed array\n   * @returns {ModelComponents.Attribute} The attribute\n   */\n  static createTexCoordAttribute(texCoordsTypedArray) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"texCoordsTypedArray\", texCoordsTypedArray);\n    //>>includeEnd('debug');\n\n    const texCoordAttribute = {\n      name: \"Imagery Texture Coordinates\",\n      semantic: VertexAttributeSemantic.TEXCOORD,\n      setIndex: 0,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC2,\n      normalized: false,\n      count: texCoordsTypedArray.length / 2,\n      min: undefined,\n      max: undefined,\n      constant: new Cartesian2(0, 0),\n      quantization: undefined,\n      typedArray: texCoordsTypedArray,\n      byteOffset: 0,\n      byteStride: undefined\n    };\n    return texCoordAttribute;\n  }\n}\nexport default ModelImageryMapping;","map":{"version":3,"names":["defined","Cartesian2","Cartesian3","Matrix4","Rectangle","Cartographic","BoundingRectangle","ComponentDatatype","Check","AttributeType","ModelReader","VertexAttributeSemantic","ModelImageryMapping","createTextureCoordinatesForMappedPositions","mappedPositions","projection","cartographicPositions","cartographicBoundingRectangle","numPositions","_createTextureCoordinates","typeOf","number","greaterThanOrEquals","boundingRectangle","fromRectangle","projectedPositions","createProjectedPositions","texCoords","computeTexCoords","texCoordsTypedArray","createTypedArrayFromCartesians2","createTextureCoordinatesAttributeForMappedPositions","texCoordAttribute","createTexCoordAttribute","createCartographicPositions","primitivePositionAttribute","primitivePositionTransform","ellipsoid","typedArray","readAttributeAsTypedArray","type","numComponents","getNumberOfComponents","positions","createIterableCartesian3FromTypedArray","transformedPositions","transformCartesians3","transformToCartographic","stride","cartesian","numElements","length","result","Symbol","iterator","i","x","y","z","map","iterable","mapper","element","computeCartographicBoundingRectangle","north","Number","NEGATIVE_INFINITY","south","POSITIVE_INFINITY","east","west","cartographicPosition","Math","max","latitude","min","longitude","matrix","transformedPosition","p","multiplyByPoint","cartesianToCartographic","projectedPosition","c","project","texCoord","invSizeX","width","invSizeY","height","uRaw","vRaw","u","v","elements","Float32Array","index","name","semantic","TEXCOORD","setIndex","componentDatatype","FLOAT","VEC2","normalized","count","undefined","constant","quantization","byteOffset","byteStride"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Model/ModelImageryMapping.js"],"sourcesContent":["import defined from \"../../Core/defined.js\";\nimport Cartesian2 from \"../../Core/Cartesian2.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Rectangle from \"../../Core/Rectangle.js\";\nimport Cartographic from \"../../Core/Cartographic.js\";\nimport BoundingRectangle from \"../../Core/BoundingRectangle.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport Check from \"../../Core/Check.js\";\n\nimport AttributeType from \"../AttributeType.js\";\nimport ModelReader from \"./ModelReader.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\n/**\n * A class for computing the texture coordinates of imagery that is\n * supposed to be mapped on a <code>ModelComponents.Primitive</code>.\n *\n * @private\n */\nclass ModelImageryMapping {\n  /**\n   * Creates a typed array that contains texture coordinates for\n   * the given <code>MappedPositions</code>, using the given\n   * projection.\n   *\n   * This will be a typed array that contains the texture coordinates\n   * that result from projecting the given positions with the given\n   * projection, and normalizing them to their bounding rectangle.\n   *\n   * @param {MappedPositions} mappedPositions The positions\n   * @param {MapProjection} projection The projection that should be used\n   * @returns {TypedArray} The result\n   */\n  static createTextureCoordinatesForMappedPositions(\n    mappedPositions,\n    projection,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"mappedPositions\", mappedPositions);\n    Check.defined(\"projection\", projection);\n    //>>includeEnd('debug');\n\n    const cartographicPositions = mappedPositions.cartographicPositions;\n    const cartographicBoundingRectangle =\n      mappedPositions.cartographicBoundingRectangle;\n    const numPositions = mappedPositions.numPositions;\n    return ModelImageryMapping._createTextureCoordinates(\n      cartographicPositions,\n      numPositions,\n      cartographicBoundingRectangle,\n      projection,\n    );\n  }\n\n  /**\n   * Creates a typed array that contains texture coordinates for\n   * a primitive with the given positions, using the given\n   * projection.\n   *\n   * This will be a typed array of size <code>numPositions*2</code>\n   * that contains the texture coordinates that result from\n   * projecting the given positions with the given projection,\n   * and normalizing them to the given bounding rectangle.\n   *\n   * @param {Iterable<Cartographic>} cartographicPositions The\n   * cartographic positions\n   * @param {number} numPositions The number of positions (vertices)\n   * @param {Rectangle} cartographicBoundingRectangle The bounding\n   * rectangle of the cartographic positions\n   * @param {MapProjection} projection The projection that should be used\n   * @returns {TypedArray} The result\n   * @private\n   */\n  static _createTextureCoordinates(\n    cartographicPositions,\n    numPositions,\n    cartographicBoundingRectangle,\n    projection,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"cartographicPositions\", cartographicPositions);\n    Check.typeOf.number.greaterThanOrEquals(\"numPositions\", numPositions, 0);\n    Check.defined(\n      \"cartographicBoundingRectangle\",\n      cartographicBoundingRectangle,\n    );\n    Check.defined(\"projection\", projection);\n    //>>includeEnd('debug');\n\n    // Convert the bounding `Rectangle`(!) of the cartographic positions\n    // into a `BoundingRectangle`(!) using the given projection\n    const boundingRectangle = new BoundingRectangle();\n    BoundingRectangle.fromRectangle(\n      cartographicBoundingRectangle,\n      projection,\n      boundingRectangle,\n    );\n\n    // Compute the projected positions, using the given projection\n    const projectedPositions = ModelImageryMapping.createProjectedPositions(\n      cartographicPositions,\n      projection,\n    );\n\n    // Relativize the projected positions into the bounding rectangle\n    // to obtain texture coordinates\n    const texCoords = ModelImageryMapping.computeTexCoords(\n      projectedPositions,\n      boundingRectangle,\n    );\n\n    // Convert the texture coordinates into a typed array\n    const texCoordsTypedArray =\n      ModelImageryMapping.createTypedArrayFromCartesians2(\n        numPositions,\n        texCoords,\n      );\n\n    return texCoordsTypedArray;\n  }\n\n  /**\n   * Creates the `ModelComponents.Attribute` for the texture coordinates\n   * for a primitive\n   *\n   * This will create an attribute with\n   * - semantic: VertexAttributeSemantic.TEXCOORD\n   * - type: AttributeType.VEC2\n   * - count: mappedPositions.numPositions\n   * that contains the texture coordinates for the given vertex positions,\n   * after they are projected using the given projection, normalized to\n   * their bounding rectangle.\n   *\n   * @param {Iterable<Cartographic>} cartographicPositions The\n   * cartographic positions\n   * @param {number} numPositions The number of positions (vertices)\n   * @param {Rectangle} cartographicBoundingRectangle The bounding\n   * rectangle of the cartographic positions\n   * @param {MapProjection} projection The projection that should be used\n   * @returns {ModelComponents.Attribute} The new attribute\n   */\n  static createTextureCoordinatesAttributeForMappedPositions(\n    mappedPositions,\n    projection,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"mappedPositions\", mappedPositions);\n    Check.defined(\"projection\", projection);\n    //>>includeEnd('debug');\n\n    // Create the typed array that contains the texture coordinates\n    const texCoordsTypedArray =\n      ModelImageryMapping.createTextureCoordinatesForMappedPositions(\n        mappedPositions,\n        projection,\n      );\n\n    // Create an attribute from the texture coordinates typed array\n    const texCoordAttribute =\n      ModelImageryMapping.createTexCoordAttribute(texCoordsTypedArray);\n\n    return texCoordAttribute;\n  }\n\n  /**\n   * Create an iterable that provides the cartographic positions\n   * of the given POSITION attribute, based on the given ellipsoid\n   *\n   * @param {ModelComponents.Attribute} primitivePositionAttribute\n   * The \"POSITION\" attribute of the primitive.\n   * @param {Matrix4} primitivePositionTransform The full transform of the primitive\n   * @param {Elliposid} ellipsoid The ellipsoid that should be used\n   * @returns {Iterable<Cartographic>} The iterable over `Cartographic` objects\n   */\n  static createCartographicPositions(\n    primitivePositionAttribute,\n    primitivePositionTransform,\n    ellipsoid,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"primitivePositionAttribute\", primitivePositionAttribute);\n    Check.defined(\"primitivePositionTransform\", primitivePositionTransform);\n    Check.defined(\"ellipsoid\", ellipsoid);\n    //>>includeEnd('debug');\n\n    // Extract the positions as a typed array\n    const typedArray = ModelReader.readAttributeAsTypedArray(\n      primitivePositionAttribute,\n    );\n\n    // Create an iterable over the positions\n    const type = primitivePositionAttribute.type;\n    const numComponents = AttributeType.getNumberOfComponents(type);\n    const positions =\n      ModelImageryMapping.createIterableCartesian3FromTypedArray(\n        typedArray,\n        numComponents,\n      );\n\n    // Compute the positions after they are transformed with the given matrix\n    const transformedPositions = ModelImageryMapping.transformCartesians3(\n      positions,\n      primitivePositionTransform,\n    );\n\n    // Compute the cartographic positions for the given ellipsoid\n    const cartographicPositions = ModelImageryMapping.transformToCartographic(\n      transformedPositions,\n      ellipsoid,\n    );\n    return cartographicPositions;\n  }\n\n  /**\n   * Creates an iterable over `Cartesian3` objects from the given\n   * typed array.\n   *\n   * The resulting iterable will always return the same `Cartesian3`\n   * object. Clients should not store and modify this object.\n   *\n   * @param {TypedArray} typedArray The typed array\n   * @param {number} stride The stride between to consecutive\n   * `Cartesian3` elements in the given array. Must be at least 3.\n   * @returns {Iterable<Cartesian3>} The iterable\n   */\n  static createIterableCartesian3FromTypedArray(typedArray, stride) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"typedArray\", typedArray);\n    Check.typeOf.number.greaterThanOrEquals(\"stride\", stride, 3);\n    //>>includeEnd('debug');\n\n    const cartesian = new Cartesian3();\n    const numElements = typedArray.length / stride;\n    const result = {\n      [Symbol.iterator]: function* () {\n        for (let i = 0; i < numElements; i++) {\n          cartesian.x = typedArray[i * stride + 0];\n          cartesian.y = typedArray[i * stride + 1];\n          cartesian.z = typedArray[i * stride + 2];\n          yield cartesian;\n        }\n      },\n    };\n    return result;\n  }\n\n  /**\n   * Creates a new iterable that applies the given mapper to the given iterable.\n   *\n   * @param {Iterable} iterable The input iterable\n   * @param {Function} mapper The mapper\n   * @returns {Iterable} The mapped iterable\n   */\n  static map(iterable, mapper) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"iterable\", iterable);\n    Check.defined(\"mapper\", mapper);\n    //>>includeEnd('debug');\n\n    const result = {\n      [Symbol.iterator]: function* () {\n        for (const element of iterable) {\n          yield mapper(element);\n        }\n      },\n    };\n    return result;\n  }\n\n  /**\n   * Computes the bounding rectangle of the given cartographic positions,\n   * stores it in the given result, and returns it.\n   *\n   * If the given result is `undefined`, a new rectangle will be created\n   * and returned.\n   *\n   * @param {Iterable<Cartographic>} cartographicPositions The cartographics\n   * @param {Rectangle} [result] The result\n   * @returns {Rectangle} The result\n   */\n  static computeCartographicBoundingRectangle(cartographicPositions, result) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"cartographicPositions\", cartographicPositions);\n    //>>includeEnd('debug');\n\n    if (!defined(result)) {\n      result = new Rectangle();\n    }\n    // One could store these directly in the result, but that would\n    // violate the constraint of the PI-related ranges..\n    let north = Number.NEGATIVE_INFINITY;\n    let south = Number.POSITIVE_INFINITY;\n    let east = Number.NEGATIVE_INFINITY;\n    let west = Number.POSITIVE_INFINITY;\n    for (const cartographicPosition of cartographicPositions) {\n      north = Math.max(north, cartographicPosition.latitude);\n      south = Math.min(south, cartographicPosition.latitude);\n      east = Math.max(east, cartographicPosition.longitude);\n      west = Math.min(west, cartographicPosition.longitude);\n    }\n    result.north = north;\n    result.south = south;\n    result.east = east;\n    result.west = west;\n    return result;\n  }\n\n  /**\n   * Creates a new iterable that provides `Cartesian3` objects that\n   * are created by transforming the `Cartesian3` objects of the\n   * given iterable with the given matrix.\n   *\n   * The resulting iterable will always return the same `Cartesian3`\n   * object. Clients should not store and modify this object.\n   *\n   * @param {Iterable<Cartesian3>} positions The positions\n   * @param {Matrix4} matrix The matrix\n   * @returns {Iterable<Cartesian3>} The transformed cartesians\n   */\n  static transformCartesians3(positions, matrix) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"positions\", positions);\n    Check.defined(\"matrix\", matrix);\n    //>>includeEnd('debug');\n\n    const transformedPosition = new Cartesian3();\n    const transformedPositions = ModelImageryMapping.map(positions, (p) => {\n      Matrix4.multiplyByPoint(matrix, p, transformedPosition);\n      return transformedPosition;\n    });\n    return transformedPositions;\n  }\n\n  /**\n   * Creates a new iterable that provides `Cartographic` objects that\n   * are created by converting the given `Cartesian3` objects to\n   * cartographics, based on the given ellipsoid.\n   *\n   * The resulting iterable will always return the same `Cartographic`\n   * object. Clients should not store and modify this object.\n   *\n   * @param {Iterable<Cartesian3>} positions The positions\n   * @param {Ellipsoid} ellipsoid The ellipsoid\n   * @returns {Iterable<Cartographic>} The cartographic positions\n   */\n  static transformToCartographic(positions, ellipsoid) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"positions\", positions);\n    Check.defined(\"ellipsoid\", ellipsoid);\n    //>>includeEnd('debug');\n\n    const cartographicPosition = new Cartographic();\n    const cartographicPositions = ModelImageryMapping.map(positions, (p) => {\n      // Note: This will not yield valid results for p=(0,0,0).\n      // But there is no sensible cartographic position for\n      // that, so simply accept the unspecified output here.\n      ellipsoid.cartesianToCartographic(p, cartographicPosition);\n      return cartographicPosition;\n    });\n    return cartographicPositions;\n  }\n\n  /**\n   * Creates an iterable over the results of applying the given projection\n   * to the given cartographic positions.\n   *\n   * The resulting iterable will always return the same `Cartesian3`\n   * object. Clients should not store and modify this object.\n   *\n   * @param {Iterable<Cartographic>} cartographicPositions The cartographic\n   * positions\n   * @param {MapProjection} projection The projection to use\n   * @returns {Iterable<Cartesian3>} The projected positions\n   */\n  static createProjectedPositions(cartographicPositions, projection) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"cartographicPositions\", cartographicPositions);\n    Check.defined(\"projection\", projection);\n    //>>includeEnd('debug');\n\n    const projectedPosition = new Cartesian3();\n    const projectedPositions = ModelImageryMapping.map(\n      cartographicPositions,\n      (c) => {\n        projection.project(c, projectedPosition);\n        return projectedPosition;\n      },\n    );\n    return projectedPositions;\n  }\n\n  /**\n   * Computes the texture coordinates for the given positions, relative\n   * to the given bounding rectangle.\n   *\n   * This will make the x/y coordinates of the given cartesians relative\n   * to the given bounding rectangle and clamp them to [0,0]-[1,1].\n   *\n   * NOTE: This could be broken down into\n   * 1. mapping to 2D\n   * 2. relativizing for the bounding recangle\n   * 3. clamping to [0,0]-[1,1]\n   *\n   * @param {Iterable<Cartesian3>} positions The positions\n   * @param {BoundingRectangle} boundingRectangle The rectangle\n   * @returns {Iterable<Cartesian2>} The texture coordinates\n   */\n  static computeTexCoords(positions, boundingRectangle) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"positions\", positions);\n    Check.defined(\"boundingRectangle\", boundingRectangle);\n    //>>includeEnd('debug');\n\n    const texCoord = new Cartesian2();\n    const invSizeX = 1.0 / boundingRectangle.width;\n    const invSizeY = 1.0 / boundingRectangle.height;\n    const texCoords = ModelImageryMapping.map(positions, (p) => {\n      const uRaw = (p.x - boundingRectangle.x) * invSizeX;\n      const vRaw = (p.y - boundingRectangle.y) * invSizeY;\n      const u = Math.min(Math.max(uRaw, 0.0), 1.0);\n      const v = Math.min(Math.max(vRaw, 0.0), 1.0);\n      texCoord.x = u;\n      texCoord.y = v;\n      return texCoord;\n    });\n    return texCoords;\n  }\n\n  /**\n   * Creates a new typed array from the given `Cartesian2` objects.\n   *\n   * @param {number} numElements The number of elements\n   * @param {Iterable<Cartesian2>} elements The elements\n   * @returns {TypedArray} The typed array\n   */\n  static createTypedArrayFromCartesians2(numElements, elements) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.typeOf.number.greaterThanOrEquals(\"numElements\", numElements, 0);\n    Check.defined(\"elements\", elements);\n    //>>includeEnd('debug');\n\n    const typedArray = new Float32Array(numElements * 2);\n    let index = 0;\n    for (const element of elements) {\n      typedArray[index * 2 + 0] = element.x;\n      typedArray[index * 2 + 1] = element.y;\n      index++;\n    }\n    return typedArray;\n  }\n\n  /**\n   * Create a new texture coordinates attribute from the given data.\n   *\n   * This will create an attribute with\n   * - semantic: VertexAttributeSemantic.TEXCOORD\n   * - type: AttributeType.VEC2\n   * - count: texCoordsTypedArray.length / 2\n   * that contains the data from the given typed array.\n   *\n   * @param {TypedArray} texCoordsTypedArray The typed array\n   * @returns {ModelComponents.Attribute} The attribute\n   */\n  static createTexCoordAttribute(texCoordsTypedArray) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"texCoordsTypedArray\", texCoordsTypedArray);\n    //>>includeEnd('debug');\n\n    const texCoordAttribute = {\n      name: \"Imagery Texture Coordinates\",\n      semantic: VertexAttributeSemantic.TEXCOORD,\n      setIndex: 0,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC2,\n      normalized: false,\n      count: texCoordsTypedArray.length / 2,\n      min: undefined,\n      max: undefined,\n      constant: new Cartesian2(0, 0),\n      quantization: undefined,\n      typedArray: texCoordsTypedArray,\n      byteOffset: 0,\n      byteStride: undefined,\n    };\n    return texCoordAttribute;\n  }\n}\nexport default ModelImageryMapping;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}