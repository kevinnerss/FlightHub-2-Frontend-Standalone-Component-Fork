{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\n\n/**\n * An availability bitstream for use in an {@link ImplicitSubtree}. This handles\n * both Uint8Array bitstreams and constant values.\n *\n * @alias ImplicitAvailabilityBitstream\n * @constructor\n *\n * @param {object} options An object with the following properties:\n * @param {number} options.lengthBits The length of the bitstream in bits\n * @param {boolean} [options.constant] A single boolean value indicating the value of all the bits in the bitstream if they are all the same\n * @param {Uint8Array} [options.bitstream] An array of bytes storing the bitstream in binary\n * @param {number} [options.availableCount] A number indicating how many 1 bits are found in the bitstream\n * @param {boolean} [options.computeAvailableCountEnabled=false] If true, and options.availableCount is undefined, the availableCount will be computed from the bitstream.\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction ImplicitAvailabilityBitstream(options) {\n  const lengthBits = options.lengthBits;\n  let availableCount = options.availableCount;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"options.lengthBits\", lengthBits);\n  //>>includeEnd('debug');\n\n  const constant = options.constant;\n  const bitstream = options.bitstream;\n  if (defined(constant)) {\n    // if defined, constant must be 1 which means all tiles are available\n    availableCount = lengthBits;\n  } else {\n    const expectedLength = Math.ceil(lengthBits / 8);\n    if (bitstream.length !== expectedLength) {\n      throw new RuntimeError(`Availability bitstream must be exactly ${expectedLength} bytes long to store ${lengthBits} bits. Actual bitstream was ${bitstream.length} bytes long.`);\n    }\n\n    // Only compute the available count if requested, as this involves looping\n    // over the bitstream.\n    const computeAvailableCountEnabled = options.computeAvailableCountEnabled ?? false;\n    if (!defined(availableCount) && computeAvailableCountEnabled) {\n      availableCount = count1Bits(bitstream, lengthBits);\n    }\n  }\n  this._lengthBits = lengthBits;\n  this._availableCount = availableCount;\n  this._constant = constant;\n  this._bitstream = bitstream;\n}\n\n/**\n * Count the number of bits with value 1 in the bitstream. This is used for\n * computing availableCount if not precomputed\n *\n * @param {Uint8Array} bitstream The bitstream typed array\n * @param {number} lengthBits How many bits are in the bitstream\n * @private\n */\nfunction count1Bits(bitstream, lengthBits) {\n  let count = 0;\n  for (let i = 0; i < lengthBits; i++) {\n    const byteIndex = i >> 3;\n    const bitIndex = i % 8;\n    count += bitstream[byteIndex] >> bitIndex & 1;\n  }\n  return count;\n}\nObject.defineProperties(ImplicitAvailabilityBitstream.prototype, {\n  /**\n   * The length of the bitstream in bits.\n   *\n   * @memberof ImplicitAvailabilityBitstream.prototype\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  lengthBits: {\n    get: function () {\n      return this._lengthBits;\n    }\n  },\n  /**\n   * The number of bits in the bitstream with value <code>1</code>.\n   *\n   * @memberof ImplicitAvailabilityBitstream.prototype\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  availableCount: {\n    get: function () {\n      return this._availableCount;\n    }\n  }\n});\n\n/**\n * Get a bit from the availability bitstream as a Boolean. If the bitstream\n * is a constant, the constant value is returned instead.\n *\n * @param {number} index The integer index of the bit.\n * @returns {boolean} The value of the bit\n * @private\n */\nImplicitAvailabilityBitstream.prototype.getBit = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (index < 0 || index >= this._lengthBits) {\n    throw new DeveloperError(\"Bit index out of bounds.\");\n  }\n  //>>includeEnd('debug');\n\n  if (defined(this._constant)) {\n    return this._constant;\n  }\n\n  // byteIndex is floor(index / 8)\n  const byteIndex = index >> 3;\n  const bitIndex = index % 8;\n  return (this._bitstream[byteIndex] >> bitIndex & 1) === 1;\n};\nexport default ImplicitAvailabilityBitstream;","map":{"version":3,"names":["Check","defined","DeveloperError","RuntimeError","ImplicitAvailabilityBitstream","options","lengthBits","availableCount","typeOf","number","constant","bitstream","expectedLength","Math","ceil","length","computeAvailableCountEnabled","count1Bits","_lengthBits","_availableCount","_constant","_bitstream","count","i","byteIndex","bitIndex","Object","defineProperties","prototype","get","getBit","index"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/ImplicitAvailabilityBitstream.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\n\n/**\n * An availability bitstream for use in an {@link ImplicitSubtree}. This handles\n * both Uint8Array bitstreams and constant values.\n *\n * @alias ImplicitAvailabilityBitstream\n * @constructor\n *\n * @param {object} options An object with the following properties:\n * @param {number} options.lengthBits The length of the bitstream in bits\n * @param {boolean} [options.constant] A single boolean value indicating the value of all the bits in the bitstream if they are all the same\n * @param {Uint8Array} [options.bitstream] An array of bytes storing the bitstream in binary\n * @param {number} [options.availableCount] A number indicating how many 1 bits are found in the bitstream\n * @param {boolean} [options.computeAvailableCountEnabled=false] If true, and options.availableCount is undefined, the availableCount will be computed from the bitstream.\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction ImplicitAvailabilityBitstream(options) {\n  const lengthBits = options.lengthBits;\n  let availableCount = options.availableCount;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"options.lengthBits\", lengthBits);\n  //>>includeEnd('debug');\n\n  const constant = options.constant;\n  const bitstream = options.bitstream;\n\n  if (defined(constant)) {\n    // if defined, constant must be 1 which means all tiles are available\n    availableCount = lengthBits;\n  } else {\n    const expectedLength = Math.ceil(lengthBits / 8);\n    if (bitstream.length !== expectedLength) {\n      throw new RuntimeError(\n        `Availability bitstream must be exactly ${expectedLength} bytes long to store ${lengthBits} bits. Actual bitstream was ${bitstream.length} bytes long.`,\n      );\n    }\n\n    // Only compute the available count if requested, as this involves looping\n    // over the bitstream.\n    const computeAvailableCountEnabled =\n      options.computeAvailableCountEnabled ?? false;\n    if (!defined(availableCount) && computeAvailableCountEnabled) {\n      availableCount = count1Bits(bitstream, lengthBits);\n    }\n  }\n\n  this._lengthBits = lengthBits;\n  this._availableCount = availableCount;\n  this._constant = constant;\n  this._bitstream = bitstream;\n}\n\n/**\n * Count the number of bits with value 1 in the bitstream. This is used for\n * computing availableCount if not precomputed\n *\n * @param {Uint8Array} bitstream The bitstream typed array\n * @param {number} lengthBits How many bits are in the bitstream\n * @private\n */\nfunction count1Bits(bitstream, lengthBits) {\n  let count = 0;\n  for (let i = 0; i < lengthBits; i++) {\n    const byteIndex = i >> 3;\n    const bitIndex = i % 8;\n    count += (bitstream[byteIndex] >> bitIndex) & 1;\n  }\n  return count;\n}\n\nObject.defineProperties(ImplicitAvailabilityBitstream.prototype, {\n  /**\n   * The length of the bitstream in bits.\n   *\n   * @memberof ImplicitAvailabilityBitstream.prototype\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  lengthBits: {\n    get: function () {\n      return this._lengthBits;\n    },\n  },\n  /**\n   * The number of bits in the bitstream with value <code>1</code>.\n   *\n   * @memberof ImplicitAvailabilityBitstream.prototype\n   *\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  availableCount: {\n    get: function () {\n      return this._availableCount;\n    },\n  },\n});\n\n/**\n * Get a bit from the availability bitstream as a Boolean. If the bitstream\n * is a constant, the constant value is returned instead.\n *\n * @param {number} index The integer index of the bit.\n * @returns {boolean} The value of the bit\n * @private\n */\nImplicitAvailabilityBitstream.prototype.getBit = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (index < 0 || index >= this._lengthBits) {\n    throw new DeveloperError(\"Bit index out of bounds.\");\n  }\n  //>>includeEnd('debug');\n\n  if (defined(this._constant)) {\n    return this._constant;\n  }\n\n  // byteIndex is floor(index / 8)\n  const byteIndex = index >> 3;\n  const bitIndex = index % 8;\n\n  return ((this._bitstream[byteIndex] >> bitIndex) & 1) === 1;\n};\n\nexport default ImplicitAvailabilityBitstream;\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,kBAAkB;AACpC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,YAAY,MAAM,yBAAyB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,6BAA6BA,CAACC,OAAO,EAAE;EAC9C,MAAMC,UAAU,GAAGD,OAAO,CAACC,UAAU;EACrC,IAAIC,cAAc,GAAGF,OAAO,CAACE,cAAc;;EAE3C;EACAP,KAAK,CAACQ,MAAM,CAACC,MAAM,CAAC,oBAAoB,EAAEH,UAAU,CAAC;EACrD;;EAEA,MAAMI,QAAQ,GAAGL,OAAO,CAACK,QAAQ;EACjC,MAAMC,SAAS,GAAGN,OAAO,CAACM,SAAS;EAEnC,IAAIV,OAAO,CAACS,QAAQ,CAAC,EAAE;IACrB;IACAH,cAAc,GAAGD,UAAU;EAC7B,CAAC,MAAM;IACL,MAAMM,cAAc,GAAGC,IAAI,CAACC,IAAI,CAACR,UAAU,GAAG,CAAC,CAAC;IAChD,IAAIK,SAAS,CAACI,MAAM,KAAKH,cAAc,EAAE;MACvC,MAAM,IAAIT,YAAY,CACpB,0CAA0CS,cAAc,wBAAwBN,UAAU,+BAA+BK,SAAS,CAACI,MAAM,cAC3I,CAAC;IACH;;IAEA;IACA;IACA,MAAMC,4BAA4B,GAChCX,OAAO,CAACW,4BAA4B,IAAI,KAAK;IAC/C,IAAI,CAACf,OAAO,CAACM,cAAc,CAAC,IAAIS,4BAA4B,EAAE;MAC5DT,cAAc,GAAGU,UAAU,CAACN,SAAS,EAAEL,UAAU,CAAC;IACpD;EACF;EAEA,IAAI,CAACY,WAAW,GAAGZ,UAAU;EAC7B,IAAI,CAACa,eAAe,GAAGZ,cAAc;EACrC,IAAI,CAACa,SAAS,GAAGV,QAAQ;EACzB,IAAI,CAACW,UAAU,GAAGV,SAAS;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASM,UAAUA,CAACN,SAAS,EAAEL,UAAU,EAAE;EACzC,IAAIgB,KAAK,GAAG,CAAC;EACb,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjB,UAAU,EAAEiB,CAAC,EAAE,EAAE;IACnC,MAAMC,SAAS,GAAGD,CAAC,IAAI,CAAC;IACxB,MAAME,QAAQ,GAAGF,CAAC,GAAG,CAAC;IACtBD,KAAK,IAAKX,SAAS,CAACa,SAAS,CAAC,IAAIC,QAAQ,GAAI,CAAC;EACjD;EACA,OAAOH,KAAK;AACd;AAEAI,MAAM,CAACC,gBAAgB,CAACvB,6BAA6B,CAACwB,SAAS,EAAE;EAC/D;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEtB,UAAU,EAAE;IACVuB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACX,WAAW;IACzB;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEX,cAAc,EAAE;IACdsB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACV,eAAe;IAC7B;EACF;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAf,6BAA6B,CAACwB,SAAS,CAACE,MAAM,GAAG,UAAUC,KAAK,EAAE;EAChE;EACA,IAAIA,KAAK,GAAG,CAAC,IAAIA,KAAK,IAAI,IAAI,CAACb,WAAW,EAAE;IAC1C,MAAM,IAAIhB,cAAc,CAAC,0BAA0B,CAAC;EACtD;EACA;;EAEA,IAAID,OAAO,CAAC,IAAI,CAACmB,SAAS,CAAC,EAAE;IAC3B,OAAO,IAAI,CAACA,SAAS;EACvB;;EAEA;EACA,MAAMI,SAAS,GAAGO,KAAK,IAAI,CAAC;EAC5B,MAAMN,QAAQ,GAAGM,KAAK,GAAG,CAAC;EAE1B,OAAO,CAAE,IAAI,CAACV,UAAU,CAACG,SAAS,CAAC,IAAIC,QAAQ,GAAI,CAAC,MAAM,CAAC;AAC7D,CAAC;AAED,eAAerB,6BAA6B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}