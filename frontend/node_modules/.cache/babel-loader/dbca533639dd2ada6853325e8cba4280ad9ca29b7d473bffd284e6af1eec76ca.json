{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport LinearSpline from \"./LinearSpline.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Spline from \"./Spline.js\";\nimport TridiagonalSystemSolver from \"./TridiagonalSystemSolver.js\";\nconst scratchLower = [];\nconst scratchDiagonal = [];\nconst scratchUpper = [];\nconst scratchRight = [];\nfunction generateClamped(points, firstTangent, lastTangent) {\n  const l = scratchLower;\n  const u = scratchUpper;\n  const d = scratchDiagonal;\n  const r = scratchRight;\n  l.length = u.length = points.length - 1;\n  d.length = r.length = points.length;\n  let i;\n  l[0] = d[0] = 1.0;\n  u[0] = 0.0;\n  let right = r[0];\n  if (!defined(right)) {\n    right = r[0] = new Cartesian3();\n  }\n  Cartesian3.clone(firstTangent, right);\n  for (i = 1; i < l.length - 1; ++i) {\n    l[i] = u[i] = 1.0;\n    d[i] = 4.0;\n    right = r[i];\n    if (!defined(right)) {\n      right = r[i] = new Cartesian3();\n    }\n    Cartesian3.subtract(points[i + 1], points[i - 1], right);\n    Cartesian3.multiplyByScalar(right, 3.0, right);\n  }\n  l[i] = 0.0;\n  u[i] = 1.0;\n  d[i] = 4.0;\n  right = r[i];\n  if (!defined(right)) {\n    right = r[i] = new Cartesian3();\n  }\n  Cartesian3.subtract(points[i + 1], points[i - 1], right);\n  Cartesian3.multiplyByScalar(right, 3.0, right);\n  d[i + 1] = 1.0;\n  right = r[i + 1];\n  if (!defined(right)) {\n    right = r[i + 1] = new Cartesian3();\n  }\n  Cartesian3.clone(lastTangent, right);\n  return TridiagonalSystemSolver.solve(l, d, u, r);\n}\nfunction generateNatural(points) {\n  const l = scratchLower;\n  const u = scratchUpper;\n  const d = scratchDiagonal;\n  const r = scratchRight;\n  l.length = u.length = points.length - 1;\n  d.length = r.length = points.length;\n  let i;\n  l[0] = u[0] = 1.0;\n  d[0] = 2.0;\n  let right = r[0];\n  if (!defined(right)) {\n    right = r[0] = new Cartesian3();\n  }\n  Cartesian3.subtract(points[1], points[0], right);\n  Cartesian3.multiplyByScalar(right, 3.0, right);\n  for (i = 1; i < l.length; ++i) {\n    l[i] = u[i] = 1.0;\n    d[i] = 4.0;\n    right = r[i];\n    if (!defined(right)) {\n      right = r[i] = new Cartesian3();\n    }\n    Cartesian3.subtract(points[i + 1], points[i - 1], right);\n    Cartesian3.multiplyByScalar(right, 3.0, right);\n  }\n  d[i] = 2.0;\n  right = r[i];\n  if (!defined(right)) {\n    right = r[i] = new Cartesian3();\n  }\n  Cartesian3.subtract(points[i], points[i - 1], right);\n  Cartesian3.multiplyByScalar(right, 3.0, right);\n  return TridiagonalSystemSolver.solve(l, d, u, r);\n}\n\n/**\n * A Hermite spline is a cubic interpolating spline. Points, incoming tangents, outgoing tangents, and times\n * must be defined for each control point. The outgoing tangents are defined for points [0, n - 2] and the incoming\n * tangents are defined for points [1, n - 1]. For example, when interpolating a segment of the curve between <code>points[i]</code> and\n * <code>points[i + 1]</code>, the tangents at the points will be <code>outTangents[i]</code> and <code>inTangents[i]</code>,\n * respectively.\n *\n * @alias HermiteSpline\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Cartesian3[]} options.points The array of control points.\n * @param {Cartesian3[]} options.inTangents The array of incoming tangents at each control point.\n * @param {Cartesian3[]} options.outTangents The array of outgoing tangents at each control point.\n *\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n * @exception {DeveloperError} inTangents and outTangents must have a length equal to points.length - 1.\n * @exception {DeveloperError} inTangents and outTangents must be of the same type as points.\n *\n * @example\n * // Create a G<sup>1</sup> continuous Hermite spline\n * const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * const spline = new Cesium.HermiteSpline({\n *     times : times,\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ],\n *     outTangents : [\n *         new Cesium.Cartesian3(1125196, -161816, 270551),\n *         new Cesium.Cartesian3(-996690.5, -365906.5, 184028.5),\n *         new Cesium.Cartesian3(-2096917, 48379.5, -292683.5),\n *         new Cesium.Cartesian3(-890902.5, 408999.5, -447115)\n *     ],\n *     inTangents : [\n *         new Cesium.Cartesian3(-1993381, -731813, 368057),\n *         new Cesium.Cartesian3(-4193834, 96759, -585367),\n *         new Cesium.Cartesian3(-1781805, 817999, -894230),\n *         new Cesium.Cartesian3(1165345, 112641, 47281)\n *     ]\n * });\n *\n * const p0 = spline.evaluate(times[0]);\n *\n * @see ConstantSpline\n * @see SteppedSpline\n * @see LinearSpline\n * @see CatmullRomSpline\n * @see QuaternionSpline\n * @see MorphWeightSpline\n */\nfunction HermiteSpline(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const points = options.points;\n  const times = options.times;\n  const inTangents = options.inTangents;\n  const outTangents = options.outTangents;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times) || !defined(inTangents) || !defined(outTangents)) {\n    throw new DeveloperError(\"times, points, inTangents, and outTangents are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\"points.length must be greater than or equal to 2.\");\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  if (inTangents.length !== outTangents.length || inTangents.length !== points.length - 1) {\n    throw new DeveloperError(\"inTangents and outTangents must have a length equal to points.length - 1.\");\n  }\n  //>>includeEnd('debug');\n\n  this._times = times;\n  this._points = points;\n  this._pointType = Spline.getPointType(points[0]);\n  //>>includeStart('debug', pragmas.debug);\n  if (this._pointType !== Spline.getPointType(inTangents[0]) || this._pointType !== Spline.getPointType(outTangents[0])) {\n    throw new DeveloperError(\"inTangents and outTangents must be of the same type as points.\");\n  }\n  //>>includeEnd('debug');\n\n  this._inTangents = inTangents;\n  this._outTangents = outTangents;\n  this._lastTimeIndex = 0;\n}\nObject.defineProperties(HermiteSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    }\n  },\n  /**\n   * An array of control points.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    }\n  },\n  /**\n   * An array of incoming tangents at each control point.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  inTangents: {\n    get: function () {\n      return this._inTangents;\n    }\n  },\n  /**\n   * An array of outgoing tangents at each control point.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  outTangents: {\n    get: function () {\n      return this._outTangents;\n    }\n  }\n});\n\n/**\n * Creates a spline where the tangents at each control point are the same.\n * The curves are guaranteed to be at least in the class C<sup>1</sup>.\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times The array of control point times.\n * @param {Cartesian3[]} options.points The array of control points.\n * @param {Cartesian3[]} options.tangents The array of tangents at the control points.\n * @returns {HermiteSpline} A hermite spline.\n *\n * @exception {DeveloperError} points, times and tangents are required.\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times, points and tangents must have the same length.\n *\n * @example\n * const points = [\n *     new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *     new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *     new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *     new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *     new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n * ];\n *\n * // Add tangents\n * const tangents = new Array(points.length);\n * tangents[0] = new Cesium.Cartesian3(1125196, -161816, 270551);\n * const temp = new Cesium.Cartesian3();\n * for (let i = 1; i < tangents.length - 1; ++i) {\n *     tangents[i] = Cesium.Cartesian3.multiplyByScalar(Cesium.Cartesian3.subtract(points[i + 1], points[i - 1], temp), 0.5, new Cesium.Cartesian3());\n * }\n * tangents[tangents.length - 1] = new Cesium.Cartesian3(1165345, 112641, 47281);\n *\n * const spline = Cesium.HermiteSpline.createC1({\n *     times : times,\n *     points : points,\n *     tangents : tangents\n * });\n */\nHermiteSpline.createC1 = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const times = options.times;\n  const points = options.points;\n  const tangents = options.tangents;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times) || !defined(tangents)) {\n    throw new DeveloperError(\"points, times and tangents are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\"points.length must be greater than or equal to 2.\");\n  }\n  if (times.length !== points.length || times.length !== tangents.length) {\n    throw new DeveloperError(\"times, points and tangents must have the same length.\");\n  }\n  //>>includeEnd('debug');\n\n  const outTangents = tangents.slice(0, tangents.length - 1);\n  const inTangents = tangents.slice(1, tangents.length);\n  return new HermiteSpline({\n    times: times,\n    points: points,\n    inTangents: inTangents,\n    outTangents: outTangents\n  });\n};\n\n/**\n * Creates a natural cubic spline. The tangents at the control points are generated\n * to create a curve in the class C<sup>2</sup>.\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times The array of control point times.\n * @param {Cartesian3[]} options.points The array of control points.\n * @returns {HermiteSpline|LinearSpline} A hermite spline, or a linear spline if less than 3 control points were given.\n *\n * @exception {DeveloperError} points and times are required.\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n * @example\n * // Create a natural cubic spline above the earth from Philadelphia to Los Angeles.\n * const spline = Cesium.HermiteSpline.createNaturalCubic({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n */\nHermiteSpline.createNaturalCubic = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const times = options.times;\n  const points = options.points;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times)) {\n    throw new DeveloperError(\"points and times are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\"points.length must be greater than or equal to 2.\");\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  //>>includeEnd('debug');\n\n  if (points.length < 3) {\n    return new LinearSpline({\n      points: points,\n      times: times\n    });\n  }\n  const tangents = generateNatural(points);\n  const outTangents = tangents.slice(0, tangents.length - 1);\n  const inTangents = tangents.slice(1, tangents.length);\n  return new HermiteSpline({\n    times: times,\n    points: points,\n    inTangents: inTangents,\n    outTangents: outTangents\n  });\n};\n\n/**\n * Creates a clamped cubic spline. The tangents at the interior control points are generated\n * to create a curve in the class C<sup>2</sup>.\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times The array of control point times.\n * @param {number[]|Cartesian3[]} options.points The array of control points.\n * @param {Cartesian3} options.firstTangent The outgoing tangent of the first control point.\n * @param {Cartesian3} options.lastTangent The incoming tangent of the last control point.\n * @returns {HermiteSpline|LinearSpline} A hermite spline, or a linear spline if less than 3 control points were given.\n *\n * @exception {DeveloperError} points, times, firstTangent and lastTangent are required.\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n * @exception {DeveloperError} firstTangent and lastTangent must be of the same type as points.\n *\n * @example\n * // Create a clamped cubic spline above the earth from Philadelphia to Los Angeles.\n * const spline = Cesium.HermiteSpline.createClampedCubic({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ],\n *     firstTangent : new Cesium.Cartesian3(1125196, -161816, 270551),\n *     lastTangent : new Cesium.Cartesian3(1165345, 112641, 47281)\n * });\n */\nHermiteSpline.createClampedCubic = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const times = options.times;\n  const points = options.points;\n  const firstTangent = options.firstTangent;\n  const lastTangent = options.lastTangent;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times) || !defined(firstTangent) || !defined(lastTangent)) {\n    throw new DeveloperError(\"points, times, firstTangent and lastTangent are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\"points.length must be greater than or equal to 2.\");\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  //>>includeEnd('debug');\n\n  const PointType = Spline.getPointType(points[0]);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (PointType !== Spline.getPointType(firstTangent) || PointType !== Spline.getPointType(lastTangent)) {\n    throw new DeveloperError(\"firstTangent and lastTangent must be of the same type as points.\");\n  }\n  //>>includeEnd('debug');\n\n  if (points.length < 3) {\n    return new LinearSpline({\n      points: points,\n      times: times\n    });\n  }\n  const tangents = generateClamped(points, firstTangent, lastTangent);\n  const outTangents = tangents.slice(0, tangents.length - 1);\n  const inTangents = tangents.slice(1, tangents.length);\n  return new HermiteSpline({\n    times: times,\n    points: points,\n    inTangents: inTangents,\n    outTangents: outTangents\n  });\n};\n\n//prettier-ignore\nHermiteSpline.hermiteCoefficientMatrix = new Matrix4(2.0, -3.0, 0.0, 1.0, -2.0, 3.0, 0.0, 0.0, 1.0, -2.0, 1.0, 0.0, 1.0, -1.0, 0.0, 0.0);\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {number} time The time.\n * @returns {number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nHermiteSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\nconst scratchTimeVec = new Cartesian4();\nconst scratchTemp = new Cartesian3();\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, wrapped around to the updated animation.\n */\nHermiteSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, clamped to the animation period.\n */\nHermiteSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {number} time The time at which to evaluate the curve.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nHermiteSpline.prototype.evaluate = function (time, result) {\n  const points = this.points;\n  const times = this.times;\n  const inTangents = this.inTangents;\n  const outTangents = this.outTangents;\n  this._lastTimeIndex = this.findTimeInterval(time, this._lastTimeIndex);\n  const i = this._lastTimeIndex;\n  const timesDelta = times[i + 1] - times[i];\n  const u = (time - times[i]) / timesDelta;\n  const timeVec = scratchTimeVec;\n  timeVec.z = u;\n  timeVec.y = u * u;\n  timeVec.x = timeVec.y * u;\n  timeVec.w = 1.0;\n\n  // Coefficients are returned in the following order:\n  // start, end, out-tangent, in-tangent\n  const coefs = Matrix4.multiplyByVector(HermiteSpline.hermiteCoefficientMatrix, timeVec, timeVec);\n\n  // Multiply the out-tangent and in-tangent values by the time delta.\n  coefs.z *= timesDelta;\n  coefs.w *= timesDelta;\n  const PointType = this._pointType;\n  if (PointType === Number) {\n    return points[i] * coefs.x + points[i + 1] * coefs.y + outTangents[i] * coefs.z + inTangents[i] * coefs.w;\n  }\n  if (!defined(result)) {\n    result = new PointType();\n  }\n  result = PointType.multiplyByScalar(points[i], coefs.x, result);\n  PointType.multiplyByScalar(points[i + 1], coefs.y, scratchTemp);\n  PointType.add(result, scratchTemp, result);\n  PointType.multiplyByScalar(outTangents[i], coefs.z, scratchTemp);\n  PointType.add(result, scratchTemp, result);\n  PointType.multiplyByScalar(inTangents[i], coefs.w, scratchTemp);\n  return PointType.add(result, scratchTemp, result);\n};\nexport default HermiteSpline;","map":{"version":3,"names":["Cartesian3","Cartesian4","Frozen","defined","DeveloperError","LinearSpline","Matrix4","Spline","TridiagonalSystemSolver","scratchLower","scratchDiagonal","scratchUpper","scratchRight","generateClamped","points","firstTangent","lastTangent","l","u","d","r","length","i","right","clone","subtract","multiplyByScalar","solve","generateNatural","HermiteSpline","options","EMPTY_OBJECT","times","inTangents","outTangents","_times","_points","_pointType","getPointType","_inTangents","_outTangents","_lastTimeIndex","Object","defineProperties","prototype","get","createC1","tangents","slice","createNaturalCubic","createClampedCubic","PointType","hermiteCoefficientMatrix","findTimeInterval","scratchTimeVec","scratchTemp","wrapTime","clampTime","evaluate","time","result","timesDelta","timeVec","z","y","x","w","coefs","multiplyByVector","Number","add"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/HermiteSpline.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport LinearSpline from \"./LinearSpline.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Spline from \"./Spline.js\";\nimport TridiagonalSystemSolver from \"./TridiagonalSystemSolver.js\";\n\nconst scratchLower = [];\nconst scratchDiagonal = [];\nconst scratchUpper = [];\nconst scratchRight = [];\n\nfunction generateClamped(points, firstTangent, lastTangent) {\n  const l = scratchLower;\n  const u = scratchUpper;\n  const d = scratchDiagonal;\n  const r = scratchRight;\n\n  l.length = u.length = points.length - 1;\n  d.length = r.length = points.length;\n\n  let i;\n  l[0] = d[0] = 1.0;\n  u[0] = 0.0;\n\n  let right = r[0];\n  if (!defined(right)) {\n    right = r[0] = new Cartesian3();\n  }\n  Cartesian3.clone(firstTangent, right);\n\n  for (i = 1; i < l.length - 1; ++i) {\n    l[i] = u[i] = 1.0;\n    d[i] = 4.0;\n\n    right = r[i];\n    if (!defined(right)) {\n      right = r[i] = new Cartesian3();\n    }\n    Cartesian3.subtract(points[i + 1], points[i - 1], right);\n    Cartesian3.multiplyByScalar(right, 3.0, right);\n  }\n\n  l[i] = 0.0;\n  u[i] = 1.0;\n  d[i] = 4.0;\n\n  right = r[i];\n  if (!defined(right)) {\n    right = r[i] = new Cartesian3();\n  }\n  Cartesian3.subtract(points[i + 1], points[i - 1], right);\n  Cartesian3.multiplyByScalar(right, 3.0, right);\n\n  d[i + 1] = 1.0;\n  right = r[i + 1];\n  if (!defined(right)) {\n    right = r[i + 1] = new Cartesian3();\n  }\n  Cartesian3.clone(lastTangent, right);\n\n  return TridiagonalSystemSolver.solve(l, d, u, r);\n}\n\nfunction generateNatural(points) {\n  const l = scratchLower;\n  const u = scratchUpper;\n  const d = scratchDiagonal;\n  const r = scratchRight;\n\n  l.length = u.length = points.length - 1;\n  d.length = r.length = points.length;\n\n  let i;\n  l[0] = u[0] = 1.0;\n  d[0] = 2.0;\n\n  let right = r[0];\n  if (!defined(right)) {\n    right = r[0] = new Cartesian3();\n  }\n  Cartesian3.subtract(points[1], points[0], right);\n  Cartesian3.multiplyByScalar(right, 3.0, right);\n\n  for (i = 1; i < l.length; ++i) {\n    l[i] = u[i] = 1.0;\n    d[i] = 4.0;\n\n    right = r[i];\n    if (!defined(right)) {\n      right = r[i] = new Cartesian3();\n    }\n    Cartesian3.subtract(points[i + 1], points[i - 1], right);\n    Cartesian3.multiplyByScalar(right, 3.0, right);\n  }\n\n  d[i] = 2.0;\n\n  right = r[i];\n  if (!defined(right)) {\n    right = r[i] = new Cartesian3();\n  }\n  Cartesian3.subtract(points[i], points[i - 1], right);\n  Cartesian3.multiplyByScalar(right, 3.0, right);\n\n  return TridiagonalSystemSolver.solve(l, d, u, r);\n}\n\n/**\n * A Hermite spline is a cubic interpolating spline. Points, incoming tangents, outgoing tangents, and times\n * must be defined for each control point. The outgoing tangents are defined for points [0, n - 2] and the incoming\n * tangents are defined for points [1, n - 1]. For example, when interpolating a segment of the curve between <code>points[i]</code> and\n * <code>points[i + 1]</code>, the tangents at the points will be <code>outTangents[i]</code> and <code>inTangents[i]</code>,\n * respectively.\n *\n * @alias HermiteSpline\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Cartesian3[]} options.points The array of control points.\n * @param {Cartesian3[]} options.inTangents The array of incoming tangents at each control point.\n * @param {Cartesian3[]} options.outTangents The array of outgoing tangents at each control point.\n *\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n * @exception {DeveloperError} inTangents and outTangents must have a length equal to points.length - 1.\n * @exception {DeveloperError} inTangents and outTangents must be of the same type as points.\n *\n * @example\n * // Create a G<sup>1</sup> continuous Hermite spline\n * const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * const spline = new Cesium.HermiteSpline({\n *     times : times,\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ],\n *     outTangents : [\n *         new Cesium.Cartesian3(1125196, -161816, 270551),\n *         new Cesium.Cartesian3(-996690.5, -365906.5, 184028.5),\n *         new Cesium.Cartesian3(-2096917, 48379.5, -292683.5),\n *         new Cesium.Cartesian3(-890902.5, 408999.5, -447115)\n *     ],\n *     inTangents : [\n *         new Cesium.Cartesian3(-1993381, -731813, 368057),\n *         new Cesium.Cartesian3(-4193834, 96759, -585367),\n *         new Cesium.Cartesian3(-1781805, 817999, -894230),\n *         new Cesium.Cartesian3(1165345, 112641, 47281)\n *     ]\n * });\n *\n * const p0 = spline.evaluate(times[0]);\n *\n * @see ConstantSpline\n * @see SteppedSpline\n * @see LinearSpline\n * @see CatmullRomSpline\n * @see QuaternionSpline\n * @see MorphWeightSpline\n */\nfunction HermiteSpline(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const points = options.points;\n  const times = options.times;\n  const inTangents = options.inTangents;\n  const outTangents = options.outTangents;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(points) ||\n    !defined(times) ||\n    !defined(inTangents) ||\n    !defined(outTangents)\n  ) {\n    throw new DeveloperError(\n      \"times, points, inTangents, and outTangents are required.\",\n    );\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\",\n    );\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  if (\n    inTangents.length !== outTangents.length ||\n    inTangents.length !== points.length - 1\n  ) {\n    throw new DeveloperError(\n      \"inTangents and outTangents must have a length equal to points.length - 1.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._times = times;\n  this._points = points;\n  this._pointType = Spline.getPointType(points[0]);\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    this._pointType !== Spline.getPointType(inTangents[0]) ||\n    this._pointType !== Spline.getPointType(outTangents[0])\n  ) {\n    throw new DeveloperError(\n      \"inTangents and outTangents must be of the same type as points.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._inTangents = inTangents;\n  this._outTangents = outTangents;\n\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(HermiteSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n  },\n\n  /**\n   * An array of control points.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    },\n  },\n\n  /**\n   * An array of incoming tangents at each control point.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  inTangents: {\n    get: function () {\n      return this._inTangents;\n    },\n  },\n\n  /**\n   * An array of outgoing tangents at each control point.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  outTangents: {\n    get: function () {\n      return this._outTangents;\n    },\n  },\n});\n\n/**\n * Creates a spline where the tangents at each control point are the same.\n * The curves are guaranteed to be at least in the class C<sup>1</sup>.\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times The array of control point times.\n * @param {Cartesian3[]} options.points The array of control points.\n * @param {Cartesian3[]} options.tangents The array of tangents at the control points.\n * @returns {HermiteSpline} A hermite spline.\n *\n * @exception {DeveloperError} points, times and tangents are required.\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times, points and tangents must have the same length.\n *\n * @example\n * const points = [\n *     new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *     new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *     new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *     new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *     new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n * ];\n *\n * // Add tangents\n * const tangents = new Array(points.length);\n * tangents[0] = new Cesium.Cartesian3(1125196, -161816, 270551);\n * const temp = new Cesium.Cartesian3();\n * for (let i = 1; i < tangents.length - 1; ++i) {\n *     tangents[i] = Cesium.Cartesian3.multiplyByScalar(Cesium.Cartesian3.subtract(points[i + 1], points[i - 1], temp), 0.5, new Cesium.Cartesian3());\n * }\n * tangents[tangents.length - 1] = new Cesium.Cartesian3(1165345, 112641, 47281);\n *\n * const spline = Cesium.HermiteSpline.createC1({\n *     times : times,\n *     points : points,\n *     tangents : tangents\n * });\n */\nHermiteSpline.createC1 = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const times = options.times;\n  const points = options.points;\n  const tangents = options.tangents;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times) || !defined(tangents)) {\n    throw new DeveloperError(\"points, times and tangents are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\",\n    );\n  }\n  if (times.length !== points.length || times.length !== tangents.length) {\n    throw new DeveloperError(\n      \"times, points and tangents must have the same length.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const outTangents = tangents.slice(0, tangents.length - 1);\n  const inTangents = tangents.slice(1, tangents.length);\n\n  return new HermiteSpline({\n    times: times,\n    points: points,\n    inTangents: inTangents,\n    outTangents: outTangents,\n  });\n};\n\n/**\n * Creates a natural cubic spline. The tangents at the control points are generated\n * to create a curve in the class C<sup>2</sup>.\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times The array of control point times.\n * @param {Cartesian3[]} options.points The array of control points.\n * @returns {HermiteSpline|LinearSpline} A hermite spline, or a linear spline if less than 3 control points were given.\n *\n * @exception {DeveloperError} points and times are required.\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n * @example\n * // Create a natural cubic spline above the earth from Philadelphia to Los Angeles.\n * const spline = Cesium.HermiteSpline.createNaturalCubic({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n */\nHermiteSpline.createNaturalCubic = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const times = options.times;\n  const points = options.points;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times)) {\n    throw new DeveloperError(\"points and times are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\",\n    );\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  //>>includeEnd('debug');\n\n  if (points.length < 3) {\n    return new LinearSpline({\n      points: points,\n      times: times,\n    });\n  }\n\n  const tangents = generateNatural(points);\n  const outTangents = tangents.slice(0, tangents.length - 1);\n  const inTangents = tangents.slice(1, tangents.length);\n\n  return new HermiteSpline({\n    times: times,\n    points: points,\n    inTangents: inTangents,\n    outTangents: outTangents,\n  });\n};\n\n/**\n * Creates a clamped cubic spline. The tangents at the interior control points are generated\n * to create a curve in the class C<sup>2</sup>.\n *\n * @param {object} options Object with the following properties:\n * @param {number[]} options.times The array of control point times.\n * @param {number[]|Cartesian3[]} options.points The array of control points.\n * @param {Cartesian3} options.firstTangent The outgoing tangent of the first control point.\n * @param {Cartesian3} options.lastTangent The incoming tangent of the last control point.\n * @returns {HermiteSpline|LinearSpline} A hermite spline, or a linear spline if less than 3 control points were given.\n *\n * @exception {DeveloperError} points, times, firstTangent and lastTangent are required.\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n * @exception {DeveloperError} firstTangent and lastTangent must be of the same type as points.\n *\n * @example\n * // Create a clamped cubic spline above the earth from Philadelphia to Los Angeles.\n * const spline = Cesium.HermiteSpline.createClampedCubic({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ],\n *     firstTangent : new Cesium.Cartesian3(1125196, -161816, 270551),\n *     lastTangent : new Cesium.Cartesian3(1165345, 112641, 47281)\n * });\n */\nHermiteSpline.createClampedCubic = function (options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  const times = options.times;\n  const points = options.points;\n  const firstTangent = options.firstTangent;\n  const lastTangent = options.lastTangent;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(points) ||\n    !defined(times) ||\n    !defined(firstTangent) ||\n    !defined(lastTangent)\n  ) {\n    throw new DeveloperError(\n      \"points, times, firstTangent and lastTangent are required.\",\n    );\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\",\n    );\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  //>>includeEnd('debug');\n\n  const PointType = Spline.getPointType(points[0]);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    PointType !== Spline.getPointType(firstTangent) ||\n    PointType !== Spline.getPointType(lastTangent)\n  ) {\n    throw new DeveloperError(\n      \"firstTangent and lastTangent must be of the same type as points.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (points.length < 3) {\n    return new LinearSpline({\n      points: points,\n      times: times,\n    });\n  }\n\n  const tangents = generateClamped(points, firstTangent, lastTangent);\n  const outTangents = tangents.slice(0, tangents.length - 1);\n  const inTangents = tangents.slice(1, tangents.length);\n\n  return new HermiteSpline({\n    times: times,\n    points: points,\n    inTangents: inTangents,\n    outTangents: outTangents,\n  });\n};\n\n//prettier-ignore\nHermiteSpline.hermiteCoefficientMatrix = new Matrix4(\n  2.0, -3.0, 0.0, 1.0,\n  -2.0, 3.0, 0.0, 0.0,\n  1.0, -2.0, 1.0, 0.0,\n  1.0, -1.0, 0.0, 0.0\n);\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {number} time The time.\n * @returns {number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nHermiteSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\nconst scratchTimeVec = new Cartesian4();\nconst scratchTemp = new Cartesian3();\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, wrapped around to the updated animation.\n */\nHermiteSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {number} time The time.\n * @return {number} The time, clamped to the animation period.\n */\nHermiteSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {number} time The time at which to evaluate the curve.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nHermiteSpline.prototype.evaluate = function (time, result) {\n  const points = this.points;\n  const times = this.times;\n  const inTangents = this.inTangents;\n  const outTangents = this.outTangents;\n\n  this._lastTimeIndex = this.findTimeInterval(time, this._lastTimeIndex);\n  const i = this._lastTimeIndex;\n\n  const timesDelta = times[i + 1] - times[i];\n  const u = (time - times[i]) / timesDelta;\n\n  const timeVec = scratchTimeVec;\n  timeVec.z = u;\n  timeVec.y = u * u;\n  timeVec.x = timeVec.y * u;\n  timeVec.w = 1.0;\n\n  // Coefficients are returned in the following order:\n  // start, end, out-tangent, in-tangent\n  const coefs = Matrix4.multiplyByVector(\n    HermiteSpline.hermiteCoefficientMatrix,\n    timeVec,\n    timeVec,\n  );\n\n  // Multiply the out-tangent and in-tangent values by the time delta.\n  coefs.z *= timesDelta;\n  coefs.w *= timesDelta;\n\n  const PointType = this._pointType;\n\n  if (PointType === Number) {\n    return (\n      points[i] * coefs.x +\n      points[i + 1] * coefs.y +\n      outTangents[i] * coefs.z +\n      inTangents[i] * coefs.w\n    );\n  }\n\n  if (!defined(result)) {\n    result = new PointType();\n  }\n\n  result = PointType.multiplyByScalar(points[i], coefs.x, result);\n  PointType.multiplyByScalar(points[i + 1], coefs.y, scratchTemp);\n  PointType.add(result, scratchTemp, result);\n  PointType.multiplyByScalar(outTangents[i], coefs.z, scratchTemp);\n  PointType.add(result, scratchTemp, result);\n  PointType.multiplyByScalar(inTangents[i], coefs.w, scratchTemp);\n  return PointType.add(result, scratchTemp, result);\n};\nexport default HermiteSpline;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}