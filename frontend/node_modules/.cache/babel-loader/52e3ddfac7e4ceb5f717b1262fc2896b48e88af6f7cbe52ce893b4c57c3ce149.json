{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Check from \"../Core/Check.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TexturePacker from \"../Core/TexturePacker.js\";\nimport Framebuffer from \"./Framebuffer.js\";\nimport Texture from \"./Texture.js\";\nconst defaultInitialDimensions = 16;\n\n/**\n * A TextureAtlas stores multiple images in one∂ texture and keeps\n * track of the texture coordinates for each image. A TextureAtlas is dynamic,\n * meaning new images can be added at any point in time.\n * Texture coordinates are subject to change if the texture atlas resizes, so it's\n * important to check {@link TextureAtlas#guid} before using old values.\n *\n * @alias TextureAtlas\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {PixelFormat} [options.pixelFormat=PixelFormat.RGBA] The pixel format of the texture.\n * @param {Sampler} [options.sampler=new Sampler()] Information about how to sample the texture.\n * @param {number} [options.borderWidthInPixels=1] The amount of spacing between adjacent images in pixels.\n * @param {Cartesian2} [options.initialSize=new Cartesian2(16.0, 16.0)] The initial side lengths of the texture.\n *\n * @exception {DeveloperError} borderWidthInPixels must be greater than or equal to zero.\n * @exception {DeveloperError} initialSize must be greater than zero.\n *\n * @private\n */\nfunction TextureAtlas(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const borderWidthInPixels = options.borderWidthInPixels ?? 1.0;\n  const initialSize = options.initialSize ?? new Cartesian2(defaultInitialDimensions, defaultInitialDimensions);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"options.borderWidthInPixels\", borderWidthInPixels, 0);\n  Check.typeOf.number.greaterThan(\"options.initialSize.x\", initialSize.x, 0);\n  Check.typeOf.number.greaterThan(\"options.initialSize.y\", initialSize.y, 0);\n  //>>includeEnd('debug');\n\n  this._pixelFormat = options.pixelFormat ?? PixelFormat.RGBA;\n  this._sampler = options.sampler;\n  this._borderWidthInPixels = borderWidthInPixels;\n  this._initialSize = initialSize;\n  this._texturePacker = undefined;\n  this._rectangles = [];\n  this._subRegions = new Map();\n  this._guid = createGuid();\n  this._imagesToAddQueue = [];\n  this._indexById = new Map();\n  this._indexPromiseById = new Map();\n  this._nextIndex = 0;\n}\nObject.defineProperties(TextureAtlas.prototype, {\n  /**\n   * The amount of spacing between adjacent images in pixels.\n   * @memberof TextureAtlas.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  borderWidthInPixels: {\n    get: function () {\n      return this._borderWidthInPixels;\n    }\n  },\n  /**\n   * An array of {@link BoundingRectangle} pixel offset and dimensions for all the images in the texture atlas.\n   * The x and y values of the rectangle correspond to the bottom-left corner of the texture coordinate.\n   * If the index is a subregion of an existing image, thea and y values are specified as offsets relative to the parent.\n   * The coordinates are in the order that the corresponding images were added to the atlas.\n   * @memberof TextureAtlas.prototype\n   * @type {BoundingRectangle[]}\n   * @readonly\n   * @private\n   */\n  rectangles: {\n    get: function () {\n      return this._rectangles;\n    }\n  },\n  /**\n   * The texture that all of the images are being written to. The value will be <code>undefined</code> until the first update.\n   * @memberof TextureAtlas.prototype\n   * @type {Texture|undefined}\n   * @readonly\n   * @private\n   */\n  texture: {\n    get: function () {\n      return this._texture;\n    }\n  },\n  /**\n   * The pixel format of the texture.\n   * @memberof TextureAtlas.prototype\n   * @type {PixelFormat}\n   * @readonly\n   * @private\n   */\n  pixelFormat: {\n    get: function () {\n      return this._pixelFormat;\n    }\n  },\n  /**\n   * The sampler to use when sampling this texture. If <code>undefined</code>, the default sampler is used.\n   * @memberof TextureAtlas.prototype\n   * @type {Sampler|undefined}\n   * @readonly\n   * @private\n   */\n  sampler: {\n    get: function () {\n      return this._sampler;\n    }\n  },\n  /**\n   * The number of images in the texture atlas. This value increases\n   * every time addImage or addImageSubRegion is called.\n   * Texture coordinates are subject to change if the texture atlas resizes, so it is\n   * important to check {@link TextureAtlas#guid} before using old values.\n   * @memberof TextureAtlas.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  numberOfImages: {\n    get: function () {\n      return this._nextIndex;\n    }\n  },\n  /**\n   * The atlas' globally unique identifier (GUID).\n   * The GUID changes whenever the texture atlas is modified.\n   * Classes that use a texture atlas should check if the GUID\n   * has changed before processing the atlas data.\n   * @memberof TextureAtlas.prototype\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  guid: {\n    get: function () {\n      return this._guid;\n    }\n  },\n  /**\n   * Returns the size in bytes of the texture.\n   * @memberof TextureAtlas.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  sizeInBytes: {\n    get: function () {\n      if (!defined(this._texture)) {\n        return 0;\n      }\n      return this._texture.sizeInBytes;\n    }\n  }\n});\n\n/**\n * Get the texture coordinates for reading the associated image in shaders.\n * @param {number} index The index of the image region.\n * @param {BoundingRectangle} [result] The object into which to store the result.\n * @return {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n * @private\n * @example\n * const index = await atlas.addImage(\"myImage\", image);\n * const rectangle = atlas.computeTextureCoordinates(index);\n * BoundingRectangle.pack(rectangle, bufferView);\n */\nTextureAtlas.prototype.computeTextureCoordinates = function (index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  //>>includeEnd('debug');\n\n  const texture = this._texture;\n  const rectangle = this._rectangles[index];\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n  if (!defined(rectangle)) {\n    result.x = 0;\n    result.y = 0;\n    result.width = 0;\n    result.height = 0;\n    return result;\n  }\n  const atlasWidth = texture.width;\n  const atlasHeight = texture.height;\n  const width = rectangle.width;\n  const height = rectangle.height;\n  let x = rectangle.x;\n  let y = rectangle.y;\n  const parentIndex = this._subRegions.get(index);\n  if (defined(parentIndex)) {\n    const parentRectangle = this._rectangles[parentIndex];\n    x += parentRectangle.x;\n    y += parentRectangle.y;\n  }\n  result.x = x / atlasWidth;\n  result.y = y / atlasHeight;\n  result.width = width / atlasWidth;\n  result.height = height / atlasHeight;\n  return result;\n};\n\n/**\n * Perform a WebGL texture copy for each existing image from its previous packed position to its new packed position in the new texture.\n * @param {Context} context The rendering context\n * @param {number} width The pixel width of the texture\n * @param {number} height The pixel height of the texture\n * @param {BoundingRectangle[]} rectangles The packed bounding rectangles for the reszied texture\n * @param {number} queueOffset Index of the last queued item that was successfully packed\n * @private\n */\nTextureAtlas.prototype._copyFromTexture = function (context, width, height, rectangles) {\n  const pixelFormat = this._pixelFormat;\n  const sampler = this._sampler;\n  const newTexture = new Texture({\n    context,\n    height,\n    width,\n    pixelFormat,\n    sampler\n  });\n  const gl = context._gl;\n  const target = newTexture._textureTarget;\n  const oldTexture = this._texture;\n  const framebuffer = new Framebuffer({\n    context,\n    colorTextures: [oldTexture],\n    destroyAttachments: false\n  });\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, newTexture._texture);\n  framebuffer._bind();\n\n  // Copy any textures from the old atlas to its new position in the new atlas\n  const oldRectangles = this.rectangles;\n  const subRegions = this._subRegions;\n  for (let index = 0; index < oldRectangles.length; ++index) {\n    const rectangle = rectangles[index];\n    const frameBufferOffset = oldRectangles[index];\n    if (!defined(rectangle) || !defined(frameBufferOffset) || defined(subRegions.get(index)) // The rectangle corresponds to a subregion of a parent image\n    ) {\n      continue;\n    }\n    const {\n      x,\n      y,\n      width,\n      height\n    } = rectangle;\n    gl.copyTexSubImage2D(target, 0, x, y, frameBufferOffset.x, frameBufferOffset.y, width, height);\n  }\n  gl.bindTexture(target, null);\n  newTexture._initialized = true;\n  framebuffer._unBind();\n  framebuffer.destroy();\n  return newTexture;\n};\n\n/**\n * Recreates the texture atlas texture with new dimensions and repacks images as needed.\n * @param {Context} context The rendering context\n * @param {number} [queueOffset = 0] Index of the last queued item that was successfully packed\n * @private\n */\nTextureAtlas.prototype._resize = function (context, queueOffset = 0) {\n  const borderPadding = this._borderWidthInPixels;\n  const oldRectangles = this._rectangles;\n  const queue = this._imagesToAddQueue;\n  const oldTexture = this._texture;\n  let width = oldTexture.width;\n  let height = oldTexture.height;\n\n  // Get the rectangles (width and height) of the current set of images,\n  // ignoring the subregions, which don't get packed\n  const subRegions = this._subRegions;\n  const toPack = oldRectangles.map((image, index) => {\n    return new AddImageRequest({\n      index,\n      image\n    });\n  }).filter((request, index) => defined(request.image) && !defined(subRegions.get(index)));\n\n  // Add the new set of images\n  let maxWidth = 0;\n  let maxHeight = 0;\n  let areaQueued = 0;\n  for (let i = queueOffset; i < queue.length; ++i) {\n    const {\n      width,\n      height\n    } = queue[i].image;\n    maxWidth = Math.max(maxWidth, width);\n    maxHeight = Math.max(maxHeight, height);\n    areaQueued += width * height;\n    toPack.push(queue[i]);\n  }\n\n  // At minimum, the texture will need to scale to accommodate the largest width and height\n  width = Math.max(maxWidth, width);\n  height = Math.max(maxHeight, height);\n  if (!context.webgl2) {\n    width = CesiumMath.nextPowerOfTwo(width);\n    height = CesiumMath.nextPowerOfTwo(height);\n  }\n\n  // Determine by what factor the texture need to be scaled by at minimum\n  const areaDifference = areaQueued;\n  let scalingFactor = 1.0;\n  while (areaDifference / width / height >= 1.0) {\n    scalingFactor *= 2.0;\n\n    // Resize by one dimension\n    if (width > height) {\n      height *= scalingFactor;\n    } else {\n      width *= scalingFactor;\n    }\n  }\n  toPack.sort(({\n    image: imageA\n  }, {\n    image: imageB\n  }) => imageB.height * imageB.width - imageA.height * imageA.width);\n  const newRectangles = new Array(this._nextIndex);\n  for (const index of this._subRegions.keys()) {\n    // Subregions are specified relative to their parents,\n    // so we can copy them directly\n    if (defined(subRegions.get(index))) {\n      newRectangles[index] = oldRectangles[index];\n    }\n  }\n  let texturePacker,\n    packed = false;\n  while (!packed) {\n    texturePacker = new TexturePacker({\n      height,\n      width,\n      borderPadding\n    });\n    let i;\n    for (i = 0; i < toPack.length; ++i) {\n      const {\n        index,\n        image\n      } = toPack[i];\n      if (!defined(image)) {\n        continue;\n      }\n      const repackedNode = texturePacker.pack(index, image);\n      if (!defined(repackedNode)) {\n        // Could not fit everything into the new texture.\n        // Scale texture size and try again\n        if (width > height) {\n          // Resize height\n          height *= 2.0;\n        } else {\n          // Resize width\n          width *= 2.0;\n        }\n        break;\n      }\n      newRectangles[index] = repackedNode.rectangle;\n    }\n    packed = i === toPack.length;\n  }\n  this._texturePacker = texturePacker;\n  this._texture = this._copyFromTexture(context, width, height, newRectangles);\n  oldTexture.destroy();\n  this._rectangles = newRectangles;\n  this._guid = createGuid();\n};\n\n/**\n * Return the index of the image region for the specified ID. If the image is already in the atlas, the existing index is returned. Otherwise, the result is undefined.\n * @param {string} id An identifier to detect whether the image already exists in the atlas.\n * @returns {number|undefined} The image index, or undefined if the image does not exist in the atlas.\n * @private\n */\nTextureAtlas.prototype.getImageIndex = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"id\", id);\n  //>>includeEnd('debug');\n\n  return this._indexById.get(id);\n};\n\n/**\n * Copy image data into the underlying texture atlas.\n * @param {AddImageRequest} imageRequest The data needed to resolve the call to addImage in the queue\n * @private\n */\nTextureAtlas.prototype._copyImageToTexture = function ({\n  index,\n  image,\n  resolve,\n  reject\n}) {\n  const texture = this._texture;\n  const rectangle = this._rectangles[index];\n  try {\n    texture.copyFrom({\n      source: image,\n      xOffset: rectangle.x,\n      yOffset: rectangle.y\n    });\n    if (defined(resolve)) {\n      resolve(index);\n    }\n  } catch (e) {\n    if (defined(reject)) {\n      reject(e);\n      return;\n    }\n  }\n};\n\n/**\n * Info needed to add a queued image to the texture atlas when update operatons are executed, typically at the end of a frame.\n * @constructor\n * @private\n * @param {object} options Object with the following properties:\n * @param {number} options.index An identifier\n * @param {TexturePacker.PackableObject} options.image An object, such as an <code>Image</code> with <code>width</code> and <code>height</code> properties in pixels\n * @param {function} [options.resolve] The promise resolver\n * @param {function} [options.reject] The promise rejecter\n */\nfunction AddImageRequest({\n  index,\n  image,\n  resolve,\n  reject\n}) {\n  this.index = index;\n  this.image = image;\n  this.resolve = resolve;\n  this.reject = reject;\n  this.rectangle = undefined;\n}\n\n/**\n * Adds an image to the queue for this frame.\n * The image will be copied to the texture at the end of the frame, resizing the texture if needed.\n *\n * @private\n * @param {number} index An identifier\n * @param {TexturePacker.PackableObject} image An object, such as an <code>Image</code> with <code>width</code> and <code>height</code> properties in pixels\n * @returns {Promise<number>} Promise which resolves to the image index once the image has been added, or rejects if there was an error. The promise resolves to <code>-1</code> if the texture atlas is destoyed in the interim.\n */\nTextureAtlas.prototype._addImage = function (index, image) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.defined(\"image\", image);\n  //>>includeEnd('debug');\n\n  return new Promise((resolve, reject) => {\n    this._imagesToAddQueue.push(new AddImageRequest({\n      index,\n      image,\n      resolve,\n      reject\n    }));\n    this._imagesToAddQueue.sort(({\n      image: imageA\n    }, {\n      image: imageB\n    }) => imageB.height * imageB.width - imageA.height * imageA.width);\n  });\n};\n\n/**\n * Process the image queue for this frame, copying to the texture atlas and resizing the texture as needed.\n * @private\n * @param {Context} context The rendering context\n * @return {boolean} true if the texture was updated this frame\n */\nTextureAtlas.prototype._processImageQueue = function (context) {\n  const queue = this._imagesToAddQueue;\n  if (queue.length === 0) {\n    return false;\n  }\n  this._rectangles.length = this._nextIndex;\n  let i, error;\n  for (i = 0; i < queue.length; ++i) {\n    const imageRequest = queue[i];\n    const {\n      image,\n      index\n    } = imageRequest;\n    const node = this._texturePacker.pack(index, image);\n    if (!defined(node)) {\n      // Atlas cannot fit all images in the queue\n      // Bail early and resize\n      try {\n        this._resize(context, i);\n      } catch (e) {\n        error = e;\n        if (defined(imageRequest.reject)) {\n          imageRequest.reject(error);\n        }\n      }\n      break;\n    }\n    this._rectangles[index] = node.rectangle;\n  }\n  if (defined(error)) {\n    for (i = i + 1; i < queue.length; ++i) {\n      const {\n        resolve\n      } = queue[i];\n      if (defined(resolve)) {\n        resolve(-1);\n      }\n    }\n    queue.length = 0;\n    return false;\n  }\n  for (let i = 0; i < queue.length; ++i) {\n    this._copyImageToTexture(queue[i]);\n  }\n  queue.length = 0;\n  return true;\n};\n\n/**\n * Processes any updates queued this frame, and updates rendering resources accordingly. Call before or after a frame has been rendered to avoid any race conditions for any dependant render commands.\n * @private\n * @param {Context} context The rendering context\n * @return {boolean} true if rendering resources were updated.\n */\nTextureAtlas.prototype.update = function (context) {\n  if (!defined(this._texture)) {\n    const width = this._initialSize.x;\n    const height = this._initialSize.y;\n    const pixelFormat = this._pixelFormat;\n    const sampler = this._sampler;\n    const borderPadding = this._borderWidthInPixels;\n    this._texture = new Texture({\n      context,\n      width,\n      height,\n      pixelFormat,\n      sampler\n    });\n    this._texturePacker = new TexturePacker({\n      height,\n      width,\n      borderPadding\n    });\n  }\n  return this._processImageQueue(context);\n};\nasync function resolveImage(image, id) {\n  if (typeof image === \"function\") {\n    image = image(id);\n  }\n  if (typeof image === \"string\" || image instanceof Resource) {\n    // Fetch the resource\n    const resource = Resource.createIfNeeded(image);\n    image = resource.fetchImage();\n  }\n  return image;\n}\n\n/**\n * Adds an image to the atlas.  If the image is already in the atlas, the atlas is unchanged and\n * the existing index is used.\n * @private\n * @param {string} id An identifier to detect whether the image already exists in the atlas.\n * @param {HTMLImageElement|HTMLCanvasElement|string|Resource|Promise|TextureAtlas.CreateImageCallback} image An image or canvas to add to the texture atlas,\n *        or a URL to an Image, or a Promise for an image, or a function that creates an image.\n * @returns {Promise<number>} A Promise that resolves to the image region index. -1 is returned if resouces are in the process of being destroyed.\n */\nTextureAtlas.prototype.addImage = function (id, image) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"id\", id);\n  Check.defined(\"image\", image);\n  //>>includeEnd('debug');\n\n  let promise = this._indexPromiseById.get(id);\n  if (defined(promise)) {\n    // This image has already been added\n    return promise;\n  }\n  const index = this._nextIndex++;\n  this._indexById.set(id, index);\n  const resolveAndAddImage = async () => {\n    image = await resolveImage(image, id);\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"image\", image);\n    //>>includeEnd('debug');\n\n    if (this.isDestroyed() || !defined(image)) {\n      return -1;\n    }\n    return this._addImage(index, image);\n  };\n  promise = resolveAndAddImage();\n  this._indexPromiseById.set(id, promise);\n  return promise;\n};\n\n/**\n * Add a sub-region of an existing atlas image as additional image indices.\n * @private\n * @param {string} id The identifier of the existing image.\n * @param {BoundingRectangle} subRegion An {@link BoundingRectangle} defining a region of an existing image, measured in pixels from the bottom-left of the image.\n * @returns {Promise<number>} A Promise that resolves to the image region index. -1 is returned if resouces are in the process of being destroyed.\n */\nTextureAtlas.prototype.addImageSubRegion = function (id, subRegion) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"id\", id);\n  Check.defined(\"subRegion\", subRegion);\n  //>>includeEnd('debug');\n\n  const imageIndex = this._indexById.get(id);\n  if (!defined(imageIndex)) {\n    throw new RuntimeError(`image with id \"${id}\" not found in the atlas.`);\n  }\n  const indexPromise = this._indexPromiseById.get(id);\n  for (const [index, parentIndex] of this._subRegions.entries()) {\n    if (imageIndex === parentIndex) {\n      const boundingRegion = this._rectangles[index];\n      if (boundingRegion.equals(subRegion)) {\n        // The subregion is already being tracked\n        return indexPromise.then(resolvedImageIndex => {\n          if (resolvedImageIndex === -1) {\n            // The atlas has been destroyed\n            return -1;\n          }\n          return index;\n        });\n      }\n    }\n  }\n  const index = this._nextIndex++;\n  this._subRegions.set(index, imageIndex);\n  this._rectangles[index] = subRegion.clone();\n  return indexPromise.then(imageIndex => {\n    if (imageIndex === -1) {\n      // The atlas has been destroyed\n      return -1;\n    }\n    const rectangle = this._rectangles[imageIndex];\n\n    //>>includeStart('debug', pragmas.debug);\n    Check.typeOf.number.lessThanOrEquals(\"subRegion.x\", subRegion.x, rectangle.width);\n    Check.typeOf.number.lessThanOrEquals(\"subRegion.x + subRegion.width\", subRegion.x + subRegion.width, rectangle.width);\n    Check.typeOf.number.lessThanOrEquals(\"subRegion.y\", subRegion.y, rectangle.height);\n    Check.typeOf.number.lessThanOrEquals(\"subRegion.y + subRegion.height\", subRegion.y + subRegion.height, rectangle.height);\n    //>>includeEnd('debug');\n\n    return index;\n  });\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * @private\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n * @see TextureAtlas#destroy\n */\nTextureAtlas.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * @private\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n * @example\n * atlas = atlas && atlas.destroy();\n * @see TextureAtlas#isDestroyed\n */\nTextureAtlas.prototype.destroy = function () {\n  this._texture = this._texture && this._texture.destroy();\n  this._imagesToAddQueue.forEach(({\n    resolve\n  }) => {\n    if (defined(resolve)) {\n      resolve(-1);\n    }\n  });\n  return destroyObject(this);\n};\n\n/**\n * A function that creates an image.\n * @private\n * @callback TextureAtlas.CreateImageCallback\n * @param {string} id The identifier of the image to load.\n * @returns {HTMLImageElement|Promise<HTMLImageElement>} The image, or a promise that will resolve to an image.\n */\n\nexport default TextureAtlas;","map":{"version":3,"names":["BoundingRectangle","Cartesian2","Check","createGuid","Frozen","defined","destroyObject","CesiumMath","PixelFormat","Resource","RuntimeError","TexturePacker","Framebuffer","Texture","defaultInitialDimensions","TextureAtlas","options","EMPTY_OBJECT","borderWidthInPixels","initialSize","typeOf","number","greaterThanOrEquals","greaterThan","x","y","_pixelFormat","pixelFormat","RGBA","_sampler","sampler","_borderWidthInPixels","_initialSize","_texturePacker","undefined","_rectangles","_subRegions","Map","_guid","_imagesToAddQueue","_indexById","_indexPromiseById","_nextIndex","Object","defineProperties","prototype","get","rectangles","texture","_texture","numberOfImages","guid","sizeInBytes","computeTextureCoordinates","index","result","rectangle","width","height","atlasWidth","atlasHeight","parentIndex","parentRectangle","_copyFromTexture","context","newTexture","gl","_gl","target","_textureTarget","oldTexture","framebuffer","colorTextures","destroyAttachments","activeTexture","TEXTURE0","bindTexture","_bind","oldRectangles","subRegions","length","frameBufferOffset","copyTexSubImage2D","_initialized","_unBind","destroy","_resize","queueOffset","borderPadding","queue","toPack","map","image","AddImageRequest","filter","request","maxWidth","maxHeight","areaQueued","i","Math","max","push","webgl2","nextPowerOfTwo","areaDifference","scalingFactor","sort","imageA","imageB","newRectangles","Array","keys","texturePacker","packed","repackedNode","pack","getImageIndex","id","string","_copyImageToTexture","resolve","reject","copyFrom","source","xOffset","yOffset","e","_addImage","Promise","_processImageQueue","error","imageRequest","node","update","resolveImage","resource","createIfNeeded","fetchImage","addImage","promise","set","resolveAndAddImage","isDestroyed","addImageSubRegion","subRegion","imageIndex","indexPromise","entries","boundingRegion","equals","then","resolvedImageIndex","clone","lessThanOrEquals","forEach"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Renderer/TextureAtlas.js"],"sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Check from \"../Core/Check.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport Frozen from \"../Core/Frozen.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TexturePacker from \"../Core/TexturePacker.js\";\nimport Framebuffer from \"./Framebuffer.js\";\nimport Texture from \"./Texture.js\";\n\nconst defaultInitialDimensions = 16;\n\n/**\n * A TextureAtlas stores multiple images in one∂ texture and keeps\n * track of the texture coordinates for each image. A TextureAtlas is dynamic,\n * meaning new images can be added at any point in time.\n * Texture coordinates are subject to change if the texture atlas resizes, so it's\n * important to check {@link TextureAtlas#guid} before using old values.\n *\n * @alias TextureAtlas\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {PixelFormat} [options.pixelFormat=PixelFormat.RGBA] The pixel format of the texture.\n * @param {Sampler} [options.sampler=new Sampler()] Information about how to sample the texture.\n * @param {number} [options.borderWidthInPixels=1] The amount of spacing between adjacent images in pixels.\n * @param {Cartesian2} [options.initialSize=new Cartesian2(16.0, 16.0)] The initial side lengths of the texture.\n *\n * @exception {DeveloperError} borderWidthInPixels must be greater than or equal to zero.\n * @exception {DeveloperError} initialSize must be greater than zero.\n *\n * @private\n */\nfunction TextureAtlas(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  const borderWidthInPixels = options.borderWidthInPixels ?? 1.0;\n  const initialSize =\n    options.initialSize ??\n    new Cartesian2(defaultInitialDimensions, defaultInitialDimensions);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\n    \"options.borderWidthInPixels\",\n    borderWidthInPixels,\n    0,\n  );\n  Check.typeOf.number.greaterThan(\"options.initialSize.x\", initialSize.x, 0);\n  Check.typeOf.number.greaterThan(\"options.initialSize.y\", initialSize.y, 0);\n  //>>includeEnd('debug');\n\n  this._pixelFormat = options.pixelFormat ?? PixelFormat.RGBA;\n  this._sampler = options.sampler;\n  this._borderWidthInPixels = borderWidthInPixels;\n  this._initialSize = initialSize;\n\n  this._texturePacker = undefined;\n  this._rectangles = [];\n  this._subRegions = new Map();\n  this._guid = createGuid();\n\n  this._imagesToAddQueue = [];\n  this._indexById = new Map();\n  this._indexPromiseById = new Map();\n  this._nextIndex = 0;\n}\n\nObject.defineProperties(TextureAtlas.prototype, {\n  /**\n   * The amount of spacing between adjacent images in pixels.\n   * @memberof TextureAtlas.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  borderWidthInPixels: {\n    get: function () {\n      return this._borderWidthInPixels;\n    },\n  },\n\n  /**\n   * An array of {@link BoundingRectangle} pixel offset and dimensions for all the images in the texture atlas.\n   * The x and y values of the rectangle correspond to the bottom-left corner of the texture coordinate.\n   * If the index is a subregion of an existing image, thea and y values are specified as offsets relative to the parent.\n   * The coordinates are in the order that the corresponding images were added to the atlas.\n   * @memberof TextureAtlas.prototype\n   * @type {BoundingRectangle[]}\n   * @readonly\n   * @private\n   */\n  rectangles: {\n    get: function () {\n      return this._rectangles;\n    },\n  },\n\n  /**\n   * The texture that all of the images are being written to. The value will be <code>undefined</code> until the first update.\n   * @memberof TextureAtlas.prototype\n   * @type {Texture|undefined}\n   * @readonly\n   * @private\n   */\n  texture: {\n    get: function () {\n      return this._texture;\n    },\n  },\n\n  /**\n   * The pixel format of the texture.\n   * @memberof TextureAtlas.prototype\n   * @type {PixelFormat}\n   * @readonly\n   * @private\n   */\n  pixelFormat: {\n    get: function () {\n      return this._pixelFormat;\n    },\n  },\n\n  /**\n   * The sampler to use when sampling this texture. If <code>undefined</code>, the default sampler is used.\n   * @memberof TextureAtlas.prototype\n   * @type {Sampler|undefined}\n   * @readonly\n   * @private\n   */\n  sampler: {\n    get: function () {\n      return this._sampler;\n    },\n  },\n\n  /**\n   * The number of images in the texture atlas. This value increases\n   * every time addImage or addImageSubRegion is called.\n   * Texture coordinates are subject to change if the texture atlas resizes, so it is\n   * important to check {@link TextureAtlas#guid} before using old values.\n   * @memberof TextureAtlas.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  numberOfImages: {\n    get: function () {\n      return this._nextIndex;\n    },\n  },\n\n  /**\n   * The atlas' globally unique identifier (GUID).\n   * The GUID changes whenever the texture atlas is modified.\n   * Classes that use a texture atlas should check if the GUID\n   * has changed before processing the atlas data.\n   * @memberof TextureAtlas.prototype\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  guid: {\n    get: function () {\n      return this._guid;\n    },\n  },\n\n  /**\n   * Returns the size in bytes of the texture.\n   * @memberof TextureAtlas.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  sizeInBytes: {\n    get: function () {\n      if (!defined(this._texture)) {\n        return 0;\n      }\n\n      return this._texture.sizeInBytes;\n    },\n  },\n});\n\n/**\n * Get the texture coordinates for reading the associated image in shaders.\n * @param {number} index The index of the image region.\n * @param {BoundingRectangle} [result] The object into which to store the result.\n * @return {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.\n * @private\n * @example\n * const index = await atlas.addImage(\"myImage\", image);\n * const rectangle = atlas.computeTextureCoordinates(index);\n * BoundingRectangle.pack(rectangle, bufferView);\n */\nTextureAtlas.prototype.computeTextureCoordinates = function (index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  //>>includeEnd('debug');\n\n  const texture = this._texture;\n  const rectangle = this._rectangles[index];\n\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n\n  if (!defined(rectangle)) {\n    result.x = 0;\n    result.y = 0;\n    result.width = 0;\n    result.height = 0;\n\n    return result;\n  }\n\n  const atlasWidth = texture.width;\n  const atlasHeight = texture.height;\n\n  const width = rectangle.width;\n  const height = rectangle.height;\n  let x = rectangle.x;\n  let y = rectangle.y;\n\n  const parentIndex = this._subRegions.get(index);\n  if (defined(parentIndex)) {\n    const parentRectangle = this._rectangles[parentIndex];\n\n    x += parentRectangle.x;\n    y += parentRectangle.y;\n  }\n\n  result.x = x / atlasWidth;\n  result.y = y / atlasHeight;\n  result.width = width / atlasWidth;\n  result.height = height / atlasHeight;\n\n  return result;\n};\n\n/**\n * Perform a WebGL texture copy for each existing image from its previous packed position to its new packed position in the new texture.\n * @param {Context} context The rendering context\n * @param {number} width The pixel width of the texture\n * @param {number} height The pixel height of the texture\n * @param {BoundingRectangle[]} rectangles The packed bounding rectangles for the reszied texture\n * @param {number} queueOffset Index of the last queued item that was successfully packed\n * @private\n */\nTextureAtlas.prototype._copyFromTexture = function (\n  context,\n  width,\n  height,\n  rectangles,\n) {\n  const pixelFormat = this._pixelFormat;\n  const sampler = this._sampler;\n  const newTexture = new Texture({\n    context,\n    height,\n    width,\n    pixelFormat,\n    sampler,\n  });\n\n  const gl = context._gl;\n  const target = newTexture._textureTarget;\n\n  const oldTexture = this._texture;\n  const framebuffer = new Framebuffer({\n    context,\n    colorTextures: [oldTexture],\n    destroyAttachments: false,\n  });\n\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, newTexture._texture);\n\n  framebuffer._bind();\n\n  // Copy any textures from the old atlas to its new position in the new atlas\n  const oldRectangles = this.rectangles;\n  const subRegions = this._subRegions;\n  for (let index = 0; index < oldRectangles.length; ++index) {\n    const rectangle = rectangles[index];\n    const frameBufferOffset = oldRectangles[index];\n\n    if (\n      !defined(rectangle) ||\n      !defined(frameBufferOffset) ||\n      defined(subRegions.get(index)) // The rectangle corresponds to a subregion of a parent image\n    ) {\n      continue;\n    }\n\n    const { x, y, width, height } = rectangle;\n    gl.copyTexSubImage2D(\n      target,\n      0,\n      x,\n      y,\n      frameBufferOffset.x,\n      frameBufferOffset.y,\n      width,\n      height,\n    );\n  }\n\n  gl.bindTexture(target, null);\n  newTexture._initialized = true;\n\n  framebuffer._unBind();\n  framebuffer.destroy();\n\n  return newTexture;\n};\n\n/**\n * Recreates the texture atlas texture with new dimensions and repacks images as needed.\n * @param {Context} context The rendering context\n * @param {number} [queueOffset = 0] Index of the last queued item that was successfully packed\n * @private\n */\nTextureAtlas.prototype._resize = function (context, queueOffset = 0) {\n  const borderPadding = this._borderWidthInPixels;\n  const oldRectangles = this._rectangles;\n  const queue = this._imagesToAddQueue;\n\n  const oldTexture = this._texture;\n  let width = oldTexture.width;\n  let height = oldTexture.height;\n\n  // Get the rectangles (width and height) of the current set of images,\n  // ignoring the subregions, which don't get packed\n  const subRegions = this._subRegions;\n  const toPack = oldRectangles\n    .map((image, index) => {\n      return new AddImageRequest({ index, image });\n    })\n    .filter(\n      (request, index) =>\n        defined(request.image) && !defined(subRegions.get(index)),\n    );\n\n  // Add the new set of images\n  let maxWidth = 0;\n  let maxHeight = 0;\n  let areaQueued = 0;\n  for (let i = queueOffset; i < queue.length; ++i) {\n    const { width, height } = queue[i].image;\n    maxWidth = Math.max(maxWidth, width);\n    maxHeight = Math.max(maxHeight, height);\n    areaQueued += width * height;\n    toPack.push(queue[i]);\n  }\n\n  // At minimum, the texture will need to scale to accommodate the largest width and height\n  width = Math.max(maxWidth, width);\n  height = Math.max(maxHeight, height);\n\n  if (!context.webgl2) {\n    width = CesiumMath.nextPowerOfTwo(width);\n    height = CesiumMath.nextPowerOfTwo(height);\n  }\n\n  // Determine by what factor the texture need to be scaled by at minimum\n  const areaDifference = areaQueued;\n  let scalingFactor = 1.0;\n  while (areaDifference / width / height >= 1.0) {\n    scalingFactor *= 2.0;\n\n    // Resize by one dimension\n    if (width > height) {\n      height *= scalingFactor;\n    } else {\n      width *= scalingFactor;\n    }\n  }\n\n  toPack.sort(\n    ({ image: imageA }, { image: imageB }) =>\n      imageB.height * imageB.width - imageA.height * imageA.width,\n  );\n\n  const newRectangles = new Array(this._nextIndex);\n  for (const index of this._subRegions.keys()) {\n    // Subregions are specified relative to their parents,\n    // so we can copy them directly\n    if (defined(subRegions.get(index))) {\n      newRectangles[index] = oldRectangles[index];\n    }\n  }\n\n  let texturePacker,\n    packed = false;\n  while (!packed) {\n    texturePacker = new TexturePacker({ height, width, borderPadding });\n\n    let i;\n    for (i = 0; i < toPack.length; ++i) {\n      const { index, image } = toPack[i];\n      if (!defined(image)) {\n        continue;\n      }\n\n      const repackedNode = texturePacker.pack(index, image);\n      if (!defined(repackedNode)) {\n        // Could not fit everything into the new texture.\n        // Scale texture size and try again\n        if (width > height) {\n          // Resize height\n          height *= 2.0;\n        } else {\n          // Resize width\n          width *= 2.0;\n        }\n\n        break;\n      }\n\n      newRectangles[index] = repackedNode.rectangle;\n    }\n\n    packed = i === toPack.length;\n  }\n\n  this._texturePacker = texturePacker;\n  this._texture = this._copyFromTexture(context, width, height, newRectangles);\n\n  oldTexture.destroy();\n\n  this._rectangles = newRectangles;\n  this._guid = createGuid();\n};\n\n/**\n * Return the index of the image region for the specified ID. If the image is already in the atlas, the existing index is returned. Otherwise, the result is undefined.\n * @param {string} id An identifier to detect whether the image already exists in the atlas.\n * @returns {number|undefined} The image index, or undefined if the image does not exist in the atlas.\n * @private\n */\nTextureAtlas.prototype.getImageIndex = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"id\", id);\n  //>>includeEnd('debug');\n\n  return this._indexById.get(id);\n};\n\n/**\n * Copy image data into the underlying texture atlas.\n * @param {AddImageRequest} imageRequest The data needed to resolve the call to addImage in the queue\n * @private\n */\nTextureAtlas.prototype._copyImageToTexture = function ({\n  index,\n  image,\n  resolve,\n  reject,\n}) {\n  const texture = this._texture;\n  const rectangle = this._rectangles[index];\n\n  try {\n    texture.copyFrom({\n      source: image,\n      xOffset: rectangle.x,\n      yOffset: rectangle.y,\n    });\n\n    if (defined(resolve)) {\n      resolve(index);\n    }\n  } catch (e) {\n    if (defined(reject)) {\n      reject(e);\n      return;\n    }\n  }\n};\n\n/**\n * Info needed to add a queued image to the texture atlas when update operatons are executed, typically at the end of a frame.\n * @constructor\n * @private\n * @param {object} options Object with the following properties:\n * @param {number} options.index An identifier\n * @param {TexturePacker.PackableObject} options.image An object, such as an <code>Image</code> with <code>width</code> and <code>height</code> properties in pixels\n * @param {function} [options.resolve] The promise resolver\n * @param {function} [options.reject] The promise rejecter\n */\nfunction AddImageRequest({ index, image, resolve, reject }) {\n  this.index = index;\n  this.image = image;\n  this.resolve = resolve;\n  this.reject = reject;\n  this.rectangle = undefined;\n}\n\n/**\n * Adds an image to the queue for this frame.\n * The image will be copied to the texture at the end of the frame, resizing the texture if needed.\n *\n * @private\n * @param {number} index An identifier\n * @param {TexturePacker.PackableObject} image An object, such as an <code>Image</code> with <code>width</code> and <code>height</code> properties in pixels\n * @returns {Promise<number>} Promise which resolves to the image index once the image has been added, or rejects if there was an error. The promise resolves to <code>-1</code> if the texture atlas is destoyed in the interim.\n */\nTextureAtlas.prototype._addImage = function (index, image) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.defined(\"image\", image);\n  //>>includeEnd('debug');\n\n  return new Promise((resolve, reject) => {\n    this._imagesToAddQueue.push(\n      new AddImageRequest({\n        index,\n        image,\n        resolve,\n        reject,\n      }),\n    );\n\n    this._imagesToAddQueue.sort(\n      ({ image: imageA }, { image: imageB }) =>\n        imageB.height * imageB.width - imageA.height * imageA.width,\n    );\n  });\n};\n\n/**\n * Process the image queue for this frame, copying to the texture atlas and resizing the texture as needed.\n * @private\n * @param {Context} context The rendering context\n * @return {boolean} true if the texture was updated this frame\n */\nTextureAtlas.prototype._processImageQueue = function (context) {\n  const queue = this._imagesToAddQueue;\n  if (queue.length === 0) {\n    return false;\n  }\n\n  this._rectangles.length = this._nextIndex;\n\n  let i, error;\n  for (i = 0; i < queue.length; ++i) {\n    const imageRequest = queue[i];\n    const { image, index } = imageRequest;\n    const node = this._texturePacker.pack(index, image);\n    if (!defined(node)) {\n      // Atlas cannot fit all images in the queue\n      // Bail early and resize\n      try {\n        this._resize(context, i);\n      } catch (e) {\n        error = e;\n\n        if (defined(imageRequest.reject)) {\n          imageRequest.reject(error);\n        }\n      }\n      break;\n    }\n    this._rectangles[index] = node.rectangle;\n  }\n\n  if (defined(error)) {\n    for (i = i + 1; i < queue.length; ++i) {\n      const { resolve } = queue[i];\n      if (defined(resolve)) {\n        resolve(-1);\n      }\n    }\n\n    queue.length = 0;\n    return false;\n  }\n\n  for (let i = 0; i < queue.length; ++i) {\n    this._copyImageToTexture(queue[i]);\n  }\n\n  queue.length = 0;\n  return true;\n};\n\n/**\n * Processes any updates queued this frame, and updates rendering resources accordingly. Call before or after a frame has been rendered to avoid any race conditions for any dependant render commands.\n * @private\n * @param {Context} context The rendering context\n * @return {boolean} true if rendering resources were updated.\n */\nTextureAtlas.prototype.update = function (context) {\n  if (!defined(this._texture)) {\n    const width = this._initialSize.x;\n    const height = this._initialSize.y;\n    const pixelFormat = this._pixelFormat;\n    const sampler = this._sampler;\n    const borderPadding = this._borderWidthInPixels;\n\n    this._texture = new Texture({\n      context,\n      width,\n      height,\n      pixelFormat,\n      sampler,\n    });\n\n    this._texturePacker = new TexturePacker({\n      height,\n      width,\n      borderPadding,\n    });\n  }\n\n  return this._processImageQueue(context);\n};\n\nasync function resolveImage(image, id) {\n  if (typeof image === \"function\") {\n    image = image(id);\n  }\n\n  if (typeof image === \"string\" || image instanceof Resource) {\n    // Fetch the resource\n    const resource = Resource.createIfNeeded(image);\n    image = resource.fetchImage();\n  }\n\n  return image;\n}\n\n/**\n * Adds an image to the atlas.  If the image is already in the atlas, the atlas is unchanged and\n * the existing index is used.\n * @private\n * @param {string} id An identifier to detect whether the image already exists in the atlas.\n * @param {HTMLImageElement|HTMLCanvasElement|string|Resource|Promise|TextureAtlas.CreateImageCallback} image An image or canvas to add to the texture atlas,\n *        or a URL to an Image, or a Promise for an image, or a function that creates an image.\n * @returns {Promise<number>} A Promise that resolves to the image region index. -1 is returned if resouces are in the process of being destroyed.\n */\nTextureAtlas.prototype.addImage = function (id, image) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"id\", id);\n  Check.defined(\"image\", image);\n  //>>includeEnd('debug');\n\n  let promise = this._indexPromiseById.get(id);\n  if (defined(promise)) {\n    // This image has already been added\n    return promise;\n  }\n\n  const index = this._nextIndex++;\n  this._indexById.set(id, index);\n\n  const resolveAndAddImage = async () => {\n    image = await resolveImage(image, id);\n    //>>includeStart('debug', pragmas.debug);\n    Check.defined(\"image\", image);\n    //>>includeEnd('debug');\n\n    if (this.isDestroyed() || !defined(image)) {\n      return -1;\n    }\n\n    return this._addImage(index, image);\n  };\n\n  promise = resolveAndAddImage();\n  this._indexPromiseById.set(id, promise);\n  return promise;\n};\n\n/**\n * Add a sub-region of an existing atlas image as additional image indices.\n * @private\n * @param {string} id The identifier of the existing image.\n * @param {BoundingRectangle} subRegion An {@link BoundingRectangle} defining a region of an existing image, measured in pixels from the bottom-left of the image.\n * @returns {Promise<number>} A Promise that resolves to the image region index. -1 is returned if resouces are in the process of being destroyed.\n */\nTextureAtlas.prototype.addImageSubRegion = function (id, subRegion) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"id\", id);\n  Check.defined(\"subRegion\", subRegion);\n  //>>includeEnd('debug');\n\n  const imageIndex = this._indexById.get(id);\n  if (!defined(imageIndex)) {\n    throw new RuntimeError(`image with id \"${id}\" not found in the atlas.`);\n  }\n\n  const indexPromise = this._indexPromiseById.get(id);\n  for (const [index, parentIndex] of this._subRegions.entries()) {\n    if (imageIndex === parentIndex) {\n      const boundingRegion = this._rectangles[index];\n      if (boundingRegion.equals(subRegion)) {\n        // The subregion is already being tracked\n        return indexPromise.then((resolvedImageIndex) => {\n          if (resolvedImageIndex === -1) {\n            // The atlas has been destroyed\n            return -1;\n          }\n\n          return index;\n        });\n      }\n    }\n  }\n\n  const index = this._nextIndex++;\n  this._subRegions.set(index, imageIndex);\n  this._rectangles[index] = subRegion.clone();\n\n  return indexPromise.then((imageIndex) => {\n    if (imageIndex === -1) {\n      // The atlas has been destroyed\n      return -1;\n    }\n\n    const rectangle = this._rectangles[imageIndex];\n\n    //>>includeStart('debug', pragmas.debug);\n    Check.typeOf.number.lessThanOrEquals(\n      \"subRegion.x\",\n      subRegion.x,\n      rectangle.width,\n    );\n    Check.typeOf.number.lessThanOrEquals(\n      \"subRegion.x + subRegion.width\",\n      subRegion.x + subRegion.width,\n      rectangle.width,\n    );\n    Check.typeOf.number.lessThanOrEquals(\n      \"subRegion.y\",\n      subRegion.y,\n      rectangle.height,\n    );\n    Check.typeOf.number.lessThanOrEquals(\n      \"subRegion.y + subRegion.height\",\n      subRegion.y + subRegion.height,\n      rectangle.height,\n    );\n    //>>includeEnd('debug');\n\n    return index;\n  });\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * @private\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n * @see TextureAtlas#destroy\n */\nTextureAtlas.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * @private\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n * @example\n * atlas = atlas && atlas.destroy();\n * @see TextureAtlas#isDestroyed\n */\nTextureAtlas.prototype.destroy = function () {\n  this._texture = this._texture && this._texture.destroy();\n  this._imagesToAddQueue.forEach(({ resolve }) => {\n    if (defined(resolve)) {\n      resolve(-1);\n    }\n  });\n\n  return destroyObject(this);\n};\n\n/**\n * A function that creates an image.\n * @private\n * @callback TextureAtlas.CreateImageCallback\n * @param {string} id The identifier of the image to load.\n * @returns {HTMLImageElement|Promise<HTMLImageElement>} The image, or a promise that will resolve to an image.\n */\n\nexport default TextureAtlas;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}