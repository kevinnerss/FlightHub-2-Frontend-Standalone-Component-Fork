{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Intersect from \"./Intersect.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * Creates an instance of an OrientedBoundingBox.\n * An OrientedBoundingBox of some object is a closed and convex rectangular cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.\n * @alias OrientedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.\n * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.\n *                                          Equivalently, the transformation matrix, to rotate and scale a 2x2x2\n *                                          cube centered at the origin.\n *\n *\n * @example\n * // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.\n * const center = new Cesium.Cartesian3(1.0, 0.0, 0.0);\n * const halfAxes = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(1.0, 3.0, 2.0), new Cesium.Matrix3());\n *\n * const obb = new Cesium.OrientedBoundingBox(center, halfAxes);\n *\n * @see BoundingSphere\n * @see BoundingRectangle\n */\nfunction OrientedBoundingBox(center, halfAxes) {\n  /**\n   * The center of the box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.center = Cartesian3.clone(center ?? Cartesian3.ZERO);\n  /**\n   * The three orthogonal half-axes of the bounding box. Equivalently, the\n   * transformation matrix, to rotate and scale a 2x2x2 cube centered at the\n   * origin.\n   * @type {Matrix3}\n   * @default {@link Matrix3.ZERO}\n   */\n  this.halfAxes = Matrix3.clone(halfAxes ?? Matrix3.ZERO);\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nOrientedBoundingBox.packedLength = Cartesian3.packedLength + Matrix3.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {OrientedBoundingBox} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nOrientedBoundingBox.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n  Cartesian3.pack(value.center, array, startingIndex);\n  Matrix3.pack(value.halfAxes, array, startingIndex + Cartesian3.packedLength);\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {OrientedBoundingBox} [result] The object into which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n */\nOrientedBoundingBox.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n  Cartesian3.unpack(array, startingIndex, result.center);\n  Matrix3.unpack(array, startingIndex + Cartesian3.packedLength, result.halfAxes);\n  return result;\n};\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartesian4 = new Cartesian3();\nconst scratchCartesian5 = new Cartesian3();\nconst scratchCartesian6 = new Cartesian3();\nconst scratchCovarianceResult = new Matrix3();\nconst scratchEigenResult = {\n  unitary: new Matrix3(),\n  diagonal: new Matrix3()\n};\n\n/**\n * Computes an instance of an OrientedBoundingBox of the given positions.\n * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\n * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\n *\n * @param {Cartesian3[]} [positions] List of {@link Cartesian3} points that the bounding box will enclose.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n *\n * @example\n * // Compute an object oriented bounding box enclosing two points.\n * const box = Cesium.OrientedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\n */\nOrientedBoundingBox.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n  if (!defined(positions) || positions.length === 0) {\n    result.halfAxes = Matrix3.ZERO;\n    result.center = Cartesian3.ZERO;\n    return result;\n  }\n  let i;\n  const length = positions.length;\n  const meanPoint = Cartesian3.clone(positions[0], scratchCartesian1);\n  for (i = 1; i < length; i++) {\n    Cartesian3.add(meanPoint, positions[i], meanPoint);\n  }\n  const invLength = 1.0 / length;\n  Cartesian3.multiplyByScalar(meanPoint, invLength, meanPoint);\n  let exx = 0.0;\n  let exy = 0.0;\n  let exz = 0.0;\n  let eyy = 0.0;\n  let eyz = 0.0;\n  let ezz = 0.0;\n  let p;\n  for (i = 0; i < length; i++) {\n    p = Cartesian3.subtract(positions[i], meanPoint, scratchCartesian2);\n    exx += p.x * p.x;\n    exy += p.x * p.y;\n    exz += p.x * p.z;\n    eyy += p.y * p.y;\n    eyz += p.y * p.z;\n    ezz += p.z * p.z;\n  }\n  exx *= invLength;\n  exy *= invLength;\n  exz *= invLength;\n  eyy *= invLength;\n  eyz *= invLength;\n  ezz *= invLength;\n  const covarianceMatrix = scratchCovarianceResult;\n  covarianceMatrix[0] = exx;\n  covarianceMatrix[1] = exy;\n  covarianceMatrix[2] = exz;\n  covarianceMatrix[3] = exy;\n  covarianceMatrix[4] = eyy;\n  covarianceMatrix[5] = eyz;\n  covarianceMatrix[6] = exz;\n  covarianceMatrix[7] = eyz;\n  covarianceMatrix[8] = ezz;\n  const eigenDecomposition = Matrix3.computeEigenDecomposition(covarianceMatrix, scratchEigenResult);\n  const rotation = Matrix3.clone(eigenDecomposition.unitary, result.halfAxes);\n  let v1 = Matrix3.getColumn(rotation, 0, scratchCartesian4);\n  let v2 = Matrix3.getColumn(rotation, 1, scratchCartesian5);\n  let v3 = Matrix3.getColumn(rotation, 2, scratchCartesian6);\n  let u1 = -Number.MAX_VALUE;\n  let u2 = -Number.MAX_VALUE;\n  let u3 = -Number.MAX_VALUE;\n  let l1 = Number.MAX_VALUE;\n  let l2 = Number.MAX_VALUE;\n  let l3 = Number.MAX_VALUE;\n  for (i = 0; i < length; i++) {\n    p = positions[i];\n    u1 = Math.max(Cartesian3.dot(v1, p), u1);\n    u2 = Math.max(Cartesian3.dot(v2, p), u2);\n    u3 = Math.max(Cartesian3.dot(v3, p), u3);\n    l1 = Math.min(Cartesian3.dot(v1, p), l1);\n    l2 = Math.min(Cartesian3.dot(v2, p), l2);\n    l3 = Math.min(Cartesian3.dot(v3, p), l3);\n  }\n  v1 = Cartesian3.multiplyByScalar(v1, 0.5 * (l1 + u1), v1);\n  v2 = Cartesian3.multiplyByScalar(v2, 0.5 * (l2 + u2), v2);\n  v3 = Cartesian3.multiplyByScalar(v3, 0.5 * (l3 + u3), v3);\n  const center = Cartesian3.add(v1, v2, result.center);\n  Cartesian3.add(center, v3, center);\n  const scale = scratchCartesian3;\n  scale.x = u1 - l1;\n  scale.y = u2 - l2;\n  scale.z = u3 - l3;\n  Cartesian3.multiplyByScalar(scale, 0.5, scale);\n  Matrix3.multiplyByScale(result.halfAxes, scale, result.halfAxes);\n  return result;\n};\nconst scratchOffset = new Cartesian3();\nconst scratchScale = new Cartesian3();\nfunction fromPlaneExtents(planeOrigin, planeXAxis, planeYAxis, planeZAxis, minimumX, maximumX, minimumY, maximumY, minimumZ, maximumZ, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(minimumX) || !defined(maximumX) || !defined(minimumY) || !defined(maximumY) || !defined(minimumZ) || !defined(maximumZ)) {\n    throw new DeveloperError(\"all extents (minimum/maximum X/Y/Z) are required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n  const halfAxes = result.halfAxes;\n  Matrix3.setColumn(halfAxes, 0, planeXAxis, halfAxes);\n  Matrix3.setColumn(halfAxes, 1, planeYAxis, halfAxes);\n  Matrix3.setColumn(halfAxes, 2, planeZAxis, halfAxes);\n  let centerOffset = scratchOffset;\n  centerOffset.x = (minimumX + maximumX) / 2.0;\n  centerOffset.y = (minimumY + maximumY) / 2.0;\n  centerOffset.z = (minimumZ + maximumZ) / 2.0;\n  const scale = scratchScale;\n  scale.x = (maximumX - minimumX) / 2.0;\n  scale.y = (maximumY - minimumY) / 2.0;\n  scale.z = (maximumZ - minimumZ) / 2.0;\n  const center = result.center;\n  centerOffset = Matrix3.multiplyByVector(halfAxes, centerOffset, centerOffset);\n  Cartesian3.add(planeOrigin, centerOffset, center);\n  Matrix3.multiplyByScale(halfAxes, scale, halfAxes);\n  return result;\n}\nconst scratchRectangleCenterCartographic = new Cartographic();\nconst scratchRectangleCenter = new Cartesian3();\nconst scratchPerimeterCartographicNC = new Cartographic();\nconst scratchPerimeterCartographicNW = new Cartographic();\nconst scratchPerimeterCartographicCW = new Cartographic();\nconst scratchPerimeterCartographicSW = new Cartographic();\nconst scratchPerimeterCartographicSC = new Cartographic();\nconst scratchPerimeterCartesianNC = new Cartesian3();\nconst scratchPerimeterCartesianNW = new Cartesian3();\nconst scratchPerimeterCartesianCW = new Cartesian3();\nconst scratchPerimeterCartesianSW = new Cartesian3();\nconst scratchPerimeterCartesianSC = new Cartesian3();\nconst scratchPerimeterProjectedNC = new Cartesian2();\nconst scratchPerimeterProjectedNW = new Cartesian2();\nconst scratchPerimeterProjectedCW = new Cartesian2();\nconst scratchPerimeterProjectedSW = new Cartesian2();\nconst scratchPerimeterProjectedSC = new Cartesian2();\nconst scratchPlaneOrigin = new Cartesian3();\nconst scratchPlaneNormal = new Cartesian3();\nconst scratchPlaneXAxis = new Cartesian3();\nconst scratchHorizonCartesian = new Cartesian3();\nconst scratchHorizonProjected = new Cartesian2();\nconst scratchMaxY = new Cartesian3();\nconst scratchMinY = new Cartesian3();\nconst scratchZ = new Cartesian3();\nconst scratchPlane = new Plane(Cartesian3.UNIT_X, 0.0);\n\n/**\n * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.\n * There are no guarantees about the orientation of the bounding box.\n *\n * @param {Rectangle} rectangle The cartographic rectangle on the surface of the ellipsoid.\n * @param {number} [minimumHeight=0.0] The minimum height (elevation) within the tile.\n * @param {number} [maximumHeight=0.0] The maximum height (elevation) within the tile.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the rectangle is defined.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\n *\n * @exception {DeveloperError} rectangle.width must be between 0 and 2 * pi.\n * @exception {DeveloperError} rectangle.height must be between 0 and pi.\n * @exception {DeveloperError} ellipsoid must be an ellipsoid of revolution (<code>radii.x == radii.y</code>)\n */\nOrientedBoundingBox.fromRectangle = function (rectangle, minimumHeight, maximumHeight, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required\");\n  }\n  if (rectangle.width < 0.0 || rectangle.width > CesiumMath.TWO_PI) {\n    throw new DeveloperError(\"Rectangle width must be between 0 and 2 * pi\");\n  }\n  if (rectangle.height < 0.0 || rectangle.height > CesiumMath.PI) {\n    throw new DeveloperError(\"Rectangle height must be between 0 and pi\");\n  }\n  if (defined(ellipsoid) && !CesiumMath.equalsEpsilon(ellipsoid.radii.x, ellipsoid.radii.y, CesiumMath.EPSILON15)) {\n    throw new DeveloperError(\"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\");\n  }\n  //>>includeEnd('debug');\n\n  minimumHeight = minimumHeight ?? 0.0;\n  maximumHeight = maximumHeight ?? 0.0;\n  ellipsoid = ellipsoid ?? Ellipsoid.default;\n  let minX, maxX, minY, maxY, minZ, maxZ, plane;\n  if (rectangle.width <= CesiumMath.PI) {\n    // The bounding box will be aligned with the tangent plane at the center of the rectangle.\n    const tangentPointCartographic = Rectangle.center(rectangle, scratchRectangleCenterCartographic);\n    const tangentPoint = ellipsoid.cartographicToCartesian(tangentPointCartographic, scratchRectangleCenter);\n    const tangentPlane = new EllipsoidTangentPlane(tangentPoint, ellipsoid);\n    plane = tangentPlane.plane;\n\n    // If the rectangle spans the equator, CW is instead aligned with the equator (because it sticks out the farthest at the equator).\n    const lonCenter = tangentPointCartographic.longitude;\n    const latCenter = rectangle.south < 0.0 && rectangle.north > 0.0 ? 0.0 : tangentPointCartographic.latitude;\n\n    // Compute XY extents using the rectangle at maximum height\n    const perimeterCartographicNC = Cartographic.fromRadians(lonCenter, rectangle.north, maximumHeight, scratchPerimeterCartographicNC);\n    const perimeterCartographicNW = Cartographic.fromRadians(rectangle.west, rectangle.north, maximumHeight, scratchPerimeterCartographicNW);\n    const perimeterCartographicCW = Cartographic.fromRadians(rectangle.west, latCenter, maximumHeight, scratchPerimeterCartographicCW);\n    const perimeterCartographicSW = Cartographic.fromRadians(rectangle.west, rectangle.south, maximumHeight, scratchPerimeterCartographicSW);\n    const perimeterCartographicSC = Cartographic.fromRadians(lonCenter, rectangle.south, maximumHeight, scratchPerimeterCartographicSC);\n    const perimeterCartesianNC = ellipsoid.cartographicToCartesian(perimeterCartographicNC, scratchPerimeterCartesianNC);\n    let perimeterCartesianNW = ellipsoid.cartographicToCartesian(perimeterCartographicNW, scratchPerimeterCartesianNW);\n    const perimeterCartesianCW = ellipsoid.cartographicToCartesian(perimeterCartographicCW, scratchPerimeterCartesianCW);\n    let perimeterCartesianSW = ellipsoid.cartographicToCartesian(perimeterCartographicSW, scratchPerimeterCartesianSW);\n    const perimeterCartesianSC = ellipsoid.cartographicToCartesian(perimeterCartographicSC, scratchPerimeterCartesianSC);\n    const perimeterProjectedNC = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianNC, scratchPerimeterProjectedNC);\n    const perimeterProjectedNW = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianNW, scratchPerimeterProjectedNW);\n    const perimeterProjectedCW = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianCW, scratchPerimeterProjectedCW);\n    const perimeterProjectedSW = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianSW, scratchPerimeterProjectedSW);\n    const perimeterProjectedSC = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianSC, scratchPerimeterProjectedSC);\n    minX = Math.min(perimeterProjectedNW.x, perimeterProjectedCW.x, perimeterProjectedSW.x);\n    maxX = -minX; // symmetrical\n\n    maxY = Math.max(perimeterProjectedNW.y, perimeterProjectedNC.y);\n    minY = Math.min(perimeterProjectedSW.y, perimeterProjectedSC.y);\n\n    // Compute minimum Z using the rectangle at minimum height, since it will be deeper than the maximum height\n    perimeterCartographicNW.height = perimeterCartographicSW.height = minimumHeight;\n    perimeterCartesianNW = ellipsoid.cartographicToCartesian(perimeterCartographicNW, scratchPerimeterCartesianNW);\n    perimeterCartesianSW = ellipsoid.cartographicToCartesian(perimeterCartographicSW, scratchPerimeterCartesianSW);\n    minZ = Math.min(Plane.getPointDistance(plane, perimeterCartesianNW), Plane.getPointDistance(plane, perimeterCartesianSW));\n    maxZ = maximumHeight; // Since the tangent plane touches the surface at height = 0, this is okay\n\n    return fromPlaneExtents(tangentPlane.origin, tangentPlane.xAxis, tangentPlane.yAxis, tangentPlane.zAxis, minX, maxX, minY, maxY, minZ, maxZ, result);\n  }\n\n  // Handle the case where rectangle width is greater than PI (wraps around more than half the ellipsoid).\n  const fullyAboveEquator = rectangle.south > 0.0;\n  const fullyBelowEquator = rectangle.north < 0.0;\n  const latitudeNearestToEquator = fullyAboveEquator ? rectangle.south : fullyBelowEquator ? rectangle.north : 0.0;\n  const centerLongitude = Rectangle.center(rectangle, scratchRectangleCenterCartographic).longitude;\n\n  // Plane is located at the rectangle's center longitude and the rectangle's latitude that is closest to the equator. It rotates around the Z axis.\n  // This results in a better fit than the obb approach for smaller rectangles, which orients with the rectangle's center normal.\n  const planeOrigin = Cartesian3.fromRadians(centerLongitude, latitudeNearestToEquator, maximumHeight, ellipsoid, scratchPlaneOrigin);\n  planeOrigin.z = 0.0; // center the plane on the equator to simpify plane normal calculation\n  const isPole = Math.abs(planeOrigin.x) < CesiumMath.EPSILON10 && Math.abs(planeOrigin.y) < CesiumMath.EPSILON10;\n  const planeNormal = !isPole ? Cartesian3.normalize(planeOrigin, scratchPlaneNormal) : Cartesian3.UNIT_X;\n  const planeYAxis = Cartesian3.UNIT_Z;\n  const planeXAxis = Cartesian3.cross(planeNormal, planeYAxis, scratchPlaneXAxis);\n  plane = Plane.fromPointNormal(planeOrigin, planeNormal, scratchPlane);\n\n  // Get the horizon point relative to the center. This will be the farthest extent in the plane's X dimension.\n  const horizonCartesian = Cartesian3.fromRadians(centerLongitude + CesiumMath.PI_OVER_TWO, latitudeNearestToEquator, maximumHeight, ellipsoid, scratchHorizonCartesian);\n  maxX = Cartesian3.dot(Plane.projectPointOntoPlane(plane, horizonCartesian, scratchHorizonProjected), planeXAxis);\n  minX = -maxX; // symmetrical\n\n  // Get the min and max Y, using the height that will give the largest extent\n  maxY = Cartesian3.fromRadians(0.0, rectangle.north, fullyBelowEquator ? minimumHeight : maximumHeight, ellipsoid, scratchMaxY).z;\n  minY = Cartesian3.fromRadians(0.0, rectangle.south, fullyAboveEquator ? minimumHeight : maximumHeight, ellipsoid, scratchMinY).z;\n  const farZ = Cartesian3.fromRadians(rectangle.east, latitudeNearestToEquator, maximumHeight, ellipsoid, scratchZ);\n  minZ = Plane.getPointDistance(plane, farZ);\n  maxZ = 0.0; // plane origin starts at maxZ already\n\n  // min and max are local to the plane axes\n  return fromPlaneExtents(planeOrigin, planeXAxis, planeYAxis, planeNormal, minX, maxX, minY, maxY, minZ, maxZ, result);\n};\n\n/**\n * Computes an OrientedBoundingBox that bounds an affine transformation.\n *\n * @param {Matrix4} transformation The affine transformation.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\n */\nOrientedBoundingBox.fromTransformation = function (transformation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"transformation\", transformation);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n  result.center = Matrix4.getTranslation(transformation, result.center);\n  result.halfAxes = Matrix4.getMatrix3(transformation, result.halfAxes);\n  result.halfAxes = Matrix3.multiplyByScalar(result.halfAxes, 0.5, result.halfAxes);\n  return result;\n};\n\n/**\n * Duplicates a OrientedBoundingBox instance.\n *\n * @param {OrientedBoundingBox} box The bounding box to duplicate.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\n */\nOrientedBoundingBox.clone = function (box, result) {\n  if (!defined(box)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new OrientedBoundingBox(box.center, box.halfAxes);\n  }\n  Cartesian3.clone(box.center, result.center);\n  Matrix3.clone(box.halfAxes, result.halfAxes);\n  return result;\n};\n\n/**\n * Determines which side of a plane the oriented bounding box is located.\n *\n * @param {OrientedBoundingBox} box The oriented bounding box to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nOrientedBoundingBox.intersectPlane = function (box, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const center = box.center;\n  const normal = plane.normal;\n  const halfAxes = box.halfAxes;\n  const normalX = normal.x,\n    normalY = normal.y,\n    normalZ = normal.z;\n  // plane is used as if it is its normal; the first three components are assumed to be normalized\n  const radEffective = Math.abs(normalX * halfAxes[Matrix3.COLUMN0ROW0] + normalY * halfAxes[Matrix3.COLUMN0ROW1] + normalZ * halfAxes[Matrix3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[Matrix3.COLUMN1ROW0] + normalY * halfAxes[Matrix3.COLUMN1ROW1] + normalZ * halfAxes[Matrix3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[Matrix3.COLUMN2ROW0] + normalY * halfAxes[Matrix3.COLUMN2ROW1] + normalZ * halfAxes[Matrix3.COLUMN2ROW2]);\n  const distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\n  if (distanceToPlane <= -radEffective) {\n    // The entire box is on the negative side of the plane normal\n    return Intersect.OUTSIDE;\n  } else if (distanceToPlane >= radEffective) {\n    // The entire box is on the positive side of the plane normal\n    return Intersect.INSIDE;\n  }\n  return Intersect.INTERSECTING;\n};\nconst scratchCartesianU = new Cartesian3();\nconst scratchCartesianV = new Cartesian3();\nconst scratchCartesianW = new Cartesian3();\nconst scratchValidAxis2 = new Cartesian3();\nconst scratchValidAxis3 = new Cartesian3();\nconst scratchPPrime = new Cartesian3();\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\n *\n * @param {OrientedBoundingBox} box The box.\n * @param {Cartesian3} cartesian The point\n * @returns {number} The distance squared from the oriented bounding box to the point. Returns 0 if the point is inside the box.\n *\n * @example\n * // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return Cesium.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - Cesium.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);\n * });\n */\nOrientedBoundingBox.distanceSquaredTo = function (box, cartesian) {\n  // See Geometric Tools for Computer Graphics 10.4.2\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const offset = Cartesian3.subtract(cartesian, box.center, scratchOffset);\n  const halfAxes = box.halfAxes;\n  let u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\n  let v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\n  let w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\n  const uHalf = Cartesian3.magnitude(u);\n  const vHalf = Cartesian3.magnitude(v);\n  const wHalf = Cartesian3.magnitude(w);\n  let uValid = true;\n  let vValid = true;\n  let wValid = true;\n  if (uHalf > 0) {\n    Cartesian3.divideByScalar(u, uHalf, u);\n  } else {\n    uValid = false;\n  }\n  if (vHalf > 0) {\n    Cartesian3.divideByScalar(v, vHalf, v);\n  } else {\n    vValid = false;\n  }\n  if (wHalf > 0) {\n    Cartesian3.divideByScalar(w, wHalf, w);\n  } else {\n    wValid = false;\n  }\n  const numberOfDegenerateAxes = !uValid + !vValid + !wValid;\n  let validAxis1;\n  let validAxis2;\n  let validAxis3;\n  if (numberOfDegenerateAxes === 1) {\n    let degenerateAxis = u;\n    validAxis1 = v;\n    validAxis2 = w;\n    if (!vValid) {\n      degenerateAxis = v;\n      validAxis1 = u;\n    } else if (!wValid) {\n      degenerateAxis = w;\n      validAxis2 = u;\n    }\n    validAxis3 = Cartesian3.cross(validAxis1, validAxis2, scratchValidAxis3);\n    if (degenerateAxis === u) {\n      u = validAxis3;\n    } else if (degenerateAxis === v) {\n      v = validAxis3;\n    } else if (degenerateAxis === w) {\n      w = validAxis3;\n    }\n  } else if (numberOfDegenerateAxes === 2) {\n    validAxis1 = u;\n    if (vValid) {\n      validAxis1 = v;\n    } else if (wValid) {\n      validAxis1 = w;\n    }\n    let crossVector = Cartesian3.UNIT_Y;\n    if (crossVector.equalsEpsilon(validAxis1, CesiumMath.EPSILON3)) {\n      crossVector = Cartesian3.UNIT_X;\n    }\n    validAxis2 = Cartesian3.cross(validAxis1, crossVector, scratchValidAxis2);\n    Cartesian3.normalize(validAxis2, validAxis2);\n    validAxis3 = Cartesian3.cross(validAxis1, validAxis2, scratchValidAxis3);\n    Cartesian3.normalize(validAxis3, validAxis3);\n    if (validAxis1 === u) {\n      v = validAxis2;\n      w = validAxis3;\n    } else if (validAxis1 === v) {\n      w = validAxis2;\n      u = validAxis3;\n    } else if (validAxis1 === w) {\n      u = validAxis2;\n      v = validAxis3;\n    }\n  } else if (numberOfDegenerateAxes === 3) {\n    u = Cartesian3.UNIT_X;\n    v = Cartesian3.UNIT_Y;\n    w = Cartesian3.UNIT_Z;\n  }\n  const pPrime = scratchPPrime;\n  pPrime.x = Cartesian3.dot(offset, u);\n  pPrime.y = Cartesian3.dot(offset, v);\n  pPrime.z = Cartesian3.dot(offset, w);\n  let distanceSquared = 0.0;\n  let d;\n  if (pPrime.x < -uHalf) {\n    d = pPrime.x + uHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.x > uHalf) {\n    d = pPrime.x - uHalf;\n    distanceSquared += d * d;\n  }\n  if (pPrime.y < -vHalf) {\n    d = pPrime.y + vHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.y > vHalf) {\n    d = pPrime.y - vHalf;\n    distanceSquared += d * d;\n  }\n  if (pPrime.z < -wHalf) {\n    d = pPrime.z + wHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.z > wHalf) {\n    d = pPrime.z - wHalf;\n    distanceSquared += d * d;\n  }\n  return distanceSquared;\n};\nconst scratchCorner = new Cartesian3();\nconst scratchToCenter = new Cartesian3();\n\n/**\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding box.\n *\n * @param {OrientedBoundingBox} box The bounding box to calculate the distance to.\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\n */\nOrientedBoundingBox.computePlaneDistances = function (box, position, direction, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Interval();\n  }\n  let minDist = Number.POSITIVE_INFINITY;\n  let maxDist = Number.NEGATIVE_INFINITY;\n  const center = box.center;\n  const halfAxes = box.halfAxes;\n  const u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\n  const v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\n  const w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\n\n  // project first corner\n  const corner = Cartesian3.add(u, v, scratchCorner);\n  Cartesian3.add(corner, w, corner);\n  Cartesian3.add(corner, center, corner);\n  const toCenter = Cartesian3.subtract(corner, position, scratchToCenter);\n  let mag = Cartesian3.dot(direction, toCenter);\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project second corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project third corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project fourth corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project fifth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project sixth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project seventh corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project eighth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n  result.start = minDist;\n  result.stop = maxDist;\n  return result;\n};\nconst scratchXAxis = new Cartesian3();\nconst scratchYAxis = new Cartesian3();\nconst scratchZAxis = new Cartesian3();\n\n/**\n * Computes the eight corners of an oriented bounding box. The corners are ordered by (-X, -Y, -Z), (-X, -Y, +Z), (-X, +Y, -Z), (-X, +Y, +Z), (+X, -Y, -Z), (+X, -Y, +Z), (+X, +Y, -Z), (+X, +Y, +Z).\n *\n * @param {OrientedBoundingBox} box The oriented bounding box.\n * @param {Cartesian3[]} [result] An array of eight {@link Cartesian3} instances onto which to store the corners.\n * @returns {Cartesian3[]} The modified result parameter or a new array if none was provided.\n */\nOrientedBoundingBox.computeCorners = function (box, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"box\", box);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3()];\n  }\n  const center = box.center;\n  const halfAxes = box.halfAxes;\n  const xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);\n  const yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);\n  const zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);\n  Cartesian3.clone(center, result[0]);\n  Cartesian3.subtract(result[0], xAxis, result[0]);\n  Cartesian3.subtract(result[0], yAxis, result[0]);\n  Cartesian3.subtract(result[0], zAxis, result[0]);\n  Cartesian3.clone(center, result[1]);\n  Cartesian3.subtract(result[1], xAxis, result[1]);\n  Cartesian3.subtract(result[1], yAxis, result[1]);\n  Cartesian3.add(result[1], zAxis, result[1]);\n  Cartesian3.clone(center, result[2]);\n  Cartesian3.subtract(result[2], xAxis, result[2]);\n  Cartesian3.add(result[2], yAxis, result[2]);\n  Cartesian3.subtract(result[2], zAxis, result[2]);\n  Cartesian3.clone(center, result[3]);\n  Cartesian3.subtract(result[3], xAxis, result[3]);\n  Cartesian3.add(result[3], yAxis, result[3]);\n  Cartesian3.add(result[3], zAxis, result[3]);\n  Cartesian3.clone(center, result[4]);\n  Cartesian3.add(result[4], xAxis, result[4]);\n  Cartesian3.subtract(result[4], yAxis, result[4]);\n  Cartesian3.subtract(result[4], zAxis, result[4]);\n  Cartesian3.clone(center, result[5]);\n  Cartesian3.add(result[5], xAxis, result[5]);\n  Cartesian3.subtract(result[5], yAxis, result[5]);\n  Cartesian3.add(result[5], zAxis, result[5]);\n  Cartesian3.clone(center, result[6]);\n  Cartesian3.add(result[6], xAxis, result[6]);\n  Cartesian3.add(result[6], yAxis, result[6]);\n  Cartesian3.subtract(result[6], zAxis, result[6]);\n  Cartesian3.clone(center, result[7]);\n  Cartesian3.add(result[7], xAxis, result[7]);\n  Cartesian3.add(result[7], yAxis, result[7]);\n  Cartesian3.add(result[7], zAxis, result[7]);\n  return result;\n};\nconst scratchRotationScale = new Matrix3();\n\n/**\n * Computes a transformation matrix from an oriented bounding box.\n *\n * @param {OrientedBoundingBox} box The oriented bounding box.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new {@link Matrix4} instance if none was provided.\n */\nOrientedBoundingBox.computeTransformation = function (box, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"box\", box);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Matrix4();\n  }\n  const translation = box.center;\n  const rotationScale = Matrix3.multiplyByUniformScale(box.halfAxes, 2.0, scratchRotationScale);\n  return Matrix4.fromRotationTranslation(rotationScale, translation, result);\n};\nconst scratchBoundingSphere = new BoundingSphere();\n\n/**\n * Determines whether or not a bounding box is hidden from view by the occluder.\n *\n * @param {OrientedBoundingBox} box The bounding box surrounding the occludee object.\n * @param {Occluder} occluder The occluder.\n * @returns {boolean} <code>true</code> if the box is not visible; otherwise <code>false</code>.\n */\nOrientedBoundingBox.isOccluded = function (box, occluder) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n  if (!defined(occluder)) {\n    throw new DeveloperError(\"occluder is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const sphere = BoundingSphere.fromOrientedBoundingBox(box, scratchBoundingSphere);\n  return !occluder.isBoundingSphereVisible(sphere);\n};\n\n/**\n * Determines which side of a plane the oriented bounding box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nOrientedBoundingBox.prototype.intersectPlane = function (plane) {\n  return OrientedBoundingBox.intersectPlane(this, plane);\n};\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\n *\n * @param {Cartesian3} cartesian The point\n * @returns {number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n * });\n */\nOrientedBoundingBox.prototype.distanceSquaredTo = function (cartesian) {\n  return OrientedBoundingBox.distanceSquaredTo(this, cartesian);\n};\n\n/**\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding box.\n *\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\n */\nOrientedBoundingBox.prototype.computePlaneDistances = function (position, direction, result) {\n  return OrientedBoundingBox.computePlaneDistances(this, position, direction, result);\n};\n\n/**\n * Computes the eight corners of an oriented bounding box. The corners are ordered by (-X, -Y, -Z), (-X, -Y, +Z), (-X, +Y, -Z), (-X, +Y, +Z), (+X, -Y, -Z), (+X, -Y, +Z), (+X, +Y, -Z), (+X, +Y, +Z).\n *\n * @param {Cartesian3[]} [result] An array of eight {@link Cartesian3} instances onto which to store the corners.\n * @returns {Cartesian3[]} The modified result parameter or a new array if none was provided.\n */\nOrientedBoundingBox.prototype.computeCorners = function (result) {\n  return OrientedBoundingBox.computeCorners(this, result);\n};\n\n/**\n * Computes a transformation matrix from an oriented bounding box.\n *\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new {@link Matrix4} instance if none was provided.\n */\nOrientedBoundingBox.prototype.computeTransformation = function (result) {\n  return OrientedBoundingBox.computeTransformation(this, result);\n};\n\n/**\n * Determines whether or not a bounding box is hidden from view by the occluder.\n *\n * @param {Occluder} occluder The occluder.\n * @returns {boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\nOrientedBoundingBox.prototype.isOccluded = function (occluder) {\n  return OrientedBoundingBox.isOccluded(this, occluder);\n};\n\n/**\n * Compares the provided OrientedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrientedBoundingBox} [left] The first OrientedBoundingBox.\n * @param {OrientedBoundingBox} [right] The second OrientedBoundingBox.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nOrientedBoundingBox.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && Cartesian3.equals(left.center, right.center) && Matrix3.equals(left.halfAxes, right.halfAxes);\n};\n\n/**\n * Duplicates this OrientedBoundingBox instance.\n *\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n */\nOrientedBoundingBox.prototype.clone = function (result) {\n  return OrientedBoundingBox.clone(this, result);\n};\n\n/**\n * Compares this OrientedBoundingBox against the provided OrientedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrientedBoundingBox} [right] The right hand side OrientedBoundingBox.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nOrientedBoundingBox.prototype.equals = function (right) {\n  return OrientedBoundingBox.equals(this, right);\n};\nexport default OrientedBoundingBox;","map":{"version":3,"names":["BoundingSphere","Cartesian2","Cartesian3","Cartographic","Check","defined","DeveloperError","Ellipsoid","EllipsoidTangentPlane","Intersect","Interval","CesiumMath","Matrix3","Matrix4","Plane","Rectangle","OrientedBoundingBox","center","halfAxes","clone","ZERO","packedLength","pack","value","array","startingIndex","typeOf","object","unpack","result","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","scratchCartesian5","scratchCartesian6","scratchCovarianceResult","scratchEigenResult","unitary","diagonal","fromPoints","positions","length","i","meanPoint","add","invLength","multiplyByScalar","exx","exy","exz","eyy","eyz","ezz","p","subtract","x","y","z","covarianceMatrix","eigenDecomposition","computeEigenDecomposition","rotation","v1","getColumn","v2","v3","u1","Number","MAX_VALUE","u2","u3","l1","l2","l3","Math","max","dot","min","scale","multiplyByScale","scratchOffset","scratchScale","fromPlaneExtents","planeOrigin","planeXAxis","planeYAxis","planeZAxis","minimumX","maximumX","minimumY","maximumY","minimumZ","maximumZ","setColumn","centerOffset","multiplyByVector","scratchRectangleCenterCartographic","scratchRectangleCenter","scratchPerimeterCartographicNC","scratchPerimeterCartographicNW","scratchPerimeterCartographicCW","scratchPerimeterCartographicSW","scratchPerimeterCartographicSC","scratchPerimeterCartesianNC","scratchPerimeterCartesianNW","scratchPerimeterCartesianCW","scratchPerimeterCartesianSW","scratchPerimeterCartesianSC","scratchPerimeterProjectedNC","scratchPerimeterProjectedNW","scratchPerimeterProjectedCW","scratchPerimeterProjectedSW","scratchPerimeterProjectedSC","scratchPlaneOrigin","scratchPlaneNormal","scratchPlaneXAxis","scratchHorizonCartesian","scratchHorizonProjected","scratchMaxY","scratchMinY","scratchZ","scratchPlane","UNIT_X","fromRectangle","rectangle","minimumHeight","maximumHeight","ellipsoid","width","TWO_PI","height","PI","equalsEpsilon","radii","EPSILON15","default","minX","maxX","minY","maxY","minZ","maxZ","plane","tangentPointCartographic","tangentPoint","cartographicToCartesian","tangentPlane","lonCenter","longitude","latCenter","south","north","latitude","perimeterCartographicNC","fromRadians","perimeterCartographicNW","west","perimeterCartographicCW","perimeterCartographicSW","perimeterCartographicSC","perimeterCartesianNC","perimeterCartesianNW","perimeterCartesianCW","perimeterCartesianSW","perimeterCartesianSC","perimeterProjectedNC","projectPointToNearestOnPlane","perimeterProjectedNW","perimeterProjectedCW","perimeterProjectedSW","perimeterProjectedSC","getPointDistance","origin","xAxis","yAxis","zAxis","fullyAboveEquator","fullyBelowEquator","latitudeNearestToEquator","centerLongitude","isPole","abs","EPSILON10","planeNormal","normalize","UNIT_Z","cross","fromPointNormal","horizonCartesian","PI_OVER_TWO","projectPointOntoPlane","farZ","east","fromTransformation","transformation","getTranslation","getMatrix3","box","undefined","intersectPlane","normal","normalX","normalY","normalZ","radEffective","COLUMN0ROW0","COLUMN0ROW1","COLUMN0ROW2","COLUMN1ROW0","COLUMN1ROW1","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","distanceToPlane","distance","OUTSIDE","INSIDE","INTERSECTING","scratchCartesianU","scratchCartesianV","scratchCartesianW","scratchValidAxis2","scratchValidAxis3","scratchPPrime","distanceSquaredTo","cartesian","offset","u","v","w","uHalf","magnitude","vHalf","wHalf","uValid","vValid","wValid","divideByScalar","numberOfDegenerateAxes","validAxis1","validAxis2","validAxis3","degenerateAxis","crossVector","UNIT_Y","EPSILON3","pPrime","distanceSquared","d","scratchCorner","scratchToCenter","computePlaneDistances","position","direction","minDist","POSITIVE_INFINITY","maxDist","NEGATIVE_INFINITY","corner","toCenter","mag","start","stop","scratchXAxis","scratchYAxis","scratchZAxis","computeCorners","scratchRotationScale","computeTransformation","translation","rotationScale","multiplyByUniformScale","fromRotationTranslation","scratchBoundingSphere","isOccluded","occluder","sphere","fromOrientedBoundingBox","isBoundingSphereVisible","prototype","equals","left","right"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/OrientedBoundingBox.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Intersect from \"./Intersect.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * Creates an instance of an OrientedBoundingBox.\n * An OrientedBoundingBox of some object is a closed and convex rectangular cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.\n * @alias OrientedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.\n * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.\n *                                          Equivalently, the transformation matrix, to rotate and scale a 2x2x2\n *                                          cube centered at the origin.\n *\n *\n * @example\n * // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.\n * const center = new Cesium.Cartesian3(1.0, 0.0, 0.0);\n * const halfAxes = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(1.0, 3.0, 2.0), new Cesium.Matrix3());\n *\n * const obb = new Cesium.OrientedBoundingBox(center, halfAxes);\n *\n * @see BoundingSphere\n * @see BoundingRectangle\n */\nfunction OrientedBoundingBox(center, halfAxes) {\n  /**\n   * The center of the box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.center = Cartesian3.clone(center ?? Cartesian3.ZERO);\n  /**\n   * The three orthogonal half-axes of the bounding box. Equivalently, the\n   * transformation matrix, to rotate and scale a 2x2x2 cube centered at the\n   * origin.\n   * @type {Matrix3}\n   * @default {@link Matrix3.ZERO}\n   */\n  this.halfAxes = Matrix3.clone(halfAxes ?? Matrix3.ZERO);\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nOrientedBoundingBox.packedLength =\n  Cartesian3.packedLength + Matrix3.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {OrientedBoundingBox} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nOrientedBoundingBox.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  Cartesian3.pack(value.center, array, startingIndex);\n  Matrix3.pack(value.halfAxes, array, startingIndex + Cartesian3.packedLength);\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {OrientedBoundingBox} [result] The object into which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n */\nOrientedBoundingBox.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = startingIndex ?? 0;\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  Cartesian3.unpack(array, startingIndex, result.center);\n  Matrix3.unpack(\n    array,\n    startingIndex + Cartesian3.packedLength,\n    result.halfAxes,\n  );\n  return result;\n};\n\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartesian4 = new Cartesian3();\nconst scratchCartesian5 = new Cartesian3();\nconst scratchCartesian6 = new Cartesian3();\nconst scratchCovarianceResult = new Matrix3();\nconst scratchEigenResult = {\n  unitary: new Matrix3(),\n  diagonal: new Matrix3(),\n};\n\n/**\n * Computes an instance of an OrientedBoundingBox of the given positions.\n * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\n * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\n *\n * @param {Cartesian3[]} [positions] List of {@link Cartesian3} points that the bounding box will enclose.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n *\n * @example\n * // Compute an object oriented bounding box enclosing two points.\n * const box = Cesium.OrientedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\n */\nOrientedBoundingBox.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.halfAxes = Matrix3.ZERO;\n    result.center = Cartesian3.ZERO;\n    return result;\n  }\n\n  let i;\n  const length = positions.length;\n\n  const meanPoint = Cartesian3.clone(positions[0], scratchCartesian1);\n  for (i = 1; i < length; i++) {\n    Cartesian3.add(meanPoint, positions[i], meanPoint);\n  }\n  const invLength = 1.0 / length;\n  Cartesian3.multiplyByScalar(meanPoint, invLength, meanPoint);\n\n  let exx = 0.0;\n  let exy = 0.0;\n  let exz = 0.0;\n  let eyy = 0.0;\n  let eyz = 0.0;\n  let ezz = 0.0;\n  let p;\n\n  for (i = 0; i < length; i++) {\n    p = Cartesian3.subtract(positions[i], meanPoint, scratchCartesian2);\n    exx += p.x * p.x;\n    exy += p.x * p.y;\n    exz += p.x * p.z;\n    eyy += p.y * p.y;\n    eyz += p.y * p.z;\n    ezz += p.z * p.z;\n  }\n\n  exx *= invLength;\n  exy *= invLength;\n  exz *= invLength;\n  eyy *= invLength;\n  eyz *= invLength;\n  ezz *= invLength;\n\n  const covarianceMatrix = scratchCovarianceResult;\n  covarianceMatrix[0] = exx;\n  covarianceMatrix[1] = exy;\n  covarianceMatrix[2] = exz;\n  covarianceMatrix[3] = exy;\n  covarianceMatrix[4] = eyy;\n  covarianceMatrix[5] = eyz;\n  covarianceMatrix[6] = exz;\n  covarianceMatrix[7] = eyz;\n  covarianceMatrix[8] = ezz;\n\n  const eigenDecomposition = Matrix3.computeEigenDecomposition(\n    covarianceMatrix,\n    scratchEigenResult,\n  );\n  const rotation = Matrix3.clone(eigenDecomposition.unitary, result.halfAxes);\n\n  let v1 = Matrix3.getColumn(rotation, 0, scratchCartesian4);\n  let v2 = Matrix3.getColumn(rotation, 1, scratchCartesian5);\n  let v3 = Matrix3.getColumn(rotation, 2, scratchCartesian6);\n\n  let u1 = -Number.MAX_VALUE;\n  let u2 = -Number.MAX_VALUE;\n  let u3 = -Number.MAX_VALUE;\n  let l1 = Number.MAX_VALUE;\n  let l2 = Number.MAX_VALUE;\n  let l3 = Number.MAX_VALUE;\n\n  for (i = 0; i < length; i++) {\n    p = positions[i];\n    u1 = Math.max(Cartesian3.dot(v1, p), u1);\n    u2 = Math.max(Cartesian3.dot(v2, p), u2);\n    u3 = Math.max(Cartesian3.dot(v3, p), u3);\n\n    l1 = Math.min(Cartesian3.dot(v1, p), l1);\n    l2 = Math.min(Cartesian3.dot(v2, p), l2);\n    l3 = Math.min(Cartesian3.dot(v3, p), l3);\n  }\n\n  v1 = Cartesian3.multiplyByScalar(v1, 0.5 * (l1 + u1), v1);\n  v2 = Cartesian3.multiplyByScalar(v2, 0.5 * (l2 + u2), v2);\n  v3 = Cartesian3.multiplyByScalar(v3, 0.5 * (l3 + u3), v3);\n\n  const center = Cartesian3.add(v1, v2, result.center);\n  Cartesian3.add(center, v3, center);\n\n  const scale = scratchCartesian3;\n  scale.x = u1 - l1;\n  scale.y = u2 - l2;\n  scale.z = u3 - l3;\n  Cartesian3.multiplyByScalar(scale, 0.5, scale);\n  Matrix3.multiplyByScale(result.halfAxes, scale, result.halfAxes);\n\n  return result;\n};\n\nconst scratchOffset = new Cartesian3();\nconst scratchScale = new Cartesian3();\nfunction fromPlaneExtents(\n  planeOrigin,\n  planeXAxis,\n  planeYAxis,\n  planeZAxis,\n  minimumX,\n  maximumX,\n  minimumY,\n  maximumY,\n  minimumZ,\n  maximumZ,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(minimumX) ||\n    !defined(maximumX) ||\n    !defined(minimumY) ||\n    !defined(maximumY) ||\n    !defined(minimumZ) ||\n    !defined(maximumZ)\n  ) {\n    throw new DeveloperError(\n      \"all extents (minimum/maximum X/Y/Z) are required.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  const halfAxes = result.halfAxes;\n  Matrix3.setColumn(halfAxes, 0, planeXAxis, halfAxes);\n  Matrix3.setColumn(halfAxes, 1, planeYAxis, halfAxes);\n  Matrix3.setColumn(halfAxes, 2, planeZAxis, halfAxes);\n\n  let centerOffset = scratchOffset;\n  centerOffset.x = (minimumX + maximumX) / 2.0;\n  centerOffset.y = (minimumY + maximumY) / 2.0;\n  centerOffset.z = (minimumZ + maximumZ) / 2.0;\n\n  const scale = scratchScale;\n  scale.x = (maximumX - minimumX) / 2.0;\n  scale.y = (maximumY - minimumY) / 2.0;\n  scale.z = (maximumZ - minimumZ) / 2.0;\n\n  const center = result.center;\n  centerOffset = Matrix3.multiplyByVector(halfAxes, centerOffset, centerOffset);\n  Cartesian3.add(planeOrigin, centerOffset, center);\n  Matrix3.multiplyByScale(halfAxes, scale, halfAxes);\n\n  return result;\n}\n\nconst scratchRectangleCenterCartographic = new Cartographic();\nconst scratchRectangleCenter = new Cartesian3();\nconst scratchPerimeterCartographicNC = new Cartographic();\nconst scratchPerimeterCartographicNW = new Cartographic();\nconst scratchPerimeterCartographicCW = new Cartographic();\nconst scratchPerimeterCartographicSW = new Cartographic();\nconst scratchPerimeterCartographicSC = new Cartographic();\nconst scratchPerimeterCartesianNC = new Cartesian3();\nconst scratchPerimeterCartesianNW = new Cartesian3();\nconst scratchPerimeterCartesianCW = new Cartesian3();\nconst scratchPerimeterCartesianSW = new Cartesian3();\nconst scratchPerimeterCartesianSC = new Cartesian3();\nconst scratchPerimeterProjectedNC = new Cartesian2();\nconst scratchPerimeterProjectedNW = new Cartesian2();\nconst scratchPerimeterProjectedCW = new Cartesian2();\nconst scratchPerimeterProjectedSW = new Cartesian2();\nconst scratchPerimeterProjectedSC = new Cartesian2();\n\nconst scratchPlaneOrigin = new Cartesian3();\nconst scratchPlaneNormal = new Cartesian3();\nconst scratchPlaneXAxis = new Cartesian3();\nconst scratchHorizonCartesian = new Cartesian3();\nconst scratchHorizonProjected = new Cartesian2();\nconst scratchMaxY = new Cartesian3();\nconst scratchMinY = new Cartesian3();\nconst scratchZ = new Cartesian3();\nconst scratchPlane = new Plane(Cartesian3.UNIT_X, 0.0);\n\n/**\n * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.\n * There are no guarantees about the orientation of the bounding box.\n *\n * @param {Rectangle} rectangle The cartographic rectangle on the surface of the ellipsoid.\n * @param {number} [minimumHeight=0.0] The minimum height (elevation) within the tile.\n * @param {number} [maximumHeight=0.0] The maximum height (elevation) within the tile.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the rectangle is defined.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\n *\n * @exception {DeveloperError} rectangle.width must be between 0 and 2 * pi.\n * @exception {DeveloperError} rectangle.height must be between 0 and pi.\n * @exception {DeveloperError} ellipsoid must be an ellipsoid of revolution (<code>radii.x == radii.y</code>)\n */\nOrientedBoundingBox.fromRectangle = function (\n  rectangle,\n  minimumHeight,\n  maximumHeight,\n  ellipsoid,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required\");\n  }\n  if (rectangle.width < 0.0 || rectangle.width > CesiumMath.TWO_PI) {\n    throw new DeveloperError(\"Rectangle width must be between 0 and 2 * pi\");\n  }\n  if (rectangle.height < 0.0 || rectangle.height > CesiumMath.PI) {\n    throw new DeveloperError(\"Rectangle height must be between 0 and pi\");\n  }\n  if (\n    defined(ellipsoid) &&\n    !CesiumMath.equalsEpsilon(\n      ellipsoid.radii.x,\n      ellipsoid.radii.y,\n      CesiumMath.EPSILON15,\n    )\n  ) {\n    throw new DeveloperError(\n      \"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  minimumHeight = minimumHeight ?? 0.0;\n  maximumHeight = maximumHeight ?? 0.0;\n  ellipsoid = ellipsoid ?? Ellipsoid.default;\n\n  let minX, maxX, minY, maxY, minZ, maxZ, plane;\n\n  if (rectangle.width <= CesiumMath.PI) {\n    // The bounding box will be aligned with the tangent plane at the center of the rectangle.\n    const tangentPointCartographic = Rectangle.center(\n      rectangle,\n      scratchRectangleCenterCartographic,\n    );\n    const tangentPoint = ellipsoid.cartographicToCartesian(\n      tangentPointCartographic,\n      scratchRectangleCenter,\n    );\n    const tangentPlane = new EllipsoidTangentPlane(tangentPoint, ellipsoid);\n    plane = tangentPlane.plane;\n\n    // If the rectangle spans the equator, CW is instead aligned with the equator (because it sticks out the farthest at the equator).\n    const lonCenter = tangentPointCartographic.longitude;\n    const latCenter =\n      rectangle.south < 0.0 && rectangle.north > 0.0\n        ? 0.0\n        : tangentPointCartographic.latitude;\n\n    // Compute XY extents using the rectangle at maximum height\n    const perimeterCartographicNC = Cartographic.fromRadians(\n      lonCenter,\n      rectangle.north,\n      maximumHeight,\n      scratchPerimeterCartographicNC,\n    );\n    const perimeterCartographicNW = Cartographic.fromRadians(\n      rectangle.west,\n      rectangle.north,\n      maximumHeight,\n      scratchPerimeterCartographicNW,\n    );\n    const perimeterCartographicCW = Cartographic.fromRadians(\n      rectangle.west,\n      latCenter,\n      maximumHeight,\n      scratchPerimeterCartographicCW,\n    );\n    const perimeterCartographicSW = Cartographic.fromRadians(\n      rectangle.west,\n      rectangle.south,\n      maximumHeight,\n      scratchPerimeterCartographicSW,\n    );\n    const perimeterCartographicSC = Cartographic.fromRadians(\n      lonCenter,\n      rectangle.south,\n      maximumHeight,\n      scratchPerimeterCartographicSC,\n    );\n\n    const perimeterCartesianNC = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNC,\n      scratchPerimeterCartesianNC,\n    );\n    let perimeterCartesianNW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNW,\n      scratchPerimeterCartesianNW,\n    );\n    const perimeterCartesianCW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicCW,\n      scratchPerimeterCartesianCW,\n    );\n    let perimeterCartesianSW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSW,\n      scratchPerimeterCartesianSW,\n    );\n    const perimeterCartesianSC = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSC,\n      scratchPerimeterCartesianSC,\n    );\n\n    const perimeterProjectedNC = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianNC,\n      scratchPerimeterProjectedNC,\n    );\n    const perimeterProjectedNW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianNW,\n      scratchPerimeterProjectedNW,\n    );\n    const perimeterProjectedCW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianCW,\n      scratchPerimeterProjectedCW,\n    );\n    const perimeterProjectedSW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianSW,\n      scratchPerimeterProjectedSW,\n    );\n    const perimeterProjectedSC = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianSC,\n      scratchPerimeterProjectedSC,\n    );\n\n    minX = Math.min(\n      perimeterProjectedNW.x,\n      perimeterProjectedCW.x,\n      perimeterProjectedSW.x,\n    );\n    maxX = -minX; // symmetrical\n\n    maxY = Math.max(perimeterProjectedNW.y, perimeterProjectedNC.y);\n    minY = Math.min(perimeterProjectedSW.y, perimeterProjectedSC.y);\n\n    // Compute minimum Z using the rectangle at minimum height, since it will be deeper than the maximum height\n    perimeterCartographicNW.height = perimeterCartographicSW.height =\n      minimumHeight;\n    perimeterCartesianNW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNW,\n      scratchPerimeterCartesianNW,\n    );\n    perimeterCartesianSW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSW,\n      scratchPerimeterCartesianSW,\n    );\n\n    minZ = Math.min(\n      Plane.getPointDistance(plane, perimeterCartesianNW),\n      Plane.getPointDistance(plane, perimeterCartesianSW),\n    );\n    maxZ = maximumHeight; // Since the tangent plane touches the surface at height = 0, this is okay\n\n    return fromPlaneExtents(\n      tangentPlane.origin,\n      tangentPlane.xAxis,\n      tangentPlane.yAxis,\n      tangentPlane.zAxis,\n      minX,\n      maxX,\n      minY,\n      maxY,\n      minZ,\n      maxZ,\n      result,\n    );\n  }\n\n  // Handle the case where rectangle width is greater than PI (wraps around more than half the ellipsoid).\n  const fullyAboveEquator = rectangle.south > 0.0;\n  const fullyBelowEquator = rectangle.north < 0.0;\n  const latitudeNearestToEquator = fullyAboveEquator\n    ? rectangle.south\n    : fullyBelowEquator\n      ? rectangle.north\n      : 0.0;\n  const centerLongitude = Rectangle.center(\n    rectangle,\n    scratchRectangleCenterCartographic,\n  ).longitude;\n\n  // Plane is located at the rectangle's center longitude and the rectangle's latitude that is closest to the equator. It rotates around the Z axis.\n  // This results in a better fit than the obb approach for smaller rectangles, which orients with the rectangle's center normal.\n  const planeOrigin = Cartesian3.fromRadians(\n    centerLongitude,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchPlaneOrigin,\n  );\n  planeOrigin.z = 0.0; // center the plane on the equator to simpify plane normal calculation\n  const isPole =\n    Math.abs(planeOrigin.x) < CesiumMath.EPSILON10 &&\n    Math.abs(planeOrigin.y) < CesiumMath.EPSILON10;\n  const planeNormal = !isPole\n    ? Cartesian3.normalize(planeOrigin, scratchPlaneNormal)\n    : Cartesian3.UNIT_X;\n  const planeYAxis = Cartesian3.UNIT_Z;\n  const planeXAxis = Cartesian3.cross(\n    planeNormal,\n    planeYAxis,\n    scratchPlaneXAxis,\n  );\n  plane = Plane.fromPointNormal(planeOrigin, planeNormal, scratchPlane);\n\n  // Get the horizon point relative to the center. This will be the farthest extent in the plane's X dimension.\n  const horizonCartesian = Cartesian3.fromRadians(\n    centerLongitude + CesiumMath.PI_OVER_TWO,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchHorizonCartesian,\n  );\n  maxX = Cartesian3.dot(\n    Plane.projectPointOntoPlane(\n      plane,\n      horizonCartesian,\n      scratchHorizonProjected,\n    ),\n    planeXAxis,\n  );\n  minX = -maxX; // symmetrical\n\n  // Get the min and max Y, using the height that will give the largest extent\n  maxY = Cartesian3.fromRadians(\n    0.0,\n    rectangle.north,\n    fullyBelowEquator ? minimumHeight : maximumHeight,\n    ellipsoid,\n    scratchMaxY,\n  ).z;\n  minY = Cartesian3.fromRadians(\n    0.0,\n    rectangle.south,\n    fullyAboveEquator ? minimumHeight : maximumHeight,\n    ellipsoid,\n    scratchMinY,\n  ).z;\n\n  const farZ = Cartesian3.fromRadians(\n    rectangle.east,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchZ,\n  );\n  minZ = Plane.getPointDistance(plane, farZ);\n  maxZ = 0.0; // plane origin starts at maxZ already\n\n  // min and max are local to the plane axes\n  return fromPlaneExtents(\n    planeOrigin,\n    planeXAxis,\n    planeYAxis,\n    planeNormal,\n    minX,\n    maxX,\n    minY,\n    maxY,\n    minZ,\n    maxZ,\n    result,\n  );\n};\n\n/**\n * Computes an OrientedBoundingBox that bounds an affine transformation.\n *\n * @param {Matrix4} transformation The affine transformation.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\n */\nOrientedBoundingBox.fromTransformation = function (transformation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"transformation\", transformation);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  result.center = Matrix4.getTranslation(transformation, result.center);\n  result.halfAxes = Matrix4.getMatrix3(transformation, result.halfAxes);\n  result.halfAxes = Matrix3.multiplyByScalar(\n    result.halfAxes,\n    0.5,\n    result.halfAxes,\n  );\n  return result;\n};\n\n/**\n * Duplicates a OrientedBoundingBox instance.\n *\n * @param {OrientedBoundingBox} box The bounding box to duplicate.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\n */\nOrientedBoundingBox.clone = function (box, result) {\n  if (!defined(box)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new OrientedBoundingBox(box.center, box.halfAxes);\n  }\n\n  Cartesian3.clone(box.center, result.center);\n  Matrix3.clone(box.halfAxes, result.halfAxes);\n\n  return result;\n};\n\n/**\n * Determines which side of a plane the oriented bounding box is located.\n *\n * @param {OrientedBoundingBox} box The oriented bounding box to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nOrientedBoundingBox.intersectPlane = function (box, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const center = box.center;\n  const normal = plane.normal;\n  const halfAxes = box.halfAxes;\n  const normalX = normal.x,\n    normalY = normal.y,\n    normalZ = normal.z;\n  // plane is used as if it is its normal; the first three components are assumed to be normalized\n  const radEffective =\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN0ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN0ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN0ROW2],\n    ) +\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN1ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN1ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN1ROW2],\n    ) +\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN2ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN2ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN2ROW2],\n    );\n  const distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\n\n  if (distanceToPlane <= -radEffective) {\n    // The entire box is on the negative side of the plane normal\n    return Intersect.OUTSIDE;\n  } else if (distanceToPlane >= radEffective) {\n    // The entire box is on the positive side of the plane normal\n    return Intersect.INSIDE;\n  }\n  return Intersect.INTERSECTING;\n};\n\nconst scratchCartesianU = new Cartesian3();\nconst scratchCartesianV = new Cartesian3();\nconst scratchCartesianW = new Cartesian3();\nconst scratchValidAxis2 = new Cartesian3();\nconst scratchValidAxis3 = new Cartesian3();\nconst scratchPPrime = new Cartesian3();\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\n *\n * @param {OrientedBoundingBox} box The box.\n * @param {Cartesian3} cartesian The point\n * @returns {number} The distance squared from the oriented bounding box to the point. Returns 0 if the point is inside the box.\n *\n * @example\n * // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return Cesium.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - Cesium.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);\n * });\n */\nOrientedBoundingBox.distanceSquaredTo = function (box, cartesian) {\n  // See Geometric Tools for Computer Graphics 10.4.2\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const offset = Cartesian3.subtract(cartesian, box.center, scratchOffset);\n\n  const halfAxes = box.halfAxes;\n  let u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\n  let v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\n  let w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\n\n  const uHalf = Cartesian3.magnitude(u);\n  const vHalf = Cartesian3.magnitude(v);\n  const wHalf = Cartesian3.magnitude(w);\n\n  let uValid = true;\n  let vValid = true;\n  let wValid = true;\n\n  if (uHalf > 0) {\n    Cartesian3.divideByScalar(u, uHalf, u);\n  } else {\n    uValid = false;\n  }\n\n  if (vHalf > 0) {\n    Cartesian3.divideByScalar(v, vHalf, v);\n  } else {\n    vValid = false;\n  }\n\n  if (wHalf > 0) {\n    Cartesian3.divideByScalar(w, wHalf, w);\n  } else {\n    wValid = false;\n  }\n\n  const numberOfDegenerateAxes = !uValid + !vValid + !wValid;\n  let validAxis1;\n  let validAxis2;\n  let validAxis3;\n\n  if (numberOfDegenerateAxes === 1) {\n    let degenerateAxis = u;\n    validAxis1 = v;\n    validAxis2 = w;\n    if (!vValid) {\n      degenerateAxis = v;\n      validAxis1 = u;\n    } else if (!wValid) {\n      degenerateAxis = w;\n      validAxis2 = u;\n    }\n\n    validAxis3 = Cartesian3.cross(validAxis1, validAxis2, scratchValidAxis3);\n\n    if (degenerateAxis === u) {\n      u = validAxis3;\n    } else if (degenerateAxis === v) {\n      v = validAxis3;\n    } else if (degenerateAxis === w) {\n      w = validAxis3;\n    }\n  } else if (numberOfDegenerateAxes === 2) {\n    validAxis1 = u;\n    if (vValid) {\n      validAxis1 = v;\n    } else if (wValid) {\n      validAxis1 = w;\n    }\n\n    let crossVector = Cartesian3.UNIT_Y;\n    if (crossVector.equalsEpsilon(validAxis1, CesiumMath.EPSILON3)) {\n      crossVector = Cartesian3.UNIT_X;\n    }\n\n    validAxis2 = Cartesian3.cross(validAxis1, crossVector, scratchValidAxis2);\n    Cartesian3.normalize(validAxis2, validAxis2);\n    validAxis3 = Cartesian3.cross(validAxis1, validAxis2, scratchValidAxis3);\n    Cartesian3.normalize(validAxis3, validAxis3);\n\n    if (validAxis1 === u) {\n      v = validAxis2;\n      w = validAxis3;\n    } else if (validAxis1 === v) {\n      w = validAxis2;\n      u = validAxis3;\n    } else if (validAxis1 === w) {\n      u = validAxis2;\n      v = validAxis3;\n    }\n  } else if (numberOfDegenerateAxes === 3) {\n    u = Cartesian3.UNIT_X;\n    v = Cartesian3.UNIT_Y;\n    w = Cartesian3.UNIT_Z;\n  }\n\n  const pPrime = scratchPPrime;\n  pPrime.x = Cartesian3.dot(offset, u);\n  pPrime.y = Cartesian3.dot(offset, v);\n  pPrime.z = Cartesian3.dot(offset, w);\n\n  let distanceSquared = 0.0;\n  let d;\n\n  if (pPrime.x < -uHalf) {\n    d = pPrime.x + uHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.x > uHalf) {\n    d = pPrime.x - uHalf;\n    distanceSquared += d * d;\n  }\n\n  if (pPrime.y < -vHalf) {\n    d = pPrime.y + vHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.y > vHalf) {\n    d = pPrime.y - vHalf;\n    distanceSquared += d * d;\n  }\n\n  if (pPrime.z < -wHalf) {\n    d = pPrime.z + wHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.z > wHalf) {\n    d = pPrime.z - wHalf;\n    distanceSquared += d * d;\n  }\n\n  return distanceSquared;\n};\n\nconst scratchCorner = new Cartesian3();\nconst scratchToCenter = new Cartesian3();\n\n/**\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding box.\n *\n * @param {OrientedBoundingBox} box The bounding box to calculate the distance to.\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\n */\nOrientedBoundingBox.computePlaneDistances = function (\n  box,\n  position,\n  direction,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Interval();\n  }\n\n  let minDist = Number.POSITIVE_INFINITY;\n  let maxDist = Number.NEGATIVE_INFINITY;\n\n  const center = box.center;\n  const halfAxes = box.halfAxes;\n\n  const u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\n  const v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\n  const w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\n\n  // project first corner\n  const corner = Cartesian3.add(u, v, scratchCorner);\n  Cartesian3.add(corner, w, corner);\n  Cartesian3.add(corner, center, corner);\n\n  const toCenter = Cartesian3.subtract(corner, position, scratchToCenter);\n  let mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project second corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project third corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project fourth corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project fifth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project sixth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project seventh corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project eighth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  result.start = minDist;\n  result.stop = maxDist;\n  return result;\n};\n\nconst scratchXAxis = new Cartesian3();\nconst scratchYAxis = new Cartesian3();\nconst scratchZAxis = new Cartesian3();\n\n/**\n * Computes the eight corners of an oriented bounding box. The corners are ordered by (-X, -Y, -Z), (-X, -Y, +Z), (-X, +Y, -Z), (-X, +Y, +Z), (+X, -Y, -Z), (+X, -Y, +Z), (+X, +Y, -Z), (+X, +Y, +Z).\n *\n * @param {OrientedBoundingBox} box The oriented bounding box.\n * @param {Cartesian3[]} [result] An array of eight {@link Cartesian3} instances onto which to store the corners.\n * @returns {Cartesian3[]} The modified result parameter or a new array if none was provided.\n */\nOrientedBoundingBox.computeCorners = function (box, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"box\", box);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n    ];\n  }\n\n  const center = box.center;\n  const halfAxes = box.halfAxes;\n  const xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);\n  const yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);\n  const zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);\n\n  Cartesian3.clone(center, result[0]);\n  Cartesian3.subtract(result[0], xAxis, result[0]);\n  Cartesian3.subtract(result[0], yAxis, result[0]);\n  Cartesian3.subtract(result[0], zAxis, result[0]);\n\n  Cartesian3.clone(center, result[1]);\n  Cartesian3.subtract(result[1], xAxis, result[1]);\n  Cartesian3.subtract(result[1], yAxis, result[1]);\n  Cartesian3.add(result[1], zAxis, result[1]);\n\n  Cartesian3.clone(center, result[2]);\n  Cartesian3.subtract(result[2], xAxis, result[2]);\n  Cartesian3.add(result[2], yAxis, result[2]);\n  Cartesian3.subtract(result[2], zAxis, result[2]);\n\n  Cartesian3.clone(center, result[3]);\n  Cartesian3.subtract(result[3], xAxis, result[3]);\n  Cartesian3.add(result[3], yAxis, result[3]);\n  Cartesian3.add(result[3], zAxis, result[3]);\n\n  Cartesian3.clone(center, result[4]);\n  Cartesian3.add(result[4], xAxis, result[4]);\n  Cartesian3.subtract(result[4], yAxis, result[4]);\n  Cartesian3.subtract(result[4], zAxis, result[4]);\n\n  Cartesian3.clone(center, result[5]);\n  Cartesian3.add(result[5], xAxis, result[5]);\n  Cartesian3.subtract(result[5], yAxis, result[5]);\n  Cartesian3.add(result[5], zAxis, result[5]);\n\n  Cartesian3.clone(center, result[6]);\n  Cartesian3.add(result[6], xAxis, result[6]);\n  Cartesian3.add(result[6], yAxis, result[6]);\n  Cartesian3.subtract(result[6], zAxis, result[6]);\n\n  Cartesian3.clone(center, result[7]);\n  Cartesian3.add(result[7], xAxis, result[7]);\n  Cartesian3.add(result[7], yAxis, result[7]);\n  Cartesian3.add(result[7], zAxis, result[7]);\n\n  return result;\n};\n\nconst scratchRotationScale = new Matrix3();\n\n/**\n * Computes a transformation matrix from an oriented bounding box.\n *\n * @param {OrientedBoundingBox} box The oriented bounding box.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new {@link Matrix4} instance if none was provided.\n */\nOrientedBoundingBox.computeTransformation = function (box, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"box\", box);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Matrix4();\n  }\n\n  const translation = box.center;\n  const rotationScale = Matrix3.multiplyByUniformScale(\n    box.halfAxes,\n    2.0,\n    scratchRotationScale,\n  );\n  return Matrix4.fromRotationTranslation(rotationScale, translation, result);\n};\n\nconst scratchBoundingSphere = new BoundingSphere();\n\n/**\n * Determines whether or not a bounding box is hidden from view by the occluder.\n *\n * @param {OrientedBoundingBox} box The bounding box surrounding the occludee object.\n * @param {Occluder} occluder The occluder.\n * @returns {boolean} <code>true</code> if the box is not visible; otherwise <code>false</code>.\n */\nOrientedBoundingBox.isOccluded = function (box, occluder) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n  if (!defined(occluder)) {\n    throw new DeveloperError(\"occluder is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const sphere = BoundingSphere.fromOrientedBoundingBox(\n    box,\n    scratchBoundingSphere,\n  );\n\n  return !occluder.isBoundingSphereVisible(sphere);\n};\n\n/**\n * Determines which side of a plane the oriented bounding box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nOrientedBoundingBox.prototype.intersectPlane = function (plane) {\n  return OrientedBoundingBox.intersectPlane(this, plane);\n};\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\n *\n * @param {Cartesian3} cartesian The point\n * @returns {number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n * });\n */\nOrientedBoundingBox.prototype.distanceSquaredTo = function (cartesian) {\n  return OrientedBoundingBox.distanceSquaredTo(this, cartesian);\n};\n\n/**\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding box.\n *\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\n */\nOrientedBoundingBox.prototype.computePlaneDistances = function (\n  position,\n  direction,\n  result,\n) {\n  return OrientedBoundingBox.computePlaneDistances(\n    this,\n    position,\n    direction,\n    result,\n  );\n};\n\n/**\n * Computes the eight corners of an oriented bounding box. The corners are ordered by (-X, -Y, -Z), (-X, -Y, +Z), (-X, +Y, -Z), (-X, +Y, +Z), (+X, -Y, -Z), (+X, -Y, +Z), (+X, +Y, -Z), (+X, +Y, +Z).\n *\n * @param {Cartesian3[]} [result] An array of eight {@link Cartesian3} instances onto which to store the corners.\n * @returns {Cartesian3[]} The modified result parameter or a new array if none was provided.\n */\nOrientedBoundingBox.prototype.computeCorners = function (result) {\n  return OrientedBoundingBox.computeCorners(this, result);\n};\n\n/**\n * Computes a transformation matrix from an oriented bounding box.\n *\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new {@link Matrix4} instance if none was provided.\n */\nOrientedBoundingBox.prototype.computeTransformation = function (result) {\n  return OrientedBoundingBox.computeTransformation(this, result);\n};\n\n/**\n * Determines whether or not a bounding box is hidden from view by the occluder.\n *\n * @param {Occluder} occluder The occluder.\n * @returns {boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\nOrientedBoundingBox.prototype.isOccluded = function (occluder) {\n  return OrientedBoundingBox.isOccluded(this, occluder);\n};\n\n/**\n * Compares the provided OrientedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrientedBoundingBox} [left] The first OrientedBoundingBox.\n * @param {OrientedBoundingBox} [right] The second OrientedBoundingBox.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nOrientedBoundingBox.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Cartesian3.equals(left.center, right.center) &&\n      Matrix3.equals(left.halfAxes, right.halfAxes))\n  );\n};\n\n/**\n * Duplicates this OrientedBoundingBox instance.\n *\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n */\nOrientedBoundingBox.prototype.clone = function (result) {\n  return OrientedBoundingBox.clone(this, result);\n};\n\n/**\n * Compares this OrientedBoundingBox against the provided OrientedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrientedBoundingBox} [right] The right hand side OrientedBoundingBox.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nOrientedBoundingBox.prototype.equals = function (right) {\n  return OrientedBoundingBox.equals(this, right);\n};\nexport default OrientedBoundingBox;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}