{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"in vec2 v_textureCoordinates;\\n\\\n\\n\\\nuniform int u_polygonsLength;\\n\\\nuniform int u_extentsLength;\\n\\\nuniform highp sampler2D u_polygonTexture;\\n\\\nuniform highp sampler2D u_extentsTexture;\\n\\\n\\n\\\nint getPolygonIndex(float dimension, vec2 coord) {\\n\\\n   vec2 uv = coord.xy * dimension;\\n\\\n   return int(floor(uv.y) * dimension + floor(uv.x));\\n\\\n}\\n\\\n\\n\\\nvec2 getLookupUv(ivec2 dimensions, int i) {\\n\\\n    int pixY = i / dimensions.x;\\n\\\n    int pixX = i - (pixY * dimensions.x);\\n\\\n    float pixelWidth = 1.0 / float(dimensions.x);\\n\\\n    float pixelHeight = 1.0 / float(dimensions.y);\\n\\\n    float u = (float(pixX) + 0.5) * pixelWidth; // sample from center of pixel\\n\\\n    float v = (float(pixY) + 0.5) * pixelHeight;\\n\\\n    return vec2(u, v);\\n\\\n}\\n\\\n\\n\\\nvec4 getExtents(int i) {\\n\\\n    return texture(u_extentsTexture, getLookupUv(textureSize(u_extentsTexture, 0), i));\\n\\\n}\\n\\\n\\n\\\nivec2 getPositionsLengthAndExtentsIndex(int i) {\\n\\\n    vec2 uv = getLookupUv(textureSize(u_polygonTexture, 0), i);\\n\\\n    vec4 value = texture(u_polygonTexture, uv);\\n\\\n    return ivec2(int(value.x), int(value.y));\\n\\\n}\\n\\\n\\n\\\nvec2 getPolygonPosition(int i) {\\n\\\n    vec2 uv = getLookupUv(textureSize(u_polygonTexture, 0), i);\\n\\\n    return texture(u_polygonTexture, uv).xy;\\n\\\n}\\n\\\n\\n\\\nvec2 getCoordinates(vec2 textureCoordinates, vec4 extents) {\\n\\\n    float latitude = mix(extents.x, extents.x + 1.0 / extents.z, textureCoordinates.y);\\n\\\n    float longitude = mix(extents.y, extents.y + 1.0 / extents.w, textureCoordinates.x);\\n\\\n    return vec2(latitude, longitude);\\n\\\n}\\n\\\n\\n\\\nvoid main() {\\n\\\n    int lastPolygonIndex = 0;\\n\\\n    out_FragColor = vec4(1.0);\\n\\\n\\n\\\n    // Get the relevant region of the texture\\n\\\n    float dimension = float(u_extentsLength);\\n\\\n    if (u_extentsLength > 2) {\\n\\\n        dimension = ceil(log2(float(u_extentsLength)));\\n\\\n    }\\n\\\n    int regionIndex = getPolygonIndex(dimension, v_textureCoordinates);\\n\\\n\\n\\\n    for (int polygonIndex = 0; polygonIndex < u_polygonsLength; polygonIndex++) {\\n\\\n        ivec2 positionsLengthAndExtents = getPositionsLengthAndExtentsIndex(lastPolygonIndex);\\n\\\n        int positionsLength = positionsLengthAndExtents.x;\\n\\\n        int polygonExtentsIndex = positionsLengthAndExtents.y;\\n\\\n        lastPolygonIndex += 1;\\n\\\n\\n\\\n         // Only compute signed distance for the relevant part of the atlas\\n\\\n         if (polygonExtentsIndex == regionIndex) {\\n\\\n            float clipAmount = czm_infinity;\\n\\\n            vec4 extents = getExtents(polygonExtentsIndex);\\n\\\n            vec2 textureOffset = vec2(mod(float(polygonExtentsIndex), dimension), floor(float(polygonExtentsIndex) / dimension)) / dimension;\\n\\\n            vec2 p = getCoordinates((v_textureCoordinates - textureOffset) * dimension, extents);\\n\\\n            float s = 1.0;\\n\\\n\\n\\\n            // Check each edge for absolute distance\\n\\\n            for (int i = 0, j = positionsLength - 1; i < positionsLength; j = i, i++) {\\n\\\n                vec2 a = getPolygonPosition(lastPolygonIndex + i);\\n\\\n                vec2 b = getPolygonPosition(lastPolygonIndex + j);\\n\\\n \\n\\\n                vec2 ab = b - a;\\n\\\n                vec2 pa = p - a;\\n\\\n                float t = dot(pa, ab) / dot(ab, ab);\\n\\\n                t = clamp(t, 0.0, 1.0);\\n\\\n\\n\\\n                vec2 pq = pa - t * ab;\\n\\\n                float d = length(pq);\\n\\\n\\n\\\n                // Inside / outside computation to determine sign\\n\\\n                bvec3 cond = bvec3(p.y >= a.y, \\n\\\n                            p.y < b.y, \\n\\\n                            ab.x * pa.y > ab.y * pa.x);\\n\\\n                if (all(cond) || all(not(cond))) s = -s;\\n\\\n                if (abs(d) < abs(clipAmount)) {\\n\\\n                    clipAmount = d;\\n\\\n                }\\n\\\n            }\\n\\\n\\n\\\n            // Normalize the range to [0,1]\\n\\\n            vec4 result = (s * vec4(clipAmount * length(extents.zw))) / 2.0 + 0.5;\\n\\\n            // In the case where we've iterated through multiple polygons, take the minimum\\n\\\n            out_FragColor = min(out_FragColor, result);\\n\\\n         }\\n\\\n\\n\\\n        lastPolygonIndex += positionsLength;\\n\\\n    }\\n\\\n}\";","map":{"version":3,"names":[],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Shaders/PolygonSignedDistanceFS.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"in vec2 v_textureCoordinates;\\n\\\n\\n\\\nuniform int u_polygonsLength;\\n\\\nuniform int u_extentsLength;\\n\\\nuniform highp sampler2D u_polygonTexture;\\n\\\nuniform highp sampler2D u_extentsTexture;\\n\\\n\\n\\\nint getPolygonIndex(float dimension, vec2 coord) {\\n\\\n   vec2 uv = coord.xy * dimension;\\n\\\n   return int(floor(uv.y) * dimension + floor(uv.x));\\n\\\n}\\n\\\n\\n\\\nvec2 getLookupUv(ivec2 dimensions, int i) {\\n\\\n    int pixY = i / dimensions.x;\\n\\\n    int pixX = i - (pixY * dimensions.x);\\n\\\n    float pixelWidth = 1.0 / float(dimensions.x);\\n\\\n    float pixelHeight = 1.0 / float(dimensions.y);\\n\\\n    float u = (float(pixX) + 0.5) * pixelWidth; // sample from center of pixel\\n\\\n    float v = (float(pixY) + 0.5) * pixelHeight;\\n\\\n    return vec2(u, v);\\n\\\n}\\n\\\n\\n\\\nvec4 getExtents(int i) {\\n\\\n    return texture(u_extentsTexture, getLookupUv(textureSize(u_extentsTexture, 0), i));\\n\\\n}\\n\\\n\\n\\\nivec2 getPositionsLengthAndExtentsIndex(int i) {\\n\\\n    vec2 uv = getLookupUv(textureSize(u_polygonTexture, 0), i);\\n\\\n    vec4 value = texture(u_polygonTexture, uv);\\n\\\n    return ivec2(int(value.x), int(value.y));\\n\\\n}\\n\\\n\\n\\\nvec2 getPolygonPosition(int i) {\\n\\\n    vec2 uv = getLookupUv(textureSize(u_polygonTexture, 0), i);\\n\\\n    return texture(u_polygonTexture, uv).xy;\\n\\\n}\\n\\\n\\n\\\nvec2 getCoordinates(vec2 textureCoordinates, vec4 extents) {\\n\\\n    float latitude = mix(extents.x, extents.x + 1.0 / extents.z, textureCoordinates.y);\\n\\\n    float longitude = mix(extents.y, extents.y + 1.0 / extents.w, textureCoordinates.x);\\n\\\n    return vec2(latitude, longitude);\\n\\\n}\\n\\\n\\n\\\nvoid main() {\\n\\\n    int lastPolygonIndex = 0;\\n\\\n    out_FragColor = vec4(1.0);\\n\\\n\\n\\\n    // Get the relevant region of the texture\\n\\\n    float dimension = float(u_extentsLength);\\n\\\n    if (u_extentsLength > 2) {\\n\\\n        dimension = ceil(log2(float(u_extentsLength)));\\n\\\n    }\\n\\\n    int regionIndex = getPolygonIndex(dimension, v_textureCoordinates);\\n\\\n\\n\\\n    for (int polygonIndex = 0; polygonIndex < u_polygonsLength; polygonIndex++) {\\n\\\n        ivec2 positionsLengthAndExtents = getPositionsLengthAndExtentsIndex(lastPolygonIndex);\\n\\\n        int positionsLength = positionsLengthAndExtents.x;\\n\\\n        int polygonExtentsIndex = positionsLengthAndExtents.y;\\n\\\n        lastPolygonIndex += 1;\\n\\\n\\n\\\n         // Only compute signed distance for the relevant part of the atlas\\n\\\n         if (polygonExtentsIndex == regionIndex) {\\n\\\n            float clipAmount = czm_infinity;\\n\\\n            vec4 extents = getExtents(polygonExtentsIndex);\\n\\\n            vec2 textureOffset = vec2(mod(float(polygonExtentsIndex), dimension), floor(float(polygonExtentsIndex) / dimension)) / dimension;\\n\\\n            vec2 p = getCoordinates((v_textureCoordinates - textureOffset) * dimension, extents);\\n\\\n            float s = 1.0;\\n\\\n\\n\\\n            // Check each edge for absolute distance\\n\\\n            for (int i = 0, j = positionsLength - 1; i < positionsLength; j = i, i++) {\\n\\\n                vec2 a = getPolygonPosition(lastPolygonIndex + i);\\n\\\n                vec2 b = getPolygonPosition(lastPolygonIndex + j);\\n\\\n \\n\\\n                vec2 ab = b - a;\\n\\\n                vec2 pa = p - a;\\n\\\n                float t = dot(pa, ab) / dot(ab, ab);\\n\\\n                t = clamp(t, 0.0, 1.0);\\n\\\n\\n\\\n                vec2 pq = pa - t * ab;\\n\\\n                float d = length(pq);\\n\\\n\\n\\\n                // Inside / outside computation to determine sign\\n\\\n                bvec3 cond = bvec3(p.y >= a.y, \\n\\\n                            p.y < b.y, \\n\\\n                            ab.x * pa.y > ab.y * pa.x);\\n\\\n                if (all(cond) || all(not(cond))) s = -s;\\n\\\n                if (abs(d) < abs(clipAmount)) {\\n\\\n                    clipAmount = d;\\n\\\n                }\\n\\\n            }\\n\\\n\\n\\\n            // Normalize the range to [0,1]\\n\\\n            vec4 result = (s * vec4(clipAmount * length(extents.zw))) / 2.0 + 0.5;\\n\\\n            // In the case where we've iterated through multiple polygons, take the minimum\\n\\\n            out_FragColor = min(out_FragColor, result);\\n\\\n         }\\n\\\n\\n\\\n        lastPolygonIndex += positionsLength;\\n\\\n    }\\n\\\n}\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}