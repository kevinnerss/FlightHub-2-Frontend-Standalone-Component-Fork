{"ast":null,"code":"import Check from \"./Check.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport JulianDate from \"./JulianDate.js\";\n\n/**\n * An interval defined by a start and a stop time; optionally including those times as part of the interval.\n * Arbitrary data can optionally be associated with each instance for used with {@link TimeIntervalCollection}.\n *\n * @alias TimeInterval\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {JulianDate} [options.start=new JulianDate()] The start time of the interval.\n * @param {JulianDate} [options.stop=new JulianDate()] The stop time of the interval.\n * @param {boolean} [options.isStartIncluded=true] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.isStopIncluded=true] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.\n * @param {object} [options.data] Arbitrary data associated with this interval.\n *\n * @example\n * // Create an instance that spans August 1st, 1980 and is associated\n * // with a Cartesian position.\n * const timeInterval = new Cesium.TimeInterval({\n *     start : Cesium.JulianDate.fromIso8601('1980-08-01T00:00:00Z'),\n *     stop : Cesium.JulianDate.fromIso8601('1980-08-02T00:00:00Z'),\n *     isStartIncluded : true,\n *     isStopIncluded : false,\n *     data : Cesium.Cartesian3.fromDegrees(39.921037, -75.170082)\n * });\n *\n * @example\n * // Create two instances from ISO 8601 intervals with associated numeric data\n * // then compute their intersection, summing the data they contain.\n * const left = Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2000/2010',\n *     data : 2\n * });\n *\n * const right = Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '1995/2005',\n *     data : 3\n * });\n *\n * //The result of the below intersection will be an interval equivalent to\n * //const intersection = Cesium.TimeInterval.fromIso8601({\n * //  iso8601 : '2000/2005',\n * //  data : 5\n * //});\n * const intersection = new Cesium.TimeInterval();\n * Cesium.TimeInterval.intersect(left, right, intersection, function(leftData, rightData) {\n *     return leftData + rightData;\n * });\n *\n * @example\n * // Check if an interval contains a specific time.\n * const dateToCheck = Cesium.JulianDate.fromIso8601('1982-09-08T11:30:00Z');\n * const containsDate = Cesium.TimeInterval.contains(timeInterval, dateToCheck);\n */\nfunction TimeInterval(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  /**\n   * Gets or sets the start time of this interval.\n   * @type {JulianDate}\n   */\n  this.start = defined(options.start) ? JulianDate.clone(options.start) : new JulianDate();\n\n  /**\n   * Gets or sets the stop time of this interval.\n   * @type {JulianDate}\n   */\n  this.stop = defined(options.stop) ? JulianDate.clone(options.stop) : new JulianDate();\n\n  /**\n   * Gets or sets the data associated with this interval.\n   * @type {*}\n   */\n  this.data = options.data;\n\n  /**\n   * Gets or sets whether or not the start time is included in this interval.\n   * @type {boolean}\n   * @default true\n   */\n  this.isStartIncluded = options.isStartIncluded ?? true;\n\n  /**\n   * Gets or sets whether or not the stop time is included in this interval.\n   * @type {boolean}\n   * @default true\n   */\n  this.isStopIncluded = options.isStopIncluded ?? true;\n}\nObject.defineProperties(TimeInterval.prototype, {\n  /**\n   * Gets whether or not this interval is empty.\n   * @memberof TimeInterval.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  isEmpty: {\n    get: function () {\n      const stopComparedToStart = JulianDate.compare(this.stop, this.start);\n      return stopComparedToStart < 0 || stopComparedToStart === 0 && (!this.isStartIncluded || !this.isStopIncluded);\n    }\n  }\n});\nconst scratchInterval = {\n  start: undefined,\n  stop: undefined,\n  isStartIncluded: undefined,\n  isStopIncluded: undefined,\n  data: undefined\n};\n\n/**\n * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} interval.\n *\n * @throws DeveloperError if options.iso8601 does not match proper formatting.\n *\n * @param {object} options Object with the following properties:\n * @param {string} options.iso8601 An ISO 8601 interval.\n * @param {boolean} [options.isStartIncluded=true] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.isStopIncluded=true] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.\n * @param {object} [options.data] Arbitrary data associated with this interval.\n * @param {TimeInterval} [result] An existing instance to use for the result.\n * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.\n */\nTimeInterval.fromIso8601 = function (options, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.string(\"options.iso8601\", options.iso8601);\n  //>>includeEnd('debug');\n\n  const dates = options.iso8601.split(\"/\");\n  if (dates.length !== 2) {\n    throw new DeveloperError(\"options.iso8601 is an invalid ISO 8601 interval.\");\n  }\n  const start = JulianDate.fromIso8601(dates[0]);\n  const stop = JulianDate.fromIso8601(dates[1]);\n  const isStartIncluded = options.isStartIncluded ?? true;\n  const isStopIncluded = options.isStopIncluded ?? true;\n  const data = options.data;\n  if (!defined(result)) {\n    scratchInterval.start = start;\n    scratchInterval.stop = stop;\n    scratchInterval.isStartIncluded = isStartIncluded;\n    scratchInterval.isStopIncluded = isStopIncluded;\n    scratchInterval.data = data;\n    return new TimeInterval(scratchInterval);\n  }\n  result.start = start;\n  result.stop = stop;\n  result.isStartIncluded = isStartIncluded;\n  result.isStopIncluded = isStopIncluded;\n  result.data = data;\n  return result;\n};\n\n/**\n * Creates an ISO8601 representation of the provided interval.\n *\n * @param {TimeInterval} timeInterval The interval to be converted.\n * @param {number} [precision] The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.\n * @returns {string} The ISO8601 representation of the provided interval.\n */\nTimeInterval.toIso8601 = function (timeInterval, precision) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"timeInterval\", timeInterval);\n  //>>includeEnd('debug');\n\n  return `${JulianDate.toIso8601(timeInterval.start, precision)}/${JulianDate.toIso8601(timeInterval.stop, precision)}`;\n};\n\n/**\n * Duplicates the provided instance.\n *\n * @param {TimeInterval} [timeInterval] The instance to clone.\n * @param {TimeInterval} [result] An existing instance to use for the result.\n * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.\n */\nTimeInterval.clone = function (timeInterval, result) {\n  if (!defined(timeInterval)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new TimeInterval(timeInterval);\n  }\n  result.start = timeInterval.start;\n  result.stop = timeInterval.stop;\n  result.isStartIncluded = timeInterval.isStartIncluded;\n  result.isStopIncluded = timeInterval.isStopIncluded;\n  result.data = timeInterval.data;\n  return result;\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {TimeInterval} [left] The first instance.\n * @param {TimeInterval} [right] The second instance.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n */\nTimeInterval.equals = function (left, right, dataComparer) {\n  return left === right || defined(left) && defined(right) && (left.isEmpty && right.isEmpty || left.isStartIncluded === right.isStartIncluded && left.isStopIncluded === right.isStopIncluded && JulianDate.equals(left.start, right.start) && JulianDate.equals(left.stop, right.stop) && (left.data === right.data || defined(dataComparer) && dataComparer(left.data, right.data)));\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n * each other.  That is, in order for the dates to be considered equal (and for\n * this function to return <code>true</code>), the absolute value of the difference between them, in\n * seconds, must be less than <code>epsilon</code>.\n *\n * @param {TimeInterval} [left] The first instance.\n * @param {TimeInterval} [right] The second instance.\n * @param {number} [epsilon=0] The maximum number of seconds that should separate the two instances.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n */\nTimeInterval.equalsEpsilon = function (left, right, epsilon, dataComparer) {\n  epsilon = epsilon ?? 0;\n  return left === right || defined(left) && defined(right) && (left.isEmpty && right.isEmpty || left.isStartIncluded === right.isStartIncluded && left.isStopIncluded === right.isStopIncluded && JulianDate.equalsEpsilon(left.start, right.start, epsilon) && JulianDate.equalsEpsilon(left.stop, right.stop, epsilon) && (left.data === right.data || defined(dataComparer) && dataComparer(left.data, right.data)));\n};\n\n/**\n * Computes the intersection of two intervals, optionally merging their data.\n *\n * @param {TimeInterval} left The first interval.\n * @param {TimeInterval} [right] The second interval.\n * @param {TimeInterval} [result] An existing instance to use for the result.\n * @param {TimeInterval.MergeCallback} [mergeCallback] A function which merges the data of the two intervals. If omitted, the data from the left interval will be used.\n * @returns {TimeInterval} The modified result parameter.\n */\nTimeInterval.intersect = function (left, right, result, mergeCallback) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  //>>includeEnd('debug');\n\n  if (!defined(right)) {\n    return TimeInterval.clone(TimeInterval.EMPTY, result);\n  }\n  const leftStart = left.start;\n  const leftStop = left.stop;\n  const rightStart = right.start;\n  const rightStop = right.stop;\n  const intersectsStartRight = JulianDate.greaterThanOrEquals(rightStart, leftStart) && JulianDate.greaterThanOrEquals(leftStop, rightStart);\n  const intersectsStartLeft = !intersectsStartRight && JulianDate.lessThanOrEquals(rightStart, leftStart) && JulianDate.lessThanOrEquals(leftStart, rightStop);\n  if (!intersectsStartRight && !intersectsStartLeft) {\n    return TimeInterval.clone(TimeInterval.EMPTY, result);\n  }\n  const leftIsStartIncluded = left.isStartIncluded;\n  const leftIsStopIncluded = left.isStopIncluded;\n  const rightIsStartIncluded = right.isStartIncluded;\n  const rightIsStopIncluded = right.isStopIncluded;\n  const leftLessThanRight = JulianDate.lessThan(leftStop, rightStop);\n  if (!defined(result)) {\n    result = new TimeInterval();\n  }\n  result.start = intersectsStartRight ? rightStart : leftStart;\n  result.isStartIncluded = leftIsStartIncluded && rightIsStartIncluded || !JulianDate.equals(rightStart, leftStart) && (intersectsStartRight && rightIsStartIncluded || intersectsStartLeft && leftIsStartIncluded);\n  result.stop = leftLessThanRight ? leftStop : rightStop;\n  result.isStopIncluded = leftLessThanRight ? leftIsStopIncluded : leftIsStopIncluded && rightIsStopIncluded || !JulianDate.equals(rightStop, leftStop) && rightIsStopIncluded;\n  result.data = defined(mergeCallback) ? mergeCallback(left.data, right.data) : left.data;\n  return result;\n};\n\n/**\n * Checks if the specified date is inside the provided interval.\n *\n * @param {TimeInterval} timeInterval The interval.\n * @param {JulianDate} julianDate The date to check.\n * @returns {boolean} <code>true</code> if the interval contains the specified date, <code>false</code> otherwise.\n */\nTimeInterval.contains = function (timeInterval, julianDate) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"timeInterval\", timeInterval);\n  Check.typeOf.object(\"julianDate\", julianDate);\n  //>>includeEnd('debug');\n\n  if (timeInterval.isEmpty) {\n    return false;\n  }\n  const startComparedToDate = JulianDate.compare(timeInterval.start, julianDate);\n  if (startComparedToDate === 0) {\n    return timeInterval.isStartIncluded;\n  }\n  const dateComparedToStop = JulianDate.compare(julianDate, timeInterval.stop);\n  if (dateComparedToStop === 0) {\n    return timeInterval.isStopIncluded;\n  }\n  return startComparedToDate < 0 && dateComparedToStop < 0;\n};\n\n/**\n * Duplicates this instance.\n *\n * @param {TimeInterval} [result] An existing instance to use for the result.\n * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.\n */\nTimeInterval.prototype.clone = function (result) {\n  return TimeInterval.clone(this, result);\n};\n\n/**\n * Compares this instance against the provided instance componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {TimeInterval} [right] The right hand side interval.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nTimeInterval.prototype.equals = function (right, dataComparer) {\n  return TimeInterval.equals(this, right, dataComparer);\n};\n\n/**\n * Compares this instance against the provided instance componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {TimeInterval} [right] The right hand side interval.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nTimeInterval.prototype.equalsEpsilon = function (right, epsilon, dataComparer) {\n  return TimeInterval.equalsEpsilon(this, right, epsilon, dataComparer);\n};\n\n/**\n * Creates a string representing this TimeInterval in ISO8601 format.\n *\n * @returns {string} A string representing this TimeInterval in ISO8601 format.\n */\nTimeInterval.prototype.toString = function () {\n  return TimeInterval.toIso8601(this);\n};\n\n/**\n * An immutable empty interval.\n *\n * @type {TimeInterval}\n * @constant\n */\nTimeInterval.EMPTY = Object.freeze(new TimeInterval({\n  start: new JulianDate(),\n  stop: new JulianDate(),\n  isStartIncluded: false,\n  isStopIncluded: false\n}));\n\n/**\n * Function interface for merging interval data.\n * @callback TimeInterval.MergeCallback\n *\n * @param {*} leftData The first data instance.\n * @param {*} rightData The second data instance.\n * @returns {*} The result of merging the two data instances.\n */\n\n/**\n * Function interface for comparing interval data.\n * @callback TimeInterval.DataComparer\n * @param {*} leftData The first data instance.\n * @param {*} rightData The second data instance.\n * @returns {boolean} <code>true</code> if the provided instances are equal, <code>false</code> otherwise.\n */\nexport default TimeInterval;","map":{"version":3,"names":["Check","Frozen","defined","DeveloperError","JulianDate","TimeInterval","options","EMPTY_OBJECT","start","clone","stop","data","isStartIncluded","isStopIncluded","Object","defineProperties","prototype","isEmpty","get","stopComparedToStart","compare","scratchInterval","undefined","fromIso8601","result","typeOf","object","string","iso8601","dates","split","length","toIso8601","timeInterval","precision","equals","left","right","dataComparer","equalsEpsilon","epsilon","intersect","mergeCallback","EMPTY","leftStart","leftStop","rightStart","rightStop","intersectsStartRight","greaterThanOrEquals","intersectsStartLeft","lessThanOrEquals","leftIsStartIncluded","leftIsStopIncluded","rightIsStartIncluded","rightIsStopIncluded","leftLessThanRight","lessThan","contains","julianDate","startComparedToDate","dateComparedToStop","toString","freeze"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Core/TimeInterval.js"],"sourcesContent":["import Check from \"./Check.js\";\nimport Frozen from \"./Frozen.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport JulianDate from \"./JulianDate.js\";\n\n/**\n * An interval defined by a start and a stop time; optionally including those times as part of the interval.\n * Arbitrary data can optionally be associated with each instance for used with {@link TimeIntervalCollection}.\n *\n * @alias TimeInterval\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {JulianDate} [options.start=new JulianDate()] The start time of the interval.\n * @param {JulianDate} [options.stop=new JulianDate()] The stop time of the interval.\n * @param {boolean} [options.isStartIncluded=true] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.isStopIncluded=true] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.\n * @param {object} [options.data] Arbitrary data associated with this interval.\n *\n * @example\n * // Create an instance that spans August 1st, 1980 and is associated\n * // with a Cartesian position.\n * const timeInterval = new Cesium.TimeInterval({\n *     start : Cesium.JulianDate.fromIso8601('1980-08-01T00:00:00Z'),\n *     stop : Cesium.JulianDate.fromIso8601('1980-08-02T00:00:00Z'),\n *     isStartIncluded : true,\n *     isStopIncluded : false,\n *     data : Cesium.Cartesian3.fromDegrees(39.921037, -75.170082)\n * });\n *\n * @example\n * // Create two instances from ISO 8601 intervals with associated numeric data\n * // then compute their intersection, summing the data they contain.\n * const left = Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '2000/2010',\n *     data : 2\n * });\n *\n * const right = Cesium.TimeInterval.fromIso8601({\n *     iso8601 : '1995/2005',\n *     data : 3\n * });\n *\n * //The result of the below intersection will be an interval equivalent to\n * //const intersection = Cesium.TimeInterval.fromIso8601({\n * //  iso8601 : '2000/2005',\n * //  data : 5\n * //});\n * const intersection = new Cesium.TimeInterval();\n * Cesium.TimeInterval.intersect(left, right, intersection, function(leftData, rightData) {\n *     return leftData + rightData;\n * });\n *\n * @example\n * // Check if an interval contains a specific time.\n * const dateToCheck = Cesium.JulianDate.fromIso8601('1982-09-08T11:30:00Z');\n * const containsDate = Cesium.TimeInterval.contains(timeInterval, dateToCheck);\n */\nfunction TimeInterval(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n  /**\n   * Gets or sets the start time of this interval.\n   * @type {JulianDate}\n   */\n  this.start = defined(options.start)\n    ? JulianDate.clone(options.start)\n    : new JulianDate();\n\n  /**\n   * Gets or sets the stop time of this interval.\n   * @type {JulianDate}\n   */\n  this.stop = defined(options.stop)\n    ? JulianDate.clone(options.stop)\n    : new JulianDate();\n\n  /**\n   * Gets or sets the data associated with this interval.\n   * @type {*}\n   */\n  this.data = options.data;\n\n  /**\n   * Gets or sets whether or not the start time is included in this interval.\n   * @type {boolean}\n   * @default true\n   */\n  this.isStartIncluded = options.isStartIncluded ?? true;\n\n  /**\n   * Gets or sets whether or not the stop time is included in this interval.\n   * @type {boolean}\n   * @default true\n   */\n  this.isStopIncluded = options.isStopIncluded ?? true;\n}\n\nObject.defineProperties(TimeInterval.prototype, {\n  /**\n   * Gets whether or not this interval is empty.\n   * @memberof TimeInterval.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  isEmpty: {\n    get: function () {\n      const stopComparedToStart = JulianDate.compare(this.stop, this.start);\n      return (\n        stopComparedToStart < 0 ||\n        (stopComparedToStart === 0 &&\n          (!this.isStartIncluded || !this.isStopIncluded))\n      );\n    },\n  },\n});\n\nconst scratchInterval = {\n  start: undefined,\n  stop: undefined,\n  isStartIncluded: undefined,\n  isStopIncluded: undefined,\n  data: undefined,\n};\n\n/**\n * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} interval.\n *\n * @throws DeveloperError if options.iso8601 does not match proper formatting.\n *\n * @param {object} options Object with the following properties:\n * @param {string} options.iso8601 An ISO 8601 interval.\n * @param {boolean} [options.isStartIncluded=true] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.\n * @param {boolean} [options.isStopIncluded=true] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.\n * @param {object} [options.data] Arbitrary data associated with this interval.\n * @param {TimeInterval} [result] An existing instance to use for the result.\n * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.\n */\nTimeInterval.fromIso8601 = function (options, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.string(\"options.iso8601\", options.iso8601);\n  //>>includeEnd('debug');\n\n  const dates = options.iso8601.split(\"/\");\n  if (dates.length !== 2) {\n    throw new DeveloperError(\n      \"options.iso8601 is an invalid ISO 8601 interval.\",\n    );\n  }\n  const start = JulianDate.fromIso8601(dates[0]);\n  const stop = JulianDate.fromIso8601(dates[1]);\n  const isStartIncluded = options.isStartIncluded ?? true;\n  const isStopIncluded = options.isStopIncluded ?? true;\n  const data = options.data;\n\n  if (!defined(result)) {\n    scratchInterval.start = start;\n    scratchInterval.stop = stop;\n    scratchInterval.isStartIncluded = isStartIncluded;\n    scratchInterval.isStopIncluded = isStopIncluded;\n    scratchInterval.data = data;\n    return new TimeInterval(scratchInterval);\n  }\n\n  result.start = start;\n  result.stop = stop;\n  result.isStartIncluded = isStartIncluded;\n  result.isStopIncluded = isStopIncluded;\n  result.data = data;\n  return result;\n};\n\n/**\n * Creates an ISO8601 representation of the provided interval.\n *\n * @param {TimeInterval} timeInterval The interval to be converted.\n * @param {number} [precision] The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.\n * @returns {string} The ISO8601 representation of the provided interval.\n */\nTimeInterval.toIso8601 = function (timeInterval, precision) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"timeInterval\", timeInterval);\n  //>>includeEnd('debug');\n\n  return `${JulianDate.toIso8601(\n    timeInterval.start,\n    precision,\n  )}/${JulianDate.toIso8601(timeInterval.stop, precision)}`;\n};\n\n/**\n * Duplicates the provided instance.\n *\n * @param {TimeInterval} [timeInterval] The instance to clone.\n * @param {TimeInterval} [result] An existing instance to use for the result.\n * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.\n */\nTimeInterval.clone = function (timeInterval, result) {\n  if (!defined(timeInterval)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new TimeInterval(timeInterval);\n  }\n  result.start = timeInterval.start;\n  result.stop = timeInterval.stop;\n  result.isStartIncluded = timeInterval.isStartIncluded;\n  result.isStopIncluded = timeInterval.isStopIncluded;\n  result.data = timeInterval.data;\n  return result;\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {TimeInterval} [left] The first instance.\n * @param {TimeInterval} [right] The second instance.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n */\nTimeInterval.equals = function (left, right, dataComparer) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      ((left.isEmpty && right.isEmpty) ||\n        (left.isStartIncluded === right.isStartIncluded &&\n          left.isStopIncluded === right.isStopIncluded &&\n          JulianDate.equals(left.start, right.start) &&\n          JulianDate.equals(left.stop, right.stop) &&\n          (left.data === right.data ||\n            (defined(dataComparer) && dataComparer(left.data, right.data))))))\n  );\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n * each other.  That is, in order for the dates to be considered equal (and for\n * this function to return <code>true</code>), the absolute value of the difference between them, in\n * seconds, must be less than <code>epsilon</code>.\n *\n * @param {TimeInterval} [left] The first instance.\n * @param {TimeInterval} [right] The second instance.\n * @param {number} [epsilon=0] The maximum number of seconds that should separate the two instances.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n */\nTimeInterval.equalsEpsilon = function (left, right, epsilon, dataComparer) {\n  epsilon = epsilon ?? 0;\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      ((left.isEmpty && right.isEmpty) ||\n        (left.isStartIncluded === right.isStartIncluded &&\n          left.isStopIncluded === right.isStopIncluded &&\n          JulianDate.equalsEpsilon(left.start, right.start, epsilon) &&\n          JulianDate.equalsEpsilon(left.stop, right.stop, epsilon) &&\n          (left.data === right.data ||\n            (defined(dataComparer) && dataComparer(left.data, right.data))))))\n  );\n};\n\n/**\n * Computes the intersection of two intervals, optionally merging their data.\n *\n * @param {TimeInterval} left The first interval.\n * @param {TimeInterval} [right] The second interval.\n * @param {TimeInterval} [result] An existing instance to use for the result.\n * @param {TimeInterval.MergeCallback} [mergeCallback] A function which merges the data of the two intervals. If omitted, the data from the left interval will be used.\n * @returns {TimeInterval} The modified result parameter.\n */\nTimeInterval.intersect = function (left, right, result, mergeCallback) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  //>>includeEnd('debug');\n\n  if (!defined(right)) {\n    return TimeInterval.clone(TimeInterval.EMPTY, result);\n  }\n\n  const leftStart = left.start;\n  const leftStop = left.stop;\n\n  const rightStart = right.start;\n  const rightStop = right.stop;\n\n  const intersectsStartRight =\n    JulianDate.greaterThanOrEquals(rightStart, leftStart) &&\n    JulianDate.greaterThanOrEquals(leftStop, rightStart);\n  const intersectsStartLeft =\n    !intersectsStartRight &&\n    JulianDate.lessThanOrEquals(rightStart, leftStart) &&\n    JulianDate.lessThanOrEquals(leftStart, rightStop);\n\n  if (!intersectsStartRight && !intersectsStartLeft) {\n    return TimeInterval.clone(TimeInterval.EMPTY, result);\n  }\n\n  const leftIsStartIncluded = left.isStartIncluded;\n  const leftIsStopIncluded = left.isStopIncluded;\n  const rightIsStartIncluded = right.isStartIncluded;\n  const rightIsStopIncluded = right.isStopIncluded;\n  const leftLessThanRight = JulianDate.lessThan(leftStop, rightStop);\n\n  if (!defined(result)) {\n    result = new TimeInterval();\n  }\n\n  result.start = intersectsStartRight ? rightStart : leftStart;\n  result.isStartIncluded =\n    (leftIsStartIncluded && rightIsStartIncluded) ||\n    (!JulianDate.equals(rightStart, leftStart) &&\n      ((intersectsStartRight && rightIsStartIncluded) ||\n        (intersectsStartLeft && leftIsStartIncluded)));\n  result.stop = leftLessThanRight ? leftStop : rightStop;\n  result.isStopIncluded = leftLessThanRight\n    ? leftIsStopIncluded\n    : (leftIsStopIncluded && rightIsStopIncluded) ||\n      (!JulianDate.equals(rightStop, leftStop) && rightIsStopIncluded);\n  result.data = defined(mergeCallback)\n    ? mergeCallback(left.data, right.data)\n    : left.data;\n  return result;\n};\n\n/**\n * Checks if the specified date is inside the provided interval.\n *\n * @param {TimeInterval} timeInterval The interval.\n * @param {JulianDate} julianDate The date to check.\n * @returns {boolean} <code>true</code> if the interval contains the specified date, <code>false</code> otherwise.\n */\nTimeInterval.contains = function (timeInterval, julianDate) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"timeInterval\", timeInterval);\n  Check.typeOf.object(\"julianDate\", julianDate);\n  //>>includeEnd('debug');\n\n  if (timeInterval.isEmpty) {\n    return false;\n  }\n\n  const startComparedToDate = JulianDate.compare(\n    timeInterval.start,\n    julianDate,\n  );\n  if (startComparedToDate === 0) {\n    return timeInterval.isStartIncluded;\n  }\n\n  const dateComparedToStop = JulianDate.compare(julianDate, timeInterval.stop);\n  if (dateComparedToStop === 0) {\n    return timeInterval.isStopIncluded;\n  }\n\n  return startComparedToDate < 0 && dateComparedToStop < 0;\n};\n\n/**\n * Duplicates this instance.\n *\n * @param {TimeInterval} [result] An existing instance to use for the result.\n * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.\n */\nTimeInterval.prototype.clone = function (result) {\n  return TimeInterval.clone(this, result);\n};\n\n/**\n * Compares this instance against the provided instance componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {TimeInterval} [right] The right hand side interval.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nTimeInterval.prototype.equals = function (right, dataComparer) {\n  return TimeInterval.equals(this, right, dataComparer);\n};\n\n/**\n * Compares this instance against the provided instance componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {TimeInterval} [right] The right hand side interval.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nTimeInterval.prototype.equalsEpsilon = function (right, epsilon, dataComparer) {\n  return TimeInterval.equalsEpsilon(this, right, epsilon, dataComparer);\n};\n\n/**\n * Creates a string representing this TimeInterval in ISO8601 format.\n *\n * @returns {string} A string representing this TimeInterval in ISO8601 format.\n */\nTimeInterval.prototype.toString = function () {\n  return TimeInterval.toIso8601(this);\n};\n\n/**\n * An immutable empty interval.\n *\n * @type {TimeInterval}\n * @constant\n */\nTimeInterval.EMPTY = Object.freeze(\n  new TimeInterval({\n    start: new JulianDate(),\n    stop: new JulianDate(),\n    isStartIncluded: false,\n    isStopIncluded: false,\n  }),\n);\n\n/**\n * Function interface for merging interval data.\n * @callback TimeInterval.MergeCallback\n *\n * @param {*} leftData The first data instance.\n * @param {*} rightData The second data instance.\n * @returns {*} The result of merging the two data instances.\n */\n\n/**\n * Function interface for comparing interval data.\n * @callback TimeInterval.DataComparer\n * @param {*} leftData The first data instance.\n * @param {*} rightData The second data instance.\n * @returns {boolean} <code>true</code> if the provided instances are equal, <code>false</code> otherwise.\n */\nexport default TimeInterval;\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,YAAY;AAC9B,OAAOC,MAAM,MAAM,aAAa;AAChC,OAAOC,OAAO,MAAM,cAAc;AAClC,OAAOC,cAAc,MAAM,qBAAqB;AAChD,OAAOC,UAAU,MAAM,iBAAiB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAYA,CAACC,OAAO,EAAE;EAC7BA,OAAO,GAAGA,OAAO,IAAIL,MAAM,CAACM,YAAY;EACxC;AACF;AACA;AACA;EACE,IAAI,CAACC,KAAK,GAAGN,OAAO,CAACI,OAAO,CAACE,KAAK,CAAC,GAC/BJ,UAAU,CAACK,KAAK,CAACH,OAAO,CAACE,KAAK,CAAC,GAC/B,IAAIJ,UAAU,CAAC,CAAC;;EAEpB;AACF;AACA;AACA;EACE,IAAI,CAACM,IAAI,GAAGR,OAAO,CAACI,OAAO,CAACI,IAAI,CAAC,GAC7BN,UAAU,CAACK,KAAK,CAACH,OAAO,CAACI,IAAI,CAAC,GAC9B,IAAIN,UAAU,CAAC,CAAC;;EAEpB;AACF;AACA;AACA;EACE,IAAI,CAACO,IAAI,GAAGL,OAAO,CAACK,IAAI;;EAExB;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,eAAe,GAAGN,OAAO,CAACM,eAAe,IAAI,IAAI;;EAEtD;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,cAAc,GAAGP,OAAO,CAACO,cAAc,IAAI,IAAI;AACtD;AAEAC,MAAM,CAACC,gBAAgB,CAACV,YAAY,CAACW,SAAS,EAAE;EAC9C;AACF;AACA;AACA;AACA;AACA;EACEC,OAAO,EAAE;IACPC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,MAAMC,mBAAmB,GAAGf,UAAU,CAACgB,OAAO,CAAC,IAAI,CAACV,IAAI,EAAE,IAAI,CAACF,KAAK,CAAC;MACrE,OACEW,mBAAmB,GAAG,CAAC,IACtBA,mBAAmB,KAAK,CAAC,KACvB,CAAC,IAAI,CAACP,eAAe,IAAI,CAAC,IAAI,CAACC,cAAc,CAAE;IAEtD;EACF;AACF,CAAC,CAAC;AAEF,MAAMQ,eAAe,GAAG;EACtBb,KAAK,EAAEc,SAAS;EAChBZ,IAAI,EAAEY,SAAS;EACfV,eAAe,EAAEU,SAAS;EAC1BT,cAAc,EAAES,SAAS;EACzBX,IAAI,EAAEW;AACR,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAjB,YAAY,CAACkB,WAAW,GAAG,UAAUjB,OAAO,EAAEkB,MAAM,EAAE;EACpD;EACAxB,KAAK,CAACyB,MAAM,CAACC,MAAM,CAAC,SAAS,EAAEpB,OAAO,CAAC;EACvCN,KAAK,CAACyB,MAAM,CAACE,MAAM,CAAC,iBAAiB,EAAErB,OAAO,CAACsB,OAAO,CAAC;EACvD;;EAEA,MAAMC,KAAK,GAAGvB,OAAO,CAACsB,OAAO,CAACE,KAAK,CAAC,GAAG,CAAC;EACxC,IAAID,KAAK,CAACE,MAAM,KAAK,CAAC,EAAE;IACtB,MAAM,IAAI5B,cAAc,CACtB,kDACF,CAAC;EACH;EACA,MAAMK,KAAK,GAAGJ,UAAU,CAACmB,WAAW,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC;EAC9C,MAAMnB,IAAI,GAAGN,UAAU,CAACmB,WAAW,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC;EAC7C,MAAMjB,eAAe,GAAGN,OAAO,CAACM,eAAe,IAAI,IAAI;EACvD,MAAMC,cAAc,GAAGP,OAAO,CAACO,cAAc,IAAI,IAAI;EACrD,MAAMF,IAAI,GAAGL,OAAO,CAACK,IAAI;EAEzB,IAAI,CAACT,OAAO,CAACsB,MAAM,CAAC,EAAE;IACpBH,eAAe,CAACb,KAAK,GAAGA,KAAK;IAC7Ba,eAAe,CAACX,IAAI,GAAGA,IAAI;IAC3BW,eAAe,CAACT,eAAe,GAAGA,eAAe;IACjDS,eAAe,CAACR,cAAc,GAAGA,cAAc;IAC/CQ,eAAe,CAACV,IAAI,GAAGA,IAAI;IAC3B,OAAO,IAAIN,YAAY,CAACgB,eAAe,CAAC;EAC1C;EAEAG,MAAM,CAAChB,KAAK,GAAGA,KAAK;EACpBgB,MAAM,CAACd,IAAI,GAAGA,IAAI;EAClBc,MAAM,CAACZ,eAAe,GAAGA,eAAe;EACxCY,MAAM,CAACX,cAAc,GAAGA,cAAc;EACtCW,MAAM,CAACb,IAAI,GAAGA,IAAI;EAClB,OAAOa,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAnB,YAAY,CAAC2B,SAAS,GAAG,UAAUC,YAAY,EAAEC,SAAS,EAAE;EAC1D;EACAlC,KAAK,CAACyB,MAAM,CAACC,MAAM,CAAC,cAAc,EAAEO,YAAY,CAAC;EACjD;;EAEA,OAAO,GAAG7B,UAAU,CAAC4B,SAAS,CAC5BC,YAAY,CAACzB,KAAK,EAClB0B,SACF,CAAC,IAAI9B,UAAU,CAAC4B,SAAS,CAACC,YAAY,CAACvB,IAAI,EAAEwB,SAAS,CAAC,EAAE;AAC3D,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA7B,YAAY,CAACI,KAAK,GAAG,UAAUwB,YAAY,EAAET,MAAM,EAAE;EACnD,IAAI,CAACtB,OAAO,CAAC+B,YAAY,CAAC,EAAE;IAC1B,OAAOX,SAAS;EAClB;EACA,IAAI,CAACpB,OAAO,CAACsB,MAAM,CAAC,EAAE;IACpB,OAAO,IAAInB,YAAY,CAAC4B,YAAY,CAAC;EACvC;EACAT,MAAM,CAAChB,KAAK,GAAGyB,YAAY,CAACzB,KAAK;EACjCgB,MAAM,CAACd,IAAI,GAAGuB,YAAY,CAACvB,IAAI;EAC/Bc,MAAM,CAACZ,eAAe,GAAGqB,YAAY,CAACrB,eAAe;EACrDY,MAAM,CAACX,cAAc,GAAGoB,YAAY,CAACpB,cAAc;EACnDW,MAAM,CAACb,IAAI,GAAGsB,YAAY,CAACtB,IAAI;EAC/B,OAAOa,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAnB,YAAY,CAAC8B,MAAM,GAAG,UAAUC,IAAI,EAAEC,KAAK,EAAEC,YAAY,EAAE;EACzD,OACEF,IAAI,KAAKC,KAAK,IACbnC,OAAO,CAACkC,IAAI,CAAC,IACZlC,OAAO,CAACmC,KAAK,CAAC,KACZD,IAAI,CAACnB,OAAO,IAAIoB,KAAK,CAACpB,OAAO,IAC5BmB,IAAI,CAACxB,eAAe,KAAKyB,KAAK,CAACzB,eAAe,IAC7CwB,IAAI,CAACvB,cAAc,KAAKwB,KAAK,CAACxB,cAAc,IAC5CT,UAAU,CAAC+B,MAAM,CAACC,IAAI,CAAC5B,KAAK,EAAE6B,KAAK,CAAC7B,KAAK,CAAC,IAC1CJ,UAAU,CAAC+B,MAAM,CAACC,IAAI,CAAC1B,IAAI,EAAE2B,KAAK,CAAC3B,IAAI,CAAC,KACvC0B,IAAI,CAACzB,IAAI,KAAK0B,KAAK,CAAC1B,IAAI,IACtBT,OAAO,CAACoC,YAAY,CAAC,IAAIA,YAAY,CAACF,IAAI,CAACzB,IAAI,EAAE0B,KAAK,CAAC1B,IAAI,CAAE,CAAE,CAAE;AAE9E,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAN,YAAY,CAACkC,aAAa,GAAG,UAAUH,IAAI,EAAEC,KAAK,EAAEG,OAAO,EAAEF,YAAY,EAAE;EACzEE,OAAO,GAAGA,OAAO,IAAI,CAAC;EAEtB,OACEJ,IAAI,KAAKC,KAAK,IACbnC,OAAO,CAACkC,IAAI,CAAC,IACZlC,OAAO,CAACmC,KAAK,CAAC,KACZD,IAAI,CAACnB,OAAO,IAAIoB,KAAK,CAACpB,OAAO,IAC5BmB,IAAI,CAACxB,eAAe,KAAKyB,KAAK,CAACzB,eAAe,IAC7CwB,IAAI,CAACvB,cAAc,KAAKwB,KAAK,CAACxB,cAAc,IAC5CT,UAAU,CAACmC,aAAa,CAACH,IAAI,CAAC5B,KAAK,EAAE6B,KAAK,CAAC7B,KAAK,EAAEgC,OAAO,CAAC,IAC1DpC,UAAU,CAACmC,aAAa,CAACH,IAAI,CAAC1B,IAAI,EAAE2B,KAAK,CAAC3B,IAAI,EAAE8B,OAAO,CAAC,KACvDJ,IAAI,CAACzB,IAAI,KAAK0B,KAAK,CAAC1B,IAAI,IACtBT,OAAO,CAACoC,YAAY,CAAC,IAAIA,YAAY,CAACF,IAAI,CAACzB,IAAI,EAAE0B,KAAK,CAAC1B,IAAI,CAAE,CAAE,CAAE;AAE9E,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAN,YAAY,CAACoC,SAAS,GAAG,UAAUL,IAAI,EAAEC,KAAK,EAAEb,MAAM,EAAEkB,aAAa,EAAE;EACrE;EACA1C,KAAK,CAACyB,MAAM,CAACC,MAAM,CAAC,MAAM,EAAEU,IAAI,CAAC;EACjC;;EAEA,IAAI,CAAClC,OAAO,CAACmC,KAAK,CAAC,EAAE;IACnB,OAAOhC,YAAY,CAACI,KAAK,CAACJ,YAAY,CAACsC,KAAK,EAAEnB,MAAM,CAAC;EACvD;EAEA,MAAMoB,SAAS,GAAGR,IAAI,CAAC5B,KAAK;EAC5B,MAAMqC,QAAQ,GAAGT,IAAI,CAAC1B,IAAI;EAE1B,MAAMoC,UAAU,GAAGT,KAAK,CAAC7B,KAAK;EAC9B,MAAMuC,SAAS,GAAGV,KAAK,CAAC3B,IAAI;EAE5B,MAAMsC,oBAAoB,GACxB5C,UAAU,CAAC6C,mBAAmB,CAACH,UAAU,EAAEF,SAAS,CAAC,IACrDxC,UAAU,CAAC6C,mBAAmB,CAACJ,QAAQ,EAAEC,UAAU,CAAC;EACtD,MAAMI,mBAAmB,GACvB,CAACF,oBAAoB,IACrB5C,UAAU,CAAC+C,gBAAgB,CAACL,UAAU,EAAEF,SAAS,CAAC,IAClDxC,UAAU,CAAC+C,gBAAgB,CAACP,SAAS,EAAEG,SAAS,CAAC;EAEnD,IAAI,CAACC,oBAAoB,IAAI,CAACE,mBAAmB,EAAE;IACjD,OAAO7C,YAAY,CAACI,KAAK,CAACJ,YAAY,CAACsC,KAAK,EAAEnB,MAAM,CAAC;EACvD;EAEA,MAAM4B,mBAAmB,GAAGhB,IAAI,CAACxB,eAAe;EAChD,MAAMyC,kBAAkB,GAAGjB,IAAI,CAACvB,cAAc;EAC9C,MAAMyC,oBAAoB,GAAGjB,KAAK,CAACzB,eAAe;EAClD,MAAM2C,mBAAmB,GAAGlB,KAAK,CAACxB,cAAc;EAChD,MAAM2C,iBAAiB,GAAGpD,UAAU,CAACqD,QAAQ,CAACZ,QAAQ,EAAEE,SAAS,CAAC;EAElE,IAAI,CAAC7C,OAAO,CAACsB,MAAM,CAAC,EAAE;IACpBA,MAAM,GAAG,IAAInB,YAAY,CAAC,CAAC;EAC7B;EAEAmB,MAAM,CAAChB,KAAK,GAAGwC,oBAAoB,GAAGF,UAAU,GAAGF,SAAS;EAC5DpB,MAAM,CAACZ,eAAe,GACnBwC,mBAAmB,IAAIE,oBAAoB,IAC3C,CAAClD,UAAU,CAAC+B,MAAM,CAACW,UAAU,EAAEF,SAAS,CAAC,KACtCI,oBAAoB,IAAIM,oBAAoB,IAC3CJ,mBAAmB,IAAIE,mBAAoB,CAAE;EACpD5B,MAAM,CAACd,IAAI,GAAG8C,iBAAiB,GAAGX,QAAQ,GAAGE,SAAS;EACtDvB,MAAM,CAACX,cAAc,GAAG2C,iBAAiB,GACrCH,kBAAkB,GACjBA,kBAAkB,IAAIE,mBAAmB,IACzC,CAACnD,UAAU,CAAC+B,MAAM,CAACY,SAAS,EAAEF,QAAQ,CAAC,IAAIU,mBAAoB;EACpE/B,MAAM,CAACb,IAAI,GAAGT,OAAO,CAACwC,aAAa,CAAC,GAChCA,aAAa,CAACN,IAAI,CAACzB,IAAI,EAAE0B,KAAK,CAAC1B,IAAI,CAAC,GACpCyB,IAAI,CAACzB,IAAI;EACb,OAAOa,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAnB,YAAY,CAACqD,QAAQ,GAAG,UAAUzB,YAAY,EAAE0B,UAAU,EAAE;EAC1D;EACA3D,KAAK,CAACyB,MAAM,CAACC,MAAM,CAAC,cAAc,EAAEO,YAAY,CAAC;EACjDjC,KAAK,CAACyB,MAAM,CAACC,MAAM,CAAC,YAAY,EAAEiC,UAAU,CAAC;EAC7C;;EAEA,IAAI1B,YAAY,CAAChB,OAAO,EAAE;IACxB,OAAO,KAAK;EACd;EAEA,MAAM2C,mBAAmB,GAAGxD,UAAU,CAACgB,OAAO,CAC5Ca,YAAY,CAACzB,KAAK,EAClBmD,UACF,CAAC;EACD,IAAIC,mBAAmB,KAAK,CAAC,EAAE;IAC7B,OAAO3B,YAAY,CAACrB,eAAe;EACrC;EAEA,MAAMiD,kBAAkB,GAAGzD,UAAU,CAACgB,OAAO,CAACuC,UAAU,EAAE1B,YAAY,CAACvB,IAAI,CAAC;EAC5E,IAAImD,kBAAkB,KAAK,CAAC,EAAE;IAC5B,OAAO5B,YAAY,CAACpB,cAAc;EACpC;EAEA,OAAO+C,mBAAmB,GAAG,CAAC,IAAIC,kBAAkB,GAAG,CAAC;AAC1D,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAxD,YAAY,CAACW,SAAS,CAACP,KAAK,GAAG,UAAUe,MAAM,EAAE;EAC/C,OAAOnB,YAAY,CAACI,KAAK,CAAC,IAAI,EAAEe,MAAM,CAAC;AACzC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAnB,YAAY,CAACW,SAAS,CAACmB,MAAM,GAAG,UAAUE,KAAK,EAAEC,YAAY,EAAE;EAC7D,OAAOjC,YAAY,CAAC8B,MAAM,CAAC,IAAI,EAAEE,KAAK,EAAEC,YAAY,CAAC;AACvD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAjC,YAAY,CAACW,SAAS,CAACuB,aAAa,GAAG,UAAUF,KAAK,EAAEG,OAAO,EAAEF,YAAY,EAAE;EAC7E,OAAOjC,YAAY,CAACkC,aAAa,CAAC,IAAI,EAAEF,KAAK,EAAEG,OAAO,EAAEF,YAAY,CAAC;AACvE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAjC,YAAY,CAACW,SAAS,CAAC8C,QAAQ,GAAG,YAAY;EAC5C,OAAOzD,YAAY,CAAC2B,SAAS,CAAC,IAAI,CAAC;AACrC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA3B,YAAY,CAACsC,KAAK,GAAG7B,MAAM,CAACiD,MAAM,CAChC,IAAI1D,YAAY,CAAC;EACfG,KAAK,EAAE,IAAIJ,UAAU,CAAC,CAAC;EACvBM,IAAI,EAAE,IAAIN,UAAU,CAAC,CAAC;EACtBQ,eAAe,EAAE,KAAK;EACtBC,cAAc,EAAE;AAClB,CAAC,CACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeR,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}