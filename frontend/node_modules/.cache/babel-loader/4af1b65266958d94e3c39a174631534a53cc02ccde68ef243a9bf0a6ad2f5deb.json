{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport jsep from \"jsep\";\nimport ExpressionNodeType from \"./ExpressionNodeType.js\";\n\n/**\n * An expression for a style applied to a {@link Cesium3DTileset}.\n * <p>\n * Evaluates an expression defined using the\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}.\n * </p>\n * <p>\n * Implements the {@link StyleExpression} interface.\n * </p>\n *\n * @alias Expression\n * @constructor\n *\n * @param {string} [expression] The expression defined using the 3D Tiles Styling language.\n * @param {object} [defines] Defines in the style.\n *\n * @example\n * const expression = new Cesium.Expression('(regExp(\"^Chest\").test(${County})) && (${YearBuilt} >= 1970)');\n * expression.evaluate(feature); // returns true or false depending on the feature's properties\n *\n * @example\n * const expression = new Cesium.Expression('(${Temperature} > 90) ? color(\"red\") : color(\"white\")');\n * expression.evaluateColor(feature, result); // returns a Cesium.Color object\n */\nfunction Expression(expression, defines) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"expression\", expression);\n  //>>includeEnd('debug');\n\n  this._expression = expression;\n  expression = replaceDefines(expression, defines);\n  expression = replaceVariables(removeBackslashes(expression));\n\n  // customize jsep operators\n  jsep.addBinaryOp(\"=~\", 0);\n  jsep.addBinaryOp(\"!~\", 0);\n  let ast;\n  try {\n    ast = jsep(expression);\n  } catch (e) {\n    throw new RuntimeError(e);\n  }\n  this._runtimeAst = createRuntimeAst(this, ast);\n}\nObject.defineProperties(Expression.prototype, {\n  /**\n   * Gets the expression defined in the 3D Tiles Styling language.\n   *\n   * @memberof Expression.prototype\n   *\n   * @type {string}\n   * @readonly\n   *\n   * @default undefined\n   */\n  expression: {\n    get: function () {\n      return this._expression;\n    }\n  }\n});\n\n// Scratch storage manager while evaluating deep expressions.\n// For example, an expression like dot(vec4(${red}), vec4(${green}) * vec4(${blue}) requires 3 scratch Cartesian4's\nconst scratchStorage = {\n  arrayIndex: 0,\n  arrayArray: [[]],\n  cartesian2Index: 0,\n  cartesian3Index: 0,\n  cartesian4Index: 0,\n  cartesian2Array: [new Cartesian2()],\n  cartesian3Array: [new Cartesian3()],\n  cartesian4Array: [new Cartesian4()],\n  reset: function () {\n    this.arrayIndex = 0;\n    this.cartesian2Index = 0;\n    this.cartesian3Index = 0;\n    this.cartesian4Index = 0;\n  },\n  getArray: function () {\n    if (this.arrayIndex >= this.arrayArray.length) {\n      this.arrayArray.push([]);\n    }\n    const array = this.arrayArray[this.arrayIndex++];\n    array.length = 0;\n    return array;\n  },\n  getCartesian2: function () {\n    if (this.cartesian2Index >= this.cartesian2Array.length) {\n      this.cartesian2Array.push(new Cartesian2());\n    }\n    return this.cartesian2Array[this.cartesian2Index++];\n  },\n  getCartesian3: function () {\n    if (this.cartesian3Index >= this.cartesian3Array.length) {\n      this.cartesian3Array.push(new Cartesian3());\n    }\n    return this.cartesian3Array[this.cartesian3Index++];\n  },\n  getCartesian4: function () {\n    if (this.cartesian4Index >= this.cartesian4Array.length) {\n      this.cartesian4Array.push(new Cartesian4());\n    }\n    return this.cartesian4Array[this.cartesian4Index++];\n  }\n};\n\n/**\n * Evaluates the result of an expression, optionally using the provided feature's properties. If the result of\n * the expression in the\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}\n * is of type <code>Boolean</code>, <code>Number</code>, or <code>String</code>, the corresponding JavaScript\n * primitive type will be returned. If the result is a <code>RegExp</code>, a Javascript <code>RegExp</code>\n * object will be returned. If the result is a <code>Cartesian2</code>, <code>Cartesian3</code>, or <code>Cartesian4</code>,\n * a {@link Cartesian2}, {@link Cartesian3}, or {@link Cartesian4} object will be returned. If the <code>result</code> argument is\n * a {@link Color}, the {@link Cartesian4} value is converted to a {@link Color} and then returned.\n *\n * @param {Cesium3DTileFeature} feature The feature whose properties may be used as variables in the expression.\n * @param {object} [result] The object onto which to store the result.\n * @returns {boolean|number|string|RegExp|Cartesian2|Cartesian3|Cartesian4|Color} The result of evaluating the expression.\n */\nExpression.prototype.evaluate = function (feature, result) {\n  scratchStorage.reset();\n  const value = this._runtimeAst.evaluate(feature);\n  if (result instanceof Color && value instanceof Cartesian4) {\n    return Color.fromCartesian4(value, result);\n  }\n  if (value instanceof Cartesian2 || value instanceof Cartesian3 || value instanceof Cartesian4) {\n    return value.clone(result);\n  }\n  return value;\n};\n\n/**\n * Evaluates the result of a Color expression, optionally using the provided feature's properties.\n * <p>\n * This is equivalent to {@link Expression#evaluate} but always returns a {@link Color} object.\n * </p>\n *\n * @param {Cesium3DTileFeature} feature The feature whose properties may be used as variables in the expression.\n * @param {Color} [result] The object in which to store the result\n * @returns {Color} The modified result parameter or a new Color instance if one was not provided.\n */\nExpression.prototype.evaluateColor = function (feature, result) {\n  scratchStorage.reset();\n  const color = this._runtimeAst.evaluate(feature);\n  return Color.fromCartesian4(color, result);\n};\n\n/**\n * Gets the shader function for this expression.\n * Returns undefined if the shader function can't be generated from this expression.\n *\n * @param {string} functionSignature Signature of the generated function.\n * @param {object} variableSubstitutionMap Maps variable names to shader variable names.\n * @param {object} shaderState Stores information about the generated shader function, including whether it is translucent.\n * @param {string} returnType The return type of the generated function.\n *\n * @returns {string} The shader function.\n *\n * @private\n */\nExpression.prototype.getShaderFunction = function (functionSignature, variableSubstitutionMap, shaderState, returnType) {\n  let shaderExpression = this.getShaderExpression(variableSubstitutionMap, shaderState);\n  shaderExpression = `${returnType} ${functionSignature}\\n` + `{\\n` + `    return ${shaderExpression};\\n` + `}\\n`;\n  return shaderExpression;\n};\n\n/**\n * Gets the shader expression for this expression.\n * Returns undefined if the shader expression can't be generated from this expression.\n *\n * @param {object} variableSubstitutionMap Maps variable names to shader variable names.\n * @param {object} shaderState Stores information about the generated shader function, including whether it is translucent.\n *\n * @returns {string} The shader expression.\n *\n * @private\n */\nExpression.prototype.getShaderExpression = function (variableSubstitutionMap, shaderState) {\n  return this._runtimeAst.getShaderExpression(variableSubstitutionMap, shaderState);\n};\n\n/**\n * Gets the variables used by the expression.\n *\n * @returns {string[]} The variables used by the expression.\n *\n * @private\n */\nExpression.prototype.getVariables = function () {\n  let variables = [];\n  this._runtimeAst.getVariables(variables);\n\n  // Remove duplicates\n  variables = variables.filter(function (variable, index, variables) {\n    return variables.indexOf(variable) === index;\n  });\n  return variables;\n};\nconst unaryOperators = [\"!\", \"-\", \"+\"];\nconst binaryOperators = [\"+\", \"-\", \"*\", \"/\", \"%\", \"===\", \"!==\", \">\", \">=\", \"<\", \"<=\", \"&&\", \"||\", \"!~\", \"=~\"];\nconst variableRegex = /\\${(.*?)}/g; // Matches ${variable_name}\nconst backslashRegex = /\\\\/g;\nconst backslashReplacement = \"@#%\";\nconst replacementRegex = /@#%/g;\nconst scratchColor = new Color();\nconst unaryFunctions = {\n  abs: getEvaluateUnaryComponentwise(Math.abs),\n  sqrt: getEvaluateUnaryComponentwise(Math.sqrt),\n  cos: getEvaluateUnaryComponentwise(Math.cos),\n  sin: getEvaluateUnaryComponentwise(Math.sin),\n  tan: getEvaluateUnaryComponentwise(Math.tan),\n  acos: getEvaluateUnaryComponentwise(Math.acos),\n  asin: getEvaluateUnaryComponentwise(Math.asin),\n  atan: getEvaluateUnaryComponentwise(Math.atan),\n  radians: getEvaluateUnaryComponentwise(CesiumMath.toRadians),\n  degrees: getEvaluateUnaryComponentwise(CesiumMath.toDegrees),\n  sign: getEvaluateUnaryComponentwise(CesiumMath.sign),\n  floor: getEvaluateUnaryComponentwise(Math.floor),\n  ceil: getEvaluateUnaryComponentwise(Math.ceil),\n  round: getEvaluateUnaryComponentwise(Math.round),\n  exp: getEvaluateUnaryComponentwise(Math.exp),\n  exp2: getEvaluateUnaryComponentwise(exp2),\n  log: getEvaluateUnaryComponentwise(Math.log),\n  log2: getEvaluateUnaryComponentwise(log2),\n  fract: getEvaluateUnaryComponentwise(fract),\n  length: length,\n  normalize: normalize\n};\nconst binaryFunctions = {\n  atan2: getEvaluateBinaryComponentwise(Math.atan2, false),\n  pow: getEvaluateBinaryComponentwise(Math.pow, false),\n  min: getEvaluateBinaryComponentwise(Math.min, true),\n  max: getEvaluateBinaryComponentwise(Math.max, true),\n  distance: distance,\n  dot: dot,\n  cross: cross\n};\nconst ternaryFunctions = {\n  clamp: getEvaluateTernaryComponentwise(CesiumMath.clamp, true),\n  mix: getEvaluateTernaryComponentwise(CesiumMath.lerp, true)\n};\nfunction fract(number) {\n  return number - Math.floor(number);\n}\nfunction exp2(exponent) {\n  return Math.pow(2.0, exponent);\n}\nfunction log2(number) {\n  return CesiumMath.log2(number);\n}\nfunction getEvaluateUnaryComponentwise(operation) {\n  return function (call, left) {\n    if (typeof left === \"number\") {\n      return operation(left);\n    } else if (left instanceof Cartesian2) {\n      return Cartesian2.fromElements(operation(left.x), operation(left.y), scratchStorage.getCartesian2());\n    } else if (left instanceof Cartesian3) {\n      return Cartesian3.fromElements(operation(left.x), operation(left.y), operation(left.z), scratchStorage.getCartesian3());\n    } else if (left instanceof Cartesian4) {\n      return Cartesian4.fromElements(operation(left.x), operation(left.y), operation(left.z), operation(left.w), scratchStorage.getCartesian4());\n    }\n    throw new RuntimeError(`Function \"${call}\" requires a vector or number argument. Argument is ${left}.`);\n  };\n}\nfunction getEvaluateBinaryComponentwise(operation, allowScalar) {\n  return function (call, left, right) {\n    if (allowScalar && typeof right === \"number\") {\n      if (typeof left === \"number\") {\n        return operation(left, right);\n      } else if (left instanceof Cartesian2) {\n        return Cartesian2.fromElements(operation(left.x, right), operation(left.y, right), scratchStorage.getCartesian2());\n      } else if (left instanceof Cartesian3) {\n        return Cartesian3.fromElements(operation(left.x, right), operation(left.y, right), operation(left.z, right), scratchStorage.getCartesian3());\n      } else if (left instanceof Cartesian4) {\n        return Cartesian4.fromElements(operation(left.x, right), operation(left.y, right), operation(left.z, right), operation(left.w, right), scratchStorage.getCartesian4());\n      }\n    }\n    if (typeof left === \"number\" && typeof right === \"number\") {\n      return operation(left, right);\n    } else if (left instanceof Cartesian2 && right instanceof Cartesian2) {\n      return Cartesian2.fromElements(operation(left.x, right.x), operation(left.y, right.y), scratchStorage.getCartesian2());\n    } else if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n      return Cartesian3.fromElements(operation(left.x, right.x), operation(left.y, right.y), operation(left.z, right.z), scratchStorage.getCartesian3());\n    } else if (left instanceof Cartesian4 && right instanceof Cartesian4) {\n      return Cartesian4.fromElements(operation(left.x, right.x), operation(left.y, right.y), operation(left.z, right.z), operation(left.w, right.w), scratchStorage.getCartesian4());\n    }\n    throw new RuntimeError(`Function \"${call}\" requires vector or number arguments of matching types. Arguments are ${left} and ${right}.`);\n  };\n}\nfunction getEvaluateTernaryComponentwise(operation, allowScalar) {\n  return function (call, left, right, test) {\n    if (allowScalar && typeof test === \"number\") {\n      if (typeof left === \"number\" && typeof right === \"number\") {\n        return operation(left, right, test);\n      } else if (left instanceof Cartesian2 && right instanceof Cartesian2) {\n        return Cartesian2.fromElements(operation(left.x, right.x, test), operation(left.y, right.y, test), scratchStorage.getCartesian2());\n      } else if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n        return Cartesian3.fromElements(operation(left.x, right.x, test), operation(left.y, right.y, test), operation(left.z, right.z, test), scratchStorage.getCartesian3());\n      } else if (left instanceof Cartesian4 && right instanceof Cartesian4) {\n        return Cartesian4.fromElements(operation(left.x, right.x, test), operation(left.y, right.y, test), operation(left.z, right.z, test), operation(left.w, right.w, test), scratchStorage.getCartesian4());\n      }\n    }\n    if (typeof left === \"number\" && typeof right === \"number\" && typeof test === \"number\") {\n      return operation(left, right, test);\n    } else if (left instanceof Cartesian2 && right instanceof Cartesian2 && test instanceof Cartesian2) {\n      return Cartesian2.fromElements(operation(left.x, right.x, test.x), operation(left.y, right.y, test.y), scratchStorage.getCartesian2());\n    } else if (left instanceof Cartesian3 && right instanceof Cartesian3 && test instanceof Cartesian3) {\n      return Cartesian3.fromElements(operation(left.x, right.x, test.x), operation(left.y, right.y, test.y), operation(left.z, right.z, test.z), scratchStorage.getCartesian3());\n    } else if (left instanceof Cartesian4 && right instanceof Cartesian4 && test instanceof Cartesian4) {\n      return Cartesian4.fromElements(operation(left.x, right.x, test.x), operation(left.y, right.y, test.y), operation(left.z, right.z, test.z), operation(left.w, right.w, test.w), scratchStorage.getCartesian4());\n    }\n    throw new RuntimeError(`Function \"${call}\" requires vector or number arguments of matching types. Arguments are ${left}, ${right}, and ${test}.`);\n  };\n}\nfunction length(call, left) {\n  if (typeof left === \"number\") {\n    return Math.abs(left);\n  } else if (left instanceof Cartesian2) {\n    return Cartesian2.magnitude(left);\n  } else if (left instanceof Cartesian3) {\n    return Cartesian3.magnitude(left);\n  } else if (left instanceof Cartesian4) {\n    return Cartesian4.magnitude(left);\n  }\n  throw new RuntimeError(`Function \"${call}\" requires a vector or number argument. Argument is ${left}.`);\n}\nfunction normalize(call, left) {\n  if (typeof left === \"number\") {\n    return 1.0;\n  } else if (left instanceof Cartesian2) {\n    return Cartesian2.normalize(left, scratchStorage.getCartesian2());\n  } else if (left instanceof Cartesian3) {\n    return Cartesian3.normalize(left, scratchStorage.getCartesian3());\n  } else if (left instanceof Cartesian4) {\n    return Cartesian4.normalize(left, scratchStorage.getCartesian4());\n  }\n  throw new RuntimeError(`Function \"${call}\" requires a vector or number argument. Argument is ${left}.`);\n}\nfunction distance(call, left, right) {\n  if (typeof left === \"number\" && typeof right === \"number\") {\n    return Math.abs(left - right);\n  } else if (left instanceof Cartesian2 && right instanceof Cartesian2) {\n    return Cartesian2.distance(left, right);\n  } else if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n    return Cartesian3.distance(left, right);\n  } else if (left instanceof Cartesian4 && right instanceof Cartesian4) {\n    return Cartesian4.distance(left, right);\n  }\n  throw new RuntimeError(`Function \"${call}\" requires vector or number arguments of matching types. Arguments are ${left} and ${right}.`);\n}\nfunction dot(call, left, right) {\n  if (typeof left === \"number\" && typeof right === \"number\") {\n    return left * right;\n  } else if (left instanceof Cartesian2 && right instanceof Cartesian2) {\n    return Cartesian2.dot(left, right);\n  } else if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n    return Cartesian3.dot(left, right);\n  } else if (left instanceof Cartesian4 && right instanceof Cartesian4) {\n    return Cartesian4.dot(left, right);\n  }\n  throw new RuntimeError(`Function \"${call}\" requires vector or number arguments of matching types. Arguments are ${left} and ${right}.`);\n}\nfunction cross(call, left, right) {\n  if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n    return Cartesian3.cross(left, right, scratchStorage.getCartesian3());\n  }\n  throw new RuntimeError(`Function \"${call}\" requires vec3 arguments. Arguments are ${left} and ${right}.`);\n}\nfunction Node(type, value, left, right, test) {\n  this._type = type;\n  this._value = value;\n  this._left = left;\n  this._right = right;\n  this._test = test;\n  this.evaluate = undefined;\n  setEvaluateFunction(this);\n}\nfunction replaceDefines(expression, defines) {\n  if (!defined(defines)) {\n    return expression;\n  }\n  for (const key in defines) {\n    if (defines.hasOwnProperty(key)) {\n      const definePlaceholder = new RegExp(`\\\\$\\\\{${key}\\\\}`, \"g\");\n      const defineReplace = `(${defines[key]})`;\n      if (defined(defineReplace)) {\n        expression = expression.replace(definePlaceholder, defineReplace);\n      }\n    }\n  }\n  return expression;\n}\nfunction removeBackslashes(expression) {\n  return expression.replace(backslashRegex, backslashReplacement);\n}\nfunction replaceBackslashes(expression) {\n  return expression.replace(replacementRegex, \"\\\\\");\n}\nfunction replaceVariables(expression) {\n  let exp = expression;\n  let result = \"\";\n  let i = exp.indexOf(\"${\");\n  while (i >= 0) {\n    // Check if string is inside quotes\n    const openSingleQuote = exp.indexOf(\"'\");\n    const openDoubleQuote = exp.indexOf('\"');\n    let closeQuote;\n    if (openSingleQuote >= 0 && openSingleQuote < i) {\n      closeQuote = exp.indexOf(\"'\", openSingleQuote + 1);\n      result += exp.substr(0, closeQuote + 1);\n      exp = exp.substr(closeQuote + 1);\n      i = exp.indexOf(\"${\");\n    } else if (openDoubleQuote >= 0 && openDoubleQuote < i) {\n      closeQuote = exp.indexOf('\"', openDoubleQuote + 1);\n      result += exp.substr(0, closeQuote + 1);\n      exp = exp.substr(closeQuote + 1);\n      i = exp.indexOf(\"${\");\n    } else {\n      result += exp.substr(0, i);\n      const j = exp.indexOf(\"}\");\n      if (j < 0) {\n        throw new RuntimeError(\"Unmatched {.\");\n      }\n      result += `czm_${exp.substr(i + 2, j - (i + 2))}`;\n      exp = exp.substr(j + 1);\n      i = exp.indexOf(\"${\");\n    }\n  }\n  result += exp;\n  return result;\n}\nfunction parseLiteral(ast) {\n  const type = typeof ast.value;\n  if (ast.value === null) {\n    return new Node(ExpressionNodeType.LITERAL_NULL, null);\n  } else if (type === \"boolean\") {\n    return new Node(ExpressionNodeType.LITERAL_BOOLEAN, ast.value);\n  } else if (type === \"number\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, ast.value);\n  } else if (type === \"string\") {\n    if (ast.value.indexOf(\"${\") >= 0) {\n      return new Node(ExpressionNodeType.VARIABLE_IN_STRING, ast.value);\n    }\n    return new Node(ExpressionNodeType.LITERAL_STRING, replaceBackslashes(ast.value));\n  }\n}\nfunction parseCall(expression, ast) {\n  const args = ast.arguments;\n  const argsLength = args.length;\n  let call;\n  let val, left, right;\n\n  // Member function calls\n  if (ast.callee.type === \"MemberExpression\") {\n    call = ast.callee.property.name;\n    const object = ast.callee.object;\n    if (call === \"test\" || call === \"exec\") {\n      // Make sure this is called on a valid type\n      if (!defined(object.callee) || object.callee.name !== \"regExp\") {\n        throw new RuntimeError(`${call} is not a function.`);\n      }\n      if (argsLength === 0) {\n        if (call === \"test\") {\n          return new Node(ExpressionNodeType.LITERAL_BOOLEAN, false);\n        }\n        return new Node(ExpressionNodeType.LITERAL_NULL, null);\n      }\n      left = createRuntimeAst(expression, object);\n      right = createRuntimeAst(expression, args[0]);\n      return new Node(ExpressionNodeType.FUNCTION_CALL, call, left, right);\n    } else if (call === \"toString\") {\n      val = createRuntimeAst(expression, object);\n      return new Node(ExpressionNodeType.FUNCTION_CALL, call, val);\n    }\n    throw new RuntimeError(`Unexpected function call \"${call}\".`);\n  }\n\n  // Non-member function calls\n  call = ast.callee.name;\n  if (call === \"color\") {\n    if (argsLength === 0) {\n      return new Node(ExpressionNodeType.LITERAL_COLOR, call);\n    }\n    val = createRuntimeAst(expression, args[0]);\n    if (defined(args[1])) {\n      const alpha = createRuntimeAst(expression, args[1]);\n      return new Node(ExpressionNodeType.LITERAL_COLOR, call, [val, alpha]);\n    }\n    return new Node(ExpressionNodeType.LITERAL_COLOR, call, [val]);\n  } else if (call === \"rgb\" || call === \"hsl\") {\n    if (argsLength < 3) {\n      throw new RuntimeError(`${call} requires three arguments.`);\n    }\n    val = [createRuntimeAst(expression, args[0]), createRuntimeAst(expression, args[1]), createRuntimeAst(expression, args[2])];\n    return new Node(ExpressionNodeType.LITERAL_COLOR, call, val);\n  } else if (call === \"rgba\" || call === \"hsla\") {\n    if (argsLength < 4) {\n      throw new RuntimeError(`${call} requires four arguments.`);\n    }\n    val = [createRuntimeAst(expression, args[0]), createRuntimeAst(expression, args[1]), createRuntimeAst(expression, args[2]), createRuntimeAst(expression, args[3])];\n    return new Node(ExpressionNodeType.LITERAL_COLOR, call, val);\n  } else if (call === \"vec2\" || call === \"vec3\" || call === \"vec4\") {\n    // Check for invalid constructors at evaluation time\n    val = new Array(argsLength);\n    for (let i = 0; i < argsLength; ++i) {\n      val[i] = createRuntimeAst(expression, args[i]);\n    }\n    return new Node(ExpressionNodeType.LITERAL_VECTOR, call, val);\n  } else if (call === \"isNaN\" || call === \"isFinite\") {\n    if (argsLength === 0) {\n      if (call === \"isNaN\") {\n        return new Node(ExpressionNodeType.LITERAL_BOOLEAN, true);\n      }\n      return new Node(ExpressionNodeType.LITERAL_BOOLEAN, false);\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"isExactClass\" || call === \"isClass\") {\n    if (argsLength < 1 || argsLength > 1) {\n      throw new RuntimeError(`${call} requires exactly one argument.`);\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"getExactClassName\") {\n    if (argsLength > 0) {\n      throw new RuntimeError(`${call} does not take any argument.`);\n    }\n    return new Node(ExpressionNodeType.UNARY, call);\n  } else if (defined(unaryFunctions[call])) {\n    if (argsLength !== 1) {\n      throw new RuntimeError(`${call} requires exactly one argument.`);\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (defined(binaryFunctions[call])) {\n    if (argsLength !== 2) {\n      throw new RuntimeError(`${call} requires exactly two arguments.`);\n    }\n    left = createRuntimeAst(expression, args[0]);\n    right = createRuntimeAst(expression, args[1]);\n    return new Node(ExpressionNodeType.BINARY, call, left, right);\n  } else if (defined(ternaryFunctions[call])) {\n    if (argsLength !== 3) {\n      throw new RuntimeError(`${call} requires exactly three arguments.`);\n    }\n    left = createRuntimeAst(expression, args[0]);\n    right = createRuntimeAst(expression, args[1]);\n    const test = createRuntimeAst(expression, args[2]);\n    return new Node(ExpressionNodeType.TERNARY, call, left, right, test);\n  } else if (call === \"Boolean\") {\n    if (argsLength === 0) {\n      return new Node(ExpressionNodeType.LITERAL_BOOLEAN, false);\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"Number\") {\n    if (argsLength === 0) {\n      return new Node(ExpressionNodeType.LITERAL_NUMBER, 0);\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"String\") {\n    if (argsLength === 0) {\n      return new Node(ExpressionNodeType.LITERAL_STRING, \"\");\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"regExp\") {\n    return parseRegex(expression, ast);\n  }\n  throw new RuntimeError(`Unexpected function call \"${call}\".`);\n}\nfunction parseRegex(expression, ast) {\n  const args = ast.arguments;\n  // no arguments, return default regex\n  if (args.length === 0) {\n    return new Node(ExpressionNodeType.LITERAL_REGEX, new RegExp());\n  }\n  const pattern = createRuntimeAst(expression, args[0]);\n  let exp;\n\n  // optional flag argument supplied\n  if (args.length > 1) {\n    const flags = createRuntimeAst(expression, args[1]);\n    if (isLiteralType(pattern) && isLiteralType(flags)) {\n      try {\n        exp = new RegExp(replaceBackslashes(String(pattern._value)), flags._value);\n      } catch (e) {\n        throw new RuntimeError(e);\n      }\n      return new Node(ExpressionNodeType.LITERAL_REGEX, exp);\n    }\n    return new Node(ExpressionNodeType.REGEX, pattern, flags);\n  }\n\n  // only pattern argument supplied\n  if (isLiteralType(pattern)) {\n    try {\n      exp = new RegExp(replaceBackslashes(String(pattern._value)));\n    } catch (e) {\n      throw new RuntimeError(e);\n    }\n    return new Node(ExpressionNodeType.LITERAL_REGEX, exp);\n  }\n  return new Node(ExpressionNodeType.REGEX, pattern);\n}\nfunction parseKeywordsAndVariables(ast) {\n  if (isVariable(ast.name)) {\n    const name = getPropertyName(ast.name);\n    if (name.substr(0, 8) === \"tiles3d_\") {\n      return new Node(ExpressionNodeType.BUILTIN_VARIABLE, name);\n    }\n    return new Node(ExpressionNodeType.VARIABLE, name);\n  } else if (ast.name === \"NaN\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, NaN);\n  } else if (ast.name === \"Infinity\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, Infinity);\n  } else if (ast.name === \"undefined\") {\n    return new Node(ExpressionNodeType.LITERAL_UNDEFINED, undefined);\n  }\n  throw new RuntimeError(`${ast.name} is not defined.`);\n}\nfunction parseMathConstant(ast) {\n  const name = ast.property.name;\n  if (name === \"PI\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, Math.PI);\n  } else if (name === \"E\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, Math.E);\n  }\n}\nfunction parseNumberConstant(ast) {\n  const name = ast.property.name;\n  if (name === \"POSITIVE_INFINITY\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, Number.POSITIVE_INFINITY);\n  }\n}\nfunction parseMemberExpression(expression, ast) {\n  if (ast.object.name === \"Math\") {\n    return parseMathConstant(ast);\n  } else if (ast.object.name === \"Number\") {\n    return parseNumberConstant(ast);\n  }\n  let val;\n  const obj = createRuntimeAst(expression, ast.object);\n  if (ast.computed) {\n    val = createRuntimeAst(expression, ast.property);\n    return new Node(ExpressionNodeType.MEMBER, \"brackets\", obj, val);\n  }\n  val = new Node(ExpressionNodeType.LITERAL_STRING, ast.property.name);\n  return new Node(ExpressionNodeType.MEMBER, \"dot\", obj, val);\n}\nfunction isLiteralType(node) {\n  return node._type >= ExpressionNodeType.LITERAL_NULL;\n}\nfunction isVariable(name) {\n  return name.substr(0, 4) === \"czm_\";\n}\nfunction getPropertyName(variable) {\n  return variable.substr(4);\n}\nfunction createRuntimeAst(expression, ast) {\n  let node;\n  let op;\n  let left;\n  let right;\n  if (ast.type === \"Literal\") {\n    node = parseLiteral(ast);\n  } else if (ast.type === \"CallExpression\") {\n    node = parseCall(expression, ast);\n  } else if (ast.type === \"Identifier\") {\n    node = parseKeywordsAndVariables(ast);\n  } else if (ast.type === \"UnaryExpression\") {\n    op = ast.operator;\n    const child = createRuntimeAst(expression, ast.argument);\n    if (unaryOperators.indexOf(op) > -1) {\n      node = new Node(ExpressionNodeType.UNARY, op, child);\n    } else {\n      throw new RuntimeError(`Unexpected operator \"${op}\".`);\n    }\n  } else if (ast.type === \"BinaryExpression\") {\n    op = ast.operator;\n    left = createRuntimeAst(expression, ast.left);\n    right = createRuntimeAst(expression, ast.right);\n    if (binaryOperators.indexOf(op) > -1) {\n      node = new Node(ExpressionNodeType.BINARY, op, left, right);\n    } else {\n      throw new RuntimeError(`Unexpected operator \"${op}\".`);\n    }\n  } else if (ast.type === \"LogicalExpression\") {\n    op = ast.operator;\n    left = createRuntimeAst(expression, ast.left);\n    right = createRuntimeAst(expression, ast.right);\n    if (binaryOperators.indexOf(op) > -1) {\n      node = new Node(ExpressionNodeType.BINARY, op, left, right);\n    }\n  } else if (ast.type === \"ConditionalExpression\") {\n    const test = createRuntimeAst(expression, ast.test);\n    left = createRuntimeAst(expression, ast.consequent);\n    right = createRuntimeAst(expression, ast.alternate);\n    node = new Node(ExpressionNodeType.CONDITIONAL, \"?\", left, right, test);\n  } else if (ast.type === \"MemberExpression\") {\n    node = parseMemberExpression(expression, ast);\n  } else if (ast.type === \"ArrayExpression\") {\n    const val = [];\n    for (let i = 0; i < ast.elements.length; i++) {\n      val[i] = createRuntimeAst(expression, ast.elements[i]);\n    }\n    node = new Node(ExpressionNodeType.ARRAY, val);\n  } else if (ast.type === \"Compound\") {\n    // empty expression or multiple expressions\n    throw new RuntimeError(\"Provide exactly one expression.\");\n  } else {\n    throw new RuntimeError(\"Cannot parse expression.\");\n  }\n  return node;\n}\nfunction setEvaluateFunction(node) {\n  if (node._type === ExpressionNodeType.CONDITIONAL) {\n    node.evaluate = node._evaluateConditional;\n  } else if (node._type === ExpressionNodeType.FUNCTION_CALL) {\n    if (node._value === \"test\") {\n      node.evaluate = node._evaluateRegExpTest;\n    } else if (node._value === \"exec\") {\n      node.evaluate = node._evaluateRegExpExec;\n    } else if (node._value === \"toString\") {\n      node.evaluate = node._evaluateToString;\n    }\n  } else if (node._type === ExpressionNodeType.UNARY) {\n    if (node._value === \"!\") {\n      node.evaluate = node._evaluateNot;\n    } else if (node._value === \"-\") {\n      node.evaluate = node._evaluateNegative;\n    } else if (node._value === \"+\") {\n      node.evaluate = node._evaluatePositive;\n    } else if (node._value === \"isNaN\") {\n      node.evaluate = node._evaluateNaN;\n    } else if (node._value === \"isFinite\") {\n      node.evaluate = node._evaluateIsFinite;\n    } else if (node._value === \"isExactClass\") {\n      node.evaluate = node._evaluateIsExactClass;\n    } else if (node._value === \"isClass\") {\n      node.evaluate = node._evaluateIsClass;\n    } else if (node._value === \"getExactClassName\") {\n      node.evaluate = node._evaluateGetExactClassName;\n    } else if (node._value === \"Boolean\") {\n      node.evaluate = node._evaluateBooleanConversion;\n    } else if (node._value === \"Number\") {\n      node.evaluate = node._evaluateNumberConversion;\n    } else if (node._value === \"String\") {\n      node.evaluate = node._evaluateStringConversion;\n    } else if (defined(unaryFunctions[node._value])) {\n      node.evaluate = getEvaluateUnaryFunction(node._value);\n    }\n  } else if (node._type === ExpressionNodeType.BINARY) {\n    if (node._value === \"+\") {\n      node.evaluate = node._evaluatePlus;\n    } else if (node._value === \"-\") {\n      node.evaluate = node._evaluateMinus;\n    } else if (node._value === \"*\") {\n      node.evaluate = node._evaluateTimes;\n    } else if (node._value === \"/\") {\n      node.evaluate = node._evaluateDivide;\n    } else if (node._value === \"%\") {\n      node.evaluate = node._evaluateMod;\n    } else if (node._value === \"===\") {\n      node.evaluate = node._evaluateEqualsStrict;\n    } else if (node._value === \"!==\") {\n      node.evaluate = node._evaluateNotEqualsStrict;\n    } else if (node._value === \"<\") {\n      node.evaluate = node._evaluateLessThan;\n    } else if (node._value === \"<=\") {\n      node.evaluate = node._evaluateLessThanOrEquals;\n    } else if (node._value === \">\") {\n      node.evaluate = node._evaluateGreaterThan;\n    } else if (node._value === \">=\") {\n      node.evaluate = node._evaluateGreaterThanOrEquals;\n    } else if (node._value === \"&&\") {\n      node.evaluate = node._evaluateAnd;\n    } else if (node._value === \"||\") {\n      node.evaluate = node._evaluateOr;\n    } else if (node._value === \"=~\") {\n      node.evaluate = node._evaluateRegExpMatch;\n    } else if (node._value === \"!~\") {\n      node.evaluate = node._evaluateRegExpNotMatch;\n    } else if (defined(binaryFunctions[node._value])) {\n      node.evaluate = getEvaluateBinaryFunction(node._value);\n    }\n  } else if (node._type === ExpressionNodeType.TERNARY) {\n    node.evaluate = getEvaluateTernaryFunction(node._value);\n  } else if (node._type === ExpressionNodeType.MEMBER) {\n    if (node._value === \"brackets\") {\n      node.evaluate = node._evaluateMemberBrackets;\n    } else {\n      node.evaluate = node._evaluateMemberDot;\n    }\n  } else if (node._type === ExpressionNodeType.ARRAY) {\n    node.evaluate = node._evaluateArray;\n  } else if (node._type === ExpressionNodeType.VARIABLE) {\n    node.evaluate = node._evaluateVariable;\n  } else if (node._type === ExpressionNodeType.VARIABLE_IN_STRING) {\n    node.evaluate = node._evaluateVariableString;\n  } else if (node._type === ExpressionNodeType.LITERAL_COLOR) {\n    node.evaluate = node._evaluateLiteralColor;\n  } else if (node._type === ExpressionNodeType.LITERAL_VECTOR) {\n    node.evaluate = node._evaluateLiteralVector;\n  } else if (node._type === ExpressionNodeType.LITERAL_STRING) {\n    node.evaluate = node._evaluateLiteralString;\n  } else if (node._type === ExpressionNodeType.REGEX) {\n    node.evaluate = node._evaluateRegExp;\n  } else if (node._type === ExpressionNodeType.BUILTIN_VARIABLE) {\n    if (node._value === \"tiles3d_tileset_time\") {\n      node.evaluate = evaluateTilesetTime;\n    }\n  } else {\n    node.evaluate = node._evaluateLiteral;\n  }\n}\nfunction evaluateTilesetTime(feature) {\n  if (!defined(feature)) {\n    return 0.0;\n  }\n  return feature.content.tileset.timeSinceLoad;\n}\nfunction getEvaluateUnaryFunction(call) {\n  const evaluate = unaryFunctions[call];\n  return function (feature) {\n    const left = this._left.evaluate(feature);\n    return evaluate(call, left);\n  };\n}\nfunction getEvaluateBinaryFunction(call) {\n  const evaluate = binaryFunctions[call];\n  return function (feature) {\n    const left = this._left.evaluate(feature);\n    const right = this._right.evaluate(feature);\n    return evaluate(call, left, right);\n  };\n}\nfunction getEvaluateTernaryFunction(call) {\n  const evaluate = ternaryFunctions[call];\n  return function (feature) {\n    const left = this._left.evaluate(feature);\n    const right = this._right.evaluate(feature);\n    const test = this._test.evaluate(feature);\n    return evaluate(call, left, right, test);\n  };\n}\nfunction getFeatureProperty(feature, name) {\n  // Returns undefined if the feature is not defined or the property name is not defined for that feature\n  if (defined(feature)) {\n    return feature.getPropertyInherited(name);\n  }\n}\nNode.prototype._evaluateLiteral = function () {\n  return this._value;\n};\nNode.prototype._evaluateLiteralColor = function (feature) {\n  const color = scratchColor;\n  const args = this._left;\n  if (this._value === \"color\") {\n    if (!defined(args)) {\n      Color.fromBytes(255, 255, 255, 255, color);\n    } else if (args.length > 1) {\n      Color.fromCssColorString(args[0].evaluate(feature), color);\n      color.alpha = args[1].evaluate(feature);\n    } else {\n      Color.fromCssColorString(args[0].evaluate(feature), color);\n    }\n  } else if (this._value === \"rgb\") {\n    Color.fromBytes(args[0].evaluate(feature), args[1].evaluate(feature), args[2].evaluate(feature), 255, color);\n  } else if (this._value === \"rgba\") {\n    // convert between css alpha (0 to 1) and cesium alpha (0 to 255)\n    const a = args[3].evaluate(feature) * 255;\n    Color.fromBytes(args[0].evaluate(feature), args[1].evaluate(feature), args[2].evaluate(feature), a, color);\n  } else if (this._value === \"hsl\") {\n    Color.fromHsl(args[0].evaluate(feature), args[1].evaluate(feature), args[2].evaluate(feature), 1.0, color);\n  } else if (this._value === \"hsla\") {\n    Color.fromHsl(args[0].evaluate(feature), args[1].evaluate(feature), args[2].evaluate(feature), args[3].evaluate(feature), color);\n  }\n  return Cartesian4.fromColor(color, scratchStorage.getCartesian4());\n};\nNode.prototype._evaluateLiteralVector = function (feature) {\n  // Gather the components that make up the vector, which includes components from interior vectors.\n  // For example vec3(1, 2, 3) or vec3(vec2(1, 2), 3) are both valid.\n  //\n  // If the number of components does not equal the vector's size, then a RuntimeError is thrown - with two exceptions:\n  // 1. A vector may be constructed from a larger vector and drop the extra components.\n  // 2. A vector may be constructed from a single component - vec3(1) will become vec3(1, 1, 1).\n  //\n  // Examples of invalid constructors include:\n  // vec4(1, 2)        // not enough components\n  // vec3(vec2(1, 2))  // not enough components\n  // vec3(1, 2, 3, 4)  // too many components\n  // vec2(vec4(1), 1)  // too many components\n\n  const components = scratchStorage.getArray();\n  const call = this._value;\n  const args = this._left;\n  const argsLength = args.length;\n  for (let i = 0; i < argsLength; ++i) {\n    const value = args[i].evaluate(feature);\n    if (typeof value === \"number\") {\n      components.push(value);\n    } else if (value instanceof Cartesian2) {\n      components.push(value.x, value.y);\n    } else if (value instanceof Cartesian3) {\n      components.push(value.x, value.y, value.z);\n    } else if (value instanceof Cartesian4) {\n      components.push(value.x, value.y, value.z, value.w);\n    } else {\n      throw new RuntimeError(`${call} argument must be a vector or number. Argument is ${value}.`);\n    }\n  }\n  const componentsLength = components.length;\n  const vectorLength = parseInt(call.charAt(3));\n  if (componentsLength === 0) {\n    throw new RuntimeError(`Invalid ${call} constructor. No valid arguments.`);\n  } else if (componentsLength < vectorLength && componentsLength > 1) {\n    throw new RuntimeError(`Invalid ${call} constructor. Not enough arguments.`);\n  } else if (componentsLength > vectorLength && argsLength > 1) {\n    throw new RuntimeError(`Invalid ${call} constructor. Too many arguments.`);\n  }\n  if (componentsLength === 1) {\n    // Add the same component 3 more times\n    const component = components[0];\n    components.push(component, component, component);\n  }\n  if (call === \"vec2\") {\n    return Cartesian2.fromArray(components, 0, scratchStorage.getCartesian2());\n  } else if (call === \"vec3\") {\n    return Cartesian3.fromArray(components, 0, scratchStorage.getCartesian3());\n  } else if (call === \"vec4\") {\n    return Cartesian4.fromArray(components, 0, scratchStorage.getCartesian4());\n  }\n};\nNode.prototype._evaluateLiteralString = function () {\n  return this._value;\n};\nNode.prototype._evaluateVariableString = function (feature) {\n  let result = this._value;\n  let match = variableRegex.exec(result);\n  while (match !== null) {\n    const placeholder = match[0];\n    const variableName = match[1];\n    let property = getFeatureProperty(feature, variableName);\n    if (!defined(property)) {\n      property = \"\";\n    }\n    result = result.replace(placeholder, property);\n    variableRegex.lastIndex += property.length - placeholder.length;\n    match = variableRegex.exec(result);\n  }\n  return result;\n};\nNode.prototype._evaluateVariable = function (feature) {\n  // evaluates to undefined if the property name is not defined for that feature\n  return getFeatureProperty(feature, this._value);\n};\nfunction checkFeature(ast) {\n  return ast._value === \"feature\";\n}\n\n// PERFORMANCE_IDEA: Determine if parent property needs to be computed before runtime\nNode.prototype._evaluateMemberDot = function (feature) {\n  if (checkFeature(this._left)) {\n    return getFeatureProperty(feature, this._right.evaluate(feature));\n  }\n  const property = this._left.evaluate(feature);\n  if (!defined(property)) {\n    return undefined;\n  }\n  const member = this._right.evaluate(feature);\n  if (property instanceof Cartesian2 || property instanceof Cartesian3 || property instanceof Cartesian4) {\n    // Vector components may be accessed with .r, .g, .b, .a and implicitly with .x, .y, .z, .w\n    if (member === \"r\") {\n      return property.x;\n    } else if (member === \"g\") {\n      return property.y;\n    } else if (member === \"b\") {\n      return property.z;\n    } else if (member === \"a\") {\n      return property.w;\n    }\n  }\n  return property[member];\n};\nNode.prototype._evaluateMemberBrackets = function (feature) {\n  if (checkFeature(this._left)) {\n    return getFeatureProperty(feature, this._right.evaluate(feature));\n  }\n  const property = this._left.evaluate(feature);\n  if (!defined(property)) {\n    return undefined;\n  }\n  const member = this._right.evaluate(feature);\n  if (property instanceof Cartesian2 || property instanceof Cartesian3 || property instanceof Cartesian4) {\n    // Vector components may be accessed with [0][1][2][3], ['r']['g']['b']['a'] and implicitly with ['x']['y']['z']['w']\n    // For Cartesian2 and Cartesian3 out-of-range components will just return undefined\n    if (member === 0 || member === \"r\") {\n      return property.x;\n    } else if (member === 1 || member === \"g\") {\n      return property.y;\n    } else if (member === 2 || member === \"b\") {\n      return property.z;\n    } else if (member === 3 || member === \"a\") {\n      return property.w;\n    }\n  }\n  return property[member];\n};\nNode.prototype._evaluateArray = function (feature) {\n  const array = [];\n  for (let i = 0; i < this._value.length; i++) {\n    array[i] = this._value[i].evaluate(feature);\n  }\n  return array;\n};\n\n// PERFORMANCE_IDEA: Have \"fast path\" functions that deal only with specific types\n// that we can assign if we know the types before runtime\n\nNode.prototype._evaluateNot = function (feature) {\n  const left = this._left.evaluate(feature);\n  if (typeof left !== \"boolean\") {\n    throw new RuntimeError(`Operator \"!\" requires a boolean argument. Argument is ${left}.`);\n  }\n  return !left;\n};\nNode.prototype._evaluateNegative = function (feature) {\n  const left = this._left.evaluate(feature);\n  if (left instanceof Cartesian2) {\n    return Cartesian2.negate(left, scratchStorage.getCartesian2());\n  } else if (left instanceof Cartesian3) {\n    return Cartesian3.negate(left, scratchStorage.getCartesian3());\n  } else if (left instanceof Cartesian4) {\n    return Cartesian4.negate(left, scratchStorage.getCartesian4());\n  } else if (typeof left === \"number\") {\n    return -left;\n  }\n  throw new RuntimeError(`Operator \"-\" requires a vector or number argument. Argument is ${left}.`);\n};\nNode.prototype._evaluatePositive = function (feature) {\n  const left = this._left.evaluate(feature);\n  if (!(left instanceof Cartesian2 || left instanceof Cartesian3 || left instanceof Cartesian4 || typeof left === \"number\")) {\n    throw new RuntimeError(`Operator \"+\" requires a vector or number argument. Argument is ${left}.`);\n  }\n  return left;\n};\nNode.prototype._evaluateLessThan = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (typeof left !== \"number\" || typeof right !== \"number\") {\n    throw new RuntimeError(`Operator \"<\" requires number arguments. Arguments are ${left} and ${right}.`);\n  }\n  return left < right;\n};\nNode.prototype._evaluateLessThanOrEquals = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (typeof left !== \"number\" || typeof right !== \"number\") {\n    throw new RuntimeError(`Operator \"<=\" requires number arguments. Arguments are ${left} and ${right}.`);\n  }\n  return left <= right;\n};\nNode.prototype._evaluateGreaterThan = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (typeof left !== \"number\" || typeof right !== \"number\") {\n    throw new RuntimeError(`Operator \">\" requires number arguments. Arguments are ${left} and ${right}.`);\n  }\n  return left > right;\n};\nNode.prototype._evaluateGreaterThanOrEquals = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (typeof left !== \"number\" || typeof right !== \"number\") {\n    throw new RuntimeError(`Operator \">=\" requires number arguments. Arguments are ${left} and ${right}.`);\n  }\n  return left >= right;\n};\nNode.prototype._evaluateOr = function (feature) {\n  const left = this._left.evaluate(feature);\n  if (typeof left !== \"boolean\") {\n    throw new RuntimeError(`Operator \"||\" requires boolean arguments. First argument is ${left}.`);\n  }\n\n  // short circuit the expression\n  if (left) {\n    return true;\n  }\n  const right = this._right.evaluate(feature);\n  if (typeof right !== \"boolean\") {\n    throw new RuntimeError(`Operator \"||\" requires boolean arguments. Second argument is ${right}.`);\n  }\n  return left || right;\n};\nNode.prototype._evaluateAnd = function (feature) {\n  const left = this._left.evaluate(feature);\n  if (typeof left !== \"boolean\") {\n    throw new RuntimeError(`Operator \"&&\" requires boolean arguments. First argument is ${left}.`);\n  }\n\n  // short circuit the expression\n  if (!left) {\n    return false;\n  }\n  const right = this._right.evaluate(feature);\n  if (typeof right !== \"boolean\") {\n    throw new RuntimeError(`Operator \"&&\" requires boolean arguments. Second argument is ${right}.`);\n  }\n  return left && right;\n};\nNode.prototype._evaluatePlus = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.add(left, right, scratchStorage.getCartesian2());\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.add(left, right, scratchStorage.getCartesian3());\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.add(left, right, scratchStorage.getCartesian4());\n  } else if (typeof left === \"string\" || typeof right === \"string\") {\n    // If only one argument is a string the other argument calls its toString function.\n    return left + right;\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left + right;\n  }\n  throw new RuntimeError(`Operator \"+\" requires vector or number arguments of matching types, or at least one string argument. Arguments are ${left} and ${right}.`);\n};\nNode.prototype._evaluateMinus = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.subtract(left, right, scratchStorage.getCartesian2());\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.subtract(left, right, scratchStorage.getCartesian3());\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.subtract(left, right, scratchStorage.getCartesian4());\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left - right;\n  }\n  throw new RuntimeError(`Operator \"-\" requires vector or number arguments of matching types. Arguments are ${left} and ${right}.`);\n};\nNode.prototype._evaluateTimes = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.multiplyComponents(left, right, scratchStorage.getCartesian2());\n  } else if (right instanceof Cartesian2 && typeof left === \"number\") {\n    return Cartesian2.multiplyByScalar(right, left, scratchStorage.getCartesian2());\n  } else if (left instanceof Cartesian2 && typeof right === \"number\") {\n    return Cartesian2.multiplyByScalar(left, right, scratchStorage.getCartesian2());\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.multiplyComponents(left, right, scratchStorage.getCartesian3());\n  } else if (right instanceof Cartesian3 && typeof left === \"number\") {\n    return Cartesian3.multiplyByScalar(right, left, scratchStorage.getCartesian3());\n  } else if (left instanceof Cartesian3 && typeof right === \"number\") {\n    return Cartesian3.multiplyByScalar(left, right, scratchStorage.getCartesian3());\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.multiplyComponents(left, right, scratchStorage.getCartesian4());\n  } else if (right instanceof Cartesian4 && typeof left === \"number\") {\n    return Cartesian4.multiplyByScalar(right, left, scratchStorage.getCartesian4());\n  } else if (left instanceof Cartesian4 && typeof right === \"number\") {\n    return Cartesian4.multiplyByScalar(left, right, scratchStorage.getCartesian4());\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left * right;\n  }\n  throw new RuntimeError(`Operator \"*\" requires vector or number arguments. If both arguments are vectors they must be matching types. Arguments are ${left} and ${right}.`);\n};\nNode.prototype._evaluateDivide = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.divideComponents(left, right, scratchStorage.getCartesian2());\n  } else if (left instanceof Cartesian2 && typeof right === \"number\") {\n    return Cartesian2.divideByScalar(left, right, scratchStorage.getCartesian2());\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.divideComponents(left, right, scratchStorage.getCartesian3());\n  } else if (left instanceof Cartesian3 && typeof right === \"number\") {\n    return Cartesian3.divideByScalar(left, right, scratchStorage.getCartesian3());\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.divideComponents(left, right, scratchStorage.getCartesian4());\n  } else if (left instanceof Cartesian4 && typeof right === \"number\") {\n    return Cartesian4.divideByScalar(left, right, scratchStorage.getCartesian4());\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left / right;\n  }\n  throw new RuntimeError(`Operator \"/\" requires vector or number arguments of matching types, or a number as the second argument. Arguments are ${left} and ${right}.`);\n};\nNode.prototype._evaluateMod = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.fromElements(left.x % right.x, left.y % right.y, scratchStorage.getCartesian2());\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.fromElements(left.x % right.x, left.y % right.y, left.z % right.z, scratchStorage.getCartesian3());\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.fromElements(left.x % right.x, left.y % right.y, left.z % right.z, left.w % right.w, scratchStorage.getCartesian4());\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left % right;\n  }\n  throw new RuntimeError(`Operator \"%\" requires vector or number arguments of matching types. Arguments are ${left} and ${right}.`);\n};\nNode.prototype._evaluateEqualsStrict = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (right instanceof Cartesian2 && left instanceof Cartesian2 || right instanceof Cartesian3 && left instanceof Cartesian3 || right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return left.equals(right);\n  }\n  return left === right;\n};\nNode.prototype._evaluateNotEqualsStrict = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (right instanceof Cartesian2 && left instanceof Cartesian2 || right instanceof Cartesian3 && left instanceof Cartesian3 || right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return !left.equals(right);\n  }\n  return left !== right;\n};\nNode.prototype._evaluateConditional = function (feature) {\n  const test = this._test.evaluate(feature);\n  if (typeof test !== \"boolean\") {\n    throw new RuntimeError(`Conditional argument of conditional expression must be a boolean. Argument is ${test}.`);\n  }\n  if (test) {\n    return this._left.evaluate(feature);\n  }\n  return this._right.evaluate(feature);\n};\nNode.prototype._evaluateNaN = function (feature) {\n  return isNaN(this._left.evaluate(feature));\n};\nNode.prototype._evaluateIsFinite = function (feature) {\n  return isFinite(this._left.evaluate(feature));\n};\nNode.prototype._evaluateIsExactClass = function (feature) {\n  if (defined(feature)) {\n    return feature.isExactClass(this._left.evaluate(feature));\n  }\n  return false;\n};\nNode.prototype._evaluateIsClass = function (feature) {\n  if (defined(feature)) {\n    return feature.isClass(this._left.evaluate(feature));\n  }\n  return false;\n};\nNode.prototype._evaluateGetExactClassName = function (feature) {\n  if (defined(feature)) {\n    return feature.getExactClassName();\n  }\n};\nNode.prototype._evaluateBooleanConversion = function (feature) {\n  return Boolean(this._left.evaluate(feature));\n};\nNode.prototype._evaluateNumberConversion = function (feature) {\n  return Number(this._left.evaluate(feature));\n};\nNode.prototype._evaluateStringConversion = function (feature) {\n  return String(this._left.evaluate(feature));\n};\nNode.prototype._evaluateRegExp = function (feature) {\n  const pattern = this._value.evaluate(feature);\n  let flags = \"\";\n  if (defined(this._left)) {\n    flags = this._left.evaluate(feature);\n  }\n  let exp;\n  try {\n    exp = new RegExp(pattern, flags);\n  } catch (e) {\n    throw new RuntimeError(e);\n  }\n  return exp;\n};\nNode.prototype._evaluateRegExpTest = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (!(left instanceof RegExp && typeof right === \"string\")) {\n    throw new RuntimeError(`RegExp.test requires the first argument to be a RegExp and the second argument to be a string. Arguments are ${left} and ${right}.`);\n  }\n  return left.test(right);\n};\nNode.prototype._evaluateRegExpMatch = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (left instanceof RegExp && typeof right === \"string\") {\n    return left.test(right);\n  } else if (right instanceof RegExp && typeof left === \"string\") {\n    return right.test(left);\n  }\n  throw new RuntimeError(`Operator \"=~\" requires one RegExp argument and one string argument. Arguments are ${left} and ${right}.`);\n};\nNode.prototype._evaluateRegExpNotMatch = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (left instanceof RegExp && typeof right === \"string\") {\n    return !left.test(right);\n  } else if (right instanceof RegExp && typeof left === \"string\") {\n    return !right.test(left);\n  }\n  throw new RuntimeError(`Operator \"!~\" requires one RegExp argument and one string argument. Arguments are ${left} and ${right}.`);\n};\nNode.prototype._evaluateRegExpExec = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (!(left instanceof RegExp && typeof right === \"string\")) {\n    throw new RuntimeError(`RegExp.exec requires the first argument to be a RegExp and the second argument to be a string. Arguments are ${left} and ${right}.`);\n  }\n  const exec = left.exec(right);\n  if (!defined(exec)) {\n    return null;\n  }\n  return exec[1];\n};\nNode.prototype._evaluateToString = function (feature) {\n  const left = this._left.evaluate(feature);\n  if (left instanceof RegExp || left instanceof Cartesian2 || left instanceof Cartesian3 || left instanceof Cartesian4) {\n    return String(left);\n  }\n  throw new RuntimeError(`Unexpected function call \"${this._value}\".`);\n};\nfunction convertHSLToRGB(ast) {\n  // Check if the color contains any nested expressions to see if the color can be converted here.\n  // E.g. \"hsl(0.9, 0.6, 0.7)\" is able to convert directly to rgb, \"hsl(0.9, 0.6, ${Height})\" is not.\n  const channels = ast._left;\n  const length = channels.length;\n  for (let i = 0; i < length; ++i) {\n    if (channels[i]._type !== ExpressionNodeType.LITERAL_NUMBER) {\n      return undefined;\n    }\n  }\n  const h = channels[0]._value;\n  const s = channels[1]._value;\n  const l = channels[2]._value;\n  const a = length === 4 ? channels[3]._value : 1.0;\n  return Color.fromHsl(h, s, l, a, scratchColor);\n}\nfunction convertRGBToColor(ast) {\n  // Check if the color contains any nested expressions to see if the color can be converted here.\n  // E.g. \"rgb(255, 255, 255)\" is able to convert directly to Color, \"rgb(255, 255, ${Height})\" is not.\n  const channels = ast._left;\n  const length = channels.length;\n  for (let i = 0; i < length; ++i) {\n    if (channels[i]._type !== ExpressionNodeType.LITERAL_NUMBER) {\n      return undefined;\n    }\n  }\n  const color = scratchColor;\n  color.red = channels[0]._value / 255.0;\n  color.green = channels[1]._value / 255.0;\n  color.blue = channels[2]._value / 255.0;\n  color.alpha = length === 4 ? channels[3]._value : 1.0;\n  return color;\n}\nfunction numberToString(number) {\n  if (number % 1 === 0) {\n    // Add a .0 to whole numbers\n    return number.toFixed(1);\n  }\n  return number.toString();\n}\nfunction colorToVec3(color) {\n  const r = numberToString(color.red);\n  const g = numberToString(color.green);\n  const b = numberToString(color.blue);\n  return `vec3(${r}, ${g}, ${b})`;\n}\nfunction colorToVec4(color) {\n  const r = numberToString(color.red);\n  const g = numberToString(color.green);\n  const b = numberToString(color.blue);\n  const a = numberToString(color.alpha);\n  return `vec4(${r}, ${g}, ${b}, ${a})`;\n}\nfunction getExpressionArray(array, variableSubstitutionMap, shaderState, parent) {\n  const length = array.length;\n  const expressions = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    expressions[i] = array[i].getShaderExpression(variableSubstitutionMap, shaderState, parent);\n  }\n  return expressions;\n}\nfunction getVariableName(variableName, variableSubstitutionMap) {\n  if (!defined(variableSubstitutionMap[variableName])) {\n    return Expression.NULL_SENTINEL;\n  }\n  return variableSubstitutionMap[variableName];\n}\n\n/**\n * @private\n */\nExpression.NULL_SENTINEL = \"czm_infinity\"; // null just needs to be some sentinel value that will cause \"[expression] === null\" to be false in nearly all cases. GLSL doesn't have a NaN constant so use czm_infinity.\n\nNode.prototype.getShaderExpression = function (variableSubstitutionMap, shaderState, parent) {\n  let color;\n  let left;\n  let right;\n  let test;\n  const type = this._type;\n  let value = this._value;\n  if (defined(this._left)) {\n    if (Array.isArray(this._left)) {\n      // Left can be an array if the type is LITERAL_COLOR or LITERAL_VECTOR\n      left = getExpressionArray(this._left, variableSubstitutionMap, shaderState, this);\n    } else {\n      left = this._left.getShaderExpression(variableSubstitutionMap, shaderState, this);\n    }\n  }\n  if (defined(this._right)) {\n    right = this._right.getShaderExpression(variableSubstitutionMap, shaderState, this);\n  }\n  if (defined(this._test)) {\n    test = this._test.getShaderExpression(variableSubstitutionMap, shaderState, this);\n  }\n  if (Array.isArray(this._value)) {\n    // For ARRAY type\n    value = getExpressionArray(this._value, variableSubstitutionMap, shaderState, this);\n  }\n  let args;\n  let length;\n  let vectorExpression;\n  switch (type) {\n    case ExpressionNodeType.VARIABLE:\n      if (checkFeature(this)) {\n        return undefined;\n      }\n      return getVariableName(value, variableSubstitutionMap);\n    case ExpressionNodeType.UNARY:\n      // Supported types: +, -, !, Boolean, Number\n      if (value === \"Boolean\") {\n        return `bool(${left})`;\n      } else if (value === \"Number\") {\n        return `float(${left})`;\n      } else if (value === \"round\") {\n        return `floor(${left} + 0.5)`;\n      } else if (defined(unaryFunctions[value])) {\n        return `${value}(${left})`;\n      } else if (value === \"isNaN\") {\n        // In GLSL 2.0 use isnan instead\n        return `(${left} != ${left})`;\n      } else if (value === \"isFinite\") {\n        // In GLSL 2.0 use isinf instead. GLSL doesn't have an infinity constant so use czm_infinity which is an arbitrarily big enough number.\n        return `(abs(${left}) < czm_infinity)`;\n      } else if (value === \"String\" || value === \"isExactClass\" || value === \"isClass\" || value === \"getExactClassName\") {\n        throw new RuntimeError(`Error generating style shader: \"${value}\" is not supported.`);\n      }\n      return value + left;\n    case ExpressionNodeType.BINARY:\n      // Supported types: ||, &&, ===, !==, <, >, <=, >=, +, -, *, /, %\n      if (value === \"%\") {\n        return `mod(${left}, ${right})`;\n      } else if (value === \"===\") {\n        return `(${left} == ${right})`;\n      } else if (value === \"!==\") {\n        return `(${left} != ${right})`;\n      } else if (value === \"atan2\") {\n        return `atan(${left}, ${right})`;\n      } else if (defined(binaryFunctions[value])) {\n        return `${value}(${left}, ${right})`;\n      }\n      return `(${left} ${value} ${right})`;\n    case ExpressionNodeType.TERNARY:\n      if (defined(ternaryFunctions[value])) {\n        return `${value}(${left}, ${right}, ${test})`;\n      }\n      break;\n    case ExpressionNodeType.CONDITIONAL:\n      return `(${test} ? ${left} : ${right})`;\n    case ExpressionNodeType.MEMBER:\n      if (checkFeature(this._left)) {\n        return getVariableName(right, variableSubstitutionMap);\n      }\n      // This is intended for accessing the components of vector properties. String members aren't supported.\n      // Check for 0.0 rather than 0 because all numbers are previously converted to decimals.\n      if (right === \"r\" || right === \"x\" || right === \"0.0\") {\n        return `${left}[0]`;\n      } else if (right === \"g\" || right === \"y\" || right === \"1.0\") {\n        return `${left}[1]`;\n      } else if (right === \"b\" || right === \"z\" || right === \"2.0\") {\n        return `${left}[2]`;\n      } else if (right === \"a\" || right === \"w\" || right === \"3.0\") {\n        return `${left}[3]`;\n      }\n      return `${left}[int(${right})]`;\n    case ExpressionNodeType.FUNCTION_CALL:\n      throw new RuntimeError(`Error generating style shader: \"${value}\" is not supported.`);\n    case ExpressionNodeType.ARRAY:\n      if (value.length === 4) {\n        return `vec4(${value[0]}, ${value[1]}, ${value[2]}, ${value[3]})`;\n      } else if (value.length === 3) {\n        return `vec3(${value[0]}, ${value[1]}, ${value[2]})`;\n      } else if (value.length === 2) {\n        return `vec2(${value[0]}, ${value[1]})`;\n      }\n      throw new RuntimeError(\"Error generating style shader: Invalid array length. Array length should be 2, 3, or 4.\");\n    case ExpressionNodeType.REGEX:\n      throw new RuntimeError(\"Error generating style shader: Regular expressions are not supported.\");\n    case ExpressionNodeType.VARIABLE_IN_STRING:\n      throw new RuntimeError(\"Error generating style shader: Converting a variable to a string is not supported.\");\n    case ExpressionNodeType.LITERAL_NULL:\n      return Expression.NULL_SENTINEL;\n    case ExpressionNodeType.LITERAL_BOOLEAN:\n      return value ? \"true\" : \"false\";\n    case ExpressionNodeType.LITERAL_NUMBER:\n      return numberToString(value);\n    case ExpressionNodeType.LITERAL_STRING:\n      if (defined(parent) && parent._type === ExpressionNodeType.MEMBER) {\n        if (value === \"r\" || value === \"g\" || value === \"b\" || value === \"a\" || value === \"x\" || value === \"y\" || value === \"z\" || value === \"w\" || checkFeature(parent._left)) {\n          return value;\n        }\n      }\n      // Check for css color strings\n      color = Color.fromCssColorString(value, scratchColor);\n      if (defined(color)) {\n        return colorToVec3(color);\n      }\n      throw new RuntimeError(\"Error generating style shader: String literals are not supported.\");\n    case ExpressionNodeType.LITERAL_COLOR:\n      args = left;\n      if (value === \"color\") {\n        if (!defined(args)) {\n          return \"vec4(1.0)\";\n        } else if (args.length > 1) {\n          const rgb = args[0];\n          const alpha = args[1];\n          if (alpha !== \"1.0\") {\n            shaderState.translucent = true;\n          }\n          return `vec4(${rgb}, ${alpha})`;\n        }\n        return `vec4(${args[0]}, 1.0)`;\n      } else if (value === \"rgb\") {\n        color = convertRGBToColor(this);\n        if (defined(color)) {\n          return colorToVec4(color);\n        }\n        return `vec4(${args[0]} / 255.0, ${args[1]} / 255.0, ${args[2]} / 255.0, 1.0)`;\n      } else if (value === \"rgba\") {\n        if (args[3] !== \"1.0\") {\n          shaderState.translucent = true;\n        }\n        color = convertRGBToColor(this);\n        if (defined(color)) {\n          return colorToVec4(color);\n        }\n        return `vec4(${args[0]} / 255.0, ${args[1]} / 255.0, ${args[2]} / 255.0, ${args[3]})`;\n      } else if (value === \"hsl\") {\n        color = convertHSLToRGB(this);\n        if (defined(color)) {\n          return colorToVec4(color);\n        }\n        return `vec4(czm_HSLToRGB(vec3(${args[0]}, ${args[1]}, ${args[2]})), 1.0)`;\n      } else if (value === \"hsla\") {\n        color = convertHSLToRGB(this);\n        if (defined(color)) {\n          if (color.alpha !== 1.0) {\n            shaderState.translucent = true;\n          }\n          return colorToVec4(color);\n        }\n        if (args[3] !== \"1.0\") {\n          shaderState.translucent = true;\n        }\n        return `vec4(czm_HSLToRGB(vec3(${args[0]}, ${args[1]}, ${args[2]})), ${args[3]})`;\n      }\n      break;\n    case ExpressionNodeType.LITERAL_VECTOR:\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(left)) {\n        throw new DeveloperError(\"left should always be defined for type ExpressionNodeType.LITERAL_VECTOR\");\n      }\n      //>>includeEnd('debug');\n      length = left.length;\n      vectorExpression = `${value}(`;\n      for (let i = 0; i < length; ++i) {\n        vectorExpression += left[i];\n        if (i < length - 1) {\n          vectorExpression += \", \";\n        }\n      }\n      vectorExpression += \")\";\n      return vectorExpression;\n    case ExpressionNodeType.LITERAL_REGEX:\n      throw new RuntimeError(\"Error generating style shader: Regular expressions are not supported.\");\n    case ExpressionNodeType.LITERAL_UNDEFINED:\n      return Expression.NULL_SENTINEL;\n    case ExpressionNodeType.BUILTIN_VARIABLE:\n      if (value === \"tiles3d_tileset_time\") {\n        return value;\n      }\n  }\n};\nNode.prototype.getVariables = function (variables, parent) {\n  let array;\n  let length;\n  let i;\n  const type = this._type;\n  const value = this._value;\n  if (defined(this._left)) {\n    if (Array.isArray(this._left)) {\n      // Left can be an array if the type is LITERAL_COLOR or LITERAL_VECTOR\n      array = this._left;\n      length = array.length;\n      for (i = 0; i < length; ++i) {\n        array[i].getVariables(variables, this);\n      }\n    } else {\n      this._left.getVariables(variables, this);\n    }\n  }\n  if (defined(this._right)) {\n    this._right.getVariables(variables, this);\n  }\n  if (defined(this._test)) {\n    this._test.getVariables(variables, this);\n  }\n  if (Array.isArray(this._value)) {\n    // For ARRAY type\n    array = this._value;\n    length = array.length;\n    for (i = 0; i < length; ++i) {\n      array[i].getVariables(variables, this);\n    }\n  }\n  let match;\n  switch (type) {\n    case ExpressionNodeType.VARIABLE:\n      if (!checkFeature(this)) {\n        variables.push(value);\n      }\n      break;\n    case ExpressionNodeType.VARIABLE_IN_STRING:\n      match = variableRegex.exec(value);\n      while (match !== null) {\n        variables.push(match[1]);\n        match = variableRegex.exec(value);\n      }\n      break;\n    case ExpressionNodeType.LITERAL_STRING:\n      if (defined(parent) && parent._type === ExpressionNodeType.MEMBER && checkFeature(parent._left)) {\n        variables.push(value);\n      }\n      break;\n  }\n};\nexport default Expression;","map":{"version":3,"names":["Cartesian2","Cartesian3","Cartesian4","Check","Color","defined","DeveloperError","CesiumMath","RuntimeError","jsep","ExpressionNodeType","Expression","expression","defines","typeOf","string","_expression","replaceDefines","replaceVariables","removeBackslashes","addBinaryOp","ast","e","_runtimeAst","createRuntimeAst","Object","defineProperties","prototype","get","scratchStorage","arrayIndex","arrayArray","cartesian2Index","cartesian3Index","cartesian4Index","cartesian2Array","cartesian3Array","cartesian4Array","reset","getArray","length","push","array","getCartesian2","getCartesian3","getCartesian4","evaluate","feature","result","value","fromCartesian4","clone","evaluateColor","color","getShaderFunction","functionSignature","variableSubstitutionMap","shaderState","returnType","shaderExpression","getShaderExpression","getVariables","variables","filter","variable","index","indexOf","unaryOperators","binaryOperators","variableRegex","backslashRegex","backslashReplacement","replacementRegex","scratchColor","unaryFunctions","abs","getEvaluateUnaryComponentwise","Math","sqrt","cos","sin","tan","acos","asin","atan","radians","toRadians","degrees","toDegrees","sign","floor","ceil","round","exp","exp2","log","log2","fract","normalize","binaryFunctions","atan2","getEvaluateBinaryComponentwise","pow","min","max","distance","dot","cross","ternaryFunctions","clamp","getEvaluateTernaryComponentwise","mix","lerp","number","exponent","operation","call","left","fromElements","x","y","z","w","allowScalar","right","test","magnitude","Node","type","_type","_value","_left","_right","_test","undefined","setEvaluateFunction","key","hasOwnProperty","definePlaceholder","RegExp","defineReplace","replace","replaceBackslashes","i","openSingleQuote","openDoubleQuote","closeQuote","substr","j","parseLiteral","LITERAL_NULL","LITERAL_BOOLEAN","LITERAL_NUMBER","VARIABLE_IN_STRING","LITERAL_STRING","parseCall","args","arguments","argsLength","val","callee","property","name","object","FUNCTION_CALL","LITERAL_COLOR","alpha","Array","LITERAL_VECTOR","UNARY","BINARY","TERNARY","parseRegex","LITERAL_REGEX","pattern","flags","isLiteralType","String","REGEX","parseKeywordsAndVariables","isVariable","getPropertyName","BUILTIN_VARIABLE","VARIABLE","NaN","Infinity","LITERAL_UNDEFINED","parseMathConstant","PI","E","parseNumberConstant","Number","POSITIVE_INFINITY","parseMemberExpression","obj","computed","MEMBER","node","op","operator","child","argument","consequent","alternate","CONDITIONAL","elements","ARRAY","_evaluateConditional","_evaluateRegExpTest","_evaluateRegExpExec","_evaluateToString","_evaluateNot","_evaluateNegative","_evaluatePositive","_evaluateNaN","_evaluateIsFinite","_evaluateIsExactClass","_evaluateIsClass","_evaluateGetExactClassName","_evaluateBooleanConversion","_evaluateNumberConversion","_evaluateStringConversion","getEvaluateUnaryFunction","_evaluatePlus","_evaluateMinus","_evaluateTimes","_evaluateDivide","_evaluateMod","_evaluateEqualsStrict","_evaluateNotEqualsStrict","_evaluateLessThan","_evaluateLessThanOrEquals","_evaluateGreaterThan","_evaluateGreaterThanOrEquals","_evaluateAnd","_evaluateOr","_evaluateRegExpMatch","_evaluateRegExpNotMatch","getEvaluateBinaryFunction","getEvaluateTernaryFunction","_evaluateMemberBrackets","_evaluateMemberDot","_evaluateArray","_evaluateVariable","_evaluateVariableString","_evaluateLiteralColor","_evaluateLiteralVector","_evaluateLiteralString","_evaluateRegExp","evaluateTilesetTime","_evaluateLiteral","content","tileset","timeSinceLoad","getFeatureProperty","getPropertyInherited","fromBytes","fromCssColorString","a","fromHsl","fromColor","components","componentsLength","vectorLength","parseInt","charAt","component","fromArray","match","exec","placeholder","variableName","lastIndex","checkFeature","member","negate","add","subtract","multiplyComponents","multiplyByScalar","divideComponents","divideByScalar","equals","isNaN","isFinite","isExactClass","isClass","getExactClassName","Boolean","convertHSLToRGB","channels","h","s","l","convertRGBToColor","red","green","blue","numberToString","toFixed","toString","colorToVec3","r","g","b","colorToVec4","getExpressionArray","parent","expressions","getVariableName","NULL_SENTINEL","isArray","vectorExpression","rgb","translucent"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Expression.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport jsep from \"jsep\";\nimport ExpressionNodeType from \"./ExpressionNodeType.js\";\n\n/**\n * An expression for a style applied to a {@link Cesium3DTileset}.\n * <p>\n * Evaluates an expression defined using the\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}.\n * </p>\n * <p>\n * Implements the {@link StyleExpression} interface.\n * </p>\n *\n * @alias Expression\n * @constructor\n *\n * @param {string} [expression] The expression defined using the 3D Tiles Styling language.\n * @param {object} [defines] Defines in the style.\n *\n * @example\n * const expression = new Cesium.Expression('(regExp(\"^Chest\").test(${County})) && (${YearBuilt} >= 1970)');\n * expression.evaluate(feature); // returns true or false depending on the feature's properties\n *\n * @example\n * const expression = new Cesium.Expression('(${Temperature} > 90) ? color(\"red\") : color(\"white\")');\n * expression.evaluateColor(feature, result); // returns a Cesium.Color object\n */\nfunction Expression(expression, defines) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"expression\", expression);\n  //>>includeEnd('debug');\n\n  this._expression = expression;\n  expression = replaceDefines(expression, defines);\n  expression = replaceVariables(removeBackslashes(expression));\n\n  // customize jsep operators\n  jsep.addBinaryOp(\"=~\", 0);\n  jsep.addBinaryOp(\"!~\", 0);\n\n  let ast;\n  try {\n    ast = jsep(expression);\n  } catch (e) {\n    throw new RuntimeError(e);\n  }\n\n  this._runtimeAst = createRuntimeAst(this, ast);\n}\n\nObject.defineProperties(Expression.prototype, {\n  /**\n   * Gets the expression defined in the 3D Tiles Styling language.\n   *\n   * @memberof Expression.prototype\n   *\n   * @type {string}\n   * @readonly\n   *\n   * @default undefined\n   */\n  expression: {\n    get: function () {\n      return this._expression;\n    },\n  },\n});\n\n// Scratch storage manager while evaluating deep expressions.\n// For example, an expression like dot(vec4(${red}), vec4(${green}) * vec4(${blue}) requires 3 scratch Cartesian4's\nconst scratchStorage = {\n  arrayIndex: 0,\n  arrayArray: [[]],\n  cartesian2Index: 0,\n  cartesian3Index: 0,\n  cartesian4Index: 0,\n  cartesian2Array: [new Cartesian2()],\n  cartesian3Array: [new Cartesian3()],\n  cartesian4Array: [new Cartesian4()],\n  reset: function () {\n    this.arrayIndex = 0;\n    this.cartesian2Index = 0;\n    this.cartesian3Index = 0;\n    this.cartesian4Index = 0;\n  },\n  getArray: function () {\n    if (this.arrayIndex >= this.arrayArray.length) {\n      this.arrayArray.push([]);\n    }\n    const array = this.arrayArray[this.arrayIndex++];\n    array.length = 0;\n    return array;\n  },\n  getCartesian2: function () {\n    if (this.cartesian2Index >= this.cartesian2Array.length) {\n      this.cartesian2Array.push(new Cartesian2());\n    }\n    return this.cartesian2Array[this.cartesian2Index++];\n  },\n  getCartesian3: function () {\n    if (this.cartesian3Index >= this.cartesian3Array.length) {\n      this.cartesian3Array.push(new Cartesian3());\n    }\n    return this.cartesian3Array[this.cartesian3Index++];\n  },\n  getCartesian4: function () {\n    if (this.cartesian4Index >= this.cartesian4Array.length) {\n      this.cartesian4Array.push(new Cartesian4());\n    }\n    return this.cartesian4Array[this.cartesian4Index++];\n  },\n};\n\n/**\n * Evaluates the result of an expression, optionally using the provided feature's properties. If the result of\n * the expression in the\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}\n * is of type <code>Boolean</code>, <code>Number</code>, or <code>String</code>, the corresponding JavaScript\n * primitive type will be returned. If the result is a <code>RegExp</code>, a Javascript <code>RegExp</code>\n * object will be returned. If the result is a <code>Cartesian2</code>, <code>Cartesian3</code>, or <code>Cartesian4</code>,\n * a {@link Cartesian2}, {@link Cartesian3}, or {@link Cartesian4} object will be returned. If the <code>result</code> argument is\n * a {@link Color}, the {@link Cartesian4} value is converted to a {@link Color} and then returned.\n *\n * @param {Cesium3DTileFeature} feature The feature whose properties may be used as variables in the expression.\n * @param {object} [result] The object onto which to store the result.\n * @returns {boolean|number|string|RegExp|Cartesian2|Cartesian3|Cartesian4|Color} The result of evaluating the expression.\n */\nExpression.prototype.evaluate = function (feature, result) {\n  scratchStorage.reset();\n  const value = this._runtimeAst.evaluate(feature);\n  if (result instanceof Color && value instanceof Cartesian4) {\n    return Color.fromCartesian4(value, result);\n  }\n  if (\n    value instanceof Cartesian2 ||\n    value instanceof Cartesian3 ||\n    value instanceof Cartesian4\n  ) {\n    return value.clone(result);\n  }\n  return value;\n};\n\n/**\n * Evaluates the result of a Color expression, optionally using the provided feature's properties.\n * <p>\n * This is equivalent to {@link Expression#evaluate} but always returns a {@link Color} object.\n * </p>\n *\n * @param {Cesium3DTileFeature} feature The feature whose properties may be used as variables in the expression.\n * @param {Color} [result] The object in which to store the result\n * @returns {Color} The modified result parameter or a new Color instance if one was not provided.\n */\nExpression.prototype.evaluateColor = function (feature, result) {\n  scratchStorage.reset();\n  const color = this._runtimeAst.evaluate(feature);\n  return Color.fromCartesian4(color, result);\n};\n\n/**\n * Gets the shader function for this expression.\n * Returns undefined if the shader function can't be generated from this expression.\n *\n * @param {string} functionSignature Signature of the generated function.\n * @param {object} variableSubstitutionMap Maps variable names to shader variable names.\n * @param {object} shaderState Stores information about the generated shader function, including whether it is translucent.\n * @param {string} returnType The return type of the generated function.\n *\n * @returns {string} The shader function.\n *\n * @private\n */\nExpression.prototype.getShaderFunction = function (\n  functionSignature,\n  variableSubstitutionMap,\n  shaderState,\n  returnType,\n) {\n  let shaderExpression = this.getShaderExpression(\n    variableSubstitutionMap,\n    shaderState,\n  );\n\n  shaderExpression =\n    `${returnType} ${functionSignature}\\n` +\n    `{\\n` +\n    `    return ${shaderExpression};\\n` +\n    `}\\n`;\n\n  return shaderExpression;\n};\n\n/**\n * Gets the shader expression for this expression.\n * Returns undefined if the shader expression can't be generated from this expression.\n *\n * @param {object} variableSubstitutionMap Maps variable names to shader variable names.\n * @param {object} shaderState Stores information about the generated shader function, including whether it is translucent.\n *\n * @returns {string} The shader expression.\n *\n * @private\n */\nExpression.prototype.getShaderExpression = function (\n  variableSubstitutionMap,\n  shaderState,\n) {\n  return this._runtimeAst.getShaderExpression(\n    variableSubstitutionMap,\n    shaderState,\n  );\n};\n\n/**\n * Gets the variables used by the expression.\n *\n * @returns {string[]} The variables used by the expression.\n *\n * @private\n */\nExpression.prototype.getVariables = function () {\n  let variables = [];\n\n  this._runtimeAst.getVariables(variables);\n\n  // Remove duplicates\n  variables = variables.filter(function (variable, index, variables) {\n    return variables.indexOf(variable) === index;\n  });\n\n  return variables;\n};\n\nconst unaryOperators = [\"!\", \"-\", \"+\"];\nconst binaryOperators = [\n  \"+\",\n  \"-\",\n  \"*\",\n  \"/\",\n  \"%\",\n  \"===\",\n  \"!==\",\n  \">\",\n  \">=\",\n  \"<\",\n  \"<=\",\n  \"&&\",\n  \"||\",\n  \"!~\",\n  \"=~\",\n];\n\nconst variableRegex = /\\${(.*?)}/g; // Matches ${variable_name}\nconst backslashRegex = /\\\\/g;\nconst backslashReplacement = \"@#%\";\nconst replacementRegex = /@#%/g;\n\nconst scratchColor = new Color();\n\nconst unaryFunctions = {\n  abs: getEvaluateUnaryComponentwise(Math.abs),\n  sqrt: getEvaluateUnaryComponentwise(Math.sqrt),\n  cos: getEvaluateUnaryComponentwise(Math.cos),\n  sin: getEvaluateUnaryComponentwise(Math.sin),\n  tan: getEvaluateUnaryComponentwise(Math.tan),\n  acos: getEvaluateUnaryComponentwise(Math.acos),\n  asin: getEvaluateUnaryComponentwise(Math.asin),\n  atan: getEvaluateUnaryComponentwise(Math.atan),\n  radians: getEvaluateUnaryComponentwise(CesiumMath.toRadians),\n  degrees: getEvaluateUnaryComponentwise(CesiumMath.toDegrees),\n  sign: getEvaluateUnaryComponentwise(CesiumMath.sign),\n  floor: getEvaluateUnaryComponentwise(Math.floor),\n  ceil: getEvaluateUnaryComponentwise(Math.ceil),\n  round: getEvaluateUnaryComponentwise(Math.round),\n  exp: getEvaluateUnaryComponentwise(Math.exp),\n  exp2: getEvaluateUnaryComponentwise(exp2),\n  log: getEvaluateUnaryComponentwise(Math.log),\n  log2: getEvaluateUnaryComponentwise(log2),\n  fract: getEvaluateUnaryComponentwise(fract),\n  length: length,\n  normalize: normalize,\n};\n\nconst binaryFunctions = {\n  atan2: getEvaluateBinaryComponentwise(Math.atan2, false),\n  pow: getEvaluateBinaryComponentwise(Math.pow, false),\n  min: getEvaluateBinaryComponentwise(Math.min, true),\n  max: getEvaluateBinaryComponentwise(Math.max, true),\n  distance: distance,\n  dot: dot,\n  cross: cross,\n};\n\nconst ternaryFunctions = {\n  clamp: getEvaluateTernaryComponentwise(CesiumMath.clamp, true),\n  mix: getEvaluateTernaryComponentwise(CesiumMath.lerp, true),\n};\n\nfunction fract(number) {\n  return number - Math.floor(number);\n}\n\nfunction exp2(exponent) {\n  return Math.pow(2.0, exponent);\n}\n\nfunction log2(number) {\n  return CesiumMath.log2(number);\n}\n\nfunction getEvaluateUnaryComponentwise(operation) {\n  return function (call, left) {\n    if (typeof left === \"number\") {\n      return operation(left);\n    } else if (left instanceof Cartesian2) {\n      return Cartesian2.fromElements(\n        operation(left.x),\n        operation(left.y),\n        scratchStorage.getCartesian2(),\n      );\n    } else if (left instanceof Cartesian3) {\n      return Cartesian3.fromElements(\n        operation(left.x),\n        operation(left.y),\n        operation(left.z),\n        scratchStorage.getCartesian3(),\n      );\n    } else if (left instanceof Cartesian4) {\n      return Cartesian4.fromElements(\n        operation(left.x),\n        operation(left.y),\n        operation(left.z),\n        operation(left.w),\n        scratchStorage.getCartesian4(),\n      );\n    }\n    throw new RuntimeError(\n      `Function \"${call}\" requires a vector or number argument. Argument is ${left}.`,\n    );\n  };\n}\n\nfunction getEvaluateBinaryComponentwise(operation, allowScalar) {\n  return function (call, left, right) {\n    if (allowScalar && typeof right === \"number\") {\n      if (typeof left === \"number\") {\n        return operation(left, right);\n      } else if (left instanceof Cartesian2) {\n        return Cartesian2.fromElements(\n          operation(left.x, right),\n          operation(left.y, right),\n          scratchStorage.getCartesian2(),\n        );\n      } else if (left instanceof Cartesian3) {\n        return Cartesian3.fromElements(\n          operation(left.x, right),\n          operation(left.y, right),\n          operation(left.z, right),\n          scratchStorage.getCartesian3(),\n        );\n      } else if (left instanceof Cartesian4) {\n        return Cartesian4.fromElements(\n          operation(left.x, right),\n          operation(left.y, right),\n          operation(left.z, right),\n          operation(left.w, right),\n          scratchStorage.getCartesian4(),\n        );\n      }\n    }\n\n    if (typeof left === \"number\" && typeof right === \"number\") {\n      return operation(left, right);\n    } else if (left instanceof Cartesian2 && right instanceof Cartesian2) {\n      return Cartesian2.fromElements(\n        operation(left.x, right.x),\n        operation(left.y, right.y),\n        scratchStorage.getCartesian2(),\n      );\n    } else if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n      return Cartesian3.fromElements(\n        operation(left.x, right.x),\n        operation(left.y, right.y),\n        operation(left.z, right.z),\n        scratchStorage.getCartesian3(),\n      );\n    } else if (left instanceof Cartesian4 && right instanceof Cartesian4) {\n      return Cartesian4.fromElements(\n        operation(left.x, right.x),\n        operation(left.y, right.y),\n        operation(left.z, right.z),\n        operation(left.w, right.w),\n        scratchStorage.getCartesian4(),\n      );\n    }\n\n    throw new RuntimeError(\n      `Function \"${call}\" requires vector or number arguments of matching types. Arguments are ${left} and ${right}.`,\n    );\n  };\n}\n\nfunction getEvaluateTernaryComponentwise(operation, allowScalar) {\n  return function (call, left, right, test) {\n    if (allowScalar && typeof test === \"number\") {\n      if (typeof left === \"number\" && typeof right === \"number\") {\n        return operation(left, right, test);\n      } else if (left instanceof Cartesian2 && right instanceof Cartesian2) {\n        return Cartesian2.fromElements(\n          operation(left.x, right.x, test),\n          operation(left.y, right.y, test),\n          scratchStorage.getCartesian2(),\n        );\n      } else if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n        return Cartesian3.fromElements(\n          operation(left.x, right.x, test),\n          operation(left.y, right.y, test),\n          operation(left.z, right.z, test),\n          scratchStorage.getCartesian3(),\n        );\n      } else if (left instanceof Cartesian4 && right instanceof Cartesian4) {\n        return Cartesian4.fromElements(\n          operation(left.x, right.x, test),\n          operation(left.y, right.y, test),\n          operation(left.z, right.z, test),\n          operation(left.w, right.w, test),\n          scratchStorage.getCartesian4(),\n        );\n      }\n    }\n\n    if (\n      typeof left === \"number\" &&\n      typeof right === \"number\" &&\n      typeof test === \"number\"\n    ) {\n      return operation(left, right, test);\n    } else if (\n      left instanceof Cartesian2 &&\n      right instanceof Cartesian2 &&\n      test instanceof Cartesian2\n    ) {\n      return Cartesian2.fromElements(\n        operation(left.x, right.x, test.x),\n        operation(left.y, right.y, test.y),\n        scratchStorage.getCartesian2(),\n      );\n    } else if (\n      left instanceof Cartesian3 &&\n      right instanceof Cartesian3 &&\n      test instanceof Cartesian3\n    ) {\n      return Cartesian3.fromElements(\n        operation(left.x, right.x, test.x),\n        operation(left.y, right.y, test.y),\n        operation(left.z, right.z, test.z),\n        scratchStorage.getCartesian3(),\n      );\n    } else if (\n      left instanceof Cartesian4 &&\n      right instanceof Cartesian4 &&\n      test instanceof Cartesian4\n    ) {\n      return Cartesian4.fromElements(\n        operation(left.x, right.x, test.x),\n        operation(left.y, right.y, test.y),\n        operation(left.z, right.z, test.z),\n        operation(left.w, right.w, test.w),\n        scratchStorage.getCartesian4(),\n      );\n    }\n\n    throw new RuntimeError(\n      `Function \"${call}\" requires vector or number arguments of matching types. Arguments are ${left}, ${right}, and ${test}.`,\n    );\n  };\n}\n\nfunction length(call, left) {\n  if (typeof left === \"number\") {\n    return Math.abs(left);\n  } else if (left instanceof Cartesian2) {\n    return Cartesian2.magnitude(left);\n  } else if (left instanceof Cartesian3) {\n    return Cartesian3.magnitude(left);\n  } else if (left instanceof Cartesian4) {\n    return Cartesian4.magnitude(left);\n  }\n\n  throw new RuntimeError(\n    `Function \"${call}\" requires a vector or number argument. Argument is ${left}.`,\n  );\n}\n\nfunction normalize(call, left) {\n  if (typeof left === \"number\") {\n    return 1.0;\n  } else if (left instanceof Cartesian2) {\n    return Cartesian2.normalize(left, scratchStorage.getCartesian2());\n  } else if (left instanceof Cartesian3) {\n    return Cartesian3.normalize(left, scratchStorage.getCartesian3());\n  } else if (left instanceof Cartesian4) {\n    return Cartesian4.normalize(left, scratchStorage.getCartesian4());\n  }\n\n  throw new RuntimeError(\n    `Function \"${call}\" requires a vector or number argument. Argument is ${left}.`,\n  );\n}\n\nfunction distance(call, left, right) {\n  if (typeof left === \"number\" && typeof right === \"number\") {\n    return Math.abs(left - right);\n  } else if (left instanceof Cartesian2 && right instanceof Cartesian2) {\n    return Cartesian2.distance(left, right);\n  } else if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n    return Cartesian3.distance(left, right);\n  } else if (left instanceof Cartesian4 && right instanceof Cartesian4) {\n    return Cartesian4.distance(left, right);\n  }\n\n  throw new RuntimeError(\n    `Function \"${call}\" requires vector or number arguments of matching types. Arguments are ${left} and ${right}.`,\n  );\n}\n\nfunction dot(call, left, right) {\n  if (typeof left === \"number\" && typeof right === \"number\") {\n    return left * right;\n  } else if (left instanceof Cartesian2 && right instanceof Cartesian2) {\n    return Cartesian2.dot(left, right);\n  } else if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n    return Cartesian3.dot(left, right);\n  } else if (left instanceof Cartesian4 && right instanceof Cartesian4) {\n    return Cartesian4.dot(left, right);\n  }\n\n  throw new RuntimeError(\n    `Function \"${call}\" requires vector or number arguments of matching types. Arguments are ${left} and ${right}.`,\n  );\n}\n\nfunction cross(call, left, right) {\n  if (left instanceof Cartesian3 && right instanceof Cartesian3) {\n    return Cartesian3.cross(left, right, scratchStorage.getCartesian3());\n  }\n\n  throw new RuntimeError(\n    `Function \"${call}\" requires vec3 arguments. Arguments are ${left} and ${right}.`,\n  );\n}\n\nfunction Node(type, value, left, right, test) {\n  this._type = type;\n  this._value = value;\n  this._left = left;\n  this._right = right;\n  this._test = test;\n  this.evaluate = undefined;\n\n  setEvaluateFunction(this);\n}\n\nfunction replaceDefines(expression, defines) {\n  if (!defined(defines)) {\n    return expression;\n  }\n  for (const key in defines) {\n    if (defines.hasOwnProperty(key)) {\n      const definePlaceholder = new RegExp(`\\\\$\\\\{${key}\\\\}`, \"g\");\n      const defineReplace = `(${defines[key]})`;\n      if (defined(defineReplace)) {\n        expression = expression.replace(definePlaceholder, defineReplace);\n      }\n    }\n  }\n  return expression;\n}\n\nfunction removeBackslashes(expression) {\n  return expression.replace(backslashRegex, backslashReplacement);\n}\n\nfunction replaceBackslashes(expression) {\n  return expression.replace(replacementRegex, \"\\\\\");\n}\n\nfunction replaceVariables(expression) {\n  let exp = expression;\n  let result = \"\";\n  let i = exp.indexOf(\"${\");\n  while (i >= 0) {\n    // Check if string is inside quotes\n    const openSingleQuote = exp.indexOf(\"'\");\n    const openDoubleQuote = exp.indexOf('\"');\n    let closeQuote;\n    if (openSingleQuote >= 0 && openSingleQuote < i) {\n      closeQuote = exp.indexOf(\"'\", openSingleQuote + 1);\n      result += exp.substr(0, closeQuote + 1);\n      exp = exp.substr(closeQuote + 1);\n      i = exp.indexOf(\"${\");\n    } else if (openDoubleQuote >= 0 && openDoubleQuote < i) {\n      closeQuote = exp.indexOf('\"', openDoubleQuote + 1);\n      result += exp.substr(0, closeQuote + 1);\n      exp = exp.substr(closeQuote + 1);\n      i = exp.indexOf(\"${\");\n    } else {\n      result += exp.substr(0, i);\n      const j = exp.indexOf(\"}\");\n      if (j < 0) {\n        throw new RuntimeError(\"Unmatched {.\");\n      }\n      result += `czm_${exp.substr(i + 2, j - (i + 2))}`;\n      exp = exp.substr(j + 1);\n      i = exp.indexOf(\"${\");\n    }\n  }\n  result += exp;\n  return result;\n}\n\nfunction parseLiteral(ast) {\n  const type = typeof ast.value;\n  if (ast.value === null) {\n    return new Node(ExpressionNodeType.LITERAL_NULL, null);\n  } else if (type === \"boolean\") {\n    return new Node(ExpressionNodeType.LITERAL_BOOLEAN, ast.value);\n  } else if (type === \"number\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, ast.value);\n  } else if (type === \"string\") {\n    if (ast.value.indexOf(\"${\") >= 0) {\n      return new Node(ExpressionNodeType.VARIABLE_IN_STRING, ast.value);\n    }\n    return new Node(\n      ExpressionNodeType.LITERAL_STRING,\n      replaceBackslashes(ast.value),\n    );\n  }\n}\n\nfunction parseCall(expression, ast) {\n  const args = ast.arguments;\n  const argsLength = args.length;\n  let call;\n  let val, left, right;\n\n  // Member function calls\n  if (ast.callee.type === \"MemberExpression\") {\n    call = ast.callee.property.name;\n    const object = ast.callee.object;\n    if (call === \"test\" || call === \"exec\") {\n      // Make sure this is called on a valid type\n      if (!defined(object.callee) || object.callee.name !== \"regExp\") {\n        throw new RuntimeError(`${call} is not a function.`);\n      }\n      if (argsLength === 0) {\n        if (call === \"test\") {\n          return new Node(ExpressionNodeType.LITERAL_BOOLEAN, false);\n        }\n        return new Node(ExpressionNodeType.LITERAL_NULL, null);\n      }\n      left = createRuntimeAst(expression, object);\n      right = createRuntimeAst(expression, args[0]);\n      return new Node(ExpressionNodeType.FUNCTION_CALL, call, left, right);\n    } else if (call === \"toString\") {\n      val = createRuntimeAst(expression, object);\n      return new Node(ExpressionNodeType.FUNCTION_CALL, call, val);\n    }\n\n    throw new RuntimeError(`Unexpected function call \"${call}\".`);\n  }\n\n  // Non-member function calls\n  call = ast.callee.name;\n  if (call === \"color\") {\n    if (argsLength === 0) {\n      return new Node(ExpressionNodeType.LITERAL_COLOR, call);\n    }\n    val = createRuntimeAst(expression, args[0]);\n    if (defined(args[1])) {\n      const alpha = createRuntimeAst(expression, args[1]);\n      return new Node(ExpressionNodeType.LITERAL_COLOR, call, [val, alpha]);\n    }\n    return new Node(ExpressionNodeType.LITERAL_COLOR, call, [val]);\n  } else if (call === \"rgb\" || call === \"hsl\") {\n    if (argsLength < 3) {\n      throw new RuntimeError(`${call} requires three arguments.`);\n    }\n    val = [\n      createRuntimeAst(expression, args[0]),\n      createRuntimeAst(expression, args[1]),\n      createRuntimeAst(expression, args[2]),\n    ];\n    return new Node(ExpressionNodeType.LITERAL_COLOR, call, val);\n  } else if (call === \"rgba\" || call === \"hsla\") {\n    if (argsLength < 4) {\n      throw new RuntimeError(`${call} requires four arguments.`);\n    }\n    val = [\n      createRuntimeAst(expression, args[0]),\n      createRuntimeAst(expression, args[1]),\n      createRuntimeAst(expression, args[2]),\n      createRuntimeAst(expression, args[3]),\n    ];\n    return new Node(ExpressionNodeType.LITERAL_COLOR, call, val);\n  } else if (call === \"vec2\" || call === \"vec3\" || call === \"vec4\") {\n    // Check for invalid constructors at evaluation time\n    val = new Array(argsLength);\n    for (let i = 0; i < argsLength; ++i) {\n      val[i] = createRuntimeAst(expression, args[i]);\n    }\n    return new Node(ExpressionNodeType.LITERAL_VECTOR, call, val);\n  } else if (call === \"isNaN\" || call === \"isFinite\") {\n    if (argsLength === 0) {\n      if (call === \"isNaN\") {\n        return new Node(ExpressionNodeType.LITERAL_BOOLEAN, true);\n      }\n      return new Node(ExpressionNodeType.LITERAL_BOOLEAN, false);\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"isExactClass\" || call === \"isClass\") {\n    if (argsLength < 1 || argsLength > 1) {\n      throw new RuntimeError(`${call} requires exactly one argument.`);\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"getExactClassName\") {\n    if (argsLength > 0) {\n      throw new RuntimeError(`${call} does not take any argument.`);\n    }\n    return new Node(ExpressionNodeType.UNARY, call);\n  } else if (defined(unaryFunctions[call])) {\n    if (argsLength !== 1) {\n      throw new RuntimeError(`${call} requires exactly one argument.`);\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (defined(binaryFunctions[call])) {\n    if (argsLength !== 2) {\n      throw new RuntimeError(`${call} requires exactly two arguments.`);\n    }\n    left = createRuntimeAst(expression, args[0]);\n    right = createRuntimeAst(expression, args[1]);\n    return new Node(ExpressionNodeType.BINARY, call, left, right);\n  } else if (defined(ternaryFunctions[call])) {\n    if (argsLength !== 3) {\n      throw new RuntimeError(`${call} requires exactly three arguments.`);\n    }\n    left = createRuntimeAst(expression, args[0]);\n    right = createRuntimeAst(expression, args[1]);\n    const test = createRuntimeAst(expression, args[2]);\n    return new Node(ExpressionNodeType.TERNARY, call, left, right, test);\n  } else if (call === \"Boolean\") {\n    if (argsLength === 0) {\n      return new Node(ExpressionNodeType.LITERAL_BOOLEAN, false);\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"Number\") {\n    if (argsLength === 0) {\n      return new Node(ExpressionNodeType.LITERAL_NUMBER, 0);\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"String\") {\n    if (argsLength === 0) {\n      return new Node(ExpressionNodeType.LITERAL_STRING, \"\");\n    }\n    val = createRuntimeAst(expression, args[0]);\n    return new Node(ExpressionNodeType.UNARY, call, val);\n  } else if (call === \"regExp\") {\n    return parseRegex(expression, ast);\n  }\n\n  throw new RuntimeError(`Unexpected function call \"${call}\".`);\n}\n\nfunction parseRegex(expression, ast) {\n  const args = ast.arguments;\n  // no arguments, return default regex\n  if (args.length === 0) {\n    return new Node(ExpressionNodeType.LITERAL_REGEX, new RegExp());\n  }\n\n  const pattern = createRuntimeAst(expression, args[0]);\n  let exp;\n\n  // optional flag argument supplied\n  if (args.length > 1) {\n    const flags = createRuntimeAst(expression, args[1]);\n    if (isLiteralType(pattern) && isLiteralType(flags)) {\n      try {\n        exp = new RegExp(\n          replaceBackslashes(String(pattern._value)),\n          flags._value,\n        );\n      } catch (e) {\n        throw new RuntimeError(e);\n      }\n      return new Node(ExpressionNodeType.LITERAL_REGEX, exp);\n    }\n    return new Node(ExpressionNodeType.REGEX, pattern, flags);\n  }\n\n  // only pattern argument supplied\n  if (isLiteralType(pattern)) {\n    try {\n      exp = new RegExp(replaceBackslashes(String(pattern._value)));\n    } catch (e) {\n      throw new RuntimeError(e);\n    }\n    return new Node(ExpressionNodeType.LITERAL_REGEX, exp);\n  }\n  return new Node(ExpressionNodeType.REGEX, pattern);\n}\n\nfunction parseKeywordsAndVariables(ast) {\n  if (isVariable(ast.name)) {\n    const name = getPropertyName(ast.name);\n    if (name.substr(0, 8) === \"tiles3d_\") {\n      return new Node(ExpressionNodeType.BUILTIN_VARIABLE, name);\n    }\n    return new Node(ExpressionNodeType.VARIABLE, name);\n  } else if (ast.name === \"NaN\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, NaN);\n  } else if (ast.name === \"Infinity\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, Infinity);\n  } else if (ast.name === \"undefined\") {\n    return new Node(ExpressionNodeType.LITERAL_UNDEFINED, undefined);\n  }\n\n  throw new RuntimeError(`${ast.name} is not defined.`);\n}\n\nfunction parseMathConstant(ast) {\n  const name = ast.property.name;\n  if (name === \"PI\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, Math.PI);\n  } else if (name === \"E\") {\n    return new Node(ExpressionNodeType.LITERAL_NUMBER, Math.E);\n  }\n}\n\nfunction parseNumberConstant(ast) {\n  const name = ast.property.name;\n  if (name === \"POSITIVE_INFINITY\") {\n    return new Node(\n      ExpressionNodeType.LITERAL_NUMBER,\n      Number.POSITIVE_INFINITY,\n    );\n  }\n}\n\nfunction parseMemberExpression(expression, ast) {\n  if (ast.object.name === \"Math\") {\n    return parseMathConstant(ast);\n  } else if (ast.object.name === \"Number\") {\n    return parseNumberConstant(ast);\n  }\n\n  let val;\n  const obj = createRuntimeAst(expression, ast.object);\n  if (ast.computed) {\n    val = createRuntimeAst(expression, ast.property);\n    return new Node(ExpressionNodeType.MEMBER, \"brackets\", obj, val);\n  }\n\n  val = new Node(ExpressionNodeType.LITERAL_STRING, ast.property.name);\n  return new Node(ExpressionNodeType.MEMBER, \"dot\", obj, val);\n}\n\nfunction isLiteralType(node) {\n  return node._type >= ExpressionNodeType.LITERAL_NULL;\n}\n\nfunction isVariable(name) {\n  return name.substr(0, 4) === \"czm_\";\n}\n\nfunction getPropertyName(variable) {\n  return variable.substr(4);\n}\n\nfunction createRuntimeAst(expression, ast) {\n  let node;\n  let op;\n  let left;\n  let right;\n\n  if (ast.type === \"Literal\") {\n    node = parseLiteral(ast);\n  } else if (ast.type === \"CallExpression\") {\n    node = parseCall(expression, ast);\n  } else if (ast.type === \"Identifier\") {\n    node = parseKeywordsAndVariables(ast);\n  } else if (ast.type === \"UnaryExpression\") {\n    op = ast.operator;\n    const child = createRuntimeAst(expression, ast.argument);\n    if (unaryOperators.indexOf(op) > -1) {\n      node = new Node(ExpressionNodeType.UNARY, op, child);\n    } else {\n      throw new RuntimeError(`Unexpected operator \"${op}\".`);\n    }\n  } else if (ast.type === \"BinaryExpression\") {\n    op = ast.operator;\n    left = createRuntimeAst(expression, ast.left);\n    right = createRuntimeAst(expression, ast.right);\n    if (binaryOperators.indexOf(op) > -1) {\n      node = new Node(ExpressionNodeType.BINARY, op, left, right);\n    } else {\n      throw new RuntimeError(`Unexpected operator \"${op}\".`);\n    }\n  } else if (ast.type === \"LogicalExpression\") {\n    op = ast.operator;\n    left = createRuntimeAst(expression, ast.left);\n    right = createRuntimeAst(expression, ast.right);\n    if (binaryOperators.indexOf(op) > -1) {\n      node = new Node(ExpressionNodeType.BINARY, op, left, right);\n    }\n  } else if (ast.type === \"ConditionalExpression\") {\n    const test = createRuntimeAst(expression, ast.test);\n    left = createRuntimeAst(expression, ast.consequent);\n    right = createRuntimeAst(expression, ast.alternate);\n    node = new Node(ExpressionNodeType.CONDITIONAL, \"?\", left, right, test);\n  } else if (ast.type === \"MemberExpression\") {\n    node = parseMemberExpression(expression, ast);\n  } else if (ast.type === \"ArrayExpression\") {\n    const val = [];\n    for (let i = 0; i < ast.elements.length; i++) {\n      val[i] = createRuntimeAst(expression, ast.elements[i]);\n    }\n    node = new Node(ExpressionNodeType.ARRAY, val);\n  } else if (ast.type === \"Compound\") {\n    // empty expression or multiple expressions\n    throw new RuntimeError(\"Provide exactly one expression.\");\n  } else {\n    throw new RuntimeError(\"Cannot parse expression.\");\n  }\n\n  return node;\n}\n\nfunction setEvaluateFunction(node) {\n  if (node._type === ExpressionNodeType.CONDITIONAL) {\n    node.evaluate = node._evaluateConditional;\n  } else if (node._type === ExpressionNodeType.FUNCTION_CALL) {\n    if (node._value === \"test\") {\n      node.evaluate = node._evaluateRegExpTest;\n    } else if (node._value === \"exec\") {\n      node.evaluate = node._evaluateRegExpExec;\n    } else if (node._value === \"toString\") {\n      node.evaluate = node._evaluateToString;\n    }\n  } else if (node._type === ExpressionNodeType.UNARY) {\n    if (node._value === \"!\") {\n      node.evaluate = node._evaluateNot;\n    } else if (node._value === \"-\") {\n      node.evaluate = node._evaluateNegative;\n    } else if (node._value === \"+\") {\n      node.evaluate = node._evaluatePositive;\n    } else if (node._value === \"isNaN\") {\n      node.evaluate = node._evaluateNaN;\n    } else if (node._value === \"isFinite\") {\n      node.evaluate = node._evaluateIsFinite;\n    } else if (node._value === \"isExactClass\") {\n      node.evaluate = node._evaluateIsExactClass;\n    } else if (node._value === \"isClass\") {\n      node.evaluate = node._evaluateIsClass;\n    } else if (node._value === \"getExactClassName\") {\n      node.evaluate = node._evaluateGetExactClassName;\n    } else if (node._value === \"Boolean\") {\n      node.evaluate = node._evaluateBooleanConversion;\n    } else if (node._value === \"Number\") {\n      node.evaluate = node._evaluateNumberConversion;\n    } else if (node._value === \"String\") {\n      node.evaluate = node._evaluateStringConversion;\n    } else if (defined(unaryFunctions[node._value])) {\n      node.evaluate = getEvaluateUnaryFunction(node._value);\n    }\n  } else if (node._type === ExpressionNodeType.BINARY) {\n    if (node._value === \"+\") {\n      node.evaluate = node._evaluatePlus;\n    } else if (node._value === \"-\") {\n      node.evaluate = node._evaluateMinus;\n    } else if (node._value === \"*\") {\n      node.evaluate = node._evaluateTimes;\n    } else if (node._value === \"/\") {\n      node.evaluate = node._evaluateDivide;\n    } else if (node._value === \"%\") {\n      node.evaluate = node._evaluateMod;\n    } else if (node._value === \"===\") {\n      node.evaluate = node._evaluateEqualsStrict;\n    } else if (node._value === \"!==\") {\n      node.evaluate = node._evaluateNotEqualsStrict;\n    } else if (node._value === \"<\") {\n      node.evaluate = node._evaluateLessThan;\n    } else if (node._value === \"<=\") {\n      node.evaluate = node._evaluateLessThanOrEquals;\n    } else if (node._value === \">\") {\n      node.evaluate = node._evaluateGreaterThan;\n    } else if (node._value === \">=\") {\n      node.evaluate = node._evaluateGreaterThanOrEquals;\n    } else if (node._value === \"&&\") {\n      node.evaluate = node._evaluateAnd;\n    } else if (node._value === \"||\") {\n      node.evaluate = node._evaluateOr;\n    } else if (node._value === \"=~\") {\n      node.evaluate = node._evaluateRegExpMatch;\n    } else if (node._value === \"!~\") {\n      node.evaluate = node._evaluateRegExpNotMatch;\n    } else if (defined(binaryFunctions[node._value])) {\n      node.evaluate = getEvaluateBinaryFunction(node._value);\n    }\n  } else if (node._type === ExpressionNodeType.TERNARY) {\n    node.evaluate = getEvaluateTernaryFunction(node._value);\n  } else if (node._type === ExpressionNodeType.MEMBER) {\n    if (node._value === \"brackets\") {\n      node.evaluate = node._evaluateMemberBrackets;\n    } else {\n      node.evaluate = node._evaluateMemberDot;\n    }\n  } else if (node._type === ExpressionNodeType.ARRAY) {\n    node.evaluate = node._evaluateArray;\n  } else if (node._type === ExpressionNodeType.VARIABLE) {\n    node.evaluate = node._evaluateVariable;\n  } else if (node._type === ExpressionNodeType.VARIABLE_IN_STRING) {\n    node.evaluate = node._evaluateVariableString;\n  } else if (node._type === ExpressionNodeType.LITERAL_COLOR) {\n    node.evaluate = node._evaluateLiteralColor;\n  } else if (node._type === ExpressionNodeType.LITERAL_VECTOR) {\n    node.evaluate = node._evaluateLiteralVector;\n  } else if (node._type === ExpressionNodeType.LITERAL_STRING) {\n    node.evaluate = node._evaluateLiteralString;\n  } else if (node._type === ExpressionNodeType.REGEX) {\n    node.evaluate = node._evaluateRegExp;\n  } else if (node._type === ExpressionNodeType.BUILTIN_VARIABLE) {\n    if (node._value === \"tiles3d_tileset_time\") {\n      node.evaluate = evaluateTilesetTime;\n    }\n  } else {\n    node.evaluate = node._evaluateLiteral;\n  }\n}\n\nfunction evaluateTilesetTime(feature) {\n  if (!defined(feature)) {\n    return 0.0;\n  }\n  return feature.content.tileset.timeSinceLoad;\n}\n\nfunction getEvaluateUnaryFunction(call) {\n  const evaluate = unaryFunctions[call];\n  return function (feature) {\n    const left = this._left.evaluate(feature);\n    return evaluate(call, left);\n  };\n}\n\nfunction getEvaluateBinaryFunction(call) {\n  const evaluate = binaryFunctions[call];\n  return function (feature) {\n    const left = this._left.evaluate(feature);\n    const right = this._right.evaluate(feature);\n    return evaluate(call, left, right);\n  };\n}\n\nfunction getEvaluateTernaryFunction(call) {\n  const evaluate = ternaryFunctions[call];\n  return function (feature) {\n    const left = this._left.evaluate(feature);\n    const right = this._right.evaluate(feature);\n    const test = this._test.evaluate(feature);\n    return evaluate(call, left, right, test);\n  };\n}\n\nfunction getFeatureProperty(feature, name) {\n  // Returns undefined if the feature is not defined or the property name is not defined for that feature\n  if (defined(feature)) {\n    return feature.getPropertyInherited(name);\n  }\n}\n\nNode.prototype._evaluateLiteral = function () {\n  return this._value;\n};\n\nNode.prototype._evaluateLiteralColor = function (feature) {\n  const color = scratchColor;\n  const args = this._left;\n  if (this._value === \"color\") {\n    if (!defined(args)) {\n      Color.fromBytes(255, 255, 255, 255, color);\n    } else if (args.length > 1) {\n      Color.fromCssColorString(args[0].evaluate(feature), color);\n      color.alpha = args[1].evaluate(feature);\n    } else {\n      Color.fromCssColorString(args[0].evaluate(feature), color);\n    }\n  } else if (this._value === \"rgb\") {\n    Color.fromBytes(\n      args[0].evaluate(feature),\n      args[1].evaluate(feature),\n      args[2].evaluate(feature),\n      255,\n      color,\n    );\n  } else if (this._value === \"rgba\") {\n    // convert between css alpha (0 to 1) and cesium alpha (0 to 255)\n    const a = args[3].evaluate(feature) * 255;\n    Color.fromBytes(\n      args[0].evaluate(feature),\n      args[1].evaluate(feature),\n      args[2].evaluate(feature),\n      a,\n      color,\n    );\n  } else if (this._value === \"hsl\") {\n    Color.fromHsl(\n      args[0].evaluate(feature),\n      args[1].evaluate(feature),\n      args[2].evaluate(feature),\n      1.0,\n      color,\n    );\n  } else if (this._value === \"hsla\") {\n    Color.fromHsl(\n      args[0].evaluate(feature),\n      args[1].evaluate(feature),\n      args[2].evaluate(feature),\n      args[3].evaluate(feature),\n      color,\n    );\n  }\n  return Cartesian4.fromColor(color, scratchStorage.getCartesian4());\n};\n\nNode.prototype._evaluateLiteralVector = function (feature) {\n  // Gather the components that make up the vector, which includes components from interior vectors.\n  // For example vec3(1, 2, 3) or vec3(vec2(1, 2), 3) are both valid.\n  //\n  // If the number of components does not equal the vector's size, then a RuntimeError is thrown - with two exceptions:\n  // 1. A vector may be constructed from a larger vector and drop the extra components.\n  // 2. A vector may be constructed from a single component - vec3(1) will become vec3(1, 1, 1).\n  //\n  // Examples of invalid constructors include:\n  // vec4(1, 2)        // not enough components\n  // vec3(vec2(1, 2))  // not enough components\n  // vec3(1, 2, 3, 4)  // too many components\n  // vec2(vec4(1), 1)  // too many components\n\n  const components = scratchStorage.getArray();\n  const call = this._value;\n  const args = this._left;\n  const argsLength = args.length;\n  for (let i = 0; i < argsLength; ++i) {\n    const value = args[i].evaluate(feature);\n    if (typeof value === \"number\") {\n      components.push(value);\n    } else if (value instanceof Cartesian2) {\n      components.push(value.x, value.y);\n    } else if (value instanceof Cartesian3) {\n      components.push(value.x, value.y, value.z);\n    } else if (value instanceof Cartesian4) {\n      components.push(value.x, value.y, value.z, value.w);\n    } else {\n      throw new RuntimeError(\n        `${call} argument must be a vector or number. Argument is ${value}.`,\n      );\n    }\n  }\n\n  const componentsLength = components.length;\n  const vectorLength = parseInt(call.charAt(3));\n\n  if (componentsLength === 0) {\n    throw new RuntimeError(`Invalid ${call} constructor. No valid arguments.`);\n  } else if (componentsLength < vectorLength && componentsLength > 1) {\n    throw new RuntimeError(\n      `Invalid ${call} constructor. Not enough arguments.`,\n    );\n  } else if (componentsLength > vectorLength && argsLength > 1) {\n    throw new RuntimeError(`Invalid ${call} constructor. Too many arguments.`);\n  }\n\n  if (componentsLength === 1) {\n    // Add the same component 3 more times\n    const component = components[0];\n    components.push(component, component, component);\n  }\n\n  if (call === \"vec2\") {\n    return Cartesian2.fromArray(components, 0, scratchStorage.getCartesian2());\n  } else if (call === \"vec3\") {\n    return Cartesian3.fromArray(components, 0, scratchStorage.getCartesian3());\n  } else if (call === \"vec4\") {\n    return Cartesian4.fromArray(components, 0, scratchStorage.getCartesian4());\n  }\n};\n\nNode.prototype._evaluateLiteralString = function () {\n  return this._value;\n};\n\nNode.prototype._evaluateVariableString = function (feature) {\n  let result = this._value;\n  let match = variableRegex.exec(result);\n  while (match !== null) {\n    const placeholder = match[0];\n    const variableName = match[1];\n    let property = getFeatureProperty(feature, variableName);\n    if (!defined(property)) {\n      property = \"\";\n    }\n    result = result.replace(placeholder, property);\n    variableRegex.lastIndex += property.length - placeholder.length;\n    match = variableRegex.exec(result);\n  }\n  return result;\n};\n\nNode.prototype._evaluateVariable = function (feature) {\n  // evaluates to undefined if the property name is not defined for that feature\n  return getFeatureProperty(feature, this._value);\n};\n\nfunction checkFeature(ast) {\n  return ast._value === \"feature\";\n}\n\n// PERFORMANCE_IDEA: Determine if parent property needs to be computed before runtime\nNode.prototype._evaluateMemberDot = function (feature) {\n  if (checkFeature(this._left)) {\n    return getFeatureProperty(feature, this._right.evaluate(feature));\n  }\n  const property = this._left.evaluate(feature);\n  if (!defined(property)) {\n    return undefined;\n  }\n\n  const member = this._right.evaluate(feature);\n  if (\n    property instanceof Cartesian2 ||\n    property instanceof Cartesian3 ||\n    property instanceof Cartesian4\n  ) {\n    // Vector components may be accessed with .r, .g, .b, .a and implicitly with .x, .y, .z, .w\n    if (member === \"r\") {\n      return property.x;\n    } else if (member === \"g\") {\n      return property.y;\n    } else if (member === \"b\") {\n      return property.z;\n    } else if (member === \"a\") {\n      return property.w;\n    }\n  }\n  return property[member];\n};\n\nNode.prototype._evaluateMemberBrackets = function (feature) {\n  if (checkFeature(this._left)) {\n    return getFeatureProperty(feature, this._right.evaluate(feature));\n  }\n  const property = this._left.evaluate(feature);\n  if (!defined(property)) {\n    return undefined;\n  }\n\n  const member = this._right.evaluate(feature);\n  if (\n    property instanceof Cartesian2 ||\n    property instanceof Cartesian3 ||\n    property instanceof Cartesian4\n  ) {\n    // Vector components may be accessed with [0][1][2][3], ['r']['g']['b']['a'] and implicitly with ['x']['y']['z']['w']\n    // For Cartesian2 and Cartesian3 out-of-range components will just return undefined\n    if (member === 0 || member === \"r\") {\n      return property.x;\n    } else if (member === 1 || member === \"g\") {\n      return property.y;\n    } else if (member === 2 || member === \"b\") {\n      return property.z;\n    } else if (member === 3 || member === \"a\") {\n      return property.w;\n    }\n  }\n  return property[member];\n};\n\nNode.prototype._evaluateArray = function (feature) {\n  const array = [];\n  for (let i = 0; i < this._value.length; i++) {\n    array[i] = this._value[i].evaluate(feature);\n  }\n  return array;\n};\n\n// PERFORMANCE_IDEA: Have \"fast path\" functions that deal only with specific types\n// that we can assign if we know the types before runtime\n\nNode.prototype._evaluateNot = function (feature) {\n  const left = this._left.evaluate(feature);\n  if (typeof left !== \"boolean\") {\n    throw new RuntimeError(\n      `Operator \"!\" requires a boolean argument. Argument is ${left}.`,\n    );\n  }\n  return !left;\n};\n\nNode.prototype._evaluateNegative = function (feature) {\n  const left = this._left.evaluate(feature);\n  if (left instanceof Cartesian2) {\n    return Cartesian2.negate(left, scratchStorage.getCartesian2());\n  } else if (left instanceof Cartesian3) {\n    return Cartesian3.negate(left, scratchStorage.getCartesian3());\n  } else if (left instanceof Cartesian4) {\n    return Cartesian4.negate(left, scratchStorage.getCartesian4());\n  } else if (typeof left === \"number\") {\n    return -left;\n  }\n\n  throw new RuntimeError(\n    `Operator \"-\" requires a vector or number argument. Argument is ${left}.`,\n  );\n};\n\nNode.prototype._evaluatePositive = function (feature) {\n  const left = this._left.evaluate(feature);\n\n  if (\n    !(\n      left instanceof Cartesian2 ||\n      left instanceof Cartesian3 ||\n      left instanceof Cartesian4 ||\n      typeof left === \"number\"\n    )\n  ) {\n    throw new RuntimeError(\n      `Operator \"+\" requires a vector or number argument. Argument is ${left}.`,\n    );\n  }\n\n  return left;\n};\n\nNode.prototype._evaluateLessThan = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n\n  if (typeof left !== \"number\" || typeof right !== \"number\") {\n    throw new RuntimeError(\n      `Operator \"<\" requires number arguments. Arguments are ${left} and ${right}.`,\n    );\n  }\n\n  return left < right;\n};\n\nNode.prototype._evaluateLessThanOrEquals = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n\n  if (typeof left !== \"number\" || typeof right !== \"number\") {\n    throw new RuntimeError(\n      `Operator \"<=\" requires number arguments. Arguments are ${left} and ${right}.`,\n    );\n  }\n\n  return left <= right;\n};\n\nNode.prototype._evaluateGreaterThan = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n\n  if (typeof left !== \"number\" || typeof right !== \"number\") {\n    throw new RuntimeError(\n      `Operator \">\" requires number arguments. Arguments are ${left} and ${right}.`,\n    );\n  }\n\n  return left > right;\n};\n\nNode.prototype._evaluateGreaterThanOrEquals = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n\n  if (typeof left !== \"number\" || typeof right !== \"number\") {\n    throw new RuntimeError(\n      `Operator \">=\" requires number arguments. Arguments are ${left} and ${right}.`,\n    );\n  }\n\n  return left >= right;\n};\n\nNode.prototype._evaluateOr = function (feature) {\n  const left = this._left.evaluate(feature);\n  if (typeof left !== \"boolean\") {\n    throw new RuntimeError(\n      `Operator \"||\" requires boolean arguments. First argument is ${left}.`,\n    );\n  }\n\n  // short circuit the expression\n  if (left) {\n    return true;\n  }\n\n  const right = this._right.evaluate(feature);\n  if (typeof right !== \"boolean\") {\n    throw new RuntimeError(\n      `Operator \"||\" requires boolean arguments. Second argument is ${right}.`,\n    );\n  }\n\n  return left || right;\n};\n\nNode.prototype._evaluateAnd = function (feature) {\n  const left = this._left.evaluate(feature);\n  if (typeof left !== \"boolean\") {\n    throw new RuntimeError(\n      `Operator \"&&\" requires boolean arguments. First argument is ${left}.`,\n    );\n  }\n\n  // short circuit the expression\n  if (!left) {\n    return false;\n  }\n\n  const right = this._right.evaluate(feature);\n  if (typeof right !== \"boolean\") {\n    throw new RuntimeError(\n      `Operator \"&&\" requires boolean arguments. Second argument is ${right}.`,\n    );\n  }\n\n  return left && right;\n};\n\nNode.prototype._evaluatePlus = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.add(left, right, scratchStorage.getCartesian2());\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.add(left, right, scratchStorage.getCartesian3());\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.add(left, right, scratchStorage.getCartesian4());\n  } else if (typeof left === \"string\" || typeof right === \"string\") {\n    // If only one argument is a string the other argument calls its toString function.\n    return left + right;\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left + right;\n  }\n\n  throw new RuntimeError(\n    `Operator \"+\" requires vector or number arguments of matching types, or at least one string argument. Arguments are ${left} and ${right}.`,\n  );\n};\n\nNode.prototype._evaluateMinus = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.subtract(left, right, scratchStorage.getCartesian2());\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.subtract(left, right, scratchStorage.getCartesian3());\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.subtract(left, right, scratchStorage.getCartesian4());\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left - right;\n  }\n\n  throw new RuntimeError(\n    `Operator \"-\" requires vector or number arguments of matching types. Arguments are ${left} and ${right}.`,\n  );\n};\n\nNode.prototype._evaluateTimes = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.multiplyComponents(\n      left,\n      right,\n      scratchStorage.getCartesian2(),\n    );\n  } else if (right instanceof Cartesian2 && typeof left === \"number\") {\n    return Cartesian2.multiplyByScalar(\n      right,\n      left,\n      scratchStorage.getCartesian2(),\n    );\n  } else if (left instanceof Cartesian2 && typeof right === \"number\") {\n    return Cartesian2.multiplyByScalar(\n      left,\n      right,\n      scratchStorage.getCartesian2(),\n    );\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.multiplyComponents(\n      left,\n      right,\n      scratchStorage.getCartesian3(),\n    );\n  } else if (right instanceof Cartesian3 && typeof left === \"number\") {\n    return Cartesian3.multiplyByScalar(\n      right,\n      left,\n      scratchStorage.getCartesian3(),\n    );\n  } else if (left instanceof Cartesian3 && typeof right === \"number\") {\n    return Cartesian3.multiplyByScalar(\n      left,\n      right,\n      scratchStorage.getCartesian3(),\n    );\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.multiplyComponents(\n      left,\n      right,\n      scratchStorage.getCartesian4(),\n    );\n  } else if (right instanceof Cartesian4 && typeof left === \"number\") {\n    return Cartesian4.multiplyByScalar(\n      right,\n      left,\n      scratchStorage.getCartesian4(),\n    );\n  } else if (left instanceof Cartesian4 && typeof right === \"number\") {\n    return Cartesian4.multiplyByScalar(\n      left,\n      right,\n      scratchStorage.getCartesian4(),\n    );\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left * right;\n  }\n\n  throw new RuntimeError(\n    `Operator \"*\" requires vector or number arguments. If both arguments are vectors they must be matching types. Arguments are ${left} and ${right}.`,\n  );\n};\n\nNode.prototype._evaluateDivide = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.divideComponents(\n      left,\n      right,\n      scratchStorage.getCartesian2(),\n    );\n  } else if (left instanceof Cartesian2 && typeof right === \"number\") {\n    return Cartesian2.divideByScalar(\n      left,\n      right,\n      scratchStorage.getCartesian2(),\n    );\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.divideComponents(\n      left,\n      right,\n      scratchStorage.getCartesian3(),\n    );\n  } else if (left instanceof Cartesian3 && typeof right === \"number\") {\n    return Cartesian3.divideByScalar(\n      left,\n      right,\n      scratchStorage.getCartesian3(),\n    );\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.divideComponents(\n      left,\n      right,\n      scratchStorage.getCartesian4(),\n    );\n  } else if (left instanceof Cartesian4 && typeof right === \"number\") {\n    return Cartesian4.divideByScalar(\n      left,\n      right,\n      scratchStorage.getCartesian4(),\n    );\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left / right;\n  }\n\n  throw new RuntimeError(\n    `Operator \"/\" requires vector or number arguments of matching types, or a number as the second argument. Arguments are ${left} and ${right}.`,\n  );\n};\n\nNode.prototype._evaluateMod = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (right instanceof Cartesian2 && left instanceof Cartesian2) {\n    return Cartesian2.fromElements(\n      left.x % right.x,\n      left.y % right.y,\n      scratchStorage.getCartesian2(),\n    );\n  } else if (right instanceof Cartesian3 && left instanceof Cartesian3) {\n    return Cartesian3.fromElements(\n      left.x % right.x,\n      left.y % right.y,\n      left.z % right.z,\n      scratchStorage.getCartesian3(),\n    );\n  } else if (right instanceof Cartesian4 && left instanceof Cartesian4) {\n    return Cartesian4.fromElements(\n      left.x % right.x,\n      left.y % right.y,\n      left.z % right.z,\n      left.w % right.w,\n      scratchStorage.getCartesian4(),\n    );\n  } else if (typeof left === \"number\" && typeof right === \"number\") {\n    return left % right;\n  }\n\n  throw new RuntimeError(\n    `Operator \"%\" requires vector or number arguments of matching types. Arguments are ${left} and ${right}.`,\n  );\n};\n\nNode.prototype._evaluateEqualsStrict = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (\n    (right instanceof Cartesian2 && left instanceof Cartesian2) ||\n    (right instanceof Cartesian3 && left instanceof Cartesian3) ||\n    (right instanceof Cartesian4 && left instanceof Cartesian4)\n  ) {\n    return left.equals(right);\n  }\n  return left === right;\n};\n\nNode.prototype._evaluateNotEqualsStrict = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n  if (\n    (right instanceof Cartesian2 && left instanceof Cartesian2) ||\n    (right instanceof Cartesian3 && left instanceof Cartesian3) ||\n    (right instanceof Cartesian4 && left instanceof Cartesian4)\n  ) {\n    return !left.equals(right);\n  }\n  return left !== right;\n};\n\nNode.prototype._evaluateConditional = function (feature) {\n  const test = this._test.evaluate(feature);\n\n  if (typeof test !== \"boolean\") {\n    throw new RuntimeError(\n      `Conditional argument of conditional expression must be a boolean. Argument is ${test}.`,\n    );\n  }\n\n  if (test) {\n    return this._left.evaluate(feature);\n  }\n  return this._right.evaluate(feature);\n};\n\nNode.prototype._evaluateNaN = function (feature) {\n  return isNaN(this._left.evaluate(feature));\n};\n\nNode.prototype._evaluateIsFinite = function (feature) {\n  return isFinite(this._left.evaluate(feature));\n};\n\nNode.prototype._evaluateIsExactClass = function (feature) {\n  if (defined(feature)) {\n    return feature.isExactClass(this._left.evaluate(feature));\n  }\n  return false;\n};\n\nNode.prototype._evaluateIsClass = function (feature) {\n  if (defined(feature)) {\n    return feature.isClass(this._left.evaluate(feature));\n  }\n  return false;\n};\n\nNode.prototype._evaluateGetExactClassName = function (feature) {\n  if (defined(feature)) {\n    return feature.getExactClassName();\n  }\n};\n\nNode.prototype._evaluateBooleanConversion = function (feature) {\n  return Boolean(this._left.evaluate(feature));\n};\n\nNode.prototype._evaluateNumberConversion = function (feature) {\n  return Number(this._left.evaluate(feature));\n};\n\nNode.prototype._evaluateStringConversion = function (feature) {\n  return String(this._left.evaluate(feature));\n};\n\nNode.prototype._evaluateRegExp = function (feature) {\n  const pattern = this._value.evaluate(feature);\n  let flags = \"\";\n\n  if (defined(this._left)) {\n    flags = this._left.evaluate(feature);\n  }\n\n  let exp;\n  try {\n    exp = new RegExp(pattern, flags);\n  } catch (e) {\n    throw new RuntimeError(e);\n  }\n  return exp;\n};\n\nNode.prototype._evaluateRegExpTest = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n\n  if (!(left instanceof RegExp && typeof right === \"string\")) {\n    throw new RuntimeError(\n      `RegExp.test requires the first argument to be a RegExp and the second argument to be a string. Arguments are ${left} and ${right}.`,\n    );\n  }\n\n  return left.test(right);\n};\n\nNode.prototype._evaluateRegExpMatch = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n\n  if (left instanceof RegExp && typeof right === \"string\") {\n    return left.test(right);\n  } else if (right instanceof RegExp && typeof left === \"string\") {\n    return right.test(left);\n  }\n\n  throw new RuntimeError(\n    `Operator \"=~\" requires one RegExp argument and one string argument. Arguments are ${left} and ${right}.`,\n  );\n};\n\nNode.prototype._evaluateRegExpNotMatch = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n\n  if (left instanceof RegExp && typeof right === \"string\") {\n    return !left.test(right);\n  } else if (right instanceof RegExp && typeof left === \"string\") {\n    return !right.test(left);\n  }\n\n  throw new RuntimeError(\n    `Operator \"!~\" requires one RegExp argument and one string argument. Arguments are ${left} and ${right}.`,\n  );\n};\n\nNode.prototype._evaluateRegExpExec = function (feature) {\n  const left = this._left.evaluate(feature);\n  const right = this._right.evaluate(feature);\n\n  if (!(left instanceof RegExp && typeof right === \"string\")) {\n    throw new RuntimeError(\n      `RegExp.exec requires the first argument to be a RegExp and the second argument to be a string. Arguments are ${left} and ${right}.`,\n    );\n  }\n\n  const exec = left.exec(right);\n  if (!defined(exec)) {\n    return null;\n  }\n  return exec[1];\n};\n\nNode.prototype._evaluateToString = function (feature) {\n  const left = this._left.evaluate(feature);\n  if (\n    left instanceof RegExp ||\n    left instanceof Cartesian2 ||\n    left instanceof Cartesian3 ||\n    left instanceof Cartesian4\n  ) {\n    return String(left);\n  }\n\n  throw new RuntimeError(`Unexpected function call \"${this._value}\".`);\n};\n\nfunction convertHSLToRGB(ast) {\n  // Check if the color contains any nested expressions to see if the color can be converted here.\n  // E.g. \"hsl(0.9, 0.6, 0.7)\" is able to convert directly to rgb, \"hsl(0.9, 0.6, ${Height})\" is not.\n  const channels = ast._left;\n  const length = channels.length;\n  for (let i = 0; i < length; ++i) {\n    if (channels[i]._type !== ExpressionNodeType.LITERAL_NUMBER) {\n      return undefined;\n    }\n  }\n  const h = channels[0]._value;\n  const s = channels[1]._value;\n  const l = channels[2]._value;\n  const a = length === 4 ? channels[3]._value : 1.0;\n  return Color.fromHsl(h, s, l, a, scratchColor);\n}\n\nfunction convertRGBToColor(ast) {\n  // Check if the color contains any nested expressions to see if the color can be converted here.\n  // E.g. \"rgb(255, 255, 255)\" is able to convert directly to Color, \"rgb(255, 255, ${Height})\" is not.\n  const channels = ast._left;\n  const length = channels.length;\n  for (let i = 0; i < length; ++i) {\n    if (channels[i]._type !== ExpressionNodeType.LITERAL_NUMBER) {\n      return undefined;\n    }\n  }\n  const color = scratchColor;\n  color.red = channels[0]._value / 255.0;\n  color.green = channels[1]._value / 255.0;\n  color.blue = channels[2]._value / 255.0;\n  color.alpha = length === 4 ? channels[3]._value : 1.0;\n  return color;\n}\n\nfunction numberToString(number) {\n  if (number % 1 === 0) {\n    // Add a .0 to whole numbers\n    return number.toFixed(1);\n  }\n\n  return number.toString();\n}\n\nfunction colorToVec3(color) {\n  const r = numberToString(color.red);\n  const g = numberToString(color.green);\n  const b = numberToString(color.blue);\n  return `vec3(${r}, ${g}, ${b})`;\n}\n\nfunction colorToVec4(color) {\n  const r = numberToString(color.red);\n  const g = numberToString(color.green);\n  const b = numberToString(color.blue);\n  const a = numberToString(color.alpha);\n  return `vec4(${r}, ${g}, ${b}, ${a})`;\n}\n\nfunction getExpressionArray(\n  array,\n  variableSubstitutionMap,\n  shaderState,\n  parent,\n) {\n  const length = array.length;\n  const expressions = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    expressions[i] = array[i].getShaderExpression(\n      variableSubstitutionMap,\n      shaderState,\n      parent,\n    );\n  }\n  return expressions;\n}\n\nfunction getVariableName(variableName, variableSubstitutionMap) {\n  if (!defined(variableSubstitutionMap[variableName])) {\n    return Expression.NULL_SENTINEL;\n  }\n\n  return variableSubstitutionMap[variableName];\n}\n\n/**\n * @private\n */\nExpression.NULL_SENTINEL = \"czm_infinity\"; // null just needs to be some sentinel value that will cause \"[expression] === null\" to be false in nearly all cases. GLSL doesn't have a NaN constant so use czm_infinity.\n\nNode.prototype.getShaderExpression = function (\n  variableSubstitutionMap,\n  shaderState,\n  parent,\n) {\n  let color;\n  let left;\n  let right;\n  let test;\n\n  const type = this._type;\n  let value = this._value;\n\n  if (defined(this._left)) {\n    if (Array.isArray(this._left)) {\n      // Left can be an array if the type is LITERAL_COLOR or LITERAL_VECTOR\n      left = getExpressionArray(\n        this._left,\n        variableSubstitutionMap,\n        shaderState,\n        this,\n      );\n    } else {\n      left = this._left.getShaderExpression(\n        variableSubstitutionMap,\n        shaderState,\n        this,\n      );\n    }\n  }\n\n  if (defined(this._right)) {\n    right = this._right.getShaderExpression(\n      variableSubstitutionMap,\n      shaderState,\n      this,\n    );\n  }\n\n  if (defined(this._test)) {\n    test = this._test.getShaderExpression(\n      variableSubstitutionMap,\n      shaderState,\n      this,\n    );\n  }\n\n  if (Array.isArray(this._value)) {\n    // For ARRAY type\n    value = getExpressionArray(\n      this._value,\n      variableSubstitutionMap,\n      shaderState,\n      this,\n    );\n  }\n\n  let args;\n  let length;\n  let vectorExpression;\n  switch (type) {\n    case ExpressionNodeType.VARIABLE:\n      if (checkFeature(this)) {\n        return undefined;\n      }\n      return getVariableName(value, variableSubstitutionMap);\n    case ExpressionNodeType.UNARY:\n      // Supported types: +, -, !, Boolean, Number\n      if (value === \"Boolean\") {\n        return `bool(${left})`;\n      } else if (value === \"Number\") {\n        return `float(${left})`;\n      } else if (value === \"round\") {\n        return `floor(${left} + 0.5)`;\n      } else if (defined(unaryFunctions[value])) {\n        return `${value}(${left})`;\n      } else if (value === \"isNaN\") {\n        // In GLSL 2.0 use isnan instead\n        return `(${left} != ${left})`;\n      } else if (value === \"isFinite\") {\n        // In GLSL 2.0 use isinf instead. GLSL doesn't have an infinity constant so use czm_infinity which is an arbitrarily big enough number.\n        return `(abs(${left}) < czm_infinity)`;\n      } else if (\n        value === \"String\" ||\n        value === \"isExactClass\" ||\n        value === \"isClass\" ||\n        value === \"getExactClassName\"\n      ) {\n        throw new RuntimeError(\n          `Error generating style shader: \"${value}\" is not supported.`,\n        );\n      }\n      return value + left;\n    case ExpressionNodeType.BINARY:\n      // Supported types: ||, &&, ===, !==, <, >, <=, >=, +, -, *, /, %\n      if (value === \"%\") {\n        return `mod(${left}, ${right})`;\n      } else if (value === \"===\") {\n        return `(${left} == ${right})`;\n      } else if (value === \"!==\") {\n        return `(${left} != ${right})`;\n      } else if (value === \"atan2\") {\n        return `atan(${left}, ${right})`;\n      } else if (defined(binaryFunctions[value])) {\n        return `${value}(${left}, ${right})`;\n      }\n      return `(${left} ${value} ${right})`;\n    case ExpressionNodeType.TERNARY:\n      if (defined(ternaryFunctions[value])) {\n        return `${value}(${left}, ${right}, ${test})`;\n      }\n      break;\n    case ExpressionNodeType.CONDITIONAL:\n      return `(${test} ? ${left} : ${right})`;\n    case ExpressionNodeType.MEMBER:\n      if (checkFeature(this._left)) {\n        return getVariableName(right, variableSubstitutionMap);\n      }\n      // This is intended for accessing the components of vector properties. String members aren't supported.\n      // Check for 0.0 rather than 0 because all numbers are previously converted to decimals.\n      if (right === \"r\" || right === \"x\" || right === \"0.0\") {\n        return `${left}[0]`;\n      } else if (right === \"g\" || right === \"y\" || right === \"1.0\") {\n        return `${left}[1]`;\n      } else if (right === \"b\" || right === \"z\" || right === \"2.0\") {\n        return `${left}[2]`;\n      } else if (right === \"a\" || right === \"w\" || right === \"3.0\") {\n        return `${left}[3]`;\n      }\n      return `${left}[int(${right})]`;\n    case ExpressionNodeType.FUNCTION_CALL:\n      throw new RuntimeError(\n        `Error generating style shader: \"${value}\" is not supported.`,\n      );\n    case ExpressionNodeType.ARRAY:\n      if (value.length === 4) {\n        return `vec4(${value[0]}, ${value[1]}, ${value[2]}, ${value[3]})`;\n      } else if (value.length === 3) {\n        return `vec3(${value[0]}, ${value[1]}, ${value[2]})`;\n      } else if (value.length === 2) {\n        return `vec2(${value[0]}, ${value[1]})`;\n      }\n      throw new RuntimeError(\n        \"Error generating style shader: Invalid array length. Array length should be 2, 3, or 4.\",\n      );\n    case ExpressionNodeType.REGEX:\n      throw new RuntimeError(\n        \"Error generating style shader: Regular expressions are not supported.\",\n      );\n    case ExpressionNodeType.VARIABLE_IN_STRING:\n      throw new RuntimeError(\n        \"Error generating style shader: Converting a variable to a string is not supported.\",\n      );\n    case ExpressionNodeType.LITERAL_NULL:\n      return Expression.NULL_SENTINEL;\n    case ExpressionNodeType.LITERAL_BOOLEAN:\n      return value ? \"true\" : \"false\";\n    case ExpressionNodeType.LITERAL_NUMBER:\n      return numberToString(value);\n    case ExpressionNodeType.LITERAL_STRING:\n      if (defined(parent) && parent._type === ExpressionNodeType.MEMBER) {\n        if (\n          value === \"r\" ||\n          value === \"g\" ||\n          value === \"b\" ||\n          value === \"a\" ||\n          value === \"x\" ||\n          value === \"y\" ||\n          value === \"z\" ||\n          value === \"w\" ||\n          checkFeature(parent._left)\n        ) {\n          return value;\n        }\n      }\n      // Check for css color strings\n      color = Color.fromCssColorString(value, scratchColor);\n      if (defined(color)) {\n        return colorToVec3(color);\n      }\n      throw new RuntimeError(\n        \"Error generating style shader: String literals are not supported.\",\n      );\n    case ExpressionNodeType.LITERAL_COLOR:\n      args = left;\n      if (value === \"color\") {\n        if (!defined(args)) {\n          return \"vec4(1.0)\";\n        } else if (args.length > 1) {\n          const rgb = args[0];\n          const alpha = args[1];\n          if (alpha !== \"1.0\") {\n            shaderState.translucent = true;\n          }\n          return `vec4(${rgb}, ${alpha})`;\n        }\n        return `vec4(${args[0]}, 1.0)`;\n      } else if (value === \"rgb\") {\n        color = convertRGBToColor(this);\n        if (defined(color)) {\n          return colorToVec4(color);\n        }\n        return `vec4(${args[0]} / 255.0, ${args[1]} / 255.0, ${args[2]} / 255.0, 1.0)`;\n      } else if (value === \"rgba\") {\n        if (args[3] !== \"1.0\") {\n          shaderState.translucent = true;\n        }\n        color = convertRGBToColor(this);\n        if (defined(color)) {\n          return colorToVec4(color);\n        }\n        return `vec4(${args[0]} / 255.0, ${args[1]} / 255.0, ${args[2]} / 255.0, ${args[3]})`;\n      } else if (value === \"hsl\") {\n        color = convertHSLToRGB(this);\n        if (defined(color)) {\n          return colorToVec4(color);\n        }\n        return `vec4(czm_HSLToRGB(vec3(${args[0]}, ${args[1]}, ${args[2]})), 1.0)`;\n      } else if (value === \"hsla\") {\n        color = convertHSLToRGB(this);\n        if (defined(color)) {\n          if (color.alpha !== 1.0) {\n            shaderState.translucent = true;\n          }\n          return colorToVec4(color);\n        }\n        if (args[3] !== \"1.0\") {\n          shaderState.translucent = true;\n        }\n        return `vec4(czm_HSLToRGB(vec3(${args[0]}, ${args[1]}, ${args[2]})), ${args[3]})`;\n      }\n      break;\n    case ExpressionNodeType.LITERAL_VECTOR:\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(left)) {\n        throw new DeveloperError(\n          \"left should always be defined for type ExpressionNodeType.LITERAL_VECTOR\",\n        );\n      }\n      //>>includeEnd('debug');\n      length = left.length;\n      vectorExpression = `${value}(`;\n      for (let i = 0; i < length; ++i) {\n        vectorExpression += left[i];\n        if (i < length - 1) {\n          vectorExpression += \", \";\n        }\n      }\n      vectorExpression += \")\";\n      return vectorExpression;\n    case ExpressionNodeType.LITERAL_REGEX:\n      throw new RuntimeError(\n        \"Error generating style shader: Regular expressions are not supported.\",\n      );\n    case ExpressionNodeType.LITERAL_UNDEFINED:\n      return Expression.NULL_SENTINEL;\n    case ExpressionNodeType.BUILTIN_VARIABLE:\n      if (value === \"tiles3d_tileset_time\") {\n        return value;\n      }\n  }\n};\n\nNode.prototype.getVariables = function (variables, parent) {\n  let array;\n  let length;\n  let i;\n\n  const type = this._type;\n  const value = this._value;\n\n  if (defined(this._left)) {\n    if (Array.isArray(this._left)) {\n      // Left can be an array if the type is LITERAL_COLOR or LITERAL_VECTOR\n      array = this._left;\n      length = array.length;\n      for (i = 0; i < length; ++i) {\n        array[i].getVariables(variables, this);\n      }\n    } else {\n      this._left.getVariables(variables, this);\n    }\n  }\n\n  if (defined(this._right)) {\n    this._right.getVariables(variables, this);\n  }\n\n  if (defined(this._test)) {\n    this._test.getVariables(variables, this);\n  }\n\n  if (Array.isArray(this._value)) {\n    // For ARRAY type\n    array = this._value;\n    length = array.length;\n    for (i = 0; i < length; ++i) {\n      array[i].getVariables(variables, this);\n    }\n  }\n\n  let match;\n  switch (type) {\n    case ExpressionNodeType.VARIABLE:\n      if (!checkFeature(this)) {\n        variables.push(value);\n      }\n      break;\n    case ExpressionNodeType.VARIABLE_IN_STRING:\n      match = variableRegex.exec(value);\n      while (match !== null) {\n        variables.push(match[1]);\n        match = variableRegex.exec(value);\n      }\n      break;\n    case ExpressionNodeType.LITERAL_STRING:\n      if (\n        defined(parent) &&\n        parent._type === ExpressionNodeType.MEMBER &&\n        checkFeature(parent._left)\n      ) {\n        variables.push(value);\n      }\n      break;\n  }\n};\n\nexport default Expression;\n"],"mappings":";;;AAAA,OAAOA,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,IAAI,MAAM,MAAM;AACvB,OAAOC,kBAAkB,MAAM,yBAAyB;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,UAAUA,CAACC,UAAU,EAAEC,OAAO,EAAE;EACvC;EACAV,KAAK,CAACW,MAAM,CAACC,MAAM,CAAC,YAAY,EAAEH,UAAU,CAAC;EAC7C;;EAEA,IAAI,CAACI,WAAW,GAAGJ,UAAU;EAC7BA,UAAU,GAAGK,cAAc,CAACL,UAAU,EAAEC,OAAO,CAAC;EAChDD,UAAU,GAAGM,gBAAgB,CAACC,iBAAiB,CAACP,UAAU,CAAC,CAAC;;EAE5D;EACAH,IAAI,CAACW,WAAW,CAAC,IAAI,EAAE,CAAC,CAAC;EACzBX,IAAI,CAACW,WAAW,CAAC,IAAI,EAAE,CAAC,CAAC;EAEzB,IAAIC,GAAG;EACP,IAAI;IACFA,GAAG,GAAGZ,IAAI,CAACG,UAAU,CAAC;EACxB,CAAC,CAAC,OAAOU,CAAC,EAAE;IACV,MAAM,IAAId,YAAY,CAACc,CAAC,CAAC;EAC3B;EAEA,IAAI,CAACC,WAAW,GAAGC,gBAAgB,CAAC,IAAI,EAAEH,GAAG,CAAC;AAChD;AAEAI,MAAM,CAACC,gBAAgB,CAACf,UAAU,CAACgB,SAAS,EAAE;EAC5C;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEf,UAAU,EAAE;IACVgB,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACZ,WAAW;IACzB;EACF;AACF,CAAC,CAAC;;AAEF;AACA;AACA,MAAMa,cAAc,GAAG;EACrBC,UAAU,EAAE,CAAC;EACbC,UAAU,EAAE,CAAC,EAAE,CAAC;EAChBC,eAAe,EAAE,CAAC;EAClBC,eAAe,EAAE,CAAC;EAClBC,eAAe,EAAE,CAAC;EAClBC,eAAe,EAAE,CAAC,IAAInC,UAAU,CAAC,CAAC,CAAC;EACnCoC,eAAe,EAAE,CAAC,IAAInC,UAAU,CAAC,CAAC,CAAC;EACnCoC,eAAe,EAAE,CAAC,IAAInC,UAAU,CAAC,CAAC,CAAC;EACnCoC,KAAK,EAAE,SAAAA,CAAA,EAAY;IACjB,IAAI,CAACR,UAAU,GAAG,CAAC;IACnB,IAAI,CAACE,eAAe,GAAG,CAAC;IACxB,IAAI,CAACC,eAAe,GAAG,CAAC;IACxB,IAAI,CAACC,eAAe,GAAG,CAAC;EAC1B,CAAC;EACDK,QAAQ,EAAE,SAAAA,CAAA,EAAY;IACpB,IAAI,IAAI,CAACT,UAAU,IAAI,IAAI,CAACC,UAAU,CAACS,MAAM,EAAE;MAC7C,IAAI,CAACT,UAAU,CAACU,IAAI,CAAC,EAAE,CAAC;IAC1B;IACA,MAAMC,KAAK,GAAG,IAAI,CAACX,UAAU,CAAC,IAAI,CAACD,UAAU,EAAE,CAAC;IAChDY,KAAK,CAACF,MAAM,GAAG,CAAC;IAChB,OAAOE,KAAK;EACd,CAAC;EACDC,aAAa,EAAE,SAAAA,CAAA,EAAY;IACzB,IAAI,IAAI,CAACX,eAAe,IAAI,IAAI,CAACG,eAAe,CAACK,MAAM,EAAE;MACvD,IAAI,CAACL,eAAe,CAACM,IAAI,CAAC,IAAIzC,UAAU,CAAC,CAAC,CAAC;IAC7C;IACA,OAAO,IAAI,CAACmC,eAAe,CAAC,IAAI,CAACH,eAAe,EAAE,CAAC;EACrD,CAAC;EACDY,aAAa,EAAE,SAAAA,CAAA,EAAY;IACzB,IAAI,IAAI,CAACX,eAAe,IAAI,IAAI,CAACG,eAAe,CAACI,MAAM,EAAE;MACvD,IAAI,CAACJ,eAAe,CAACK,IAAI,CAAC,IAAIxC,UAAU,CAAC,CAAC,CAAC;IAC7C;IACA,OAAO,IAAI,CAACmC,eAAe,CAAC,IAAI,CAACH,eAAe,EAAE,CAAC;EACrD,CAAC;EACDY,aAAa,EAAE,SAAAA,CAAA,EAAY;IACzB,IAAI,IAAI,CAACX,eAAe,IAAI,IAAI,CAACG,eAAe,CAACG,MAAM,EAAE;MACvD,IAAI,CAACH,eAAe,CAACI,IAAI,CAAC,IAAIvC,UAAU,CAAC,CAAC,CAAC;IAC7C;IACA,OAAO,IAAI,CAACmC,eAAe,CAAC,IAAI,CAACH,eAAe,EAAE,CAAC;EACrD;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAvB,UAAU,CAACgB,SAAS,CAACmB,QAAQ,GAAG,UAAUC,OAAO,EAAEC,MAAM,EAAE;EACzDnB,cAAc,CAACS,KAAK,CAAC,CAAC;EACtB,MAAMW,KAAK,GAAG,IAAI,CAAC1B,WAAW,CAACuB,QAAQ,CAACC,OAAO,CAAC;EAChD,IAAIC,MAAM,YAAY5C,KAAK,IAAI6C,KAAK,YAAY/C,UAAU,EAAE;IAC1D,OAAOE,KAAK,CAAC8C,cAAc,CAACD,KAAK,EAAED,MAAM,CAAC;EAC5C;EACA,IACEC,KAAK,YAAYjD,UAAU,IAC3BiD,KAAK,YAAYhD,UAAU,IAC3BgD,KAAK,YAAY/C,UAAU,EAC3B;IACA,OAAO+C,KAAK,CAACE,KAAK,CAACH,MAAM,CAAC;EAC5B;EACA,OAAOC,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAtC,UAAU,CAACgB,SAAS,CAACyB,aAAa,GAAG,UAAUL,OAAO,EAAEC,MAAM,EAAE;EAC9DnB,cAAc,CAACS,KAAK,CAAC,CAAC;EACtB,MAAMe,KAAK,GAAG,IAAI,CAAC9B,WAAW,CAACuB,QAAQ,CAACC,OAAO,CAAC;EAChD,OAAO3C,KAAK,CAAC8C,cAAc,CAACG,KAAK,EAAEL,MAAM,CAAC;AAC5C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACArC,UAAU,CAACgB,SAAS,CAAC2B,iBAAiB,GAAG,UACvCC,iBAAiB,EACjBC,uBAAuB,EACvBC,WAAW,EACXC,UAAU,EACV;EACA,IAAIC,gBAAgB,GAAG,IAAI,CAACC,mBAAmB,CAC7CJ,uBAAuB,EACvBC,WACF,CAAC;EAEDE,gBAAgB,GACd,GAAGD,UAAU,IAAIH,iBAAiB,IAAI,GACtC,KAAK,GACL,cAAcI,gBAAgB,KAAK,GACnC,KAAK;EAEP,OAAOA,gBAAgB;AACzB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAhD,UAAU,CAACgB,SAAS,CAACiC,mBAAmB,GAAG,UACzCJ,uBAAuB,EACvBC,WAAW,EACX;EACA,OAAO,IAAI,CAAClC,WAAW,CAACqC,mBAAmB,CACzCJ,uBAAuB,EACvBC,WACF,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA9C,UAAU,CAACgB,SAAS,CAACkC,YAAY,GAAG,YAAY;EAC9C,IAAIC,SAAS,GAAG,EAAE;EAElB,IAAI,CAACvC,WAAW,CAACsC,YAAY,CAACC,SAAS,CAAC;;EAExC;EACAA,SAAS,GAAGA,SAAS,CAACC,MAAM,CAAC,UAAUC,QAAQ,EAAEC,KAAK,EAAEH,SAAS,EAAE;IACjE,OAAOA,SAAS,CAACI,OAAO,CAACF,QAAQ,CAAC,KAAKC,KAAK;EAC9C,CAAC,CAAC;EAEF,OAAOH,SAAS;AAClB,CAAC;AAED,MAAMK,cAAc,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AACtC,MAAMC,eAAe,GAAG,CACtB,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,KAAK,EACL,KAAK,EACL,GAAG,EACH,IAAI,EACJ,GAAG,EACH,IAAI,EACJ,IAAI,EACJ,IAAI,EACJ,IAAI,EACJ,IAAI,CACL;AAED,MAAMC,aAAa,GAAG,YAAY,CAAC,CAAC;AACpC,MAAMC,cAAc,GAAG,KAAK;AAC5B,MAAMC,oBAAoB,GAAG,KAAK;AAClC,MAAMC,gBAAgB,GAAG,MAAM;AAE/B,MAAMC,YAAY,GAAG,IAAIrE,KAAK,CAAC,CAAC;AAEhC,MAAMsE,cAAc,GAAG;EACrBC,GAAG,EAAEC,6BAA6B,CAACC,IAAI,CAACF,GAAG,CAAC;EAC5CG,IAAI,EAAEF,6BAA6B,CAACC,IAAI,CAACC,IAAI,CAAC;EAC9CC,GAAG,EAAEH,6BAA6B,CAACC,IAAI,CAACE,GAAG,CAAC;EAC5CC,GAAG,EAAEJ,6BAA6B,CAACC,IAAI,CAACG,GAAG,CAAC;EAC5CC,GAAG,EAAEL,6BAA6B,CAACC,IAAI,CAACI,GAAG,CAAC;EAC5CC,IAAI,EAAEN,6BAA6B,CAACC,IAAI,CAACK,IAAI,CAAC;EAC9CC,IAAI,EAAEP,6BAA6B,CAACC,IAAI,CAACM,IAAI,CAAC;EAC9CC,IAAI,EAAER,6BAA6B,CAACC,IAAI,CAACO,IAAI,CAAC;EAC9CC,OAAO,EAAET,6BAA6B,CAACrE,UAAU,CAAC+E,SAAS,CAAC;EAC5DC,OAAO,EAAEX,6BAA6B,CAACrE,UAAU,CAACiF,SAAS,CAAC;EAC5DC,IAAI,EAAEb,6BAA6B,CAACrE,UAAU,CAACkF,IAAI,CAAC;EACpDC,KAAK,EAAEd,6BAA6B,CAACC,IAAI,CAACa,KAAK,CAAC;EAChDC,IAAI,EAAEf,6BAA6B,CAACC,IAAI,CAACc,IAAI,CAAC;EAC9CC,KAAK,EAAEhB,6BAA6B,CAACC,IAAI,CAACe,KAAK,CAAC;EAChDC,GAAG,EAAEjB,6BAA6B,CAACC,IAAI,CAACgB,GAAG,CAAC;EAC5CC,IAAI,EAAElB,6BAA6B,CAACkB,IAAI,CAAC;EACzCC,GAAG,EAAEnB,6BAA6B,CAACC,IAAI,CAACkB,GAAG,CAAC;EAC5CC,IAAI,EAAEpB,6BAA6B,CAACoB,IAAI,CAAC;EACzCC,KAAK,EAAErB,6BAA6B,CAACqB,KAAK,CAAC;EAC3CzD,MAAM,EAAEA,MAAM;EACd0D,SAAS,EAAEA;AACb,CAAC;AAED,MAAMC,eAAe,GAAG;EACtBC,KAAK,EAAEC,8BAA8B,CAACxB,IAAI,CAACuB,KAAK,EAAE,KAAK,CAAC;EACxDE,GAAG,EAAED,8BAA8B,CAACxB,IAAI,CAACyB,GAAG,EAAE,KAAK,CAAC;EACpDC,GAAG,EAAEF,8BAA8B,CAACxB,IAAI,CAAC0B,GAAG,EAAE,IAAI,CAAC;EACnDC,GAAG,EAAEH,8BAA8B,CAACxB,IAAI,CAAC2B,GAAG,EAAE,IAAI,CAAC;EACnDC,QAAQ,EAAEA,QAAQ;EAClBC,GAAG,EAAEA,GAAG;EACRC,KAAK,EAAEA;AACT,CAAC;AAED,MAAMC,gBAAgB,GAAG;EACvBC,KAAK,EAAEC,+BAA+B,CAACvG,UAAU,CAACsG,KAAK,EAAE,IAAI,CAAC;EAC9DE,GAAG,EAAED,+BAA+B,CAACvG,UAAU,CAACyG,IAAI,EAAE,IAAI;AAC5D,CAAC;AAED,SAASf,KAAKA,CAACgB,MAAM,EAAE;EACrB,OAAOA,MAAM,GAAGpC,IAAI,CAACa,KAAK,CAACuB,MAAM,CAAC;AACpC;AAEA,SAASnB,IAAIA,CAACoB,QAAQ,EAAE;EACtB,OAAOrC,IAAI,CAACyB,GAAG,CAAC,GAAG,EAAEY,QAAQ,CAAC;AAChC;AAEA,SAASlB,IAAIA,CAACiB,MAAM,EAAE;EACpB,OAAO1G,UAAU,CAACyF,IAAI,CAACiB,MAAM,CAAC;AAChC;AAEA,SAASrC,6BAA6BA,CAACuC,SAAS,EAAE;EAChD,OAAO,UAAUC,IAAI,EAAEC,IAAI,EAAE;IAC3B,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;MAC5B,OAAOF,SAAS,CAACE,IAAI,CAAC;IACxB,CAAC,MAAM,IAAIA,IAAI,YAAYrH,UAAU,EAAE;MACrC,OAAOA,UAAU,CAACsH,YAAY,CAC5BH,SAAS,CAACE,IAAI,CAACE,CAAC,CAAC,EACjBJ,SAAS,CAACE,IAAI,CAACG,CAAC,CAAC,EACjB3F,cAAc,CAACc,aAAa,CAAC,CAC/B,CAAC;IACH,CAAC,MAAM,IAAI0E,IAAI,YAAYpH,UAAU,EAAE;MACrC,OAAOA,UAAU,CAACqH,YAAY,CAC5BH,SAAS,CAACE,IAAI,CAACE,CAAC,CAAC,EACjBJ,SAAS,CAACE,IAAI,CAACG,CAAC,CAAC,EACjBL,SAAS,CAACE,IAAI,CAACI,CAAC,CAAC,EACjB5F,cAAc,CAACe,aAAa,CAAC,CAC/B,CAAC;IACH,CAAC,MAAM,IAAIyE,IAAI,YAAYnH,UAAU,EAAE;MACrC,OAAOA,UAAU,CAACoH,YAAY,CAC5BH,SAAS,CAACE,IAAI,CAACE,CAAC,CAAC,EACjBJ,SAAS,CAACE,IAAI,CAACG,CAAC,CAAC,EACjBL,SAAS,CAACE,IAAI,CAACI,CAAC,CAAC,EACjBN,SAAS,CAACE,IAAI,CAACK,CAAC,CAAC,EACjB7F,cAAc,CAACgB,aAAa,CAAC,CAC/B,CAAC;IACH;IACA,MAAM,IAAIrC,YAAY,CACpB,aAAa4G,IAAI,uDAAuDC,IAAI,GAC9E,CAAC;EACH,CAAC;AACH;AAEA,SAAShB,8BAA8BA,CAACc,SAAS,EAAEQ,WAAW,EAAE;EAC9D,OAAO,UAAUP,IAAI,EAAEC,IAAI,EAAEO,KAAK,EAAE;IAClC,IAAID,WAAW,IAAI,OAAOC,KAAK,KAAK,QAAQ,EAAE;MAC5C,IAAI,OAAOP,IAAI,KAAK,QAAQ,EAAE;QAC5B,OAAOF,SAAS,CAACE,IAAI,EAAEO,KAAK,CAAC;MAC/B,CAAC,MAAM,IAAIP,IAAI,YAAYrH,UAAU,EAAE;QACrC,OAAOA,UAAU,CAACsH,YAAY,CAC5BH,SAAS,CAACE,IAAI,CAACE,CAAC,EAAEK,KAAK,CAAC,EACxBT,SAAS,CAACE,IAAI,CAACG,CAAC,EAAEI,KAAK,CAAC,EACxB/F,cAAc,CAACc,aAAa,CAAC,CAC/B,CAAC;MACH,CAAC,MAAM,IAAI0E,IAAI,YAAYpH,UAAU,EAAE;QACrC,OAAOA,UAAU,CAACqH,YAAY,CAC5BH,SAAS,CAACE,IAAI,CAACE,CAAC,EAAEK,KAAK,CAAC,EACxBT,SAAS,CAACE,IAAI,CAACG,CAAC,EAAEI,KAAK,CAAC,EACxBT,SAAS,CAACE,IAAI,CAACI,CAAC,EAAEG,KAAK,CAAC,EACxB/F,cAAc,CAACe,aAAa,CAAC,CAC/B,CAAC;MACH,CAAC,MAAM,IAAIyE,IAAI,YAAYnH,UAAU,EAAE;QACrC,OAAOA,UAAU,CAACoH,YAAY,CAC5BH,SAAS,CAACE,IAAI,CAACE,CAAC,EAAEK,KAAK,CAAC,EACxBT,SAAS,CAACE,IAAI,CAACG,CAAC,EAAEI,KAAK,CAAC,EACxBT,SAAS,CAACE,IAAI,CAACI,CAAC,EAAEG,KAAK,CAAC,EACxBT,SAAS,CAACE,IAAI,CAACK,CAAC,EAAEE,KAAK,CAAC,EACxB/F,cAAc,CAACgB,aAAa,CAAC,CAC/B,CAAC;MACH;IACF;IAEA,IAAI,OAAOwE,IAAI,KAAK,QAAQ,IAAI,OAAOO,KAAK,KAAK,QAAQ,EAAE;MACzD,OAAOT,SAAS,CAACE,IAAI,EAAEO,KAAK,CAAC;IAC/B,CAAC,MAAM,IAAIP,IAAI,YAAYrH,UAAU,IAAI4H,KAAK,YAAY5H,UAAU,EAAE;MACpE,OAAOA,UAAU,CAACsH,YAAY,CAC5BH,SAAS,CAACE,IAAI,CAACE,CAAC,EAAEK,KAAK,CAACL,CAAC,CAAC,EAC1BJ,SAAS,CAACE,IAAI,CAACG,CAAC,EAAEI,KAAK,CAACJ,CAAC,CAAC,EAC1B3F,cAAc,CAACc,aAAa,CAAC,CAC/B,CAAC;IACH,CAAC,MAAM,IAAI0E,IAAI,YAAYpH,UAAU,IAAI2H,KAAK,YAAY3H,UAAU,EAAE;MACpE,OAAOA,UAAU,CAACqH,YAAY,CAC5BH,SAAS,CAACE,IAAI,CAACE,CAAC,EAAEK,KAAK,CAACL,CAAC,CAAC,EAC1BJ,SAAS,CAACE,IAAI,CAACG,CAAC,EAAEI,KAAK,CAACJ,CAAC,CAAC,EAC1BL,SAAS,CAACE,IAAI,CAACI,CAAC,EAAEG,KAAK,CAACH,CAAC,CAAC,EAC1B5F,cAAc,CAACe,aAAa,CAAC,CAC/B,CAAC;IACH,CAAC,MAAM,IAAIyE,IAAI,YAAYnH,UAAU,IAAI0H,KAAK,YAAY1H,UAAU,EAAE;MACpE,OAAOA,UAAU,CAACoH,YAAY,CAC5BH,SAAS,CAACE,IAAI,CAACE,CAAC,EAAEK,KAAK,CAACL,CAAC,CAAC,EAC1BJ,SAAS,CAACE,IAAI,CAACG,CAAC,EAAEI,KAAK,CAACJ,CAAC,CAAC,EAC1BL,SAAS,CAACE,IAAI,CAACI,CAAC,EAAEG,KAAK,CAACH,CAAC,CAAC,EAC1BN,SAAS,CAACE,IAAI,CAACK,CAAC,EAAEE,KAAK,CAACF,CAAC,CAAC,EAC1B7F,cAAc,CAACgB,aAAa,CAAC,CAC/B,CAAC;IACH;IAEA,MAAM,IAAIrC,YAAY,CACpB,aAAa4G,IAAI,0EAA0EC,IAAI,QAAQO,KAAK,GAC9G,CAAC;EACH,CAAC;AACH;AAEA,SAASd,+BAA+BA,CAACK,SAAS,EAAEQ,WAAW,EAAE;EAC/D,OAAO,UAAUP,IAAI,EAAEC,IAAI,EAAEO,KAAK,EAAEC,IAAI,EAAE;IACxC,IAAIF,WAAW,IAAI,OAAOE,IAAI,KAAK,QAAQ,EAAE;MAC3C,IAAI,OAAOR,IAAI,KAAK,QAAQ,IAAI,OAAOO,KAAK,KAAK,QAAQ,EAAE;QACzD,OAAOT,SAAS,CAACE,IAAI,EAAEO,KAAK,EAAEC,IAAI,CAAC;MACrC,CAAC,MAAM,IAAIR,IAAI,YAAYrH,UAAU,IAAI4H,KAAK,YAAY5H,UAAU,EAAE;QACpE,OAAOA,UAAU,CAACsH,YAAY,CAC5BH,SAAS,CAACE,IAAI,CAACE,CAAC,EAAEK,KAAK,CAACL,CAAC,EAAEM,IAAI,CAAC,EAChCV,SAAS,CAACE,IAAI,CAACG,CAAC,EAAEI,KAAK,CAACJ,CAAC,EAAEK,IAAI,CAAC,EAChChG,cAAc,CAACc,aAAa,CAAC,CAC/B,CAAC;MACH,CAAC,MAAM,IAAI0E,IAAI,YAAYpH,UAAU,IAAI2H,KAAK,YAAY3H,UAAU,EAAE;QACpE,OAAOA,UAAU,CAACqH,YAAY,CAC5BH,SAAS,CAACE,IAAI,CAACE,CAAC,EAAEK,KAAK,CAACL,CAAC,EAAEM,IAAI,CAAC,EAChCV,SAAS,CAACE,IAAI,CAACG,CAAC,EAAEI,KAAK,CAACJ,CAAC,EAAEK,IAAI,CAAC,EAChCV,SAAS,CAACE,IAAI,CAACI,CAAC,EAAEG,KAAK,CAACH,CAAC,EAAEI,IAAI,CAAC,EAChChG,cAAc,CAACe,aAAa,CAAC,CAC/B,CAAC;MACH,CAAC,MAAM,IAAIyE,IAAI,YAAYnH,UAAU,IAAI0H,KAAK,YAAY1H,UAAU,EAAE;QACpE,OAAOA,UAAU,CAACoH,YAAY,CAC5BH,SAAS,CAACE,IAAI,CAACE,CAAC,EAAEK,KAAK,CAACL,CAAC,EAAEM,IAAI,CAAC,EAChCV,SAAS,CAACE,IAAI,CAACG,CAAC,EAAEI,KAAK,CAACJ,CAAC,EAAEK,IAAI,CAAC,EAChCV,SAAS,CAACE,IAAI,CAACI,CAAC,EAAEG,KAAK,CAACH,CAAC,EAAEI,IAAI,CAAC,EAChCV,SAAS,CAACE,IAAI,CAACK,CAAC,EAAEE,KAAK,CAACF,CAAC,EAAEG,IAAI,CAAC,EAChChG,cAAc,CAACgB,aAAa,CAAC,CAC/B,CAAC;MACH;IACF;IAEA,IACE,OAAOwE,IAAI,KAAK,QAAQ,IACxB,OAAOO,KAAK,KAAK,QAAQ,IACzB,OAAOC,IAAI,KAAK,QAAQ,EACxB;MACA,OAAOV,SAAS,CAACE,IAAI,EAAEO,KAAK,EAAEC,IAAI,CAAC;IACrC,CAAC,MAAM,IACLR,IAAI,YAAYrH,UAAU,IAC1B4H,KAAK,YAAY5H,UAAU,IAC3B6H,IAAI,YAAY7H,UAAU,EAC1B;MACA,OAAOA,UAAU,CAACsH,YAAY,CAC5BH,SAAS,CAACE,IAAI,CAACE,CAAC,EAAEK,KAAK,CAACL,CAAC,EAAEM,IAAI,CAACN,CAAC,CAAC,EAClCJ,SAAS,CAACE,IAAI,CAACG,CAAC,EAAEI,KAAK,CAACJ,CAAC,EAAEK,IAAI,CAACL,CAAC,CAAC,EAClC3F,cAAc,CAACc,aAAa,CAAC,CAC/B,CAAC;IACH,CAAC,MAAM,IACL0E,IAAI,YAAYpH,UAAU,IAC1B2H,KAAK,YAAY3H,UAAU,IAC3B4H,IAAI,YAAY5H,UAAU,EAC1B;MACA,OAAOA,UAAU,CAACqH,YAAY,CAC5BH,SAAS,CAACE,IAAI,CAACE,CAAC,EAAEK,KAAK,CAACL,CAAC,EAAEM,IAAI,CAACN,CAAC,CAAC,EAClCJ,SAAS,CAACE,IAAI,CAACG,CAAC,EAAEI,KAAK,CAACJ,CAAC,EAAEK,IAAI,CAACL,CAAC,CAAC,EAClCL,SAAS,CAACE,IAAI,CAACI,CAAC,EAAEG,KAAK,CAACH,CAAC,EAAEI,IAAI,CAACJ,CAAC,CAAC,EAClC5F,cAAc,CAACe,aAAa,CAAC,CAC/B,CAAC;IACH,CAAC,MAAM,IACLyE,IAAI,YAAYnH,UAAU,IAC1B0H,KAAK,YAAY1H,UAAU,IAC3B2H,IAAI,YAAY3H,UAAU,EAC1B;MACA,OAAOA,UAAU,CAACoH,YAAY,CAC5BH,SAAS,CAACE,IAAI,CAACE,CAAC,EAAEK,KAAK,CAACL,CAAC,EAAEM,IAAI,CAACN,CAAC,CAAC,EAClCJ,SAAS,CAACE,IAAI,CAACG,CAAC,EAAEI,KAAK,CAACJ,CAAC,EAAEK,IAAI,CAACL,CAAC,CAAC,EAClCL,SAAS,CAACE,IAAI,CAACI,CAAC,EAAEG,KAAK,CAACH,CAAC,EAAEI,IAAI,CAACJ,CAAC,CAAC,EAClCN,SAAS,CAACE,IAAI,CAACK,CAAC,EAAEE,KAAK,CAACF,CAAC,EAAEG,IAAI,CAACH,CAAC,CAAC,EAClC7F,cAAc,CAACgB,aAAa,CAAC,CAC/B,CAAC;IACH;IAEA,MAAM,IAAIrC,YAAY,CACpB,aAAa4G,IAAI,0EAA0EC,IAAI,KAAKO,KAAK,SAASC,IAAI,GACxH,CAAC;EACH,CAAC;AACH;AAEA,SAASrF,MAAMA,CAAC4E,IAAI,EAAEC,IAAI,EAAE;EAC1B,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;IAC5B,OAAOxC,IAAI,CAACF,GAAG,CAAC0C,IAAI,CAAC;EACvB,CAAC,MAAM,IAAIA,IAAI,YAAYrH,UAAU,EAAE;IACrC,OAAOA,UAAU,CAAC8H,SAAS,CAACT,IAAI,CAAC;EACnC,CAAC,MAAM,IAAIA,IAAI,YAAYpH,UAAU,EAAE;IACrC,OAAOA,UAAU,CAAC6H,SAAS,CAACT,IAAI,CAAC;EACnC,CAAC,MAAM,IAAIA,IAAI,YAAYnH,UAAU,EAAE;IACrC,OAAOA,UAAU,CAAC4H,SAAS,CAACT,IAAI,CAAC;EACnC;EAEA,MAAM,IAAI7G,YAAY,CACpB,aAAa4G,IAAI,uDAAuDC,IAAI,GAC9E,CAAC;AACH;AAEA,SAASnB,SAASA,CAACkB,IAAI,EAAEC,IAAI,EAAE;EAC7B,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;IAC5B,OAAO,GAAG;EACZ,CAAC,MAAM,IAAIA,IAAI,YAAYrH,UAAU,EAAE;IACrC,OAAOA,UAAU,CAACkG,SAAS,CAACmB,IAAI,EAAExF,cAAc,CAACc,aAAa,CAAC,CAAC,CAAC;EACnE,CAAC,MAAM,IAAI0E,IAAI,YAAYpH,UAAU,EAAE;IACrC,OAAOA,UAAU,CAACiG,SAAS,CAACmB,IAAI,EAAExF,cAAc,CAACe,aAAa,CAAC,CAAC,CAAC;EACnE,CAAC,MAAM,IAAIyE,IAAI,YAAYnH,UAAU,EAAE;IACrC,OAAOA,UAAU,CAACgG,SAAS,CAACmB,IAAI,EAAExF,cAAc,CAACgB,aAAa,CAAC,CAAC,CAAC;EACnE;EAEA,MAAM,IAAIrC,YAAY,CACpB,aAAa4G,IAAI,uDAAuDC,IAAI,GAC9E,CAAC;AACH;AAEA,SAASZ,QAAQA,CAACW,IAAI,EAAEC,IAAI,EAAEO,KAAK,EAAE;EACnC,IAAI,OAAOP,IAAI,KAAK,QAAQ,IAAI,OAAOO,KAAK,KAAK,QAAQ,EAAE;IACzD,OAAO/C,IAAI,CAACF,GAAG,CAAC0C,IAAI,GAAGO,KAAK,CAAC;EAC/B,CAAC,MAAM,IAAIP,IAAI,YAAYrH,UAAU,IAAI4H,KAAK,YAAY5H,UAAU,EAAE;IACpE,OAAOA,UAAU,CAACyG,QAAQ,CAACY,IAAI,EAAEO,KAAK,CAAC;EACzC,CAAC,MAAM,IAAIP,IAAI,YAAYpH,UAAU,IAAI2H,KAAK,YAAY3H,UAAU,EAAE;IACpE,OAAOA,UAAU,CAACwG,QAAQ,CAACY,IAAI,EAAEO,KAAK,CAAC;EACzC,CAAC,MAAM,IAAIP,IAAI,YAAYnH,UAAU,IAAI0H,KAAK,YAAY1H,UAAU,EAAE;IACpE,OAAOA,UAAU,CAACuG,QAAQ,CAACY,IAAI,EAAEO,KAAK,CAAC;EACzC;EAEA,MAAM,IAAIpH,YAAY,CACpB,aAAa4G,IAAI,0EAA0EC,IAAI,QAAQO,KAAK,GAC9G,CAAC;AACH;AAEA,SAASlB,GAAGA,CAACU,IAAI,EAAEC,IAAI,EAAEO,KAAK,EAAE;EAC9B,IAAI,OAAOP,IAAI,KAAK,QAAQ,IAAI,OAAOO,KAAK,KAAK,QAAQ,EAAE;IACzD,OAAOP,IAAI,GAAGO,KAAK;EACrB,CAAC,MAAM,IAAIP,IAAI,YAAYrH,UAAU,IAAI4H,KAAK,YAAY5H,UAAU,EAAE;IACpE,OAAOA,UAAU,CAAC0G,GAAG,CAACW,IAAI,EAAEO,KAAK,CAAC;EACpC,CAAC,MAAM,IAAIP,IAAI,YAAYpH,UAAU,IAAI2H,KAAK,YAAY3H,UAAU,EAAE;IACpE,OAAOA,UAAU,CAACyG,GAAG,CAACW,IAAI,EAAEO,KAAK,CAAC;EACpC,CAAC,MAAM,IAAIP,IAAI,YAAYnH,UAAU,IAAI0H,KAAK,YAAY1H,UAAU,EAAE;IACpE,OAAOA,UAAU,CAACwG,GAAG,CAACW,IAAI,EAAEO,KAAK,CAAC;EACpC;EAEA,MAAM,IAAIpH,YAAY,CACpB,aAAa4G,IAAI,0EAA0EC,IAAI,QAAQO,KAAK,GAC9G,CAAC;AACH;AAEA,SAASjB,KAAKA,CAACS,IAAI,EAAEC,IAAI,EAAEO,KAAK,EAAE;EAChC,IAAIP,IAAI,YAAYpH,UAAU,IAAI2H,KAAK,YAAY3H,UAAU,EAAE;IAC7D,OAAOA,UAAU,CAAC0G,KAAK,CAACU,IAAI,EAAEO,KAAK,EAAE/F,cAAc,CAACe,aAAa,CAAC,CAAC,CAAC;EACtE;EAEA,MAAM,IAAIpC,YAAY,CACpB,aAAa4G,IAAI,4CAA4CC,IAAI,QAAQO,KAAK,GAChF,CAAC;AACH;AAEA,SAASG,IAAIA,CAACC,IAAI,EAAE/E,KAAK,EAAEoE,IAAI,EAAEO,KAAK,EAAEC,IAAI,EAAE;EAC5C,IAAI,CAACI,KAAK,GAAGD,IAAI;EACjB,IAAI,CAACE,MAAM,GAAGjF,KAAK;EACnB,IAAI,CAACkF,KAAK,GAAGd,IAAI;EACjB,IAAI,CAACe,MAAM,GAAGR,KAAK;EACnB,IAAI,CAACS,KAAK,GAAGR,IAAI;EACjB,IAAI,CAAC/E,QAAQ,GAAGwF,SAAS;EAEzBC,mBAAmB,CAAC,IAAI,CAAC;AAC3B;AAEA,SAAStH,cAAcA,CAACL,UAAU,EAAEC,OAAO,EAAE;EAC3C,IAAI,CAACR,OAAO,CAACQ,OAAO,CAAC,EAAE;IACrB,OAAOD,UAAU;EACnB;EACA,KAAK,MAAM4H,GAAG,IAAI3H,OAAO,EAAE;IACzB,IAAIA,OAAO,CAAC4H,cAAc,CAACD,GAAG,CAAC,EAAE;MAC/B,MAAME,iBAAiB,GAAG,IAAIC,MAAM,CAAC,SAASH,GAAG,KAAK,EAAE,GAAG,CAAC;MAC5D,MAAMI,aAAa,GAAG,IAAI/H,OAAO,CAAC2H,GAAG,CAAC,GAAG;MACzC,IAAInI,OAAO,CAACuI,aAAa,CAAC,EAAE;QAC1BhI,UAAU,GAAGA,UAAU,CAACiI,OAAO,CAACH,iBAAiB,EAAEE,aAAa,CAAC;MACnE;IACF;EACF;EACA,OAAOhI,UAAU;AACnB;AAEA,SAASO,iBAAiBA,CAACP,UAAU,EAAE;EACrC,OAAOA,UAAU,CAACiI,OAAO,CAACvE,cAAc,EAAEC,oBAAoB,CAAC;AACjE;AAEA,SAASuE,kBAAkBA,CAAClI,UAAU,EAAE;EACtC,OAAOA,UAAU,CAACiI,OAAO,CAACrE,gBAAgB,EAAE,IAAI,CAAC;AACnD;AAEA,SAAStD,gBAAgBA,CAACN,UAAU,EAAE;EACpC,IAAIiF,GAAG,GAAGjF,UAAU;EACpB,IAAIoC,MAAM,GAAG,EAAE;EACf,IAAI+F,CAAC,GAAGlD,GAAG,CAAC3B,OAAO,CAAC,IAAI,CAAC;EACzB,OAAO6E,CAAC,IAAI,CAAC,EAAE;IACb;IACA,MAAMC,eAAe,GAAGnD,GAAG,CAAC3B,OAAO,CAAC,GAAG,CAAC;IACxC,MAAM+E,eAAe,GAAGpD,GAAG,CAAC3B,OAAO,CAAC,GAAG,CAAC;IACxC,IAAIgF,UAAU;IACd,IAAIF,eAAe,IAAI,CAAC,IAAIA,eAAe,GAAGD,CAAC,EAAE;MAC/CG,UAAU,GAAGrD,GAAG,CAAC3B,OAAO,CAAC,GAAG,EAAE8E,eAAe,GAAG,CAAC,CAAC;MAClDhG,MAAM,IAAI6C,GAAG,CAACsD,MAAM,CAAC,CAAC,EAAED,UAAU,GAAG,CAAC,CAAC;MACvCrD,GAAG,GAAGA,GAAG,CAACsD,MAAM,CAACD,UAAU,GAAG,CAAC,CAAC;MAChCH,CAAC,GAAGlD,GAAG,CAAC3B,OAAO,CAAC,IAAI,CAAC;IACvB,CAAC,MAAM,IAAI+E,eAAe,IAAI,CAAC,IAAIA,eAAe,GAAGF,CAAC,EAAE;MACtDG,UAAU,GAAGrD,GAAG,CAAC3B,OAAO,CAAC,GAAG,EAAE+E,eAAe,GAAG,CAAC,CAAC;MAClDjG,MAAM,IAAI6C,GAAG,CAACsD,MAAM,CAAC,CAAC,EAAED,UAAU,GAAG,CAAC,CAAC;MACvCrD,GAAG,GAAGA,GAAG,CAACsD,MAAM,CAACD,UAAU,GAAG,CAAC,CAAC;MAChCH,CAAC,GAAGlD,GAAG,CAAC3B,OAAO,CAAC,IAAI,CAAC;IACvB,CAAC,MAAM;MACLlB,MAAM,IAAI6C,GAAG,CAACsD,MAAM,CAAC,CAAC,EAAEJ,CAAC,CAAC;MAC1B,MAAMK,CAAC,GAAGvD,GAAG,CAAC3B,OAAO,CAAC,GAAG,CAAC;MAC1B,IAAIkF,CAAC,GAAG,CAAC,EAAE;QACT,MAAM,IAAI5I,YAAY,CAAC,cAAc,CAAC;MACxC;MACAwC,MAAM,IAAI,OAAO6C,GAAG,CAACsD,MAAM,CAACJ,CAAC,GAAG,CAAC,EAAEK,CAAC,IAAIL,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;MACjDlD,GAAG,GAAGA,GAAG,CAACsD,MAAM,CAACC,CAAC,GAAG,CAAC,CAAC;MACvBL,CAAC,GAAGlD,GAAG,CAAC3B,OAAO,CAAC,IAAI,CAAC;IACvB;EACF;EACAlB,MAAM,IAAI6C,GAAG;EACb,OAAO7C,MAAM;AACf;AAEA,SAASqG,YAAYA,CAAChI,GAAG,EAAE;EACzB,MAAM2G,IAAI,GAAG,OAAO3G,GAAG,CAAC4B,KAAK;EAC7B,IAAI5B,GAAG,CAAC4B,KAAK,KAAK,IAAI,EAAE;IACtB,OAAO,IAAI8E,IAAI,CAACrH,kBAAkB,CAAC4I,YAAY,EAAE,IAAI,CAAC;EACxD,CAAC,MAAM,IAAItB,IAAI,KAAK,SAAS,EAAE;IAC7B,OAAO,IAAID,IAAI,CAACrH,kBAAkB,CAAC6I,eAAe,EAAElI,GAAG,CAAC4B,KAAK,CAAC;EAChE,CAAC,MAAM,IAAI+E,IAAI,KAAK,QAAQ,EAAE;IAC5B,OAAO,IAAID,IAAI,CAACrH,kBAAkB,CAAC8I,cAAc,EAAEnI,GAAG,CAAC4B,KAAK,CAAC;EAC/D,CAAC,MAAM,IAAI+E,IAAI,KAAK,QAAQ,EAAE;IAC5B,IAAI3G,GAAG,CAAC4B,KAAK,CAACiB,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;MAChC,OAAO,IAAI6D,IAAI,CAACrH,kBAAkB,CAAC+I,kBAAkB,EAAEpI,GAAG,CAAC4B,KAAK,CAAC;IACnE;IACA,OAAO,IAAI8E,IAAI,CACbrH,kBAAkB,CAACgJ,cAAc,EACjCZ,kBAAkB,CAACzH,GAAG,CAAC4B,KAAK,CAC9B,CAAC;EACH;AACF;AAEA,SAAS0G,SAASA,CAAC/I,UAAU,EAAES,GAAG,EAAE;EAClC,MAAMuI,IAAI,GAAGvI,GAAG,CAACwI,SAAS;EAC1B,MAAMC,UAAU,GAAGF,IAAI,CAACpH,MAAM;EAC9B,IAAI4E,IAAI;EACR,IAAI2C,GAAG,EAAE1C,IAAI,EAAEO,KAAK;;EAEpB;EACA,IAAIvG,GAAG,CAAC2I,MAAM,CAAChC,IAAI,KAAK,kBAAkB,EAAE;IAC1CZ,IAAI,GAAG/F,GAAG,CAAC2I,MAAM,CAACC,QAAQ,CAACC,IAAI;IAC/B,MAAMC,MAAM,GAAG9I,GAAG,CAAC2I,MAAM,CAACG,MAAM;IAChC,IAAI/C,IAAI,KAAK,MAAM,IAAIA,IAAI,KAAK,MAAM,EAAE;MACtC;MACA,IAAI,CAAC/G,OAAO,CAAC8J,MAAM,CAACH,MAAM,CAAC,IAAIG,MAAM,CAACH,MAAM,CAACE,IAAI,KAAK,QAAQ,EAAE;QAC9D,MAAM,IAAI1J,YAAY,CAAC,GAAG4G,IAAI,qBAAqB,CAAC;MACtD;MACA,IAAI0C,UAAU,KAAK,CAAC,EAAE;QACpB,IAAI1C,IAAI,KAAK,MAAM,EAAE;UACnB,OAAO,IAAIW,IAAI,CAACrH,kBAAkB,CAAC6I,eAAe,EAAE,KAAK,CAAC;QAC5D;QACA,OAAO,IAAIxB,IAAI,CAACrH,kBAAkB,CAAC4I,YAAY,EAAE,IAAI,CAAC;MACxD;MACAjC,IAAI,GAAG7F,gBAAgB,CAACZ,UAAU,EAAEuJ,MAAM,CAAC;MAC3CvC,KAAK,GAAGpG,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC;MAC7C,OAAO,IAAI7B,IAAI,CAACrH,kBAAkB,CAAC0J,aAAa,EAAEhD,IAAI,EAAEC,IAAI,EAAEO,KAAK,CAAC;IACtE,CAAC,MAAM,IAAIR,IAAI,KAAK,UAAU,EAAE;MAC9B2C,GAAG,GAAGvI,gBAAgB,CAACZ,UAAU,EAAEuJ,MAAM,CAAC;MAC1C,OAAO,IAAIpC,IAAI,CAACrH,kBAAkB,CAAC0J,aAAa,EAAEhD,IAAI,EAAE2C,GAAG,CAAC;IAC9D;IAEA,MAAM,IAAIvJ,YAAY,CAAC,6BAA6B4G,IAAI,IAAI,CAAC;EAC/D;;EAEA;EACAA,IAAI,GAAG/F,GAAG,CAAC2I,MAAM,CAACE,IAAI;EACtB,IAAI9C,IAAI,KAAK,OAAO,EAAE;IACpB,IAAI0C,UAAU,KAAK,CAAC,EAAE;MACpB,OAAO,IAAI/B,IAAI,CAACrH,kBAAkB,CAAC2J,aAAa,EAAEjD,IAAI,CAAC;IACzD;IACA2C,GAAG,GAAGvI,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC;IAC3C,IAAIvJ,OAAO,CAACuJ,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;MACpB,MAAMU,KAAK,GAAG9I,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC;MACnD,OAAO,IAAI7B,IAAI,CAACrH,kBAAkB,CAAC2J,aAAa,EAAEjD,IAAI,EAAE,CAAC2C,GAAG,EAAEO,KAAK,CAAC,CAAC;IACvE;IACA,OAAO,IAAIvC,IAAI,CAACrH,kBAAkB,CAAC2J,aAAa,EAAEjD,IAAI,EAAE,CAAC2C,GAAG,CAAC,CAAC;EAChE,CAAC,MAAM,IAAI3C,IAAI,KAAK,KAAK,IAAIA,IAAI,KAAK,KAAK,EAAE;IAC3C,IAAI0C,UAAU,GAAG,CAAC,EAAE;MAClB,MAAM,IAAItJ,YAAY,CAAC,GAAG4G,IAAI,4BAA4B,CAAC;IAC7D;IACA2C,GAAG,GAAG,CACJvI,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC,EACrCpI,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC,EACrCpI,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC,CACtC;IACD,OAAO,IAAI7B,IAAI,CAACrH,kBAAkB,CAAC2J,aAAa,EAAEjD,IAAI,EAAE2C,GAAG,CAAC;EAC9D,CAAC,MAAM,IAAI3C,IAAI,KAAK,MAAM,IAAIA,IAAI,KAAK,MAAM,EAAE;IAC7C,IAAI0C,UAAU,GAAG,CAAC,EAAE;MAClB,MAAM,IAAItJ,YAAY,CAAC,GAAG4G,IAAI,2BAA2B,CAAC;IAC5D;IACA2C,GAAG,GAAG,CACJvI,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC,EACrCpI,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC,EACrCpI,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC,EACrCpI,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC,CACtC;IACD,OAAO,IAAI7B,IAAI,CAACrH,kBAAkB,CAAC2J,aAAa,EAAEjD,IAAI,EAAE2C,GAAG,CAAC;EAC9D,CAAC,MAAM,IAAI3C,IAAI,KAAK,MAAM,IAAIA,IAAI,KAAK,MAAM,IAAIA,IAAI,KAAK,MAAM,EAAE;IAChE;IACA2C,GAAG,GAAG,IAAIQ,KAAK,CAACT,UAAU,CAAC;IAC3B,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,UAAU,EAAE,EAAEf,CAAC,EAAE;MACnCgB,GAAG,CAAChB,CAAC,CAAC,GAAGvH,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAACb,CAAC,CAAC,CAAC;IAChD;IACA,OAAO,IAAIhB,IAAI,CAACrH,kBAAkB,CAAC8J,cAAc,EAAEpD,IAAI,EAAE2C,GAAG,CAAC;EAC/D,CAAC,MAAM,IAAI3C,IAAI,KAAK,OAAO,IAAIA,IAAI,KAAK,UAAU,EAAE;IAClD,IAAI0C,UAAU,KAAK,CAAC,EAAE;MACpB,IAAI1C,IAAI,KAAK,OAAO,EAAE;QACpB,OAAO,IAAIW,IAAI,CAACrH,kBAAkB,CAAC6I,eAAe,EAAE,IAAI,CAAC;MAC3D;MACA,OAAO,IAAIxB,IAAI,CAACrH,kBAAkB,CAAC6I,eAAe,EAAE,KAAK,CAAC;IAC5D;IACAQ,GAAG,GAAGvI,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC;IAC3C,OAAO,IAAI7B,IAAI,CAACrH,kBAAkB,CAAC+J,KAAK,EAAErD,IAAI,EAAE2C,GAAG,CAAC;EACtD,CAAC,MAAM,IAAI3C,IAAI,KAAK,cAAc,IAAIA,IAAI,KAAK,SAAS,EAAE;IACxD,IAAI0C,UAAU,GAAG,CAAC,IAAIA,UAAU,GAAG,CAAC,EAAE;MACpC,MAAM,IAAItJ,YAAY,CAAC,GAAG4G,IAAI,iCAAiC,CAAC;IAClE;IACA2C,GAAG,GAAGvI,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC;IAC3C,OAAO,IAAI7B,IAAI,CAACrH,kBAAkB,CAAC+J,KAAK,EAAErD,IAAI,EAAE2C,GAAG,CAAC;EACtD,CAAC,MAAM,IAAI3C,IAAI,KAAK,mBAAmB,EAAE;IACvC,IAAI0C,UAAU,GAAG,CAAC,EAAE;MAClB,MAAM,IAAItJ,YAAY,CAAC,GAAG4G,IAAI,8BAA8B,CAAC;IAC/D;IACA,OAAO,IAAIW,IAAI,CAACrH,kBAAkB,CAAC+J,KAAK,EAAErD,IAAI,CAAC;EACjD,CAAC,MAAM,IAAI/G,OAAO,CAACqE,cAAc,CAAC0C,IAAI,CAAC,CAAC,EAAE;IACxC,IAAI0C,UAAU,KAAK,CAAC,EAAE;MACpB,MAAM,IAAItJ,YAAY,CAAC,GAAG4G,IAAI,iCAAiC,CAAC;IAClE;IACA2C,GAAG,GAAGvI,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC;IAC3C,OAAO,IAAI7B,IAAI,CAACrH,kBAAkB,CAAC+J,KAAK,EAAErD,IAAI,EAAE2C,GAAG,CAAC;EACtD,CAAC,MAAM,IAAI1J,OAAO,CAAC8F,eAAe,CAACiB,IAAI,CAAC,CAAC,EAAE;IACzC,IAAI0C,UAAU,KAAK,CAAC,EAAE;MACpB,MAAM,IAAItJ,YAAY,CAAC,GAAG4G,IAAI,kCAAkC,CAAC;IACnE;IACAC,IAAI,GAAG7F,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC;IAC5ChC,KAAK,GAAGpG,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC;IAC7C,OAAO,IAAI7B,IAAI,CAACrH,kBAAkB,CAACgK,MAAM,EAAEtD,IAAI,EAAEC,IAAI,EAAEO,KAAK,CAAC;EAC/D,CAAC,MAAM,IAAIvH,OAAO,CAACuG,gBAAgB,CAACQ,IAAI,CAAC,CAAC,EAAE;IAC1C,IAAI0C,UAAU,KAAK,CAAC,EAAE;MACpB,MAAM,IAAItJ,YAAY,CAAC,GAAG4G,IAAI,oCAAoC,CAAC;IACrE;IACAC,IAAI,GAAG7F,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC;IAC5ChC,KAAK,GAAGpG,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC;IAC7C,MAAM/B,IAAI,GAAGrG,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC;IAClD,OAAO,IAAI7B,IAAI,CAACrH,kBAAkB,CAACiK,OAAO,EAAEvD,IAAI,EAAEC,IAAI,EAAEO,KAAK,EAAEC,IAAI,CAAC;EACtE,CAAC,MAAM,IAAIT,IAAI,KAAK,SAAS,EAAE;IAC7B,IAAI0C,UAAU,KAAK,CAAC,EAAE;MACpB,OAAO,IAAI/B,IAAI,CAACrH,kBAAkB,CAAC6I,eAAe,EAAE,KAAK,CAAC;IAC5D;IACAQ,GAAG,GAAGvI,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC;IAC3C,OAAO,IAAI7B,IAAI,CAACrH,kBAAkB,CAAC+J,KAAK,EAAErD,IAAI,EAAE2C,GAAG,CAAC;EACtD,CAAC,MAAM,IAAI3C,IAAI,KAAK,QAAQ,EAAE;IAC5B,IAAI0C,UAAU,KAAK,CAAC,EAAE;MACpB,OAAO,IAAI/B,IAAI,CAACrH,kBAAkB,CAAC8I,cAAc,EAAE,CAAC,CAAC;IACvD;IACAO,GAAG,GAAGvI,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC;IAC3C,OAAO,IAAI7B,IAAI,CAACrH,kBAAkB,CAAC+J,KAAK,EAAErD,IAAI,EAAE2C,GAAG,CAAC;EACtD,CAAC,MAAM,IAAI3C,IAAI,KAAK,QAAQ,EAAE;IAC5B,IAAI0C,UAAU,KAAK,CAAC,EAAE;MACpB,OAAO,IAAI/B,IAAI,CAACrH,kBAAkB,CAACgJ,cAAc,EAAE,EAAE,CAAC;IACxD;IACAK,GAAG,GAAGvI,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC;IAC3C,OAAO,IAAI7B,IAAI,CAACrH,kBAAkB,CAAC+J,KAAK,EAAErD,IAAI,EAAE2C,GAAG,CAAC;EACtD,CAAC,MAAM,IAAI3C,IAAI,KAAK,QAAQ,EAAE;IAC5B,OAAOwD,UAAU,CAAChK,UAAU,EAAES,GAAG,CAAC;EACpC;EAEA,MAAM,IAAIb,YAAY,CAAC,6BAA6B4G,IAAI,IAAI,CAAC;AAC/D;AAEA,SAASwD,UAAUA,CAAChK,UAAU,EAAES,GAAG,EAAE;EACnC,MAAMuI,IAAI,GAAGvI,GAAG,CAACwI,SAAS;EAC1B;EACA,IAAID,IAAI,CAACpH,MAAM,KAAK,CAAC,EAAE;IACrB,OAAO,IAAIuF,IAAI,CAACrH,kBAAkB,CAACmK,aAAa,EAAE,IAAIlC,MAAM,CAAC,CAAC,CAAC;EACjE;EAEA,MAAMmC,OAAO,GAAGtJ,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC;EACrD,IAAI/D,GAAG;;EAEP;EACA,IAAI+D,IAAI,CAACpH,MAAM,GAAG,CAAC,EAAE;IACnB,MAAMuI,KAAK,GAAGvJ,gBAAgB,CAACZ,UAAU,EAAEgJ,IAAI,CAAC,CAAC,CAAC,CAAC;IACnD,IAAIoB,aAAa,CAACF,OAAO,CAAC,IAAIE,aAAa,CAACD,KAAK,CAAC,EAAE;MAClD,IAAI;QACFlF,GAAG,GAAG,IAAI8C,MAAM,CACdG,kBAAkB,CAACmC,MAAM,CAACH,OAAO,CAAC5C,MAAM,CAAC,CAAC,EAC1C6C,KAAK,CAAC7C,MACR,CAAC;MACH,CAAC,CAAC,OAAO5G,CAAC,EAAE;QACV,MAAM,IAAId,YAAY,CAACc,CAAC,CAAC;MAC3B;MACA,OAAO,IAAIyG,IAAI,CAACrH,kBAAkB,CAACmK,aAAa,EAAEhF,GAAG,CAAC;IACxD;IACA,OAAO,IAAIkC,IAAI,CAACrH,kBAAkB,CAACwK,KAAK,EAAEJ,OAAO,EAAEC,KAAK,CAAC;EAC3D;;EAEA;EACA,IAAIC,aAAa,CAACF,OAAO,CAAC,EAAE;IAC1B,IAAI;MACFjF,GAAG,GAAG,IAAI8C,MAAM,CAACG,kBAAkB,CAACmC,MAAM,CAACH,OAAO,CAAC5C,MAAM,CAAC,CAAC,CAAC;IAC9D,CAAC,CAAC,OAAO5G,CAAC,EAAE;MACV,MAAM,IAAId,YAAY,CAACc,CAAC,CAAC;IAC3B;IACA,OAAO,IAAIyG,IAAI,CAACrH,kBAAkB,CAACmK,aAAa,EAAEhF,GAAG,CAAC;EACxD;EACA,OAAO,IAAIkC,IAAI,CAACrH,kBAAkB,CAACwK,KAAK,EAAEJ,OAAO,CAAC;AACpD;AAEA,SAASK,yBAAyBA,CAAC9J,GAAG,EAAE;EACtC,IAAI+J,UAAU,CAAC/J,GAAG,CAAC6I,IAAI,CAAC,EAAE;IACxB,MAAMA,IAAI,GAAGmB,eAAe,CAAChK,GAAG,CAAC6I,IAAI,CAAC;IACtC,IAAIA,IAAI,CAACf,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,UAAU,EAAE;MACpC,OAAO,IAAIpB,IAAI,CAACrH,kBAAkB,CAAC4K,gBAAgB,EAAEpB,IAAI,CAAC;IAC5D;IACA,OAAO,IAAInC,IAAI,CAACrH,kBAAkB,CAAC6K,QAAQ,EAAErB,IAAI,CAAC;EACpD,CAAC,MAAM,IAAI7I,GAAG,CAAC6I,IAAI,KAAK,KAAK,EAAE;IAC7B,OAAO,IAAInC,IAAI,CAACrH,kBAAkB,CAAC8I,cAAc,EAAEgC,GAAG,CAAC;EACzD,CAAC,MAAM,IAAInK,GAAG,CAAC6I,IAAI,KAAK,UAAU,EAAE;IAClC,OAAO,IAAInC,IAAI,CAACrH,kBAAkB,CAAC8I,cAAc,EAAEiC,QAAQ,CAAC;EAC9D,CAAC,MAAM,IAAIpK,GAAG,CAAC6I,IAAI,KAAK,WAAW,EAAE;IACnC,OAAO,IAAInC,IAAI,CAACrH,kBAAkB,CAACgL,iBAAiB,EAAEpD,SAAS,CAAC;EAClE;EAEA,MAAM,IAAI9H,YAAY,CAAC,GAAGa,GAAG,CAAC6I,IAAI,kBAAkB,CAAC;AACvD;AAEA,SAASyB,iBAAiBA,CAACtK,GAAG,EAAE;EAC9B,MAAM6I,IAAI,GAAG7I,GAAG,CAAC4I,QAAQ,CAACC,IAAI;EAC9B,IAAIA,IAAI,KAAK,IAAI,EAAE;IACjB,OAAO,IAAInC,IAAI,CAACrH,kBAAkB,CAAC8I,cAAc,EAAE3E,IAAI,CAAC+G,EAAE,CAAC;EAC7D,CAAC,MAAM,IAAI1B,IAAI,KAAK,GAAG,EAAE;IACvB,OAAO,IAAInC,IAAI,CAACrH,kBAAkB,CAAC8I,cAAc,EAAE3E,IAAI,CAACgH,CAAC,CAAC;EAC5D;AACF;AAEA,SAASC,mBAAmBA,CAACzK,GAAG,EAAE;EAChC,MAAM6I,IAAI,GAAG7I,GAAG,CAAC4I,QAAQ,CAACC,IAAI;EAC9B,IAAIA,IAAI,KAAK,mBAAmB,EAAE;IAChC,OAAO,IAAInC,IAAI,CACbrH,kBAAkB,CAAC8I,cAAc,EACjCuC,MAAM,CAACC,iBACT,CAAC;EACH;AACF;AAEA,SAASC,qBAAqBA,CAACrL,UAAU,EAAES,GAAG,EAAE;EAC9C,IAAIA,GAAG,CAAC8I,MAAM,CAACD,IAAI,KAAK,MAAM,EAAE;IAC9B,OAAOyB,iBAAiB,CAACtK,GAAG,CAAC;EAC/B,CAAC,MAAM,IAAIA,GAAG,CAAC8I,MAAM,CAACD,IAAI,KAAK,QAAQ,EAAE;IACvC,OAAO4B,mBAAmB,CAACzK,GAAG,CAAC;EACjC;EAEA,IAAI0I,GAAG;EACP,MAAMmC,GAAG,GAAG1K,gBAAgB,CAACZ,UAAU,EAAES,GAAG,CAAC8I,MAAM,CAAC;EACpD,IAAI9I,GAAG,CAAC8K,QAAQ,EAAE;IAChBpC,GAAG,GAAGvI,gBAAgB,CAACZ,UAAU,EAAES,GAAG,CAAC4I,QAAQ,CAAC;IAChD,OAAO,IAAIlC,IAAI,CAACrH,kBAAkB,CAAC0L,MAAM,EAAE,UAAU,EAAEF,GAAG,EAAEnC,GAAG,CAAC;EAClE;EAEAA,GAAG,GAAG,IAAIhC,IAAI,CAACrH,kBAAkB,CAACgJ,cAAc,EAAErI,GAAG,CAAC4I,QAAQ,CAACC,IAAI,CAAC;EACpE,OAAO,IAAInC,IAAI,CAACrH,kBAAkB,CAAC0L,MAAM,EAAE,KAAK,EAAEF,GAAG,EAAEnC,GAAG,CAAC;AAC7D;AAEA,SAASiB,aAAaA,CAACqB,IAAI,EAAE;EAC3B,OAAOA,IAAI,CAACpE,KAAK,IAAIvH,kBAAkB,CAAC4I,YAAY;AACtD;AAEA,SAAS8B,UAAUA,CAAClB,IAAI,EAAE;EACxB,OAAOA,IAAI,CAACf,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,MAAM;AACrC;AAEA,SAASkC,eAAeA,CAACrH,QAAQ,EAAE;EACjC,OAAOA,QAAQ,CAACmF,MAAM,CAAC,CAAC,CAAC;AAC3B;AAEA,SAAS3H,gBAAgBA,CAACZ,UAAU,EAAES,GAAG,EAAE;EACzC,IAAIgL,IAAI;EACR,IAAIC,EAAE;EACN,IAAIjF,IAAI;EACR,IAAIO,KAAK;EAET,IAAIvG,GAAG,CAAC2G,IAAI,KAAK,SAAS,EAAE;IAC1BqE,IAAI,GAAGhD,YAAY,CAAChI,GAAG,CAAC;EAC1B,CAAC,MAAM,IAAIA,GAAG,CAAC2G,IAAI,KAAK,gBAAgB,EAAE;IACxCqE,IAAI,GAAG1C,SAAS,CAAC/I,UAAU,EAAES,GAAG,CAAC;EACnC,CAAC,MAAM,IAAIA,GAAG,CAAC2G,IAAI,KAAK,YAAY,EAAE;IACpCqE,IAAI,GAAGlB,yBAAyB,CAAC9J,GAAG,CAAC;EACvC,CAAC,MAAM,IAAIA,GAAG,CAAC2G,IAAI,KAAK,iBAAiB,EAAE;IACzCsE,EAAE,GAAGjL,GAAG,CAACkL,QAAQ;IACjB,MAAMC,KAAK,GAAGhL,gBAAgB,CAACZ,UAAU,EAAES,GAAG,CAACoL,QAAQ,CAAC;IACxD,IAAItI,cAAc,CAACD,OAAO,CAACoI,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;MACnCD,IAAI,GAAG,IAAItE,IAAI,CAACrH,kBAAkB,CAAC+J,KAAK,EAAE6B,EAAE,EAAEE,KAAK,CAAC;IACtD,CAAC,MAAM;MACL,MAAM,IAAIhM,YAAY,CAAC,wBAAwB8L,EAAE,IAAI,CAAC;IACxD;EACF,CAAC,MAAM,IAAIjL,GAAG,CAAC2G,IAAI,KAAK,kBAAkB,EAAE;IAC1CsE,EAAE,GAAGjL,GAAG,CAACkL,QAAQ;IACjBlF,IAAI,GAAG7F,gBAAgB,CAACZ,UAAU,EAAES,GAAG,CAACgG,IAAI,CAAC;IAC7CO,KAAK,GAAGpG,gBAAgB,CAACZ,UAAU,EAAES,GAAG,CAACuG,KAAK,CAAC;IAC/C,IAAIxD,eAAe,CAACF,OAAO,CAACoI,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;MACpCD,IAAI,GAAG,IAAItE,IAAI,CAACrH,kBAAkB,CAACgK,MAAM,EAAE4B,EAAE,EAAEjF,IAAI,EAAEO,KAAK,CAAC;IAC7D,CAAC,MAAM;MACL,MAAM,IAAIpH,YAAY,CAAC,wBAAwB8L,EAAE,IAAI,CAAC;IACxD;EACF,CAAC,MAAM,IAAIjL,GAAG,CAAC2G,IAAI,KAAK,mBAAmB,EAAE;IAC3CsE,EAAE,GAAGjL,GAAG,CAACkL,QAAQ;IACjBlF,IAAI,GAAG7F,gBAAgB,CAACZ,UAAU,EAAES,GAAG,CAACgG,IAAI,CAAC;IAC7CO,KAAK,GAAGpG,gBAAgB,CAACZ,UAAU,EAAES,GAAG,CAACuG,KAAK,CAAC;IAC/C,IAAIxD,eAAe,CAACF,OAAO,CAACoI,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;MACpCD,IAAI,GAAG,IAAItE,IAAI,CAACrH,kBAAkB,CAACgK,MAAM,EAAE4B,EAAE,EAAEjF,IAAI,EAAEO,KAAK,CAAC;IAC7D;EACF,CAAC,MAAM,IAAIvG,GAAG,CAAC2G,IAAI,KAAK,uBAAuB,EAAE;IAC/C,MAAMH,IAAI,GAAGrG,gBAAgB,CAACZ,UAAU,EAAES,GAAG,CAACwG,IAAI,CAAC;IACnDR,IAAI,GAAG7F,gBAAgB,CAACZ,UAAU,EAAES,GAAG,CAACqL,UAAU,CAAC;IACnD9E,KAAK,GAAGpG,gBAAgB,CAACZ,UAAU,EAAES,GAAG,CAACsL,SAAS,CAAC;IACnDN,IAAI,GAAG,IAAItE,IAAI,CAACrH,kBAAkB,CAACkM,WAAW,EAAE,GAAG,EAAEvF,IAAI,EAAEO,KAAK,EAAEC,IAAI,CAAC;EACzE,CAAC,MAAM,IAAIxG,GAAG,CAAC2G,IAAI,KAAK,kBAAkB,EAAE;IAC1CqE,IAAI,GAAGJ,qBAAqB,CAACrL,UAAU,EAAES,GAAG,CAAC;EAC/C,CAAC,MAAM,IAAIA,GAAG,CAAC2G,IAAI,KAAK,iBAAiB,EAAE;IACzC,MAAM+B,GAAG,GAAG,EAAE;IACd,KAAK,IAAIhB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG1H,GAAG,CAACwL,QAAQ,CAACrK,MAAM,EAAEuG,CAAC,EAAE,EAAE;MAC5CgB,GAAG,CAAChB,CAAC,CAAC,GAAGvH,gBAAgB,CAACZ,UAAU,EAAES,GAAG,CAACwL,QAAQ,CAAC9D,CAAC,CAAC,CAAC;IACxD;IACAsD,IAAI,GAAG,IAAItE,IAAI,CAACrH,kBAAkB,CAACoM,KAAK,EAAE/C,GAAG,CAAC;EAChD,CAAC,MAAM,IAAI1I,GAAG,CAAC2G,IAAI,KAAK,UAAU,EAAE;IAClC;IACA,MAAM,IAAIxH,YAAY,CAAC,iCAAiC,CAAC;EAC3D,CAAC,MAAM;IACL,MAAM,IAAIA,YAAY,CAAC,0BAA0B,CAAC;EACpD;EAEA,OAAO6L,IAAI;AACb;AAEA,SAAS9D,mBAAmBA,CAAC8D,IAAI,EAAE;EACjC,IAAIA,IAAI,CAACpE,KAAK,KAAKvH,kBAAkB,CAACkM,WAAW,EAAE;IACjDP,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACU,oBAAoB;EAC3C,CAAC,MAAM,IAAIV,IAAI,CAACpE,KAAK,KAAKvH,kBAAkB,CAAC0J,aAAa,EAAE;IAC1D,IAAIiC,IAAI,CAACnE,MAAM,KAAK,MAAM,EAAE;MAC1BmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACW,mBAAmB;IAC1C,CAAC,MAAM,IAAIX,IAAI,CAACnE,MAAM,KAAK,MAAM,EAAE;MACjCmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACY,mBAAmB;IAC1C,CAAC,MAAM,IAAIZ,IAAI,CAACnE,MAAM,KAAK,UAAU,EAAE;MACrCmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACa,iBAAiB;IACxC;EACF,CAAC,MAAM,IAAIb,IAAI,CAACpE,KAAK,KAAKvH,kBAAkB,CAAC+J,KAAK,EAAE;IAClD,IAAI4B,IAAI,CAACnE,MAAM,KAAK,GAAG,EAAE;MACvBmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACc,YAAY;IACnC,CAAC,MAAM,IAAId,IAAI,CAACnE,MAAM,KAAK,GAAG,EAAE;MAC9BmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACe,iBAAiB;IACxC,CAAC,MAAM,IAAIf,IAAI,CAACnE,MAAM,KAAK,GAAG,EAAE;MAC9BmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACgB,iBAAiB;IACxC,CAAC,MAAM,IAAIhB,IAAI,CAACnE,MAAM,KAAK,OAAO,EAAE;MAClCmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACiB,YAAY;IACnC,CAAC,MAAM,IAAIjB,IAAI,CAACnE,MAAM,KAAK,UAAU,EAAE;MACrCmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACkB,iBAAiB;IACxC,CAAC,MAAM,IAAIlB,IAAI,CAACnE,MAAM,KAAK,cAAc,EAAE;MACzCmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACmB,qBAAqB;IAC5C,CAAC,MAAM,IAAInB,IAAI,CAACnE,MAAM,KAAK,SAAS,EAAE;MACpCmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACoB,gBAAgB;IACvC,CAAC,MAAM,IAAIpB,IAAI,CAACnE,MAAM,KAAK,mBAAmB,EAAE;MAC9CmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACqB,0BAA0B;IACjD,CAAC,MAAM,IAAIrB,IAAI,CAACnE,MAAM,KAAK,SAAS,EAAE;MACpCmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACsB,0BAA0B;IACjD,CAAC,MAAM,IAAItB,IAAI,CAACnE,MAAM,KAAK,QAAQ,EAAE;MACnCmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACuB,yBAAyB;IAChD,CAAC,MAAM,IAAIvB,IAAI,CAACnE,MAAM,KAAK,QAAQ,EAAE;MACnCmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACwB,yBAAyB;IAChD,CAAC,MAAM,IAAIxN,OAAO,CAACqE,cAAc,CAAC2H,IAAI,CAACnE,MAAM,CAAC,CAAC,EAAE;MAC/CmE,IAAI,CAACvJ,QAAQ,GAAGgL,wBAAwB,CAACzB,IAAI,CAACnE,MAAM,CAAC;IACvD;EACF,CAAC,MAAM,IAAImE,IAAI,CAACpE,KAAK,KAAKvH,kBAAkB,CAACgK,MAAM,EAAE;IACnD,IAAI2B,IAAI,CAACnE,MAAM,KAAK,GAAG,EAAE;MACvBmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAAC0B,aAAa;IACpC,CAAC,MAAM,IAAI1B,IAAI,CAACnE,MAAM,KAAK,GAAG,EAAE;MAC9BmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAAC2B,cAAc;IACrC,CAAC,MAAM,IAAI3B,IAAI,CAACnE,MAAM,KAAK,GAAG,EAAE;MAC9BmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAAC4B,cAAc;IACrC,CAAC,MAAM,IAAI5B,IAAI,CAACnE,MAAM,KAAK,GAAG,EAAE;MAC9BmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAAC6B,eAAe;IACtC,CAAC,MAAM,IAAI7B,IAAI,CAACnE,MAAM,KAAK,GAAG,EAAE;MAC9BmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAAC8B,YAAY;IACnC,CAAC,MAAM,IAAI9B,IAAI,CAACnE,MAAM,KAAK,KAAK,EAAE;MAChCmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAAC+B,qBAAqB;IAC5C,CAAC,MAAM,IAAI/B,IAAI,CAACnE,MAAM,KAAK,KAAK,EAAE;MAChCmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACgC,wBAAwB;IAC/C,CAAC,MAAM,IAAIhC,IAAI,CAACnE,MAAM,KAAK,GAAG,EAAE;MAC9BmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACiC,iBAAiB;IACxC,CAAC,MAAM,IAAIjC,IAAI,CAACnE,MAAM,KAAK,IAAI,EAAE;MAC/BmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACkC,yBAAyB;IAChD,CAAC,MAAM,IAAIlC,IAAI,CAACnE,MAAM,KAAK,GAAG,EAAE;MAC9BmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACmC,oBAAoB;IAC3C,CAAC,MAAM,IAAInC,IAAI,CAACnE,MAAM,KAAK,IAAI,EAAE;MAC/BmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACoC,4BAA4B;IACnD,CAAC,MAAM,IAAIpC,IAAI,CAACnE,MAAM,KAAK,IAAI,EAAE;MAC/BmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACqC,YAAY;IACnC,CAAC,MAAM,IAAIrC,IAAI,CAACnE,MAAM,KAAK,IAAI,EAAE;MAC/BmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACsC,WAAW;IAClC,CAAC,MAAM,IAAItC,IAAI,CAACnE,MAAM,KAAK,IAAI,EAAE;MAC/BmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACuC,oBAAoB;IAC3C,CAAC,MAAM,IAAIvC,IAAI,CAACnE,MAAM,KAAK,IAAI,EAAE;MAC/BmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACwC,uBAAuB;IAC9C,CAAC,MAAM,IAAIxO,OAAO,CAAC8F,eAAe,CAACkG,IAAI,CAACnE,MAAM,CAAC,CAAC,EAAE;MAChDmE,IAAI,CAACvJ,QAAQ,GAAGgM,yBAAyB,CAACzC,IAAI,CAACnE,MAAM,CAAC;IACxD;EACF,CAAC,MAAM,IAAImE,IAAI,CAACpE,KAAK,KAAKvH,kBAAkB,CAACiK,OAAO,EAAE;IACpD0B,IAAI,CAACvJ,QAAQ,GAAGiM,0BAA0B,CAAC1C,IAAI,CAACnE,MAAM,CAAC;EACzD,CAAC,MAAM,IAAImE,IAAI,CAACpE,KAAK,KAAKvH,kBAAkB,CAAC0L,MAAM,EAAE;IACnD,IAAIC,IAAI,CAACnE,MAAM,KAAK,UAAU,EAAE;MAC9BmE,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAAC2C,uBAAuB;IAC9C,CAAC,MAAM;MACL3C,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAAC4C,kBAAkB;IACzC;EACF,CAAC,MAAM,IAAI5C,IAAI,CAACpE,KAAK,KAAKvH,kBAAkB,CAACoM,KAAK,EAAE;IAClDT,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAAC6C,cAAc;EACrC,CAAC,MAAM,IAAI7C,IAAI,CAACpE,KAAK,KAAKvH,kBAAkB,CAAC6K,QAAQ,EAAE;IACrDc,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAAC8C,iBAAiB;EACxC,CAAC,MAAM,IAAI9C,IAAI,CAACpE,KAAK,KAAKvH,kBAAkB,CAAC+I,kBAAkB,EAAE;IAC/D4C,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAAC+C,uBAAuB;EAC9C,CAAC,MAAM,IAAI/C,IAAI,CAACpE,KAAK,KAAKvH,kBAAkB,CAAC2J,aAAa,EAAE;IAC1DgC,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACgD,qBAAqB;EAC5C,CAAC,MAAM,IAAIhD,IAAI,CAACpE,KAAK,KAAKvH,kBAAkB,CAAC8J,cAAc,EAAE;IAC3D6B,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACiD,sBAAsB;EAC7C,CAAC,MAAM,IAAIjD,IAAI,CAACpE,KAAK,KAAKvH,kBAAkB,CAACgJ,cAAc,EAAE;IAC3D2C,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACkD,sBAAsB;EAC7C,CAAC,MAAM,IAAIlD,IAAI,CAACpE,KAAK,KAAKvH,kBAAkB,CAACwK,KAAK,EAAE;IAClDmB,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACmD,eAAe;EACtC,CAAC,MAAM,IAAInD,IAAI,CAACpE,KAAK,KAAKvH,kBAAkB,CAAC4K,gBAAgB,EAAE;IAC7D,IAAIe,IAAI,CAACnE,MAAM,KAAK,sBAAsB,EAAE;MAC1CmE,IAAI,CAACvJ,QAAQ,GAAG2M,mBAAmB;IACrC;EACF,CAAC,MAAM;IACLpD,IAAI,CAACvJ,QAAQ,GAAGuJ,IAAI,CAACqD,gBAAgB;EACvC;AACF;AAEA,SAASD,mBAAmBA,CAAC1M,OAAO,EAAE;EACpC,IAAI,CAAC1C,OAAO,CAAC0C,OAAO,CAAC,EAAE;IACrB,OAAO,GAAG;EACZ;EACA,OAAOA,OAAO,CAAC4M,OAAO,CAACC,OAAO,CAACC,aAAa;AAC9C;AAEA,SAAS/B,wBAAwBA,CAAC1G,IAAI,EAAE;EACtC,MAAMtE,QAAQ,GAAG4B,cAAc,CAAC0C,IAAI,CAAC;EACrC,OAAO,UAAUrE,OAAO,EAAE;IACxB,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;IACzC,OAAOD,QAAQ,CAACsE,IAAI,EAAEC,IAAI,CAAC;EAC7B,CAAC;AACH;AAEA,SAASyH,yBAAyBA,CAAC1H,IAAI,EAAE;EACvC,MAAMtE,QAAQ,GAAGqD,eAAe,CAACiB,IAAI,CAAC;EACtC,OAAO,UAAUrE,OAAO,EAAE;IACxB,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;IACzC,MAAM6E,KAAK,GAAG,IAAI,CAACQ,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC;IAC3C,OAAOD,QAAQ,CAACsE,IAAI,EAAEC,IAAI,EAAEO,KAAK,CAAC;EACpC,CAAC;AACH;AAEA,SAASmH,0BAA0BA,CAAC3H,IAAI,EAAE;EACxC,MAAMtE,QAAQ,GAAG8D,gBAAgB,CAACQ,IAAI,CAAC;EACvC,OAAO,UAAUrE,OAAO,EAAE;IACxB,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;IACzC,MAAM6E,KAAK,GAAG,IAAI,CAACQ,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC;IAC3C,MAAM8E,IAAI,GAAG,IAAI,CAACQ,KAAK,CAACvF,QAAQ,CAACC,OAAO,CAAC;IACzC,OAAOD,QAAQ,CAACsE,IAAI,EAAEC,IAAI,EAAEO,KAAK,EAAEC,IAAI,CAAC;EAC1C,CAAC;AACH;AAEA,SAASiI,kBAAkBA,CAAC/M,OAAO,EAAEmH,IAAI,EAAE;EACzC;EACA,IAAI7J,OAAO,CAAC0C,OAAO,CAAC,EAAE;IACpB,OAAOA,OAAO,CAACgN,oBAAoB,CAAC7F,IAAI,CAAC;EAC3C;AACF;AAEAnC,IAAI,CAACpG,SAAS,CAAC+N,gBAAgB,GAAG,YAAY;EAC5C,OAAO,IAAI,CAACxH,MAAM;AACpB,CAAC;AAEDH,IAAI,CAACpG,SAAS,CAAC0N,qBAAqB,GAAG,UAAUtM,OAAO,EAAE;EACxD,MAAMM,KAAK,GAAGoB,YAAY;EAC1B,MAAMmF,IAAI,GAAG,IAAI,CAACzB,KAAK;EACvB,IAAI,IAAI,CAACD,MAAM,KAAK,OAAO,EAAE;IAC3B,IAAI,CAAC7H,OAAO,CAACuJ,IAAI,CAAC,EAAE;MAClBxJ,KAAK,CAAC4P,SAAS,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE3M,KAAK,CAAC;IAC5C,CAAC,MAAM,IAAIuG,IAAI,CAACpH,MAAM,GAAG,CAAC,EAAE;MAC1BpC,KAAK,CAAC6P,kBAAkB,CAACrG,IAAI,CAAC,CAAC,CAAC,CAAC9G,QAAQ,CAACC,OAAO,CAAC,EAAEM,KAAK,CAAC;MAC1DA,KAAK,CAACiH,KAAK,GAAGV,IAAI,CAAC,CAAC,CAAC,CAAC9G,QAAQ,CAACC,OAAO,CAAC;IACzC,CAAC,MAAM;MACL3C,KAAK,CAAC6P,kBAAkB,CAACrG,IAAI,CAAC,CAAC,CAAC,CAAC9G,QAAQ,CAACC,OAAO,CAAC,EAAEM,KAAK,CAAC;IAC5D;EACF,CAAC,MAAM,IAAI,IAAI,CAAC6E,MAAM,KAAK,KAAK,EAAE;IAChC9H,KAAK,CAAC4P,SAAS,CACbpG,IAAI,CAAC,CAAC,CAAC,CAAC9G,QAAQ,CAACC,OAAO,CAAC,EACzB6G,IAAI,CAAC,CAAC,CAAC,CAAC9G,QAAQ,CAACC,OAAO,CAAC,EACzB6G,IAAI,CAAC,CAAC,CAAC,CAAC9G,QAAQ,CAACC,OAAO,CAAC,EACzB,GAAG,EACHM,KACF,CAAC;EACH,CAAC,MAAM,IAAI,IAAI,CAAC6E,MAAM,KAAK,MAAM,EAAE;IACjC;IACA,MAAMgI,CAAC,GAAGtG,IAAI,CAAC,CAAC,CAAC,CAAC9G,QAAQ,CAACC,OAAO,CAAC,GAAG,GAAG;IACzC3C,KAAK,CAAC4P,SAAS,CACbpG,IAAI,CAAC,CAAC,CAAC,CAAC9G,QAAQ,CAACC,OAAO,CAAC,EACzB6G,IAAI,CAAC,CAAC,CAAC,CAAC9G,QAAQ,CAACC,OAAO,CAAC,EACzB6G,IAAI,CAAC,CAAC,CAAC,CAAC9G,QAAQ,CAACC,OAAO,CAAC,EACzBmN,CAAC,EACD7M,KACF,CAAC;EACH,CAAC,MAAM,IAAI,IAAI,CAAC6E,MAAM,KAAK,KAAK,EAAE;IAChC9H,KAAK,CAAC+P,OAAO,CACXvG,IAAI,CAAC,CAAC,CAAC,CAAC9G,QAAQ,CAACC,OAAO,CAAC,EACzB6G,IAAI,CAAC,CAAC,CAAC,CAAC9G,QAAQ,CAACC,OAAO,CAAC,EACzB6G,IAAI,CAAC,CAAC,CAAC,CAAC9G,QAAQ,CAACC,OAAO,CAAC,EACzB,GAAG,EACHM,KACF,CAAC;EACH,CAAC,MAAM,IAAI,IAAI,CAAC6E,MAAM,KAAK,MAAM,EAAE;IACjC9H,KAAK,CAAC+P,OAAO,CACXvG,IAAI,CAAC,CAAC,CAAC,CAAC9G,QAAQ,CAACC,OAAO,CAAC,EACzB6G,IAAI,CAAC,CAAC,CAAC,CAAC9G,QAAQ,CAACC,OAAO,CAAC,EACzB6G,IAAI,CAAC,CAAC,CAAC,CAAC9G,QAAQ,CAACC,OAAO,CAAC,EACzB6G,IAAI,CAAC,CAAC,CAAC,CAAC9G,QAAQ,CAACC,OAAO,CAAC,EACzBM,KACF,CAAC;EACH;EACA,OAAOnD,UAAU,CAACkQ,SAAS,CAAC/M,KAAK,EAAExB,cAAc,CAACgB,aAAa,CAAC,CAAC,CAAC;AACpE,CAAC;AAEDkF,IAAI,CAACpG,SAAS,CAAC2N,sBAAsB,GAAG,UAAUvM,OAAO,EAAE;EACzD;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA,MAAMsN,UAAU,GAAGxO,cAAc,CAACU,QAAQ,CAAC,CAAC;EAC5C,MAAM6E,IAAI,GAAG,IAAI,CAACc,MAAM;EACxB,MAAM0B,IAAI,GAAG,IAAI,CAACzB,KAAK;EACvB,MAAM2B,UAAU,GAAGF,IAAI,CAACpH,MAAM;EAC9B,KAAK,IAAIuG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,UAAU,EAAE,EAAEf,CAAC,EAAE;IACnC,MAAM9F,KAAK,GAAG2G,IAAI,CAACb,CAAC,CAAC,CAACjG,QAAQ,CAACC,OAAO,CAAC;IACvC,IAAI,OAAOE,KAAK,KAAK,QAAQ,EAAE;MAC7BoN,UAAU,CAAC5N,IAAI,CAACQ,KAAK,CAAC;IACxB,CAAC,MAAM,IAAIA,KAAK,YAAYjD,UAAU,EAAE;MACtCqQ,UAAU,CAAC5N,IAAI,CAACQ,KAAK,CAACsE,CAAC,EAAEtE,KAAK,CAACuE,CAAC,CAAC;IACnC,CAAC,MAAM,IAAIvE,KAAK,YAAYhD,UAAU,EAAE;MACtCoQ,UAAU,CAAC5N,IAAI,CAACQ,KAAK,CAACsE,CAAC,EAAEtE,KAAK,CAACuE,CAAC,EAAEvE,KAAK,CAACwE,CAAC,CAAC;IAC5C,CAAC,MAAM,IAAIxE,KAAK,YAAY/C,UAAU,EAAE;MACtCmQ,UAAU,CAAC5N,IAAI,CAACQ,KAAK,CAACsE,CAAC,EAAEtE,KAAK,CAACuE,CAAC,EAAEvE,KAAK,CAACwE,CAAC,EAAExE,KAAK,CAACyE,CAAC,CAAC;IACrD,CAAC,MAAM;MACL,MAAM,IAAIlH,YAAY,CACpB,GAAG4G,IAAI,qDAAqDnE,KAAK,GACnE,CAAC;IACH;EACF;EAEA,MAAMqN,gBAAgB,GAAGD,UAAU,CAAC7N,MAAM;EAC1C,MAAM+N,YAAY,GAAGC,QAAQ,CAACpJ,IAAI,CAACqJ,MAAM,CAAC,CAAC,CAAC,CAAC;EAE7C,IAAIH,gBAAgB,KAAK,CAAC,EAAE;IAC1B,MAAM,IAAI9P,YAAY,CAAC,WAAW4G,IAAI,mCAAmC,CAAC;EAC5E,CAAC,MAAM,IAAIkJ,gBAAgB,GAAGC,YAAY,IAAID,gBAAgB,GAAG,CAAC,EAAE;IAClE,MAAM,IAAI9P,YAAY,CACpB,WAAW4G,IAAI,qCACjB,CAAC;EACH,CAAC,MAAM,IAAIkJ,gBAAgB,GAAGC,YAAY,IAAIzG,UAAU,GAAG,CAAC,EAAE;IAC5D,MAAM,IAAItJ,YAAY,CAAC,WAAW4G,IAAI,mCAAmC,CAAC;EAC5E;EAEA,IAAIkJ,gBAAgB,KAAK,CAAC,EAAE;IAC1B;IACA,MAAMI,SAAS,GAAGL,UAAU,CAAC,CAAC,CAAC;IAC/BA,UAAU,CAAC5N,IAAI,CAACiO,SAAS,EAAEA,SAAS,EAAEA,SAAS,CAAC;EAClD;EAEA,IAAItJ,IAAI,KAAK,MAAM,EAAE;IACnB,OAAOpH,UAAU,CAAC2Q,SAAS,CAACN,UAAU,EAAE,CAAC,EAAExO,cAAc,CAACc,aAAa,CAAC,CAAC,CAAC;EAC5E,CAAC,MAAM,IAAIyE,IAAI,KAAK,MAAM,EAAE;IAC1B,OAAOnH,UAAU,CAAC0Q,SAAS,CAACN,UAAU,EAAE,CAAC,EAAExO,cAAc,CAACe,aAAa,CAAC,CAAC,CAAC;EAC5E,CAAC,MAAM,IAAIwE,IAAI,KAAK,MAAM,EAAE;IAC1B,OAAOlH,UAAU,CAACyQ,SAAS,CAACN,UAAU,EAAE,CAAC,EAAExO,cAAc,CAACgB,aAAa,CAAC,CAAC,CAAC;EAC5E;AACF,CAAC;AAEDkF,IAAI,CAACpG,SAAS,CAAC4N,sBAAsB,GAAG,YAAY;EAClD,OAAO,IAAI,CAACrH,MAAM;AACpB,CAAC;AAEDH,IAAI,CAACpG,SAAS,CAACyN,uBAAuB,GAAG,UAAUrM,OAAO,EAAE;EAC1D,IAAIC,MAAM,GAAG,IAAI,CAACkF,MAAM;EACxB,IAAI0I,KAAK,GAAGvM,aAAa,CAACwM,IAAI,CAAC7N,MAAM,CAAC;EACtC,OAAO4N,KAAK,KAAK,IAAI,EAAE;IACrB,MAAME,WAAW,GAAGF,KAAK,CAAC,CAAC,CAAC;IAC5B,MAAMG,YAAY,GAAGH,KAAK,CAAC,CAAC,CAAC;IAC7B,IAAI3G,QAAQ,GAAG6F,kBAAkB,CAAC/M,OAAO,EAAEgO,YAAY,CAAC;IACxD,IAAI,CAAC1Q,OAAO,CAAC4J,QAAQ,CAAC,EAAE;MACtBA,QAAQ,GAAG,EAAE;IACf;IACAjH,MAAM,GAAGA,MAAM,CAAC6F,OAAO,CAACiI,WAAW,EAAE7G,QAAQ,CAAC;IAC9C5F,aAAa,CAAC2M,SAAS,IAAI/G,QAAQ,CAACzH,MAAM,GAAGsO,WAAW,CAACtO,MAAM;IAC/DoO,KAAK,GAAGvM,aAAa,CAACwM,IAAI,CAAC7N,MAAM,CAAC;EACpC;EACA,OAAOA,MAAM;AACf,CAAC;AAED+E,IAAI,CAACpG,SAAS,CAACwN,iBAAiB,GAAG,UAAUpM,OAAO,EAAE;EACpD;EACA,OAAO+M,kBAAkB,CAAC/M,OAAO,EAAE,IAAI,CAACmF,MAAM,CAAC;AACjD,CAAC;AAED,SAAS+I,YAAYA,CAAC5P,GAAG,EAAE;EACzB,OAAOA,GAAG,CAAC6G,MAAM,KAAK,SAAS;AACjC;;AAEA;AACAH,IAAI,CAACpG,SAAS,CAACsN,kBAAkB,GAAG,UAAUlM,OAAO,EAAE;EACrD,IAAIkO,YAAY,CAAC,IAAI,CAAC9I,KAAK,CAAC,EAAE;IAC5B,OAAO2H,kBAAkB,CAAC/M,OAAO,EAAE,IAAI,CAACqF,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC,CAAC;EACnE;EACA,MAAMkH,QAAQ,GAAG,IAAI,CAAC9B,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EAC7C,IAAI,CAAC1C,OAAO,CAAC4J,QAAQ,CAAC,EAAE;IACtB,OAAO3B,SAAS;EAClB;EAEA,MAAM4I,MAAM,GAAG,IAAI,CAAC9I,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC;EAC5C,IACEkH,QAAQ,YAAYjK,UAAU,IAC9BiK,QAAQ,YAAYhK,UAAU,IAC9BgK,QAAQ,YAAY/J,UAAU,EAC9B;IACA;IACA,IAAIgR,MAAM,KAAK,GAAG,EAAE;MAClB,OAAOjH,QAAQ,CAAC1C,CAAC;IACnB,CAAC,MAAM,IAAI2J,MAAM,KAAK,GAAG,EAAE;MACzB,OAAOjH,QAAQ,CAACzC,CAAC;IACnB,CAAC,MAAM,IAAI0J,MAAM,KAAK,GAAG,EAAE;MACzB,OAAOjH,QAAQ,CAACxC,CAAC;IACnB,CAAC,MAAM,IAAIyJ,MAAM,KAAK,GAAG,EAAE;MACzB,OAAOjH,QAAQ,CAACvC,CAAC;IACnB;EACF;EACA,OAAOuC,QAAQ,CAACiH,MAAM,CAAC;AACzB,CAAC;AAEDnJ,IAAI,CAACpG,SAAS,CAACqN,uBAAuB,GAAG,UAAUjM,OAAO,EAAE;EAC1D,IAAIkO,YAAY,CAAC,IAAI,CAAC9I,KAAK,CAAC,EAAE;IAC5B,OAAO2H,kBAAkB,CAAC/M,OAAO,EAAE,IAAI,CAACqF,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC,CAAC;EACnE;EACA,MAAMkH,QAAQ,GAAG,IAAI,CAAC9B,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EAC7C,IAAI,CAAC1C,OAAO,CAAC4J,QAAQ,CAAC,EAAE;IACtB,OAAO3B,SAAS;EAClB;EAEA,MAAM4I,MAAM,GAAG,IAAI,CAAC9I,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC;EAC5C,IACEkH,QAAQ,YAAYjK,UAAU,IAC9BiK,QAAQ,YAAYhK,UAAU,IAC9BgK,QAAQ,YAAY/J,UAAU,EAC9B;IACA;IACA;IACA,IAAIgR,MAAM,KAAK,CAAC,IAAIA,MAAM,KAAK,GAAG,EAAE;MAClC,OAAOjH,QAAQ,CAAC1C,CAAC;IACnB,CAAC,MAAM,IAAI2J,MAAM,KAAK,CAAC,IAAIA,MAAM,KAAK,GAAG,EAAE;MACzC,OAAOjH,QAAQ,CAACzC,CAAC;IACnB,CAAC,MAAM,IAAI0J,MAAM,KAAK,CAAC,IAAIA,MAAM,KAAK,GAAG,EAAE;MACzC,OAAOjH,QAAQ,CAACxC,CAAC;IACnB,CAAC,MAAM,IAAIyJ,MAAM,KAAK,CAAC,IAAIA,MAAM,KAAK,GAAG,EAAE;MACzC,OAAOjH,QAAQ,CAACvC,CAAC;IACnB;EACF;EACA,OAAOuC,QAAQ,CAACiH,MAAM,CAAC;AACzB,CAAC;AAEDnJ,IAAI,CAACpG,SAAS,CAACuN,cAAc,GAAG,UAAUnM,OAAO,EAAE;EACjD,MAAML,KAAK,GAAG,EAAE;EAChB,KAAK,IAAIqG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACb,MAAM,CAAC1F,MAAM,EAAEuG,CAAC,EAAE,EAAE;IAC3CrG,KAAK,CAACqG,CAAC,CAAC,GAAG,IAAI,CAACb,MAAM,CAACa,CAAC,CAAC,CAACjG,QAAQ,CAACC,OAAO,CAAC;EAC7C;EACA,OAAOL,KAAK;AACd,CAAC;;AAED;AACA;;AAEAqF,IAAI,CAACpG,SAAS,CAACwL,YAAY,GAAG,UAAUpK,OAAO,EAAE;EAC/C,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EACzC,IAAI,OAAOsE,IAAI,KAAK,SAAS,EAAE;IAC7B,MAAM,IAAI7G,YAAY,CACpB,yDAAyD6G,IAAI,GAC/D,CAAC;EACH;EACA,OAAO,CAACA,IAAI;AACd,CAAC;AAEDU,IAAI,CAACpG,SAAS,CAACyL,iBAAiB,GAAG,UAAUrK,OAAO,EAAE;EACpD,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EACzC,IAAIsE,IAAI,YAAYrH,UAAU,EAAE;IAC9B,OAAOA,UAAU,CAACmR,MAAM,CAAC9J,IAAI,EAAExF,cAAc,CAACc,aAAa,CAAC,CAAC,CAAC;EAChE,CAAC,MAAM,IAAI0E,IAAI,YAAYpH,UAAU,EAAE;IACrC,OAAOA,UAAU,CAACkR,MAAM,CAAC9J,IAAI,EAAExF,cAAc,CAACe,aAAa,CAAC,CAAC,CAAC;EAChE,CAAC,MAAM,IAAIyE,IAAI,YAAYnH,UAAU,EAAE;IACrC,OAAOA,UAAU,CAACiR,MAAM,CAAC9J,IAAI,EAAExF,cAAc,CAACgB,aAAa,CAAC,CAAC,CAAC;EAChE,CAAC,MAAM,IAAI,OAAOwE,IAAI,KAAK,QAAQ,EAAE;IACnC,OAAO,CAACA,IAAI;EACd;EAEA,MAAM,IAAI7G,YAAY,CACpB,kEAAkE6G,IAAI,GACxE,CAAC;AACH,CAAC;AAEDU,IAAI,CAACpG,SAAS,CAAC0L,iBAAiB,GAAG,UAAUtK,OAAO,EAAE;EACpD,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EAEzC,IACE,EACEsE,IAAI,YAAYrH,UAAU,IAC1BqH,IAAI,YAAYpH,UAAU,IAC1BoH,IAAI,YAAYnH,UAAU,IAC1B,OAAOmH,IAAI,KAAK,QAAQ,CACzB,EACD;IACA,MAAM,IAAI7G,YAAY,CACpB,kEAAkE6G,IAAI,GACxE,CAAC;EACH;EAEA,OAAOA,IAAI;AACb,CAAC;AAEDU,IAAI,CAACpG,SAAS,CAAC2M,iBAAiB,GAAG,UAAUvL,OAAO,EAAE;EACpD,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EACzC,MAAM6E,KAAK,GAAG,IAAI,CAACQ,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC;EAE3C,IAAI,OAAOsE,IAAI,KAAK,QAAQ,IAAI,OAAOO,KAAK,KAAK,QAAQ,EAAE;IACzD,MAAM,IAAIpH,YAAY,CACpB,yDAAyD6G,IAAI,QAAQO,KAAK,GAC5E,CAAC;EACH;EAEA,OAAOP,IAAI,GAAGO,KAAK;AACrB,CAAC;AAEDG,IAAI,CAACpG,SAAS,CAAC4M,yBAAyB,GAAG,UAAUxL,OAAO,EAAE;EAC5D,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EACzC,MAAM6E,KAAK,GAAG,IAAI,CAACQ,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC;EAE3C,IAAI,OAAOsE,IAAI,KAAK,QAAQ,IAAI,OAAOO,KAAK,KAAK,QAAQ,EAAE;IACzD,MAAM,IAAIpH,YAAY,CACpB,0DAA0D6G,IAAI,QAAQO,KAAK,GAC7E,CAAC;EACH;EAEA,OAAOP,IAAI,IAAIO,KAAK;AACtB,CAAC;AAEDG,IAAI,CAACpG,SAAS,CAAC6M,oBAAoB,GAAG,UAAUzL,OAAO,EAAE;EACvD,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EACzC,MAAM6E,KAAK,GAAG,IAAI,CAACQ,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC;EAE3C,IAAI,OAAOsE,IAAI,KAAK,QAAQ,IAAI,OAAOO,KAAK,KAAK,QAAQ,EAAE;IACzD,MAAM,IAAIpH,YAAY,CACpB,yDAAyD6G,IAAI,QAAQO,KAAK,GAC5E,CAAC;EACH;EAEA,OAAOP,IAAI,GAAGO,KAAK;AACrB,CAAC;AAEDG,IAAI,CAACpG,SAAS,CAAC8M,4BAA4B,GAAG,UAAU1L,OAAO,EAAE;EAC/D,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EACzC,MAAM6E,KAAK,GAAG,IAAI,CAACQ,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC;EAE3C,IAAI,OAAOsE,IAAI,KAAK,QAAQ,IAAI,OAAOO,KAAK,KAAK,QAAQ,EAAE;IACzD,MAAM,IAAIpH,YAAY,CACpB,0DAA0D6G,IAAI,QAAQO,KAAK,GAC7E,CAAC;EACH;EAEA,OAAOP,IAAI,IAAIO,KAAK;AACtB,CAAC;AAEDG,IAAI,CAACpG,SAAS,CAACgN,WAAW,GAAG,UAAU5L,OAAO,EAAE;EAC9C,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EACzC,IAAI,OAAOsE,IAAI,KAAK,SAAS,EAAE;IAC7B,MAAM,IAAI7G,YAAY,CACpB,+DAA+D6G,IAAI,GACrE,CAAC;EACH;;EAEA;EACA,IAAIA,IAAI,EAAE;IACR,OAAO,IAAI;EACb;EAEA,MAAMO,KAAK,GAAG,IAAI,CAACQ,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC;EAC3C,IAAI,OAAO6E,KAAK,KAAK,SAAS,EAAE;IAC9B,MAAM,IAAIpH,YAAY,CACpB,gEAAgEoH,KAAK,GACvE,CAAC;EACH;EAEA,OAAOP,IAAI,IAAIO,KAAK;AACtB,CAAC;AAEDG,IAAI,CAACpG,SAAS,CAAC+M,YAAY,GAAG,UAAU3L,OAAO,EAAE;EAC/C,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EACzC,IAAI,OAAOsE,IAAI,KAAK,SAAS,EAAE;IAC7B,MAAM,IAAI7G,YAAY,CACpB,+DAA+D6G,IAAI,GACrE,CAAC;EACH;;EAEA;EACA,IAAI,CAACA,IAAI,EAAE;IACT,OAAO,KAAK;EACd;EAEA,MAAMO,KAAK,GAAG,IAAI,CAACQ,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC;EAC3C,IAAI,OAAO6E,KAAK,KAAK,SAAS,EAAE;IAC9B,MAAM,IAAIpH,YAAY,CACpB,gEAAgEoH,KAAK,GACvE,CAAC;EACH;EAEA,OAAOP,IAAI,IAAIO,KAAK;AACtB,CAAC;AAEDG,IAAI,CAACpG,SAAS,CAACoM,aAAa,GAAG,UAAUhL,OAAO,EAAE;EAChD,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EACzC,MAAM6E,KAAK,GAAG,IAAI,CAACQ,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC;EAC3C,IAAI6E,KAAK,YAAY5H,UAAU,IAAIqH,IAAI,YAAYrH,UAAU,EAAE;IAC7D,OAAOA,UAAU,CAACoR,GAAG,CAAC/J,IAAI,EAAEO,KAAK,EAAE/F,cAAc,CAACc,aAAa,CAAC,CAAC,CAAC;EACpE,CAAC,MAAM,IAAIiF,KAAK,YAAY3H,UAAU,IAAIoH,IAAI,YAAYpH,UAAU,EAAE;IACpE,OAAOA,UAAU,CAACmR,GAAG,CAAC/J,IAAI,EAAEO,KAAK,EAAE/F,cAAc,CAACe,aAAa,CAAC,CAAC,CAAC;EACpE,CAAC,MAAM,IAAIgF,KAAK,YAAY1H,UAAU,IAAImH,IAAI,YAAYnH,UAAU,EAAE;IACpE,OAAOA,UAAU,CAACkR,GAAG,CAAC/J,IAAI,EAAEO,KAAK,EAAE/F,cAAc,CAACgB,aAAa,CAAC,CAAC,CAAC;EACpE,CAAC,MAAM,IAAI,OAAOwE,IAAI,KAAK,QAAQ,IAAI,OAAOO,KAAK,KAAK,QAAQ,EAAE;IAChE;IACA,OAAOP,IAAI,GAAGO,KAAK;EACrB,CAAC,MAAM,IAAI,OAAOP,IAAI,KAAK,QAAQ,IAAI,OAAOO,KAAK,KAAK,QAAQ,EAAE;IAChE,OAAOP,IAAI,GAAGO,KAAK;EACrB;EAEA,MAAM,IAAIpH,YAAY,CACpB,sHAAsH6G,IAAI,QAAQO,KAAK,GACzI,CAAC;AACH,CAAC;AAEDG,IAAI,CAACpG,SAAS,CAACqM,cAAc,GAAG,UAAUjL,OAAO,EAAE;EACjD,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EACzC,MAAM6E,KAAK,GAAG,IAAI,CAACQ,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC;EAC3C,IAAI6E,KAAK,YAAY5H,UAAU,IAAIqH,IAAI,YAAYrH,UAAU,EAAE;IAC7D,OAAOA,UAAU,CAACqR,QAAQ,CAAChK,IAAI,EAAEO,KAAK,EAAE/F,cAAc,CAACc,aAAa,CAAC,CAAC,CAAC;EACzE,CAAC,MAAM,IAAIiF,KAAK,YAAY3H,UAAU,IAAIoH,IAAI,YAAYpH,UAAU,EAAE;IACpE,OAAOA,UAAU,CAACoR,QAAQ,CAAChK,IAAI,EAAEO,KAAK,EAAE/F,cAAc,CAACe,aAAa,CAAC,CAAC,CAAC;EACzE,CAAC,MAAM,IAAIgF,KAAK,YAAY1H,UAAU,IAAImH,IAAI,YAAYnH,UAAU,EAAE;IACpE,OAAOA,UAAU,CAACmR,QAAQ,CAAChK,IAAI,EAAEO,KAAK,EAAE/F,cAAc,CAACgB,aAAa,CAAC,CAAC,CAAC;EACzE,CAAC,MAAM,IAAI,OAAOwE,IAAI,KAAK,QAAQ,IAAI,OAAOO,KAAK,KAAK,QAAQ,EAAE;IAChE,OAAOP,IAAI,GAAGO,KAAK;EACrB;EAEA,MAAM,IAAIpH,YAAY,CACpB,qFAAqF6G,IAAI,QAAQO,KAAK,GACxG,CAAC;AACH,CAAC;AAEDG,IAAI,CAACpG,SAAS,CAACsM,cAAc,GAAG,UAAUlL,OAAO,EAAE;EACjD,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EACzC,MAAM6E,KAAK,GAAG,IAAI,CAACQ,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC;EAC3C,IAAI6E,KAAK,YAAY5H,UAAU,IAAIqH,IAAI,YAAYrH,UAAU,EAAE;IAC7D,OAAOA,UAAU,CAACsR,kBAAkB,CAClCjK,IAAI,EACJO,KAAK,EACL/F,cAAc,CAACc,aAAa,CAAC,CAC/B,CAAC;EACH,CAAC,MAAM,IAAIiF,KAAK,YAAY5H,UAAU,IAAI,OAAOqH,IAAI,KAAK,QAAQ,EAAE;IAClE,OAAOrH,UAAU,CAACuR,gBAAgB,CAChC3J,KAAK,EACLP,IAAI,EACJxF,cAAc,CAACc,aAAa,CAAC,CAC/B,CAAC;EACH,CAAC,MAAM,IAAI0E,IAAI,YAAYrH,UAAU,IAAI,OAAO4H,KAAK,KAAK,QAAQ,EAAE;IAClE,OAAO5H,UAAU,CAACuR,gBAAgB,CAChClK,IAAI,EACJO,KAAK,EACL/F,cAAc,CAACc,aAAa,CAAC,CAC/B,CAAC;EACH,CAAC,MAAM,IAAIiF,KAAK,YAAY3H,UAAU,IAAIoH,IAAI,YAAYpH,UAAU,EAAE;IACpE,OAAOA,UAAU,CAACqR,kBAAkB,CAClCjK,IAAI,EACJO,KAAK,EACL/F,cAAc,CAACe,aAAa,CAAC,CAC/B,CAAC;EACH,CAAC,MAAM,IAAIgF,KAAK,YAAY3H,UAAU,IAAI,OAAOoH,IAAI,KAAK,QAAQ,EAAE;IAClE,OAAOpH,UAAU,CAACsR,gBAAgB,CAChC3J,KAAK,EACLP,IAAI,EACJxF,cAAc,CAACe,aAAa,CAAC,CAC/B,CAAC;EACH,CAAC,MAAM,IAAIyE,IAAI,YAAYpH,UAAU,IAAI,OAAO2H,KAAK,KAAK,QAAQ,EAAE;IAClE,OAAO3H,UAAU,CAACsR,gBAAgB,CAChClK,IAAI,EACJO,KAAK,EACL/F,cAAc,CAACe,aAAa,CAAC,CAC/B,CAAC;EACH,CAAC,MAAM,IAAIgF,KAAK,YAAY1H,UAAU,IAAImH,IAAI,YAAYnH,UAAU,EAAE;IACpE,OAAOA,UAAU,CAACoR,kBAAkB,CAClCjK,IAAI,EACJO,KAAK,EACL/F,cAAc,CAACgB,aAAa,CAAC,CAC/B,CAAC;EACH,CAAC,MAAM,IAAI+E,KAAK,YAAY1H,UAAU,IAAI,OAAOmH,IAAI,KAAK,QAAQ,EAAE;IAClE,OAAOnH,UAAU,CAACqR,gBAAgB,CAChC3J,KAAK,EACLP,IAAI,EACJxF,cAAc,CAACgB,aAAa,CAAC,CAC/B,CAAC;EACH,CAAC,MAAM,IAAIwE,IAAI,YAAYnH,UAAU,IAAI,OAAO0H,KAAK,KAAK,QAAQ,EAAE;IAClE,OAAO1H,UAAU,CAACqR,gBAAgB,CAChClK,IAAI,EACJO,KAAK,EACL/F,cAAc,CAACgB,aAAa,CAAC,CAC/B,CAAC;EACH,CAAC,MAAM,IAAI,OAAOwE,IAAI,KAAK,QAAQ,IAAI,OAAOO,KAAK,KAAK,QAAQ,EAAE;IAChE,OAAOP,IAAI,GAAGO,KAAK;EACrB;EAEA,MAAM,IAAIpH,YAAY,CACpB,8HAA8H6G,IAAI,QAAQO,KAAK,GACjJ,CAAC;AACH,CAAC;AAEDG,IAAI,CAACpG,SAAS,CAACuM,eAAe,GAAG,UAAUnL,OAAO,EAAE;EAClD,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EACzC,MAAM6E,KAAK,GAAG,IAAI,CAACQ,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC;EAC3C,IAAI6E,KAAK,YAAY5H,UAAU,IAAIqH,IAAI,YAAYrH,UAAU,EAAE;IAC7D,OAAOA,UAAU,CAACwR,gBAAgB,CAChCnK,IAAI,EACJO,KAAK,EACL/F,cAAc,CAACc,aAAa,CAAC,CAC/B,CAAC;EACH,CAAC,MAAM,IAAI0E,IAAI,YAAYrH,UAAU,IAAI,OAAO4H,KAAK,KAAK,QAAQ,EAAE;IAClE,OAAO5H,UAAU,CAACyR,cAAc,CAC9BpK,IAAI,EACJO,KAAK,EACL/F,cAAc,CAACc,aAAa,CAAC,CAC/B,CAAC;EACH,CAAC,MAAM,IAAIiF,KAAK,YAAY3H,UAAU,IAAIoH,IAAI,YAAYpH,UAAU,EAAE;IACpE,OAAOA,UAAU,CAACuR,gBAAgB,CAChCnK,IAAI,EACJO,KAAK,EACL/F,cAAc,CAACe,aAAa,CAAC,CAC/B,CAAC;EACH,CAAC,MAAM,IAAIyE,IAAI,YAAYpH,UAAU,IAAI,OAAO2H,KAAK,KAAK,QAAQ,EAAE;IAClE,OAAO3H,UAAU,CAACwR,cAAc,CAC9BpK,IAAI,EACJO,KAAK,EACL/F,cAAc,CAACe,aAAa,CAAC,CAC/B,CAAC;EACH,CAAC,MAAM,IAAIgF,KAAK,YAAY1H,UAAU,IAAImH,IAAI,YAAYnH,UAAU,EAAE;IACpE,OAAOA,UAAU,CAACsR,gBAAgB,CAChCnK,IAAI,EACJO,KAAK,EACL/F,cAAc,CAACgB,aAAa,CAAC,CAC/B,CAAC;EACH,CAAC,MAAM,IAAIwE,IAAI,YAAYnH,UAAU,IAAI,OAAO0H,KAAK,KAAK,QAAQ,EAAE;IAClE,OAAO1H,UAAU,CAACuR,cAAc,CAC9BpK,IAAI,EACJO,KAAK,EACL/F,cAAc,CAACgB,aAAa,CAAC,CAC/B,CAAC;EACH,CAAC,MAAM,IAAI,OAAOwE,IAAI,KAAK,QAAQ,IAAI,OAAOO,KAAK,KAAK,QAAQ,EAAE;IAChE,OAAOP,IAAI,GAAGO,KAAK;EACrB;EAEA,MAAM,IAAIpH,YAAY,CACpB,yHAAyH6G,IAAI,QAAQO,KAAK,GAC5I,CAAC;AACH,CAAC;AAEDG,IAAI,CAACpG,SAAS,CAACwM,YAAY,GAAG,UAAUpL,OAAO,EAAE;EAC/C,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EACzC,MAAM6E,KAAK,GAAG,IAAI,CAACQ,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC;EAC3C,IAAI6E,KAAK,YAAY5H,UAAU,IAAIqH,IAAI,YAAYrH,UAAU,EAAE;IAC7D,OAAOA,UAAU,CAACsH,YAAY,CAC5BD,IAAI,CAACE,CAAC,GAAGK,KAAK,CAACL,CAAC,EAChBF,IAAI,CAACG,CAAC,GAAGI,KAAK,CAACJ,CAAC,EAChB3F,cAAc,CAACc,aAAa,CAAC,CAC/B,CAAC;EACH,CAAC,MAAM,IAAIiF,KAAK,YAAY3H,UAAU,IAAIoH,IAAI,YAAYpH,UAAU,EAAE;IACpE,OAAOA,UAAU,CAACqH,YAAY,CAC5BD,IAAI,CAACE,CAAC,GAAGK,KAAK,CAACL,CAAC,EAChBF,IAAI,CAACG,CAAC,GAAGI,KAAK,CAACJ,CAAC,EAChBH,IAAI,CAACI,CAAC,GAAGG,KAAK,CAACH,CAAC,EAChB5F,cAAc,CAACe,aAAa,CAAC,CAC/B,CAAC;EACH,CAAC,MAAM,IAAIgF,KAAK,YAAY1H,UAAU,IAAImH,IAAI,YAAYnH,UAAU,EAAE;IACpE,OAAOA,UAAU,CAACoH,YAAY,CAC5BD,IAAI,CAACE,CAAC,GAAGK,KAAK,CAACL,CAAC,EAChBF,IAAI,CAACG,CAAC,GAAGI,KAAK,CAACJ,CAAC,EAChBH,IAAI,CAACI,CAAC,GAAGG,KAAK,CAACH,CAAC,EAChBJ,IAAI,CAACK,CAAC,GAAGE,KAAK,CAACF,CAAC,EAChB7F,cAAc,CAACgB,aAAa,CAAC,CAC/B,CAAC;EACH,CAAC,MAAM,IAAI,OAAOwE,IAAI,KAAK,QAAQ,IAAI,OAAOO,KAAK,KAAK,QAAQ,EAAE;IAChE,OAAOP,IAAI,GAAGO,KAAK;EACrB;EAEA,MAAM,IAAIpH,YAAY,CACpB,qFAAqF6G,IAAI,QAAQO,KAAK,GACxG,CAAC;AACH,CAAC;AAEDG,IAAI,CAACpG,SAAS,CAACyM,qBAAqB,GAAG,UAAUrL,OAAO,EAAE;EACxD,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EACzC,MAAM6E,KAAK,GAAG,IAAI,CAACQ,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC;EAC3C,IACG6E,KAAK,YAAY5H,UAAU,IAAIqH,IAAI,YAAYrH,UAAU,IACzD4H,KAAK,YAAY3H,UAAU,IAAIoH,IAAI,YAAYpH,UAAW,IAC1D2H,KAAK,YAAY1H,UAAU,IAAImH,IAAI,YAAYnH,UAAW,EAC3D;IACA,OAAOmH,IAAI,CAACqK,MAAM,CAAC9J,KAAK,CAAC;EAC3B;EACA,OAAOP,IAAI,KAAKO,KAAK;AACvB,CAAC;AAEDG,IAAI,CAACpG,SAAS,CAAC0M,wBAAwB,GAAG,UAAUtL,OAAO,EAAE;EAC3D,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EACzC,MAAM6E,KAAK,GAAG,IAAI,CAACQ,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC;EAC3C,IACG6E,KAAK,YAAY5H,UAAU,IAAIqH,IAAI,YAAYrH,UAAU,IACzD4H,KAAK,YAAY3H,UAAU,IAAIoH,IAAI,YAAYpH,UAAW,IAC1D2H,KAAK,YAAY1H,UAAU,IAAImH,IAAI,YAAYnH,UAAW,EAC3D;IACA,OAAO,CAACmH,IAAI,CAACqK,MAAM,CAAC9J,KAAK,CAAC;EAC5B;EACA,OAAOP,IAAI,KAAKO,KAAK;AACvB,CAAC;AAEDG,IAAI,CAACpG,SAAS,CAACoL,oBAAoB,GAAG,UAAUhK,OAAO,EAAE;EACvD,MAAM8E,IAAI,GAAG,IAAI,CAACQ,KAAK,CAACvF,QAAQ,CAACC,OAAO,CAAC;EAEzC,IAAI,OAAO8E,IAAI,KAAK,SAAS,EAAE;IAC7B,MAAM,IAAIrH,YAAY,CACpB,iFAAiFqH,IAAI,GACvF,CAAC;EACH;EAEA,IAAIA,IAAI,EAAE;IACR,OAAO,IAAI,CAACM,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EACrC;EACA,OAAO,IAAI,CAACqF,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC;AACtC,CAAC;AAEDgF,IAAI,CAACpG,SAAS,CAAC2L,YAAY,GAAG,UAAUvK,OAAO,EAAE;EAC/C,OAAO4O,KAAK,CAAC,IAAI,CAACxJ,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC,CAAC;AAC5C,CAAC;AAEDgF,IAAI,CAACpG,SAAS,CAAC4L,iBAAiB,GAAG,UAAUxK,OAAO,EAAE;EACpD,OAAO6O,QAAQ,CAAC,IAAI,CAACzJ,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC,CAAC;AAC/C,CAAC;AAEDgF,IAAI,CAACpG,SAAS,CAAC6L,qBAAqB,GAAG,UAAUzK,OAAO,EAAE;EACxD,IAAI1C,OAAO,CAAC0C,OAAO,CAAC,EAAE;IACpB,OAAOA,OAAO,CAAC8O,YAAY,CAAC,IAAI,CAAC1J,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC,CAAC;EAC3D;EACA,OAAO,KAAK;AACd,CAAC;AAEDgF,IAAI,CAACpG,SAAS,CAAC8L,gBAAgB,GAAG,UAAU1K,OAAO,EAAE;EACnD,IAAI1C,OAAO,CAAC0C,OAAO,CAAC,EAAE;IACpB,OAAOA,OAAO,CAAC+O,OAAO,CAAC,IAAI,CAAC3J,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC,CAAC;EACtD;EACA,OAAO,KAAK;AACd,CAAC;AAEDgF,IAAI,CAACpG,SAAS,CAAC+L,0BAA0B,GAAG,UAAU3K,OAAO,EAAE;EAC7D,IAAI1C,OAAO,CAAC0C,OAAO,CAAC,EAAE;IACpB,OAAOA,OAAO,CAACgP,iBAAiB,CAAC,CAAC;EACpC;AACF,CAAC;AAEDhK,IAAI,CAACpG,SAAS,CAACgM,0BAA0B,GAAG,UAAU5K,OAAO,EAAE;EAC7D,OAAOiP,OAAO,CAAC,IAAI,CAAC7J,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC,CAAC;AAC9C,CAAC;AAEDgF,IAAI,CAACpG,SAAS,CAACiM,yBAAyB,GAAG,UAAU7K,OAAO,EAAE;EAC5D,OAAOgJ,MAAM,CAAC,IAAI,CAAC5D,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC,CAAC;AAC7C,CAAC;AAEDgF,IAAI,CAACpG,SAAS,CAACkM,yBAAyB,GAAG,UAAU9K,OAAO,EAAE;EAC5D,OAAOkI,MAAM,CAAC,IAAI,CAAC9C,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC,CAAC;AAC7C,CAAC;AAEDgF,IAAI,CAACpG,SAAS,CAAC6N,eAAe,GAAG,UAAUzM,OAAO,EAAE;EAClD,MAAM+H,OAAO,GAAG,IAAI,CAAC5C,MAAM,CAACpF,QAAQ,CAACC,OAAO,CAAC;EAC7C,IAAIgI,KAAK,GAAG,EAAE;EAEd,IAAI1K,OAAO,CAAC,IAAI,CAAC8H,KAAK,CAAC,EAAE;IACvB4C,KAAK,GAAG,IAAI,CAAC5C,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EACtC;EAEA,IAAI8C,GAAG;EACP,IAAI;IACFA,GAAG,GAAG,IAAI8C,MAAM,CAACmC,OAAO,EAAEC,KAAK,CAAC;EAClC,CAAC,CAAC,OAAOzJ,CAAC,EAAE;IACV,MAAM,IAAId,YAAY,CAACc,CAAC,CAAC;EAC3B;EACA,OAAOuE,GAAG;AACZ,CAAC;AAEDkC,IAAI,CAACpG,SAAS,CAACqL,mBAAmB,GAAG,UAAUjK,OAAO,EAAE;EACtD,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EACzC,MAAM6E,KAAK,GAAG,IAAI,CAACQ,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC;EAE3C,IAAI,EAAEsE,IAAI,YAAYsB,MAAM,IAAI,OAAOf,KAAK,KAAK,QAAQ,CAAC,EAAE;IAC1D,MAAM,IAAIpH,YAAY,CACpB,gHAAgH6G,IAAI,QAAQO,KAAK,GACnI,CAAC;EACH;EAEA,OAAOP,IAAI,CAACQ,IAAI,CAACD,KAAK,CAAC;AACzB,CAAC;AAEDG,IAAI,CAACpG,SAAS,CAACiN,oBAAoB,GAAG,UAAU7L,OAAO,EAAE;EACvD,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EACzC,MAAM6E,KAAK,GAAG,IAAI,CAACQ,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC;EAE3C,IAAIsE,IAAI,YAAYsB,MAAM,IAAI,OAAOf,KAAK,KAAK,QAAQ,EAAE;IACvD,OAAOP,IAAI,CAACQ,IAAI,CAACD,KAAK,CAAC;EACzB,CAAC,MAAM,IAAIA,KAAK,YAAYe,MAAM,IAAI,OAAOtB,IAAI,KAAK,QAAQ,EAAE;IAC9D,OAAOO,KAAK,CAACC,IAAI,CAACR,IAAI,CAAC;EACzB;EAEA,MAAM,IAAI7G,YAAY,CACpB,qFAAqF6G,IAAI,QAAQO,KAAK,GACxG,CAAC;AACH,CAAC;AAEDG,IAAI,CAACpG,SAAS,CAACkN,uBAAuB,GAAG,UAAU9L,OAAO,EAAE;EAC1D,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EACzC,MAAM6E,KAAK,GAAG,IAAI,CAACQ,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC;EAE3C,IAAIsE,IAAI,YAAYsB,MAAM,IAAI,OAAOf,KAAK,KAAK,QAAQ,EAAE;IACvD,OAAO,CAACP,IAAI,CAACQ,IAAI,CAACD,KAAK,CAAC;EAC1B,CAAC,MAAM,IAAIA,KAAK,YAAYe,MAAM,IAAI,OAAOtB,IAAI,KAAK,QAAQ,EAAE;IAC9D,OAAO,CAACO,KAAK,CAACC,IAAI,CAACR,IAAI,CAAC;EAC1B;EAEA,MAAM,IAAI7G,YAAY,CACpB,qFAAqF6G,IAAI,QAAQO,KAAK,GACxG,CAAC;AACH,CAAC;AAEDG,IAAI,CAACpG,SAAS,CAACsL,mBAAmB,GAAG,UAAUlK,OAAO,EAAE;EACtD,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EACzC,MAAM6E,KAAK,GAAG,IAAI,CAACQ,MAAM,CAACtF,QAAQ,CAACC,OAAO,CAAC;EAE3C,IAAI,EAAEsE,IAAI,YAAYsB,MAAM,IAAI,OAAOf,KAAK,KAAK,QAAQ,CAAC,EAAE;IAC1D,MAAM,IAAIpH,YAAY,CACpB,gHAAgH6G,IAAI,QAAQO,KAAK,GACnI,CAAC;EACH;EAEA,MAAMiJ,IAAI,GAAGxJ,IAAI,CAACwJ,IAAI,CAACjJ,KAAK,CAAC;EAC7B,IAAI,CAACvH,OAAO,CAACwQ,IAAI,CAAC,EAAE;IAClB,OAAO,IAAI;EACb;EACA,OAAOA,IAAI,CAAC,CAAC,CAAC;AAChB,CAAC;AAED9I,IAAI,CAACpG,SAAS,CAACuL,iBAAiB,GAAG,UAAUnK,OAAO,EAAE;EACpD,MAAMsE,IAAI,GAAG,IAAI,CAACc,KAAK,CAACrF,QAAQ,CAACC,OAAO,CAAC;EACzC,IACEsE,IAAI,YAAYsB,MAAM,IACtBtB,IAAI,YAAYrH,UAAU,IAC1BqH,IAAI,YAAYpH,UAAU,IAC1BoH,IAAI,YAAYnH,UAAU,EAC1B;IACA,OAAO+K,MAAM,CAAC5D,IAAI,CAAC;EACrB;EAEA,MAAM,IAAI7G,YAAY,CAAC,6BAA6B,IAAI,CAAC0H,MAAM,IAAI,CAAC;AACtE,CAAC;AAED,SAAS+J,eAAeA,CAAC5Q,GAAG,EAAE;EAC5B;EACA;EACA,MAAM6Q,QAAQ,GAAG7Q,GAAG,CAAC8G,KAAK;EAC1B,MAAM3F,MAAM,GAAG0P,QAAQ,CAAC1P,MAAM;EAC9B,KAAK,IAAIuG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGvG,MAAM,EAAE,EAAEuG,CAAC,EAAE;IAC/B,IAAImJ,QAAQ,CAACnJ,CAAC,CAAC,CAACd,KAAK,KAAKvH,kBAAkB,CAAC8I,cAAc,EAAE;MAC3D,OAAOlB,SAAS;IAClB;EACF;EACA,MAAM6J,CAAC,GAAGD,QAAQ,CAAC,CAAC,CAAC,CAAChK,MAAM;EAC5B,MAAMkK,CAAC,GAAGF,QAAQ,CAAC,CAAC,CAAC,CAAChK,MAAM;EAC5B,MAAMmK,CAAC,GAAGH,QAAQ,CAAC,CAAC,CAAC,CAAChK,MAAM;EAC5B,MAAMgI,CAAC,GAAG1N,MAAM,KAAK,CAAC,GAAG0P,QAAQ,CAAC,CAAC,CAAC,CAAChK,MAAM,GAAG,GAAG;EACjD,OAAO9H,KAAK,CAAC+P,OAAO,CAACgC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEnC,CAAC,EAAEzL,YAAY,CAAC;AAChD;AAEA,SAAS6N,iBAAiBA,CAACjR,GAAG,EAAE;EAC9B;EACA;EACA,MAAM6Q,QAAQ,GAAG7Q,GAAG,CAAC8G,KAAK;EAC1B,MAAM3F,MAAM,GAAG0P,QAAQ,CAAC1P,MAAM;EAC9B,KAAK,IAAIuG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGvG,MAAM,EAAE,EAAEuG,CAAC,EAAE;IAC/B,IAAImJ,QAAQ,CAACnJ,CAAC,CAAC,CAACd,KAAK,KAAKvH,kBAAkB,CAAC8I,cAAc,EAAE;MAC3D,OAAOlB,SAAS;IAClB;EACF;EACA,MAAMjF,KAAK,GAAGoB,YAAY;EAC1BpB,KAAK,CAACkP,GAAG,GAAGL,QAAQ,CAAC,CAAC,CAAC,CAAChK,MAAM,GAAG,KAAK;EACtC7E,KAAK,CAACmP,KAAK,GAAGN,QAAQ,CAAC,CAAC,CAAC,CAAChK,MAAM,GAAG,KAAK;EACxC7E,KAAK,CAACoP,IAAI,GAAGP,QAAQ,CAAC,CAAC,CAAC,CAAChK,MAAM,GAAG,KAAK;EACvC7E,KAAK,CAACiH,KAAK,GAAG9H,MAAM,KAAK,CAAC,GAAG0P,QAAQ,CAAC,CAAC,CAAC,CAAChK,MAAM,GAAG,GAAG;EACrD,OAAO7E,KAAK;AACd;AAEA,SAASqP,cAAcA,CAACzL,MAAM,EAAE;EAC9B,IAAIA,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;IACpB;IACA,OAAOA,MAAM,CAAC0L,OAAO,CAAC,CAAC,CAAC;EAC1B;EAEA,OAAO1L,MAAM,CAAC2L,QAAQ,CAAC,CAAC;AAC1B;AAEA,SAASC,WAAWA,CAACxP,KAAK,EAAE;EAC1B,MAAMyP,CAAC,GAAGJ,cAAc,CAACrP,KAAK,CAACkP,GAAG,CAAC;EACnC,MAAMQ,CAAC,GAAGL,cAAc,CAACrP,KAAK,CAACmP,KAAK,CAAC;EACrC,MAAMQ,CAAC,GAAGN,cAAc,CAACrP,KAAK,CAACoP,IAAI,CAAC;EACpC,OAAO,QAAQK,CAAC,KAAKC,CAAC,KAAKC,CAAC,GAAG;AACjC;AAEA,SAASC,WAAWA,CAAC5P,KAAK,EAAE;EAC1B,MAAMyP,CAAC,GAAGJ,cAAc,CAACrP,KAAK,CAACkP,GAAG,CAAC;EACnC,MAAMQ,CAAC,GAAGL,cAAc,CAACrP,KAAK,CAACmP,KAAK,CAAC;EACrC,MAAMQ,CAAC,GAAGN,cAAc,CAACrP,KAAK,CAACoP,IAAI,CAAC;EACpC,MAAMvC,CAAC,GAAGwC,cAAc,CAACrP,KAAK,CAACiH,KAAK,CAAC;EACrC,OAAO,QAAQwI,CAAC,KAAKC,CAAC,KAAKC,CAAC,KAAK9C,CAAC,GAAG;AACvC;AAEA,SAASgD,kBAAkBA,CACzBxQ,KAAK,EACLc,uBAAuB,EACvBC,WAAW,EACX0P,MAAM,EACN;EACA,MAAM3Q,MAAM,GAAGE,KAAK,CAACF,MAAM;EAC3B,MAAM4Q,WAAW,GAAG,IAAI7I,KAAK,CAAC/H,MAAM,CAAC;EACrC,KAAK,IAAIuG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGvG,MAAM,EAAE,EAAEuG,CAAC,EAAE;IAC/BqK,WAAW,CAACrK,CAAC,CAAC,GAAGrG,KAAK,CAACqG,CAAC,CAAC,CAACnF,mBAAmB,CAC3CJ,uBAAuB,EACvBC,WAAW,EACX0P,MACF,CAAC;EACH;EACA,OAAOC,WAAW;AACpB;AAEA,SAASC,eAAeA,CAACtC,YAAY,EAAEvN,uBAAuB,EAAE;EAC9D,IAAI,CAACnD,OAAO,CAACmD,uBAAuB,CAACuN,YAAY,CAAC,CAAC,EAAE;IACnD,OAAOpQ,UAAU,CAAC2S,aAAa;EACjC;EAEA,OAAO9P,uBAAuB,CAACuN,YAAY,CAAC;AAC9C;;AAEA;AACA;AACA;AACApQ,UAAU,CAAC2S,aAAa,GAAG,cAAc,CAAC,CAAC;;AAE3CvL,IAAI,CAACpG,SAAS,CAACiC,mBAAmB,GAAG,UACnCJ,uBAAuB,EACvBC,WAAW,EACX0P,MAAM,EACN;EACA,IAAI9P,KAAK;EACT,IAAIgE,IAAI;EACR,IAAIO,KAAK;EACT,IAAIC,IAAI;EAER,MAAMG,IAAI,GAAG,IAAI,CAACC,KAAK;EACvB,IAAIhF,KAAK,GAAG,IAAI,CAACiF,MAAM;EAEvB,IAAI7H,OAAO,CAAC,IAAI,CAAC8H,KAAK,CAAC,EAAE;IACvB,IAAIoC,KAAK,CAACgJ,OAAO,CAAC,IAAI,CAACpL,KAAK,CAAC,EAAE;MAC7B;MACAd,IAAI,GAAG6L,kBAAkB,CACvB,IAAI,CAAC/K,KAAK,EACV3E,uBAAuB,EACvBC,WAAW,EACX,IACF,CAAC;IACH,CAAC,MAAM;MACL4D,IAAI,GAAG,IAAI,CAACc,KAAK,CAACvE,mBAAmB,CACnCJ,uBAAuB,EACvBC,WAAW,EACX,IACF,CAAC;IACH;EACF;EAEA,IAAIpD,OAAO,CAAC,IAAI,CAAC+H,MAAM,CAAC,EAAE;IACxBR,KAAK,GAAG,IAAI,CAACQ,MAAM,CAACxE,mBAAmB,CACrCJ,uBAAuB,EACvBC,WAAW,EACX,IACF,CAAC;EACH;EAEA,IAAIpD,OAAO,CAAC,IAAI,CAACgI,KAAK,CAAC,EAAE;IACvBR,IAAI,GAAG,IAAI,CAACQ,KAAK,CAACzE,mBAAmB,CACnCJ,uBAAuB,EACvBC,WAAW,EACX,IACF,CAAC;EACH;EAEA,IAAI8G,KAAK,CAACgJ,OAAO,CAAC,IAAI,CAACrL,MAAM,CAAC,EAAE;IAC9B;IACAjF,KAAK,GAAGiQ,kBAAkB,CACxB,IAAI,CAAChL,MAAM,EACX1E,uBAAuB,EACvBC,WAAW,EACX,IACF,CAAC;EACH;EAEA,IAAImG,IAAI;EACR,IAAIpH,MAAM;EACV,IAAIgR,gBAAgB;EACpB,QAAQxL,IAAI;IACV,KAAKtH,kBAAkB,CAAC6K,QAAQ;MAC9B,IAAI0F,YAAY,CAAC,IAAI,CAAC,EAAE;QACtB,OAAO3I,SAAS;MAClB;MACA,OAAO+K,eAAe,CAACpQ,KAAK,EAAEO,uBAAuB,CAAC;IACxD,KAAK9C,kBAAkB,CAAC+J,KAAK;MAC3B;MACA,IAAIxH,KAAK,KAAK,SAAS,EAAE;QACvB,OAAO,QAAQoE,IAAI,GAAG;MACxB,CAAC,MAAM,IAAIpE,KAAK,KAAK,QAAQ,EAAE;QAC7B,OAAO,SAASoE,IAAI,GAAG;MACzB,CAAC,MAAM,IAAIpE,KAAK,KAAK,OAAO,EAAE;QAC5B,OAAO,SAASoE,IAAI,SAAS;MAC/B,CAAC,MAAM,IAAIhH,OAAO,CAACqE,cAAc,CAACzB,KAAK,CAAC,CAAC,EAAE;QACzC,OAAO,GAAGA,KAAK,IAAIoE,IAAI,GAAG;MAC5B,CAAC,MAAM,IAAIpE,KAAK,KAAK,OAAO,EAAE;QAC5B;QACA,OAAO,IAAIoE,IAAI,OAAOA,IAAI,GAAG;MAC/B,CAAC,MAAM,IAAIpE,KAAK,KAAK,UAAU,EAAE;QAC/B;QACA,OAAO,QAAQoE,IAAI,mBAAmB;MACxC,CAAC,MAAM,IACLpE,KAAK,KAAK,QAAQ,IAClBA,KAAK,KAAK,cAAc,IACxBA,KAAK,KAAK,SAAS,IACnBA,KAAK,KAAK,mBAAmB,EAC7B;QACA,MAAM,IAAIzC,YAAY,CACpB,mCAAmCyC,KAAK,qBAC1C,CAAC;MACH;MACA,OAAOA,KAAK,GAAGoE,IAAI;IACrB,KAAK3G,kBAAkB,CAACgK,MAAM;MAC5B;MACA,IAAIzH,KAAK,KAAK,GAAG,EAAE;QACjB,OAAO,OAAOoE,IAAI,KAAKO,KAAK,GAAG;MACjC,CAAC,MAAM,IAAI3E,KAAK,KAAK,KAAK,EAAE;QAC1B,OAAO,IAAIoE,IAAI,OAAOO,KAAK,GAAG;MAChC,CAAC,MAAM,IAAI3E,KAAK,KAAK,KAAK,EAAE;QAC1B,OAAO,IAAIoE,IAAI,OAAOO,KAAK,GAAG;MAChC,CAAC,MAAM,IAAI3E,KAAK,KAAK,OAAO,EAAE;QAC5B,OAAO,QAAQoE,IAAI,KAAKO,KAAK,GAAG;MAClC,CAAC,MAAM,IAAIvH,OAAO,CAAC8F,eAAe,CAAClD,KAAK,CAAC,CAAC,EAAE;QAC1C,OAAO,GAAGA,KAAK,IAAIoE,IAAI,KAAKO,KAAK,GAAG;MACtC;MACA,OAAO,IAAIP,IAAI,IAAIpE,KAAK,IAAI2E,KAAK,GAAG;IACtC,KAAKlH,kBAAkB,CAACiK,OAAO;MAC7B,IAAItK,OAAO,CAACuG,gBAAgB,CAAC3D,KAAK,CAAC,CAAC,EAAE;QACpC,OAAO,GAAGA,KAAK,IAAIoE,IAAI,KAAKO,KAAK,KAAKC,IAAI,GAAG;MAC/C;MACA;IACF,KAAKnH,kBAAkB,CAACkM,WAAW;MACjC,OAAO,IAAI/E,IAAI,MAAMR,IAAI,MAAMO,KAAK,GAAG;IACzC,KAAKlH,kBAAkB,CAAC0L,MAAM;MAC5B,IAAI6E,YAAY,CAAC,IAAI,CAAC9I,KAAK,CAAC,EAAE;QAC5B,OAAOkL,eAAe,CAACzL,KAAK,EAAEpE,uBAAuB,CAAC;MACxD;MACA;MACA;MACA,IAAIoE,KAAK,KAAK,GAAG,IAAIA,KAAK,KAAK,GAAG,IAAIA,KAAK,KAAK,KAAK,EAAE;QACrD,OAAO,GAAGP,IAAI,KAAK;MACrB,CAAC,MAAM,IAAIO,KAAK,KAAK,GAAG,IAAIA,KAAK,KAAK,GAAG,IAAIA,KAAK,KAAK,KAAK,EAAE;QAC5D,OAAO,GAAGP,IAAI,KAAK;MACrB,CAAC,MAAM,IAAIO,KAAK,KAAK,GAAG,IAAIA,KAAK,KAAK,GAAG,IAAIA,KAAK,KAAK,KAAK,EAAE;QAC5D,OAAO,GAAGP,IAAI,KAAK;MACrB,CAAC,MAAM,IAAIO,KAAK,KAAK,GAAG,IAAIA,KAAK,KAAK,GAAG,IAAIA,KAAK,KAAK,KAAK,EAAE;QAC5D,OAAO,GAAGP,IAAI,KAAK;MACrB;MACA,OAAO,GAAGA,IAAI,QAAQO,KAAK,IAAI;IACjC,KAAKlH,kBAAkB,CAAC0J,aAAa;MACnC,MAAM,IAAI5J,YAAY,CACpB,mCAAmCyC,KAAK,qBAC1C,CAAC;IACH,KAAKvC,kBAAkB,CAACoM,KAAK;MAC3B,IAAI7J,KAAK,CAACT,MAAM,KAAK,CAAC,EAAE;QACtB,OAAO,QAAQS,KAAK,CAAC,CAAC,CAAC,KAAKA,KAAK,CAAC,CAAC,CAAC,KAAKA,KAAK,CAAC,CAAC,CAAC,KAAKA,KAAK,CAAC,CAAC,CAAC,GAAG;MACnE,CAAC,MAAM,IAAIA,KAAK,CAACT,MAAM,KAAK,CAAC,EAAE;QAC7B,OAAO,QAAQS,KAAK,CAAC,CAAC,CAAC,KAAKA,KAAK,CAAC,CAAC,CAAC,KAAKA,KAAK,CAAC,CAAC,CAAC,GAAG;MACtD,CAAC,MAAM,IAAIA,KAAK,CAACT,MAAM,KAAK,CAAC,EAAE;QAC7B,OAAO,QAAQS,KAAK,CAAC,CAAC,CAAC,KAAKA,KAAK,CAAC,CAAC,CAAC,GAAG;MACzC;MACA,MAAM,IAAIzC,YAAY,CACpB,yFACF,CAAC;IACH,KAAKE,kBAAkB,CAACwK,KAAK;MAC3B,MAAM,IAAI1K,YAAY,CACpB,uEACF,CAAC;IACH,KAAKE,kBAAkB,CAAC+I,kBAAkB;MACxC,MAAM,IAAIjJ,YAAY,CACpB,oFACF,CAAC;IACH,KAAKE,kBAAkB,CAAC4I,YAAY;MAClC,OAAO3I,UAAU,CAAC2S,aAAa;IACjC,KAAK5S,kBAAkB,CAAC6I,eAAe;MACrC,OAAOtG,KAAK,GAAG,MAAM,GAAG,OAAO;IACjC,KAAKvC,kBAAkB,CAAC8I,cAAc;MACpC,OAAOkJ,cAAc,CAACzP,KAAK,CAAC;IAC9B,KAAKvC,kBAAkB,CAACgJ,cAAc;MACpC,IAAIrJ,OAAO,CAAC8S,MAAM,CAAC,IAAIA,MAAM,CAAClL,KAAK,KAAKvH,kBAAkB,CAAC0L,MAAM,EAAE;QACjE,IACEnJ,KAAK,KAAK,GAAG,IACbA,KAAK,KAAK,GAAG,IACbA,KAAK,KAAK,GAAG,IACbA,KAAK,KAAK,GAAG,IACbA,KAAK,KAAK,GAAG,IACbA,KAAK,KAAK,GAAG,IACbA,KAAK,KAAK,GAAG,IACbA,KAAK,KAAK,GAAG,IACbgO,YAAY,CAACkC,MAAM,CAAChL,KAAK,CAAC,EAC1B;UACA,OAAOlF,KAAK;QACd;MACF;MACA;MACAI,KAAK,GAAGjD,KAAK,CAAC6P,kBAAkB,CAAChN,KAAK,EAAEwB,YAAY,CAAC;MACrD,IAAIpE,OAAO,CAACgD,KAAK,CAAC,EAAE;QAClB,OAAOwP,WAAW,CAACxP,KAAK,CAAC;MAC3B;MACA,MAAM,IAAI7C,YAAY,CACpB,mEACF,CAAC;IACH,KAAKE,kBAAkB,CAAC2J,aAAa;MACnCT,IAAI,GAAGvC,IAAI;MACX,IAAIpE,KAAK,KAAK,OAAO,EAAE;QACrB,IAAI,CAAC5C,OAAO,CAACuJ,IAAI,CAAC,EAAE;UAClB,OAAO,WAAW;QACpB,CAAC,MAAM,IAAIA,IAAI,CAACpH,MAAM,GAAG,CAAC,EAAE;UAC1B,MAAMiR,GAAG,GAAG7J,IAAI,CAAC,CAAC,CAAC;UACnB,MAAMU,KAAK,GAAGV,IAAI,CAAC,CAAC,CAAC;UACrB,IAAIU,KAAK,KAAK,KAAK,EAAE;YACnB7G,WAAW,CAACiQ,WAAW,GAAG,IAAI;UAChC;UACA,OAAO,QAAQD,GAAG,KAAKnJ,KAAK,GAAG;QACjC;QACA,OAAO,QAAQV,IAAI,CAAC,CAAC,CAAC,QAAQ;MAChC,CAAC,MAAM,IAAI3G,KAAK,KAAK,KAAK,EAAE;QAC1BI,KAAK,GAAGiP,iBAAiB,CAAC,IAAI,CAAC;QAC/B,IAAIjS,OAAO,CAACgD,KAAK,CAAC,EAAE;UAClB,OAAO4P,WAAW,CAAC5P,KAAK,CAAC;QAC3B;QACA,OAAO,QAAQuG,IAAI,CAAC,CAAC,CAAC,aAAaA,IAAI,CAAC,CAAC,CAAC,aAAaA,IAAI,CAAC,CAAC,CAAC,gBAAgB;MAChF,CAAC,MAAM,IAAI3G,KAAK,KAAK,MAAM,EAAE;QAC3B,IAAI2G,IAAI,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE;UACrBnG,WAAW,CAACiQ,WAAW,GAAG,IAAI;QAChC;QACArQ,KAAK,GAAGiP,iBAAiB,CAAC,IAAI,CAAC;QAC/B,IAAIjS,OAAO,CAACgD,KAAK,CAAC,EAAE;UAClB,OAAO4P,WAAW,CAAC5P,KAAK,CAAC;QAC3B;QACA,OAAO,QAAQuG,IAAI,CAAC,CAAC,CAAC,aAAaA,IAAI,CAAC,CAAC,CAAC,aAAaA,IAAI,CAAC,CAAC,CAAC,aAAaA,IAAI,CAAC,CAAC,CAAC,GAAG;MACvF,CAAC,MAAM,IAAI3G,KAAK,KAAK,KAAK,EAAE;QAC1BI,KAAK,GAAG4O,eAAe,CAAC,IAAI,CAAC;QAC7B,IAAI5R,OAAO,CAACgD,KAAK,CAAC,EAAE;UAClB,OAAO4P,WAAW,CAAC5P,KAAK,CAAC;QAC3B;QACA,OAAO,0BAA0BuG,IAAI,CAAC,CAAC,CAAC,KAAKA,IAAI,CAAC,CAAC,CAAC,KAAKA,IAAI,CAAC,CAAC,CAAC,UAAU;MAC5E,CAAC,MAAM,IAAI3G,KAAK,KAAK,MAAM,EAAE;QAC3BI,KAAK,GAAG4O,eAAe,CAAC,IAAI,CAAC;QAC7B,IAAI5R,OAAO,CAACgD,KAAK,CAAC,EAAE;UAClB,IAAIA,KAAK,CAACiH,KAAK,KAAK,GAAG,EAAE;YACvB7G,WAAW,CAACiQ,WAAW,GAAG,IAAI;UAChC;UACA,OAAOT,WAAW,CAAC5P,KAAK,CAAC;QAC3B;QACA,IAAIuG,IAAI,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE;UACrBnG,WAAW,CAACiQ,WAAW,GAAG,IAAI;QAChC;QACA,OAAO,0BAA0B9J,IAAI,CAAC,CAAC,CAAC,KAAKA,IAAI,CAAC,CAAC,CAAC,KAAKA,IAAI,CAAC,CAAC,CAAC,OAAOA,IAAI,CAAC,CAAC,CAAC,GAAG;MACnF;MACA;IACF,KAAKlJ,kBAAkB,CAAC8J,cAAc;MACpC;MACA,IAAI,CAACnK,OAAO,CAACgH,IAAI,CAAC,EAAE;QAClB,MAAM,IAAI/G,cAAc,CACtB,0EACF,CAAC;MACH;MACA;MACAkC,MAAM,GAAG6E,IAAI,CAAC7E,MAAM;MACpBgR,gBAAgB,GAAG,GAAGvQ,KAAK,GAAG;MAC9B,KAAK,IAAI8F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGvG,MAAM,EAAE,EAAEuG,CAAC,EAAE;QAC/ByK,gBAAgB,IAAInM,IAAI,CAAC0B,CAAC,CAAC;QAC3B,IAAIA,CAAC,GAAGvG,MAAM,GAAG,CAAC,EAAE;UAClBgR,gBAAgB,IAAI,IAAI;QAC1B;MACF;MACAA,gBAAgB,IAAI,GAAG;MACvB,OAAOA,gBAAgB;IACzB,KAAK9S,kBAAkB,CAACmK,aAAa;MACnC,MAAM,IAAIrK,YAAY,CACpB,uEACF,CAAC;IACH,KAAKE,kBAAkB,CAACgL,iBAAiB;MACvC,OAAO/K,UAAU,CAAC2S,aAAa;IACjC,KAAK5S,kBAAkB,CAAC4K,gBAAgB;MACtC,IAAIrI,KAAK,KAAK,sBAAsB,EAAE;QACpC,OAAOA,KAAK;MACd;EACJ;AACF,CAAC;AAED8E,IAAI,CAACpG,SAAS,CAACkC,YAAY,GAAG,UAAUC,SAAS,EAAEqP,MAAM,EAAE;EACzD,IAAIzQ,KAAK;EACT,IAAIF,MAAM;EACV,IAAIuG,CAAC;EAEL,MAAMf,IAAI,GAAG,IAAI,CAACC,KAAK;EACvB,MAAMhF,KAAK,GAAG,IAAI,CAACiF,MAAM;EAEzB,IAAI7H,OAAO,CAAC,IAAI,CAAC8H,KAAK,CAAC,EAAE;IACvB,IAAIoC,KAAK,CAACgJ,OAAO,CAAC,IAAI,CAACpL,KAAK,CAAC,EAAE;MAC7B;MACAzF,KAAK,GAAG,IAAI,CAACyF,KAAK;MAClB3F,MAAM,GAAGE,KAAK,CAACF,MAAM;MACrB,KAAKuG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGvG,MAAM,EAAE,EAAEuG,CAAC,EAAE;QAC3BrG,KAAK,CAACqG,CAAC,CAAC,CAAClF,YAAY,CAACC,SAAS,EAAE,IAAI,CAAC;MACxC;IACF,CAAC,MAAM;MACL,IAAI,CAACqE,KAAK,CAACtE,YAAY,CAACC,SAAS,EAAE,IAAI,CAAC;IAC1C;EACF;EAEA,IAAIzD,OAAO,CAAC,IAAI,CAAC+H,MAAM,CAAC,EAAE;IACxB,IAAI,CAACA,MAAM,CAACvE,YAAY,CAACC,SAAS,EAAE,IAAI,CAAC;EAC3C;EAEA,IAAIzD,OAAO,CAAC,IAAI,CAACgI,KAAK,CAAC,EAAE;IACvB,IAAI,CAACA,KAAK,CAACxE,YAAY,CAACC,SAAS,EAAE,IAAI,CAAC;EAC1C;EAEA,IAAIyG,KAAK,CAACgJ,OAAO,CAAC,IAAI,CAACrL,MAAM,CAAC,EAAE;IAC9B;IACAxF,KAAK,GAAG,IAAI,CAACwF,MAAM;IACnB1F,MAAM,GAAGE,KAAK,CAACF,MAAM;IACrB,KAAKuG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGvG,MAAM,EAAE,EAAEuG,CAAC,EAAE;MAC3BrG,KAAK,CAACqG,CAAC,CAAC,CAAClF,YAAY,CAACC,SAAS,EAAE,IAAI,CAAC;IACxC;EACF;EAEA,IAAI8M,KAAK;EACT,QAAQ5I,IAAI;IACV,KAAKtH,kBAAkB,CAAC6K,QAAQ;MAC9B,IAAI,CAAC0F,YAAY,CAAC,IAAI,CAAC,EAAE;QACvBnN,SAAS,CAACrB,IAAI,CAACQ,KAAK,CAAC;MACvB;MACA;IACF,KAAKvC,kBAAkB,CAAC+I,kBAAkB;MACxCmH,KAAK,GAAGvM,aAAa,CAACwM,IAAI,CAAC5N,KAAK,CAAC;MACjC,OAAO2N,KAAK,KAAK,IAAI,EAAE;QACrB9M,SAAS,CAACrB,IAAI,CAACmO,KAAK,CAAC,CAAC,CAAC,CAAC;QACxBA,KAAK,GAAGvM,aAAa,CAACwM,IAAI,CAAC5N,KAAK,CAAC;MACnC;MACA;IACF,KAAKvC,kBAAkB,CAACgJ,cAAc;MACpC,IACErJ,OAAO,CAAC8S,MAAM,CAAC,IACfA,MAAM,CAAClL,KAAK,KAAKvH,kBAAkB,CAAC0L,MAAM,IAC1C6E,YAAY,CAACkC,MAAM,CAAChL,KAAK,CAAC,EAC1B;QACArE,SAAS,CAACrB,IAAI,CAACQ,KAAK,CAAC;MACvB;MACA;EACJ;AACF,CAAC;AAED,eAAetC,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}