{"ast":null,"code":"import { isAlphaNumericOrMarkChar, isValidEmailLocalPartSpecialChar } from '../char-utils';\nimport { isKnownTld } from './uri-utils';\n/**\n * A regular expression to match a 'mailto:' prefix on an email address.\n */\nexport var mailtoSchemePrefixRe = /^mailto:/i;\n/**\n * Determines if the given character may start the \"local part\" of an email\n * address. The local part is the part to the left of the '@' sign.\n *\n * Technically according to the email spec, any of the characters in the\n * {@link emailLocalPartCharRegex} can start an email address (including any of\n * the special characters), but this is so rare in the wild and the\n * implementation is much simpler by only starting an email address with a word\n * character. This is especially important when matching the '{' character which\n * generally starts a brace that isn't part of the email address.\n */\nexport var isEmailLocalPartStartChar = isAlphaNumericOrMarkChar; // alias for clarity\n/**\n * Determines if the given character can be part of the \"local part\" of an email\n * address. The local part is the part to the left of the '@' sign.\n *\n * Checking for an email address's start char is handled with {@link #isEmailLocalPartStartChar}\n */\nexport function isEmailLocalPartChar(charCode) {\n  return isEmailLocalPartStartChar(charCode) || isValidEmailLocalPartSpecialChar(charCode);\n}\n/**\n * Determines if the given email address is valid. We consider it valid if it\n * has a valid TLD in its host.\n *\n * @param emailAddress email address\n * @return true is email have valid TLD, false otherwise\n */\nexport function isValidEmail(emailAddress) {\n  var emailAddressTld = emailAddress.split('.').pop(); // as long as we have a valid string (as opposed to null or undefined), we will always get at least one element in the .split('.') array\n  return isKnownTld(emailAddressTld);\n}","map":{"version":3,"names":["isAlphaNumericOrMarkChar","isValidEmailLocalPartSpecialChar","isKnownTld","mailtoSchemePrefixRe","isEmailLocalPartStartChar","isEmailLocalPartChar","charCode","isValidEmail","emailAddress","emailAddressTld","split","pop"],"sources":["../../../src/parser/email-utils.ts"],"sourcesContent":["import { isAlphaNumericOrMarkChar, isValidEmailLocalPartSpecialChar } from '../char-utils';\nimport { isKnownTld } from './uri-utils';\n\n/**\n * A regular expression to match a 'mailto:' prefix on an email address.\n */\nexport const mailtoSchemePrefixRe = /^mailto:/i;\n\n/**\n * Determines if the given character may start the \"local part\" of an email\n * address. The local part is the part to the left of the '@' sign.\n *\n * Technically according to the email spec, any of the characters in the\n * {@link emailLocalPartCharRegex} can start an email address (including any of\n * the special characters), but this is so rare in the wild and the\n * implementation is much simpler by only starting an email address with a word\n * character. This is especially important when matching the '{' character which\n * generally starts a brace that isn't part of the email address.\n */\nexport const isEmailLocalPartStartChar = isAlphaNumericOrMarkChar; // alias for clarity\n\n/**\n * Determines if the given character can be part of the \"local part\" of an email\n * address. The local part is the part to the left of the '@' sign.\n *\n * Checking for an email address's start char is handled with {@link #isEmailLocalPartStartChar}\n */\nexport function isEmailLocalPartChar(charCode: number): boolean {\n    return isEmailLocalPartStartChar(charCode) || isValidEmailLocalPartSpecialChar(charCode);\n}\n\n/**\n * Determines if the given email address is valid. We consider it valid if it\n * has a valid TLD in its host.\n *\n * @param emailAddress email address\n * @return true is email have valid TLD, false otherwise\n */\nexport function isValidEmail(emailAddress: string): boolean {\n    const emailAddressTld: string = emailAddress.split('.').pop()!; // as long as we have a valid string (as opposed to null or undefined), we will always get at least one element in the .split('.') array\n\n    return isKnownTld(emailAddressTld);\n}\n"],"mappings":"AAAA,SAASA,wBAAwB,EAAEC,gCAAgC,QAAQ,eAAe;AAC1F,SAASC,UAAU,QAAQ,aAAa;AAExC;;;AAGA,OAAO,IAAMC,oBAAoB,GAAG,WAAW;AAE/C;;;;;;;;;;;AAWA,OAAO,IAAMC,yBAAyB,GAAGJ,wBAAwB,CAAC,CAAC;AAEnE;;;;;;AAMA,OAAM,SAAUK,oBAAoBA,CAACC,QAAgB;EACjD,OAAOF,yBAAyB,CAACE,QAAQ,CAAC,IAAIL,gCAAgC,CAACK,QAAQ,CAAC;AAC5F;AAEA;;;;;;;AAOA,OAAM,SAAUC,YAAYA,CAACC,YAAoB;EAC7C,IAAMC,eAAe,GAAWD,YAAY,CAACE,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,EAAG,CAAC,CAAC;EAEhE,OAAOT,UAAU,CAACO,eAAe,CAAC;AACtC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}