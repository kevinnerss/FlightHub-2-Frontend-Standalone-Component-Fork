{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport Frozen from \"../../Core/Frozen.js\";\nimport defined from \"../../Core/defined.js\";\nimport Ellipsoid from \"../../Core/Ellipsoid.js\";\nimport IndexDatatype from \"../../Core/IndexDatatype.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\nimport Transforms from \"../../Core/Transforms.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport JsonMetadataTable from \"../JsonMetadataTable.js\";\nimport MetadataSchema from \"../MetadataSchema.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport PropertyTable from \"../PropertyTable.js\";\nimport ResourceLoader from \"../ResourceLoader.js\";\nimport StructuralMetadata from \"../StructuralMetadata.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport addAllToArray from \"../../Core/addAllToArray.js\";\n\n/**\n * Loads a GeoJson model as part of the <code>MAXAR_content_geojson</code> extension with the following constraints:\n * <ul>\n *   <li>The top level GeoJSON type must be FeatureCollection or Feature.</li>\n *   <li>The geometry types must be LineString, MultiLineString, MultiPolygon, Polygon, MultiPoint, or Point.</li>\n *   <li>Polygon and polyline geometries are converted to geodesic lines.</li>\n *   <li>Only WGS84 geographic coordinates are supported.</li>\n * </ul>\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GeoJsonLoader\n * @constructor\n * @augments ResourceLoader\n * @private\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.geoJson The GeoJson object.\n */\nfunction GeoJsonLoader(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.geoJson\", options.geoJson);\n  //>>includeEnd('debug');\n\n  this._geoJson = options.geoJson;\n  this._components = undefined;\n}\nif (defined(Object.create)) {\n  GeoJsonLoader.prototype = Object.create(ResourceLoader.prototype);\n  GeoJsonLoader.prototype.constructor = GeoJsonLoader;\n}\nObject.defineProperties(GeoJsonLoader.prototype, {\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GeoJsonLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return undefined;\n    }\n  },\n  /**\n   * The loaded components.\n   *\n   * @memberof GeoJsonLoader.prototype\n   *\n   * @type {ModelComponents.Components}\n   * @readonly\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    }\n  }\n});\n\n/**\n * Loads the resource.\n * @returns {Promise<GeoJsonLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGeoJsonLoader.prototype.load = function () {\n  return Promise.resolve(this);\n};\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGeoJsonLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (defined(this._components)) {\n    return true;\n  }\n  this._components = parse(this._geoJson, frameState);\n  this._geoJson = undefined;\n  return true;\n};\nfunction ParsedFeature() {\n  this.lines = undefined;\n  this.points = undefined;\n  this.properties = undefined;\n}\nfunction ParseResult() {\n  this.features = [];\n}\nfunction parsePosition(position) {\n  const x = position[0];\n  const y = position[1];\n  const z = position[2] ?? 0.0;\n  return new Cartesian3(x, y, z);\n}\nfunction parseLineString(coordinates) {\n  const positionsLength = coordinates.length;\n  const line = new Array(positionsLength);\n  for (let i = 0; i < positionsLength; i++) {\n    line[i] = parsePosition(coordinates[i]);\n  }\n  const lines = [line];\n  return lines;\n}\nfunction parseMultiLineString(coordinates) {\n  const linesLength = coordinates.length;\n  const lines = new Array(linesLength);\n  for (let i = 0; i < linesLength; i++) {\n    lines[i] = parseLineString(coordinates[i])[0];\n  }\n  return lines;\n}\nfunction parsePolygon(coordinates) {\n  // Treat exterior polygon and interior polygons as lines\n  const linesLength = coordinates.length;\n  const lines = new Array(linesLength);\n  for (let i = 0; i < linesLength; i++) {\n    lines[i] = parseLineString(coordinates[i])[0];\n  }\n  return lines;\n}\nfunction parseMultiPolygon(coordinates) {\n  const polygonsLength = coordinates.length;\n  const lines = [];\n  for (let i = 0; i < polygonsLength; i++) {\n    const polygon = parsePolygon(coordinates[i]);\n    addAllToArray(lines, polygon);\n  }\n  return lines;\n}\nfunction parsePoint(coordinates) {\n  return [parsePosition(coordinates)];\n}\nfunction parseMultiPoint(coordinates) {\n  const pointsLength = coordinates.length;\n  const points = new Array(pointsLength);\n  for (let i = 0; i < pointsLength; i++) {\n    points[i] = parsePosition(coordinates[i]);\n  }\n  return points;\n}\nconst geometryTypes = {\n  LineString: parseLineString,\n  MultiLineString: parseMultiLineString,\n  MultiPolygon: parseMultiPolygon,\n  Polygon: parsePolygon,\n  MultiPoint: parseMultiPoint,\n  Point: parsePoint\n};\nconst primitiveTypes = {\n  LineString: PrimitiveType.LINES,\n  MultiLineString: PrimitiveType.LINES,\n  MultiPolygon: PrimitiveType.LINES,\n  Polygon: PrimitiveType.LINES,\n  MultiPoint: PrimitiveType.POINTS,\n  Point: PrimitiveType.POINTS\n};\nfunction parseFeature(feature, result) {\n  if (!defined(feature.geometry)) {\n    return;\n  }\n  const geometryType = feature.geometry.type;\n  const geometryFunction = geometryTypes[geometryType];\n  const primitiveType = primitiveTypes[geometryType];\n  const coordinates = feature.geometry.coordinates;\n  if (!defined(geometryFunction)) {\n    return;\n  }\n  if (!defined(coordinates)) {\n    return;\n  }\n  const parsedFeature = new ParsedFeature();\n  if (primitiveType === PrimitiveType.LINES) {\n    parsedFeature.lines = geometryFunction(coordinates);\n  } else if (primitiveType === PrimitiveType.POINTS) {\n    parsedFeature.points = geometryFunction(coordinates);\n  }\n  parsedFeature.properties = feature.properties;\n  result.features.push(parsedFeature);\n}\nfunction parseFeatureCollection(featureCollection, result) {\n  const features = featureCollection.features;\n  const featuresLength = features.length;\n  for (let i = 0; i < featuresLength; i++) {\n    parseFeature(features[i], result);\n  }\n}\nconst geoJsonObjectTypes = {\n  FeatureCollection: parseFeatureCollection,\n  Feature: parseFeature\n};\nconst scratchCartesian = new Cartesian3();\nfunction createLinesPrimitive(features, toLocal, frameState) {\n  // Count the number of vertices and indices\n  let vertexCount = 0;\n  let indexCount = 0;\n  const featureCount = features.length;\n  for (let i = 0; i < featureCount; i++) {\n    const feature = features[i];\n    if (defined(feature.lines)) {\n      const linesLength = feature.lines.length;\n      for (let j = 0; j < linesLength; j++) {\n        const line = feature.lines[j];\n        vertexCount += line.length;\n        indexCount += (line.length - 1) * 2;\n      }\n    }\n  }\n\n  // Allocate typed arrays\n  const positionsTypedArray = new Float32Array(vertexCount * 3);\n  const featureIdsTypedArray = new Float32Array(vertexCount);\n  const indicesTypedArray = IndexDatatype.createTypedArray(vertexCount, indexCount);\n  const indexDatatype = IndexDatatype.fromTypedArray(indicesTypedArray);\n\n  // Process the data. Convert positions to local ENU. Generate indices.\n  const localMin = new Cartesian3(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n  const localMax = new Cartesian3(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);\n  let vertexCounter = 0;\n  let segmentCounter = 0;\n  for (let i = 0; i < featureCount; i++) {\n    const feature = features[i];\n    if (!defined(feature.lines)) {\n      continue;\n    }\n    const linesLength = feature.lines.length;\n    for (let j = 0; j < linesLength; j++) {\n      const line = feature.lines[j];\n      const positionsLength = line.length;\n      for (let k = 0; k < positionsLength; k++) {\n        const cartographic = line[k];\n        const globalCartesian = Cartesian3.fromDegrees(cartographic.x, cartographic.y, cartographic.z, Ellipsoid.WGS84, scratchCartesian);\n        const localCartesian = Matrix4.multiplyByPoint(toLocal, globalCartesian, scratchCartesian);\n        Cartesian3.minimumByComponent(localMin, localCartesian, localMin);\n        Cartesian3.maximumByComponent(localMax, localCartesian, localMax);\n        Cartesian3.pack(localCartesian, positionsTypedArray, vertexCounter * 3);\n        featureIdsTypedArray[vertexCounter] = i;\n        if (k < positionsLength - 1) {\n          indicesTypedArray[segmentCounter * 2] = vertexCounter;\n          indicesTypedArray[segmentCounter * 2 + 1] = vertexCounter + 1;\n          segmentCounter++;\n        }\n        vertexCounter++;\n      }\n    }\n  }\n\n  // Create GPU buffers\n  const positionBuffer = Buffer.createVertexBuffer({\n    typedArray: positionsTypedArray,\n    context: frameState.context,\n    usage: BufferUsage.STATIC_DRAW\n  });\n  positionBuffer.vertexArrayDestroyable = false;\n  const featureIdBuffer = Buffer.createVertexBuffer({\n    typedArray: featureIdsTypedArray,\n    context: frameState.context,\n    usage: BufferUsage.STATIC_DRAW\n  });\n  featureIdBuffer.vertexArrayDestroyable = false;\n  const indexBuffer = Buffer.createIndexBuffer({\n    typedArray: indicesTypedArray,\n    context: frameState.context,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: indexDatatype\n  });\n  indexBuffer.vertexArrayDestroyable = false;\n\n  // Create ModelComponents\n  const positionAttribute = new ModelComponents.Attribute();\n  positionAttribute.semantic = VertexAttributeSemantic.POSITION;\n  positionAttribute.componentDatatype = ComponentDatatype.FLOAT;\n  positionAttribute.type = AttributeType.VEC3;\n  positionAttribute.count = vertexCount;\n  positionAttribute.min = localMin;\n  positionAttribute.max = localMax;\n  positionAttribute.buffer = positionBuffer;\n  const featureIdAttribute = new ModelComponents.Attribute();\n  featureIdAttribute.semantic = VertexAttributeSemantic.FEATURE_ID;\n  featureIdAttribute.setIndex = 0;\n  featureIdAttribute.componentDatatype = ComponentDatatype.FLOAT;\n  featureIdAttribute.type = AttributeType.SCALAR;\n  featureIdAttribute.count = vertexCount;\n  featureIdAttribute.buffer = featureIdBuffer;\n  const attributes = [positionAttribute, featureIdAttribute];\n  const material = new ModelComponents.Material();\n  material.unlit = true;\n  const indices = new ModelComponents.Indices();\n  indices.indexDatatype = indexDatatype;\n  indices.count = indicesTypedArray.length;\n  indices.buffer = indexBuffer;\n  const featureId = new ModelComponents.FeatureIdAttribute();\n  featureId.featureCount = featureCount;\n  featureId.propertyTableId = 0;\n  featureId.setIndex = 0;\n  featureId.positionalLabel = \"featureId_0\";\n  const featureIds = [featureId];\n  const primitive = new ModelComponents.Primitive();\n  primitive.attributes = attributes;\n  primitive.indices = indices;\n  primitive.featureIds = featureIds;\n  primitive.primitiveType = PrimitiveType.LINES;\n  primitive.material = material;\n  return primitive;\n}\nfunction createPointsPrimitive(features, toLocal, frameState) {\n  // Count the number of vertices\n  let vertexCount = 0;\n  const featureCount = features.length;\n  for (let i = 0; i < featureCount; i++) {\n    const feature = features[i];\n    if (defined(feature.points)) {\n      vertexCount += feature.points.length;\n    }\n  }\n\n  // Allocate typed arrays\n  const positionsTypedArray = new Float32Array(vertexCount * 3);\n  const featureIdsTypedArray = new Float32Array(vertexCount);\n\n  // Process the data. Convert positions to local ENU.\n  const localMin = new Cartesian3(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n  const localMax = new Cartesian3(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);\n  let vertexCounter = 0;\n  for (let i = 0; i < featureCount; i++) {\n    const feature = features[i];\n    if (!defined(feature.points)) {\n      continue;\n    }\n    const pointsLength = feature.points.length;\n    for (let j = 0; j < pointsLength; j++) {\n      const cartographic = feature.points[j];\n      const globalCartesian = Cartesian3.fromDegrees(cartographic.x, cartographic.y, cartographic.z, Ellipsoid.WGS84, scratchCartesian);\n      const localCartesian = Matrix4.multiplyByPoint(toLocal, globalCartesian, scratchCartesian);\n      Cartesian3.minimumByComponent(localMin, localCartesian, localMin);\n      Cartesian3.maximumByComponent(localMax, localCartesian, localMax);\n      Cartesian3.pack(localCartesian, positionsTypedArray, vertexCounter * 3);\n      featureIdsTypedArray[vertexCounter] = i;\n      vertexCounter++;\n    }\n  }\n\n  // Create GPU buffers\n  const positionBuffer = Buffer.createVertexBuffer({\n    typedArray: positionsTypedArray,\n    context: frameState.context,\n    usage: BufferUsage.STATIC_DRAW\n  });\n  positionBuffer.vertexArrayDestroyable = false;\n  const featureIdBuffer = Buffer.createVertexBuffer({\n    typedArray: featureIdsTypedArray,\n    context: frameState.context,\n    usage: BufferUsage.STATIC_DRAW\n  });\n  featureIdBuffer.vertexArrayDestroyable = false;\n\n  // Create ModelComponents\n  const positionAttribute = new ModelComponents.Attribute();\n  positionAttribute.semantic = VertexAttributeSemantic.POSITION;\n  positionAttribute.componentDatatype = ComponentDatatype.FLOAT;\n  positionAttribute.type = AttributeType.VEC3;\n  positionAttribute.count = vertexCount;\n  positionAttribute.min = localMin;\n  positionAttribute.max = localMax;\n  positionAttribute.buffer = positionBuffer;\n  const featureIdAttribute = new ModelComponents.Attribute();\n  featureIdAttribute.semantic = VertexAttributeSemantic.FEATURE_ID;\n  featureIdAttribute.setIndex = 0;\n  featureIdAttribute.componentDatatype = ComponentDatatype.FLOAT;\n  featureIdAttribute.type = AttributeType.SCALAR;\n  featureIdAttribute.count = vertexCount;\n  featureIdAttribute.buffer = featureIdBuffer;\n  const attributes = [positionAttribute, featureIdAttribute];\n  const material = new ModelComponents.Material();\n  material.unlit = true;\n  const featureId = new ModelComponents.FeatureIdAttribute();\n  featureId.featureCount = featureCount;\n  featureId.propertyTableId = 0;\n  featureId.setIndex = 0;\n  featureId.positionalLabel = \"featureId_0\";\n  const featureIds = [featureId];\n  const primitive = new ModelComponents.Primitive();\n  primitive.attributes = attributes;\n  primitive.featureIds = featureIds;\n  primitive.primitiveType = PrimitiveType.POINTS;\n  primitive.material = material;\n  return primitive;\n}\nfunction parse(geoJson, frameState) {\n  const result = new ParseResult();\n\n  // Parse the GeoJSON\n  const parseFunction = geoJsonObjectTypes[geoJson.type];\n  if (defined(parseFunction)) {\n    parseFunction(geoJson, result);\n  }\n  const features = result.features;\n  const featureCount = features.length;\n  if (featureCount === 0) {\n    throw new RuntimeError(\"GeoJSON must have at least one feature\");\n  }\n\n  // Allocate space for property values\n  const properties = {};\n  for (let i = 0; i < featureCount; i++) {\n    const feature = features[i];\n    const featureProperties = feature.properties ?? Frozen.EMPTY_OBJECT;\n    for (const propertyId in featureProperties) {\n      if (featureProperties.hasOwnProperty(propertyId)) {\n        if (!defined(properties[propertyId])) {\n          properties[propertyId] = new Array(featureCount);\n        }\n      }\n    }\n  }\n\n  // Fill in the property values. Default to empty string for undefined values.\n  for (let i = 0; i < featureCount; i++) {\n    const feature = features[i];\n    for (const propertyId in properties) {\n      if (properties.hasOwnProperty(propertyId)) {\n        const value = feature.properties[propertyId] ?? \"\";\n        properties[propertyId][i] = value;\n      }\n    }\n  }\n  const jsonMetadataTable = new JsonMetadataTable({\n    count: featureCount,\n    properties: properties\n  });\n  const propertyTable = new PropertyTable({\n    id: 0,\n    count: featureCount,\n    jsonMetadataTable: jsonMetadataTable\n  });\n  const propertyTables = [propertyTable];\n  const schema = MetadataSchema.fromJson({});\n  const structuralMetadata = new StructuralMetadata({\n    schema: schema,\n    propertyTables: propertyTables\n  });\n\n  // Find the cartographic bounding box\n  const cartographicMin = new Cartesian3(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n  const cartographicMax = new Cartesian3(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);\n  let hasLines = false;\n  let hasPoints = false;\n  for (let i = 0; i < featureCount; i++) {\n    const feature = features[i];\n    if (defined(feature.lines)) {\n      hasLines = true;\n      const linesLength = feature.lines.length;\n      for (let j = 0; j < linesLength; j++) {\n        const line = feature.lines[j];\n        const positionsLength = line.length;\n        for (let k = 0; k < positionsLength; k++) {\n          Cartesian3.minimumByComponent(cartographicMin, line[k], cartographicMin);\n          Cartesian3.maximumByComponent(cartographicMax, line[k], cartographicMax);\n        }\n      }\n    }\n    if (defined(feature.points)) {\n      hasPoints = true;\n      const pointsLength = feature.points.length;\n      for (let j = 0; j < pointsLength; j++) {\n        const point = feature.points[j];\n        Cartesian3.minimumByComponent(cartographicMin, point, cartographicMin);\n        Cartesian3.maximumByComponent(cartographicMax, point, cartographicMax);\n      }\n    }\n  }\n\n  // Compute the ENU matrix\n  const cartographicCenter = Cartesian3.midpoint(cartographicMin, cartographicMax, new Cartesian3());\n  const ecefCenter = Cartesian3.fromDegrees(cartographicCenter.x, cartographicCenter.y, cartographicCenter.z, Ellipsoid.WGS84, new Cartesian3());\n  const toGlobal = Transforms.eastNorthUpToFixedFrame(ecefCenter, Ellipsoid.WGS84, new Matrix4());\n  const toLocal = Matrix4.inverseTransformation(toGlobal, new Matrix4());\n  const primitives = [];\n  if (hasLines) {\n    primitives.push(createLinesPrimitive(features, toLocal, frameState));\n  }\n  if (hasPoints) {\n    primitives.push(createPointsPrimitive(features, toLocal, frameState));\n  }\n  const node = new ModelComponents.Node();\n  node.index = 0;\n  node.primitives = primitives;\n  const nodes = [node];\n  const scene = new ModelComponents.Scene();\n  scene.nodes = nodes;\n  const components = new ModelComponents.Components();\n  components.scene = scene;\n  components.nodes = nodes;\n  components.transform = toGlobal;\n  components.structuralMetadata = structuralMetadata;\n  return components;\n}\n\n/**\n * Unloads the resource.\n * @private\n */\nGeoJsonLoader.prototype.unload = function () {\n  this._components = undefined;\n};\nexport default GeoJsonLoader;","map":{"version":3,"names":["Cartesian3","Check","ComponentDatatype","Frozen","defined","Ellipsoid","IndexDatatype","Matrix4","PrimitiveType","RuntimeError","Transforms","AttributeType","JsonMetadataTable","MetadataSchema","ModelComponents","PropertyTable","ResourceLoader","StructuralMetadata","VertexAttributeSemantic","Buffer","BufferUsage","addAllToArray","GeoJsonLoader","options","EMPTY_OBJECT","typeOf","object","geoJson","_geoJson","_components","undefined","Object","create","prototype","constructor","defineProperties","cacheKey","get","components","load","Promise","resolve","process","frameState","parse","ParsedFeature","lines","points","properties","ParseResult","features","parsePosition","position","x","y","z","parseLineString","coordinates","positionsLength","length","line","Array","i","parseMultiLineString","linesLength","parsePolygon","parseMultiPolygon","polygonsLength","polygon","parsePoint","parseMultiPoint","pointsLength","geometryTypes","LineString","MultiLineString","MultiPolygon","Polygon","MultiPoint","Point","primitiveTypes","LINES","POINTS","parseFeature","feature","result","geometry","geometryType","type","geometryFunction","primitiveType","parsedFeature","push","parseFeatureCollection","featureCollection","featuresLength","geoJsonObjectTypes","FeatureCollection","Feature","scratchCartesian","createLinesPrimitive","toLocal","vertexCount","indexCount","featureCount","j","positionsTypedArray","Float32Array","featureIdsTypedArray","indicesTypedArray","createTypedArray","indexDatatype","fromTypedArray","localMin","Number","POSITIVE_INFINITY","localMax","NEGATIVE_INFINITY","vertexCounter","segmentCounter","k","cartographic","globalCartesian","fromDegrees","WGS84","localCartesian","multiplyByPoint","minimumByComponent","maximumByComponent","pack","positionBuffer","createVertexBuffer","typedArray","context","usage","STATIC_DRAW","vertexArrayDestroyable","featureIdBuffer","indexBuffer","createIndexBuffer","positionAttribute","Attribute","semantic","POSITION","componentDatatype","FLOAT","VEC3","count","min","max","buffer","featureIdAttribute","FEATURE_ID","setIndex","SCALAR","attributes","material","Material","unlit","indices","Indices","featureId","FeatureIdAttribute","propertyTableId","positionalLabel","featureIds","primitive","Primitive","createPointsPrimitive","parseFunction","featureProperties","propertyId","hasOwnProperty","value","jsonMetadataTable","propertyTable","id","propertyTables","schema","fromJson","structuralMetadata","cartographicMin","cartographicMax","hasLines","hasPoints","point","cartographicCenter","midpoint","ecefCenter","toGlobal","eastNorthUpToFixedFrame","inverseTransformation","primitives","node","Node","index","nodes","scene","Scene","Components","transform","unload"],"sources":["D:/projects/FlightHub-2-Frontend-Standalone-Component/frontend/node_modules/@cesium/engine/Source/Scene/Model/GeoJsonLoader.js"],"sourcesContent":["import Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport Frozen from \"../../Core/Frozen.js\";\nimport defined from \"../../Core/defined.js\";\nimport Ellipsoid from \"../../Core/Ellipsoid.js\";\nimport IndexDatatype from \"../../Core/IndexDatatype.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\nimport Transforms from \"../../Core/Transforms.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport JsonMetadataTable from \"../JsonMetadataTable.js\";\nimport MetadataSchema from \"../MetadataSchema.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport PropertyTable from \"../PropertyTable.js\";\nimport ResourceLoader from \"../ResourceLoader.js\";\nimport StructuralMetadata from \"../StructuralMetadata.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport addAllToArray from \"../../Core/addAllToArray.js\";\n\n/**\n * Loads a GeoJson model as part of the <code>MAXAR_content_geojson</code> extension with the following constraints:\n * <ul>\n *   <li>The top level GeoJSON type must be FeatureCollection or Feature.</li>\n *   <li>The geometry types must be LineString, MultiLineString, MultiPolygon, Polygon, MultiPoint, or Point.</li>\n *   <li>Polygon and polyline geometries are converted to geodesic lines.</li>\n *   <li>Only WGS84 geographic coordinates are supported.</li>\n * </ul>\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GeoJsonLoader\n * @constructor\n * @augments ResourceLoader\n * @private\n *\n * @param {object} options Object with the following properties:\n * @param {object} options.geoJson The GeoJson object.\n */\nfunction GeoJsonLoader(options) {\n  options = options ?? Frozen.EMPTY_OBJECT;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.geoJson\", options.geoJson);\n  //>>includeEnd('debug');\n\n  this._geoJson = options.geoJson;\n  this._components = undefined;\n}\n\nif (defined(Object.create)) {\n  GeoJsonLoader.prototype = Object.create(ResourceLoader.prototype);\n  GeoJsonLoader.prototype.constructor = GeoJsonLoader;\n}\n\nObject.defineProperties(GeoJsonLoader.prototype, {\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GeoJsonLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return undefined;\n    },\n  },\n  /**\n   * The loaded components.\n   *\n   * @memberof GeoJsonLoader.prototype\n   *\n   * @type {ModelComponents.Components}\n   * @readonly\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    },\n  },\n});\n\n/**\n * Loads the resource.\n * @returns {Promise<GeoJsonLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGeoJsonLoader.prototype.load = function () {\n  return Promise.resolve(this);\n};\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGeoJsonLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (defined(this._components)) {\n    return true;\n  }\n\n  this._components = parse(this._geoJson, frameState);\n  this._geoJson = undefined;\n  return true;\n};\n\nfunction ParsedFeature() {\n  this.lines = undefined;\n  this.points = undefined;\n  this.properties = undefined;\n}\n\nfunction ParseResult() {\n  this.features = [];\n}\n\nfunction parsePosition(position) {\n  const x = position[0];\n  const y = position[1];\n  const z = position[2] ?? 0.0;\n  return new Cartesian3(x, y, z);\n}\n\nfunction parseLineString(coordinates) {\n  const positionsLength = coordinates.length;\n  const line = new Array(positionsLength);\n  for (let i = 0; i < positionsLength; i++) {\n    line[i] = parsePosition(coordinates[i]);\n  }\n  const lines = [line];\n  return lines;\n}\n\nfunction parseMultiLineString(coordinates) {\n  const linesLength = coordinates.length;\n  const lines = new Array(linesLength);\n  for (let i = 0; i < linesLength; i++) {\n    lines[i] = parseLineString(coordinates[i])[0];\n  }\n  return lines;\n}\n\nfunction parsePolygon(coordinates) {\n  // Treat exterior polygon and interior polygons as lines\n  const linesLength = coordinates.length;\n  const lines = new Array(linesLength);\n  for (let i = 0; i < linesLength; i++) {\n    lines[i] = parseLineString(coordinates[i])[0];\n  }\n  return lines;\n}\n\nfunction parseMultiPolygon(coordinates) {\n  const polygonsLength = coordinates.length;\n  const lines = [];\n  for (let i = 0; i < polygonsLength; i++) {\n    const polygon = parsePolygon(coordinates[i]);\n    addAllToArray(lines, polygon);\n  }\n  return lines;\n}\n\nfunction parsePoint(coordinates) {\n  return [parsePosition(coordinates)];\n}\n\nfunction parseMultiPoint(coordinates) {\n  const pointsLength = coordinates.length;\n  const points = new Array(pointsLength);\n  for (let i = 0; i < pointsLength; i++) {\n    points[i] = parsePosition(coordinates[i]);\n  }\n  return points;\n}\n\nconst geometryTypes = {\n  LineString: parseLineString,\n  MultiLineString: parseMultiLineString,\n  MultiPolygon: parseMultiPolygon,\n  Polygon: parsePolygon,\n  MultiPoint: parseMultiPoint,\n  Point: parsePoint,\n};\n\nconst primitiveTypes = {\n  LineString: PrimitiveType.LINES,\n  MultiLineString: PrimitiveType.LINES,\n  MultiPolygon: PrimitiveType.LINES,\n  Polygon: PrimitiveType.LINES,\n  MultiPoint: PrimitiveType.POINTS,\n  Point: PrimitiveType.POINTS,\n};\n\nfunction parseFeature(feature, result) {\n  if (!defined(feature.geometry)) {\n    return;\n  }\n\n  const geometryType = feature.geometry.type;\n  const geometryFunction = geometryTypes[geometryType];\n  const primitiveType = primitiveTypes[geometryType];\n  const coordinates = feature.geometry.coordinates;\n\n  if (!defined(geometryFunction)) {\n    return;\n  }\n\n  if (!defined(coordinates)) {\n    return;\n  }\n\n  const parsedFeature = new ParsedFeature();\n\n  if (primitiveType === PrimitiveType.LINES) {\n    parsedFeature.lines = geometryFunction(coordinates);\n  } else if (primitiveType === PrimitiveType.POINTS) {\n    parsedFeature.points = geometryFunction(coordinates);\n  }\n\n  parsedFeature.properties = feature.properties;\n\n  result.features.push(parsedFeature);\n}\n\nfunction parseFeatureCollection(featureCollection, result) {\n  const features = featureCollection.features;\n  const featuresLength = features.length;\n  for (let i = 0; i < featuresLength; i++) {\n    parseFeature(features[i], result);\n  }\n}\n\nconst geoJsonObjectTypes = {\n  FeatureCollection: parseFeatureCollection,\n  Feature: parseFeature,\n};\n\nconst scratchCartesian = new Cartesian3();\n\nfunction createLinesPrimitive(features, toLocal, frameState) {\n  // Count the number of vertices and indices\n  let vertexCount = 0;\n  let indexCount = 0;\n\n  const featureCount = features.length;\n\n  for (let i = 0; i < featureCount; i++) {\n    const feature = features[i];\n    if (defined(feature.lines)) {\n      const linesLength = feature.lines.length;\n      for (let j = 0; j < linesLength; j++) {\n        const line = feature.lines[j];\n        vertexCount += line.length;\n        indexCount += (line.length - 1) * 2;\n      }\n    }\n  }\n\n  // Allocate typed arrays\n  const positionsTypedArray = new Float32Array(vertexCount * 3);\n  const featureIdsTypedArray = new Float32Array(vertexCount);\n  const indicesTypedArray = IndexDatatype.createTypedArray(\n    vertexCount,\n    indexCount,\n  );\n  const indexDatatype = IndexDatatype.fromTypedArray(indicesTypedArray);\n\n  // Process the data. Convert positions to local ENU. Generate indices.\n  const localMin = new Cartesian3(\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n  );\n\n  const localMax = new Cartesian3(\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n  );\n\n  let vertexCounter = 0;\n  let segmentCounter = 0;\n\n  for (let i = 0; i < featureCount; i++) {\n    const feature = features[i];\n\n    if (!defined(feature.lines)) {\n      continue;\n    }\n\n    const linesLength = feature.lines.length;\n    for (let j = 0; j < linesLength; j++) {\n      const line = feature.lines[j];\n      const positionsLength = line.length;\n      for (let k = 0; k < positionsLength; k++) {\n        const cartographic = line[k];\n        const globalCartesian = Cartesian3.fromDegrees(\n          cartographic.x,\n          cartographic.y,\n          cartographic.z,\n          Ellipsoid.WGS84,\n          scratchCartesian,\n        );\n        const localCartesian = Matrix4.multiplyByPoint(\n          toLocal,\n          globalCartesian,\n          scratchCartesian,\n        );\n\n        Cartesian3.minimumByComponent(localMin, localCartesian, localMin);\n        Cartesian3.maximumByComponent(localMax, localCartesian, localMax);\n\n        Cartesian3.pack(localCartesian, positionsTypedArray, vertexCounter * 3);\n\n        featureIdsTypedArray[vertexCounter] = i;\n\n        if (k < positionsLength - 1) {\n          indicesTypedArray[segmentCounter * 2] = vertexCounter;\n          indicesTypedArray[segmentCounter * 2 + 1] = vertexCounter + 1;\n          segmentCounter++;\n        }\n\n        vertexCounter++;\n      }\n    }\n  }\n\n  // Create GPU buffers\n  const positionBuffer = Buffer.createVertexBuffer({\n    typedArray: positionsTypedArray,\n    context: frameState.context,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  positionBuffer.vertexArrayDestroyable = false;\n\n  const featureIdBuffer = Buffer.createVertexBuffer({\n    typedArray: featureIdsTypedArray,\n    context: frameState.context,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  featureIdBuffer.vertexArrayDestroyable = false;\n\n  const indexBuffer = Buffer.createIndexBuffer({\n    typedArray: indicesTypedArray,\n    context: frameState.context,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: indexDatatype,\n  });\n  indexBuffer.vertexArrayDestroyable = false;\n\n  // Create ModelComponents\n  const positionAttribute = new ModelComponents.Attribute();\n  positionAttribute.semantic = VertexAttributeSemantic.POSITION;\n  positionAttribute.componentDatatype = ComponentDatatype.FLOAT;\n  positionAttribute.type = AttributeType.VEC3;\n  positionAttribute.count = vertexCount;\n  positionAttribute.min = localMin;\n  positionAttribute.max = localMax;\n  positionAttribute.buffer = positionBuffer;\n\n  const featureIdAttribute = new ModelComponents.Attribute();\n  featureIdAttribute.semantic = VertexAttributeSemantic.FEATURE_ID;\n  featureIdAttribute.setIndex = 0;\n  featureIdAttribute.componentDatatype = ComponentDatatype.FLOAT;\n  featureIdAttribute.type = AttributeType.SCALAR;\n  featureIdAttribute.count = vertexCount;\n  featureIdAttribute.buffer = featureIdBuffer;\n\n  const attributes = [positionAttribute, featureIdAttribute];\n\n  const material = new ModelComponents.Material();\n  material.unlit = true;\n\n  const indices = new ModelComponents.Indices();\n  indices.indexDatatype = indexDatatype;\n  indices.count = indicesTypedArray.length;\n  indices.buffer = indexBuffer;\n\n  const featureId = new ModelComponents.FeatureIdAttribute();\n  featureId.featureCount = featureCount;\n  featureId.propertyTableId = 0;\n  featureId.setIndex = 0;\n  featureId.positionalLabel = \"featureId_0\";\n\n  const featureIds = [featureId];\n\n  const primitive = new ModelComponents.Primitive();\n  primitive.attributes = attributes;\n  primitive.indices = indices;\n  primitive.featureIds = featureIds;\n  primitive.primitiveType = PrimitiveType.LINES;\n  primitive.material = material;\n\n  return primitive;\n}\n\nfunction createPointsPrimitive(features, toLocal, frameState) {\n  // Count the number of vertices\n  let vertexCount = 0;\n\n  const featureCount = features.length;\n\n  for (let i = 0; i < featureCount; i++) {\n    const feature = features[i];\n    if (defined(feature.points)) {\n      vertexCount += feature.points.length;\n    }\n  }\n\n  // Allocate typed arrays\n  const positionsTypedArray = new Float32Array(vertexCount * 3);\n  const featureIdsTypedArray = new Float32Array(vertexCount);\n\n  // Process the data. Convert positions to local ENU.\n  const localMin = new Cartesian3(\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n  );\n\n  const localMax = new Cartesian3(\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n  );\n\n  let vertexCounter = 0;\n\n  for (let i = 0; i < featureCount; i++) {\n    const feature = features[i];\n\n    if (!defined(feature.points)) {\n      continue;\n    }\n\n    const pointsLength = feature.points.length;\n    for (let j = 0; j < pointsLength; j++) {\n      const cartographic = feature.points[j];\n      const globalCartesian = Cartesian3.fromDegrees(\n        cartographic.x,\n        cartographic.y,\n        cartographic.z,\n        Ellipsoid.WGS84,\n        scratchCartesian,\n      );\n      const localCartesian = Matrix4.multiplyByPoint(\n        toLocal,\n        globalCartesian,\n        scratchCartesian,\n      );\n\n      Cartesian3.minimumByComponent(localMin, localCartesian, localMin);\n      Cartesian3.maximumByComponent(localMax, localCartesian, localMax);\n\n      Cartesian3.pack(localCartesian, positionsTypedArray, vertexCounter * 3);\n\n      featureIdsTypedArray[vertexCounter] = i;\n\n      vertexCounter++;\n    }\n  }\n\n  // Create GPU buffers\n  const positionBuffer = Buffer.createVertexBuffer({\n    typedArray: positionsTypedArray,\n    context: frameState.context,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  positionBuffer.vertexArrayDestroyable = false;\n\n  const featureIdBuffer = Buffer.createVertexBuffer({\n    typedArray: featureIdsTypedArray,\n    context: frameState.context,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  featureIdBuffer.vertexArrayDestroyable = false;\n\n  // Create ModelComponents\n  const positionAttribute = new ModelComponents.Attribute();\n  positionAttribute.semantic = VertexAttributeSemantic.POSITION;\n  positionAttribute.componentDatatype = ComponentDatatype.FLOAT;\n  positionAttribute.type = AttributeType.VEC3;\n  positionAttribute.count = vertexCount;\n  positionAttribute.min = localMin;\n  positionAttribute.max = localMax;\n  positionAttribute.buffer = positionBuffer;\n\n  const featureIdAttribute = new ModelComponents.Attribute();\n  featureIdAttribute.semantic = VertexAttributeSemantic.FEATURE_ID;\n  featureIdAttribute.setIndex = 0;\n  featureIdAttribute.componentDatatype = ComponentDatatype.FLOAT;\n  featureIdAttribute.type = AttributeType.SCALAR;\n  featureIdAttribute.count = vertexCount;\n  featureIdAttribute.buffer = featureIdBuffer;\n\n  const attributes = [positionAttribute, featureIdAttribute];\n\n  const material = new ModelComponents.Material();\n  material.unlit = true;\n\n  const featureId = new ModelComponents.FeatureIdAttribute();\n  featureId.featureCount = featureCount;\n  featureId.propertyTableId = 0;\n  featureId.setIndex = 0;\n  featureId.positionalLabel = \"featureId_0\";\n\n  const featureIds = [featureId];\n\n  const primitive = new ModelComponents.Primitive();\n  primitive.attributes = attributes;\n  primitive.featureIds = featureIds;\n  primitive.primitiveType = PrimitiveType.POINTS;\n  primitive.material = material;\n\n  return primitive;\n}\n\nfunction parse(geoJson, frameState) {\n  const result = new ParseResult();\n\n  // Parse the GeoJSON\n  const parseFunction = geoJsonObjectTypes[geoJson.type];\n  if (defined(parseFunction)) {\n    parseFunction(geoJson, result);\n  }\n\n  const features = result.features;\n  const featureCount = features.length;\n\n  if (featureCount === 0) {\n    throw new RuntimeError(\"GeoJSON must have at least one feature\");\n  }\n\n  // Allocate space for property values\n  const properties = {};\n  for (let i = 0; i < featureCount; i++) {\n    const feature = features[i];\n    const featureProperties = feature.properties ?? Frozen.EMPTY_OBJECT;\n    for (const propertyId in featureProperties) {\n      if (featureProperties.hasOwnProperty(propertyId)) {\n        if (!defined(properties[propertyId])) {\n          properties[propertyId] = new Array(featureCount);\n        }\n      }\n    }\n  }\n\n  // Fill in the property values. Default to empty string for undefined values.\n  for (let i = 0; i < featureCount; i++) {\n    const feature = features[i];\n    for (const propertyId in properties) {\n      if (properties.hasOwnProperty(propertyId)) {\n        const value = feature.properties[propertyId] ?? \"\";\n        properties[propertyId][i] = value;\n      }\n    }\n  }\n\n  const jsonMetadataTable = new JsonMetadataTable({\n    count: featureCount,\n    properties: properties,\n  });\n\n  const propertyTable = new PropertyTable({\n    id: 0,\n    count: featureCount,\n    jsonMetadataTable: jsonMetadataTable,\n  });\n  const propertyTables = [propertyTable];\n\n  const schema = MetadataSchema.fromJson({});\n\n  const structuralMetadata = new StructuralMetadata({\n    schema: schema,\n    propertyTables: propertyTables,\n  });\n\n  // Find the cartographic bounding box\n  const cartographicMin = new Cartesian3(\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n  );\n\n  const cartographicMax = new Cartesian3(\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n  );\n\n  let hasLines = false;\n  let hasPoints = false;\n\n  for (let i = 0; i < featureCount; i++) {\n    const feature = features[i];\n    if (defined(feature.lines)) {\n      hasLines = true;\n      const linesLength = feature.lines.length;\n      for (let j = 0; j < linesLength; j++) {\n        const line = feature.lines[j];\n        const positionsLength = line.length;\n        for (let k = 0; k < positionsLength; k++) {\n          Cartesian3.minimumByComponent(\n            cartographicMin,\n            line[k],\n            cartographicMin,\n          );\n          Cartesian3.maximumByComponent(\n            cartographicMax,\n            line[k],\n            cartographicMax,\n          );\n        }\n      }\n    }\n\n    if (defined(feature.points)) {\n      hasPoints = true;\n      const pointsLength = feature.points.length;\n      for (let j = 0; j < pointsLength; j++) {\n        const point = feature.points[j];\n        Cartesian3.minimumByComponent(cartographicMin, point, cartographicMin);\n        Cartesian3.maximumByComponent(cartographicMax, point, cartographicMax);\n      }\n    }\n  }\n\n  // Compute the ENU matrix\n  const cartographicCenter = Cartesian3.midpoint(\n    cartographicMin,\n    cartographicMax,\n    new Cartesian3(),\n  );\n  const ecefCenter = Cartesian3.fromDegrees(\n    cartographicCenter.x,\n    cartographicCenter.y,\n    cartographicCenter.z,\n    Ellipsoid.WGS84,\n    new Cartesian3(),\n  );\n  const toGlobal = Transforms.eastNorthUpToFixedFrame(\n    ecefCenter,\n    Ellipsoid.WGS84,\n    new Matrix4(),\n  );\n  const toLocal = Matrix4.inverseTransformation(toGlobal, new Matrix4());\n\n  const primitives = [];\n\n  if (hasLines) {\n    primitives.push(createLinesPrimitive(features, toLocal, frameState));\n  }\n\n  if (hasPoints) {\n    primitives.push(createPointsPrimitive(features, toLocal, frameState));\n  }\n\n  const node = new ModelComponents.Node();\n  node.index = 0;\n  node.primitives = primitives;\n\n  const nodes = [node];\n\n  const scene = new ModelComponents.Scene();\n  scene.nodes = nodes;\n\n  const components = new ModelComponents.Components();\n  components.scene = scene;\n  components.nodes = nodes;\n  components.transform = toGlobal;\n  components.structuralMetadata = structuralMetadata;\n\n  return components;\n}\n\n/**\n * Unloads the resource.\n * @private\n */\nGeoJsonLoader.prototype.unload = function () {\n  this._components = undefined;\n};\n\nexport default GeoJsonLoader;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}